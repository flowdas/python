
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>버퍼 프로토콜 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="낡은 버퍼 프로토콜" href="objbuffer.html" />
    <link rel="prev" title="이터레이터 프로토콜" href="iter.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/c-api/buffer.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="objbuffer.html" title="낡은 버퍼 프로토콜"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="iter.html" title="이터레이터 프로토콜"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="abstract.html" accesskey="U">추상 객체 계층</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="buffer-protocol">
<span id="bufferobjects"></span><span id="index-0"></span><h1>버퍼 프로토콜<a class="headerlink" href="#buffer-protocol" title="제목 주소">¶</a></h1>
<p>파이썬에서 사용할 수 있는 어떤 객체는 하부 메모리 배열 또는 <em>버퍼</em>에 대한 액세스를 감쌉니다. 이러한 객체에는 내장 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 와 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, 그리고 <a class="reference internal" href="../library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a>와 같은 일부 확장형이 포함됩니다. 제삼자 라이브러리도 이미지 처리나 수치 해석과 같은 특수한 용도로 자체 형을 정의할 수 있습니다.</p>
<p>이러한 형은 각각 고유의 의미가 있지만, (아마도) 큰 메모리 버퍼에 의해 뒷받침되는 공통된 특징을 공유합니다. 어떤 상황에서는 중간 복사 없이 직접 버퍼에 액세스하는 것이 바람직합니다.</p>
<p>파이썬은 C 수준에서 <a class="reference internal" href="#bufferobjects"><span class="std std-ref">버퍼 프로토콜</span></a> 형식으로 이러한 기능을 제공합니다. 이 프로토콜에는 두 가지 측면이 있습니다:</p>
<ul class="simple" id="index-1">
<li><p>생산자 측에서는, 형이 &quot;버퍼 인터페이스&quot;를 내보낼 수 있는데, 그 형의 객체가 하부 버퍼의 정보를 노출할 수 있게 합니다. 이 인터페이스는 <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">버퍼 객체 구조체</span></a> 절에서 설명됩니다.</p></li>
<li><p>소비자 측에서는, 객체의 원시 하부 데이터에 대한 포인터를 얻기 위해 여러 가지 방법을 사용할 수 있습니다 (예를 들어 메서드 매개 변수).</p></li>
</ul>
<p><a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 와 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>와 같은 간단한 객체는 하부 버퍼를 바이트 지향 형식으로 노출합니다. 다른 형태도 가능합니다; 예를 들어, <a class="reference internal" href="../library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a>에 의해 노출되는 요소는 멀티 바이트 값이 될 수 있습니다.</p>
<p>버퍼 인터페이스의 소비자 예는 파일 객체의 <a class="reference internal" href="../library/io.html#io.BufferedIOBase.write" title="io.BufferedIOBase.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> 메서드입니다: 버퍼 인터페이스를 통해 일련의 바이트를 내보낼 수 있는 모든 객체는 파일에 기록될 수 있습니다. <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>가 전달된 객체의 내부 내용에 대한 읽기 전용 액세스만 필요하지만, <a class="reference internal" href="../library/io.html#io.BufferedIOBase.readinto" title="io.BufferedIOBase.readinto"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readinto()</span></code></a>와 같은 다른 메서드는 인자의 내용에 쓰기 액세스가 필요합니다. 버퍼 인터페이스는 객체가 읽기-쓰기와 읽기 전용 버퍼를 선택적으로 허용하거나 거부할 수 있도록 합니다.</p>
<p>버퍼 인터페이스의 소비자가 대상 객체에 대해 버퍼를 얻는 방법에는 두 가지가 있습니다:</p>
<ul class="simple">
<li><p>올바른 매개 변수로 <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a>를 호출합니다;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y*</span></code>, <code class="docutils literal notranslate"><span class="pre">w*</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">s*</span></code> <a class="reference internal" href="arg.html#arg-parsing"><span class="std std-ref">형식 코드</span></a> 중 하나를 사용하여 <a class="reference internal" href="arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>(또는 그 형제 중 하나)을 호출합니다.</p></li>
</ul>
<p>두 경우 모두, 버퍼가 더는 필요하지 않으면 <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>를 호출해야 합니다. 그렇게 하지 않으면 자원 누수와 같은 다양한 문제가 발생할 수 있습니다.</p>
<div class="section" id="buffer-structure">
<span id="id1"></span><h2>버퍼 구조체<a class="headerlink" href="#buffer-structure" title="제목 주소">¶</a></h2>
<p>버퍼 구조체(또는 단순히 &quot;버퍼&quot;)는 다른 객체의 바이너리 데이터를 파이썬 프로그래머에게 노출하는 방법으로 유용합니다. 또한, 복사 없는(zero-copy) 슬라이싱 메커니즘으로 사용할 수 있습니다. 메모리 블록을 참조하는 능력을 사용해서, 임의의 데이터를 파이썬 프로그래머에게 아주 쉽게 노출할 수 있습니다. 메모리는 C 확장의 큰 상수 배열일 수 있으며, 운영 체제 라이브러리로 전달되기 전에 조작하기 위한 원시 메모리 블록일 수도 있고, 네이티브 인 메모리(in-memory) 형식으로 구조화된 데이터를 전달하는 데 사용될 수도 있습니다.</p>
<p>파이썬 인터프리터가 노출하는 대부분의 데이터형과 달리, 버퍼는 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> 포인터가 아니라 단순한 C 구조체입니다. 이를 통해 매우 간단하게 만들고 복사할 수 있습니다. 버퍼를 감싸는 일반 래퍼가 필요할 때는, <a class="reference internal" href="memoryview.html#memoryview-objects"><span class="std std-ref">메모리 뷰</span></a> 객체를 만들 수 있습니다.</p>
<p>제공하는(exporting) 객체를 작성하는 간단한 지침은 <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">버퍼 객체 구조체</span></a>를 참조하십시오. 버퍼를 얻으려면, <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a>를 참조하십시오.</p>
<dl class="type">
<dt id="c.Py_buffer">
<code class="sig-name descname">Py_buffer</code><a class="headerlink" href="#c.Py_buffer" title="정의 주소">¶</a></dt>
<dd><dl class="member">
<dt id="c.Py_buffer.buf">
void *<code class="sig-name descname">buf</code><a class="headerlink" href="#c.Py_buffer.buf" title="정의 주소">¶</a></dt>
<dd><p>버퍼 필드에 의해 기술된 논리적 구조의 시작을 가리키는 포인터. 이것은 제공자(exporter)의 하부 물리적 메모리 블록 내의 모든 위치일 수 있습니다. 예를 들어, 음의 <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a>를 사용하면 값이 메모리 블록의 끝을 가리킬 수 있습니다.</p>
<p><a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">연속</span></a> 배열의 경우, 값은 메모리 블록의 시작을 가리킵니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.obj">
void *<code class="sig-name descname">obj</code><a class="headerlink" href="#c.Py_buffer.obj" title="정의 주소">¶</a></dt>
<dd><p>제공하는(exporting) 객체에 대한 새 참조. 참조는 소비자가 소유하고, <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>에 의해 자동으로 감소하고 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정됩니다. 이 필드는 표준 C-API 함수의 반환 값과 동등합니다.</p>
<p>특수한 경우로, <a class="reference internal" href="memoryview.html#c.PyMemoryView_FromBuffer" title="PyMemoryView_FromBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMemoryView_FromBuffer()</span></code></a> 나 <a class="reference internal" href="#c.PyBuffer_FillInfo" title="PyBuffer_FillInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_FillInfo()</span></code></a>로 감싸진 <em>임시(temporary)</em> 버퍼의 경우, 이 필드는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>입니다. 일반적으로, 제공하는(exporting) 객체는 이 체계를 사용하지 않아야 합니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.len">
Py_ssize_t <code class="sig-name descname">len</code><a class="headerlink" href="#c.Py_buffer.len" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span></code>. 연속 배열의 경우, 하부 메모리 블록의 길이입니다. 불연속 배열의 경우, 연속 표현으로 복사된다면 논리적 구조체가 갖게 될 길이입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">((char</span> <span class="pre">*)buf)[0]</span> <span class="pre">에서</span> <span class="pre">((char</span> <span class="pre">*)buf)[len-1]</span></code> 범위의 액세스는 연속성을 보장하는 요청으로 버퍼가 확보된 경우에만 유효합니다. 대부분 이러한 요청은 <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_SIMPLE</span></code></a> 또는 <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a>입니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.readonly">
int <code class="sig-name descname">readonly</code><a class="headerlink" href="#c.Py_buffer.readonly" title="정의 주소">¶</a></dt>
<dd><p>버퍼가 읽기 전용인지를 나타내는 표시기입니다. 이 필드는 <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a> 플래그로 제어됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.itemsize">
Py_ssize_t <code class="sig-name descname">itemsize</code><a class="headerlink" href="#c.Py_buffer.itemsize" title="정의 주소">¶</a></dt>
<dd><p>단일 요소의 항목 크기(바이트)입니다. <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아닌 <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-member docutils literal notranslate"><span class="pre">format</span></code></a> 값에 호출된 <a class="reference internal" href="../library/struct.html#struct.calcsize" title="struct.calcsize"><code class="xref py py-func docutils literal notranslate"><span class="pre">struct.calcsize()</span></code></a> 값과 같습니다.</p>
<p>중요한 예외: 소비자가 <a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_FORMAT</span></code></a> 플래그 없이 버퍼를 요청하면, <a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-member docutils literal notranslate"><span class="pre">format</span></code></a>은 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정되지만, <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a>는 여전히 원래 형식의 값을 갖습니다.</p>
<p><a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a>이 있으면, <code class="docutils literal notranslate"><span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">len</span></code> 동치가 계속 성립하고 소비자는 <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a>를 사용하여 버퍼를 탐색할 수 있습니다.</p>
<p><a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_SIMPLE</span></code></a> 이나 <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a> 요청의 결과로 <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a>이 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, 소비자는 <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a>를 무시하고 <code class="docutils literal notranslate"><span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">1</span></code>로 가정해야 합니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.format">
const char *<code class="sig-name descname">format</code><a class="headerlink" href="#c.Py_buffer.format" title="정의 주소">¶</a></dt>
<dd><p>단일 항목의 내용을 설명하는 <a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 모듈 스타일 문법의 <em>NUL</em> 종료 문자열. 이것이 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, <code class="docutils literal notranslate"><span class="pre">&quot;B&quot;</span></code>(부호 없는 바이트)를 가정합니다.</p>
<p>이 필드는 <a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_FORMAT</span></code></a> 플래그로 제어됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.ndim">
int <code class="sig-name descname">ndim</code><a class="headerlink" href="#c.Py_buffer.ndim" title="정의 주소">¶</a></dt>
<dd><p>메모리가 n 차원 배열로 나타내는 차원 수. <code class="docutils literal notranslate"><span class="pre">0</span></code>이면, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a>는 스칼라를 나타내는 단일 항목을 가리 킵니다. 이 경우, <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a>, <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a> 및 <a class="reference internal" href="#c.Py_buffer.suboffsets" title="Py_buffer.suboffsets"><code class="xref c c-member docutils literal notranslate"><span class="pre">suboffsets</span></code></a>는 반드시 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 이어야 합니다.</p>
<p>매크로 <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_MAX_NDIM</span></code>는 최대 차원 수를 64로 제한합니다. 제공자는 이 제한을 존중해야 하며, 다차원 버퍼의 소비자는 <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_MAX_NDIM</span></code> 차원까지 처리할 수 있어야 합니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.shape">
Py_ssize_t *<code class="sig-name descname">shape</code><a class="headerlink" href="#c.Py_buffer.shape" title="정의 주소">¶</a></dt>
<dd><p>n-차원 배열로 메모리의 모양을 나타내는 길이 <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a>의 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code> 배열. <code class="docutils literal notranslate"><span class="pre">shape[0]</span> <span class="pre">*</span> <span class="pre">...</span> <span class="pre">*</span> <span class="pre">shape[ndim-1]</span> <span class="pre">*</span> <span class="pre">itemsize</span></code>는 <a class="reference internal" href="#c.Py_buffer.len" title="Py_buffer.len"><code class="xref c c-member docutils literal notranslate"><span class="pre">len</span></code></a>과 같아야 합니다.</p>
<p>모양 값은 <code class="docutils literal notranslate"><span class="pre">shape[n]</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>로 제한됩니다. <code class="docutils literal notranslate"><span class="pre">shape[n]</span> <span class="pre">==</span> <span class="pre">0</span></code>인 경우는 특별한 주의가 필요합니다. 자세한 정보는 <a class="reference internal" href="#complex-arrays">복잡한 배열</a>을 참조하십시오.</p>
<p>shape 배열은 소비자에게 읽기 전용입니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.strides">
Py_ssize_t *<code class="sig-name descname">strides</code><a class="headerlink" href="#c.Py_buffer.strides" title="정의 주소">¶</a></dt>
<dd><p>각 차원에서 새 요소를 가져오기 위해 건너뛸 바이트 수를 제공하는 길이 <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a>의 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code> 배열.</p>
<p>스트라이드 값은 임의의 정수일 수 있습니다. 일반 배열의 경우, 스트라이드는 보통 양수이지만, 소비자는 <code class="docutils literal notranslate"><span class="pre">strides[n]</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code>인 경우를 처리할 수 있어야 합니다. 자세한 내용은 <a class="reference internal" href="#complex-arrays">복잡한 배열</a>을 참조하십시오.</p>
<p>strides 배열은 소비자에게 읽기 전용입니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.suboffsets">
Py_ssize_t *<code class="sig-name descname">suboffsets</code><a class="headerlink" href="#c.Py_buffer.suboffsets" title="정의 주소">¶</a></dt>
<dd><p>길이 <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a>의 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code> 배열. <code class="docutils literal notranslate"><span class="pre">suboffsets[n]</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> 면, n 번째 차원을 따라 저장된 값은 포인터이고 서브 오프셋 값은 역참조(de-referencing) 후 각 포인터에 더할 바이트 수를 나타냅니다. 음의 서브 오프셋 값은 역참조(de-referencing)가 발생하지 않아야 함을 나타냅니다 (연속 메모리 블록에서의 스트라이드).</p>
<p>모든 서브 오프셋이 음수면 (즉, 역참조가 필요하지 않으면), 이 필드는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>(기본값) 이어야 합니다.</p>
<p>이 유형의 배열 표현은 파이썬 이미징 라이브러리(PIL)에서 사용됩니다. 이러한 배열 요소에 액세스하는 방법에 대한 자세한 내용은 <a class="reference internal" href="#complex-arrays">복잡한 배열</a>을 참조하십시오.</p>
<p>suboffsets 배열은 소비자에게 읽기 전용입니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.Py_buffer.internal">
void *<code class="sig-name descname">internal</code><a class="headerlink" href="#c.Py_buffer.internal" title="정의 주소">¶</a></dt>
<dd><p>이것은 제공하는(exporting) 객체에 의해 내부적으로 사용됩니다. 예를 들어, 이것은 제공자(exporter)가 정수로 다시 캐스팅할 수 있으며, 버퍼가 해제될 때 shape, strides 및 suboffsets 배열을 해제해야 하는지에 대한 플래그를 저장하는 데 사용됩니다. 소비자가 이 값을 변경해서는 안 됩니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="buffer-request-types">
<span id="id2"></span><h2>버퍼 요청 유형<a class="headerlink" href="#buffer-request-types" title="제목 주소">¶</a></h2>
<p>버퍼는 대개 <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a>를 통해 제공하는(exporting) 객체로 버퍼 요청을 보내서 얻습니다. 메모리의 논리적 구조의 복잡성이 크게 다를 수 있으므로, 소비자는 처리할 수 있는 정확한 버퍼 유형을 지정하기 위해 <em>flags</em> 인자를 사용합니다.</p>
<p>모든 <a class="reference internal" href="#c.Py_buffer" title="Py_buffer"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> 필드는 요청 유형에 의해 모호하지 않게 정의됩니다.</p>
<div class="section" id="request-independent-fields">
<h3>요청 독립적 필드<a class="headerlink" href="#request-independent-fields" title="제목 주소">¶</a></h3>
<p>다음 필드는 <em>flags</em>의 영향을 받지 않고 항상 올바른 값으로 채워져야 합니다: <a class="reference internal" href="#c.Py_buffer.obj" title="Py_buffer.obj"><code class="xref c c-member docutils literal notranslate"><span class="pre">obj</span></code></a>, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a>, <a class="reference internal" href="#c.Py_buffer.len" title="Py_buffer.len"><code class="xref c c-member docutils literal notranslate"><span class="pre">len</span></code></a>, <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a>, <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a>.</p>
</div>
<div class="section" id="readonly-format">
<h3>readonly, format<a class="headerlink" href="#readonly-format" title="제목 주소">¶</a></h3>
<blockquote>
<div><dl class="macro">
<dt id="c.PyBUF_WRITABLE">
<code class="sig-name descname">PyBUF_WRITABLE</code><a class="headerlink" href="#c.PyBUF_WRITABLE" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.Py_buffer.readonly" title="Py_buffer.readonly"><code class="xref c c-member docutils literal notranslate"><span class="pre">readonly</span></code></a> 필드를 제어합니다. 설정되면, 제공자는 반드시 쓰기 가능한 버퍼를 제공하거나 실패를 보고해야 합니다. 그렇지 않으면, 제공자는 읽기 전용 버퍼나 쓰기 가능 버퍼를 제공할 수 있지만, 모든 소비자에 대해 일관성을 유지해야 합니다.</p>
</dd></dl>

<dl class="macro">
<dt id="c.PyBUF_FORMAT">
<code class="sig-name descname">PyBUF_FORMAT</code><a class="headerlink" href="#c.PyBUF_FORMAT" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-member docutils literal notranslate"><span class="pre">format</span></code></a> 필드를 제어합니다. 설정되면, 이 필드를 올바르게 채워야 합니다. 그렇지 않으면, 이 필드는 반드시 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 이어야 합니다.</p>
</dd></dl>

</div></blockquote>
<p><a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a>은 다음 섹션의 모든 플래그와 | 될 수 있습니다. <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_SIMPLE</span></code></a>이 0으로 정의되므로, <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a>은 독립형 플래그로 사용되어 간단한 쓰기 가능한 버퍼를 요청할 수 있습니다.</p>
<p><a class="reference internal" href="#c.PyBUF_FORMAT" title="PyBUF_FORMAT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_FORMAT</span></code></a>은 <a class="reference internal" href="#c.PyBUF_SIMPLE" title="PyBUF_SIMPLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_SIMPLE</span></code></a>을 제외한 임의의 플래그와 | 될 수 있습니다. PyBUF_SIMPLE은 이미 형식 <code class="docutils literal notranslate"><span class="pre">B</span></code>(부호 없는 바이트)를 의미합니다.</p>
</div>
<div class="section" id="shape-strides-suboffsets">
<h3>shape, strides, suboffsets<a class="headerlink" href="#shape-strides-suboffsets" title="제목 주소">¶</a></h3>
<p>메모리의 논리 구조를 제어하는 플래그는 복잡도가 감소하는 순서로 나열됩니다. 각 플래그는 그 아래에 있는 플래그의 모든 비트를 포함합니다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 51%" />
<col style="width: 12%" />
<col style="width: 16%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>요청</p></th>
<th class="head"><p>shape</p></th>
<th class="head"><p>strides</p></th>
<th class="head"><p>suboffsets</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="macro">
<dt id="c.PyBUF_INDIRECT">
<code class="sig-name descname">PyBUF_INDIRECT</code><a class="headerlink" href="#c.PyBUF_INDIRECT" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>필요하면</p></td>
</tr>
<tr class="row-odd"><td><dl class="macro">
<dt id="c.PyBUF_STRIDES">
<code class="sig-name descname">PyBUF_STRIDES</code><a class="headerlink" href="#c.PyBUF_STRIDES" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>NULL</p></td>
</tr>
<tr class="row-even"><td><dl class="macro">
<dt id="c.PyBUF_ND">
<code class="sig-name descname">PyBUF_ND</code><a class="headerlink" href="#c.PyBUF_ND" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>NULL</p></td>
<td><p>NULL</p></td>
</tr>
<tr class="row-odd"><td><dl class="macro">
<dt id="c.PyBUF_SIMPLE">
<code class="sig-name descname">PyBUF_SIMPLE</code><a class="headerlink" href="#c.PyBUF_SIMPLE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>NULL</p></td>
<td><p>NULL</p></td>
<td><p>NULL</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="contiguity-requests">
<span id="index-2"></span><h3>연속성 요청<a class="headerlink" href="#contiguity-requests" title="제목 주소">¶</a></h3>
<p>C 나 포트란 <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">연속성</span></a>을 명시적으로 요청할 수 있는데, 스트라이드 정보를 포함하기도 그렇지 않기도 합니다. 스트라이드 정보가 없으면, 버퍼는 C-연속이어야 합니다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 49%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 17%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>요청</p></th>
<th class="head"><p>shape</p></th>
<th class="head"><p>strides</p></th>
<th class="head"><p>suboffsets</p></th>
<th class="head"><p>연속성</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="macro">
<dt id="c.PyBUF_C_CONTIGUOUS">
<code class="sig-name descname">PyBUF_C_CONTIGUOUS</code><a class="headerlink" href="#c.PyBUF_C_CONTIGUOUS" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>NULL</p></td>
<td><p>C</p></td>
</tr>
<tr class="row-odd"><td><dl class="macro">
<dt id="c.PyBUF_F_CONTIGUOUS">
<code class="sig-name descname">PyBUF_F_CONTIGUOUS</code><a class="headerlink" href="#c.PyBUF_F_CONTIGUOUS" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>NULL</p></td>
<td><p>F</p></td>
</tr>
<tr class="row-even"><td><dl class="macro">
<dt id="c.PyBUF_ANY_CONTIGUOUS">
<code class="sig-name descname">PyBUF_ANY_CONTIGUOUS</code><a class="headerlink" href="#c.PyBUF_ANY_CONTIGUOUS" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>NULL</p></td>
<td><p>C 또는 F</p></td>
</tr>
<tr class="row-odd"><td><dl class="macro">
<dt>
<code class="sig-name descname">PyBUF_ND</code></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>NULL</p></td>
<td><p>NULL</p></td>
<td><p>C</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="compound-requests">
<h3>복합 요청<a class="headerlink" href="#compound-requests" title="제목 주소">¶</a></h3>
<p>모든 가능한 요청은 앞 절의 플래그 조합에 의해 완전히 정의됩니다. 편의상, 버퍼 프로토콜은 자주 사용되는 조합을 단일 플래그로 제공합니다.</p>
<p>다음 표에서 <em>U</em>는 정의되지 않은 연속성을 나타냅니다. 소비자는 연속성을 판단하기 위해 <a class="reference internal" href="#c.PyBuffer_IsContiguous" title="PyBuffer_IsContiguous"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_IsContiguous()</span></code></a>를 호출해야 합니다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 8%" />
<col style="width: 11%" />
<col style="width: 14%" />
<col style="width: 9%" />
<col style="width: 12%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>요청</p></th>
<th class="head"><p>shape</p></th>
<th class="head"><p>strides</p></th>
<th class="head"><p>suboffsets</p></th>
<th class="head"><p>연속성</p></th>
<th class="head"><p>readonly</p></th>
<th class="head"><p>format</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="macro">
<dt id="c.PyBUF_FULL">
<code class="sig-name descname">PyBUF_FULL</code><a class="headerlink" href="#c.PyBUF_FULL" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>필요하면</p></td>
<td><p>U</p></td>
<td><p>0</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><dl class="macro">
<dt id="c.PyBUF_FULL_RO">
<code class="sig-name descname">PyBUF_FULL_RO</code><a class="headerlink" href="#c.PyBUF_FULL_RO" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>필요하면</p></td>
<td><p>U</p></td>
<td><p>1 또는 0</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><dl class="macro">
<dt id="c.PyBUF_RECORDS">
<code class="sig-name descname">PyBUF_RECORDS</code><a class="headerlink" href="#c.PyBUF_RECORDS" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>NULL</p></td>
<td><p>U</p></td>
<td><p>0</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><dl class="macro">
<dt id="c.PyBUF_RECORDS_RO">
<code class="sig-name descname">PyBUF_RECORDS_RO</code><a class="headerlink" href="#c.PyBUF_RECORDS_RO" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>NULL</p></td>
<td><p>U</p></td>
<td><p>1 또는 0</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><dl class="macro">
<dt id="c.PyBUF_STRIDED">
<code class="sig-name descname">PyBUF_STRIDED</code><a class="headerlink" href="#c.PyBUF_STRIDED" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>NULL</p></td>
<td><p>U</p></td>
<td><p>0</p></td>
<td><p>NULL</p></td>
</tr>
<tr class="row-odd"><td><dl class="macro">
<dt id="c.PyBUF_STRIDED_RO">
<code class="sig-name descname">PyBUF_STRIDED_RO</code><a class="headerlink" href="#c.PyBUF_STRIDED_RO" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>NULL</p></td>
<td><p>U</p></td>
<td><p>1 또는 0</p></td>
<td><p>NULL</p></td>
</tr>
<tr class="row-even"><td><dl class="macro">
<dt id="c.PyBUF_CONTIG">
<code class="sig-name descname">PyBUF_CONTIG</code><a class="headerlink" href="#c.PyBUF_CONTIG" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>NULL</p></td>
<td><p>NULL</p></td>
<td><p>C</p></td>
<td><p>0</p></td>
<td><p>NULL</p></td>
</tr>
<tr class="row-odd"><td><dl class="macro">
<dt id="c.PyBUF_CONTIG_RO">
<code class="sig-name descname">PyBUF_CONTIG_RO</code><a class="headerlink" href="#c.PyBUF_CONTIG_RO" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><p>yes</p></td>
<td><p>NULL</p></td>
<td><p>NULL</p></td>
<td><p>C</p></td>
<td><p>1 또는 0</p></td>
<td><p>NULL</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="complex-arrays">
<h2>복잡한 배열<a class="headerlink" href="#complex-arrays" title="제목 주소">¶</a></h2>
<div class="section" id="numpy-style-shape-and-strides">
<h3>NumPy-스타일: shape과 strides<a class="headerlink" href="#numpy-style-shape-and-strides" title="제목 주소">¶</a></h3>
<p>NumPy 스타일 배열의 논리적 구조는 <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a>, <a class="reference internal" href="#c.Py_buffer.ndim" title="Py_buffer.ndim"><code class="xref c c-member docutils literal notranslate"><span class="pre">ndim</span></code></a>, <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a> 및 <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a>로 정의됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">ndim</span> <span class="pre">==</span> <span class="pre">0</span></code>이면, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a>가 가리키는 메모리 위치가 <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">itemsize</span></code></a> 크기의 스칼라로 해석됩니다. 이 경우, <a class="reference internal" href="#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a> 과 <a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a>는 모두 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>입니다.</p>
<p><a class="reference internal" href="#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, 배열은 표준 n-차원 C 배열로 해석됩니다. 그렇지 않으면, 소비자는 다음과 같이 n-차원 배열에 액세스해야 합니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">...</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">strides</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="n">item</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">typeof</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>위에서 언급했듯이, <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a>는 실제 메모리 블록 내의 모든 위치를 가리킬 수 있습니다. 제공자(exporter)는 이 함수로 버퍼의 유효성을 검사 할 수 있습니다:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">verify_structure</span><span class="p">(</span><span class="n">memlen</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;매개 변수가 할당된 메모리 범위 내에서 유효한 배열을 나타내는지 확인합니다:</span>
<span class="sd">           char *mem: 물리적 메모리 블록의 시작</span>
<span class="sd">           memlen: 물리적 메모리 블록의 길이</span>
<span class="sd">           offset: (char *)buf - mem</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="o">%</span> <span class="n">itemsize</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">offset</span><span class="o">+</span><span class="n">itemsize</span> <span class="o">&gt;</span> <span class="n">memlen</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="o">%</span> <span class="n">itemsize</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">strides</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">shape</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">strides</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="n">imin</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">imax</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>
               <span class="k">if</span> <span class="n">strides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">offset</span><span class="o">+</span><span class="n">imin</span> <span class="ow">and</span> <span class="n">offset</span><span class="o">+</span><span class="n">imax</span><span class="o">+</span><span class="n">itemsize</span> <span class="o">&lt;=</span> <span class="n">memlen</span>
</pre></div>
</div>
</div>
<div class="section" id="pil-style-shape-strides-and-suboffsets">
<h3>PIL-스타일: shape, strides 및 suboffsets<a class="headerlink" href="#pil-style-shape-strides-and-suboffsets" title="제목 주소">¶</a></h3>
<p>일반 항목 외에도, PIL 스타일 배열에는 차원의 다음 요소를 가져오기 위해 따라야 하는 포인터가 포함될 수 있습니다. 예를 들어, 일반 3-차원 C 배열 <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">v[2][2][3]</span></code>는 2개의 2-차원 배열을 가리키는 2개의 포인터 배열로 볼 수도 있습니다: <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">(*v[2])[2][3]</span></code>. suboffsets 표현에서, 이 두 포인터는 <a class="reference internal" href="#c.Py_buffer.buf" title="Py_buffer.buf"><code class="xref c c-member docutils literal notranslate"><span class="pre">buf</span></code></a>의 시작 부분에 임베드 될 수 있는데, 메모리의 어느 위치 에나 배치될 수 있는 두 개의 <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">x[2][3]</span></code> 배열을 가리킵니다.</p>
<p>다음은 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아닌 strides와 suboffsets가 있을 때, N-차원 인덱스가 가리키는 N-차원 배열의 요소에 대한 포인터를 반환하는 함수입니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">get_item_pointer</span><span class="p">(</span><span class="kt">int</span> <span class="n">ndim</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">strides</span><span class="p">,</span>
                       <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">suboffsets</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndim</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pointer</span> <span class="o">+=</span> <span class="n">strides</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">suboffsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="n">pointer</span><span class="p">)</span> <span class="o">+</span> <span class="n">suboffsets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pointer</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="buffer-related-functions">
<h2>버퍼 관련 함수<a class="headerlink" href="#buffer-related-functions" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="c.PyObject_CheckBuffer">
int <code class="sig-name descname">PyObject_CheckBuffer</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_CheckBuffer" title="정의 주소">¶</a></dt>
<dd><p><em>obj</em>가 버퍼 인터페이스를 지원하면 <code class="docutils literal notranslate"><span class="pre">1</span></code>을 반환하고, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다. <code class="docutils literal notranslate"><span class="pre">1</span></code>이 반환될 때, <a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a>가 성공할 것이라고 보장하지는 않습니다. 이 함수는 항상 성공합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_GetBuffer">
int <code class="sig-name descname">PyObject_GetBuffer</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *exporter</em>, <a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a><em> *view</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_GetBuffer" title="정의 주소">¶</a></dt>
<dd><p><em>flags</em>에 지정된 대로 <em>view</em>를 채우도록 <em>exporter</em>에게 요청을 보냅니다. 제공자(exporter)가 정확한 유형의 버퍼를 제공할 수 없다면, <code class="xref c c-data docutils literal notranslate"><span class="pre">PyExc_BufferError</span></code>를 일으키고, <code class="xref c c-member docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>를 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정하고, <code class="docutils literal notranslate"><span class="pre">-1</span></code>를 반환해야 합니다.</p>
<p>성공하면, <em>view</em>를 채우고, <code class="xref c c-member docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>를 <em>exporter</em>에 대한 새 참조로 설정하고, 0을 반환합니다. 요청을 단일 객체로 리디렉션하는 연결된(chained) 버퍼 공급자의 경우, <code class="xref c c-member docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>는 <em>exporter</em> 대신 이 객체를 참조할 수 있습니다 (<a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">버퍼 객체 구조체</span></a>를 보세요).</p>
<p><a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a>에 대한 성공적인 호출은 <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>에 대한 호출과 쌍을 이루어야 합니다, <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code>과 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>와 유사합니다. 따라서, 소비자가 버퍼로 작업한 후에는, <a class="reference internal" href="#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>를 정확히 한 번 호출해야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyBuffer_Release">
void <code class="sig-name descname">PyBuffer_Release</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a><em> *view</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_Release" title="정의 주소">¶</a></dt>
<dd><p>버퍼 <em>view</em>를 해제하고 <code class="xref c c-member docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>에 대한 참조 횟수를 감소시킵니다. 버퍼가 더는 사용되지 않을 때, 이 함수를 반드시 호출해야 합니다. 그렇지 않으면 참조 누수가 발생할 수 있습니다.</p>
<p><a class="reference internal" href="#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a>를 통해 얻지 않은 버퍼에 이 함수를 호출하는 것은 에러입니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyBuffer_SizeFromFormat">
Py_ssize_t <code class="sig-name descname">PyBuffer_SizeFromFormat</code><span class="sig-paren">(</span>const char<em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_SizeFromFormat" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-data docutils literal notranslate"><span class="pre">format</span></code></a>이 암시하는 <a class="reference internal" href="#c.Py_buffer.itemsize" title="Py_buffer.itemsize"><code class="xref c c-data docutils literal notranslate"><span class="pre">itemsize</span></code></a>를 반환합니다. 이 함수는 아직 구현되지 않았습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyBuffer_IsContiguous">
int <code class="sig-name descname">PyBuffer_IsContiguous</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a><em> *view</em>, char<em> order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_IsContiguous" title="정의 주소">¶</a></dt>
<dd><p><em>view</em>로 정의된 메모리가 C 스타일(<em>order</em>가 <code class="docutils literal notranslate"><span class="pre">'C'</span></code>)이나 포트란 스타일(<em>order</em>가 <code class="docutils literal notranslate"><span class="pre">'F'</span></code>) <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">연속</span></a>이거나 둘 중 하나(<em>order</em>가 <code class="docutils literal notranslate"><span class="pre">'A'</span></code>)면 <code class="docutils literal notranslate"><span class="pre">1</span></code>을 반환합니다. 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다. 이 함수는 항상 성공합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyBuffer_GetPointer">
void* <code class="sig-name descname">PyBuffer_GetPointer</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a><em> *view</em>, Py_ssize_t<em> *indices</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_GetPointer" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>view</em> 내부의 <em>indices</em>가 가리키는 메모리 영역을 가져옵니다. <em>indices</em>는 <code class="docutils literal notranslate"><span class="pre">view-&gt;ndim</span></code> 인덱스의 배열을 가리켜야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyBuffer_FromContiguous">
int <code class="sig-name descname">PyBuffer_FromContiguous</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a><em> *view</em>, void<em> *buf</em>, Py_ssize_t<em> len</em>, char<em> fort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_FromContiguous" title="정의 주소">¶</a></dt>
<dd><p><em>buf</em>에 있는 연속된 <em>len</em> 바이트를 <em>view</em>로 복사합니다. <em>fort</em>는 <code class="docutils literal notranslate"><span class="pre">'C'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'F'</span></code>(C 스타일 또는 포트란 스타일 순서)일 수 있습니다. 성공하면 <code class="docutils literal notranslate"><span class="pre">0</span></code>이 반환되고, 에러가 있으면 <code class="docutils literal notranslate"><span class="pre">-1</span></code>이 반환됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyBuffer_ToContiguous">
int <code class="sig-name descname">PyBuffer_ToContiguous</code><span class="sig-paren">(</span>void<em> *buf</em>, <a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a><em> *src</em>, Py_ssize_t<em> len</em>, char<em> order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_ToContiguous" title="정의 주소">¶</a></dt>
<dd><p><em>src</em>에 있는 <em>len</em> 바이트를 <em>buf</em>에 연속 표현으로 복사합니다. <em>order</em>는 <code class="docutils literal notranslate"><span class="pre">'C'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'F'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'A'</span></code>(C 스타일 또는 포트란 스타일 순서 또는 둘 중 하나)일 수 있습니다. 성공하면 <code class="docutils literal notranslate"><span class="pre">0</span></code>이 반환되고, 에러가 있으면 <code class="docutils literal notranslate"><span class="pre">-1</span></code>이 반환됩니다.</p>
<p>이 함수는 <em>len</em> != <em>src-&gt;len</em>이면 실패합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyBuffer_FillContiguousStrides">
void <code class="sig-name descname">PyBuffer_FillContiguousStrides</code><span class="sig-paren">(</span>int<em> ndims</em>, Py_ssize_t<em> *shape</em>, Py_ssize_t<em> *strides</em>, int<em> itemsize</em>, char<em> order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_FillContiguousStrides" title="정의 주소">¶</a></dt>
<dd><p><em>strides</em> 배열을 주어진 요소당 바이트 수와 주어진 shape 으로 <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">연속</span></a> (<em>order</em>가 <code class="docutils literal notranslate"><span class="pre">'C'</span></code>면 C 스타일, <em>order</em>가 <code class="docutils literal notranslate"><span class="pre">'F'</span></code>면 포트란 스타일) 배열의 바이트 스트라이드로 채웁니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyBuffer_FillInfo">
int <code class="sig-name descname">PyBuffer_FillInfo</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_buffer" title="Py_buffer">Py_buffer</a><em> *view</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *exporter</em>, void<em> *buf</em>, Py_ssize_t<em> len</em>, int<em> readonly</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyBuffer_FillInfo" title="정의 주소">¶</a></dt>
<dd><p><em>readonly</em>에 따라 쓰기 가능성이 설정된 <em>len</em> 크기의 <em>buf</em>를 노출하려는 제공자(exporter)에 대한 버퍼 요청을 처리합니다. <em>buf</em>는 부호 없는 바이트의 시퀀스로 해석됩니다.</p>
<p><em>flags</em> 인자는 요청 유형을 나타냅니다. 이 함수는 <em>buf</em>가 읽기 전용으로 지정되고 <a class="reference internal" href="#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a>이 <em>flags</em>에 설정되어 있지 않으면, 항상 플래그가 지정하는 대로 <em>view</em>를 채웁니다.</p>
<p>성공하면, <code class="xref c c-member docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>를 <em>exporter</em>에 대한 새 참조로 설정하고, 0을 반환합니다. 그렇지 않으면, <code class="xref c c-data docutils literal notranslate"><span class="pre">PyExc_BufferError</span></code>를 일으키고, <code class="xref c c-member docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>를 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정한 다음 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다.</p>
<p>이 함수가 <a class="reference internal" href="typeobj.html#buffer-structs"><span class="std std-ref">getbufferproc</span></a>의 일부로 사용되면, <em>exporter</em>가 제공하는(exporting) 객체로 설정되어야 하고, <em>flags</em>는 수정되지 않은 채로 전달되어야 합니다. 그렇지 않으면 <em>exporter</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이어야 합니다.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">버퍼 프로토콜</a><ul>
<li><a class="reference internal" href="#buffer-structure">버퍼 구조체</a></li>
<li><a class="reference internal" href="#buffer-request-types">버퍼 요청 유형</a><ul>
<li><a class="reference internal" href="#request-independent-fields">요청 독립적 필드</a></li>
<li><a class="reference internal" href="#readonly-format">readonly, format</a></li>
<li><a class="reference internal" href="#shape-strides-suboffsets">shape, strides, suboffsets</a></li>
<li><a class="reference internal" href="#contiguity-requests">연속성 요청</a></li>
<li><a class="reference internal" href="#compound-requests">복합 요청</a></li>
</ul>
</li>
<li><a class="reference internal" href="#complex-arrays">복잡한 배열</a><ul>
<li><a class="reference internal" href="#numpy-style-shape-and-strides">NumPy-스타일: shape과 strides</a></li>
<li><a class="reference internal" href="#pil-style-shape-strides-and-suboffsets">PIL-스타일: shape, strides 및 suboffsets</a></li>
</ul>
</li>
<li><a class="reference internal" href="#buffer-related-functions">버퍼 관련 함수</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="iter.html"
                        title="이전 장">이터레이터 프로토콜</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="objbuffer.html"
                        title="다음 장">낡은 버퍼 프로토콜</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="objbuffer.html" title="낡은 버퍼 프로토콜"
             >다음</a> |</li>
        <li class="right" >
          <a href="iter.html" title="이터레이터 프로토콜"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="abstract.html" >추상 객체 계층</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>