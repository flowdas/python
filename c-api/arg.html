
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>인자 구문 분석과 값 구축 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="문자열 변환과 포매팅" href="conversion.html" />
    <link rel="prev" title="데이터 마샬링 지원" href="marshal.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/c-api/arg.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="conversion.html" title="문자열 변환과 포매팅"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="marshal.html" title="데이터 마샬링 지원"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="utilities.html" accesskey="U">유틸리티</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="parsing-arguments-and-building-values">
<span id="arg-parsing"></span><h1>인자 구문 분석과 값 구축<a class="headerlink" href="#parsing-arguments-and-building-values" title="제목 주소">¶</a></h1>
<p>이 함수들은 자체 확장 함수와 메서드를 만들 때 유용합니다. 추가 정보와 예제는 <a class="reference internal" href="../extending/index.html#extending-index"><span class="std std-ref">파이썬 인터프리터 확장 및 내장</span></a>에 있습니다.</p>
<p>설명된 이러한 함수 중 처음 세 개인 <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>, <a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> 및 <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_Parse()</span></code></a>는 모두 예상 인자에 관한 사항을 함수에 알리는 데 사용되는 <em>포맷 문자열(format strings)</em>을 사용합니다. 포맷 문자열은 이러한 각 함수에 대해 같은 문법을 사용합니다.</p>
<div class="section" id="parsing-arguments">
<h2>인자 구문 분석<a class="headerlink" href="#parsing-arguments" title="제목 주소">¶</a></h2>
<p>포맷 문자열은 0개 이상의 &quot;포맷 단위(format units)&quot;로 구성됩니다. 포맷 단위는 하나의 파이썬 객체를 설명합니다; 일반적으로 단일 문자나 괄호로 묶인 포맷 단위 시퀀스입니다. 몇 가지 예외를 제외하고, 괄호로 묶인 시퀀스가 아닌 포맷 단위는 일반적으로 이러한 함수에 대한 단일 주소 인자에 대응합니다. 다음 설명에서, 인용된(quoted) 형식은 포맷 단위입니다; (둥근) 괄호 안의 항목은 포맷 단위와 일치하는 파이썬 객체 형입니다; [대괄호] 안의 항목은 주소를 전달해야 하는 C 변수의 형입니다.</p>
<div class="section" id="strings-and-buffers">
<h3>문자열과 버퍼<a class="headerlink" href="#strings-and-buffers" title="제목 주소">¶</a></h3>
<p>이러한 포맷을 사용하면 연속적인 메모리 청크로 객체에 액세스 할 수 있습니다. 반환된 유니코드나 바이트열 영역에 대한 원시 저장소를 제공할 필요가 없습니다.</p>
<p>일반적으로, 포맷이 버퍼에 대한 포인터를 설정할 때, 버퍼는 해당 파이썬 객체에 의해 관리되고, 버퍼는 이 객체의 수명을 공유합니다. 여러분이 직접 메모리를 해제할 필요가 없습니다. 유일한 예외는 <code class="docutils literal notranslate"><span class="pre">es</span></code>, <code class="docutils literal notranslate"><span class="pre">es#</span></code>, <code class="docutils literal notranslate"><span class="pre">et</span></code> 및 <code class="docutils literal notranslate"><span class="pre">et#</span></code>입니다.</p>
<p>그러나, <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> 구조체가 채워질 때, 하부 버퍼가 잠겨서, 호출자가 <a class="reference internal" href="init.html#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> 블록 내에서도 가변 데이터의 크기가 조정되거나 파괴될 위험 없이 이후에 버퍼를 사용할 수 있습니다. 결과적으로, 데이터 처리를 마친 후 (또는 모든 조기 중단의 경우) <a class="reference internal" href="buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>를 <strong>호출해야 합니다</strong>.</p>
<p>달리 명시되지 않는 한, 버퍼는 NUL로 종료되지 않습니다.</p>
<p>일부 포맷에는 읽기 전용 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>가 필요하며, 버퍼 구조체 대신 포인터를 설정합니다. 객체의 <a class="reference internal" href="typeobj.html#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyBufferProcs.bf_releasebuffer</span></code></a> 필드가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>인지 확인하여 작동하며, 이때는 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>와 같은 가변 객체를 허용하지 않습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>모든 포맷의 <code class="docutils literal notranslate"><span class="pre">#</span></code> 변형(<code class="docutils literal notranslate"><span class="pre">s#</span></code>, <code class="docutils literal notranslate"><span class="pre">y#</span></code> 등)에 대해, 길이 인자의 형(int나 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>)은 <code class="file docutils literal notranslate"><span class="pre">Python.h</span></code>를 포함하기 전에 매크로 <code class="xref c c-macro docutils literal notranslate"><span class="pre">PY_SSIZE_T_CLEAN</span></code>을 정의하여 제어됩니다. 매크로가 정의되었으면, 길이는 <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>가 아닌 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>입니다. 이 동작은 향후 파이썬 버전에서 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>만 지원하고 <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> 지원을 중단하도록 변경됩니다. 항상 <code class="xref c c-macro docutils literal notranslate"><span class="pre">PY_SSIZE_T_CLEAN</span></code>을 정의하는 것이 가장 좋습니다.</p>
</div>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const char *]</dt><dd><p>유니코드 객체를 문자열에 대한 C 포인터로 변환합니다. 기존 문자열에 대한 포인터는 여러분이 주소를 전달한 문자 포인터 변수에 저장됩니다. C 문자열은 NUL로 종료됩니다. 파이썬 문자열은 내장된 널 코드 포인트를 포함하지 않아야 합니다; 그렇다면 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 예외가 발생합니다. 유니코드 객체는 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 인코딩을 사용하여 C 문자열로 변환됩니다. 이 변환이 실패하면, <a class="reference internal" href="../library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>가 발생합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 포맷은 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>를 받아들이지 않습니다. 파일 시스템 경로를 받아들이고 이를 C 문자열로 변환하려면, <a class="reference internal" href="unicode.html#c.PyUnicode_FSConverter" title="PyUnicode_FSConverter"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FSConverter()</span></code></a>를 <em>converter</em>로 <code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> 포맷을 사용하는 것이 좋습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이전에는, 파이썬 문자열에서 내장된 널 코드 포인트가 발견되면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생했습니다.</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s*</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 또는 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>) [Py_buffer]</dt><dd><p>이 포맷은 바이트열류 객체뿐만 아니라 유니코드 객체를 받아들입니다. 호출자가 제공한 <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> 구조체를 채웁니다. 이 경우 결과 C 문자열은 내장된 NUL 바이트를 포함할 수 있습니다. 유니코드 객체는 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 인코딩을 사용하여 C 문자열로 변환됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, 읽기 전용 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>) [const char *, int 또는 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>]</dt><dd><p>가변 객체를 받아들이지 않는다는 점을 제외하면, <code class="docutils literal notranslate"><span class="pre">s*</span></code>와 같습니다. 결과는 두 개의 C 변수에 저장됩니다. 첫 번째 변수는 C 문자열에 대한 포인터이고, 두 번째 변수는 길이입니다. 문자열은 내장 널 바이트를 포함할 수  있습니다. 유니코드 객체는 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 인코딩을 사용하여 C 문자열로 변환됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s</span></code>와 비슷하지만, 파이썬 객체가 <code class="docutils literal notranslate"><span class="pre">None</span></code>일 수도 있는데, 이 경우 C 포인터가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z*</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a> 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [Py_buffer]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s*</span></code>와 비슷하지만, 파이썬 객체는 <code class="docutils literal notranslate"><span class="pre">None</span></code>일 수도 있습니다, 이 경우 <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> 구조체의 <code class="docutils literal notranslate"><span class="pre">buf</span></code> 멤버가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, 읽기 전용 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a> 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *, int 또는 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s#</span></code>와 비슷하지만, 파이썬 객체는 <code class="docutils literal notranslate"><span class="pre">None</span></code>일 수도 있습니다, 이 경우 C 포인터가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y</span></code> (읽기 전용 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>) [const char *]</dt><dd><p>이 포맷은 바이트열류 객체를 문자열에 대한 C 포인터로 변환합니다; 유니코드 객체를 받아들이지 않습니다. 바이트열 버퍼는 내장 널 바이트를 포함하지 않아야 합니다; 만약 그렇다면, <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 예외가 발생합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이전에는, 바이트열 버퍼에서 내장 널 바이트가 발견되면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생했습니다.</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y*</span></code> (<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>) [Py_buffer]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s*</span></code>의 이 변형은 유니코드 객체가 아니라 바이트열류 객체만 받아들입니다. <strong>바이너리 데이터를 받아들이는 권장 방법입니다.</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y#</span></code> (읽기 전용 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>) [const char *, int 또는 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s#</span></code>의 이 변형은 유니코드 객체가 아니라 바이트열류 객체만 받아들입니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>) [PyBytesObject *]</dt><dd><p>변환을 시도하지 않고, 파이썬 객체가 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체일 것을 요구합니다. 객체가 바이트열 객체가 아니면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다. C 변수는 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code></a>로 선언될 수도 있습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Y</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) [PyByteArrayObject *]</dt><dd><p>변환을 시도하지 않고, 파이썬 객체가 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 객체일 것을 요구합니다. 객체가 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 객체가 아니면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다. C 변수는 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code></a>로 선언될 수도 있습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const Py_UNICODE *]</dt><dd><p>파이썬 유니코드 객체를 유니코드 문자의 NUL 종료 버퍼에 대한 C 포인터로 변환합니다. 기존 유니코드 버퍼에 대한 포인터로 채워질, <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 포인터 변수의 주소를 전달해야 합니다. <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 문자의 너비는 컴파일 옵션에 따라 다음에 유의하십시오 (16비트나 32비트입니다). 파이썬 문자열은 내장 널 코드 포인트를 포함하지 않아야 합니다; 만약 그렇다면, <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 예외가 발생합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이전에는, 파이썬 문자열에서 내장된 널 코드 포인트가 발견되면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생했습니다.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>이전 스타일 <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="unicode.html#c.PyUnicode_AsWideCharString" title="PyUnicode_AsWideCharString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsWideCharString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const Py_UNICODE *, int 또는 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">u</span></code>의 이 변형은 두 개의 C 변수에 저장됩니다, 첫 번째 변수는 유니코드 데이터 버퍼에 대한 포인터이고, 두 번째 변수는 길이입니다. 이 변형은 널 코드 포인트를 허용합니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>이전 스타일 <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="unicode.html#c.PyUnicode_AsWideCharString" title="PyUnicode_AsWideCharString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsWideCharString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Z</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const Py_UNICODE *]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">u</span></code>와 비슷하지만, 파이썬 객체는 <code class="docutils literal notranslate"><span class="pre">None</span></code>일 수도 있습니다, 이 경우 <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 포인터가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정됩니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>이전 스타일 <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="unicode.html#c.PyUnicode_AsWideCharString" title="PyUnicode_AsWideCharString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsWideCharString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Z#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const Py_UNICODE *, int or <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">u#</span></code>와 비슷하지만, 파이썬 객체는 <code class="docutils literal notranslate"><span class="pre">None</span></code>일 수도 있습니다, 이 경우 <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 포인터가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정됩니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>이전 스타일 <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="unicode.html#c.PyUnicode_AsWideCharString" title="PyUnicode_AsWideCharString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsWideCharString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">U</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [PyObject *]</dt><dd><p>변환을 시도하지 않고, 파이썬 객체가 유니코드 객체일 것을 요구합니다. 객체가 유니코드 객체가 아니면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다. C 변수는 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code></a>로 선언될 수도 있습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">w*</span></code> (읽기-쓰기 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>) [Py_buffer]</dt><dd><p>이 포맷은 읽기-쓰기 버퍼 인터페이스를 구현하는 모든 객체를 허용합니다. 호출자가 제공한 <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> 구조체를 채웁니다. 버퍼에는 내장 널 바이트가 포함될 수 있습니다. 호출자는 버퍼로 할 일을 마치면 <a class="reference internal" href="buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>를 호출해야 합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">es</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const char *encoding, char **buffer]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s</span></code>의 이 변형은 유니코드를 문자 버퍼로 인코딩하는 데 사용됩니다. 내장 NUL 바이트가 포함되지 않은 인코딩된 데이터에 대해서만 작동합니다.</p>
<p>이 포맷에는 두 개의 인자가 필요합니다. 첫 번째는 입력으로만 사용되며, 인코딩 이름을 가리키는 NUL 종료 문자열로 <code class="xref c c-type docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code>이거나, <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 인코딩이 사용되도록 하는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이어야 합니다. 명명된 인코딩이 파이썬에 알려지지 않았으면 예외가 발생합니다. 두 번째 인자는 <code class="xref c c-type docutils literal notranslate"><span class="pre">char**</span></code>여야 합니다; 참조하는 포인터의 값은 인자 텍스트의 내용이 있는 버퍼로 설정됩니다. 텍스트는 첫 번째 인자에 지정된 인코딩으로 인코딩됩니다.</p>
<p><a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>은 필요한 크기의 버퍼를 할당하고, 인코딩된 데이터를 이 버퍼에 복사하고 새로 할당된 스토리지를 참조하도록 <em>*buffer</em>를 조정합니다. 호출자는 사용 후에 할당된 버퍼를 해제하기 위해 <a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a>를 호출해야 합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">et</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 또는 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) [const char *encoding, char **buffer]</dt><dd><p>바이트 문자열 객체를 다시 코딩하지 않고 통과시킨다는 점을 제외하면 <code class="docutils literal notranslate"><span class="pre">es</span></code>와 같습니다. 대신, 구현은 바이트 문자열 객체가 매개 변수로 전달된 인코딩을 사용한다고 가정합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">es#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const char *encoding, char **buffer, int 또는 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code> *buffer_length]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s#</span></code>의 이 변형은 유니코드를 문자 버퍼로 인코딩하는 데 사용됩니다. <code class="docutils literal notranslate"><span class="pre">es</span></code> 포맷과 달리, 이 변형은 NUL 문자를 포함하는 입력 데이터를 허용합니다.</p>
<p>세 가지 인자가 필요합니다. 첫 번째는 입력으로만 사용되며, 인코딩 이름을 가리키는 NUL 종료 문자열로 <code class="xref c c-type docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code>이거나, <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 인코딩이 사용되도록 하는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이어야 합니다. 명명된 인코딩이 파이썬에 알려지지 않았으면 예외가 발생합니다. 두 번째 인자는 <code class="xref c c-type docutils literal notranslate"><span class="pre">char**</span></code>여야 합니다; 참조하는 포인터의 값은 인자 텍스트의 내용이 있는 버퍼로 설정됩니다. 텍스트는 첫 번째 인자에 지정된 인코딩으로 인코딩됩니다. 세 번째 인자는 정수에 대한 포인터여야 합니다; 참조된 정수는 출력 버퍼의 바이트 수로 설정됩니다.</p>
<p>두 가지 작동 모드가 있습니다:</p>
<p><em>*buffer</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 포인터를 가리키면, 함수는 필요한 크기의 버퍼를 할당하고, 이 버퍼로 인코딩된 데이터를 복사하고 <em>*buffer</em>를 새로 할당된 스토리지를 참조하도록 설정합니다. 호출자는 사용 후 할당된 버퍼를 해제하기 위해 <a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a>를 호출해야 합니다.</p>
<p><em>*buffer</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아닌 포인터를 가리키면 (이미 할당된 버퍼), <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>은 이 위치를 버퍼로 사용하고 <em>*buffer_length</em>의 초깃값을 버퍼 크기로 해석합니다. 그런 다음 인코딩된 데이터를 버퍼에 복사하고 NUL 종료합니다. 버퍼가 충분히 크지 않으면, <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 설정됩니다.</p>
<p>두 경우 모두, <em>*buffer_length</em>는 후행 NUL 바이트를 제외한 인코딩된 데이터의 길이로 설정됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">et#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 또는 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) [const char *encoding, char **buffer, int 또는 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code> *buffer_length]</dt><dd><p>바이트 문자열 객체를 다시 코딩하지 않고 통과시킨다는 점을 제외하면 <code class="docutils literal notranslate"><span class="pre">es#</span></code>와 같습니다. 대신, 구현은 바이트 문자열 객체가 매개 변수로 전달된 인코딩을 사용한다고 가정합니다.</p>
</dd>
</dl>
</div>
<div class="section" id="numbers">
<h3>숫자<a class="headerlink" href="#numbers" title="제목 주소">¶</a></h3>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned char]</dt><dd><p>음이 아닌 파이썬 정수를 부호 없는 작은 정수로 변환하고, C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>에 저장합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">B</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned char]</dt><dd><p>오버플로 검사 없이 파이썬 정수를 작은 정수로 변환하고, C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>에 저장합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [short int]</dt><dd><p>파이썬 정수를 C <code class="xref c c-type docutils literal notranslate"><span class="pre">short</span> <span class="pre">int</span></code>로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">H</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned short int]</dt><dd><p>오버플로 검사 없이, 파이썬 정수를 C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">int</span></code>로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [int]</dt><dd><p>파이썬 정수를 일반 C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned int]</dt><dd><p>오버플로 검사 없이, 파이썬 정수를 C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [long int]</dt><dd><p>파이썬 정수를 C <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">int</span></code>로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">k</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned long]</dt><dd><p>오버플로 검사 없이 파이썬 정수를 C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>으로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">L</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [long long]</dt><dd><p>파이썬 정수를 C <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>으로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">K</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned long long]</dt><dd><p>오버플로 검사 없이 파이썬 정수를 C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code>으로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [Py_ssize_t]</dt><dd><p>파이썬 정수를 C <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code> (길이 1의 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 또는 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) [char]</dt><dd><p>길이가 1인 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>나 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 객체로 표시된, 파이썬 바이트를 C <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code>로 변환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 객체를 허용합니다.</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">C</span></code> (길이 1의 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [int]</dt><dd><p>길이가 1인 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체로 표시된, 파이썬 문자를 C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) [float]</dt><dd><p>파이썬 부동 소수점 숫자를 C <code class="xref c c-type docutils literal notranslate"><span class="pre">float</span></code>로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d</span></code> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) [double]</dt><dd><p>파이썬 부동 소수점 숫자를 C <code class="xref c c-type docutils literal notranslate"><span class="pre">double</span></code>로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">D</span></code> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>) [Py_complex]</dt><dd><p>파이썬 복소수를 C <a class="reference internal" href="complex.html#c.Py_complex" title="Py_complex"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_complex</span></code></a> 구조체로 변환합니다.</p>
</dd>
</dl>
</div>
<div class="section" id="other-objects">
<h3>기타 객체<a class="headerlink" href="#other-objects" title="제목 주소">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">O</span></code> (object) [PyObject *]</dt><dd><p>C 객체 포인터에 파이썬 객체를 (변환 없이) 저장합니다. 따라서 C 프로그램은 전달된 실제 객체를 받습니다. 객체의 참조 횟수는 증가하지 않습니다. 저장된 포인터는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아닙니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">O!</span></code> (object) [<em>typeobject</em>, PyObject *]</dt><dd><p>C 객체 포인터에 파이썬 객체를 저장합니다. 이것은 <code class="docutils literal notranslate"><span class="pre">O</span></code>와 유사하지만, 두 개의 C 인자를 취합니다: 첫 번째는 파이썬 형 객체의 주소이고, 두 번째는 객체 포인터가 저장되는 (<a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code></a> 형의) C 변수의 주소입니다. 파이썬 객체가 필요한 형이 아니면, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생합니다.</p>
</dd>
</dl>
<dl id="o-ampersand">
<dt><code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> (object) [<em>converter</em>, <em>anything</em>]</dt><dd><p><em>converter</em> 함수를 통해 파이썬 객체를 C 변수로 변환합니다. 두 개의 인자를 취합니다: 첫 번째는 함수이고, 두 번째는 <code class="xref c c-type docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>로 변환된, (임의의 형의) C 변수의 주소입니다. <em>converter</em> 함수는 다음과 같이 호출됩니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">status</span> <span class="o">=</span> <span class="n">converter</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
</pre></div>
</div>
<p>여기서 <em>object</em>는 변환할 파이썬 객체이고 <em>address</em>는 <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_Parse*()</span></code></a> 함수에 전달된 <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> 인자입니다. 반환된 <em>status</em>는 성공적인 변환의 경우 <code class="docutils literal notranslate"><span class="pre">1</span></code>이고 변환에 실패한 경우 <code class="docutils literal notranslate"><span class="pre">0</span></code>이어야 합니다. 변환이 실패하면, <em>converter</em> 함수는 예외를 발생시키고 <em>address</em>의 내용을 수정하지 않은 상태로 두어야 합니다.</p>
<p><em>converter</em>가 <code class="docutils literal notranslate"><span class="pre">Py_CLEANUP_SUPPORTED</span></code>를 반환하면, 인자 구문 분석이 결국 실패하면 두 번째로 호출되어 변환기에 이미 할당된 메모리를 해제할 기회를 제공할 수 있습니다. 이 두 번째 호출에서, <em>object</em> 매개 변수는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 됩니다; <em>address</em>는 원래 호출과 같은 값을 갖습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span><code class="docutils literal notranslate"><span class="pre">Py_CLEANUP_SUPPORTED</span></code>가 추가되었습니다.</p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code> (<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>) [int]</dt><dd><p>전달된 값의 논리값을 테스트(불리언 <strong>p</strong>redicate)하고 결과를 동등한 C 참/거짓 정숫값으로 변환합니다. 표현식이 참이면 int를 <code class="docutils literal notranslate"><span class="pre">1</span></code>로, 거짓이면 <code class="docutils literal notranslate"><span class="pre">0</span></code>으로 설정합니다. 모든 유효한 파이썬 값을 허용합니다. 파이썬이 논리값을 테스트하는 방법에 대한 자세한 내용은 <a class="reference internal" href="../library/stdtypes.html#truth"><span class="std std-ref">논리값 검사</span></a>를 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(items)</span></code> (<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) [<em>matching-items</em>]</dt><dd><p>객체는 길이가 <em>items</em>에 있는 포맷 단위의 수인 파이썬 시퀀스여야 합니다. C 인자들은 <em>items</em>의 개별 포맷 단위에 대응해야 합니다. 시퀀스의 포맷 단위는 중첩될 수 있습니다.</p>
</dd>
</dl>
<p>&quot;긴&quot; 정수(값이 플랫폼의 <code class="xref py py-const docutils literal notranslate"><span class="pre">LONG_MAX</span></code>를 초과하는 정수)를 전달할 수 있지만 적절한 범위 검사가 수행되지 않습니다 --- 수신 필드가 값을 수신하기에 너무 작을 때 최상위 비트가 자동으로 잘립니다 (실제로, 이 의미는 C의 다운 캐스트에서 물려받았습니다 --- 여러분의 경험은 다를 수 있습니다).</p>
<p>몇 가지 다른 문자는 포맷 문자열에서 의미가 있습니다. 중첩된 괄호 안에서는 나타날 수 없습니다. 그들은:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p>파이썬 인자 리스트의 나머지 인자가 선택 사항임을 나타냅니다. 선택적 인자에 해당하는 C 변수는 기본값으로 초기화되어야 합니다 --- 선택적 인자가 지정되지 않을 때, <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>은 해당 C 변수의 내용을 건드리지 않습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">$</span></code></dt><dd><p><a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> 전용: 파이썬 인자 리스트의 나머지 인자가 키워드 전용임을 나타냅니다. 현재, 모든 키워드 전용 인자는 선택적 인자여야 하므로, <code class="docutils literal notranslate"><span class="pre">|</span></code>는 항상 포맷 문자열에서 <code class="docutils literal notranslate"><span class="pre">$</span></code> 앞에 지정되어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">:</span></code></dt><dd><p>포맷 단위 리스트는 여기에서 끝납니다; 콜론 뒤의 문자열은 에러 메시지에서 함수 이름으로 사용됩니다 (<a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>이 발생시키는 예외의 &quot;연관된 값&quot;).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">;</span></code></dt><dd><p>포맷 단위 리스트는 여기에서 끝납니다; 세미콜론 뒤의 문자열은 기본 에러 메시지의 에러 메시지 <em>대신</em> 에러 메시지로 사용됩니다. <code class="docutils literal notranslate"><span class="pre">:</span></code>와 <code class="docutils literal notranslate"><span class="pre">;</span></code>는 서로를 배제합니다.</p>
</dd>
</dl>
<p>호출자에게 제공되는 모든 파이썬 객체 참조는 <em>빌려온(borrowed)</em> 참조임에 유의하십시오; 참조 횟수를 줄이지 마십시오!</p>
<p>이러한 함수에 전달되는 추가 인자는 포맷 문자열에 의해 형이 결정되는 변수의 주소여야 합니다; 이들은 입력 튜플의 값을 저장하는 데 사용됩니다. 위의 포맷 단위 리스트에서 설명된 대로, 이러한 매개 변수가 입력값으로 사용되는 몇 가지 경우가 있습니다; 이 경우 해당 포맷 단위에 대해 지정된 것과 일치해야 합니다.</p>
<p>변환이 성공하려면, <em>arg</em> 객체가 포맷과 일치해야 하며 포맷이 소진되어야 합니다. 성공하면, <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_Parse*()</span></code></a> 함수는 참을 반환하고, 그렇지 않으면 거짓을 반환하고 적절한 예외를 발생시킵니다. 포맷 단위 중 하나의 변환 실패로 인해 <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_Parse*()</span></code></a> 함수가 실패하면, 해당 주소의 변수와 그 뒤에 오는 포맷 단위는 건드리지 않습니다.</p>
</div>
<div class="section" id="api-functions">
<h3>API 함수<a class="headerlink" href="#api-functions" title="제목 주소">¶</a></h3>
<dl class="function">
<dt id="c.PyArg_ParseTuple">
int <code class="sig-name descname">PyArg_ParseTuple</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em>, const char<em> *format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_ParseTuple" title="정의 주소">¶</a></dt>
<dd><p>위치 매개 변수만 지역 변수로 취하는 함수의 매개 변수를 구문 분석합니다. 성공하면 참을 반환합니다; 실패하면, 거짓을 반환하고 적절한 예외를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_VaParse">
int <code class="sig-name descname">PyArg_VaParse</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em>, const char<em> *format</em>, va_list<em> vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_VaParse" title="정의 주소">¶</a></dt>
<dd><p>가변 개수의 인자가 아닌 va_list를 받아들인다는 점을 제외하면, <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>과 동일합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_ParseTupleAndKeywords">
int <code class="sig-name descname">PyArg_ParseTupleAndKeywords</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *kw</em>, const char<em> *format</em>, char<em> *keywords[]</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_ParseTupleAndKeywords" title="정의 주소">¶</a></dt>
<dd><p>위치와 키워드 매개 변수를 모두 지역 변수로 취하는 함수의 매개 변수를 구문 분석합니다. <em>keywords</em> 인자는 키워드 매개 변수 이름의 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>-종료 배열입니다. 빈 이름은 <a class="reference internal" href="../glossary.html#positional-only-parameter"><span class="std std-ref">위치-전용 매개 변수</span></a>를 나타냅니다. 성공하면 참을 반환합니다; 실패하면, 거짓을 반환하고 적절한 예외를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="../glossary.html#positional-only-parameter"><span class="std std-ref">위치-전용 매개 변수</span></a>에 대한 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_VaParseTupleAndKeywords">
int <code class="sig-name descname">PyArg_VaParseTupleAndKeywords</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *kw</em>, const char<em> *format</em>, char<em> *keywords[]</em>, va_list<em> vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_VaParseTupleAndKeywords" title="정의 주소">¶</a></dt>
<dd><p>가변 개수의 인자가 아닌 va_list를 받아들인다는 점을 제외하면, <a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> 와 동일합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_ValidateKeywordArguments">
int <code class="sig-name descname">PyArg_ValidateKeywordArguments</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_ValidateKeywordArguments" title="정의 주소">¶</a></dt>
<dd><p>키워드 인자 딕셔너리의 키가 문자열인지 확인합니다. <a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> 가 사용되지 않는 경우에만 필요합니다, 여기서는 이미 이 검사를 수행하기 때문입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_Parse">
int <code class="sig-name descname">PyArg_Parse</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em>, const char<em> *format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_Parse" title="정의 주소">¶</a></dt>
<dd><p>&quot;이전 스타일&quot; 함수의 인자 리스트를 분해하는 데 사용되는 함수 --- 이들은 파이썬 3에서 제거된 <code class="xref py py-const docutils literal notranslate"><span class="pre">METH_OLDARGS</span></code> 매개 변수 구문 분석 메서드를 사용하는 함수입니다. 새 코드에서 매개 변수 구문 분석에 사용하는 것은 권장되지 않고, 표준 인터프리터에 있는 대부분의 코드는 더는 이런 목적으로 사용하지 않도록 수정되었습니다. 그러나, 다른 튜플을 분해하는 편리한 방법으로 남아 있으며, 그런 목적으로 계속 사용할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_UnpackTuple">
int <code class="sig-name descname">PyArg_UnpackTuple</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em>, const char<em> *name</em>, Py_ssize_t<em> min</em>, Py_ssize_t<em> max</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_UnpackTuple" title="정의 주소">¶</a></dt>
<dd><p>인자 형을 지정하기 위해 포맷 문자열을 사용하지 않는 더 간단한 형식의 매개 변수 조회. 이 방법으로 매개 변수를 꺼내는 함수는 함수나 메서드 테이블에서 <a class="reference internal" href="structures.html#METH_VARARGS" title="METH_VARARGS"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_VARARGS</span></code></a>로 선언되어야 합니다. 실제 매개 변수를 포함하는 튜플은 <em>args</em>로 전달되어야 합니다; 이것은 실제로 튜플이어야 합니다. 튜플의 길이는 <em>min</em> 이상 <em>max</em> 이하이어야 합니다; <em>min</em>과 <em>max</em>는 같을 수 있습니다. 추가 인자는 함수에 전달되어야 하며, 각 인자는 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code></a> 변수에 대한 포인터여야 합니다; 이들은 <em>args</em>의 값으로 채워집니다; 빌린 참조가 포함됩니다. <em>args</em>에서 제공하지 않는 선택적 매개 변수에 해당하는 변수는 채워지지 않습니다; 이것들은 호출자에 의해 초기화되어야 합니다. 이 함수는 성공하면 참을 반환하고 <em>args</em>가 튜플이 아니거나, 잘못된 수의 요소를 포함하면 거짓을 반환합니다; 실패하면 예외가 설정됩니다.</p>
<p>다음은 이 함수 사용의 예입니다, 약한 참조를 위한 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_weakref</span></code> 도우미 모듈의 소스에서 가져왔습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">weakref_ref</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyArg_UnpackTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;ref&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">PyWeakref_NewRef</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">callback</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>이 예제에서 <a class="reference internal" href="#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_UnpackTuple()</span></code></a>에 대한 호출은 <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>에 대한 다음 호출과 전적으로 동등합니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;O|O:ref&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="building-values">
<h2>값 구축<a class="headerlink" href="#building-values" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="c.Py_BuildValue">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">Py_BuildValue</code><span class="sig-paren">(</span>const char<em> *format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_BuildValue" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_Parse*()</span></code></a> 함수 계열에서 받아들이는 것과 유사한 포맷 문자열과 값 시퀀스를 기반으로 새 값을 만듭니다. 값을 반환하거나 에러가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다; <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 반환되면 예외가 발생합니다.</p>
<p><a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>는 항상 튜플을 구축하지는 않습니다. 포맷 문자열에 둘 이상의 포맷 단위가 포함되었을 때만 튜플을 구축합니다. 포맷 문자열이 비어 있으면, <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다; 정확히 하나의 포맷 단위를 포함하면, 해당 포맷 단위가 기술하는 객체가 무엇이건 반환합니다. 크기가 0이나 1인 튜플을 반환하도록 하려면, 포맷 문자열을 괄호로 묶으십시오.</p>
<p><code class="docutils literal notranslate"><span class="pre">s</span></code>와 <code class="docutils literal notranslate"><span class="pre">s#</span></code> 포맷의 경우처럼, 메모리 버퍼가 데이터를 빌드 객체에 제공하기 위해 매개 변수로 전달될 때, 필요한 데이터가 복사됩니다. 호출자가 제공하는 버퍼는 <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>가 만든 객체에 의해 참조되지 않습니다. 즉, 여러분의 코드가 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code>을 호출하고 할당된 메모리를 <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>에 전달하면, 인단 <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>가 반환되면 여러분이 코드가 해당 메모리에 대해 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>를 호출해야 합니다.</p>
<p>다음 설명에서, 인용된 형식은 포맷 단위입니다; (둥근) 괄호 안의 항목은 포맷 단위가 반환할 파이썬 객체 형입니다; [대괄호] 안의 항목은 전달할 C 값의 형입니다.</p>
<p>문자 스페이스, 탭, 콜론 및 쉼표는 포맷 문자열에서 무시됩니다 (하지만 <code class="docutils literal notranslate"><span class="pre">s#</span></code>와 같은 포맷 단위 내에서는 아닙니다). 이것은 긴 포맷 문자열을 좀 더 읽기 쉽게 만드는 데 사용할 수 있습니다.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 인코딩을 사용하여 널-종료 C 문자열을 파이썬 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체로 변환합니다. C 문자열 포인터가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 사용됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *, int or <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 인코딩을 사용하여 C 문자열과 그 길이를 파이썬 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체로 변환합니다. C 문자열 포인터가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, 길이가 무시되고 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>) [const char *]</dt><dd><p>이것은 C 문자열을 파이썬 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체로 변환합니다. C 문자열 포인터가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y#</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>) [const char *, int 또는 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>]</dt><dd><p>이것은 C 문자열과 그 길이를 파이썬 객체로 변환합니다. C 문자열 포인터가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s</span></code>와 같습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *, int 또는 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s#</span></code>과 같습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const wchar_t *]</dt><dd><p>유니코드 (UTF-16 또는 UCS-4) 데이터의 널-종료 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> 버퍼를 파이썬 유니코드 객체로 변환합니다. 유니코드 버퍼 포인터가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [const wchar_t *, int 또는 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>]</dt><dd><p>유니코드 (UTF-16 또는 UCS-4) 데이터 버퍼와 그 길이를 파이썬 유니코드 객체로 변환합니다. 유니코드 버퍼 포인터가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, 길이가 무시되고 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">U</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s</span></code>와 같습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">U#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *, int 또는 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s#</span></code>과 같습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [int]</dt><dd><p>일반 C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>를 파이썬 정수 객체로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [char]</dt><dd><p>일반 C <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code>을 파이썬 정수 객체로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [short int]</dt><dd><p>일반 C <code class="xref c c-type docutils literal notranslate"><span class="pre">short</span> <span class="pre">int</span></code>를 파이썬 정수 객체로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [long int]</dt><dd><p>C <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">int</span></code>를 파이썬 정수 객체로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">B</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned char]</dt><dd><p>C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>을 파이썬 정수 객체로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">H</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned short int]</dt><dd><p>C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">int</span></code>를 파이썬 정수 객체로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned int]</dt><dd><p>C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>를 파이썬 정수 객체로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">k</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned long]</dt><dd><p>C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>을 파이썬 정수 객체로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">L</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [long long]</dt><dd><p>C <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>을 파이썬 정수 객체로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">K</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [unsigned long long]</dt><dd><p>C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code>을 파이썬 정수 객체로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) [Py_ssize_t]</dt><dd><p>C <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>를 파이썬 정수로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code> (길이 1의 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>) [char]</dt><dd><p>바이트를 나타내는 C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>를 길이 1의 파이썬 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">C</span></code> (길이 1의 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) [int]</dt><dd><p>문자를 나타내는 C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>를 길이 1의 파이썬 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d</span></code> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) [double]</dt><dd><p>C <code class="xref c c-type docutils literal notranslate"><span class="pre">double</span></code>을 파이썬 부동 소수점 숫자로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) [float]</dt><dd><p>C <code class="xref c c-type docutils literal notranslate"><span class="pre">float</span></code>를 파이썬 부동 소수점 숫자로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">D</span></code> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>) [Py_complex *]</dt><dd><p>C <a class="reference internal" href="complex.html#c.Py_complex" title="Py_complex"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_complex</span></code></a> 구조체를 파이썬 복소수로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">O</span></code> (object) [PyObject *]</dt><dd><p>파이썬 객체를 손대지 않고 전달합니다 (1 증가하는 참조 횟수는 예외입니다). 전달된 객체가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 포인터면, 인자를 생성하는 호출이 에러를 발견하고 예외를 설정했기 때문으로 간주합니다. 따라서, <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환하지만, 예외를 발생시키지 않습니다. 아직 예외가 발생하지 않았으면, <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemError</span></code></a>가 설정됩니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S</span></code> (object) [PyObject *]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">O</span></code>와 같습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">N</span></code> (object) [PyObject *]</dt><dd><p><code class="docutils literal notranslate"><span class="pre">O</span></code>와 같지만, 객체의 참조 횟수를 증가시키지 않습니다. 인자 리스트에서 객체 생성자를 호출하여 객체를 만들 때 유용합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> (object) [<em>converter</em>, <em>anything</em>]</dt><dd><p><em>converter</em> 함수를 통해 <em>anything</em>을 파이썬 객체로 변환합니다. 함수는 인자로 <em>anything</em>(<code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code>와 호환되어야 합니다)을 사용하여 호출되며 &quot;새&quot; 파이썬 객체를 반환하거나, 에러가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환해야 합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(items)</span></code> (<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) [<em>matching-items</em>]</dt><dd><p>C값의 시퀀스를 항목 수가 같은 파이썬 튜플로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[items]</span></code> (<a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>) [<em>matching-items</em>]</dt><dd><p>C값의 시퀀스를 항목 수가 같은 파이썬 리스트로 변환합니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{items}</span></code> (<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>) [<em>matching-items</em>]</dt><dd><p>C값의 시퀀스를 파이썬 딕셔너리로 변환합니다. 연속된 C 값의 각 쌍은 딕셔너리에 하나의 항목을 추가하여, 각각 키와 값으로 사용됩니다.</p>
</dd>
</dl>
<p>포맷 문자열에 에러가 있으면, <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemError</span></code></a> 예외가 설정되고 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 반환됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_VaBuildValue">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">Py_VaBuildValue</code><span class="sig-paren">(</span>const char<em> *format</em>, va_list<em> vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_VaBuildValue" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>가변 개수의 인자가 아닌 va_list를 받아들인다는 점을 제외하면, <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>와 동일합니다.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">인자 구문 분석과 값 구축</a><ul>
<li><a class="reference internal" href="#parsing-arguments">인자 구문 분석</a><ul>
<li><a class="reference internal" href="#strings-and-buffers">문자열과 버퍼</a></li>
<li><a class="reference internal" href="#numbers">숫자</a></li>
<li><a class="reference internal" href="#other-objects">기타 객체</a></li>
<li><a class="reference internal" href="#api-functions">API 함수</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-values">값 구축</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="marshal.html"
                        title="이전 장">데이터 마샬링 지원</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="conversion.html"
                        title="다음 장">문자열 변환과 포매팅</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="conversion.html" title="문자열 변환과 포매팅"
             >다음</a> |</li>
        <li class="right" >
          <a href="marshal.html" title="데이터 마샬링 지원"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="utilities.html" >유틸리티</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>