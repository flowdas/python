
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>호출 프로토콜 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="숫자 프로토콜" href="number.html" />
    <link rel="prev" title="객체 프로토콜" href="object.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/c-api/call.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="number.html" title="숫자 프로토콜"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="object.html" title="객체 프로토콜"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="abstract.html" accesskey="U">추상 객체 계층</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="call-protocol">
<span id="call"></span><h1>호출 프로토콜<a class="headerlink" href="#call-protocol" title="제목 주소">¶</a></h1>
<p>CPython은 두 가지 호출 프로토콜을 지원합니다: <em>tp_call</em>과 벡터콜(vectorcall).</p>
<div class="section" id="the-tp-call-protocol">
<h2><em>tp_call</em> 프로토콜<a class="headerlink" href="#the-tp-call-protocol" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>을 설정하는 클래스의 인스턴스는 콜러블입니다. 슬롯의 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">tp_call</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">callable</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">);</span>
</pre></div>
</div>
<p>파이썬 코드의 <code class="docutils literal notranslate"><span class="pre">callable(*args,</span> <span class="pre">**kwargs)</span></code>와 유사하게, 위치 인자를 위한 튜플과 키워드 인자를 위한 딕셔너리를 사용하여 호출합니다. <em>args</em>는 NULL이 아니어야합니다 (인자가 없으면 빈 튜플을 사용하십시오). 하지만 키워드 인자가 없으면 <em>kwargs</em>는 <em>NULL</em>일 수 있습니다.</p>
<p>이 규칙은 <em>tp_call</em>에서만 사용되는 것이 아닙니다: <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a>와 <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a>도 인자를 이런 식으로 전달합니다.</p>
<p>객체를 호출하려면, <a class="reference internal" href="#c.PyObject_Call" title="PyObject_Call"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Call()</span></code></a>이나 다른 <a class="reference internal" href="#capi-call"><span class="std std-ref">호출 API</span></a>를 사용하십시오.</p>
</div>
<div class="section" id="the-vectorcall-protocol">
<span id="vectorcall"></span><h2>벡터콜(Vectorcall) 프로토콜<a class="headerlink" href="#the-vectorcall-protocol" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
<p>벡터콜 프로토콜은 <span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0590"><strong>PEP 590</strong></a>에서 호출 효율을 높이기 위한 추가 프로토콜로 도입되었습니다.</p>
<p>경험 규칙으로, CPython은 콜러블이 지원하면 내부 호출에 대해 벡터콜을 선호합니다. 그러나 이것은 엄격한 규칙이 아닙니다. 또한, 일부 제삼자 확장은 (<code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_call()</span></code>을 사용하지 않고) <em>tp_call</em>을 직접 사용합니다. 따라서, 벡터콜을 지원하는 클래스도 <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>을 구현해야합니다. 또한, 어떤 프로토콜을 사용하는지에 관계없이 콜러블은 동일하게 작동해야합니다. 이를 위해 권장되는 방법은 <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>을 <a class="reference internal" href="#c.PyVectorcall_Call" title="PyVectorcall_Call"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyVectorcall_Call()</span></code></a>로 설정하는 것입니다. 이것이 반복을 처리합니다:</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>벡터콜을 지원하는 클래스도 같은 의미를 갖도록 <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>을 <strong>반드시</strong> 구현해야합니다.</p>
</div>
<p><em>tp_call</em>보다 느려진다면 클래스는 벡터콜을 구현해서는 안됩니다. 예를 들어, 피호출자가 어차피 인자를 인자 튜플과 kwargs 딕셔너리로 변환 해야하면, 벡터콜을 구현할 이유가 없습니다.</p>
<p>클래스는 <a class="reference internal" href="typeobj.html#Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_VECTORCALL</span></code></a> 플래그를 활성화하고 <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code></a>을 <em>vectorcallfunc</em>가 등장하는 객체 구조체 내부의 오프셋으로 설정하여 벡터콜 프로토콜을 구현할 수 있습니다. 이것은 다음과 같은 서명을 갖는 함수를 가리키는 포인터입니다:</p>
<dl class="type">
<dt id="c.vectorcallfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*vectorcallfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *const<em> *args</em>, size_t<em> nargsf</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *kwnames</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vectorcallfunc" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<ul class="simple">
<li><p><em>callable</em>은 호출되는 객체입니다.</p></li>
<li><dl class="simple">
<dt><em>args</em>는 위치 인자와 그 뒤를 따르는 키워드 인자의 값으로 구성된 C 배열입니다.</dt><dd><p>인자가 없으면 <em>NULL</em>일 수 있습니다.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><em>nargsf</em>는 위치 인자의 수에</dt><dd><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PY_VECTORCALL_ARGUMENTS_OFFSET</span></code> 플래그를 더한 것입니다. <em>nargsf</em>에서 실제 위치 인자 수를 얻으려면, <a class="reference internal" href="#c.PyVectorcall_NARGS" title="PyVectorcall_NARGS"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyVectorcall_NARGS()</span></code></a>를 사용하십시오.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><em>kwnames</em>는 키워드 인자의 이름을 포함하는 튜플입니다;</dt><dd><p>다시 말해, kwargs 딕셔너리의 키. 이 이름들은 문자열(<code class="docutils literal notranslate"><span class="pre">str</span></code>이나 서브 클래스의 인스턴스)이어야하며 고유해야합니다. 키워드 인자가 없으면, <em>kwnames</em>는 대신 <em>NULL</em>일 수 있습니다.</p>
</dd>
</dl>
</li>
</ul>
<dl class="var">
<dt id="c.PY_VECTORCALL_ARGUMENTS_OFFSET">
<code class="sig-name descname">PY_VECTORCALL_ARGUMENTS_OFFSET</code><a class="headerlink" href="#c.PY_VECTORCALL_ARGUMENTS_OFFSET" title="정의 주소">¶</a></dt>
<dd><p>이 플래그가 벡터콜 <em>nargsf</em> 인자에 설정되면, 피호출자는 일시적으로 <code class="docutils literal notranslate"><span class="pre">args[-1]</span></code>를 변경할 수 있습니다. 즉, <em>args</em>는 할당된 벡터에서 인자 1(0이 아닙니다)을 가리킵니다. 피호출자는 반환하기 전에 <code class="docutils literal notranslate"><span class="pre">args[-1]</span></code> 값을 복원해야합니다.</p>
<p><a class="reference internal" href="#c.PyObject_VectorcallMethod" title="PyObject_VectorcallMethod"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_VectorcallMethod()</span></code></a>의 경우, 이 플래그는 대신 <code class="docutils literal notranslate"><span class="pre">args[0]</span></code>이 변경될 수 있음을 의미합니다.</p>
<p>(추가 할당 없이) 저렴하게 할 수 있을 때마다, 호출자는 <code class="xref py py-const docutils literal notranslate"><span class="pre">PY_VECTORCALL_ARGUMENTS_OFFSET</span></code>을 사용하는 것이 좋습니다. 이렇게하면 연결된 메서드와 같은 콜러블이 후속 호출(앞에 <em>self</em> 인자를 포함하는)을 매우 효율적으로 만들 수 있습니다.</p>
</dd></dl>

<p>벡터콜을 구현하는 객체를 호출하려면, 다른 콜러블과 마찬가지로 <a class="reference internal" href="#capi-call"><span class="std std-ref">호출 API</span></a> 함수를 사용하십시오. <a class="reference internal" href="#c.PyObject_Vectorcall" title="PyObject_Vectorcall"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Vectorcall()</span></code></a>은 일반적으로 가장 효율적입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>CPython 3.8에서 벡터콜 API와 관련 함수는 앞에 밑줄이 붙은 이름으로 잠정적으로 사용할 수 있었습니다: <code class="docutils literal notranslate"><span class="pre">_PyObject_Vectorcall</span></code>, <code class="docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code>, <code class="docutils literal notranslate"><span class="pre">_PyObject_VectorcallMethod</span></code>, <code class="docutils literal notranslate"><span class="pre">_PyVectorcall_Function</span></code>, <code class="docutils literal notranslate"><span class="pre">_PyObject_CallOneArg</span></code>, <code class="docutils literal notranslate"><span class="pre">_PyObject_CallMethodNoArgs</span></code>, <code class="docutils literal notranslate"><span class="pre">_PyObject_CallMethodOneArg</span></code>. 또한, <code class="docutils literal notranslate"><span class="pre">PyObject_VectorcallDict</span></code>는 <code class="docutils literal notranslate"><span class="pre">_PyObject_FastCallDict</span></code>로 제공되었습니다. 이전 이름은 여전히 밑줄이 없는 새로운 이름의 별칭으로 정의됩니다.</p>
</div>
<div class="section" id="recursion-control">
<h3>재귀 제어<a class="headerlink" href="#recursion-control" title="제목 주소">¶</a></h3>
<p><em>tp_call</em>을 사용할 때, 피호출자는 <a class="reference internal" href="exceptions.html#recursion"><span class="std std-ref">재귀</span></a>에 대해 걱정할 필요가 없습니다: CPython은 <em>tp_call</em>을 사용하여 호출한 경우 <a class="reference internal" href="exceptions.html#c.Py_EnterRecursiveCall" title="Py_EnterRecursiveCall"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EnterRecursiveCall()</span></code></a>과 <a class="reference internal" href="exceptions.html#c.Py_LeaveRecursiveCall" title="Py_LeaveRecursiveCall"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_LeaveRecursiveCall()</span></code></a>을 사용합니다.</p>
<p>효율성을 위해, 벡터콜을 사용하여 호출한 경우에는 그렇지 않습니다: 피호출자는 필요하면 <em>Py_EnterRecursiveCall</em>과 <em>Py_LeaveRecursiveCall</em>을 사용해야합니다.</p>
</div>
<div class="section" id="vectorcall-support-api">
<h3>벡터콜 지원 API<a class="headerlink" href="#vectorcall-support-api" title="제목 주소">¶</a></h3>
<dl class="function">
<dt id="c.PyVectorcall_NARGS">
Py_ssize_t <code class="sig-name descname">PyVectorcall_NARGS</code><span class="sig-paren">(</span>size_t<em> nargsf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyVectorcall_NARGS" title="정의 주소">¶</a></dt>
<dd><p>벡터콜 <em>nargsf</em> 인자가 주어지면, 실제 인자 수를 반환합니다. 현재 다음과 동등합니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">Py_ssize_t</span><span class="p">)(</span><span class="n">nargsf</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PY_VECTORCALL_ARGUMENTS_OFFSET</span><span class="p">)</span>
</pre></div>
</div>
<p>그러나, 향후 확장을 위해 <code class="docutils literal notranslate"><span class="pre">PyVectorcall_NARGS</span></code> 함수를 사용해야합니다.</p>
<p>이 함수는 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">제한된 API</span></a>의 일부가 아닙니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyVectorcall_Function">
<a class="reference internal" href="#c.vectorcallfunc" title="vectorcallfunc">vectorcallfunc</a> <code class="sig-name descname">PyVectorcall_Function</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *op</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyVectorcall_Function" title="정의 주소">¶</a></dt>
<dd><p><em>op</em>가 벡터콜 프로토콜을 지원하지 않으면 (형이 지워하지 않거나 인스턴스가 지원하지 않기 때문에), <em>NULL</em>을 반환합니다. 그렇지 않으면, <em>op</em>에 저장된 벡터콜 함수 포인터를 반환합니다. 이 함수는 예외를 발생시키지 않습니다.</p>
<p>이것은 <em>op</em>가 벡터콜을 지원하는지를 확인하는 데 주로 유용하며, <code class="docutils literal notranslate"><span class="pre">PyVectorcall_Function(op)</span> <span class="pre">!=</span> <span class="pre">NULL</span></code>을 확인하여 수행 할 수 있습니다.</p>
<p>이 함수는 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">제한된 API</span></a>의 일부가 아닙니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyVectorcall_Call">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyVectorcall_Call</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *tuple</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *dict</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyVectorcall_Call" title="정의 주소">¶</a></dt>
<dd><p>튜플과 딕셔너리에 각각 주어진 위치와 키워드 인자로 <em>callable</em>의 <a class="reference internal" href="#c.vectorcallfunc" title="vectorcallfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">vectorcallfunc</span></code></a>를 호출합니다.</p>
<p>이것은 <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a> 슬롯에 넣거나 <code class="docutils literal notranslate"><span class="pre">tp_call</span></code> 구현에 사용하기 위한 특수 함수입니다. <a class="reference internal" href="typeobj.html#Py_TPFLAGS_HAVE_VECTORCALL" title="Py_TPFLAGS_HAVE_VECTORCALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_VECTORCALL</span></code></a> 플래그를 확인하지 않고 <code class="docutils literal notranslate"><span class="pre">tp_call</span></code>로 폴 백하지 않습니다.</p>
<p>이 함수는 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">제한된 API</span></a>의 일부가 아닙니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="object-calling-api">
<span id="capi-call"></span><h2>객체 호출 API<a class="headerlink" href="#object-calling-api" title="제목 주소">¶</a></h2>
<p>파이썬 객체를 호출하기 위해 다양한 함수를 사용할 수 있습니다. 각각은 인자를 호출된 객체가 지원하는 규칙으로 변환합니다 - <em>tp_call</em> 또는 벡터콜. 가능한 한 적은 변환을 수행하려면, 사용 가능한 데이터 형식에 가장 적합한 것을 선택하십시오.</p>
<p>다음 표는 사용 가능한 함수를 요약한 것입니다; 자세한 내용은 개별 설명서를 참조하십시오.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 19%" />
<col style="width: 21%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>함수</p></th>
<th class="head"><p>콜러블</p></th>
<th class="head"><p>args</p></th>
<th class="head"><p>kwargs</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyObject_Call" title="PyObject_Call"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Call()</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></p></td>
<td><p>튜플</p></td>
<td><p>딕셔너리/<code class="docutils literal notranslate"><span class="pre">NULL</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyObject_CallNoArgs" title="PyObject_CallNoArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallNoArgs()</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></p></td>
<td><p>---</p></td>
<td><p>---</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyObject_CallOneArg" title="PyObject_CallOneArg"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallOneArg()</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></p></td>
<td><p>1 객체</p></td>
<td><p>---</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyObject_CallObject" title="PyObject_CallObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallObject()</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></p></td>
<td><p>튜플/<code class="docutils literal notranslate"><span class="pre">NULL</span></code></p></td>
<td><p>---</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyObject_CallFunction" title="PyObject_CallFunction"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallFunction()</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></p></td>
<td><p>포맷(format)</p></td>
<td><p>---</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyObject_CallMethod" title="PyObject_CallMethod"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallMethod()</span></code></a></p></td>
<td><p>obj + <code class="docutils literal notranslate"><span class="pre">char*</span></code></p></td>
<td><p>포맷(format)</p></td>
<td><p>---</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyObject_CallFunctionObjArgs" title="PyObject_CallFunctionObjArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallFunctionObjArgs()</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></p></td>
<td><p>가변(variadic)</p></td>
<td><p>---</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyObject_CallMethodObjArgs" title="PyObject_CallMethodObjArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallMethodObjArgs()</span></code></a></p></td>
<td><p>obj + name</p></td>
<td><p>가변(variadic)</p></td>
<td><p>---</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyObject_CallMethodNoArgs" title="PyObject_CallMethodNoArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallMethodNoArgs()</span></code></a></p></td>
<td><p>obj + name</p></td>
<td><p>---</p></td>
<td><p>---</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyObject_CallMethodOneArg" title="PyObject_CallMethodOneArg"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallMethodOneArg()</span></code></a></p></td>
<td><p>obj + name</p></td>
<td><p>1 객체</p></td>
<td><p>---</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyObject_Vectorcall" title="PyObject_Vectorcall"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Vectorcall()</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></p></td>
<td><p>벡터콜</p></td>
<td><p>벡터콜</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyObject_VectorcallDict" title="PyObject_VectorcallDict"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_VectorcallDict()</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></p></td>
<td><p>벡터콜</p></td>
<td><p>딕셔너리/<code class="docutils literal notranslate"><span class="pre">NULL</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyObject_VectorcallMethod" title="PyObject_VectorcallMethod"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_VectorcallMethod()</span></code></a></p></td>
<td><p>arg + name</p></td>
<td><p>벡터콜</p></td>
<td><p>벡터콜</p></td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="c.PyObject_Call">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject_Call</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_Call" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>튜플 <em>args</em>로 주어진 인자와 딕셔너리 <em>kwargs</em>로 주어진 이름있는 인자로 콜러블 파이썬 객체 <em>callable</em>을 호출합니다.</p>
<p><em>args</em>는 <em>NULL</em>이 아니어야 합니다ㅣ 인자가 필요 없으면 빈 튜플을 사용하십시오. 이름있는 인자가 필요하지 않으면, <em>kwargs</em>는 <em>NULL</em>일 수 있습니다.</p>
<p>성공하면 호출 결과를 반환하고, 실패하면 예외를 발생시키고 <em>NULL</em>을 반환합니다.</p>
<p>이것은 파이썬 표현식 <code class="docutils literal notranslate"><span class="pre">callable(*args,</span> <span class="pre">**kwargs)</span></code>와 동등합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallNoArgs">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject_CallNoArgs</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *callable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_CallNoArgs" title="정의 주소">¶</a></dt>
<dd><p>Call a callable Python object <em>callable</em> without any arguments. It is the
most efficient way to call a callable Python object without any argument.</p>
<p>성공하면 호출 결과를 반환하고, 실패하면 예외를 발생시키고 <em>NULL</em>을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallOneArg">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject_CallOneArg</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_CallOneArg" title="정의 주소">¶</a></dt>
<dd><p>Call a callable Python object <em>callable</em> with exactly 1 positional argument
<em>arg</em> and no keyword arguments.</p>
<p>성공하면 호출 결과를 반환하고, 실패하면 예외를 발생시키고 <em>NULL</em>을 반환합니다.</p>
<p>이 함수는 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">제한된 API</span></a>의 일부가 아닙니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallObject">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject_CallObject</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_CallObject" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Call a callable Python object <em>callable</em>, with arguments given by the
tuple <em>args</em>.  If no arguments are needed, then <em>args</em> can be <em>NULL</em>.</p>
<p>성공하면 호출 결과를 반환하고, 실패하면 예외를 발생시키고 <em>NULL</em>을 반환합니다.</p>
<p>This is the equivalent of the Python expression: <code class="docutils literal notranslate"><span class="pre">callable(*args)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallFunction">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject_CallFunction</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *callable</em>, const char<em> *format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_CallFunction" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Call a callable Python object <em>callable</em>, with a variable number of C arguments.
The C arguments are described using a <a class="reference internal" href="arg.html#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> style format
string.  The format can be <em>NULL</em>, indicating that no arguments are provided.</p>
<p>성공하면 호출 결과를 반환하고, 실패하면 예외를 발생시키고 <em>NULL</em>을 반환합니다.</p>
<p>This is the equivalent of the Python expression: <code class="docutils literal notranslate"><span class="pre">callable(*args)</span></code>.</p>
<p>Note that if you only pass <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> args,
<a class="reference internal" href="#c.PyObject_CallFunctionObjArgs" title="PyObject_CallFunctionObjArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallFunctionObjArgs()</span></code></a> is a faster alternative.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>The type of <em>format</em> was changed from <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallMethod">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject_CallMethod</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em>, const char<em> *name</em>, const char<em> *format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_CallMethod" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Call the method named <em>name</em> of object <em>obj</em> with a variable number of C
arguments.  The C arguments are described by a <a class="reference internal" href="arg.html#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> format
string that should produce a tuple.</p>
<p>The format can be <em>NULL</em>, indicating that no arguments are provided.</p>
<p>성공하면 호출 결과를 반환하고, 실패하면 예외를 발생시키고 <em>NULL</em>을 반환합니다.</p>
<p>This is the equivalent of the Python expression:
<code class="docutils literal notranslate"><span class="pre">obj.name(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code>.</p>
<p>Note that if you only pass <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> args,
<a class="reference internal" href="#c.PyObject_CallMethodObjArgs" title="PyObject_CallMethodObjArgs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_CallMethodObjArgs()</span></code></a> is a faster alternative.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>The types of <em>name</em> and <em>format</em> were changed from <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallFunctionObjArgs">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject_CallFunctionObjArgs</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *callable</em>, ..., NULL<span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_CallFunctionObjArgs" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Call a callable Python object <em>callable</em>, with a variable number of
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> arguments.  The arguments are provided as a variable number
of parameters followed by <em>NULL</em>.</p>
<p>성공하면 호출 결과를 반환하고, 실패하면 예외를 발생시키고 <em>NULL</em>을 반환합니다.</p>
<p>This is the equivalent of the Python expression:
<code class="docutils literal notranslate"><span class="pre">callable(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallMethodObjArgs">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject_CallMethodObjArgs</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *name</em>, ..., NULL<span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_CallMethodObjArgs" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Call a method of the Python object <em>obj</em>, where the name of the method is given as a
Python string object in <em>name</em>.  It is called with a variable number of
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> arguments.  The arguments are provided as a variable number
of parameters followed by <em>NULL</em>.</p>
<p>성공하면 호출 결과를 반환하고, 실패하면 예외를 발생시키고 <em>NULL</em>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallMethodNoArgs">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject_CallMethodNoArgs</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_CallMethodNoArgs" title="정의 주소">¶</a></dt>
<dd><p>Call a method of the Python object <em>obj</em> without arguments,
where the name of the method is given as a Python string object in <em>name</em>.</p>
<p>성공하면 호출 결과를 반환하고, 실패하면 예외를 발생시키고 <em>NULL</em>을 반환합니다.</p>
<p>이 함수는 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">제한된 API</span></a>의 일부가 아닙니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_CallMethodOneArg">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject_CallMethodOneArg</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *name</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_CallMethodOneArg" title="정의 주소">¶</a></dt>
<dd><p>Call a method of the Python object <em>obj</em> with a single positional argument
<em>arg</em>, where the name of the method is given as a Python string object in
<em>name</em>.</p>
<p>성공하면 호출 결과를 반환하고, 실패하면 예외를 발생시키고 <em>NULL</em>을 반환합니다.</p>
<p>이 함수는 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">제한된 API</span></a>의 일부가 아닙니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_Vectorcall">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject_Vectorcall</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *const<em> *args</em>, size_t<em> nargsf</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *kwnames</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_Vectorcall" title="정의 주소">¶</a></dt>
<dd><p>Call a callable Python object <em>callable</em>.
The arguments are the same as for <a class="reference internal" href="#c.vectorcallfunc" title="vectorcallfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">vectorcallfunc</span></code></a>.
If <em>callable</em> supports <a class="reference internal" href="#vectorcall">vectorcall</a>, this directly calls
the vectorcall function stored in <em>callable</em>.</p>
<p>성공하면 호출 결과를 반환하고, 실패하면 예외를 발생시키고 <em>NULL</em>을 반환합니다.</p>
<p>이 함수는 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">제한된 API</span></a>의 일부가 아닙니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_VectorcallDict">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject_VectorcallDict</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *const<em> *args</em>, size_t<em> nargsf</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *kwdict</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_VectorcallDict" title="정의 주소">¶</a></dt>
<dd><p>Call <em>callable</em> with positional arguments passed exactly as in the <a class="reference internal" href="#vectorcall">vectorcall</a> protocol,
but with keyword arguments passed as a dictionary <em>kwdict</em>.
The <em>args</em> array contains only the positional arguments.</p>
<p>Regardless of which protocol is used internally,
a conversion of arguments needs to be done.
Therefore, this function should only be used if the caller
already has a dictionary ready to use for the keyword arguments,
but not a tuple for the positional arguments.</p>
<p>이 함수는 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">제한된 API</span></a>의 일부가 아닙니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_VectorcallMethod">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject_VectorcallMethod</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *name</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *const<em> *args</em>, size_t<em> nargsf</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *kwnames</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_VectorcallMethod" title="정의 주소">¶</a></dt>
<dd><p>Call a method using the vectorcall calling convention. The name of the method
is given as a Python string <em>name</em>. The object whose method is called is
<em>args[0]</em>, and the <em>args</em> array starting at <em>args[1]</em> represents the arguments
of the call. There must be at least one positional argument.
<em>nargsf</em> is the number of positional arguments including <em>args[0]</em>,
plus <code class="xref py py-const docutils literal notranslate"><span class="pre">PY_VECTORCALL_ARGUMENTS_OFFSET</span></code> if the value of <code class="docutils literal notranslate"><span class="pre">args[0]</span></code> may
temporarily be changed. Keyword arguments can be passed just like in
<a class="reference internal" href="#c.PyObject_Vectorcall" title="PyObject_Vectorcall"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Vectorcall()</span></code></a>.</p>
<p>If the object has the <a class="reference internal" href="typeobj.html#Py_TPFLAGS_METHOD_DESCRIPTOR" title="Py_TPFLAGS_METHOD_DESCRIPTOR"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_METHOD_DESCRIPTOR</span></code></a> feature,
this will call the unbound method object with the full
<em>args</em> vector as arguments.</p>
<p>성공하면 호출 결과를 반환하고, 실패하면 예외를 발생시키고 <em>NULL</em>을 반환합니다.</p>
<p>이 함수는 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">제한된 API</span></a>의 일부가 아닙니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="call-support-api">
<h2>Call Support API<a class="headerlink" href="#call-support-api" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="c.PyCallable_Check">
int <code class="sig-name descname">PyCallable_Check</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyCallable_Check" title="정의 주소">¶</a></dt>
<dd><p>Determine if the object <em>o</em> is callable.  Return <code class="docutils literal notranslate"><span class="pre">1</span></code> if the object is callable
and <code class="docutils literal notranslate"><span class="pre">0</span></code> otherwise.  This function always succeeds.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">호출 프로토콜</a><ul>
<li><a class="reference internal" href="#the-tp-call-protocol"><em>tp_call</em> 프로토콜</a></li>
<li><a class="reference internal" href="#the-vectorcall-protocol">벡터콜(Vectorcall) 프로토콜</a><ul>
<li><a class="reference internal" href="#recursion-control">재귀 제어</a></li>
<li><a class="reference internal" href="#vectorcall-support-api">벡터콜 지원 API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#object-calling-api">객체 호출 API</a></li>
<li><a class="reference internal" href="#call-support-api">Call Support API</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="object.html"
                        title="이전 장">객체 프로토콜</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="number.html"
                        title="다음 장">숫자 프로토콜</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="number.html" title="숫자 프로토콜"
             >다음</a> |</li>
        <li class="right" >
          <a href="object.html" title="객체 프로토콜"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="abstract.html" >추상 객체 계층</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>