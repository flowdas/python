
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>유니코드 객체와 코덱 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="튜플 객체" href="tuple.html" />
    <link rel="prev" title="바이트 배열 객체" href="bytearray.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/c-api/unicode.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="tuple.html" title="튜플 객체"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="bytearray.html" title="바이트 배열 객체"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="concrete.html" accesskey="U">구상 객체 계층</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="unicode-objects-and-codecs">
<span id="unicodeobjects"></span><h1>유니코드 객체와 코덱<a class="headerlink" href="#unicode-objects-and-codecs" title="제목 주소">¶</a></h1>
<div class="section" id="unicode-objects">
<h2>유니코드 객체<a class="headerlink" href="#unicode-objects" title="제목 주소">¶</a></h2>
<p>파이썬 3.3에서 <span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0393"><strong>PEP 393</strong></a>을 구현한 이후, 유니코드 객체는 내부적으로 다양한 표현을 사용하여 전체 유니코드 문자 범위를 처리하면서 메모리 효율성을 유지합니다. 모든 코드 포인트가 128, 256 또는 65536 미만인 문자열에 대한 특별한 경우가 있습니다; 그렇지 않으면, 코드 포인트는 1114112 (전체 유니코드 범위) 미만이어야 합니다.</p>
<p><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a>와 UTF-8 표현은 요청시 만들어지고 유니코드 객체에 캐시됩니다. <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> 표현은 폐지되었으며 비효율적입니다; 성능이나 메모리에 민감한 상황에서는 피해야합니다.</p>
<p>이전 API와 새 API 간의 전환으로 인해, 유니코드 객체는 만들어진 방법에 따라 내부적으로 두 가지 상태가 될 수 있습니다:</p>
<ul class="simple">
<li><p>&quot;규범적(canonical)&quot; 유니코드 객체는 폐지되지 않은 유니코드 API에 의해 만들어진 모든 객체입니다. 구현에서 허용하는 가장 효율적인 표현을 사용합니다.</p></li>
<li><p>&quot;레거시&quot; 유니코드 객체는 폐지된 API 중 하나(일반적으로 <a class="reference internal" href="#c.PyUnicode_FromUnicode" title="PyUnicode_FromUnicode"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromUnicode()</span></code></a>)를 통해 만들어지고 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> 표현만 포함합니다; 다른 API를 호출하기 전에 이들에 대해 <a class="reference internal" href="#c.PyUnicode_READY" title="PyUnicode_READY"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READY()</span></code></a>를 호출해야 합니다.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>&quot;레거시&quot; 유니코드 객체는 폐지된 API와 함께 파이썬 3.12에서 제거됩니다. 그 이후로 모든 유니코드 객체는 &quot;규범적&quot;이 됩니다. 자세한 정보는 <span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0623"><strong>PEP 623</strong></a>을 참조하십시오.</p>
</div>
<div class="section" id="unicode-type">
<h3>유니코드 형<a class="headerlink" href="#unicode-type" title="제목 주소">¶</a></h3>
<p>다음은 파이썬에서 유니코드 구현에 사용되는 기본 유니코드 객체 형입니다:</p>
<dl class="type">
<dt id="c.Py_UCS4">
<code class="sig-name descname">Py_UCS4</code><a class="headerlink" href="#c.Py_UCS4" title="정의 주소">¶</a></dt>
<dt id="c.Py_UCS2">
<code class="sig-name descname">Py_UCS2</code><a class="headerlink" href="#c.Py_UCS2" title="정의 주소">¶</a></dt>
<dt id="c.Py_UCS1">
<code class="sig-name descname">Py_UCS1</code><a class="headerlink" href="#c.Py_UCS1" title="정의 주소">¶</a></dt>
<dd><p>이 형들은 각각 32비트, 16비트 및 8비트의 문자를 포함하기에 충분한 부호 없는 정수 형을 위한 typedef 입니다. 단일 유니코드 문자를 처리할 때는, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UCS4</span></code></a>를 사용하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="type">
<dt id="c.Py_UNICODE">
<code class="sig-name descname">Py_UNICODE</code><a class="headerlink" href="#c.Py_UNICODE" title="정의 주소">¶</a></dt>
<dd><p>이것은 플랫폼에 따라 16비트 형이나 32비트 형인 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code>의 typedef 입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>이전 버전에서, 이것은 빌드 시 파이썬의 &quot;내로우(narrow)&quot;나 &quot;와이드(wide)&quot; 유니코드 버전 중 어느 것을 선택했는지에 따라 16비트 형이나 32비트 형이었습니다.</p>
</div>
</dd></dl>

<dl class="type">
<dt id="c.PyASCIIObject">
<code class="sig-name descname">PyASCIIObject</code><a class="headerlink" href="#c.PyASCIIObject" title="정의 주소">¶</a></dt>
<dt id="c.PyCompactUnicodeObject">
<code class="sig-name descname">PyCompactUnicodeObject</code><a class="headerlink" href="#c.PyCompactUnicodeObject" title="정의 주소">¶</a></dt>
<dt id="c.PyUnicodeObject">
<code class="sig-name descname">PyUnicodeObject</code><a class="headerlink" href="#c.PyUnicodeObject" title="정의 주소">¶</a></dt>
<dd><p>이 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> 서브 형들은 파이썬 유니코드 객체를 나타냅니다. 거의 모든 경우에, 유니코드 객체를 처리하는 모든 API 함수가 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> 포인터를 취하고 반환하므로 직접 사용해서는 안됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="var">
<dt id="c.PyUnicode_Type">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a> <code class="sig-name descname">PyUnicode_Type</code><a class="headerlink" href="#c.PyUnicode_Type" title="정의 주소">¶</a></dt>
<dd><p>이 <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 인스턴스는 파이썬 유니코드 형을 나타냅니다. 파이썬 코드에 <code class="docutils literal notranslate"><span class="pre">str</span></code>로 노출됩니다.</p>
</dd></dl>

<p>다음 API는 실제로는 C 매크로이며 빠른 검사를 수행하고 유니코드 객체의 내부 읽기 전용 데이터에 액세스하는 데 사용할 수 있습니다:</p>
<dl class="function">
<dt id="c.PyUnicode_Check">
int <code class="sig-name descname">PyUnicode_Check</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Check" title="정의 주소">¶</a></dt>
<dd><p>객체 <em>o</em>가 유니코드 객체이거나 유니코드 서브 형의 인스턴스이면 참을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_CheckExact">
int <code class="sig-name descname">PyUnicode_CheckExact</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_CheckExact" title="정의 주소">¶</a></dt>
<dd><p>객체 <em>o</em>가 유니코드 객체이지만, 서브 형의 인스턴스가 아니면 참을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_READY">
int <code class="sig-name descname">PyUnicode_READY</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_READY" title="정의 주소">¶</a></dt>
<dd><p>문자열 객체 <em>o</em>가 &quot;규범적(canonical)&quot; 표현인지 확인합니다. 이것은 아래에 설명된 액세스 매크로를 사용하기 전에 필요합니다.</p>
<p>성공 시 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환하고, 실패 시 예외를 설정하면서 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환하는데, 특히 메모리 할당이 실패하면 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.10, will be removed in version 3.12: </span>이 API는 <a class="reference internal" href="#c.PyUnicode_FromUnicode" title="PyUnicode_FromUnicode"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromUnicode()</span></code></a>와 함께 제거됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GET_LENGTH">
Py_ssize_t <code class="sig-name descname">PyUnicode_GET_LENGTH</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GET_LENGTH" title="정의 주소">¶</a></dt>
<dd><p>유니코드 문자열의 길이를 코드 포인트로 반환합니다. <em>o</em>는 &quot;규범적(canonical)&quot; 표현의 유니코드 객체여야 합니다 (검사하지 않습니다).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_1BYTE_DATA">
<a class="reference internal" href="#c.Py_UCS1" title="Py_UCS1">Py_UCS1</a>* <code class="sig-name descname">PyUnicode_1BYTE_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_1BYTE_DATA" title="정의 주소">¶</a></dt>
<dt id="c.PyUnicode_2BYTE_DATA">
<a class="reference internal" href="#c.Py_UCS2" title="Py_UCS2">Py_UCS2</a>* <code class="sig-name descname">PyUnicode_2BYTE_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_2BYTE_DATA" title="정의 주소">¶</a></dt>
<dt id="c.PyUnicode_4BYTE_DATA">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a>* <code class="sig-name descname">PyUnicode_4BYTE_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_4BYTE_DATA" title="정의 주소">¶</a></dt>
<dd><p>직접 문자 액세스를 위해 UCS1, UCS2 또는 UCS4 정수 형으로 캐스트 된 규범적(canonical) 표현에 대한 포인터를 반환합니다. 규범적(canonical) 표현이 올바른 문자 크기인지 검사하지 않습니다; <a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_KIND()</span></code></a>를 사용하여 올바른 매크로를 선택하십시오. 이것을 액세스하기 전에 <a class="reference internal" href="#c.PyUnicode_READY" title="PyUnicode_READY"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READY()</span></code></a>가 호출되었어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.PyUnicode_WCHAR_KIND">
<code class="sig-name descname">PyUnicode_WCHAR_KIND</code><a class="headerlink" href="#c.PyUnicode_WCHAR_KIND" title="정의 주소">¶</a></dt>
<dt id="c.PyUnicode_1BYTE_KIND">
<code class="sig-name descname">PyUnicode_1BYTE_KIND</code><a class="headerlink" href="#c.PyUnicode_1BYTE_KIND" title="정의 주소">¶</a></dt>
<dt id="c.PyUnicode_2BYTE_KIND">
<code class="sig-name descname">PyUnicode_2BYTE_KIND</code><a class="headerlink" href="#c.PyUnicode_2BYTE_KIND" title="정의 주소">¶</a></dt>
<dt id="c.PyUnicode_4BYTE_KIND">
<code class="sig-name descname">PyUnicode_4BYTE_KIND</code><a class="headerlink" href="#c.PyUnicode_4BYTE_KIND" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_KIND()</span></code></a> 매크로의 값을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.10, will be removed in version 3.12: </span><code class="docutils literal notranslate"><span class="pre">PyUnicode_WCHAR_KIND</span></code>는 폐지되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_KIND">
int <code class="sig-name descname">PyUnicode_KIND</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_KIND" title="정의 주소">¶</a></dt>
<dd><p>이 유니코드 객체가 데이터를 저장하는 데 사용하는 문자 당 바이트 수를 나타내는 PyUnicode 종류 상수 (위를 참조하십시오) 중 하나를 반환합니다. <em>o</em>는 &quot;규범적(canonical)&quot; 표현의 유니코드 객체여야 합니다 (검사하지 않습니다).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DATA">
void* <code class="sig-name descname">PyUnicode_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DATA" title="정의 주소">¶</a></dt>
<dd><p>원시 유니코드 버퍼에 대한 void 포인터를 반환합니다. <em>o</em>는 &quot;규범적(canonical)&quot; 표현의 유니코드 객체여야 합니다 (검사하지 않습니다).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_WRITE">
void <code class="sig-name descname">PyUnicode_WRITE</code><span class="sig-paren">(</span>int<em> kind</em>, void<em> *data</em>, Py_ssize_t<em> index</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_WRITE" title="정의 주소">¶</a></dt>
<dd><p>규범적(canonical) 표현 <em>data</em>(<a class="reference internal" href="#c.PyUnicode_DATA" title="PyUnicode_DATA"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DATA()</span></code></a>로 얻은대로)에 씁니다. 이 매크로는 온전성 검사(sanity checks)를 수행하지 않으며 루프에서 사용하기 위한 것입니다. 호출자는 다른 매크로 호출에서 얻은대로 <em>kind</em> 값과 <em>data</em> 포인터를 캐시해야 합니다. <em>index</em>는 문자열의 인덱스(0에서 시작합니다)이고 <em>value</em>는 해당 위치에 기록되어야 하는 새 코드 포인트 값입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_READ">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a> <code class="sig-name descname">PyUnicode_READ</code><span class="sig-paren">(</span>int<em> kind</em>, void<em> *data</em>, Py_ssize_t<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_READ" title="정의 주소">¶</a></dt>
<dd><p>규범적(canonical) 표현 <em>data</em>(<a class="reference internal" href="#c.PyUnicode_DATA" title="PyUnicode_DATA"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DATA()</span></code></a>로 얻은대로)에서 코드 포인트를 읽습니다. 검사나 준비(ready) 호출이 수행되지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_READ_CHAR">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a> <code class="sig-name descname">PyUnicode_READ_CHAR</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em>, Py_ssize_t<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_READ_CHAR" title="정의 주소">¶</a></dt>
<dd><p>&quot;규범적(canonical)&quot; 표현이어야 하는, 유니코드 객체 <em>o</em>에서 문자를 읽습니다. 여러 연속 읽기를 수행한다면 <a class="reference internal" href="#c.PyUnicode_READ" title="PyUnicode_READ"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READ()</span></code></a>보다 효율성이 떨어집니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_MAX_CHAR_VALUE">
<code class="sig-name descname">PyUnicode_MAX_CHAR_VALUE</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_MAX_CHAR_VALUE" title="정의 주소">¶</a></dt>
<dd><p>&quot;규범적(canonical)&quot; 표현이어야 하는, <em>o</em>를 기반으로 다른 문자열을 만드는 데 적합한 최대 코드 포인트를 반환합니다. 이것은 항상 근사치이지만 문자열을 이터레이트하는 것보다 효율적입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GET_SIZE">
Py_ssize_t <code class="sig-name descname">PyUnicode_GET_SIZE</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GET_SIZE" title="정의 주소">¶</a></dt>
<dd><p>폐지된 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 표현의 크기를 코드 단위로 반환합니다 (서로게이트 쌍을 2 단위로 포함합니다). <em>o</em>는 유니코드 객체여야 합니다 (검사하지 않습니다).</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>이전 스타일 유니코드 API의 일부입니다, <a class="reference internal" href="#c.PyUnicode_GET_LENGTH" title="PyUnicode_GET_LENGTH"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_GET_LENGTH()</span></code></a>를 사용하여 마이그레이션하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GET_DATA_SIZE">
Py_ssize_t <code class="sig-name descname">PyUnicode_GET_DATA_SIZE</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GET_DATA_SIZE" title="정의 주소">¶</a></dt>
<dd><p>폐지된 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 표현의 크기를 바이트 단위로 반환합니다. <em>o</em>는 유니코드 객체여야 합니다 (검사하지 않습니다).</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>이전 스타일 유니코드 API의 일부입니다, <a class="reference internal" href="#c.PyUnicode_GET_LENGTH" title="PyUnicode_GET_LENGTH"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_GET_LENGTH()</span></code></a>를 사용하여 마이그레이션하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AS_UNICODE">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <code class="sig-name descname">PyUnicode_AS_UNICODE</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AS_UNICODE" title="정의 주소">¶</a></dt>
<dt id="c.PyUnicode_AS_DATA">
const char* <code class="sig-name descname">PyUnicode_AS_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AS_DATA" title="정의 주소">¶</a></dt>
<dd><p>객체의 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 표현에 대한 포인터를 반환합니다. 반환된 버퍼는 항상 추가 널 코드 포인트로 끝납니다. 또한 내장된 널 코드 포인트를 포함할 수 있는데, 대부분의 C 함수에서 사용될 때 문자열이 잘리도록 합니다. <code class="docutils literal notranslate"><span class="pre">AS_DATA</span></code> 형식은 포인터를 <code class="xref c c-type docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code>로 캐스트합니다. <em>o</em> 인자는 유니코드 객체여야 합니다 (검사하지 않습니다).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>이 매크로는 이제 비효율적이고 -- 많은 경우에 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 표현이 존재하지 않고 만들어야 하기 때문에 -- 실패할 수 있습니다 (예외 설정과 함께 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다). 새 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_nBYTE_DATA()</span></code> 매크로를 사용하거나 <a class="reference internal" href="#c.PyUnicode_WRITE" title="PyUnicode_WRITE"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_WRITE()</span></code></a>나 <a class="reference internal" href="#c.PyUnicode_READ" title="PyUnicode_READ"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READ()</span></code></a>를 사용하도록 코드를 이식하십시오.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>이전 스타일 유니코드 API의 일부입니다. <code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_nBYTE_DATA()</span></code> 매크로 계열을 사용하도록 마이그레이션하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_IsIdentifier">
int <code class="sig-name descname">PyUnicode_IsIdentifier</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_IsIdentifier" title="정의 주소">¶</a></dt>
<dd><p>언어 정의에 따라 문자열이 유효한 식별자이면 <code class="docutils literal notranslate"><span class="pre">1</span></code>를 반환합니다, 섹션 <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">식별자와 키워드</span></a>. 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>문자열이 준비(ready)되지 않았을 때, 이 함수는 더는 <a class="reference internal" href="sys.html#c.Py_FatalError" title="Py_FatalError"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FatalError()</span></code></a>를 호출하지 않습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="unicode-character-properties">
<h3>유니코드 문자 속성<a class="headerlink" href="#unicode-character-properties" title="제목 주소">¶</a></h3>
<p>유니코드는 다양한 문자 속성을 제공합니다. 가장 자주 필요한 것은 파이썬 구성에 따라 C 함수에 매핑되는 이러한 매크로를 통해 사용할 수 있습니다.</p>
<dl class="function">
<dt id="c.Py_UNICODE_ISSPACE">
int <code class="sig-name descname">Py_UNICODE_ISSPACE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISSPACE" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 공백 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISLOWER">
int <code class="sig-name descname">Py_UNICODE_ISLOWER</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISLOWER" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 소문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISUPPER">
int <code class="sig-name descname">Py_UNICODE_ISUPPER</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISUPPER" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 대문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISTITLE">
int <code class="sig-name descname">Py_UNICODE_ISTITLE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISTITLE" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 제목 케이스 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISLINEBREAK">
int <code class="sig-name descname">Py_UNICODE_ISLINEBREAK</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISLINEBREAK" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 줄 바꿈 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISDECIMAL">
int <code class="sig-name descname">Py_UNICODE_ISDECIMAL</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISDECIMAL" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 10진수 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISDIGIT">
int <code class="sig-name descname">Py_UNICODE_ISDIGIT</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISDIGIT" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 디짓(digit) 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISNUMERIC">
int <code class="sig-name descname">Py_UNICODE_ISNUMERIC</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISNUMERIC" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 숫자(numeric) 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISALPHA">
int <code class="sig-name descname">Py_UNICODE_ISALPHA</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISALPHA" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 알파벳 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISALNUM">
int <code class="sig-name descname">Py_UNICODE_ISALNUM</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISALNUM" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 영숫자 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISPRINTABLE">
int <code class="sig-name descname">Py_UNICODE_ISPRINTABLE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISPRINTABLE" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 인쇄 가능한 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다. 인쇄할 수 없는 문자는, 인쇄 가능한 것으로 간주하는 ASCII 스페이스(0x20)를 제외하고, 유니코드 문자 데이터베이스에서 &quot;Other&quot;나 &quot;Separator&quot;로 정의된 문자입니다. (이 문맥에서 인쇄 가능한 문자는 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a>이 문자열에대해 호출될 때 이스케이프되지 않아야하는 문자임에 유의하십시오. <a class="reference internal" href="../library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>이나 <a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a>에 기록된 문자열의 처리와 관련이 없습니다.)</p>
</dd></dl>

<p>다음 API는 빠른 직접 문자 변환에 사용할 수 있습니다:</p>
<dl class="function">
<dt id="c.Py_UNICODE_TOLOWER">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a> <code class="sig-name descname">Py_UNICODE_TOLOWER</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TOLOWER" title="정의 주소">¶</a></dt>
<dd><p>소문자로 변환된 문자 <em>ch</em>를 반환합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지: </span>이 함수는 간단한 케이스 매핑을 사용합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TOUPPER">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a> <code class="sig-name descname">Py_UNICODE_TOUPPER</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TOUPPER" title="정의 주소">¶</a></dt>
<dd><p>대문자로 변환된 문자 <em>ch</em>를 반환합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지: </span>이 함수는 간단한 케이스 매핑을 사용합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TOTITLE">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a> <code class="sig-name descname">Py_UNICODE_TOTITLE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TOTITLE" title="정의 주소">¶</a></dt>
<dd><p>제목 케이스로 변환된 문자 <em>ch</em>를 반환합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지: </span>이 함수는 간단한 케이스 매핑을 사용합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TODECIMAL">
int <code class="sig-name descname">Py_UNICODE_TODECIMAL</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TODECIMAL" title="정의 주소">¶</a></dt>
<dd><p>10진 양의 정수로 변환된 문자 <em>ch</em>를 반환합니다. 이것이 불가능하면 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다. 이 매크로는 예외를 발생시키지 않습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TODIGIT">
int <code class="sig-name descname">Py_UNICODE_TODIGIT</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TODIGIT" title="정의 주소">¶</a></dt>
<dd><p>한 자리 정수로 변환된 문자 <em>ch</em>를 반환합니다. 이것이 불가능하면 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다. 이 매크로는 예외를 발생시키지 않습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TONUMERIC">
double <code class="sig-name descname">Py_UNICODE_TONUMERIC</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TONUMERIC" title="정의 주소">¶</a></dt>
<dd><p>double로 변환된 문자 <em>ch</em>를 반환합니다. 이것이 불가능하면 <code class="docutils literal notranslate"><span class="pre">-1.0</span></code>을 반환합니다. 이 매크로는 예외를 발생시키지 않습니다.</p>
</dd></dl>

<p>다음 API를 사용하여 서로게이트를 다룰 수 있습니다:</p>
<dl class="macro">
<dt id="c.Py_UNICODE_IS_SURROGATE">
<code class="sig-name descname">Py_UNICODE_IS_SURROGATE</code><span class="sig-paren">(</span>ch<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_IS_SURROGATE" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 서로게이트인지 확인합니다 (<code class="docutils literal notranslate"><span class="pre">0xD800</span> <span class="pre">&lt;=</span> <span class="pre">ch</span> <span class="pre">&lt;=</span> <span class="pre">0xDFFF</span></code>).</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_UNICODE_IS_HIGH_SURROGATE">
<code class="sig-name descname">Py_UNICODE_IS_HIGH_SURROGATE</code><span class="sig-paren">(</span>ch<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_IS_HIGH_SURROGATE" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 상위 서로게이트인지 확인합니다 (<code class="docutils literal notranslate"><span class="pre">0xD800</span> <span class="pre">&lt;=</span> <span class="pre">ch</span> <span class="pre">&lt;=</span> <span class="pre">0xDBFF</span></code>).</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_UNICODE_IS_LOW_SURROGATE">
<code class="sig-name descname">Py_UNICODE_IS_LOW_SURROGATE</code><span class="sig-paren">(</span>ch<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_IS_LOW_SURROGATE" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 하위 서로게이트인지 확인합니다 (<code class="docutils literal notranslate"><span class="pre">0xDC00</span> <span class="pre">&lt;=</span> <span class="pre">ch</span> <span class="pre">&lt;=</span> <span class="pre">0xDFFF</span></code>).</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_UNICODE_JOIN_SURROGATES">
<code class="sig-name descname">Py_UNICODE_JOIN_SURROGATES</code><span class="sig-paren">(</span>high, low<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_JOIN_SURROGATES" title="정의 주소">¶</a></dt>
<dd><p>두 서로게이트 문자를 결합하고 단일 Py_UCS4 값을 반환합니다. <em>high</em>와 <em>low</em>는 각각 서로게이트 쌍의 선행과 후행 서로게이트입니다.</p>
</dd></dl>

</div>
<div class="section" id="creating-and-accessing-unicode-strings">
<h3>유니코드 문자열 생성과 액세스<a class="headerlink" href="#creating-and-accessing-unicode-strings" title="제목 주소">¶</a></h3>
<p>유니코드 객체를 만들고 기본 시퀀스 속성에 액세스하려면 다음 API를 사용하십시오:</p>
<dl class="function">
<dt id="c.PyUnicode_New">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_New</code><span class="sig-paren">(</span>Py_ssize_t<em> size</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> maxchar</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_New" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>새 유니코드 객체를 만듭니다. <em>maxchar</em>은 문자열에 배치할 실제 최대 코드 포인트여야 합니다. 근사값으로, 127, 255, 65535, 1114111 시퀀스에서 가장 가까운 값으로 올림할 수 있습니다.</p>
<p>이것은 새 유니코드 객체를 할당하는 데 권장되는 방법입니다. 이 함수를 사용하여 만든 객체는 크기를 조정할 수 없습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromKindAndData">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromKindAndData</code><span class="sig-paren">(</span>int<em> kind</em>, const void<em> *buffer</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromKindAndData" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>주어진 <em>kind</em>(가능한 값은 <a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_KIND()</span></code></a>에 의해 반환된 <a class="reference internal" href="#c.PyUnicode_1BYTE_KIND" title="PyUnicode_1BYTE_KIND"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyUnicode_1BYTE_KIND</span></code></a> 등입니다)로 새로운 유니코드 객체를 만듭니다. <em>buffer</em>는 kind에 따라 문자 당 1, 2 또는 4바이트의 <em>size</em> 단위의 배열을 가리켜야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromStringAndSize">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromStringAndSize</code><span class="sig-paren">(</span>const char<em> *u</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromStringAndSize" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>char 버퍼 <em>u</em>에서 유니코드 객체를 만듭니다. 바이트는 UTF-8로 인코딩된 것으로 해석됩니다. 버퍼는 새 객체에 복사됩니다. 버퍼가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 이니면, 반환 값은 공유 객체일 수 있습니다, 즉, 데이터 수정이 허용되지 않습니다.</p>
<p><em>u</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, 이 함수는 버퍼가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정된 <a class="reference internal" href="#c.PyUnicode_FromUnicode" title="PyUnicode_FromUnicode"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromUnicode()</span></code></a>처럼 작동합니다. 이 사용법은 폐지되었고 <a class="reference internal" href="#c.PyUnicode_New" title="PyUnicode_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_New()</span></code></a>로 대체되었습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">PyUnicode_FromString</code><span class="sig-paren">(</span>const char<em> *u</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>UTF-8로 인코딩 된 널-종료 char 버퍼 <em>u</em>에서 유니코드 객체를 만듭니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromFormat">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromFormat</code><span class="sig-paren">(</span>const char<em> *format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromFormat" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>C <code class="xref c c-func docutils literal notranslate"><span class="pre">printf()</span></code>-스타일 <em>format</em> 문자열과 가변 개수의 인자를 취해서, 결과 파이썬 유니코드 문자열의 크기를 계산하고 포맷된 값이 들어간 문자열을 반환합니다. 변수 인자는 C 형이어야 하며 <em>format</em> ASCII 인코딩된 문자열의 포맷 문자와 정확히 일치해야합니다. 다음 포맷 문자가 허용됩니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 28%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>포맷 문자</p></th>
<th class="head"><p>형</p></th>
<th class="head"><p>주석</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%%</span></code></p></td>
<td><p><em>n/a</em></p></td>
<td><p>리터럴 % 문자.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%c</span></code></p></td>
<td><p>int</p></td>
<td><p>C int로 표현된, 단일 문자.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%d</span></code></p></td>
<td><p>int</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%d&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id1">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%u</span></code></p></td>
<td><p>unsigned int</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%u&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id2">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%ld</span></code></p></td>
<td><p>long</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%ld&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id3">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%li</span></code></p></td>
<td><p>long</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%li&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id4">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%lu</span></code></p></td>
<td><p>unsigned long</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%lu&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id5">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%lld</span></code></p></td>
<td><p>long long</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%lld&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id6">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%lli</span></code></p></td>
<td><p>long long</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%lli&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id7">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%llu</span></code></p></td>
<td><p>unsigned long long</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%llu&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id8">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%zd</span></code></p></td>
<td><p>Py_ssize_t</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%zd&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id9">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%zi</span></code></p></td>
<td><p>Py_ssize_t</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%zi&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id10">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%zu</span></code></p></td>
<td><p>size_t</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%zu&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id11">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%i</span></code></p></td>
<td><p>int</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%i&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id12">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%x</span></code></p></td>
<td><p>int</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%x&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id13">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%s</span></code></p></td>
<td><p>const char*</p></td>
<td><p>널-종료 C 문자 배열.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%p</span></code></p></td>
<td><p>const void*</p></td>
<td><p>C 포인터의 16진수 표현. 플랫폼의 <code class="docutils literal notranslate"><span class="pre">printf</span></code>가 산출하는 내용에 관계없이 리터럴 <code class="docutils literal notranslate"><span class="pre">0x</span></code>로 시작하는 것이 보장된다는 점을 제외하면 거의 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%p&quot;)</span></code>와 동등합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%A</span></code></p></td>
<td><p>PyObject*</p></td>
<td><p><a class="reference internal" href="../library/functions.html#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a>를 호출한 결과.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%U</span></code></p></td>
<td><p>PyObject*</p></td>
<td><p>유니코드 객체.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%V</span></code></p></td>
<td><p>PyObject*,
const char*</p></td>
<td><p>유니코드 객체(<code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 수 있습니다)와 두 번째 매개 변수로서 널-종료 C 문자 배열 (첫 번째 매개 변수가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면 사용됩니다).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%S</span></code></p></td>
<td><p>PyObject*</p></td>
<td><p><a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Str()</span></code></a>을 호출한 결과.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%R</span></code></p></td>
<td><p>PyObject*</p></td>
<td><p><a class="reference internal" href="object.html#c.PyObject_Repr" title="PyObject_Repr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Repr()</span></code></a>을 호출한 결과.</p></td>
</tr>
</tbody>
</table>
<p>인식할 수 없는 포맷 문자는 나머지 포맷 문자열이 모두 결과 문자열에 그대로 복사되고, 추가 인자는 버려지도록 합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>너비 포매터 단위는 바이트가 아닌 문자 수입니다. 정밀도 포매터 단위는 <code class="docutils literal notranslate"><span class="pre">&quot;%s&quot;</span></code>와 <code class="docutils literal notranslate"><span class="pre">&quot;%V&quot;</span></code>의 경우는 바이트 수이고 (<code class="docutils literal notranslate"><span class="pre">PyObject*</span></code> 인자가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면), <code class="docutils literal notranslate"><span class="pre">&quot;%A&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%U&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%S&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%R&quot;</span></code> 및 <code class="docutils literal notranslate"><span class="pre">&quot;%V&quot;</span></code>의 경우 문자 수입니다 (<code class="docutils literal notranslate"><span class="pre">PyObject*</span></code> 인자가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니면).</p>
</div>
<dl class="footnote brackets">
<dt class="label" id="id14"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>,<a href="#id3">3</a>,<a href="#id4">4</a>,<a href="#id5">5</a>,<a href="#id6">6</a>,<a href="#id7">7</a>,<a href="#id8">8</a>,<a href="#id9">9</a>,<a href="#id10">10</a>,<a href="#id11">11</a>,<a href="#id12">12</a>,<a href="#id13">13</a>)</span></dt>
<dd><p>정수 지정자 (d, u, ld, li, lu, lld, lli, llu, zd, zi, zu, i, x) 의 경우: 0-변환 플래그는 정밀도가 제공되는 경우에도 적용됩니다.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><code class="docutils literal notranslate"><span class="pre">&quot;%lld&quot;</span></code>와 <code class="docutils literal notranslate"><span class="pre">&quot;%llu&quot;</span></code>에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><code class="docutils literal notranslate"><span class="pre">&quot;%li&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%lli&quot;</span></code> 및 <code class="docutils literal notranslate"><span class="pre">&quot;%zi&quot;</span></code>에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">&quot;%s&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%A&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%U&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%V&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%S&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%R&quot;</span></code>에 대한 너비와 정밀도 포매터 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromFormatV">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromFormatV</code><span class="sig-paren">(</span>const char<em> *format</em>, va_list<em> vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromFormatV" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>정확히 두 개의 인자를 취한다는 점을 제외하면 <a class="reference internal" href="#c.PyUnicode_FromFormat" title="PyUnicode_FromFormat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromFormat()</span></code></a>과 동일합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromEncodedObject">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromEncodedObject</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em>, const char<em> *encoding</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromEncodedObject" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>인코딩 된 객체 <em>obj</em>를 유니코드 객체로 디코딩합니다.</p>
<p><a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 및 기타 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>는 주어진 <em>encoding</em>에 따라 <em>errors</em>로 정의한 에러 처리를 사용하여 디코딩됩니다. 둘 다 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 될 수 있고, 이 경우 인터페이스는 기본값을 사용합니다 (자세한 내용은 <a class="reference internal" href="#builtincodecs"><span class="std std-ref">Built-in Codecs</span></a>를 참조하십시오).</p>
<p>유니코드 객체를 포함한 다른 모든 객체는 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 설정되도록 합니다.</p>
<p>API는 에러가 있으면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다. 호출자는 반환된 객체의 참조 횟수를 감소시킬 책임이 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GetLength">
Py_ssize_t <code class="sig-name descname">PyUnicode_GetLength</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GetLength" title="정의 주소">¶</a></dt>
<dd><p>유니코드 객체의 길이를 코드 포인트로 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_CopyCharacters">
Py_ssize_t <code class="sig-name descname">PyUnicode_CopyCharacters</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *to</em>, Py_ssize_t<em> to_start</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *from</em>, Py_ssize_t<em> from_start</em>, Py_ssize_t<em> how_many</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_CopyCharacters" title="정의 주소">¶</a></dt>
<dd><p>한 유니코드 객체에서 다른 객체로 문자를 복사합니다. 이 함수는 필요하면 문자 변환을 수행하고 가능하면 <code class="xref c c-func docutils literal notranslate"><span class="pre">memcpy()</span></code>로 폴백합니다. 에러 시 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환하고 예외를 설정합니다, 그렇지 않으면 복사된 문자 수를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Fill">
Py_ssize_t <code class="sig-name descname">PyUnicode_Fill</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> length</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> fill_char</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Fill" title="정의 주소">¶</a></dt>
<dd><p>문자로 문자열을 채웁니다: <em>fill_char</em>을 <code class="docutils literal notranslate"><span class="pre">unicode[start:start+length]</span></code>에 씁니다.</p>
<p><em>fill_char</em>이 문자열 최대 문자보다 크거나, 문자열에 둘 이상의 참조가 있으면 실패합니다.</p>
<p>기록된 문자 수를 반환하거나, 에러 시 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환하고 예외를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_WriteChar">
int <code class="sig-name descname">PyUnicode_WriteChar</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> index</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> character</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_WriteChar" title="정의 주소">¶</a></dt>
<dd><p>문자열에 문자를 씁니다. 문자열은 <a class="reference internal" href="#c.PyUnicode_New" title="PyUnicode_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_New()</span></code></a>를 통해 만들었어야 합니다. 유니코드 문자열은 불변이므로, 문자열을 공유하거나 아직 해시하지 않아야합니다.</p>
<p>이 함수는 <em>unicode</em>가 유니코드 객체인지, 인덱스가 범위를 벗어 났는지, 객체가 안전하게 수정될 수 있는지 (즉, 참조 횟수가 1인지) 확인합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_ReadChar">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a> <code class="sig-name descname">PyUnicode_ReadChar</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_ReadChar" title="정의 주소">¶</a></dt>
<dd><p>문자열에서 문자를 읽습니다. 이 함수는 매크로 버전 <a class="reference internal" href="#c.PyUnicode_READ_CHAR" title="PyUnicode_READ_CHAR"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READ_CHAR()</span></code></a>와 달리 <em>unicode</em>가 유니코드 객체이고 인덱스가 범위를 벗어 났는지 확인합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Substring">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Substring</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Substring" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>문자 인덱스 <em>start</em>(포함합니다)에서 문자 인덱스 <em>end</em>(제외합니다)까지 <em>str</em>의 하위 문자열을 반환합니다. 음수 인덱스는 지원되지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUCS4">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a>* <code class="sig-name descname">PyUnicode_AsUCS4</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *u</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> *buffer</em>, Py_ssize_t<em> buflen</em>, int<em> copy_null</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUCS4" title="정의 주소">¶</a></dt>
<dd><p><em>copy_null</em>이 설정되면, 널 문자를 포함하여 문자열 <em>u</em>를 UCS4 버퍼에 복사합니다. 에러 시 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환하고 예외를 설정합니다 (특히, <em>buflen</em>이 <em>u</em>의 길이보다 작으면 <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemError</span></code></a>). 성공하면 <em>buffer</em>가 반환됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUCS4Copy">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a>* <code class="sig-name descname">PyUnicode_AsUCS4Copy</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *u</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUCS4Copy" title="정의 주소">¶</a></dt>
<dd><p>문자열 <em>u</em>를 <a class="reference internal" href="memory.html#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>을 사용하여 할당된 새 UCS4 버퍼에 복사합니다. 이것이 실패하면, <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 반환되고 <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a>가 설정됩니다. 반환된 버퍼에는 항상 추가 널 코드 포인트가 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="deprecated-py-unicode-apis">
<h3>폐지된 Py_UNICODE API<a class="headerlink" href="#deprecated-py-unicode-apis" title="제목 주소">¶</a></h3>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0.</span></p>
</div>
<p>이 API 함수들은 <span class="target" id="index-12"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0393"><strong>PEP 393</strong></a> 구현에 의해 폐지되었습니다. 파이썬 3.x에서 제거되지 않기 때문에, 확장 모듈은 계속해서 사용할 수 있지만, 이제 그 사용으로 인해 성능과 메모리 문제가 있을 수 있음을 인식해야 합니다.</p>
<dl class="function">
<dt id="c.PyUnicode_FromUnicode">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromUnicode</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *u</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromUnicode" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object from the Py_UNICODE buffer <em>u</em> of the given size. <em>u</em>
may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> which causes the contents to be undefined. It is the user's
responsibility to fill in the needed data.  The buffer is copied into the new
object.</p>
<p>If the buffer is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the return value might be a shared object.
Therefore, modification of the resulting Unicode object is only allowed when
<em>u</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>If the buffer is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <a class="reference internal" href="#c.PyUnicode_READY" title="PyUnicode_READY"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READY()</span></code></a> must be called once the
string content has been filled before using any of the access macros such as
<a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_KIND()</span></code></a>.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>Part of the old-style Unicode API, please migrate to using
<a class="reference internal" href="#c.PyUnicode_FromKindAndData" title="PyUnicode_FromKindAndData"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromKindAndData()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_FromWideChar" title="PyUnicode_FromWideChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromWideChar()</span></code></a>, or
<a class="reference internal" href="#c.PyUnicode_New" title="PyUnicode_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_New()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUnicode">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <code class="sig-name descname">PyUnicode_AsUnicode</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUnicode" title="정의 주소">¶</a></dt>
<dd><p>Return a read-only pointer to the Unicode object's internal
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error. This will create the
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> representation of the object if it is not yet
available. The buffer is always terminated with an extra null code point.
Note that the resulting <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> string may also contain
embedded null code points, which would cause the string to be truncated when
used in most C functions.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>Part of the old-style Unicode API, please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsUCS4" title="PyUnicode_AsUCS4"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUCS4()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_AsWideChar" title="PyUnicode_AsWideChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsWideChar()</span></code></a>,
<a class="reference internal" href="#c.PyUnicode_ReadChar" title="PyUnicode_ReadChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_ReadChar()</span></code></a> or similar new APIs.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_TransformDecimalToASCII">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_TransformDecimalToASCII</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_TransformDecimalToASCII" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by replacing all decimal digits in
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> by ASCII digits 0--9
according to their decimal value.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception occurs.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUnicodeAndSize">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <code class="sig-name descname">PyUnicode_AsUnicodeAndSize</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> *size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUnicodeAndSize" title="정의 주소">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#c.PyUnicode_AsUnicode" title="PyUnicode_AsUnicode"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUnicode()</span></code></a>, but also saves the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_UNICODE()</span></code></a>
array length (excluding the extra null terminator) in <em>size</em>.
Note that the resulting <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> string
may contain embedded null code points, which would cause the string to be
truncated when used in most C functions.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>Part of the old-style Unicode API, please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsUCS4" title="PyUnicode_AsUCS4"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUCS4()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_AsWideChar" title="PyUnicode_AsWideChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsWideChar()</span></code></a>,
<a class="reference internal" href="#c.PyUnicode_ReadChar" title="PyUnicode_ReadChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_ReadChar()</span></code></a> or similar new APIs.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUnicodeCopy">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <code class="sig-name descname">PyUnicode_AsUnicodeCopy</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUnicodeCopy" title="정의 주소">¶</a></dt>
<dd><p>Create a copy of a Unicode string ending with a null code point. Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
and raise a <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a> exception on memory allocation failure,
otherwise return a new allocated buffer (use <a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> to free
the buffer). Note that the resulting <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> string may
contain embedded null code points, which would cause the string to be
truncated when used in most C functions.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<p>Please migrate to using <a class="reference internal" href="#c.PyUnicode_AsUCS4Copy" title="PyUnicode_AsUCS4Copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUCS4Copy()</span></code></a> or similar new APIs.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GetSize">
Py_ssize_t <code class="sig-name descname">PyUnicode_GetSize</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GetSize" title="정의 주소">¶</a></dt>
<dd><p>Return the size of the deprecated <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> representation, in
code units (this includes surrogate pairs as 2 units).</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>이전 스타일 유니코드 API의 일부입니다, <a class="reference internal" href="#c.PyUnicode_GET_LENGTH" title="PyUnicode_GET_LENGTH"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_GET_LENGTH()</span></code></a>를 사용하여 마이그레이션하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromObject">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromObject</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromObject" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Copy an instance of a Unicode subtype to a new true Unicode object if
necessary. If <em>obj</em> is already a true Unicode object (not a subtype),
return the reference with incremented refcount.</p>
<p>Objects other than Unicode or its subtypes will cause a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="locale-encoding">
<h3>Locale Encoding<a class="headerlink" href="#locale-encoding" title="제목 주소">¶</a></h3>
<p>The current locale encoding can be used to decode text from the operating
system.</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeLocaleAndSize">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeLocaleAndSize</code><span class="sig-paren">(</span>const char<em> *str</em>, Py_ssize_t<em> len</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeLocaleAndSize" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Decode a string from UTF-8 on Android and VxWorks, or from the current
locale encoding on other platforms. The supported
error handlers are <code class="docutils literal notranslate"><span class="pre">&quot;strict&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;surrogateescape&quot;</span></code>
(<span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a>). The decoder uses <code class="docutils literal notranslate"><span class="pre">&quot;strict&quot;</span></code> error handler if
<em>errors</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  <em>str</em> must end with a null character but
cannot contain embedded null characters.</p>
<p>Use <a class="reference internal" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="PyUnicode_DecodeFSDefaultAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeFSDefaultAndSize()</span></code></a> to decode a string from
<code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> (the locale encoding read at
Python startup).</p>
<p>This function ignores the Python UTF-8 mode.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>The <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> function.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>The function now also uses the current locale encoding for the
<code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> error handler, except on Android. Previously, <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a>
was used for the <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code>, and the current locale encoding was
used for <code class="docutils literal notranslate"><span class="pre">strict</span></code>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeLocale">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeLocale</code><span class="sig-paren">(</span>const char<em> *str</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeLocale" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Similar to <a class="reference internal" href="#c.PyUnicode_DecodeLocaleAndSize" title="PyUnicode_DecodeLocaleAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeLocaleAndSize()</span></code></a>, but compute the string
length using <code class="xref c c-func docutils literal notranslate"><span class="pre">strlen()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeLocale">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeLocale</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeLocale" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object to UTF-8 on Android and VxWorks, or to the current
locale encoding on other platforms. The
supported error handlers are <code class="docutils literal notranslate"><span class="pre">&quot;strict&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;surrogateescape&quot;</span></code>
(<span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a>). The encoder uses <code class="docutils literal notranslate"><span class="pre">&quot;strict&quot;</span></code> error handler if
<em>errors</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. Return a <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> object. <em>unicode</em> cannot
contain embedded null characters.</p>
<p>Use <a class="reference internal" href="#c.PyUnicode_EncodeFSDefault" title="PyUnicode_EncodeFSDefault"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeFSDefault()</span></code></a> to encode a string to
<code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> (the locale encoding read at
Python startup).</p>
<p>This function ignores the Python UTF-8 mode.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>The <a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EncodeLocale()</span></code></a> function.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>The function now also uses the current locale encoding for the
<code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> error handler, except on Android. Previously,
<a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EncodeLocale()</span></code></a>
was used for the <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code>, and the current locale encoding was
used for <code class="docutils literal notranslate"><span class="pre">strict</span></code>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="file-system-encoding">
<h3>File System Encoding<a class="headerlink" href="#file-system-encoding" title="제목 주소">¶</a></h3>
<p>To encode and decode file names and other environment strings,
<code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> should be used as the encoding, and
<code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> should be used as the error handler
(<span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a> and <span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0529"><strong>PEP 529</strong></a>). To encode file names to <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> during
argument parsing, the <code class="docutils literal notranslate"><span class="pre">&quot;O&amp;&quot;</span></code> converter should be used, passing
<a class="reference internal" href="#c.PyUnicode_FSConverter" title="PyUnicode_FSConverter"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FSConverter()</span></code></a> as the conversion function:</p>
<dl class="function">
<dt id="c.PyUnicode_FSConverter">
int <code class="sig-name descname">PyUnicode_FSConverter</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>*<em> obj</em>, void*<em> result</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FSConverter" title="정의 주소">¶</a></dt>
<dd><p>ParseTuple converter: encode <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> objects -- obtained directly or
through the <a class="reference internal" href="../library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> interface -- to <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> using
<a class="reference internal" href="#c.PyUnicode_EncodeFSDefault" title="PyUnicode_EncodeFSDefault"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeFSDefault()</span></code></a>; <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> objects are output as-is.
<em>result</em> must be a <a class="reference internal" href="bytes.html#c.PyBytesObject" title="PyBytesObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBytesObject*</span></code></a> which must be released when it is
no longer used.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<p>To decode file names to <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> during argument parsing, the <code class="docutils literal notranslate"><span class="pre">&quot;O&amp;&quot;</span></code>
converter should be used, passing <a class="reference internal" href="#c.PyUnicode_FSDecoder" title="PyUnicode_FSDecoder"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FSDecoder()</span></code></a> as the
conversion function:</p>
<dl class="function">
<dt id="c.PyUnicode_FSDecoder">
int <code class="sig-name descname">PyUnicode_FSDecoder</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>*<em> obj</em>, void*<em> result</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FSDecoder" title="정의 주소">¶</a></dt>
<dd><p>ParseTuple converter: decode <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> objects -- obtained either
directly or indirectly through the <a class="reference internal" href="../library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> interface -- to
<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> using <a class="reference internal" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="PyUnicode_DecodeFSDefaultAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeFSDefaultAndSize()</span></code></a>; <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>
objects are output as-is. <em>result</em> must be a <a class="reference internal" href="#c.PyUnicodeObject" title="PyUnicodeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyUnicodeObject*</span></code></a> which
must be released when it is no longer used.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeFSDefaultAndSize">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeFSDefaultAndSize</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Decode a string using <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> and the
<code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> error handler.</p>
<p>If <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> is not set, fall back to the
locale encoding.</p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> is initialized at startup from the
locale encoding and cannot be modified later. If you need to decode a string
from the current locale encoding, use
<a class="reference internal" href="#c.PyUnicode_DecodeLocaleAndSize" title="PyUnicode_DecodeLocaleAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeLocaleAndSize()</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>The <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> function.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>Use <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> error handler.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeFSDefault">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeFSDefault</code><span class="sig-paren">(</span>const char<em> *s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeFSDefault" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Decode a null-terminated string using <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code>
and the <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> error handler.</p>
<p>If <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> is not set, fall back to the
locale encoding.</p>
<p>Use <a class="reference internal" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="PyUnicode_DecodeFSDefaultAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeFSDefaultAndSize()</span></code></a> if you know the string length.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>Use <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> error handler.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeFSDefault">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeFSDefault</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeFSDefault" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object to <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> with the
<code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> error handler, and return
<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Note that the resulting <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> object may contain
null bytes.</p>
<p>If <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> is not set, fall back to the
locale encoding.</p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> is initialized at startup from the
locale encoding and cannot be modified later. If you need to encode a string
to the current locale encoding, use <a class="reference internal" href="#c.PyUnicode_EncodeLocale" title="PyUnicode_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeLocale()</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>The <a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EncodeLocale()</span></code></a> function.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>Use <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> error handler.</p>
</div>
</dd></dl>

</div>
<div class="section" id="wchar-t-support">
<h3>wchar_t Support<a class="headerlink" href="#wchar-t-support" title="제목 주소">¶</a></h3>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> support for platforms which support it:</p>
<dl class="function">
<dt id="c.PyUnicode_FromWideChar">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromWideChar</code><span class="sig-paren">(</span>const wchar_t<em> *w</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromWideChar" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object from the <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> buffer <em>w</em> of the given <em>size</em>.
Passing <code class="docutils literal notranslate"><span class="pre">-1</span></code> as the <em>size</em> indicates that the function must itself compute the length,
using wcslen.
Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsWideChar">
Py_ssize_t <code class="sig-name descname">PyUnicode_AsWideChar</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, wchar_t<em> *w</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsWideChar" title="정의 주소">¶</a></dt>
<dd><p>Copy the Unicode object contents into the <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> buffer <em>w</em>.  At most
<em>size</em> <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> characters are copied (excluding a possibly trailing
null termination character).  Return the number of <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> characters
copied or <code class="docutils literal notranslate"><span class="pre">-1</span></code> in case of an error.  Note that the resulting <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code>
string may or may not be null-terminated.  It is the responsibility of the caller
to make sure that the <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code> string is null-terminated in case this is
required by the application. Also, note that the <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code> string
might contain null characters, which would cause the string to be truncated
when used with most C functions.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsWideCharString">
wchar_t* <code class="sig-name descname">PyUnicode_AsWideCharString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> *size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsWideCharString" title="정의 주소">¶</a></dt>
<dd><p>Convert the Unicode object to a wide character string. The output string
always ends with a null character. If <em>size</em> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, write the number
of wide characters (excluding the trailing null termination character) into
<em>*size</em>. Note that the resulting <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> string might contain
null characters, which would cause the string to be truncated when used with
most C functions. If <em>size</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code> string
contains null characters a <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised.</p>
<p>Returns a buffer allocated by <code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Alloc()</span></code> (use
<a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> to free it) on success. On error, returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
and <em>*size</em> is undefined. Raises a <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a> if memory allocation
is failed.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Raises a <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> if <em>size</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code>
string contains null characters.</p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="built-in-codecs">
<span id="builtincodecs"></span><h2>Built-in Codecs<a class="headerlink" href="#built-in-codecs" title="제목 주소">¶</a></h2>
<p>Python provides a set of built-in codecs which are written in C for speed. All of
these codecs are directly usable via the following functions.</p>
<p>Many of the following APIs take two arguments encoding and errors, and they
have the same semantics as the ones of the built-in <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> string object
constructor.</p>
<p>Setting encoding to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> causes the default encoding to be used
which is UTF-8.  The file system calls should use
<a class="reference internal" href="#c.PyUnicode_FSConverter" title="PyUnicode_FSConverter"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FSConverter()</span></code></a> for encoding file names. This uses the
variable <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> internally. This
variable should be treated as read-only: on some systems, it will be a
pointer to a static string, on others, it will change at run-time
(such as when the application invokes setlocale).</p>
<p>Error handling is set by errors which may also be set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> meaning to use
the default handling defined for the codec.  Default error handling for all
built-in codecs is &quot;strict&quot; (<a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised).</p>
<p>The codecs all use a similar interface.  Only deviation from the following
generic ones are documented for simplicity.</p>
<div class="section" id="generic-codecs">
<h3>Generic Codecs<a class="headerlink" href="#generic-codecs" title="제목 주소">¶</a></h3>
<p>These are the generic codec APIs:</p>
<dl class="function">
<dt id="c.PyUnicode_Decode">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Decode</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *encoding</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Decode" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the encoded string <em>s</em>.
<em>encoding</em> and <em>errors</em> have the same meaning as the parameters of the same name
in the <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> built-in function.  The codec to be used is looked up
using the Python codec registry.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by
the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsEncodedString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsEncodedString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, const char<em> *encoding</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsEncodedString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object and return the result as Python bytes object.
<em>encoding</em> and <em>errors</em> have the same meaning as the parameters of the same
name in the Unicode <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a> method. The codec to be used is looked up
using the Python codec registry. Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by
the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Encode">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Encode</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *encoding</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Encode" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer <em>s</em> of the given <em>size</em> and return a Python
bytes object.  <em>encoding</em> and <em>errors</em> have the same meaning as the
parameters of the same name in the Unicode <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a> method.  The codec
to be used is looked up using the Python codec registry.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an
exception was raised by the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="utf-8-codecs">
<h3>UTF-8 Codecs<a class="headerlink" href="#utf-8-codecs" title="제목 주소">¶</a></h3>
<p>These are the UTF-8 codec APIs:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUTF8">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF8</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF8" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the UTF-8 encoded string
<em>s</em>. Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeUTF8Stateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF8Stateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF8Stateful" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>If <em>consumed</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, behave like <a class="reference internal" href="#c.PyUnicode_DecodeUTF8" title="PyUnicode_DecodeUTF8"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF8()</span></code></a>. If
<em>consumed</em> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, trailing incomplete UTF-8 byte sequences will not be
treated as an error. Those bytes will not be decoded and the number of bytes
that have been decoded will be stored in <em>consumed</em>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF8String">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsUTF8String</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF8String" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object using UTF-8 and return the result as Python bytes
object.  Error handling is &quot;strict&quot;.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was
raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF8AndSize">
const char* <code class="sig-name descname">PyUnicode_AsUTF8AndSize</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> *size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF8AndSize" title="정의 주소">¶</a></dt>
<dd><p>Return a pointer to the UTF-8 encoding of the Unicode object, and
store the size of the encoded representation (in bytes) in <em>size</em>.  The
<em>size</em> argument can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>; in this case no size will be stored.  The
returned buffer always has an extra null byte appended (not included in
<em>size</em>), regardless of whether there are any other null code points.</p>
<p>In the case of an error, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned with an exception set and no
<em>size</em> is stored.</p>
<p>This caches the UTF-8 representation of the string in the Unicode object, and
subsequent calls will return a pointer to the same buffer.  The caller is not
responsible for deallocating the buffer.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>The return type is now <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> rather of <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF8">
const char* <code class="sig-name descname">PyUnicode_AsUTF8</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF8" title="정의 주소">¶</a></dt>
<dd><p>As <a class="reference internal" href="#c.PyUnicode_AsUTF8AndSize" title="PyUnicode_AsUTF8AndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF8AndSize()</span></code></a>, but does not store the size.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>The return type is now <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> rather of <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUTF8">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUTF8</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUTF8" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer <em>s</em> of the given <em>size</em> using UTF-8 and
return a Python bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by
the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsUTF8String" title="PyUnicode_AsUTF8String"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF8String()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_AsUTF8AndSize" title="PyUnicode_AsUTF8AndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF8AndSize()</span></code></a> or
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="utf-32-codecs">
<h3>UTF-32 Codecs<a class="headerlink" href="#utf-32-codecs" title="제목 주소">¶</a></h3>
<p>These are the UTF-32 codec APIs:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUTF32">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF32</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> *byteorder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF32" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Decode <em>size</em> bytes from a UTF-32 encoded buffer string and return the
corresponding Unicode object.  <em>errors</em> (if non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>) defines the error
handling. It defaults to &quot;strict&quot;.</p>
<p>If <em>byteorder</em> is non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the decoder starts decoding using the given byte
order:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">little</span> <span class="n">endian</span>
<span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>  <span class="n">native</span> <span class="n">order</span>
<span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="mi">1</span><span class="o">:</span>  <span class="n">big</span> <span class="n">endian</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">*byteorder</span></code> is zero, and the first four bytes of the input data are a
byte order mark (BOM), the decoder switches to this byte order and the BOM is
not copied into the resulting Unicode string.  If <code class="docutils literal notranslate"><span class="pre">*byteorder</span></code> is <code class="docutils literal notranslate"><span class="pre">-1</span></code> or
<code class="docutils literal notranslate"><span class="pre">1</span></code>, any byte order mark is copied to the output.</p>
<p>After completion, <em>*byteorder</em> is set to the current byte order at the end
of input data.</p>
<p>If <em>byteorder</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the codec starts in native order mode.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeUTF32Stateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF32Stateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> *byteorder</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF32Stateful" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>If <em>consumed</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, behave like <a class="reference internal" href="#c.PyUnicode_DecodeUTF32" title="PyUnicode_DecodeUTF32"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF32()</span></code></a>. If
<em>consumed</em> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <a class="reference internal" href="#c.PyUnicode_DecodeUTF32Stateful" title="PyUnicode_DecodeUTF32Stateful"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF32Stateful()</span></code></a> will not treat
trailing incomplete UTF-32 byte sequences (such as a number of bytes not divisible
by four) as an error. Those bytes will not be decoded and the number of bytes
that have been decoded will be stored in <em>consumed</em>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF32String">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsUTF32String</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF32String" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Return a Python byte string using the UTF-32 encoding in native byte
order. The string always starts with a BOM mark.  Error handling is &quot;strict&quot;.
Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUTF32">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUTF32</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> byteorder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUTF32" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Return a Python bytes object holding the UTF-32 encoded value of the Unicode
data in <em>s</em>.  Output is written according to the following byte order:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">byteorder</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">little</span> <span class="n">endian</span>
<span class="n">byteorder</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>  <span class="n">native</span> <span class="n">byte</span> <span class="n">order</span> <span class="p">(</span><span class="n">writes</span> <span class="n">a</span> <span class="n">BOM</span> <span class="n">mark</span><span class="p">)</span>
<span class="n">byteorder</span> <span class="o">==</span> <span class="mi">1</span><span class="o">:</span>  <span class="n">big</span> <span class="n">endian</span>
</pre></div>
</div>
<p>If byteorder is <code class="docutils literal notranslate"><span class="pre">0</span></code>, the output string will always start with the Unicode BOM
mark (U+FEFF). In the other two modes, no BOM mark is prepended.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Py_UNICODE_WIDE</span></code> is not defined, surrogate pairs will be output
as a single code point.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsUTF32String" title="PyUnicode_AsUTF32String"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF32String()</span></code></a> or <a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="utf-16-codecs">
<h3>UTF-16 Codecs<a class="headerlink" href="#utf-16-codecs" title="제목 주소">¶</a></h3>
<p>These are the UTF-16 codec APIs:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUTF16">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF16</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> *byteorder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF16" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Decode <em>size</em> bytes from a UTF-16 encoded buffer string and return the
corresponding Unicode object.  <em>errors</em> (if non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>) defines the error
handling. It defaults to &quot;strict&quot;.</p>
<p>If <em>byteorder</em> is non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the decoder starts decoding using the given byte
order:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">little</span> <span class="n">endian</span>
<span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>  <span class="n">native</span> <span class="n">order</span>
<span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="mi">1</span><span class="o">:</span>  <span class="n">big</span> <span class="n">endian</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">*byteorder</span></code> is zero, and the first two bytes of the input data are a
byte order mark (BOM), the decoder switches to this byte order and the BOM is
not copied into the resulting Unicode string.  If <code class="docutils literal notranslate"><span class="pre">*byteorder</span></code> is <code class="docutils literal notranslate"><span class="pre">-1</span></code> or
<code class="docutils literal notranslate"><span class="pre">1</span></code>, any byte order mark is copied to the output (where it will result in
either a <code class="docutils literal notranslate"><span class="pre">\ufeff</span></code> or a <code class="docutils literal notranslate"><span class="pre">\ufffe</span></code> character).</p>
<p>After completion, <em>*byteorder</em> is set to the current byte order at the end
of input data.</p>
<p>If <em>byteorder</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the codec starts in native order mode.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeUTF16Stateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF16Stateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> *byteorder</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF16Stateful" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>If <em>consumed</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, behave like <a class="reference internal" href="#c.PyUnicode_DecodeUTF16" title="PyUnicode_DecodeUTF16"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF16()</span></code></a>. If
<em>consumed</em> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <a class="reference internal" href="#c.PyUnicode_DecodeUTF16Stateful" title="PyUnicode_DecodeUTF16Stateful"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF16Stateful()</span></code></a> will not treat
trailing incomplete UTF-16 byte sequences (such as an odd number of bytes or a
split surrogate pair) as an error. Those bytes will not be decoded and the
number of bytes that have been decoded will be stored in <em>consumed</em>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF16String">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsUTF16String</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF16String" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Return a Python byte string using the UTF-16 encoding in native byte
order. The string always starts with a BOM mark.  Error handling is &quot;strict&quot;.
Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUTF16">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUTF16</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> byteorder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUTF16" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Return a Python bytes object holding the UTF-16 encoded value of the Unicode
data in <em>s</em>.  Output is written according to the following byte order:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">byteorder</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">little</span> <span class="n">endian</span>
<span class="n">byteorder</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>  <span class="n">native</span> <span class="n">byte</span> <span class="n">order</span> <span class="p">(</span><span class="n">writes</span> <span class="n">a</span> <span class="n">BOM</span> <span class="n">mark</span><span class="p">)</span>
<span class="n">byteorder</span> <span class="o">==</span> <span class="mi">1</span><span class="o">:</span>  <span class="n">big</span> <span class="n">endian</span>
</pre></div>
</div>
<p>If byteorder is <code class="docutils literal notranslate"><span class="pre">0</span></code>, the output string will always start with the Unicode BOM
mark (U+FEFF). In the other two modes, no BOM mark is prepended.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Py_UNICODE_WIDE</span></code> is defined, a single <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> value may get
represented as a surrogate pair. If it is not defined, each <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a>
values is interpreted as a UCS-2 character.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsUTF16String" title="PyUnicode_AsUTF16String"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF16String()</span></code></a> or <a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="utf-7-codecs">
<h3>UTF-7 Codecs<a class="headerlink" href="#utf-7-codecs" title="제목 주소">¶</a></h3>
<p>These are the UTF-7 codec APIs:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUTF7">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF7</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF7" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the UTF-7 encoded string
<em>s</em>.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeUTF7Stateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF7Stateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF7Stateful" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>If <em>consumed</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, behave like <a class="reference internal" href="#c.PyUnicode_DecodeUTF7" title="PyUnicode_DecodeUTF7"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF7()</span></code></a>.  If
<em>consumed</em> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, trailing incomplete UTF-7 base-64 sections will not
be treated as an error.  Those bytes will not be decoded and the number of
bytes that have been decoded will be stored in <em>consumed</em>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUTF7">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUTF7</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, int<em> base64SetO</em>, int<em> base64WhiteSpace</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUTF7" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given size using UTF-7 and
return a Python bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by
the codec.</p>
<p>If <em>base64SetO</em> is nonzero, &quot;Set O&quot; (punctuation that has no otherwise
special meaning) will be encoded in base-64.  If <em>base64WhiteSpace</em> is
nonzero, whitespace will be encoded in base-64.  Both are set to zero for the
Python &quot;utf-7&quot; codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="unicode-escape-codecs">
<h3>Unicode-Escape Codecs<a class="headerlink" href="#unicode-escape-codecs" title="제목 주소">¶</a></h3>
<p>These are the &quot;Unicode Escape&quot; codec APIs:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUnicodeEscape">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUnicodeEscape</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUnicodeEscape" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the Unicode-Escape encoded
string <em>s</em>.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUnicodeEscapeString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsUnicodeEscapeString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUnicodeEscapeString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object using Unicode-Escape and return the result as a
bytes object.  Error handling is &quot;strict&quot;.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was
raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUnicodeEscape">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUnicodeEscape</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUnicodeEscape" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> using Unicode-Escape and
return a bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsUnicodeEscapeString" title="PyUnicode_AsUnicodeEscapeString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUnicodeEscapeString()</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="raw-unicode-escape-codecs">
<h3>Raw-Unicode-Escape Codecs<a class="headerlink" href="#raw-unicode-escape-codecs" title="제목 주소">¶</a></h3>
<p>These are the &quot;Raw Unicode Escape&quot; codec APIs:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeRawUnicodeEscape">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeRawUnicodeEscape</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeRawUnicodeEscape" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the Raw-Unicode-Escape
encoded string <em>s</em>.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsRawUnicodeEscapeString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsRawUnicodeEscapeString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsRawUnicodeEscapeString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object using Raw-Unicode-Escape and return the result as
a bytes object.  Error handling is &quot;strict&quot;.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception
was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeRawUnicodeEscape">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeRawUnicodeEscape</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeRawUnicodeEscape" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> using Raw-Unicode-Escape
and return a bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsRawUnicodeEscapeString" title="PyUnicode_AsRawUnicodeEscapeString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsRawUnicodeEscapeString()</span></code></a> or
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="latin-1-codecs">
<h3>Latin-1 Codecs<a class="headerlink" href="#latin-1-codecs" title="제목 주소">¶</a></h3>
<p>These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256 Unicode
ordinals and only these are accepted by the codecs during encoding.</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeLatin1">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeLatin1</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeLatin1" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the Latin-1 encoded string
<em>s</em>.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsLatin1String">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsLatin1String</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsLatin1String" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object using Latin-1 and return the result as Python bytes
object.  Error handling is &quot;strict&quot;.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was
raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeLatin1">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeLatin1</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeLatin1" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> using Latin-1 and
return a Python bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by
the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsLatin1String" title="PyUnicode_AsLatin1String"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsLatin1String()</span></code></a> or
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="ascii-codecs">
<h3>ASCII Codecs<a class="headerlink" href="#ascii-codecs" title="제목 주소">¶</a></h3>
<p>These are the ASCII codec APIs.  Only 7-bit ASCII data is accepted. All other
codes generate errors.</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeASCII">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeASCII</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeASCII" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the ASCII encoded string
<em>s</em>.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsASCIIString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsASCIIString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsASCIIString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object using ASCII and return the result as Python bytes
object.  Error handling is &quot;strict&quot;.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was
raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeASCII">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeASCII</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeASCII" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> using ASCII and
return a Python bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by
the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsASCIIString" title="PyUnicode_AsASCIIString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsASCIIString()</span></code></a> or
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="character-map-codecs">
<h3>Character Map Codecs<a class="headerlink" href="#character-map-codecs" title="제목 주소">¶</a></h3>
<p>This codec is special in that it can be used to implement many different codecs
(and this is in fact what was done to obtain most of the standard codecs
included in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings</span></code> package). The codec uses mapping to encode and
decode characters.  The mapping objects provided must support the
<a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> mapping interface; dictionaries and sequences work well.</p>
<p>These are the mapping codec APIs:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeCharmap">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeCharmap</code><span class="sig-paren">(</span>const char<em> *data</em>, Py_ssize_t<em> size</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *mapping</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeCharmap" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the encoded string <em>s</em>
using the given <em>mapping</em> object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised
by the codec.</p>
<p>If <em>mapping</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, Latin-1 decoding will be applied.  Else
<em>mapping</em> must map bytes ordinals (integers in the range from 0 to 255)
to Unicode strings, integers (which are then interpreted as Unicode
ordinals) or <code class="docutils literal notranslate"><span class="pre">None</span></code>.  Unmapped data bytes -- ones which cause a
<a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>, as well as ones which get mapped to <code class="docutils literal notranslate"><span class="pre">None</span></code>,
<code class="docutils literal notranslate"><span class="pre">0xFFFE</span></code> or <code class="docutils literal notranslate"><span class="pre">'\ufffe'</span></code>, are treated as undefined mappings and cause
an error.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsCharmapString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsCharmapString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsCharmapString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object using the given <em>mapping</em> object and return the
result as a bytes object.  Error handling is &quot;strict&quot;.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an
exception was raised by the codec.</p>
<p>The <em>mapping</em> object must map Unicode ordinal integers to bytes objects,
integers in the range from 0 to 255 or <code class="docutils literal notranslate"><span class="pre">None</span></code>.  Unmapped character
ordinals (ones which cause a <a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>) as well as mapped to
<code class="docutils literal notranslate"><span class="pre">None</span></code> are treated as &quot;undefined mapping&quot; and cause an error.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeCharmap">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeCharmap</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *mapping</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeCharmap" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> using the given
<em>mapping</em> object and return the result as a bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if
an exception was raised by the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsCharmapString" title="PyUnicode_AsCharmapString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsCharmapString()</span></code></a> or
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

<p>The following codec API is special in that maps Unicode to Unicode.</p>
<dl class="function">
<dt id="c.PyUnicode_Translate">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Translate</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *mapping</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Translate" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Translate a Unicode object using the given <em>mapping</em> object and return the
resulting Unicode object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the
codec.</p>
<p>The <em>mapping</em> object must map Unicode ordinal integers to Unicode strings,
integers (which are then interpreted as Unicode ordinals) or <code class="docutils literal notranslate"><span class="pre">None</span></code>
(causing deletion of the character).  Unmapped character ordinals (ones
which cause a <a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>) are left untouched and are copied as-is.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_TranslateCharmap">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_TranslateCharmap</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *mapping</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_TranslateCharmap" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Translate a <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> by applying a
character <em>mapping</em> table to it and return the resulting Unicode object.
Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> when an exception was raised by the codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_Translate" title="PyUnicode_Translate"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_Translate()</span></code></a>. or <a class="reference internal" href="codec.html#codec-registry"><span class="std std-ref">generic codec based API</span></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="mbcs-codecs-for-windows">
<h3>MBCS codecs for Windows<a class="headerlink" href="#mbcs-codecs-for-windows" title="제목 주소">¶</a></h3>
<p>These are the MBCS codec APIs. They are currently only available on Windows and
use the Win32 MBCS converters to implement the conversions.  Note that MBCS (or
DBCS) is a class of encodings, not just one.  The target encoding is defined by
the user settings on the machine running the codec.</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeMBCS">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeMBCS</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeMBCS" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a Unicode object by decoding <em>size</em> bytes of the MBCS encoded string <em>s</em>.
Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeMBCSStateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeMBCSStateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeMBCSStateful" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>If <em>consumed</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, behave like <a class="reference internal" href="#c.PyUnicode_DecodeMBCS" title="PyUnicode_DecodeMBCS"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeMBCS()</span></code></a>. If
<em>consumed</em> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <a class="reference internal" href="#c.PyUnicode_DecodeMBCSStateful" title="PyUnicode_DecodeMBCSStateful"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeMBCSStateful()</span></code></a> will not decode
trailing lead byte and the number of bytes that have been decoded will be stored
in <em>consumed</em>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsMBCSString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsMBCSString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsMBCSString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode a Unicode object using MBCS and return the result as Python bytes
object.  Error handling is &quot;strict&quot;.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was
raised by the codec.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeCodePage">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeCodePage</code><span class="sig-paren">(</span>int<em> code_page</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeCodePage" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the Unicode object using the specified code page and return a Python
bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the codec. Use
<code class="xref c c-data docutils literal notranslate"><span class="pre">CP_ACP</span></code> code page to get the MBCS encoder.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeMBCS">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeMBCS</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeMBCS" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Encode the <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> buffer of the given <em>size</em> using MBCS and return
a Python bytes object.  Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if an exception was raised by the
codec.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.PyUnicode_AsMBCSString" title="PyUnicode_AsMBCSString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsMBCSString()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_EncodeCodePage" title="PyUnicode_EncodeCodePage"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeCodePage()</span></code></a> or
<a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="methods-slots">
<h3>Methods &amp; Slots<a class="headerlink" href="#methods-slots" title="제목 주소">¶</a></h3>
</div>
</div>
<div class="section" id="methods-and-slot-functions">
<span id="unicodemethodsandslots"></span><h2>Methods and Slot Functions<a class="headerlink" href="#methods-and-slot-functions" title="제목 주소">¶</a></h2>
<p>The following APIs are capable of handling Unicode objects and strings on input
(we refer to them as strings in the descriptions) and return Unicode objects or
integers as appropriate.</p>
<p>They all return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or <code class="docutils literal notranslate"><span class="pre">-1</span></code> if an exception occurs.</p>
<dl class="function">
<dt id="c.PyUnicode_Concat">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Concat</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *left</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *right</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Concat" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Concat two strings giving a new Unicode string.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Split">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Split</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *s</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *sep</em>, Py_ssize_t<em> maxsplit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Split" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Split a string giving a list of Unicode strings.  If <em>sep</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, splitting
will be done at all whitespace substrings.  Otherwise, splits occur at the given
separator.  At most <em>maxsplit</em> splits will be done.  If negative, no limit is
set.  Separators are not included in the resulting list.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Splitlines">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Splitlines</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *s</em>, int<em> keepend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Splitlines" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Split a Unicode string at line breaks, returning a list of Unicode strings.
CRLF is considered to be one line break.  If <em>keepend</em> is <code class="docutils literal notranslate"><span class="pre">0</span></code>, the Line break
characters are not included in the resulting strings.</p>
</dd></dl>

<dl class="function">
<dt>
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Translate</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *table</em>, const char<em> *errors</em><span class="sig-paren">)</span></dt>
<dd><p>Translate a string by applying a character mapping table to it and return the
resulting Unicode object.</p>
<p>The mapping table must map Unicode ordinal integers to Unicode ordinal integers
or <code class="docutils literal notranslate"><span class="pre">None</span></code> (causing deletion of the character).</p>
<p>Mapping tables need only provide the <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> interface; dictionaries
and sequences work well.  Unmapped character ordinals (ones which cause a
<a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>) are left untouched and are copied as-is.</p>
<p><em>errors</em> has the usual meaning for codecs. It may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> which indicates to
use the default error handling.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Join">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Join</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *separator</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *seq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Join" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Join a sequence of strings using the given <em>separator</em> and return the resulting
Unicode string.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Tailmatch">
Py_ssize_t <code class="sig-name descname">PyUnicode_Tailmatch</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *substr</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em>, int<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Tailmatch" title="정의 주소">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">1</span></code> if <em>substr</em> matches <code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code> at the given tail end
(<em>direction</em> == <code class="docutils literal notranslate"><span class="pre">-1</span></code> means to do a prefix match, <em>direction</em> == <code class="docutils literal notranslate"><span class="pre">1</span></code> a suffix match),
<code class="docutils literal notranslate"><span class="pre">0</span></code> otherwise. Return <code class="docutils literal notranslate"><span class="pre">-1</span></code> if an error occurred.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Find">
Py_ssize_t <code class="sig-name descname">PyUnicode_Find</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *substr</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em>, int<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Find" title="정의 주소">¶</a></dt>
<dd><p>Return the first position of <em>substr</em> in <code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code> using the given
<em>direction</em> (<em>direction</em> == <code class="docutils literal notranslate"><span class="pre">1</span></code> means to do a forward search, <em>direction</em> == <code class="docutils literal notranslate"><span class="pre">-1</span></code> a
backward search).  The return value is the index of the first match; a value of
<code class="docutils literal notranslate"><span class="pre">-1</span></code> indicates that no match was found, and <code class="docutils literal notranslate"><span class="pre">-2</span></code> indicates that an error
occurred and an exception has been set.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FindChar">
Py_ssize_t <code class="sig-name descname">PyUnicode_FindChar</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> ch</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em>, int<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FindChar" title="정의 주소">¶</a></dt>
<dd><p>Return the first position of the character <em>ch</em> in <code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code> using
the given <em>direction</em> (<em>direction</em> == <code class="docutils literal notranslate"><span class="pre">1</span></code> means to do a forward search,
<em>direction</em> == <code class="docutils literal notranslate"><span class="pre">-1</span></code> a backward search).  The return value is the index of the
first match; a value of <code class="docutils literal notranslate"><span class="pre">-1</span></code> indicates that no match was found, and <code class="docutils literal notranslate"><span class="pre">-2</span></code>
indicates that an error occurred and an exception has been set.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>start</em> and <em>end</em> are now adjusted to behave like <code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Count">
Py_ssize_t <code class="sig-name descname">PyUnicode_Count</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *substr</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Count" title="정의 주소">¶</a></dt>
<dd><p>Return the number of non-overlapping occurrences of <em>substr</em> in
<code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code>.  Return <code class="docutils literal notranslate"><span class="pre">-1</span></code> if an error occurred.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Replace">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Replace</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *substr</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *replstr</em>, Py_ssize_t<em> maxcount</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Replace" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Replace at most <em>maxcount</em> occurrences of <em>substr</em> in <em>str</em> with <em>replstr</em> and
return the resulting Unicode object. <em>maxcount</em> == <code class="docutils literal notranslate"><span class="pre">-1</span></code> means replace all
occurrences.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Compare">
int <code class="sig-name descname">PyUnicode_Compare</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *left</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *right</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Compare" title="정의 주소">¶</a></dt>
<dd><p>Compare two strings and return <code class="docutils literal notranslate"><span class="pre">-1</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code> for less than, equal, and greater than,
respectively.</p>
<p>This function returns <code class="docutils literal notranslate"><span class="pre">-1</span></code> upon failure, so one should call
<a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_Occurred()</span></code></a> to check for errors.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_CompareWithASCIIString">
int <code class="sig-name descname">PyUnicode_CompareWithASCIIString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *uni</em>, const char<em> *string</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_CompareWithASCIIString" title="정의 주소">¶</a></dt>
<dd><p>Compare a Unicode object, <em>uni</em>, with <em>string</em> and return <code class="docutils literal notranslate"><span class="pre">-1</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code> for less
than, equal, and greater than, respectively. It is best to pass only
ASCII-encoded strings, but the function interprets the input string as
ISO-8859-1 if it contains non-ASCII characters.</p>
<p>This function does not raise exceptions.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_RichCompare">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_RichCompare</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *left</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *right</em>, int<em> op</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_RichCompare" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Rich compare two Unicode strings and return one of the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> in case an exception was raised</p></li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_True</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_False</span></code> for successful comparisons</p></li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code> in case the type combination is unknown</p></li>
</ul>
<p>Possible values for <em>op</em> are <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_GT</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_GE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_EQ</span></code>,
<code class="xref py py-const docutils literal notranslate"><span class="pre">Py_NE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_LT</span></code>, and <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_LE</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Format">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Format</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *format</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Format" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Return a new string object from <em>format</em> and <em>args</em>; this is analogous to
<code class="docutils literal notranslate"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">args</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Contains">
int <code class="sig-name descname">PyUnicode_Contains</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *container</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *element</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Contains" title="정의 주소">¶</a></dt>
<dd><p>Check whether <em>element</em> is contained in <em>container</em> and return true or false
accordingly.</p>
<p><em>element</em> has to coerce to a one element Unicode string. <code class="docutils literal notranslate"><span class="pre">-1</span></code> is returned
if there was an error.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_InternInPlace">
void <code class="sig-name descname">PyUnicode_InternInPlace</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> **string</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_InternInPlace" title="정의 주소">¶</a></dt>
<dd><p>Intern the argument <em>*string</em> in place.  The argument must be the address of a
pointer variable pointing to a Python Unicode string object.  If there is an
existing interned string that is the same as <em>*string</em>, it sets <em>*string</em> to
it (decrementing the reference count of the old string object and incrementing
the reference count of the interned string object), otherwise it leaves
<em>*string</em> alone and interns it (incrementing its reference count).
(Clarification: even though there is a lot of talk about reference counts, think
of this function as reference-count-neutral; you own the object after the call
if and only if you owned it before the call.)</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_InternFromString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_InternFromString</code><span class="sig-paren">(</span>const char<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_InternFromString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>A combination of <a class="reference internal" href="#c.PyUnicode_FromString" title="PyUnicode_FromString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromString()</span></code></a> and
<a class="reference internal" href="#c.PyUnicode_InternInPlace" title="PyUnicode_InternInPlace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_InternInPlace()</span></code></a>, returning either a new Unicode string
object that has been interned, or a new (&quot;owned&quot;) reference to an earlier
interned string object with the same value.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">유니코드 객체와 코덱</a><ul>
<li><a class="reference internal" href="#unicode-objects">유니코드 객체</a><ul>
<li><a class="reference internal" href="#unicode-type">유니코드 형</a></li>
<li><a class="reference internal" href="#unicode-character-properties">유니코드 문자 속성</a></li>
<li><a class="reference internal" href="#creating-and-accessing-unicode-strings">유니코드 문자열 생성과 액세스</a></li>
<li><a class="reference internal" href="#deprecated-py-unicode-apis">폐지된 Py_UNICODE API</a></li>
<li><a class="reference internal" href="#locale-encoding">Locale Encoding</a></li>
<li><a class="reference internal" href="#file-system-encoding">File System Encoding</a></li>
<li><a class="reference internal" href="#wchar-t-support">wchar_t Support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#built-in-codecs">Built-in Codecs</a><ul>
<li><a class="reference internal" href="#generic-codecs">Generic Codecs</a></li>
<li><a class="reference internal" href="#utf-8-codecs">UTF-8 Codecs</a></li>
<li><a class="reference internal" href="#utf-32-codecs">UTF-32 Codecs</a></li>
<li><a class="reference internal" href="#utf-16-codecs">UTF-16 Codecs</a></li>
<li><a class="reference internal" href="#utf-7-codecs">UTF-7 Codecs</a></li>
<li><a class="reference internal" href="#unicode-escape-codecs">Unicode-Escape Codecs</a></li>
<li><a class="reference internal" href="#raw-unicode-escape-codecs">Raw-Unicode-Escape Codecs</a></li>
<li><a class="reference internal" href="#latin-1-codecs">Latin-1 Codecs</a></li>
<li><a class="reference internal" href="#ascii-codecs">ASCII Codecs</a></li>
<li><a class="reference internal" href="#character-map-codecs">Character Map Codecs</a></li>
<li><a class="reference internal" href="#mbcs-codecs-for-windows">MBCS codecs for Windows</a></li>
<li><a class="reference internal" href="#methods-slots">Methods &amp; Slots</a></li>
</ul>
</li>
<li><a class="reference internal" href="#methods-and-slot-functions">Methods and Slot Functions</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="bytearray.html"
                        title="이전 장">바이트 배열 객체</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="tuple.html"
                        title="다음 장">튜플 객체</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="tuple.html" title="튜플 객체"
             >다음</a> |</li>
        <li class="right" >
          <a href="bytearray.html" title="바이트 배열 객체"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="concrete.html" >구상 객체 계층</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>