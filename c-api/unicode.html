
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>유니코드 객체와 코덱 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="튜플 객체" href="tuple.html" />
    <link rel="prev" title="바이트 배열 객체" href="bytearray.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/c-api/unicode.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="tuple.html" title="튜플 객체"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="bytearray.html" title="바이트 배열 객체"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="concrete.html" accesskey="U">구상 객체 계층</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="unicode-objects-and-codecs">
<span id="unicodeobjects"></span><h1>유니코드 객체와 코덱<a class="headerlink" href="#unicode-objects-and-codecs" title="제목 주소">¶</a></h1>
<div class="section" id="unicode-objects">
<h2>유니코드 객체<a class="headerlink" href="#unicode-objects" title="제목 주소">¶</a></h2>
<p>파이썬 3.3에서 <span class="target" id="index-14"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0393"><strong>PEP 393</strong></a>을 구현한 이후, 유니코드 객체는 내부적으로 다양한 표현을 사용하여 전체 유니코드 문자 범위를 처리하면서 메모리 효율성을 유지합니다. 모든 코드 포인트가 128, 256 또는 65536 미만인 문자열에 대한 특별한 경우가 있습니다; 그렇지 않으면, 코드 포인트는 1114112 (전체 유니코드 범위) 미만이어야 합니다.</p>
<p><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> and UTF-8 representations are created on demand and cached
in the Unicode object.  The <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> representation is deprecated
and inefficient.</p>
<p>이전 API와 새 API 간의 전환으로 인해, 유니코드 객체는 만들어진 방법에 따라 내부적으로 두 가지 상태가 될 수 있습니다:</p>
<ul class="simple">
<li><p>&quot;규범적(canonical)&quot; 유니코드 객체는 폐지되지 않은 유니코드 API에 의해 만들어진 모든 객체입니다. 구현에서 허용하는 가장 효율적인 표현을 사용합니다.</p></li>
<li><p>&quot;레거시&quot; 유니코드 객체는 폐지된 API 중 하나(일반적으로 <a class="reference internal" href="#c.PyUnicode_FromUnicode" title="PyUnicode_FromUnicode"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromUnicode()</span></code></a>)를 통해 만들어지고 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> 표현만 포함합니다; 다른 API를 호출하기 전에 이들에 대해 <a class="reference internal" href="#c.PyUnicode_READY" title="PyUnicode_READY"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READY()</span></code></a>를 호출해야 합니다.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>&quot;레거시&quot; 유니코드 객체는 폐지된 API와 함께 파이썬 3.12에서 제거됩니다. 그 이후로 모든 유니코드 객체는 &quot;규범적&quot;이 됩니다. 자세한 정보는 <span class="target" id="index-15"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0623"><strong>PEP 623</strong></a>을 참조하십시오.</p>
</div>
<div class="section" id="unicode-type">
<h3>유니코드 형<a class="headerlink" href="#unicode-type" title="제목 주소">¶</a></h3>
<p>다음은 파이썬에서 유니코드 구현에 사용되는 기본 유니코드 객체 형입니다:</p>
<dl class="type">
<dt id="c.Py_UCS4">
<code class="sig-name descname">Py_UCS4</code><a class="headerlink" href="#c.Py_UCS4" title="정의 주소">¶</a></dt>
<dt id="c.Py_UCS2">
<code class="sig-name descname">Py_UCS2</code><a class="headerlink" href="#c.Py_UCS2" title="정의 주소">¶</a></dt>
<dt id="c.Py_UCS1">
<code class="sig-name descname">Py_UCS1</code><a class="headerlink" href="#c.Py_UCS1" title="정의 주소">¶</a></dt>
<dd><p>이 형들은 각각 32비트, 16비트 및 8비트의 문자를 포함하기에 충분한 부호 없는 정수 형을 위한 typedef 입니다. 단일 유니코드 문자를 처리할 때는, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UCS4</span></code></a>를 사용하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="type">
<dt id="c.Py_UNICODE">
<code class="sig-name descname">Py_UNICODE</code><a class="headerlink" href="#c.Py_UNICODE" title="정의 주소">¶</a></dt>
<dd><p>이것은 플랫폼에 따라 16비트 형이나 32비트 형인 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code>의 typedef 입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>이전 버전에서, 이것은 빌드 시 파이썬의 &quot;내로우(narrow)&quot;나 &quot;와이드(wide)&quot; 유니코드 버전 중 어느 것을 선택했는지에 따라 16비트 형이나 32비트 형이었습니다.</p>
</div>
</dd></dl>

<dl class="type">
<dt id="c.PyASCIIObject">
<code class="sig-name descname">PyASCIIObject</code><a class="headerlink" href="#c.PyASCIIObject" title="정의 주소">¶</a></dt>
<dt id="c.PyCompactUnicodeObject">
<code class="sig-name descname">PyCompactUnicodeObject</code><a class="headerlink" href="#c.PyCompactUnicodeObject" title="정의 주소">¶</a></dt>
<dt id="c.PyUnicodeObject">
<code class="sig-name descname">PyUnicodeObject</code><a class="headerlink" href="#c.PyUnicodeObject" title="정의 주소">¶</a></dt>
<dd><p>이 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> 서브 형들은 파이썬 유니코드 객체를 나타냅니다. 거의 모든 경우에, 유니코드 객체를 처리하는 모든 API 함수가 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> 포인터를 취하고 반환하므로 직접 사용해서는 안 됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="var">
<dt id="c.PyUnicode_Type">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a> <code class="sig-name descname">PyUnicode_Type</code><a class="headerlink" href="#c.PyUnicode_Type" title="정의 주소">¶</a></dt>
<dd><p>이 <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 인스턴스는 파이썬 유니코드 형을 나타냅니다. 파이썬 코드에 <code class="docutils literal notranslate"><span class="pre">str</span></code>로 노출됩니다.</p>
</dd></dl>

<p>다음 API는 실제로는 C 매크로이며 빠른 검사를 수행하고 유니코드 객체의 내부 읽기 전용 데이터에 액세스하는 데 사용할 수 있습니다:</p>
<dl class="function">
<dt id="c.PyUnicode_Check">
int <code class="sig-name descname">PyUnicode_Check</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Check" title="정의 주소">¶</a></dt>
<dd><p>Return true if the object <em>o</em> is a Unicode object or an instance of a Unicode
subtype.  This function always succeeds.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_CheckExact">
int <code class="sig-name descname">PyUnicode_CheckExact</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_CheckExact" title="정의 주소">¶</a></dt>
<dd><p>Return true if the object <em>o</em> is a Unicode object, but not an instance of a
subtype.  This function always succeeds.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_READY">
int <code class="sig-name descname">PyUnicode_READY</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_READY" title="정의 주소">¶</a></dt>
<dd><p>문자열 객체 <em>o</em>가 &quot;규범적(canonical)&quot; 표현인지 확인합니다. 이것은 아래에 설명된 액세스 매크로를 사용하기 전에 필요합니다.</p>
<p>성공 시 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환하고, 실패 시 예외를 설정하면서 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환하는데, 특히 메모리 할당이 실패하면 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.10, will be removed in version 3.12: </span>이 API는 <a class="reference internal" href="#c.PyUnicode_FromUnicode" title="PyUnicode_FromUnicode"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromUnicode()</span></code></a>와 함께 제거됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GET_LENGTH">
Py_ssize_t <code class="sig-name descname">PyUnicode_GET_LENGTH</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GET_LENGTH" title="정의 주소">¶</a></dt>
<dd><p>유니코드 문자열의 길이를 코드 포인트로 반환합니다. <em>o</em>는 &quot;규범적(canonical)&quot; 표현의 유니코드 객체여야 합니다 (검사하지 않습니다).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_1BYTE_DATA">
<a class="reference internal" href="#c.Py_UCS1" title="Py_UCS1">Py_UCS1</a>* <code class="sig-name descname">PyUnicode_1BYTE_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_1BYTE_DATA" title="정의 주소">¶</a></dt>
<dt id="c.PyUnicode_2BYTE_DATA">
<a class="reference internal" href="#c.Py_UCS2" title="Py_UCS2">Py_UCS2</a>* <code class="sig-name descname">PyUnicode_2BYTE_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_2BYTE_DATA" title="정의 주소">¶</a></dt>
<dt id="c.PyUnicode_4BYTE_DATA">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a>* <code class="sig-name descname">PyUnicode_4BYTE_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_4BYTE_DATA" title="정의 주소">¶</a></dt>
<dd><p>직접 문자 액세스를 위해 UCS1, UCS2 또는 UCS4 정수 형으로 캐스트 된 규범적(canonical) 표현에 대한 포인터를 반환합니다. 규범적(canonical) 표현이 올바른 문자 크기인지 검사하지 않습니다; <a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_KIND()</span></code></a>를 사용하여 올바른 매크로를 선택하십시오. 이것을 액세스하기 전에 <a class="reference internal" href="#c.PyUnicode_READY" title="PyUnicode_READY"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READY()</span></code></a>가 호출되었어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.PyUnicode_WCHAR_KIND">
<code class="sig-name descname">PyUnicode_WCHAR_KIND</code><a class="headerlink" href="#c.PyUnicode_WCHAR_KIND" title="정의 주소">¶</a></dt>
<dt id="c.PyUnicode_1BYTE_KIND">
<code class="sig-name descname">PyUnicode_1BYTE_KIND</code><a class="headerlink" href="#c.PyUnicode_1BYTE_KIND" title="정의 주소">¶</a></dt>
<dt id="c.PyUnicode_2BYTE_KIND">
<code class="sig-name descname">PyUnicode_2BYTE_KIND</code><a class="headerlink" href="#c.PyUnicode_2BYTE_KIND" title="정의 주소">¶</a></dt>
<dt id="c.PyUnicode_4BYTE_KIND">
<code class="sig-name descname">PyUnicode_4BYTE_KIND</code><a class="headerlink" href="#c.PyUnicode_4BYTE_KIND" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_KIND()</span></code></a> 매크로의 값을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.10, will be removed in version 3.12: </span><code class="docutils literal notranslate"><span class="pre">PyUnicode_WCHAR_KIND</span></code>는 폐지되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_KIND">
int <code class="sig-name descname">PyUnicode_KIND</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_KIND" title="정의 주소">¶</a></dt>
<dd><p>이 유니코드 객체가 데이터를 저장하는 데 사용하는 문자 당 바이트 수를 나타내는 PyUnicode 종류 상수 (위를 참조하십시오) 중 하나를 반환합니다. <em>o</em>는 &quot;규범적(canonical)&quot; 표현의 유니코드 객체여야 합니다 (검사하지 않습니다).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DATA">
void* <code class="sig-name descname">PyUnicode_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DATA" title="정의 주소">¶</a></dt>
<dd><p>원시 유니코드 버퍼에 대한 void 포인터를 반환합니다. <em>o</em>는 &quot;규범적(canonical)&quot; 표현의 유니코드 객체여야 합니다 (검사하지 않습니다).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_WRITE">
void <code class="sig-name descname">PyUnicode_WRITE</code><span class="sig-paren">(</span>int<em> kind</em>, void<em> *data</em>, Py_ssize_t<em> index</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_WRITE" title="정의 주소">¶</a></dt>
<dd><p>규범적(canonical) 표현 <em>data</em>(<a class="reference internal" href="#c.PyUnicode_DATA" title="PyUnicode_DATA"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DATA()</span></code></a>로 얻은 대로)에 씁니다. 이 매크로는 온전성 검사(sanity checks)를 수행하지 않으며 루프에서 사용하기 위한 것입니다. 호출자는 다른 매크로 호출에서 얻은 대로 <em>kind</em> 값과 <em>data</em> 포인터를 캐시 해야 합니다. <em>index</em>는 문자열의 인덱스(0에서 시작합니다)이고 <em>value</em>는 해당 위치에 기록되어야 하는 새 코드 포인트 값입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_READ">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a> <code class="sig-name descname">PyUnicode_READ</code><span class="sig-paren">(</span>int<em> kind</em>, void<em> *data</em>, Py_ssize_t<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_READ" title="정의 주소">¶</a></dt>
<dd><p>규범적(canonical) 표현 <em>data</em>(<a class="reference internal" href="#c.PyUnicode_DATA" title="PyUnicode_DATA"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DATA()</span></code></a>로 얻은 대로)에서 코드 포인트를 읽습니다. 검사나 준비(ready) 호출이 수행되지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_READ_CHAR">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a> <code class="sig-name descname">PyUnicode_READ_CHAR</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em>, Py_ssize_t<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_READ_CHAR" title="정의 주소">¶</a></dt>
<dd><p>&quot;규범적(canonical)&quot; 표현이어야 하는, 유니코드 객체 <em>o</em>에서 문자를 읽습니다. 여러 연속 읽기를 수행한다면 <a class="reference internal" href="#c.PyUnicode_READ" title="PyUnicode_READ"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READ()</span></code></a>보다 효율성이 떨어집니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.PyUnicode_MAX_CHAR_VALUE">
<code class="sig-name descname">PyUnicode_MAX_CHAR_VALUE</code><span class="sig-paren">(</span>o<span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_MAX_CHAR_VALUE" title="정의 주소">¶</a></dt>
<dd><p>&quot;규범적(canonical)&quot; 표현이어야 하는, <em>o</em>를 기반으로 다른 문자열을 만드는 데 적합한 최대 코드 포인트를 반환합니다. 이것은 항상 근사치이지만 문자열을 이터레이트 하는 것보다 효율적입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GET_SIZE">
Py_ssize_t <code class="sig-name descname">PyUnicode_GET_SIZE</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GET_SIZE" title="정의 주소">¶</a></dt>
<dd><p>폐지된 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 표현의 크기를 코드 단위로 반환합니다 (서로게이트 쌍을 2단위로 포함합니다). <em>o</em>는 유니코드 객체여야 합니다 (검사하지 않습니다).</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>이전 스타일 유니코드 API의 일부입니다, <a class="reference internal" href="#c.PyUnicode_GET_LENGTH" title="PyUnicode_GET_LENGTH"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_GET_LENGTH()</span></code></a>를 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GET_DATA_SIZE">
Py_ssize_t <code class="sig-name descname">PyUnicode_GET_DATA_SIZE</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GET_DATA_SIZE" title="정의 주소">¶</a></dt>
<dd><p>폐지된 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 표현의 크기를 바이트 단위로 반환합니다. <em>o</em>는 유니코드 객체여야 합니다 (검사하지 않습니다).</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>이전 스타일 유니코드 API의 일부입니다, <a class="reference internal" href="#c.PyUnicode_GET_LENGTH" title="PyUnicode_GET_LENGTH"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_GET_LENGTH()</span></code></a>를 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AS_UNICODE">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <code class="sig-name descname">PyUnicode_AS_UNICODE</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AS_UNICODE" title="정의 주소">¶</a></dt>
<dt id="c.PyUnicode_AS_DATA">
const char* <code class="sig-name descname">PyUnicode_AS_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AS_DATA" title="정의 주소">¶</a></dt>
<dd><p>객체의 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 표현에 대한 포인터를 반환합니다. 반환된 버퍼는 항상 추가 널 코드 포인트로 끝납니다. 또한 내장된 널 코드 포인트를 포함할 수 있는데, 대부분의 C 함수에서 사용될 때 문자열이 잘리도록 합니다. <code class="docutils literal notranslate"><span class="pre">AS_DATA</span></code> 형식은 포인터를 <code class="xref c c-type docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code>로 캐스트 합니다. <em>o</em> 인자는 유니코드 객체여야 합니다 (검사하지 않습니다).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>이 매크로는 이제 비효율적이고 -- 많은 경우에 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 표현이 존재하지 않고 만들어야 해서 -- 실패할 수 있습니다 (예외 설정과 함께 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다). 새 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_nBYTE_DATA()</span></code> 매크로를 사용하거나 <a class="reference internal" href="#c.PyUnicode_WRITE" title="PyUnicode_WRITE"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_WRITE()</span></code></a>나 <a class="reference internal" href="#c.PyUnicode_READ" title="PyUnicode_READ"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READ()</span></code></a>를 사용하도록 코드를 이식하십시오.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>이전 스타일 유니코드 API의 일부입니다. <code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_nBYTE_DATA()</span></code> 매크로 계열을 사용하도록 마이그레이션 하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_IsIdentifier">
int <code class="sig-name descname">PyUnicode_IsIdentifier</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_IsIdentifier" title="정의 주소">¶</a></dt>
<dd><p>언어 정의에 따라 문자열이 유효한 식별자이면 <code class="docutils literal notranslate"><span class="pre">1</span></code>을 반환합니다, 섹션 <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">식별자와 키워드</span></a>. 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>문자열이 준비(ready)되지 않았을 때, 이 함수는 더는 <a class="reference internal" href="sys.html#c.Py_FatalError" title="Py_FatalError"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FatalError()</span></code></a>를 호출하지 않습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="unicode-character-properties">
<h3>유니코드 문자 속성<a class="headerlink" href="#unicode-character-properties" title="제목 주소">¶</a></h3>
<p>유니코드는 다양한 문자 속성을 제공합니다. 가장 자주 필요한 것은 파이썬 구성에 따라 C 함수에 매핑되는 이러한 매크로를 통해 사용할 수 있습니다.</p>
<dl class="function">
<dt id="c.Py_UNICODE_ISSPACE">
int <code class="sig-name descname">Py_UNICODE_ISSPACE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISSPACE" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 공백 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISLOWER">
int <code class="sig-name descname">Py_UNICODE_ISLOWER</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISLOWER" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 소문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISUPPER">
int <code class="sig-name descname">Py_UNICODE_ISUPPER</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISUPPER" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 대문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISTITLE">
int <code class="sig-name descname">Py_UNICODE_ISTITLE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISTITLE" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 제목 케이스 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISLINEBREAK">
int <code class="sig-name descname">Py_UNICODE_ISLINEBREAK</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISLINEBREAK" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 줄 바꿈 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISDECIMAL">
int <code class="sig-name descname">Py_UNICODE_ISDECIMAL</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISDECIMAL" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 10진수 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISDIGIT">
int <code class="sig-name descname">Py_UNICODE_ISDIGIT</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISDIGIT" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 디짓(digit) 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISNUMERIC">
int <code class="sig-name descname">Py_UNICODE_ISNUMERIC</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISNUMERIC" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 숫자(numeric) 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISALPHA">
int <code class="sig-name descname">Py_UNICODE_ISALPHA</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISALPHA" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 알파벳 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISALNUM">
int <code class="sig-name descname">Py_UNICODE_ISALNUM</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISALNUM" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 영숫자 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_ISPRINTABLE">
int <code class="sig-name descname">Py_UNICODE_ISPRINTABLE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_ISPRINTABLE" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 인쇄 가능한 문자인지에 따라 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다. 인쇄할 수 없는 문자는, 인쇄 가능한 것으로 간주하는 ASCII 스페이스(0x20)를 제외하고, 유니코드 문자 데이터베이스에서 &quot;Other&quot;나 &quot;Separator&quot;로 정의된 문자입니다. (이 문맥에서 인쇄 가능한 문자는 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a>이 문자열에 대해 호출될 때 이스케이프 되지 않아야 하는 문자임에 유의하십시오. <a class="reference internal" href="../library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>이나 <a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a>에 기록된 문자열의 처리와 관련이 없습니다.)</p>
</dd></dl>

<p>다음 API는 빠른 직접 문자 변환에 사용할 수 있습니다:</p>
<dl class="function">
<dt id="c.Py_UNICODE_TOLOWER">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a> <code class="sig-name descname">Py_UNICODE_TOLOWER</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TOLOWER" title="정의 주소">¶</a></dt>
<dd><p>소문자로 변환된 문자 <em>ch</em>를 반환합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지: </span>이 함수는 간단한 케이스 매핑을 사용합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TOUPPER">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a> <code class="sig-name descname">Py_UNICODE_TOUPPER</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TOUPPER" title="정의 주소">¶</a></dt>
<dd><p>대문자로 변환된 문자 <em>ch</em>를 반환합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지: </span>이 함수는 간단한 케이스 매핑을 사용합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TOTITLE">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a> <code class="sig-name descname">Py_UNICODE_TOTITLE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TOTITLE" title="정의 주소">¶</a></dt>
<dd><p>제목 케이스로 변환된 문자 <em>ch</em>를 반환합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지: </span>이 함수는 간단한 케이스 매핑을 사용합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TODECIMAL">
int <code class="sig-name descname">Py_UNICODE_TODECIMAL</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TODECIMAL" title="정의 주소">¶</a></dt>
<dd><p>10진 양의 정수로 변환된 문자 <em>ch</em>를 반환합니다. 이것이 불가능하면 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다. 이 매크로는 예외를 발생시키지 않습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TODIGIT">
int <code class="sig-name descname">Py_UNICODE_TODIGIT</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TODIGIT" title="정의 주소">¶</a></dt>
<dd><p>한 자리 정수로 변환된 문자 <em>ch</em>를 반환합니다. 이것이 불가능하면 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다. 이 매크로는 예외를 발생시키지 않습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_UNICODE_TONUMERIC">
double <code class="sig-name descname">Py_UNICODE_TONUMERIC</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> ch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_TONUMERIC" title="정의 주소">¶</a></dt>
<dd><p>double로 변환된 문자 <em>ch</em>를 반환합니다. 이것이 불가능하면 <code class="docutils literal notranslate"><span class="pre">-1.0</span></code>을 반환합니다. 이 매크로는 예외를 발생시키지 않습니다.</p>
</dd></dl>

<p>다음 API를 사용하여 서로게이트를 다룰 수 있습니다:</p>
<dl class="macro">
<dt id="c.Py_UNICODE_IS_SURROGATE">
<code class="sig-name descname">Py_UNICODE_IS_SURROGATE</code><span class="sig-paren">(</span>ch<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_IS_SURROGATE" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 서로게이트인지 확인합니다 (<code class="docutils literal notranslate"><span class="pre">0xD800</span> <span class="pre">&lt;=</span> <span class="pre">ch</span> <span class="pre">&lt;=</span> <span class="pre">0xDFFF</span></code>).</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_UNICODE_IS_HIGH_SURROGATE">
<code class="sig-name descname">Py_UNICODE_IS_HIGH_SURROGATE</code><span class="sig-paren">(</span>ch<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_IS_HIGH_SURROGATE" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 상위 서로게이트인지 확인합니다 (<code class="docutils literal notranslate"><span class="pre">0xD800</span> <span class="pre">&lt;=</span> <span class="pre">ch</span> <span class="pre">&lt;=</span> <span class="pre">0xDBFF</span></code>).</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_UNICODE_IS_LOW_SURROGATE">
<code class="sig-name descname">Py_UNICODE_IS_LOW_SURROGATE</code><span class="sig-paren">(</span>ch<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_IS_LOW_SURROGATE" title="정의 주소">¶</a></dt>
<dd><p><em>ch</em>가 하위 서로게이트인지 확인합니다 (<code class="docutils literal notranslate"><span class="pre">0xDC00</span> <span class="pre">&lt;=</span> <span class="pre">ch</span> <span class="pre">&lt;=</span> <span class="pre">0xDFFF</span></code>).</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_UNICODE_JOIN_SURROGATES">
<code class="sig-name descname">Py_UNICODE_JOIN_SURROGATES</code><span class="sig-paren">(</span>high, low<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_UNICODE_JOIN_SURROGATES" title="정의 주소">¶</a></dt>
<dd><p>두 서로게이트 문자를 결합하고 단일 Py_UCS4 값을 반환합니다. <em>high</em>와 <em>low</em>는 각각 서로게이트 쌍의 선행과 후행 서로게이트입니다.</p>
</dd></dl>

</div>
<div class="section" id="creating-and-accessing-unicode-strings">
<h3>유니코드 문자열 생성과 액세스<a class="headerlink" href="#creating-and-accessing-unicode-strings" title="제목 주소">¶</a></h3>
<p>유니코드 객체를 만들고 기본 시퀀스 속성에 액세스하려면 다음 API를 사용하십시오:</p>
<dl class="function">
<dt id="c.PyUnicode_New">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_New</code><span class="sig-paren">(</span>Py_ssize_t<em> size</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> maxchar</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_New" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>새 유니코드 객체를 만듭니다. <em>maxchar</em>은 문자열에 배치할 실제 최대 코드 포인트여야 합니다. 근삿값으로, 127, 255, 65535, 1114111 시퀀스에서 가장 가까운 값으로 올림 할 수 있습니다.</p>
<p>이것은 새 유니코드 객체를 할당하는 데 권장되는 방법입니다. 이 함수를 사용하여 만든 객체는 크기를 조정할 수 없습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromKindAndData">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromKindAndData</code><span class="sig-paren">(</span>int<em> kind</em>, const void<em> *buffer</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromKindAndData" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>주어진 <em>kind</em>(가능한 값은 <a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_KIND()</span></code></a>에 의해 반환된 <a class="reference internal" href="#c.PyUnicode_1BYTE_KIND" title="PyUnicode_1BYTE_KIND"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyUnicode_1BYTE_KIND</span></code></a> 등입니다)로 새로운 유니코드 객체를 만듭니다. <em>buffer</em>는 kind에 따라 문자 당 1, 2 또는 4바이트의 <em>size</em> 단위의 배열을 가리켜야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromStringAndSize">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromStringAndSize</code><span class="sig-paren">(</span>const char<em> *u</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromStringAndSize" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>char 버퍼 <em>u</em>에서 유니코드 객체를 만듭니다. 바이트는 UTF-8로 인코딩된 것으로 해석됩니다. 버퍼는 새 객체에 복사됩니다. 버퍼가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니면, 반환 값은 공유 객체일 수 있습니다, 즉, 데이터 수정이 허용되지 않습니다.</p>
<p>If <em>u</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, this function behaves like <a class="reference internal" href="#c.PyUnicode_FromUnicode" title="PyUnicode_FromUnicode"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromUnicode()</span></code></a>
with the buffer set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  This usage is deprecated in favor of
<a class="reference internal" href="#c.PyUnicode_New" title="PyUnicode_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_New()</span></code></a>, and will be removed in Python 3.12.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">PyUnicode_FromString</code><span class="sig-paren">(</span>const char<em> *u</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>UTF-8로 인코딩된 널-종료 char 버퍼 <em>u</em>에서 유니코드 객체를 만듭니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromFormat">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromFormat</code><span class="sig-paren">(</span>const char<em> *format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromFormat" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>C <code class="xref c c-func docutils literal notranslate"><span class="pre">printf()</span></code>-스타일 <em>format</em> 문자열과 가변 개수의 인자를 취해서, 결과 파이썬 유니코드 문자열의 크기를 계산하고 포맷된 값이 들어간 문자열을 반환합니다. 변수 인자는 C형이어야 하며 <em>format</em> ASCII 인코딩된 문자열의 포맷 문자와 정확히 일치해야 합니다. 다음 포맷 문자가 허용됩니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 28%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>포맷 문자</p></th>
<th class="head"><p>형</p></th>
<th class="head"><p>주석</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%%</span></code></p></td>
<td><p><em>n/a</em></p></td>
<td><p>리터럴 % 문자.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%c</span></code></p></td>
<td><p>int</p></td>
<td><p>C int로 표현된, 단일 문자.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%d</span></code></p></td>
<td><p>int</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%d&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id1">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%u</span></code></p></td>
<td><p>unsigned int</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%u&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id2">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%ld</span></code></p></td>
<td><p>long</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%ld&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id3">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%li</span></code></p></td>
<td><p>long</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%li&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id4">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%lu</span></code></p></td>
<td><p>unsigned long</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%lu&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id5">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%lld</span></code></p></td>
<td><p>long long</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%lld&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id6">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%lli</span></code></p></td>
<td><p>long long</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%lli&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id7">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%llu</span></code></p></td>
<td><p>unsigned long long</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%llu&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id8">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%zd</span></code></p></td>
<td><p>Py_ssize_t</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%zd&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id9">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%zi</span></code></p></td>
<td><p>Py_ssize_t</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%zi&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id10">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%zu</span></code></p></td>
<td><p>size_t</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%zu&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id11">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%i</span></code></p></td>
<td><p>int</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%i&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id12">1</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%x</span></code></p></td>
<td><p>int</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">printf(&quot;%x&quot;)</span></code>와 동등합니다. <a class="footnote-reference brackets" href="#id14" id="id13">1</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%s</span></code></p></td>
<td><p>const char*</p></td>
<td><p>널-종료 C 문자 배열.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%p</span></code></p></td>
<td><p>const void*</p></td>
<td><p>C 포인터의 16진수 표현. 플랫폼의 <code class="docutils literal notranslate"><span class="pre">printf</span></code>가 산출하는 내용과 관계없이 리터럴 <code class="docutils literal notranslate"><span class="pre">0x</span></code>로 시작하는 것이 보장된다는 점을 제외하면 거의 <code class="docutils literal notranslate"><span class="pre">printf(&quot;%p&quot;)</span></code>와 동등합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%A</span></code></p></td>
<td><p>PyObject*</p></td>
<td><p><a class="reference internal" href="../library/functions.html#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a>를 호출한 결과.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%U</span></code></p></td>
<td><p>PyObject*</p></td>
<td><p>유니코드 객체.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%V</span></code></p></td>
<td><p>PyObject*,
const char*</p></td>
<td><p>유니코드 객체(<code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 수 있습니다)와 두 번째 매개 변수로서 널-종료 C 문자 배열 (첫 번째 매개 변수가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면 사용됩니다).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%S</span></code></p></td>
<td><p>PyObject*</p></td>
<td><p><a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Str()</span></code></a>을 호출한 결과.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">%R</span></code></p></td>
<td><p>PyObject*</p></td>
<td><p><a class="reference internal" href="object.html#c.PyObject_Repr" title="PyObject_Repr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Repr()</span></code></a>을 호출한 결과.</p></td>
</tr>
</tbody>
</table>
<p>인식할 수 없는 포맷 문자는 나머지 포맷 문자열이 모두 결과 문자열에 그대로 복사되고, 추가 인자는 버려지도록 합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>너비 포매터 단위는 바이트가 아닌 문자 수입니다. 정밀도 포매터 단위는 <code class="docutils literal notranslate"><span class="pre">&quot;%s&quot;</span></code>와 <code class="docutils literal notranslate"><span class="pre">&quot;%V&quot;</span></code>의 경우는 바이트 수이고 (<code class="docutils literal notranslate"><span class="pre">PyObject*</span></code> 인자가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면), <code class="docutils literal notranslate"><span class="pre">&quot;%A&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%U&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%S&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%R&quot;</span></code> 및 <code class="docutils literal notranslate"><span class="pre">&quot;%V&quot;</span></code>의 경우 문자 수입니다 (<code class="docutils literal notranslate"><span class="pre">PyObject*</span></code> 인자가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니면).</p>
</div>
<dl class="footnote brackets">
<dt class="label" id="id14"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>,<a href="#id3">3</a>,<a href="#id4">4</a>,<a href="#id5">5</a>,<a href="#id6">6</a>,<a href="#id7">7</a>,<a href="#id8">8</a>,<a href="#id9">9</a>,<a href="#id10">10</a>,<a href="#id11">11</a>,<a href="#id12">12</a>,<a href="#id13">13</a>)</span></dt>
<dd><p>정수 지정자 (d, u, ld, li, lu, lld, lli, llu, zd, zi, zu, i, x)의 경우: 0-변환 플래그는 정밀도가 제공되는 경우에도 적용됩니다.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><code class="docutils literal notranslate"><span class="pre">&quot;%lld&quot;</span></code>와 <code class="docutils literal notranslate"><span class="pre">&quot;%llu&quot;</span></code>에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><code class="docutils literal notranslate"><span class="pre">&quot;%li&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%lli&quot;</span></code> 및 <code class="docutils literal notranslate"><span class="pre">&quot;%zi&quot;</span></code>에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">&quot;%s&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%A&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%U&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%V&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%S&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;%R&quot;</span></code>에 대한 너비와 정밀도 포매터 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromFormatV">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromFormatV</code><span class="sig-paren">(</span>const char<em> *format</em>, va_list<em> vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromFormatV" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>정확히 두 개의 인자를 취한다는 점을 제외하면 <a class="reference internal" href="#c.PyUnicode_FromFormat" title="PyUnicode_FromFormat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromFormat()</span></code></a>과 동일합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromEncodedObject">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromEncodedObject</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em>, const char<em> *encoding</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromEncodedObject" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>인코딩된 객체 <em>obj</em>를 유니코드 객체로 디코딩합니다.</p>
<p><a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 및 기타 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>는 주어진 <em>encoding</em>에 따라 <em>errors</em>로 정의한 에러 처리를 사용하여 디코딩됩니다. 둘 다 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 될 수 있고, 이 경우 인터페이스는 기본값을 사용합니다 (자세한 내용은 <a class="reference internal" href="#builtincodecs"><span class="std std-ref">내장 코덱</span></a>를 참조하십시오).</p>
<p>유니코드 객체를 포함한 다른 모든 객체는 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 설정되도록 합니다.</p>
<p>API는 에러가 있으면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다. 호출자는 반환된 객체의 참조 횟수를 감소시킬 책임이 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GetLength">
Py_ssize_t <code class="sig-name descname">PyUnicode_GetLength</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GetLength" title="정의 주소">¶</a></dt>
<dd><p>유니코드 객체의 길이를 코드 포인트로 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_CopyCharacters">
Py_ssize_t <code class="sig-name descname">PyUnicode_CopyCharacters</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *to</em>, Py_ssize_t<em> to_start</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *from</em>, Py_ssize_t<em> from_start</em>, Py_ssize_t<em> how_many</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_CopyCharacters" title="정의 주소">¶</a></dt>
<dd><p>한 유니코드 객체에서 다른 객체로 문자를 복사합니다. 이 함수는 필요하면 문자 변환을 수행하고 가능하면 <code class="xref c c-func docutils literal notranslate"><span class="pre">memcpy()</span></code>로 폴백합니다. 에러 시 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환하고 예외를 설정합니다, 그렇지 않으면 복사된 문자 수를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Fill">
Py_ssize_t <code class="sig-name descname">PyUnicode_Fill</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> length</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> fill_char</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Fill" title="정의 주소">¶</a></dt>
<dd><p>문자로 문자열을 채웁니다: <em>fill_char</em>을 <code class="docutils literal notranslate"><span class="pre">unicode[start:start+length]</span></code>에 씁니다.</p>
<p><em>fill_char</em>이 문자열 최대 문자보다 크거나, 문자열에 둘 이상의 참조가 있으면 실패합니다.</p>
<p>기록된 문자 수를 반환하거나, 에러 시 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환하고 예외를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_WriteChar">
int <code class="sig-name descname">PyUnicode_WriteChar</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> index</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> character</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_WriteChar" title="정의 주소">¶</a></dt>
<dd><p>문자열에 문자를 씁니다. 문자열은 <a class="reference internal" href="#c.PyUnicode_New" title="PyUnicode_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_New()</span></code></a>를 통해 만들었어야 합니다. 유니코드 문자열은 불변이므로, 문자열을 공유하거나 아직 해시 하지 않아야 합니다.</p>
<p>이 함수는 <em>unicode</em>가 유니코드 객체인지, 인덱스가 범위를 벗어났는지, 객체가 안전하게 수정될 수 있는지 (즉, 참조 횟수가 1인지) 확인합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_ReadChar">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a> <code class="sig-name descname">PyUnicode_ReadChar</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_ReadChar" title="정의 주소">¶</a></dt>
<dd><p>문자열에서 문자를 읽습니다. 이 함수는 매크로 버전 <a class="reference internal" href="#c.PyUnicode_READ_CHAR" title="PyUnicode_READ_CHAR"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READ_CHAR()</span></code></a>와 달리 <em>unicode</em>가 유니코드 객체이고 인덱스가 범위를 벗어났는지 확인합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Substring">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Substring</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Substring" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>문자 인덱스 <em>start</em>(포함합니다)에서 문자 인덱스 <em>end</em>(제외합니다)까지 <em>str</em>의 하위 문자열을 반환합니다. 음수 인덱스는 지원되지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUCS4">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a>* <code class="sig-name descname">PyUnicode_AsUCS4</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *u</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> *buffer</em>, Py_ssize_t<em> buflen</em>, int<em> copy_null</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUCS4" title="정의 주소">¶</a></dt>
<dd><p><em>copy_null</em>이 설정되면, 널 문자를 포함하여 문자열 <em>u</em>를 UCS4 버퍼에 복사합니다. 에러 시 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환하고 예외를 설정합니다 (특히, <em>buflen</em>이 <em>u</em>의 길이보다 작으면 <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemError</span></code></a>). 성공하면 <em>buffer</em>가 반환됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUCS4Copy">
<a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a>* <code class="sig-name descname">PyUnicode_AsUCS4Copy</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *u</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUCS4Copy" title="정의 주소">¶</a></dt>
<dd><p>문자열 <em>u</em>를 <a class="reference internal" href="memory.html#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>을 사용하여 할당된 새 UCS4 버퍼에 복사합니다. 이것이 실패하면, <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 반환되고 <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a>가 설정됩니다. 반환된 버퍼에는 항상 추가 널 코드 포인트가 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="deprecated-py-unicode-apis">
<h3>폐지된 Py_UNICODE API<a class="headerlink" href="#deprecated-py-unicode-apis" title="제목 주소">¶</a></h3>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12.</span></p>
</div>
<p>이 API 함수들은 <span class="target" id="index-16"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0393"><strong>PEP 393</strong></a> 구현에 의해 폐지되었습니다. 파이썬 3.x에서 제거되지 않기 때문에, 확장 모듈은 계속해서 사용할 수 있지만, 이제 그 사용으로 인해 성능과 메모리 문제가 있을 수 있음을 인식해야 합니다.</p>
<dl class="function">
<dt id="c.PyUnicode_FromUnicode">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromUnicode</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *u</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromUnicode" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>주어진 크기(size)의 Py_UNICODE 버퍼 <em>u</em>에서 유니코드 객체를 만듭니다. <em>u</em>는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 수 있으며, 이럴 때는 내용이 정의되지 않습니다. 필요한 데이터를 채우는 것은 사용자의 책임입니다. 버퍼가 새 객체에 복사됩니다.</p>
<p>버퍼가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니면, 반환 값은 공유 객체일 수 있습니다. 따라서, 결과 유니코드 객체의 수정은 <em>u</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 때만 허용됩니다.</p>
<p>버퍼가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, <a class="reference internal" href="#c.PyUnicode_KIND" title="PyUnicode_KIND"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_KIND()</span></code></a>와 같은 액세스 매크로를 사용하기 전에 문자열 내용이 채워지면 <a class="reference internal" href="#c.PyUnicode_READY" title="PyUnicode_READY"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_READY()</span></code></a>를 호출해야 합니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>이전 스타일 유니코드 API의 일부입니다. <a class="reference internal" href="#c.PyUnicode_FromKindAndData" title="PyUnicode_FromKindAndData"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromKindAndData()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_FromWideChar" title="PyUnicode_FromWideChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromWideChar()</span></code></a> 또는 <a class="reference internal" href="#c.PyUnicode_New" title="PyUnicode_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_New()</span></code></a>를 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUnicode">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <code class="sig-name descname">PyUnicode_AsUnicode</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUnicode" title="정의 주소">¶</a></dt>
<dd><p>유니코드 객체의 내부 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 버퍼에 대한 읽기 전용 포인터를 반환하거나, 에러 시 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다. 아직 사용할 수 없으면 객체의 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> 표현을 만듭니다. 버퍼는 항상 여분의 널 코드 포인트로 종료됩니다. 결과 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 문자열에는 내장된 널 코드 포인트도 포함될 수 있으며, 이때는 대부분의 C 함수에서 사용될 때 문자열이 잘림에 유의하십시오.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>이전 스타일 유니코드 API의 일부입니다. <a class="reference internal" href="#c.PyUnicode_AsUCS4" title="PyUnicode_AsUCS4"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUCS4()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_AsWideChar" title="PyUnicode_AsWideChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsWideChar()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_ReadChar" title="PyUnicode_ReadChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_ReadChar()</span></code></a> 또는 유사한 새 API를 사용하여 마이그레이션 하십시오.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_TransformDecimalToASCII">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_TransformDecimalToASCII</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_TransformDecimalToASCII" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>주어진 <em>size</em>의 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 버퍼에 있는 모든 10진 숫자들을 10진 값에 따라 ASCII 숫자 0--9로 대체하여 유니코드 객체를 만듭니다. 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>Part of the old-style <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API; please migrate to using
<a class="reference internal" href="#c.Py_UNICODE_TODECIMAL" title="Py_UNICODE_TODECIMAL"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_UNICODE_TODECIMAL()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUnicodeAndSize">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <code class="sig-name descname">PyUnicode_AsUnicodeAndSize</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> *size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUnicodeAndSize" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyUnicode_AsUnicode" title="PyUnicode_AsUnicode"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUnicode()</span></code></a>와 비슷하지만, <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_UNICODE()</span></code></a> 배열 길이(추가 널 종료 제외)를 <em>size</em>에 저장하기도 합니다. 결과 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> 문자열에는 내장된 널 코드 포인트가 포함될 수 있으며, 이때는 대부분의 C 함수에서 사용될 때 문자열이 잘림에 유의하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>이전 스타일 유니코드 API의 일부입니다. <a class="reference internal" href="#c.PyUnicode_AsUCS4" title="PyUnicode_AsUCS4"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUCS4()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_AsWideChar" title="PyUnicode_AsWideChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsWideChar()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_ReadChar" title="PyUnicode_ReadChar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_ReadChar()</span></code></a> 또는 유사한 새 API를 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUnicodeCopy">
<a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a>* <code class="sig-name descname">PyUnicode_AsUnicodeCopy</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUnicodeCopy" title="정의 주소">¶</a></dt>
<dd><p>널 코드 포인트로 끝나는 유니코드 문자열의 복사본을 만듭니다. 메모리 할당 실패 시 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환하고 <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a> 예외를 발생시킵니다, 그렇지 않으면 새로 할당된 버퍼를 반환합니다 (버퍼를 해제하려면 <a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a>를 사용하십시오). 결과 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE*</span></code></a> 문자열에는 내장된 널 코드 포인트가 포함될 수 있으며, 이때는 대부분의 C 함수에서 사용될 때 문자열이 잘림에 유의하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<p><a class="reference internal" href="#c.PyUnicode_AsUCS4Copy" title="PyUnicode_AsUCS4Copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUCS4Copy()</span></code></a> 나 유사한 새 API를 사용하여 마이그레이션 하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_GetSize">
Py_ssize_t <code class="sig-name descname">PyUnicode_GetSize</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_GetSize" title="정의 주소">¶</a></dt>
<dd><p>폐지된 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 표현의 크기를 코드 단위로 반환합니다 (서로게이트 쌍을 2단위로 포함합니다).</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.12: </span>이전 스타일 유니코드 API의 일부입니다, <a class="reference internal" href="#c.PyUnicode_GET_LENGTH" title="PyUnicode_GET_LENGTH"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_GET_LENGTH()</span></code></a>를 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FromObject">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromObject</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromObject" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>필요하면 유니코드 서브 형의 인스턴스를 새로운 진짜 유니코드 객체에 복사합니다. <em>obj</em>가 이미 (서브 형이 아닌) 진짜 유니코드 객체이면, 참조 횟수를 증가시키고 참조를 반환합니다.</p>
<p>유니코드나 이의 서브 형 이외의 객체는 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

</div>
<div class="section" id="locale-encoding">
<h3>로케일 인코딩<a class="headerlink" href="#locale-encoding" title="제목 주소">¶</a></h3>
<p>현재 로케일 인코딩을 사용하여 운영 체제에서 온 텍스트를 디코딩 할 수 있습니다.</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeLocaleAndSize">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeLocaleAndSize</code><span class="sig-paren">(</span>const char<em> *str</em>, Py_ssize_t<em> len</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeLocaleAndSize" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>안드로이드와 VxWorks의 UTF-8이나 다른 플랫폼의 현재 로케일 인코딩의 문자열을 디코딩합니다. 지원되는 에러 처리기는 <code class="docutils literal notranslate"><span class="pre">&quot;strict&quot;</span></code>와 <code class="docutils literal notranslate"><span class="pre">&quot;surrogateescape&quot;</span></code>(<span class="target" id="index-17"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a>)입니다. 디코더는 <em>errors</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면 <code class="docutils literal notranslate"><span class="pre">&quot;strict&quot;</span></code> 에러 처리기를 사용합니다. <em>str</em>은 널 문자로 끝나야 하지만 널 문자를 포함할 수 없습니다.</p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code>(파이썬 시작 시 읽은 로케일 인코딩)에서 문자열을 디코딩하려면 <a class="reference internal" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="PyUnicode_DecodeFSDefaultAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeFSDefaultAndSize()</span></code></a>를 사용하십시오.</p>
<p>이 함수는 파이썬 UTF-8 모드를 무시합니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 함수.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이 함수는 이제 안드로이드를 제외하고 <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> 에러 처리기에 현재 로케일 인코딩도 사용합니다. 이전에는, <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a>이 <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code>에 사용되었고, 현재 로케일 인코딩은 <code class="docutils literal notranslate"><span class="pre">strict</span></code>에 사용되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeLocale">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeLocale</code><span class="sig-paren">(</span>const char<em> *str</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeLocale" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><a class="reference internal" href="#c.PyUnicode_DecodeLocaleAndSize" title="PyUnicode_DecodeLocaleAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeLocaleAndSize()</span></code></a>와 유사하지만, <code class="xref c c-func docutils literal notranslate"><span class="pre">strlen()</span></code>을 사용하여 문자열 길이를 계산합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeLocale">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeLocale</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeLocale" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>유니코드 객체를 안드로이드와 VxWorks에서 UTF-8로 인코딩하거나, 다른 플랫폼에서 현재 로케일 인코딩으로 인코딩합니다. 지원되는 에러 처리기는 <code class="docutils literal notranslate"><span class="pre">&quot;strict&quot;</span></code>와 <code class="docutils literal notranslate"><span class="pre">&quot;surrogateescape&quot;</span></code>(<span class="target" id="index-18"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a>)입니다. 인코더는 <em>errors</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면 <code class="docutils literal notranslate"><span class="pre">&quot;strict&quot;</span></code> 에러 처리기를 사용합니다. <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체를 반환합니다. <em>unicode</em>는 내장된 널 문자를 포함할 수 없습니다.</p>
<p>문자열을 <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code>(파이썬 시작 시 읽은 로케일 인코딩)으로 인코딩하려면 <a class="reference internal" href="#c.PyUnicode_EncodeFSDefault" title="PyUnicode_EncodeFSDefault"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeFSDefault()</span></code></a>를 사용하십시오.</p>
<p>이 함수는 파이썬 UTF-8 모드를 무시합니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EncodeLocale()</span></code></a> 함수.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이 함수는 이제 안드로이드를 제외하고 <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> 에러 처리기에 현재 로케일 인코딩도 사용합니다. 이전에는 <a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EncodeLocale()</span></code></a>이 <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code>에 사용되었고, 현재 로케일 인코딩은 <code class="docutils literal notranslate"><span class="pre">strict</span></code>에 사용되었습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="file-system-encoding">
<h3>파일 시스템 인코딩<a class="headerlink" href="#file-system-encoding" title="제목 주소">¶</a></h3>
<p>파일 이름과 기타 환경 문자열을 인코딩하고 디코딩하려면, <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> 을 인코딩으로 사용하고, <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code>를 에러 처리기로 사용해야 합니다 (<span class="target" id="index-19"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a>과 <span class="target" id="index-20"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0529"><strong>PEP 529</strong></a>). 인자 구문 분석 중에 파일 이름을 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>로 인코딩하려면, <code class="docutils literal notranslate"><span class="pre">&quot;O&amp;&quot;</span></code> 변환기를 사용하고 <a class="reference internal" href="#c.PyUnicode_FSConverter" title="PyUnicode_FSConverter"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FSConverter()</span></code></a>를 변환 함수로 전달해야 합니다:</p>
<dl class="function">
<dt id="c.PyUnicode_FSConverter">
int <code class="sig-name descname">PyUnicode_FSConverter</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>*<em> obj</em>, void*<em> result</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FSConverter" title="정의 주소">¶</a></dt>
<dd><p>ParseTuple 변환기: (직접 또는 <a class="reference internal" href="../library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> 인터페이스를 통해 얻은) <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체를 <a class="reference internal" href="#c.PyUnicode_EncodeFSDefault" title="PyUnicode_EncodeFSDefault"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeFSDefault()</span></code></a>를 사용하여 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>로 인코딩합니다; <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체는 있는 그대로의 출력입니다. <em>result</em>는 더는 사용되지 않을 때 해제해야 하는 <a class="reference internal" href="bytes.html#c.PyBytesObject" title="PyBytesObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBytesObject*</span></code></a>여야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<p>인자 구문 분석 중에 파일 이름을 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로 디코딩하려면, <code class="docutils literal notranslate"><span class="pre">&quot;O&amp;&quot;</span></code> 변환기를 사용하고 <a class="reference internal" href="#c.PyUnicode_FSDecoder" title="PyUnicode_FSDecoder"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FSDecoder()</span></code></a>를 변환 함수로 전달해야 합니다:</p>
<dl class="function">
<dt id="c.PyUnicode_FSDecoder">
int <code class="sig-name descname">PyUnicode_FSDecoder</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>*<em> obj</em>, void*<em> result</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FSDecoder" title="정의 주소">¶</a></dt>
<dd><p>ParseTuple 변환기: (직접 또는 <a class="reference internal" href="../library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> 인터페이스를 통해 간접적으로 얻은) <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체를 <a class="reference internal" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="PyUnicode_DecodeFSDefaultAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeFSDefaultAndSize()</span></code></a>를 사용하여 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로 디코딩합니다; <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체는 있는 그대로의 출력입니다. <em>result</em>는 더는 사용되지 않을 때 해제해야 하는 <a class="reference internal" href="#c.PyUnicodeObject" title="PyUnicodeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyUnicodeObject*</span></code></a>여야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeFSDefaultAndSize">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeFSDefaultAndSize</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> 과 <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> 에러 처리기를 사용하여 문자열을 디코딩합니다.</p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> 이 설정되지 않으면, 로케일 인코딩으로 폴백합니다.</p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> 은 시작 시 로케일 인코딩에서 초기화되며 나중에 수정할 수 없습니다. 현재 로케일 인코딩에서 문자열을 디코딩해야 하면, <a class="reference internal" href="#c.PyUnicode_DecodeLocaleAndSize" title="PyUnicode_DecodeLocaleAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeLocaleAndSize()</span></code></a>를 사용하십시오.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 함수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> 에러 처리기를 사용합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeFSDefault">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeFSDefault</code><span class="sig-paren">(</span>const char<em> *s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeFSDefault" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> 과 <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> 에러 처리기를 사용하여 널 종료 문자열을 디코딩합니다.</p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> 이 설정되지 않으면, 로케일 인코딩으로 폴백합니다.</p>
<p>문자열 길이를 알고 있으면 <a class="reference internal" href="#c.PyUnicode_DecodeFSDefaultAndSize" title="PyUnicode_DecodeFSDefaultAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeFSDefaultAndSize()</span></code></a>를 사용하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> 에러 처리기를 사용합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeFSDefault">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeFSDefault</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeFSDefault" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> 에러 처리기를 사용하여 유니코드 객체를 <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code>로 인코딩하고, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>를 반환합니다. 결과 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체에는 널 바이트가 포함될 수 있음에 유의하십시오.</p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> 이 설정되지 않으면, 로케일 인코딩으로 폴백합니다.</p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> 은 시작 시 로케일 인코딩에서 초기화되며 나중에 수정할 수 없습니다. 현재 로케일 인코딩으로 문자열을 인코딩해야 하면, <a class="reference internal" href="#c.PyUnicode_EncodeLocale" title="PyUnicode_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeLocale()</span></code></a>을 사용하십시오.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EncodeLocale()</span></code></a> 함수.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncodeErrors</span></code> 에러 처리기를 사용합니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="wchar-t-support">
<h3>wchar_t 지원<a class="headerlink" href="#wchar-t-support" title="제목 주소">¶</a></h3>
<p>지원하는 플랫폼에 대한 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> 지원:</p>
<dl class="function">
<dt id="c.PyUnicode_FromWideChar">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_FromWideChar</code><span class="sig-paren">(</span>const wchar_t<em> *w</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FromWideChar" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>주어진 <em>size</em>의 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> 버퍼 <em>w</em>에서 유니코드 객체를 만듭니다. <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 <em>size</em>로 전달하면 함수가 wcslen을 사용하여 길이를 스스로 계산해야 함을 나타냅니다. 실패하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsWideChar">
Py_ssize_t <code class="sig-name descname">PyUnicode_AsWideChar</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, wchar_t<em> *w</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsWideChar" title="정의 주소">¶</a></dt>
<dd><p>유니코드 객체 내용을 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> 버퍼 <em>w</em>에 복사합니다. 최대 <em>size</em> <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> 문자가 복사됩니다 (후행 널 종료 문자가 제외될 수 있습니다). 복사된 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> 문자 수나 에러가 발생하면 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다. 결과 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code> 문자열은 널로 종료될 수도 있고 아닐 수도 있음에 유의하십시오. 응용 프로그램에 필요하면 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code> 문자열이 널로 끝나는지 확인하는 것은 호출자의 책임입니다. 또한, <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code> 문자열에는 널 문자가 포함될 수 있으며, 이로 인해 대부분의 C 함수와 함께 사용될 때 문자열이 잘리게 됨에 유의하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsWideCharString">
wchar_t* <code class="sig-name descname">PyUnicode_AsWideCharString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> *size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsWideCharString" title="정의 주소">¶</a></dt>
<dd><p>유니코드 객체를 와이드 문자 문자열로 변환합니다. 출력 문자열은 항상 널 문자로 끝납니다. <em>size</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니면, (후행 널 종료 문자를 제외한) 와이드 문자의 수를 <em>*size</em>에 씁니다. 결과 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> 문자열이 널 문자를 포함할 수 있고, 이로 인해 대부분의 C 함수와 함께 사용될 때 문자열이 잘리게 됨에 유의하십시오. <em>size</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이고 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code> 문자열이 널 문자를 포함하면 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p>성공 시 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Alloc()</span></code>에 의해 할당된 버퍼를 반환합니다 (<a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a>를 사용하여 해제하십시오). 에러 시, <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환하고 <em>*size</em>는 정의되지 않습니다. 메모리 할당이 실패하면 <a class="reference internal" href="../library/exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a>를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>size</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이고 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t*</span></code> 문자열이 널 문자를 포함하면 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="built-in-codecs">
<span id="builtincodecs"></span><h2>내장 코덱<a class="headerlink" href="#built-in-codecs" title="제목 주소">¶</a></h2>
<p>파이썬은 속도를 위해 C로 작성된 내장 코덱 집합을 제공합니다. 이러한 코덱들은 모두 다음 함수들을 통해 직접 사용할 수 있습니다.</p>
<p>다음 API의 대부분은 두 개의 인자 encoding과 errors를 취하며, 내장 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 문자열 객체 생성자의 것들과 같은 의미입니다.</p>
<p>encoding을 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정하면 기본 인코딩인 UTF-8이 사용됩니다. 파일 시스템 호출은 파일 이름 인코딩에 <a class="reference internal" href="#c.PyUnicode_FSConverter" title="PyUnicode_FSConverter"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FSConverter()</span></code></a>를 사용해야 합니다. 이것은 내부적으로 변수 <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_FileSystemDefaultEncoding</span></code> 을 사용합니다. 이 변수는 읽기 전용으로 처리되어야 합니다: 일부 시스템에서는 정적 문자열에 대한 포인터가 되고, 다른 시스템에서는 실행 시간에 변경됩니다 (가령 응용 프로그램이 setlocale을 호출할 때).</p>
<p>에러 처리는 errors로 설정되는데, 코덱에 대해 정의된 기본 처리를 사용함을 의미하는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정될 수도 있습니다. 모든 내장 코덱에 대한 기본 에러 처리는 &quot;strict&quot; 입니다 (<a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다).</p>
<p>코덱은 모두 유사한 인터페이스를 사용합니다. 단순성을 위해 다음에 나오는 일반 코덱과의 차이만 설명합니다.</p>
<div class="section" id="generic-codecs">
<h3>일반 코덱<a class="headerlink" href="#generic-codecs" title="제목 주소">¶</a></h3>
<p>다음은 일반 코덱 API입니다:</p>
<dl class="function">
<dt id="c.PyUnicode_Decode">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Decode</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *encoding</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Decode" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>인코딩된 문자열 <em>s</em>의 <em>size</em> 바이트를 디코딩하여 유니코드 객체를 만듭니다. <em>encoding</em>과 <em>errors</em>는 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 내장 함수의 같은 이름의 매개 변수와 같은 의미입니다. 사용할 코덱은 파이썬 코덱 레지스트리를 사용하여 조회됩니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsEncodedString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsEncodedString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, const char<em> *encoding</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsEncodedString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>유니코드 객체를 인코딩하고 결과를 파이썬 bytes 객체로 반환합니다. <em>encoding</em>과 <em>errors</em>는 유니코드 <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a> 메서드의 같은 이름의 매개 변수와 같은 의미입니다. 사용할 코덱은 파이썬 코덱 레지스트리를 사용하여 조회됩니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Encode">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Encode</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *encoding</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Encode" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>주어진 <em>size</em>의 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 버퍼 <em>s</em>를 인코딩하고 파이썬 bytes 객체를 반환합니다. <em>encoding</em>과 <em>errors</em>는 유니코드 <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a> 메서드의 같은 이름의 매개 변수와 같은 의미입니다. 사용할 코덱은 파이썬 코덱 레지스트리를 사용하여 조회됩니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>이전 스타일 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="utf-8-codecs">
<h3>UTF-8 코덱<a class="headerlink" href="#utf-8-codecs" title="제목 주소">¶</a></h3>
<p>다음은 UTF-8 코덱 API입니다:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUTF8">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF8</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF8" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>UTF-8로 인코딩된 문자열 <em>s</em>의 <em>size</em> 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeUTF8Stateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF8Stateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF8Stateful" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><em>consumed</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, <a class="reference internal" href="#c.PyUnicode_DecodeUTF8" title="PyUnicode_DecodeUTF8"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF8()</span></code></a>처럼 동작합니다. <em>consumed</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니면, 후행 불완전한 UTF-8 바이트 시퀀스는 에러로 처리되지 않습니다. 이러한 바이트는 디코딩되지 않으며 디코딩된 바이트 수는 <em>consumed</em>에 저장됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF8String">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsUTF8String</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF8String" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>UTF-8을 사용하여 유니코드 객체를 인코딩하고 결과를 파이썬 bytes 객체로 반환합니다. 에러 처리는 &quot;strict&quot; 입니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF8AndSize">
const char* <code class="sig-name descname">PyUnicode_AsUTF8AndSize</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, Py_ssize_t<em> *size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF8AndSize" title="정의 주소">¶</a></dt>
<dd><p>유니코드 객체의 UTF-8 인코딩에 대한 포인터를 반환하고, 인코딩된 표현의 크기를 (바이트 단위로) <em>size</em>에 저장합니다. <em>size</em> 인자는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 수 있습니다; 이 경우 크기가 저장되지 않습니다. 반환된 버퍼에는 다른 널 코드 포인트가 있는지에 관계없이, 항상 추가 널 바이트가 추가됩니다 (<em>size</em>에 포함되지 않습니다).</p>
<p>에러가 발생하면, <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 예외 설정과 함께 반환되고 <em>size</em>가 저장되지 않습니다.</p>
<p>이것은 유니코드 객체에서 문자열의 UTF-8 표현을 캐시하고, 후속 호출은 같은 버퍼에 대한 포인터를 반환합니다. 호출자는 버퍼 할당 해제에 대한 책임이 없습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>반환형은 이제 <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>가 아니라 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code>입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF8">
const char* <code class="sig-name descname">PyUnicode_AsUTF8</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF8" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyUnicode_AsUTF8AndSize" title="PyUnicode_AsUTF8AndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF8AndSize()</span></code></a>와 같지만, 크기를 저장하지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>반환형은 이제 <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>가 아니라 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code>입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUTF8">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUTF8</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUTF8" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>UTF-8을 사용하여 주어진 <em>size</em>의 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 버퍼 <em>s</em>를 인코딩하고 파이썬 bytes 객체를 반환합니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>이전 스타일 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="#c.PyUnicode_AsUTF8String" title="PyUnicode_AsUTF8String"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF8String()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_AsUTF8AndSize" title="PyUnicode_AsUTF8AndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF8AndSize()</span></code></a> 나 <a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="utf-32-codecs">
<h3>UTF-32 코덱<a class="headerlink" href="#utf-32-codecs" title="제목 주소">¶</a></h3>
<p>다음은 UTF-32 코덱 API입니다:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUTF32">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF32</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> *byteorder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF32" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>UTF-32로 인코딩된 버퍼 문자열에서 <em>size</em> 바이트를 디코딩하고 해당 유니코드 객체를 반환합니다. <em>errors</em>(<code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니면)는 에러 처리를 정의합니다. 기본값은 &quot;strict&quot;입니다.</p>
<p><em>byteorder</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니면, 디코더는 지정된 바이트 순서를 사용하여 디코딩을 시작합니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">little</span> <span class="n">endian</span>
<span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>  <span class="n">native</span> <span class="n">order</span>
<span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="mi">1</span><span class="o">:</span>  <span class="n">big</span> <span class="n">endian</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">*byteorder</span></code>가 0이고, 입력 데이터의 처음 4바이트가 바이트 순서 표시(BOM)이면, 디코더가 이 바이트 순서로 전환되고 BOM은 결과 유니코드 문자열에 복사되지 않습니다. <code class="docutils literal notranslate"><span class="pre">*byteorder</span></code>가 <code class="docutils literal notranslate"><span class="pre">-1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">1</span></code>이면, 모든 바이트 순서 표시가 출력에 복사됩니다.</p>
<p>완료 후, <em>*byteorder</em>는 입력 데이터의 끝에서 현재 바이트 순서로 설정됩니다.</p>
<p><em>byteorder</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, 코덱은 네이티브 순서 모드로 시작합니다.</p>
<p>코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeUTF32Stateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF32Stateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> *byteorder</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF32Stateful" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><em>consumed</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, <a class="reference internal" href="#c.PyUnicode_DecodeUTF32" title="PyUnicode_DecodeUTF32"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF32()</span></code></a>처럼 동작합니다. <em>consumed</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니면, <a class="reference internal" href="#c.PyUnicode_DecodeUTF32Stateful" title="PyUnicode_DecodeUTF32Stateful"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF32Stateful()</span></code></a> 은 후행 불완전 UTF-32 바이트 시퀀스(가령 4로 나누어떨어지지 않는 바이트 수)를 에러로 처리하지 않습니다. 이러한 바이트는 디코딩되지 않으며 디코딩된 바이트 수는 <em>consumed</em>에 저장됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF32String">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsUTF32String</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF32String" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>네이티브 바이트 순서로 UTF-32 인코딩을 사용하여 파이썬 바이트 문자열을 반환합니다. 문자열은 항상 BOM 마크로 시작합니다. 에러 처리는 &quot;strict&quot;입니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUTF32">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUTF32</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> byteorder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUTF32" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><em>s</em>에 있는 유니코드 데이터의 UTF-32로 인코딩된 값을 포함하는 파이썬 bytes 객체를 반환합니다. 출력은 다음 바이트 순서에 따라 기록됩니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">byteorder</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">little</span> <span class="n">endian</span>
<span class="n">byteorder</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>  <span class="n">native</span> <span class="n">byte</span> <span class="n">order</span> <span class="p">(</span><span class="n">writes</span> <span class="n">a</span> <span class="n">BOM</span> <span class="n">mark</span><span class="p">)</span>
<span class="n">byteorder</span> <span class="o">==</span> <span class="mi">1</span><span class="o">:</span>  <span class="n">big</span> <span class="n">endian</span>
</pre></div>
</div>
<p>byteorder가 <code class="docutils literal notranslate"><span class="pre">0</span></code>이면, 출력 문자열은 항상 유니코드 BOM 마크(U+FEFF)로 시작합니다. 다른 두 모드에서는, BOM 마크가 앞에 추가되지 않습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">Py_UNICODE_WIDE</span></code>가 정의되지 않으면, 서로게이트 쌍이 단일 코드 포인트로 출력됩니다.</p>
<p>코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>이전 스타일 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다. <a class="reference internal" href="#c.PyUnicode_AsUTF32String" title="PyUnicode_AsUTF32String"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF32String()</span></code></a> 이나 <a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="utf-16-codecs">
<h3>UTF-16 코덱<a class="headerlink" href="#utf-16-codecs" title="제목 주소">¶</a></h3>
<p>다음은 UTF-16 코덱 API입니다:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUTF16">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF16</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> *byteorder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF16" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>UTF-16으로 인코딩된 버퍼 문자열에서 <em>size</em> 바이트를 디코딩하고 해당 유니코드 객체를 반환합니다. <em>errors</em>(<code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니면)는 에러 처리를 정의합니다. 기본값은 &quot;strict&quot;입니다.</p>
<p><em>byteorder</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니면, 디코더는 지정된 바이트 순서를 사용하여 디코딩을 시작합니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">little</span> <span class="n">endian</span>
<span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>  <span class="n">native</span> <span class="n">order</span>
<span class="o">*</span><span class="n">byteorder</span> <span class="o">==</span> <span class="mi">1</span><span class="o">:</span>  <span class="n">big</span> <span class="n">endian</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">*byteorder</span></code>가 0이고, 입력 데이터의 처음 2바이트가 바이트 순서 표시(BOM)이면, 디코더는 이 바이트 순서로 전환되고 BOM은 결과 유니코드 문자열에 복사되지 않습니다. <code class="docutils literal notranslate"><span class="pre">*byteorder</span></code>가 <code class="docutils literal notranslate"><span class="pre">-1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">1</span></code>이면 모든 바이트 순서 표시가 출력에 복사됩니다 (<code class="docutils literal notranslate"><span class="pre">\ufeff</span></code>나 <code class="docutils literal notranslate"><span class="pre">\ufffe</span></code> 문자가 됩니다).</p>
<p>완료 후, <em>*byteorder</em>는 입력 데이터의 끝에서 현재 바이트 순서로 설정됩니다.</p>
<p><em>byteorder</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, 코덱은 네이티브 순서 모드로 시작합니다.</p>
<p>코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeUTF16Stateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF16Stateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> *byteorder</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF16Stateful" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><em>consumed</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, <a class="reference internal" href="#c.PyUnicode_DecodeUTF16" title="PyUnicode_DecodeUTF16"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF16()</span></code></a>처럼 동작합니다. <em>consumed</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니면, <a class="reference internal" href="#c.PyUnicode_DecodeUTF16Stateful" title="PyUnicode_DecodeUTF16Stateful"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF16Stateful()</span></code></a> 은 후행 불완전 UTF-16 바이트 시퀀스(가령 홀수 바이트 수나 분할 서로게이트 쌍)를 에러로 처리하지 않습니다. 이러한 바이트는 디코딩되지 않으며 디코딩된 바이트 수는 <em>consumed</em>에 저장됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUTF16String">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsUTF16String</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUTF16String" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>네이티브 바이트 순서로 UTF-16 인코딩을 사용하여 파이썬 바이트 문자열을 반환합니다. 문자열은 항상 BOM 마크로 시작합니다. 에러 처리는 &quot;strict&quot;입니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUTF16">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUTF16</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, int<em> byteorder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUTF16" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><em>s</em>에 있는 유니코드 데이터의 UTF-16 인코딩된 값을 포함하는 파이썬 bytes 객체를 반환합니다. 출력은 다음 바이트 순서에 따라 기록됩니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">byteorder</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">little</span> <span class="n">endian</span>
<span class="n">byteorder</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>  <span class="n">native</span> <span class="n">byte</span> <span class="n">order</span> <span class="p">(</span><span class="n">writes</span> <span class="n">a</span> <span class="n">BOM</span> <span class="n">mark</span><span class="p">)</span>
<span class="n">byteorder</span> <span class="o">==</span> <span class="mi">1</span><span class="o">:</span>  <span class="n">big</span> <span class="n">endian</span>
</pre></div>
</div>
<p>byteorder가 <code class="docutils literal notranslate"><span class="pre">0</span></code>이면, 출력 문자열은 항상 유니코드 BOM 마크(U+FEFF)로 시작합니다. 다른 두 모드에서는, BOM 마크가 앞에 추가되지 않습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">Py_UNICODE_WIDE</span></code>가 정의되면, 단일 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 값이 서로게이트 쌍으로 표시될 수 있습니다. 정의되지 않으면, 각 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 값은 UCS-2 문자로 해석됩니다.</p>
<p>코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>이전 스타일 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="#c.PyUnicode_AsUTF16String" title="PyUnicode_AsUTF16String"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUTF16String()</span></code></a> 이나 <a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="utf-7-codecs">
<h3>UTF-7 코덱<a class="headerlink" href="#utf-7-codecs" title="제목 주소">¶</a></h3>
<p>다음은 UTF-7 코덱 API입니다:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUTF7">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF7</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF7" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>UTF-7로 인코딩된 문자열 <em>s</em>의 <em>size</em> 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeUTF7Stateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUTF7Stateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUTF7Stateful" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><em>consumed</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, <a class="reference internal" href="#c.PyUnicode_DecodeUTF7" title="PyUnicode_DecodeUTF7"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeUTF7()</span></code></a>처럼 동작합니다. <em>consumed</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니면, 후행 불완전한 UTF-7 base-64 섹션은 에러로 처리되지 않습니다. 이러한 바이트는 디코딩되지 않으며 디코딩된 바이트 수는 <em>consumed</em>에 저장됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUTF7">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUTF7</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, int<em> base64SetO</em>, int<em> base64WhiteSpace</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUTF7" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>UTF-7을 사용하여 주어진 크기의 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 버퍼를 인코딩하고 파이썬 bytes 객체를 반환합니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<p><em>base64SetO</em> 가 0이 아니면, &quot;Set O&quot;(다른 특별한 의미가 없는 구두점)는 base-64로 인코딩됩니다. <em>base64WhiteSpace</em> 가 0이 아니면, 공백은 base-64로 인코딩됩니다. 파이썬 &quot;utf-7&quot; 코덱의 경우 둘 다 0으로 설정됩니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>이전 스타일 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="unicode-escape-codecs">
<h3>유니코드 이스케이프 코덱<a class="headerlink" href="#unicode-escape-codecs" title="제목 주소">¶</a></h3>
<p>다음은 &quot;유니코드 이스케이프(Unicode Escape)&quot; 코덱 API입니다:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeUnicodeEscape">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeUnicodeEscape</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeUnicodeEscape" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>유니코드 이스케이프 인코딩된 문자열 <em>s</em>의 <em>size</em> 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsUnicodeEscapeString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsUnicodeEscapeString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsUnicodeEscapeString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>유니코드 이스케이프를 사용하여 유니코드 객체를 인코딩하고 결과를 bytes 객체로 반환합니다. 에러 처리는 &quot;strict&quot;입니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeUnicodeEscape">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeUnicodeEscape</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeUnicodeEscape" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>유니코드 이스케이프를 사용하여 주어진 <em>size</em>의 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 버퍼를 인코딩하고 bytes 객체를 반환합니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>이전 스타일 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="#c.PyUnicode_AsUnicodeEscapeString" title="PyUnicode_AsUnicodeEscapeString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsUnicodeEscapeString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="raw-unicode-escape-codecs">
<h3>원시 유니코드 이스케이프 코덱<a class="headerlink" href="#raw-unicode-escape-codecs" title="제목 주소">¶</a></h3>
<p>다음은 &quot;원시 유니코드 이스케이프(Raw Unicode Escape)&quot; 코덱 API입니다:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeRawUnicodeEscape">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeRawUnicodeEscape</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeRawUnicodeEscape" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>원시 유니코드 이스케이프 인코딩된 문자열 <em>s</em>의 <em>size</em> 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsRawUnicodeEscapeString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsRawUnicodeEscapeString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsRawUnicodeEscapeString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>원시 유니코드 이스케이프를 사용하여 유니코드 객체를 인코딩하고 결과를 bytes 객체로 반환합니다. 에러 처리는 &quot;strict&quot;입니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeRawUnicodeEscape">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeRawUnicodeEscape</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeRawUnicodeEscape" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>원시 유니코드 이스케이프를 사용하여 주어진 <em>size</em>의 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 버퍼를 인코딩하고 bytes 객체를 반환합니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>이전 스타일 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="#c.PyUnicode_AsRawUnicodeEscapeString" title="PyUnicode_AsRawUnicodeEscapeString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsRawUnicodeEscapeString()</span></code></a> 이나 <a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="latin-1-codecs">
<h3>Latin-1 코덱<a class="headerlink" href="#latin-1-codecs" title="제목 주소">¶</a></h3>
<p>다음은 Latin-1 코덱 API입니다: Latin-1은 처음 256개의 유니코드 서수에 해당하며 인코딩 중에 코덱에서 이들만 허용됩니다.</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeLatin1">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeLatin1</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeLatin1" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Latin-1 인코딩된 문자열 <em>s</em>의 <em>size</em> 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsLatin1String">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsLatin1String</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsLatin1String" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Latin-1을 사용하여 유니코드 객체를 인코딩하고 결과를 파이썬 bytes 객체로 반환합니다. 에러 처리는 &quot;strict&quot;입니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeLatin1">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeLatin1</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeLatin1" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Latin-1을 사용하여 주어진 <em>size</em>의 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 버퍼를 인코딩하고 파이썬 bytes 객체를 반환합니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>이전 스타일 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="#c.PyUnicode_AsLatin1String" title="PyUnicode_AsLatin1String"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsLatin1String()</span></code></a> 이나 <a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="ascii-codecs">
<h3>ASCII 코덱<a class="headerlink" href="#ascii-codecs" title="제목 주소">¶</a></h3>
<p>다음은 ASCII 코덱 API입니다. 7비트 ASCII 데이터만 허용됩니다. 다른 모든 코드는 에러를 생성합니다.</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeASCII">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeASCII</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeASCII" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>ASCII 인코딩된 문자열 <em>s</em>의 <em>size</em> 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsASCIIString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsASCIIString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsASCIIString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>ASCII를 사용하여 유니코드 객체를 인코딩하고 결과를 파이썬 bytes 객체로 반환합니다. 에러 처리는 &quot;strict&quot;입니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeASCII">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeASCII</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeASCII" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>ASCII를 사용하여 주어진 <em>size</em>의 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 버퍼를 인코딩하고 파이썬 bytes 객체를 반환합니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>이전 스타일 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="#c.PyUnicode_AsASCIIString" title="PyUnicode_AsASCIIString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsASCIIString()</span></code></a> 이나 <a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="character-map-codecs">
<h3>문자 맵 코덱<a class="headerlink" href="#character-map-codecs" title="제목 주소">¶</a></h3>
<p>이 코덱은 다양한 코덱을 구현하는 데 사용할 수 있다는 점에서 특별합니다 (실제로 <code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings</span></code> 패키지에 포함된 대부분의 표준 코덱을 얻기 위해 수행되었습니다). 코덱은 매핑을 사용하여 문자를 인코딩하고 디코딩합니다. 제공된 매핑 객체는 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 매핑 인터페이스를 지원해야 합니다; 딕셔너리와 시퀀스가 잘 작동합니다.</p>
<p>다음은 매핑 코덱 API입니다:</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeCharmap">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeCharmap</code><span class="sig-paren">(</span>const char<em> *data</em>, Py_ssize_t<em> size</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *mapping</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeCharmap" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>주어진 <em>mapping</em> 객체를 사용하여 인코딩된 문자열 <em>s</em>의 <em>size</em> 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<p><em>mapping</em>이 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, Latin-1 디코딩이 적용됩니다. 그렇지 않으면 <em>mapping</em>은 바이트 서수(0에서 255 사이의 정수)를 유니코드 문자열, 정수(유니코드 서수로 해석됩니다) 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 매핑해야합니다. 매핑되지 않은 데이터 바이트(<code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">0xFFFE</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'\ufffe'</span></code>로 매핑되는 것뿐만 아니라, <a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 유발하는 것)은 정의되지 않은 매핑으로 처리되어 에러를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsCharmapString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsCharmapString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsCharmapString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>주어진 <em>mapping</em> 객체를 사용하여 유니코드 객체를 인코딩하고 결과를 bytes 객체로 반환합니다. 에러 처리는 &quot;strict&quot;입니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<p><em>mapping</em> 객체는 유니코드 서수 정수를 bytes 객체, 0에서 255 사이의 정수 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 매핑해야 합니다. <code class="docutils literal notranslate"><span class="pre">None</span></code>에 매핑되는 것뿐만 아니라 매핑되지 않은 문자 서수(<a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 유발하는 것)는 &quot;정의되지 않은 매핑&quot;으로 처리되어 에러가 발생합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeCharmap">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeCharmap</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *mapping</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeCharmap" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>주어진 <em>mapping</em> 객체를 사용하여 주어진 <em>size</em>의 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 버퍼를 인코딩하고 그 결과를 bytes 객체로 반환합니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>이전 스타일 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="#c.PyUnicode_AsCharmapString" title="PyUnicode_AsCharmapString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsCharmapString()</span></code></a> 이나 <a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

<p>다음 코덱 API는 유니코드를 유니코드로 매핑한다는 점에서 특별합니다.</p>
<dl class="function">
<dt id="c.PyUnicode_Translate">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Translate</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *table</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Translate" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>문자 매핑 테이블을 적용하여 문자열을 변환하고 결과 유니코드 객체를 반환합니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<p>매핑 테이블은 유니코드 서수 정수를 유니코드 서수 정수나 <code class="docutils literal notranslate"><span class="pre">None</span></code>(문자가 삭제되도록 합니다)에 매핑해야 합니다.</p>
<p>매핑 테이블은 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 인터페이스 만 제공하면 됩니다; 딕셔너리와 시퀀스가 잘 작동합니다. 매핑되지 않은 문자 서수(<a class="reference internal" href="../library/exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 유발하는 것)는 건드리지 않고 그대로 복사됩니다.</p>
<p><em>errors</em>는 코덱에서의 일반적인 의미입니다. 기본 에러 처리를 사용함을 나타내는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_TranslateCharmap">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_TranslateCharmap</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *mapping</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_TranslateCharmap" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>문자 <em>mapping</em> 테이블을 적용하여 주어진 <em>size</em>의 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 버퍼를 변환하고 결과 유니코드 객체를 반환합니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 3.11: </span>이전 스타일 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="#c.PyUnicode_Translate" title="PyUnicode_Translate"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_Translate()</span></code></a>나 <a class="reference internal" href="codec.html#codec-registry"><span class="std std-ref">일반 코덱 기반 API</span></a>를 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="mbcs-codecs-for-windows">
<h3>윈도우 용 MBCS 코덱<a class="headerlink" href="#mbcs-codecs-for-windows" title="제목 주소">¶</a></h3>
<p>다음은 MBCS 코덱 API입니다. 현재 윈도우에서만 사용할 수 있으며 Win32 MBCS 변환기를 사용하여 변환을 구현합니다. MBCS(또는 DBCS)는 단지 하나가 아니라 인코딩 클래스임에 유의하십시오. 대상 인코딩은 코덱을 실행하는 기계의 사용자 설정에 의해 정의됩니다.</p>
<dl class="function">
<dt id="c.PyUnicode_DecodeMBCS">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeMBCS</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeMBCS" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>MBCS 인코딩된 문자열 <em>s</em>의 <em>size</em> 바이트를 디코딩하여 유니코드 객체를 만듭니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_DecodeMBCSStateful">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_DecodeMBCSStateful</code><span class="sig-paren">(</span>const char<em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em>, Py_ssize_t<em> *consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_DecodeMBCSStateful" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><em>consumed</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, <a class="reference internal" href="#c.PyUnicode_DecodeMBCS" title="PyUnicode_DecodeMBCS"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeMBCS()</span></code></a>처럼 동작합니다. <em>consumed</em>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니면, <a class="reference internal" href="#c.PyUnicode_DecodeMBCSStateful" title="PyUnicode_DecodeMBCSStateful"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_DecodeMBCSStateful()</span></code></a> 은 후행 선행(lead) 바이트를 디코딩하지 않고 디코딩된 바이트 수가 <em>consumed</em>에 저장됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_AsMBCSString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_AsMBCSString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_AsMBCSString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>MBCS를 사용하여 유니코드 객체를 인코딩하고 결과를 파이썬 bytes 객체로 반환합니다. 에러 처리는 &quot;strict&quot;입니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeCodePage">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeCodePage</code><span class="sig-paren">(</span>int<em> code_page</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *unicode</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeCodePage" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>지정된 코드 페이지를 사용하여 유니코드 객체를 인코딩하고 파이썬 bytes 객체를 반환합니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다. <code class="xref c c-data docutils literal notranslate"><span class="pre">CP_ACP</span></code> 코드 페이지를 사용하여 MBCS 인코더를 얻습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_EncodeMBCS">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_EncodeMBCS</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE">Py_UNICODE</a><em> *s</em>, Py_ssize_t<em> size</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_EncodeMBCS" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>MBCS를 사용하여 주어진 <em>size</em>의 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> 버퍼를 인코딩하고 파이썬 bytes 객체를 반환합니다. 코덱에서 예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.3, will be removed in version 4.0: </span>이전 스타일 <a class="reference internal" href="#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> API의 일부입니다; <a class="reference internal" href="#c.PyUnicode_AsMBCSString" title="PyUnicode_AsMBCSString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsMBCSString()</span></code></a>, <a class="reference internal" href="#c.PyUnicode_EncodeCodePage" title="PyUnicode_EncodeCodePage"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_EncodeCodePage()</span></code></a> 또는 <a class="reference internal" href="#c.PyUnicode_AsEncodedString" title="PyUnicode_AsEncodedString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_AsEncodedString()</span></code></a> 을 사용하여 마이그레이션 하십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="methods-slots">
<h3>메서드와 슬롯<a class="headerlink" href="#methods-slots" title="제목 주소">¶</a></h3>
</div>
</div>
<div class="section" id="methods-and-slot-functions">
<span id="unicodemethodsandslots"></span><h2>메서드와 슬롯 함수<a class="headerlink" href="#methods-and-slot-functions" title="제목 주소">¶</a></h2>
<p>다음 API는 입력의 유니코드 객체와 문자열을 (설명에서 문자열이라고 하겠습니다) 처리할 수 있으며 적절하게 유니코드 객체나 정수를 반환합니다.</p>
<p>예외가 발생하면 모두 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이나 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다.</p>
<dl class="function">
<dt id="c.PyUnicode_Concat">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Concat</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *left</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *right</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Concat" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>두 문자열을 이어붙여 하나의 새로운 유니코드 문자열을 제공합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Split">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Split</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *s</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *sep</em>, Py_ssize_t<em> maxsplit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Split" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>문자열을 분할하여 유니코드 문자열 리스트를 제공합니다. <em>sep</em>이 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, 모든 공백 부분 문자열에서 분할이 수행됩니다. 그렇지 않으면, 주어진 구분자에서 분할이 일어납니다. 최대 <em>maxsplit</em> 분할이 수행됩니다. 음수이면, 제한이 설정되지 않습니다. 구분자는 결과 리스트에 포함되지 않습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Splitlines">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Splitlines</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *s</em>, int<em> keepend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Splitlines" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>줄 바꿈에서 유니코드 문자열을 분할하여, 유니코드 문자열 리스트를 반환합니다. CRLF는 하나의 줄 바꿈으로 간주합니다. <em>keepend</em>가 <code class="docutils literal notranslate"><span class="pre">0</span></code>이면, 결과 문자열에 줄 바꿈 문자가 포함되지 않습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Join">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Join</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *separator</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *seq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Join" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>주어진 <em>separator</em>를 사용하여 문자열 시퀀스를 연결하고 결과 유니코드 문자열을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Tailmatch">
Py_ssize_t <code class="sig-name descname">PyUnicode_Tailmatch</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *substr</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em>, int<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Tailmatch" title="정의 주소">¶</a></dt>
<dd><p><em>substr</em>이 주어진 꼬리 끝에서 (<em>direction</em> == <code class="docutils literal notranslate"><span class="pre">-1</span></code>은 접두사 일치를 수행함을 의미하고, <em>direction</em> == <code class="docutils literal notranslate"><span class="pre">1</span></code>은 접미사 일치를 의미합니다) <code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code>와 일치하면 <code class="docutils literal notranslate"><span class="pre">1</span></code>을 반환합니다, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다. 에러가 발생하면 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Find">
Py_ssize_t <code class="sig-name descname">PyUnicode_Find</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *substr</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em>, int<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Find" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>direction</em>을 사용하여 (<em>direction</em> == <code class="docutils literal notranslate"><span class="pre">1</span></code>은 정방향 검색을 의미하고, <em>direction</em> == <code class="docutils literal notranslate"><span class="pre">-1</span></code>은 역방향 검색을 의미합니다) <code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code>에서 <em>substr</em>의 첫 번째 위치를 반환합니다. 반환 값은 첫 번째 일치의 인덱스입니다; <code class="docutils literal notranslate"><span class="pre">-1</span></code> 값은 일치하는 항목이 없음을 나타내고, <code class="docutils literal notranslate"><span class="pre">-2</span></code>는 에러가 발생했고 예외가 설정되었음을 나타냅니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_FindChar">
Py_ssize_t <code class="sig-name descname">PyUnicode_FindChar</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="#c.Py_UCS4" title="Py_UCS4">Py_UCS4</a><em> ch</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em>, int<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_FindChar" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>direction</em>을 사용하여 (<em>direction</em> == <code class="docutils literal notranslate"><span class="pre">1</span></code>은 정방향 검색을 의미하고, <em>direction</em> == <code class="docutils literal notranslate"><span class="pre">-1</span></code>은 역방향 검색을 의미합니다) <code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code>에서 문자 <em>ch</em>의 첫 번째 위치를 반환합니다. 반환 값은 첫 번째 일치의 인덱스입니다; <code class="docutils literal notranslate"><span class="pre">-1</span></code> 값은 일치하는 항목이 없음을 나타내고, <code class="docutils literal notranslate"><span class="pre">-2</span></code>는 에러가 발생했고 예외가 설정되었음을 나타냅니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>start</em>와 <em>end</em>는 이제 <code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code>처럼 작동하도록 조정됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Count">
Py_ssize_t <code class="sig-name descname">PyUnicode_Count</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *substr</em>, Py_ssize_t<em> start</em>, Py_ssize_t<em> end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Count" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">str[start:end]</span></code>에서 <em>substr</em>이 겹치지 않게 등장하는 횟수를 반환합니다. 에러가 발생하면 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Replace">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Replace</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *str</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *substr</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *replstr</em>, Py_ssize_t<em> maxcount</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Replace" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><em>str</em>에서 <em>substr</em>의 최대 <em>maxcount</em> 등장을 <em>replstr</em>로 바꾸고 결과 유니코드 객체를 반환합니다. <em>maxcount</em> == <code class="docutils literal notranslate"><span class="pre">-1</span></code>은 모든 등장을 교체함을 의미합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Compare">
int <code class="sig-name descname">PyUnicode_Compare</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *left</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *right</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Compare" title="정의 주소">¶</a></dt>
<dd><p>두 문자열을 비교하고 각각 작음, 같음, 큼에 대해 <code class="docutils literal notranslate"><span class="pre">-1</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>을 반환합니다.</p>
<p>이 함수는 실패 시 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환하므로, 에러를 확인하기 위해 <a class="reference internal" href="exceptions.html#c.PyErr_Occurred" title="PyErr_Occurred"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_Occurred()</span></code></a>를 호출해야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_CompareWithASCIIString">
int <code class="sig-name descname">PyUnicode_CompareWithASCIIString</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *uni</em>, const char<em> *string</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_CompareWithASCIIString" title="정의 주소">¶</a></dt>
<dd><p>유니코드 객체 <em>uni</em>를 <em>string</em>과 비교하고 각각 작음, 같음, 큼에 대해 <code class="docutils literal notranslate"><span class="pre">-1</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>을 반환합니다. ASCII로 인코딩된 문자열만 전달하는 것이 가장 좋지만, 비 ASCII 문자가 포함되면 함수는 입력 문자열을 ISO-8859-1로 해석합니다.</p>
<p>이 함수는 예외를 발생시키지 않습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_RichCompare">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_RichCompare</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *left</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *right</em>, int<em> op</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_RichCompare" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>두 유니코드 문자열을 풍부한 비교(rich comparison) 하고 다음 중 하나를 반환합니다:</p>
<ul class="simple">
<li><p>예외가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p></li>
<li><p>성공적인 비교는 <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_True</span></code>나 <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_False</span></code></p></li>
<li><p>형 조합을 알 수 없으면 <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code></p></li>
</ul>
<p><em>op</em>에 가능한 값은 <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_GT</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_GE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_EQ</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_NE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_LT</span></code> 및 <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_LE</span></code>입니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Format">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_Format</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *format</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Format" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><em>format</em>과 <em>args</em>에서 새 문자열 객체를 반환합니다; 이것은 <code class="docutils literal notranslate"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">args</span></code>와 유사합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_Contains">
int <code class="sig-name descname">PyUnicode_Contains</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *container</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *element</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_Contains" title="정의 주소">¶</a></dt>
<dd><p><em>element</em>가 <em>container</em>에 포함되어 있는지 확인하고 그에 따라 참이나 거짓을 반환합니다.</p>
<p><em>element</em>는 단일 요소 유니코드 문자열로 강제 변환해야 합니다. 에러가 있으면 <code class="docutils literal notranslate"><span class="pre">-1</span></code>이 반환됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_InternInPlace">
void <code class="sig-name descname">PyUnicode_InternInPlace</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> **string</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_InternInPlace" title="정의 주소">¶</a></dt>
<dd><p>인자 <em>*string</em>을 제자리에서 인턴(intern) 합니다.  인자는 파이썬 유니코드 문자열을 가리키는 포인터 변수의 주소여야 합니다. <em>*string</em>과 같은 기존 인턴 문자열이 있으면, <em>*string</em>을 그것으로 설정합니다 (이전 문자열 객체의 참조 횟수를 감소시키고 인턴 된 문자열 객체의 참조 횟수를 증가시킵니다), 그렇지 않으면 <em>*string</em>만 홀로 두고 인턴 합니다 (참조 횟수를 증가시킵니다). (설명: 참조 횟수에 대해 많은 이야기가 있지만, 이 함수를 참조 횟수 중립이라고 생각하십시오; 호출 전에 소유한 경우에만 호출 후 객체를 소유합니다.)</p>
</dd></dl>

<dl class="function">
<dt id="c.PyUnicode_InternFromString">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyUnicode_InternFromString</code><span class="sig-paren">(</span>const char<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnicode_InternFromString" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><a class="reference internal" href="#c.PyUnicode_FromString" title="PyUnicode_FromString"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromString()</span></code></a>과 <a class="reference internal" href="#c.PyUnicode_InternInPlace" title="PyUnicode_InternInPlace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_InternInPlace()</span></code></a>의 조합, 인턴(intern) 된 새 유니코드 문자열 객체나, 같은 값을 가진 이전에 인턴 된 문자열 객체에 대한 새 (&quot;소유된&quot;) 참조를 반환합니다.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">유니코드 객체와 코덱</a><ul>
<li><a class="reference internal" href="#unicode-objects">유니코드 객체</a><ul>
<li><a class="reference internal" href="#unicode-type">유니코드 형</a></li>
<li><a class="reference internal" href="#unicode-character-properties">유니코드 문자 속성</a></li>
<li><a class="reference internal" href="#creating-and-accessing-unicode-strings">유니코드 문자열 생성과 액세스</a></li>
<li><a class="reference internal" href="#deprecated-py-unicode-apis">폐지된 Py_UNICODE API</a></li>
<li><a class="reference internal" href="#locale-encoding">로케일 인코딩</a></li>
<li><a class="reference internal" href="#file-system-encoding">파일 시스템 인코딩</a></li>
<li><a class="reference internal" href="#wchar-t-support">wchar_t 지원</a></li>
</ul>
</li>
<li><a class="reference internal" href="#built-in-codecs">내장 코덱</a><ul>
<li><a class="reference internal" href="#generic-codecs">일반 코덱</a></li>
<li><a class="reference internal" href="#utf-8-codecs">UTF-8 코덱</a></li>
<li><a class="reference internal" href="#utf-32-codecs">UTF-32 코덱</a></li>
<li><a class="reference internal" href="#utf-16-codecs">UTF-16 코덱</a></li>
<li><a class="reference internal" href="#utf-7-codecs">UTF-7 코덱</a></li>
<li><a class="reference internal" href="#unicode-escape-codecs">유니코드 이스케이프 코덱</a></li>
<li><a class="reference internal" href="#raw-unicode-escape-codecs">원시 유니코드 이스케이프 코덱</a></li>
<li><a class="reference internal" href="#latin-1-codecs">Latin-1 코덱</a></li>
<li><a class="reference internal" href="#ascii-codecs">ASCII 코덱</a></li>
<li><a class="reference internal" href="#character-map-codecs">문자 맵 코덱</a></li>
<li><a class="reference internal" href="#mbcs-codecs-for-windows">윈도우 용 MBCS 코덱</a></li>
<li><a class="reference internal" href="#methods-slots">메서드와 슬롯</a></li>
</ul>
</li>
<li><a class="reference internal" href="#methods-and-slot-functions">메서드와 슬롯 함수</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="bytearray.html"
                        title="이전 장">바이트 배열 객체</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="tuple.html"
                        title="다음 장">튜플 객체</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="tuple.html" title="튜플 객체"
             >다음</a> |</li>
        <li class="right" >
          <a href="bytearray.html" title="바이트 배열 객체"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="concrete.html" >구상 객체 계층</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2021, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2021, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>