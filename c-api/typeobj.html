
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>형 객체 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="순환 가비지 수집 지원" href="gcsupport.html" />
    <link rel="prev" title="공통 객체 구조체" href="structures.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/c-api/typeobj.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="gcsupport.html" title="순환 가비지 수집 지원"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="structures.html" title="공통 객체 구조체"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="objimpl.html" accesskey="U">객체 구현 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="type-objects">
<span id="type-structs"></span><h1>형 객체<a class="headerlink" href="#type-objects" title="제목 주소">¶</a></h1>
<p>아마도 파이썬 객체 시스템의 가장 중요한 구조체 중 하나는 새로운 형을 정의하는 구조체일 것입니다: <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 구조체. <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_*()</span></code>나 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_*()</span></code> 함수를 사용하여 형 객체를 처리할 수 있지만, 대부분 파이썬 응용 프로그램이 흥미를 느낄 것은 많이 제공하지 않습니다. 이 객체는 객체의 동작 방식의 기초를 이루므로, 인터프리터 자체와 새로운 형을 구현하는 확장 모듈에 매우 중요합니다.</p>
<p>형 객체는 대부분 표준형보다 상당히 큽니다. 크기가 큰 이유는 각 형 객체가 많은 수의 값을 저장하기 때문인데, 주로 C 함수 포인터이고 각기 형의 기능 중 작은 부분을 구현합니다. 이 섹션에서는 형 객체의 필드를 자세히 살펴봅니다. 필드는 구조체에서 나타나는 순서대로 설명됩니다.</p>
<p>다음의 간략 참조 외에도, <a class="reference internal" href="#typedef-examples"><span class="std std-ref">예</span></a> 섹션은 <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a>의 의미와 사용에 대한 통찰을 제공합니다.</p>
<div class="section" id="quick-reference">
<h2>간략 참조<a class="headerlink" href="#quick-reference" title="제목 주소">¶</a></h2>
<div class="section" id="tp-slots">
<span id="tp-slots-table"></span><h3>&quot;tp 슬롯&quot;<a class="headerlink" href="#tp-slots" title="제목 주소">¶</a></h3>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 31%" />
<col style="width: 31%" />
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 2%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" rowspan="2"><p>PyTypeObject 슬롯 <a class="footnote-reference brackets" href="#slots" id="id1">1</a></p></th>
<th class="head" rowspan="2"><p><a class="reference internal" href="#slot-typedefs-table"><span class="std std-ref">형</span></a></p></th>
<th class="head" rowspan="2"><p>특수 메서드/어트리뷰트</p></th>
<th class="head" colspan="4"><p>정보 <a class="footnote-reference brackets" href="#cols" id="id2">2</a></p></th>
</tr>
<tr class="row-even"><th class="head"><p>O</p></th>
<th class="head"><p>T</p></th>
<th class="head"><p>D</p></th>
<th class="head"><p>I</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>&lt;R&gt; <a class="reference internal" href="#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_name</span></code></a></p></td>
<td><p>const char *</p></td>
<td><p>__name__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a></p></td>
<td><p>Py_ssize_t</p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a></p></td>
<td><p>Py_ssize_t</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dealloc</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.destructor" title="destructor"><code class="xref c c-type docutils literal notranslate"><span class="pre">destructor</span></code></a></p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code></a></p></td>
<td><p>Py_ssize_t</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>?</p></td>
</tr>
<tr class="row-even"><td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a>)</p></td>
<td><p><a class="reference internal" href="#c.getattrfunc" title="getattrfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getattrfunc</span></code></a></p></td>
<td><p>__getattribute__,
__getattr__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-odd"><td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a>)</p></td>
<td><p><a class="reference internal" href="#c.setattrfunc" title="setattrfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">setattrfunc</span></code></a></p></td>
<td><p>__setattr__,
__delattr__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_async" title="PyTypeObject.tp_as_async"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_async</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PyAsyncMethods" title="PyAsyncMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyAsyncMethods</span></code></a> *</p></td>
<td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">서브 슬롯</span></a></p></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_repr</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.reprfunc" title="reprfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">reprfunc</span></code></a></p></td>
<td><p>__repr__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_number" title="PyTypeObject.tp_as_number"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_number</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyNumberMethods</span></code></a> *</p></td>
<td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">서브 슬롯</span></a></p></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_sequence" title="PyTypeObject.tp_as_sequence"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_sequence</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PySequenceMethods</span></code></a> *</p></td>
<td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">서브 슬롯</span></a></p></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_mapping" title="PyTypeObject.tp_as_mapping"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_mapping</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PyMappingMethods" title="PyMappingMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMappingMethods</span></code></a> *</p></td>
<td><p><a class="reference internal" href="#sub-slots"><span class="std std-ref">서브 슬롯</span></a></p></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.hashfunc" title="hashfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">hashfunc</span></code></a></p></td>
<td><p>__hash__</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ternaryfunc</span></code></a></p></td>
<td><p>__call__</p></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_str" title="PyTypeObject.tp_str"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_str</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.reprfunc" title="reprfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">reprfunc</span></code></a></p></td>
<td><p>__str__</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.getattrofunc" title="getattrofunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getattrofunc</span></code></a></p></td>
<td><p>__getattribute__,
__getattr__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.setattrofunc" title="setattrofunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">setattrofunc</span></code></a></p></td>
<td><p>__setattr__,
__delattr__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_buffer</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.PyBufferProcs" title="PyBufferProcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBufferProcs</span></code></a> *</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>%</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a></p></td>
<td><p>unsigned long</p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>?</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_doc" title="PyTypeObject.tp_doc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_doc</span></code></a></p></td>
<td><p>const char *</p></td>
<td><p>__doc__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a></p></td>
<td><p><a class="reference internal" href="gcsupport.html#c.traverseproc" title="traverseproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">traverseproc</span></code></a></p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a></p></td>
<td><p><a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry"><code class="xref c c-type docutils literal notranslate"><span class="pre">inquiry</span></code></a></p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.richcmpfunc" title="richcmpfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">richcmpfunc</span></code></a></p></td>
<td><p>__lt__,
__le__,
__eq__,
__ne__,
__gt__,
__ge__</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
<td><p>G</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a></p></td>
<td><p>Py_ssize_t</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.getiterfunc" title="getiterfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getiterfunc</span></code></a></p></td>
<td><p>__iter__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iternext</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.iternextfunc" title="iternextfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">iternextfunc</span></code></a></p></td>
<td><p>__next__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_methods" title="PyTypeObject.tp_methods"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_methods</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> []</p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_members" title="PyTypeObject.tp_members"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_members</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyMemberDef" title="PyMemberDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemberDef</span></code></a> []</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_getset" title="PyTypeObject.tp_getset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getset</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyGetSetDef" title="PyGetSetDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyGetSetDef</span></code></a> []</p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_base</span></code></a></p></td>
<td><p><a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> *</p></td>
<td><p>__base__</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>__dict__</p></td>
<td></td>
<td></td>
<td><p>?</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_descr_get" title="PyTypeObject.tp_descr_get"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descr_get</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.descrgetfunc" title="descrgetfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">descrgetfunc</span></code></a></p></td>
<td><p>__get__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_descr_set" title="PyTypeObject.tp_descr_set"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descr_set</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.descrsetfunc" title="descrsetfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">descrsetfunc</span></code></a></p></td>
<td><p>__set__,
__delete__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a></p></td>
<td><p>Py_ssize_t</p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.initproc" title="initproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">initproc</span></code></a></p></td>
<td><p>__init__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_alloc</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.allocfunc" title="allocfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">allocfunc</span></code></a></p></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.newfunc" title="newfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">newfunc</span></code></a></p></td>
<td><p>__new__</p></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.freefunc" title="freefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">freefunc</span></code></a></p></td>
<td></td>
<td><p>X</p></td>
<td><p>X</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_is_gc" title="PyTypeObject.tp_is_gc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_is_gc</span></code></a></p></td>
<td><p><a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry"><code class="xref c c-type docutils literal notranslate"><span class="pre">inquiry</span></code></a></p></td>
<td></td>
<td></td>
<td><p>X</p></td>
<td></td>
<td><p>X</p></td>
</tr>
<tr class="row-even"><td><p>&lt;<a class="reference internal" href="#c.PyTypeObject.tp_bases" title="PyTypeObject.tp_bases"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_bases</span></code></a>&gt;</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>__bases__</p></td>
<td></td>
<td></td>
<td><p>~</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>&lt;<a class="reference internal" href="#c.PyTypeObject.tp_mro" title="PyTypeObject.tp_mro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_mro</span></code></a>&gt;</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>__mro__</p></td>
<td></td>
<td></td>
<td><p>~</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_cache" title="PyTypeObject.tp_cache"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_cache</span></code></a>]</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-odd"><td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_subclasses" title="PyTypeObject.tp_subclasses"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_subclasses</span></code></a>]</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>__subclasses__</p></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-even"><td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklist</span></code></a>]</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-odd"><td><p>(<a class="reference internal" href="#c.PyTypeObject.tp_del" title="PyTypeObject.tp_del"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_del</span></code></a>)</p></td>
<td><p><a class="reference internal" href="#c.destructor" title="destructor"><code class="xref c c-type docutils literal notranslate"><span class="pre">destructor</span></code></a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>[<a class="reference internal" href="#c.PyTypeObject.tp_version_tag" title="PyTypeObject.tp_version_tag"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_version_tag</span></code></a>]</p></td>
<td><p>unsigned int</p></td>
<td></td>
<td></td>
<td></td>
<td colspan="2"></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.destructor" title="destructor"><code class="xref c c-type docutils literal notranslate"><span class="pre">destructor</span></code></a></p></td>
<td><p>__del__</p></td>
<td></td>
<td></td>
<td></td>
<td><p>X</p></td>
</tr>
</tbody>
</table>
<p><code class="xref py py-const docutils literal notranslate"><span class="pre">COUNT_ALLOCS</span></code>가 정의되면 다음 (내부 전용) 필드도 존재합니다:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.PyTypeObject.tp_allocs" title="PyTypeObject.tp_allocs"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_allocs</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyTypeObject.tp_frees" title="PyTypeObject.tp_frees"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_frees</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyTypeObject.tp_maxalloc" title="PyTypeObject.tp_maxalloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_maxalloc</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyTypeObject.tp_prev" title="PyTypeObject.tp_prev"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_prev</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyTypeObject.tp_next" title="PyTypeObject.tp_next"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_next</span></code></a></p></li>
</ul>
<dl class="footnote brackets">
<dt class="label" id="slots"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>괄호 안의 슬롯 이름은 슬롯이 (효과적으로) 폐지되었음을 나타냅니다. 화살 괄호(angle brackets) 안에 있는 이름은 읽기 전용으로 취급해야 합니다. 대괄호(square brackets) 안의 이름은 내부 전용입니다. (접두사일 때) &quot;&lt;R&gt;&quot;는 필드가 필수임을 뜻합니다 (반드시 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니어야 합니다).</p>
</dd>
<dt class="label" id="cols"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>열:</p>
<p><strong>&quot;O&quot;</strong>: <code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code>에 설정</p>
<p><strong>&quot;T&quot;</strong>: <a class="reference internal" href="type.html#c.PyType_Type" title="PyType_Type"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyType_Type</span></code></a>에 설정</p>
<p><strong>&quot;D&quot;</strong>: 기본값 (슬롯이 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정된 경우)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X - PyType_Ready 는 이 값이 NULL이면 설정합니다
~ - PyType_Ready 는 항상 이 값을 설정합니다 (NULL 이어야 합니다)
? - PyType_Ready 는 다른 슬롯에 따라 이 값을 설정할 수 있습니다

계승 열(&quot;I&quot;)도 참조하십시오.
</pre></div>
</div>
<p><strong>&quot;I&quot;</strong>: 상속</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>X - 형 슬롯은 NULL 값으로 정의되었으면 PyType_Ready 를 통해 계승됩니다
% - 서브 구조체의 슬롯은 개별적으로 계승됩니다
G - 계승됩니다, 하지만 다른 슬롯과의 조합으로만; 슬롯의 설명을 참조하십시오
? - 복잡합니다; 슬롯의 설명을 참조하십시오
</pre></div>
</div>
<p>일부 슬롯은 일반 어트리뷰트 조회 체인을 통해 효과적으로 상속됨에 유의하십시오.</p>
</dd>
</dl>
</div>
<div class="section" id="sub-slots">
<span id="id3"></span><h3>서브 슬롯<a class="headerlink" href="#sub-slots" title="제목 주소">¶</a></h3>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 47%" />
<col style="width: 31%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>슬롯</p></th>
<th class="head"><p><a class="reference internal" href="#slot-typedefs-table"><span class="std std-ref">형</span></a></p></th>
<th class="head"><p>특수 메서드</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyAsyncMethods.am_await" title="PyAsyncMethods.am_await"><code class="xref c c-member docutils literal notranslate"><span class="pre">am_await</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__await__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyAsyncMethods.am_aiter" title="PyAsyncMethods.am_aiter"><code class="xref c c-member docutils literal notranslate"><span class="pre">am_aiter</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__aiter__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyAsyncMethods.am_anext" title="PyAsyncMethods.am_anext"><code class="xref c c-member docutils literal notranslate"><span class="pre">am_anext</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__anext__</p></td>
</tr>
<tr class="row-odd"><td colspan="3"></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_add" title="PyNumberMethods.nb_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_add</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__add__
__radd__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_add" title="PyNumberMethods.nb_inplace_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_add</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__iadd__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_subtract" title="PyNumberMethods.nb_subtract"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_subtract</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__sub__
__rsub__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_subtract" title="PyNumberMethods.nb_inplace_subtract"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_subtract</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__sub__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_multiply" title="PyNumberMethods.nb_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_multiply</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__mul__
__rmul__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_multiply" title="PyNumberMethods.nb_inplace_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_multiply</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__mul__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_remainder" title="PyNumberMethods.nb_remainder"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_remainder</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__mod__
__rmod__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_remainder" title="PyNumberMethods.nb_inplace_remainder"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_remainder</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__mod__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_divmod" title="PyNumberMethods.nb_divmod"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_divmod</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__divmod__
__rdivmod__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_power" title="PyNumberMethods.nb_power"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_power</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ternaryfunc</span></code></a></p></td>
<td><p>__pow__
__rpow__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_power" title="PyNumberMethods.nb_inplace_power"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_power</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ternaryfunc</span></code></a></p></td>
<td><p>__pow__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_negative" title="PyNumberMethods.nb_negative"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_negative</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__neg__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_positive" title="PyNumberMethods.nb_positive"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_positive</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__pos__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_absolute" title="PyNumberMethods.nb_absolute"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_absolute</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__abs__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_bool" title="PyNumberMethods.nb_bool"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_bool</span></code></a></p></td>
<td><p><a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry"><code class="xref c c-type docutils literal notranslate"><span class="pre">inquiry</span></code></a></p></td>
<td><p>__bool__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_invert" title="PyNumberMethods.nb_invert"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_invert</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__invert__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_lshift" title="PyNumberMethods.nb_lshift"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_lshift</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__lshift__
__rlshift__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_lshift" title="PyNumberMethods.nb_inplace_lshift"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_lshift</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__lshift__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_rshift" title="PyNumberMethods.nb_rshift"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_rshift</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__rshift__
__rrshift__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_rshift" title="PyNumberMethods.nb_inplace_rshift"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_rshift</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__rshift__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_and" title="PyNumberMethods.nb_and"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_and</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__and__
__rand__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_and" title="PyNumberMethods.nb_inplace_and"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_and</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__and__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_xor" title="PyNumberMethods.nb_xor"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_xor</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__xor__
__rxor__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_xor" title="PyNumberMethods.nb_inplace_xor"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_xor</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__xor__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_or" title="PyNumberMethods.nb_or"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_or</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__or__
__ror__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_or" title="PyNumberMethods.nb_inplace_or"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_or</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__or__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_int" title="PyNumberMethods.nb_int"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_int</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__int__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_reserved" title="PyNumberMethods.nb_reserved"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_reserved</span></code></a></p></td>
<td><p>void *</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_float" title="PyNumberMethods.nb_float"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_float</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__float__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_floor_divide" title="PyNumberMethods.nb_floor_divide"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_floor_divide</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__floordiv__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_floor_divide" title="PyNumberMethods.nb_inplace_floor_divide"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_floor_divide</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__floordiv__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_true_divide" title="PyNumberMethods.nb_true_divide"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_true_divide</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__truediv__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_true_divide" title="PyNumberMethods.nb_inplace_true_divide"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_true_divide</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__truediv__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_index" title="PyNumberMethods.nb_index"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_index</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><p>__index__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_matrix_multiply" title="PyNumberMethods.nb_matrix_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_matrix_multiply</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__matmul__
__rmatmul__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyNumberMethods.nb_inplace_matrix_multiply" title="PyNumberMethods.nb_inplace_matrix_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_matrix_multiply</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__matmul__</p></td>
</tr>
<tr class="row-even"><td colspan="3"></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyMappingMethods.mp_length" title="PyMappingMethods.mp_length"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_length</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.lenfunc" title="lenfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">lenfunc</span></code></a></p></td>
<td><p>__len__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyMappingMethods.mp_subscript" title="PyMappingMethods.mp_subscript"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_subscript</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__getitem__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyMappingMethods.mp_ass_subscript" title="PyMappingMethods.mp_ass_subscript"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_ass_subscript</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.objobjargproc" title="objobjargproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">objobjargproc</span></code></a></p></td>
<td><p>__setitem__,
__delitem__</p></td>
</tr>
<tr class="row-even"><td colspan="3"></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_length" title="PySequenceMethods.sq_length"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_length</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.lenfunc" title="lenfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">lenfunc</span></code></a></p></td>
<td><p>__len__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_concat" title="PySequenceMethods.sq_concat"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_concat</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__add__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_repeat" title="PySequenceMethods.sq_repeat"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_repeat</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeargfunc</span></code></a></p></td>
<td><p>__mul__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_item" title="PySequenceMethods.sq_item"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_item</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeargfunc</span></code></a></p></td>
<td><p>__getitem__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_ass_item" title="PySequenceMethods.sq_ass_item"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_ass_item</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ssizeobjargproc" title="ssizeobjargproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeobjargproc</span></code></a></p></td>
<td><p>__setitem__
__delitem__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_contains" title="PySequenceMethods.sq_contains"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_contains</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.objobjproc" title="objobjproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">objobjproc</span></code></a></p></td>
<td><p>__contains__</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_inplace_concat" title="PySequenceMethods.sq_inplace_concat"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_inplace_concat</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><p>__iadd__</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PySequenceMethods.sq_inplace_repeat" title="PySequenceMethods.sq_inplace_repeat"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_inplace_repeat</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeargfunc</span></code></a></p></td>
<td><p>__imul__</p></td>
</tr>
<tr class="row-odd"><td colspan="3"></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.PyBufferProcs.bf_getbuffer" title="PyBufferProcs.bf_getbuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">bf_getbuffer</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.getbufferproc" title="getbufferproc"><code class="xref c c-func docutils literal notranslate"><span class="pre">getbufferproc()</span></code></a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">bf_releasebuffer</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.releasebufferproc" title="releasebufferproc"><code class="xref c c-func docutils literal notranslate"><span class="pre">releasebufferproc()</span></code></a></p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="slot-typedefs">
<span id="slot-typedefs-table"></span><h3>슬롯 typedef<a class="headerlink" href="#slot-typedefs" title="제목 주소">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 36%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>typedef</p></th>
<th class="head"><p>매개 변수 형</p></th>
<th class="head"><p>반환형</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#c.allocfunc" title="allocfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">allocfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> *</div>
<div class="line">Py_ssize_t</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.destructor" title="destructor"><code class="xref c c-type docutils literal notranslate"><span class="pre">destructor</span></code></a></p></td>
<td><p>void *</p></td>
<td><p>void</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.freefunc" title="freefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">freefunc</span></code></a></p></td>
<td><p>void *</p></td>
<td><p>void</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="gcsupport.html#c.traverseproc" title="traverseproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">traverseproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line">void *</div>
<div class="line"><a class="reference internal" href="gcsupport.html#c.visitproc" title="visitproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">visitproc</span></code></a></div>
<div class="line">void *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.newfunc" title="newfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">newfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.initproc" title="initproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">initproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.reprfunc" title="reprfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">reprfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.getattrfunc" title="getattrfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getattrfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line">const char *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.setattrfunc" title="setattrfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">setattrfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line">const char *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.getattrofunc" title="getattrofunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getattrofunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.setattrofunc" title="setattrofunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">setattrofunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.descrgetfunc" title="descrgetfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">descrgetfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.descrsetfunc" title="descrsetfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">descrsetfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.hashfunc" title="hashfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">hashfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>Py_hash_t</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.richcmpfunc" title="richcmpfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">richcmpfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line">int</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.getiterfunc" title="getiterfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getiterfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.iternextfunc" title="iternextfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">iternextfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.lenfunc" title="lenfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">lenfunc</span></code></a></p></td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
<td><p>Py_ssize_t</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.getbufferproc" title="getbufferproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">getbufferproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> *</div>
<div class="line">int</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.releasebufferproc" title="releasebufferproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">releasebufferproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> *</div>
</div>
</td>
<td><p>void</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry"><code class="xref c c-type docutils literal notranslate"><span class="pre">inquiry</span></code></a></p></td>
<td><p>void *</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.unaryfunc" title="unaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">unaryfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.binaryfunc" title="binaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">binaryfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ternaryfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeargfunc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line">Py_ssize_t</div>
</div>
</td>
<td><p><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.ssizeobjargproc" title="ssizeobjargproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssizeobjargproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line">Py_ssize_t</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#c.objobjproc" title="objobjproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">objobjproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#c.objobjargproc" title="objobjargproc"><code class="xref c c-type docutils literal notranslate"><span class="pre">objobjargproc</span></code></a></p></td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
<div class="line"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> *</div>
</div>
</td>
<td><p>int</p></td>
</tr>
</tbody>
</table>
<p>자세한 내용은 아래 <a class="reference internal" href="#id5"><span class="std std-ref">슬롯 형 typedef</span></a>를 참조하십시오.</p>
</div>
</div>
<div class="section" id="pytypeobject-definition">
<h2>PyTypeObject 정의<a class="headerlink" href="#pytypeobject-definition" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a>의 구조체 정의는 <code class="file docutils literal notranslate"><span class="pre">Include/object.h</span></code>에서 찾을 수 있습니다. 참조 편의를 위해, 다음에 정의를 반복합니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_typeobject</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_name</span><span class="p">;</span> <span class="cm">/* 인쇄용, &quot;&lt;module&gt;.&lt;name&gt;&quot; 형식 */</span>
    <span class="n">Py_ssize_t</span> <span class="n">tp_basicsize</span><span class="p">,</span> <span class="n">tp_itemsize</span><span class="p">;</span> <span class="cm">/* 할당(allocation)용 */</span>

    <span class="cm">/* 표준 연산을 구현하는 메서드 */</span>

    <span class="n">destructor</span> <span class="n">tp_dealloc</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">tp_vectorcall_offset</span><span class="p">;</span>
    <span class="n">getattrfunc</span> <span class="n">tp_getattr</span><span class="p">;</span>
    <span class="n">setattrfunc</span> <span class="n">tp_setattr</span><span class="p">;</span>
    <span class="n">PyAsyncMethods</span> <span class="o">*</span><span class="n">tp_as_async</span><span class="p">;</span> <span class="cm">/* 이전에는 tp_compare(파이썬 2)나 tp_reserved</span>
<span class="cm">                                    (파이썬 3)로 알려졌습니다 */</span>
    <span class="n">reprfunc</span> <span class="n">tp_repr</span><span class="p">;</span>

    <span class="cm">/* 표준 클래스를 위한 메서드 스위트 */</span>

    <span class="n">PyNumberMethods</span> <span class="o">*</span><span class="n">tp_as_number</span><span class="p">;</span>
    <span class="n">PySequenceMethods</span> <span class="o">*</span><span class="n">tp_as_sequence</span><span class="p">;</span>
    <span class="n">PyMappingMethods</span> <span class="o">*</span><span class="n">tp_as_mapping</span><span class="p">;</span>

    <span class="cm">/* 더 많은 표준 연산 (바이너리 호환성을 위해 여기에) */</span>

    <span class="n">hashfunc</span> <span class="n">tp_hash</span><span class="p">;</span>
    <span class="n">ternaryfunc</span> <span class="n">tp_call</span><span class="p">;</span>
    <span class="n">reprfunc</span> <span class="n">tp_str</span><span class="p">;</span>
    <span class="n">getattrofunc</span> <span class="n">tp_getattro</span><span class="p">;</span>
    <span class="n">setattrofunc</span> <span class="n">tp_setattro</span><span class="p">;</span>

    <span class="cm">/* 입/출력 버퍼로 객체를 액세스하는 함수 */</span>
    <span class="n">PyBufferProcs</span> <span class="o">*</span><span class="n">tp_as_buffer</span><span class="p">;</span>

    <span class="cm">/* 선택/확장 기능의 존재를 정의하는 플래그 */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tp_flags</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_doc</span><span class="p">;</span> <span class="cm">/* 설명서 문자열 */</span>

    <span class="cm">/* 모든 액세스 가능한 객체에 대한 호출 함수 */</span>
    <span class="n">traverseproc</span> <span class="n">tp_traverse</span><span class="p">;</span>

    <span class="cm">/* 포함된 객체에 대한 참조 삭제 */</span>
    <span class="n">inquiry</span> <span class="n">tp_clear</span><span class="p">;</span>

    <span class="cm">/* 풍부한 비교 */</span>
    <span class="n">richcmpfunc</span> <span class="n">tp_richcompare</span><span class="p">;</span>

    <span class="cm">/* 약한 참조 활성화기 */</span>
    <span class="n">Py_ssize_t</span> <span class="n">tp_weaklistoffset</span><span class="p">;</span>

    <span class="cm">/* 이터레이터 */</span>
    <span class="n">getiterfunc</span> <span class="n">tp_iter</span><span class="p">;</span>
    <span class="n">iternextfunc</span> <span class="n">tp_iternext</span><span class="p">;</span>

    <span class="cm">/* 어트리뷰트 디스크립터와 서브 클래싱 */</span>
    <span class="k">struct</span> <span class="n">PyMethodDef</span> <span class="o">*</span><span class="n">tp_methods</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyMemberDef</span> <span class="o">*</span><span class="n">tp_members</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyGetSetDef</span> <span class="o">*</span><span class="n">tp_getset</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">_typeobject</span> <span class="o">*</span><span class="n">tp_base</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_dict</span><span class="p">;</span>
    <span class="n">descrgetfunc</span> <span class="n">tp_descr_get</span><span class="p">;</span>
    <span class="n">descrsetfunc</span> <span class="n">tp_descr_set</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">tp_dictoffset</span><span class="p">;</span>
    <span class="n">initproc</span> <span class="n">tp_init</span><span class="p">;</span>
    <span class="n">allocfunc</span> <span class="n">tp_alloc</span><span class="p">;</span>
    <span class="n">newfunc</span> <span class="n">tp_new</span><span class="p">;</span>
    <span class="n">freefunc</span> <span class="n">tp_free</span><span class="p">;</span> <span class="cm">/* 저수준의 메모리 해제 루틴 */</span>
    <span class="n">inquiry</span> <span class="n">tp_is_gc</span><span class="p">;</span> <span class="cm">/* PyObject_IS_GC 용 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_bases</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_mro</span><span class="p">;</span> <span class="cm">/* 메서드 결정 순서 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_cache</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_subclasses</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">tp_weaklist</span><span class="p">;</span>
    <span class="n">destructor</span> <span class="n">tp_del</span><span class="p">;</span>

    <span class="cm">/* 형 어트리뷰트 캐시 버전 태그. 버전 2.6에서 추가되었습니다 */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tp_version_tag</span><span class="p">;</span>

    <span class="n">destructor</span> <span class="n">tp_finalize</span><span class="p">;</span>

<span class="p">}</span> <span class="n">PyTypeObject</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="pyobject-slots">
<h2>PyObject 슬롯<a class="headerlink" href="#pyobject-slots" title="제목 주소">¶</a></h2>
<p>형 객체 구조체는 <a class="reference internal" href="structures.html#c.PyVarObject" title="PyVarObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyVarObject</span></code></a> 구조체를 확장합니다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> 필드는 동적 형(<code class="xref py py-func docutils literal notranslate"><span class="pre">type_new()</span></code>에 의해 만들어집니다, 일반적으로 class 문에서 호출됩니다)에 사용됩니다. <a class="reference internal" href="type.html#c.PyType_Type" title="PyType_Type"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyType_Type</span></code></a>(메타 형)은 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>를 초기화함에 유의하십시오, 인스턴스(즉, 형 객체)는 <em>반드시</em> <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> 필드를 가져야 함을 뜻합니다.</p>
<dl class="member">
<dt id="c.PyObject._ob_next">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject._ob_next</code><a class="headerlink" href="#c.PyObject._ob_next" title="정의 주소">¶</a></dt>
<dt id="c.PyObject._ob_prev">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyObject._ob_prev</code><a class="headerlink" href="#c.PyObject._ob_prev" title="정의 주소">¶</a></dt>
<dd><p>이 필드는 매크로 <code class="docutils literal notranslate"><span class="pre">Py_TRACE_REFS</span></code>가 정의됐을 때만 존재합니다. <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로의 초기화는 <code class="docutils literal notranslate"><span class="pre">PyObject_HEAD_INIT</span></code> 매크로에 의해 처리됩니다. 정적으로 할당된 객체의 경우, 이 필드는 항상 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 유지됩니다. 동적으로 할당된 객체의 경우, 이 두 필드는 객체를 힙에 있는 <em>모든</em> 라이브 객체의 이중 링크 리스트에 연결하는 데 사용됩니다. 이것은 다양한 디버깅 목적으로 사용될 수 있습니다; 현재 유일한 사용은 환경 변수 <span class="target" id="index-6"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDUMPREFS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDUMPREFS</span></code></a> 가 설정될 때 실행이 끝날 때 여전히 존재하는 객체를 인쇄하는 것입니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형에 의해 상속되지 않습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyObject.ob_refcnt">
Py_ssize_t <code class="sig-name descname">PyObject.ob_refcnt</code><a class="headerlink" href="#c.PyObject.ob_refcnt" title="정의 주소">¶</a></dt>
<dd><p>이것은 <code class="docutils literal notranslate"><span class="pre">PyObject_HEAD_INIT</span></code> 매크로에 의해 <code class="docutils literal notranslate"><span class="pre">1</span></code>로 초기화된 형 객체의 참조 횟수입니다. 정적으로 할당된 형 객체의 경우 형의 인스턴스(<code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_type</span></code>이 형을 다시 가리키는 객체)는 참조로 카운트되지 <em>않습니다</em>. 그러나 동적으로 할당된 형 객체의 경우, 인스턴스는 참조로 <em>카운트됩니다</em>.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형에 의해 상속되지 않습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyObject.ob_type">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a>* <code class="sig-name descname">PyObject.ob_type</code><a class="headerlink" href="#c.PyObject.ob_type" title="정의 주소">¶</a></dt>
<dd><p>이것은 형의 형, 즉 메타 형(metatype)입니다. <code class="docutils literal notranslate"><span class="pre">PyObject_HEAD_INIT</span></code> 매크로에 대한 인자로 초기화되며, 값은 일반적으로 <code class="docutils literal notranslate"><span class="pre">&amp;PyType_Type</span></code>이어야 합니다. 그러나, (적어도) 윈도우에서 사용 가능해야 하는 동적으로 로드 가능한 확장 모듈의 경우, 컴파일러는 유효한 초기화자가 아니라고 불평합니다. 따라서, 규칙은 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 <code class="docutils literal notranslate"><span class="pre">PyObject_HEAD_INIT</span></code> 매크로로 전달하고, 다른 작업을 수행하기 전에 모듈의 초기화 함수 시작에서 필드를 명시적으로 초기화하는 것입니다. 이것은 일반적으로 다음과 같이 수행됩니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Foo_Type</span><span class="p">.</span><span class="n">ob_type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">;</span>
</pre></div>
</div>
<p>형의 인스턴스를 만들기 전에 수행해야 합니다. <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a>는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_type</span></code>이 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>인지 확인하고, 그렇다면 베이스 클래스의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_type</span></code> 필드로 초기화합니다. <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a>는 0이 아니면 이 필드를 변경하지 않습니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형으로 상속됩니다.</p>
</dd></dl>

</div>
<div class="section" id="pyvarobject-slots">
<h2>PyVarObject 슬롯<a class="headerlink" href="#pyvarobject-slots" title="제목 주소">¶</a></h2>
<dl class="member">
<dt id="c.PyVarObject.ob_size">
Py_ssize_t <code class="sig-name descname">PyVarObject.ob_size</code><a class="headerlink" href="#c.PyVarObject.ob_size" title="정의 주소">¶</a></dt>
<dd><p>정적으로 할당된 형 객체의 경우, 0으로 초기화해야 합니다. 동적으로 할당된 형 객체의 경우, 이 필드에는 특별한 내부 의미가 있습니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형에 의해 상속되지 않습니다.</p>
</dd></dl>

</div>
<div class="section" id="pytypeobject-slots">
<h2>PyTypeObject 슬롯<a class="headerlink" href="#pytypeobject-slots" title="제목 주소">¶</a></h2>
<p>각 슬롯에는 상속을 설명하는 섹션이 있습니다. 필드가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정될 때 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a>가 값을 설정할 수 있으면, &quot;기본값&quot; 섹션도 있습니다. (<code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code>과 <a class="reference internal" href="type.html#c.PyType_Type" title="PyType_Type"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyType_Type</span></code></a>에 설정된 많은 필드가 효과적으로 기본값으로 작동함에 유의하십시오.)</p>
<dl class="member">
<dt id="c.PyTypeObject.tp_name">
const char* <code class="sig-name descname">PyTypeObject.tp_name</code><a class="headerlink" href="#c.PyTypeObject.tp_name" title="정의 주소">¶</a></dt>
<dd><p>형 이름이 포함된 NUL-종료 문자열을 가리키는 포인터. 모듈 전역으로 액세스 할 수 있는 형의 경우, 문자열은 전체 모듈 이름, 그 뒤에 점, 그 뒤에 형 이름이어야 합니다; 내장형의 경우, 단지 형 이름이어야 합니다. 모듈이 패키지의 서브 모듈이면, 전체 패키지 이름은 전체 모듈 이름의 일부입니다. 예를 들어, 패키지 <code class="xref py py-mod docutils literal notranslate"><span class="pre">P</span></code>의 서브 패키지 <code class="xref py py-mod docutils literal notranslate"><span class="pre">Q</span></code>에 있는 모듈 <code class="xref py py-mod docutils literal notranslate"><span class="pre">M</span></code>에 정의된 <code class="xref py py-class docutils literal notranslate"><span class="pre">T</span></code>라는 형은 <a class="reference internal" href="#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_name</span></code></a> 초기화자가 <code class="docutils literal notranslate"><span class="pre">&quot;P.Q.M.T&quot;</span></code>이어야 합니다.</p>
<p>동적으로 할당된 형 객체의 경우, 단지 형 이름이어야 하며, 모듈 이름은 형 딕셔너리에 키 <code class="docutils literal notranslate"><span class="pre">'__module__'</span></code>의 값으로 명시적으로 저장됩니다.</p>
<p>정적으로 할당된 형 객체의 경우, tp_name 필드에 점이 있어야 합니다. 마지막 점 이전의 모든 것은 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 어트리뷰트로 액세스 할 수 있으며, 마지막 점 이후의 모든 것은 <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 어트리뷰트로 액세스 할 수 있습니다.</p>
<p>점이 없으면, 전체 <a class="reference internal" href="#c.PyTypeObject.tp_name" title="PyTypeObject.tp_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_name</span></code></a> 필드는 <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 어트리뷰트로 액세스 할 수 있으며, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 어트리뷰트는 정의되지 않습니다 (위에서 설명한 대로, 딕셔너리에 명시적으로 설정되지 않는 한). 이것은 여러분의 형을 피클 할 수 없다는 것을 뜻합니다. 또한, pydoc으로 만든 모듈 설명서에 나열되지 않습니다.</p>
<p>이 필드는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니어야 합니다. <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyTypeObject()</span></code></a>에서 유일하게 필요한 필드입니다 (잠재적인 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>를 제외하고).</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형에 의해 상속되지 않습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_basicsize">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_basicsize</code><a class="headerlink" href="#c.PyTypeObject.tp_basicsize" title="정의 주소">¶</a></dt>
<dt id="c.PyTypeObject.tp_itemsize">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_itemsize</code><a class="headerlink" href="#c.PyTypeObject.tp_itemsize" title="정의 주소">¶</a></dt>
<dd><p>이 필드를 사용하면 형 인스턴스의 크기를 바이트 단위로 계산할 수 있습니다.</p>
<p>두 가지 종류의 형이 있습니다: 고정 길이 인스턴스의 형은 0 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 필드를 갖고, 가변 길이 인스턴스의 형에는 0이 아닌 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 필드가 있습니다. 고정 길이 인스턴스의 형의 경우, 모든 인스턴스는 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a>로 지정되는 같은 크기를 갖습니다.</p>
<p>가변 길이 인스턴스의 형의 경우, 인스턴스에는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> 필드가 있어야 하며, 인스턴스 크기는 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a>에 N 곱하기 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>를 더한 값입니다. 여기서 N은 객체의 &quot;길이&quot; 입니다. N값은 일반적으로 인스턴스의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> 필드에 저장됩니다. 예외가 있습니다: 예를 들어, 정수는 음수를 나타내기 위해 음의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code>를 사용하고, N은 <code class="docutils literal notranslate"><span class="pre">abs(ob_size)</span></code>입니다. 또한 인스턴스 배치에 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> 필드가 있다고 해서 인스턴스 구조체가 가변 길이라는 뜻은 아닙니다 (예를 들어, 리스트 형의 구조체는 고정 길이 인스턴스를 갖지만, 해당 인스턴스에는 의미 있는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> 필드가 있습니다).</p>
<p>기본 크기에는 매크로 <a class="reference internal" href="structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_HEAD</span></code></a>나 <a class="reference internal" href="structures.html#c.PyObject_VAR_HEAD" title="PyObject_VAR_HEAD"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_VAR_HEAD</span></code></a>(인스턴스 구조체를 선언하는 데 사용한 것)에 의해 선언된 인스턴스의 필드가 포함되며, 이것은 다시 존재한다면 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_ob_prev</span></code>와 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_ob_next</span></code> 필드도 포함됩니다. 이는 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a>의 초기화자를 얻는 유일하게 올바른 방법은 인스턴스 배치를 선언하는 데 사용되는 구조체에 <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> 연산자를 사용하는 것입니다. 기본 크기에는 GC 헤더 크기가 포함되지 않습니다.</p>
<p>정렬(alignment)에 대한 참고 사항: 가변 길이 항목에 특정 정렬이 필요하면, <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> 값에서 고려되어야 합니다. 예: 형이 <code class="docutils literal notranslate"><span class="pre">double</span></code> 배열을 구현하는 형을 가정합시다. <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">sizeof(double)</span></code>입니다. <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">sizeof(double)</span></code>의 배수가 되도록 하는 것은 프로그래머의 책임입니다 (이것이 <code class="docutils literal notranslate"><span class="pre">double</span></code>의 정렬 요구 사항이라고 가정합니다).</p>
<p>가변 길이 인스턴스가 있는 모든 형의 경우, 이 필드는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니어야 합니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형에 의해 별도로 상속됩니다. 베이스형에 0이 아닌 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>가 있으면, 일반적으로 서브 형에서 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>를 다른 0이 아닌 값으로 설정하는 것은 안전하지 않습니다 (베이스형의 구현에 따라 다르기는 합니다).</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_dealloc">
<a class="reference internal" href="#c.destructor" title="destructor">destructor</a> <code class="sig-name descname">PyTypeObject.tp_dealloc</code><a class="headerlink" href="#c.PyTypeObject.tp_dealloc" title="정의 주소">¶</a></dt>
<dd><p>인스턴스 파괴자(destructor) 함수에 대한 포인터. (싱글톤 <code class="docutils literal notranslate"><span class="pre">None</span></code>과 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code>의 경우처럼) 형이 해당 인스턴스가 할당 해제되지 않도록 보장하지 않는 한, 이 함수를 정의해야 합니다. 함수 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">tp_dealloc</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>파괴자 함수는 새로운 참조 횟수가 0일 때 <a class="reference internal" href="refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a>와 <a class="reference internal" href="refcounting.html#c.Py_XDECREF" title="Py_XDECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_XDECREF()</span></code></a> 매크로에 의해 호출됩니다. 이 시점에, 인스턴스는 여전히 존재하지만, 이에 대한 참조는 없습니다. 파괴자 함수는 인스턴스가 소유한 모든 참조를 해제하고, (버퍼 할당에 사용된 할당 함수에 해당하는 해제 함수를 사용하여) 인스턴스가 소유한 모든 메모리 버퍼를 해제한 다음, 형의 <a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a> 함수를 호출해야 합니다. 형의 서브 형을 만들 수 없는 경우 (<a class="reference internal" href="#Py_TPFLAGS_BASETYPE" title="Py_TPFLAGS_BASETYPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_BASETYPE</span></code></a> 플래그 비트가 설정되지 않은 경우) <a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a>를 거치는 대신 객체 할당 해제기(deallocator)를 직접 호출 할 수 있습니다. 객체 할당 해제기는 인스턴스를 할당하는 데 사용된 것이어야 합니다; 인스턴스가 <a class="reference internal" href="allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_New()</span></code></a>나 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_VarNew()</span></code>를 사용하여 할당되었으면 일반적으로 <a class="reference internal" href="allocation.html#c.PyObject_Del" title="PyObject_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Del()</span></code></a>이고, 인스턴스가 <a class="reference internal" href="gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_New()</span></code></a>나 <a class="reference internal" href="gcsupport.html#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_NewVar()</span></code></a>를 사용하여 할당되었으면 <a class="reference internal" href="gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Del()</span></code></a>입니다.</p>
<p>마지막으로, 형이 힙 할당(<a class="reference internal" href="#Py_TPFLAGS_HEAPTYPE" title="Py_TPFLAGS_HEAPTYPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HEAPTYPE</span></code></a>)이면, 할당 해제기는 형 할당 해제기를 호출한 후 해당 형 객체의 참조 횟수를 줄여야 합니다. 매달린(dangling) 포인터를 피하고자, 이렇게 하는 권장 방법은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">foo_dealloc</span><span class="p">(</span><span class="n">foo_object</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="c1">// 참조와 버퍼를 여기서 해제합니다</span>
    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형으로 상속됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_vectorcall_offset">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_vectorcall_offset</code><a class="headerlink" href="#c.PyTypeObject.tp_vectorcall_offset" title="정의 주소">¶</a></dt>
<dd><p>간단한 <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>의 더 효율적인 대안인 <em>벡터콜(vectorcall)</em> 프로토콜을 사용하여 객체를 호출하는 것을 구현하는 인스턴스별 함수에 대한 선택적 오프셋입니다.</p>
<p>이 필드는 플래그 <a class="reference internal" href="#_Py_TPFLAGS_HAVE_VECTORCALL" title="_Py_TPFLAGS_HAVE_VECTORCALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code></a>이 설정되었을 때만 사용됩니다. 그럴 때, 이것은 <a class="reference internal" href="#c.vectorcallfunc" title="vectorcallfunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">vectorcallfunc</span></code></a> 포인터의 인스턴스에서의 오프셋을 포함하는 양의 정수여야 합니다. 서명은 <a class="reference internal" href="object.html#c._PyObject_Vectorcall" title="_PyObject_Vectorcall"><code class="xref c c-func docutils literal notranslate"><span class="pre">_PyObject_Vectorcall()</span></code></a>과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">vectorcallfunc</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">callable</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nargsf</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwnames</span><span class="p">)</span>
</pre></div>
</div>
<p><em>vectorcallfunc</em> 포인터는 0일 수 있으며, 이때 인스턴스는 <a class="reference internal" href="#_Py_TPFLAGS_HAVE_VECTORCALL" title="_Py_TPFLAGS_HAVE_VECTORCALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code></a>이 설정되지 않은 것처럼 작동합니다: 인스턴스를 호출하면 <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>로 폴백 됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code>을 설정하는 모든 클래스는 <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>도 설정해야 하고, 해당 동작이 <em>vectorcallfunc</em> 함수와 일관되도록 만들어야 합니다. <em>tp_call</em>을 <code class="docutils literal notranslate"><span class="pre">PyVectorcall_Call</span></code>로 설정하면 됩니다:</p>
<dl class="function">
<dt id="c.PyVectorcall_Call">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">PyVectorcall_Call</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *tuple</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *dict</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyVectorcall_Call" title="정의 주소">¶</a></dt>
<dd><p>tuple과 dict에 각각 주어진 위치와 키워드 인자로 <em>callable</em>의 <em>vectorcallfunc</em>를 호출합니다.</p>
<p>이 함수는 <code class="docutils literal notranslate"><span class="pre">tp_call</span></code> 슬롯에서 사용하기 위한 것입니다. <code class="docutils literal notranslate"><span class="pre">tp_call</span></code>로 폴백하지 않으며 현재 <code class="docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code> 플래그를 확인하지 않습니다. 객체를 호출하려면, <a class="reference internal" href="object.html#c.PyObject_Call" title="PyObject_Call"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Call</span></code></a> 함수 중 하나를 대신 사용하십시오.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#heap-types"><span class="std std-ref">힙(heap) 형</span></a>에 벡터콜 프로토콜을 구현하는 것은 권장하지 않습니다. 사용자가 파이썬 코드에서 <code class="docutils literal notranslate"><span class="pre">__call__</span></code>을 설정하면, <code class="docutils literal notranslate"><span class="pre">tp_call</span></code>만 갱신되어 벡터콜 함수와 일치하지 않을 수 있습니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><code class="docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code> 슬롯의 의미론은 잠정적이며 파이썬 3.9에서 완성될 것으로 예상됩니다. 벡터콜을 사용한다면, 파이썬 3.9에서 코드를 갱신할 준비를 하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>이 슬롯은 파이썬 2.x의 인쇄 포매팅에 사용되었습니다. 파이썬 3.0에서 3.7에서는, 예약되었고 <code class="docutils literal notranslate"><span class="pre">tp_print</span></code>로 명명되었습니다.</p>
</div>
<p><strong>계승:</strong></p>
<p>이 필드는 <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>과 함께 서브 형에 의해 상속됩니다: 서브 형의 <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>이 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 때 서브 형은 베이스형에서 <a class="reference internal" href="#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code></a>을 상속합니다.</p>
<p><a class="reference internal" href="#id4">힙 형</a>(파이썬에서 정의된 서브 클래스를 포함합니다)은 <a class="reference internal" href="#_Py_TPFLAGS_HAVE_VECTORCALL" title="_Py_TPFLAGS_HAVE_VECTORCALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code></a> 플래그를 상속하지 않음에 유의하십시오.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_getattr">
<a class="reference internal" href="#c.getattrfunc" title="getattrfunc">getattrfunc</a> <code class="sig-name descname">PyTypeObject.tp_getattr</code><a class="headerlink" href="#c.PyTypeObject.tp_getattr" title="정의 주소">¶</a></dt>
<dd><p>get-attribute-string 함수에 대한 선택적 포인터.</p>
<p>이 필드는 폐지되었습니다. 정의될 때, <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a> 함수와 같게 작동하지만, 어트리뷰트 이름을 제공하기 위해 파이썬 문자열 객체 대신 C 문자열을 받아들이는 함수를 가리켜야 합니다.</p>
<p><strong>계승:</strong></p>
<p>그룹: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_getattr</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_getattro</span></code></p>
<p>이 필드는 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a>와 함께 서브 형에 의해 상속됩니다: 서브 형은 서브 형의 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a>과 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a>가 모두 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 때 베이스형에서 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a>과 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a>를 모두 상속합니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_setattr">
<a class="reference internal" href="#c.setattrfunc" title="setattrfunc">setattrfunc</a> <code class="sig-name descname">PyTypeObject.tp_setattr</code><a class="headerlink" href="#c.PyTypeObject.tp_setattr" title="정의 주소">¶</a></dt>
<dd><p>어트리뷰트 설정과 삭제를 위한 함수에 대한 선택적 포인터.</p>
<p>이 필드는 폐지되었습니다. 정의될 때, <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a> 함수와 같게 작동하지만, 어트리뷰트 이름을 제공하기 위해 파이썬 문자열 객체 대신 C 문자열을 받아들이는 함수를 가리켜야 합니다.</p>
<p><strong>계승:</strong></p>
<p>그룹: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_setattr</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_setattro</span></code></p>
<p>이 필드는 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a>와 함께 서브 형에 의해 상속됩니다. 서브 형은 서브 형의 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a>과 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a>가 모두 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 때 베이스형에서 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a>과 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a>를 모두 상속합니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_as_async">
<a class="reference internal" href="#c.PyAsyncMethods" title="PyAsyncMethods">PyAsyncMethods</a>* <code class="sig-name descname">PyTypeObject.tp_as_async</code><a class="headerlink" href="#c.PyTypeObject.tp_as_async" title="정의 주소">¶</a></dt>
<dd><p>C 수준에서 <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a>과 <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">비동기 이터레이터</span></a> 프로토콜을 구현하는 객체에만 관련된 필드를 포함하는 추가 구조체에 대한 포인터. 자세한 내용은 <a class="reference internal" href="#async-structs"><span class="std std-ref">비동기 객체 구조체</span></a>를 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가: </span>이전에는 <code class="docutils literal notranslate"><span class="pre">tp_compare</span></code>와 <code class="docutils literal notranslate"><span class="pre">tp_reserved</span></code>라고 했습니다.</p>
</div>
<p><strong>계승:</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_async" title="PyTypeObject.tp_as_async"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_async</span></code></a> 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상속됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_repr">
<a class="reference internal" href="#c.reprfunc" title="reprfunc">reprfunc</a> <code class="sig-name descname">PyTypeObject.tp_repr</code><a class="headerlink" href="#c.PyTypeObject.tp_repr" title="정의 주소">¶</a></dt>
<dd><p id="index-1">내장 함수 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a>을 구현하는 함수에 대한 선택적 포인터.</p>
<p>서명은 <a class="reference internal" href="object.html#c.PyObject_Repr" title="PyObject_Repr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Repr()</span></code></a>과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">tp_repr</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>함수는 문자열이나 유니코드 객체를 반환해야 합니다. 이상적으로, 이 함수는 <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>에 전달될 때 적합한 환경이 주어지면 같은 값을 가진 객체를 반환하는 문자열을 반환해야 합니다. 이것이 가능하지 않으면, <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code>로 시작하고 <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>로 끝나는 문자열을 반환해야 하는데, 이 문자열에서 객체의 형과 값을 모두 추론할 수 있어야 합니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형으로 상속됩니다.</p>
<p><strong>기본값:</strong></p>
<p>이 필드를 설정하지 않으면, <code class="docutils literal notranslate"><span class="pre">&lt;%s</span> <span class="pre">object</span> <span class="pre">at</span> <span class="pre">%p&gt;</span></code> 형식의 문자열이 반환됩니다. 여기서 <code class="docutils literal notranslate"><span class="pre">%s</span></code>는 형 이름으로, <code class="docutils literal notranslate"><span class="pre">%p</span></code>는 객체의 메모리 주소로 치환됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_as_number">
<a class="reference internal" href="#c.PyNumberMethods" title="PyNumberMethods">PyNumberMethods</a>* <code class="sig-name descname">PyTypeObject.tp_as_number</code><a class="headerlink" href="#c.PyTypeObject.tp_as_number" title="정의 주소">¶</a></dt>
<dd><p>숫자 프로토콜을 구현하는 객체에만 관련된 필드를 포함하는 추가 구조체에 대한 포인터. 이 필드는 <a class="reference internal" href="#number-structs"><span class="std std-ref">숫자 객체 구조체</span></a>에서 설명합니다.</p>
<p><strong>계승:</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_number" title="PyTypeObject.tp_as_number"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_number</span></code></a> 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상속됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_as_sequence">
<a class="reference internal" href="#c.PySequenceMethods" title="PySequenceMethods">PySequenceMethods</a>* <code class="sig-name descname">PyTypeObject.tp_as_sequence</code><a class="headerlink" href="#c.PyTypeObject.tp_as_sequence" title="정의 주소">¶</a></dt>
<dd><p>시퀀스 프로토콜을 구현하는 객체에만 관련된 필드를 포함하는 추가 구조체에 대한 포인터. 이 필드는 <a class="reference internal" href="#sequence-structs"><span class="std std-ref">시퀀스 객체 구조체</span></a>에서 설명합니다.</p>
<p><strong>계승:</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_sequence" title="PyTypeObject.tp_as_sequence"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_sequence</span></code></a> 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상속됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_as_mapping">
<a class="reference internal" href="#c.PyMappingMethods" title="PyMappingMethods">PyMappingMethods</a>* <code class="sig-name descname">PyTypeObject.tp_as_mapping</code><a class="headerlink" href="#c.PyTypeObject.tp_as_mapping" title="정의 주소">¶</a></dt>
<dd><p>매핑 프로토콜을 구현하는 객체에만 관련된 필드를 포함하는 추가 구조체에 대한 포인터. 이 필드는 <a class="reference internal" href="#mapping-structs"><span class="std std-ref">매핑 객체 구조체</span></a>에서 설명합니다.</p>
<p><strong>계승:</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_mapping" title="PyTypeObject.tp_as_mapping"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_mapping</span></code></a> 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상속됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_hash">
<a class="reference internal" href="#c.hashfunc" title="hashfunc">hashfunc</a> <code class="sig-name descname">PyTypeObject.tp_hash</code><a class="headerlink" href="#c.PyTypeObject.tp_hash" title="정의 주소">¶</a></dt>
<dd><p id="index-2">내장 함수 <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a>를 구현하는 함수에 대한 선택적 포인터.</p>
<p>서명은 <a class="reference internal" href="object.html#c.PyObject_Hash" title="PyObject_Hash"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Hash()</span></code></a>와 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Py_hash_t</span> <span class="nf">tp_hash</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-1</span></code> 값은 정상적인 반환 값으로 반환되지 않아야 합니다; 해시값을 계산하는 동안 에러가 발생하면 함수는 예외를 설정하고 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환해야 합니다.</p>
<p>이 필드가 설정되지 않으면 (<em>그리고</em> <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_richcompare</span></code>가 설정되지 않으면), 객체의 해시를 취하려는 시도는 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다. 이것은 <a class="reference internal" href="object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_HashNotImplemented()</span></code></a>로 설정하는 것과 같습니다.</p>
<p>이 필드는 부모 형에서 해시 메서드의 상속을 차단하기 위해 <a class="reference internal" href="object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_HashNotImplemented()</span></code></a>로 명시적으로 설정할 수 있습니다. 이것은 파이썬 수준에서의 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code>과 동등한 것으로 해석되어, <code class="docutils literal notranslate"><span class="pre">isinstance(o,</span> <span class="pre">collections.Hashable)</span></code>이 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 올바르게 반환하게 합니다. 반대의 경우도 마찬가지입니다 - 파이썬 수준의 클래스에서 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code>을 설정하면 <code class="docutils literal notranslate"><span class="pre">tp_hash</span></code> 슬롯이 <a class="reference internal" href="object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_HashNotImplemented()</span></code></a>로 설정됩니다.</p>
<p><strong>계승:</strong></p>
<p>그룹: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_hash</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_richcompare</span></code></p>
<p>이 필드는 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a>와 함께 서브 형에 의해 상속됩니다: 서브 형의 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a>와 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>가 모두 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 때, 서브 형은 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a>와 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>를 모두 상속합니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_call">
<a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc">ternaryfunc</a> <code class="sig-name descname">PyTypeObject.tp_call</code><a class="headerlink" href="#c.PyTypeObject.tp_call" title="정의 주소">¶</a></dt>
<dd><p>객체 호출을 구현하는 함수에 대한 선택적 포인터. 객체가 콜러블이 아니면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이어야 합니다. 서명은 <a class="reference internal" href="object.html#c.PyObject_Call" title="PyObject_Call"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Call()</span></code></a>과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">tp_call</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형으로 상속됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_str">
<a class="reference internal" href="#c.reprfunc" title="reprfunc">reprfunc</a> <code class="sig-name descname">PyTypeObject.tp_str</code><a class="headerlink" href="#c.PyTypeObject.tp_str" title="정의 주소">¶</a></dt>
<dd><p>내장 연산 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>을 구현하는 함수에 대한 선택적 포인터. (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>는 이제 형이며, <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>은 그 형의 생성자를 호출함에 유의하십시오. 이 생성자는 <a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Str()</span></code></a>를 호출하여 실제 작업을 수행하고, <a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Str()</span></code></a>은 이 처리기를 호출합니다.)</p>
<p>서명은 <a class="reference internal" href="object.html#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Str()</span></code></a>과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">tp_str</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>함수는 문자열이나 유니코드 객체를 반환해야 합니다. 다른 것 중에서도, <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 함수에 의해 사용될 표현이기 때문에, 객체의 &quot;친숙한&quot; 문자열 표현이어야 합니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형으로 상속됩니다.</p>
<p><strong>기본값:</strong></p>
<p>이 필드를 설정하지 않으면, 문자열 표현을 반환하기 위해 <a class="reference internal" href="object.html#c.PyObject_Repr" title="PyObject_Repr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Repr()</span></code></a>이 호출됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_getattro">
<a class="reference internal" href="#c.getattrofunc" title="getattrofunc">getattrofunc</a> <code class="sig-name descname">PyTypeObject.tp_getattro</code><a class="headerlink" href="#c.PyTypeObject.tp_getattro" title="정의 주소">¶</a></dt>
<dd><p>어트리뷰트 읽기(get-attribute) 함수에 대한 선택적 포인터.</p>
<p>서명은 <a class="reference internal" href="object.html#c.PyObject_GetAttr" title="PyObject_GetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetAttr()</span></code></a>과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">tp_getattro</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</pre></div>
</div>
<p>일반적으로 이 필드를 <a class="reference internal" href="object.html#c.PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericGetAttr()</span></code></a>로 설정하는 것이 편리합니다, 객체 어트리뷰트를 찾는 일반적인 방법을 구현합니다.</p>
<p><strong>계승:</strong></p>
<p>그룹: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_getattr</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_getattro</span></code></p>
<p>이 필드는 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a>과 함께 서브 형에 의해 상속됩니다: 서브 형의 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a>과 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a>가 모두 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 때 서브 형은 베이스형에서 <a class="reference internal" href="#c.PyTypeObject.tp_getattr" title="PyTypeObject.tp_getattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattr</span></code></a>과 <a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a>를 모두 상속합니다.</p>
<p><strong>기본값:</strong></p>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code>은 <a class="reference internal" href="object.html#c.PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericGetAttr()</span></code></a>을 사용합니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_setattro">
<a class="reference internal" href="#c.setattrofunc" title="setattrofunc">setattrofunc</a> <code class="sig-name descname">PyTypeObject.tp_setattro</code><a class="headerlink" href="#c.PyTypeObject.tp_setattro" title="정의 주소">¶</a></dt>
<dd><p>어트리뷰트 설정과 삭제를 위한 함수에 대한 선택적 포인터.</p>
<p>서명은 <a class="reference internal" href="object.html#c.PyObject_SetAttr" title="PyObject_SetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetAttr()</span></code></a>과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">tp_setattro</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>또한, <em>value</em>를 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정하여 어트리뷰트를 삭제하는 것을 반드시 지원해야 합니다. 일반적으로 이 필드를 <a class="reference internal" href="object.html#c.PyObject_GenericSetAttr" title="PyObject_GenericSetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericSetAttr()</span></code></a>로 설정하는 것이 편리합니다, 객체 어트리뷰트를 설정하는 일반적인 방법을 구현합니다.</p>
<p><strong>계승:</strong></p>
<p>그룹: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_setattr</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_setattro</span></code></p>
<p>이 필드는 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a>과 함께 서브 형에 의해 상속됩니다: 서브 형의 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a>과 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a>가 모두 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 때, 서브 형은 베이스형에서 <a class="reference internal" href="#c.PyTypeObject.tp_setattr" title="PyTypeObject.tp_setattr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattr</span></code></a>과 <a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a>를 모두 상속합니다.</p>
<p><strong>기본값:</strong></p>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code>은 <a class="reference internal" href="object.html#c.PyObject_GenericSetAttr" title="PyObject_GenericSetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericSetAttr()</span></code></a>을 사용합니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_as_buffer">
<a class="reference internal" href="#c.PyBufferProcs" title="PyBufferProcs">PyBufferProcs</a>* <code class="sig-name descname">PyTypeObject.tp_as_buffer</code><a class="headerlink" href="#c.PyTypeObject.tp_as_buffer" title="정의 주소">¶</a></dt>
<dd><p>버퍼 인터페이스를 구현하는 객체에만 관련된 필드를 포함하는 추가 구조체에 대한 포인터. 이 필드는 <a class="reference internal" href="#buffer-structs"><span class="std std-ref">버퍼 객체 구조체</span></a>에서 설명합니다.</p>
<p><strong>계승:</strong></p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_buffer</span></code></a> 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상속됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_flags">
unsigned long <code class="sig-name descname">PyTypeObject.tp_flags</code><a class="headerlink" href="#c.PyTypeObject.tp_flags" title="정의 주소">¶</a></dt>
<dd><p>이 필드는 다양한 플래그의 비트 마스크입니다. 일부 플래그는 특정 상황에 대한 변형 의미론을 나타냅니다; 다른 것들은 역사적으로 항상 존재하지는 않았던 형 객체(또는 <a class="reference internal" href="#c.PyTypeObject.tp_as_number" title="PyTypeObject.tp_as_number"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_number</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_as_sequence" title="PyTypeObject.tp_as_sequence"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_sequence</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_as_mapping" title="PyTypeObject.tp_as_mapping"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_mapping</span></code></a> 및 <a class="reference internal" href="#c.PyTypeObject.tp_as_buffer" title="PyTypeObject.tp_as_buffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_as_buffer</span></code></a>를 통해 참조되는 확장 구조체)의 특정 필드가 유효함을 나타내는 데 사용됩니다; 이러한 플래그 비트가 없으면, 이것이 보호하는 형 필드에 액세스하지 말아야 하며 대신 0이나 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 값을 갖는 것으로 간주해야 합니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드의 상속은 복잡합니다. 대부분 플래그 비트는 개별적으로 상속됩니다, 즉, 베이스형에 플래그 비트가 설정되어 있으면, 서브 형이 이 플래그 비트를 상속합니다. 확장 구조체와 관련된 플래그 비트는 확장 구조체가 상속되면 엄격하게 상속됩니다, 즉, 플래그 비트의 베이스형의 값이 확장 구조체에 대한 포인터와 함께 서브 형으로 복사됩니다. <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 플래그 비트는 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a>와 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 필드와 함께 상속됩니다, 즉, 서브 형에서 <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 플래그 비트가 설정되지 않고 서브 형의 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a>와 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 필드가 존재하고 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 값을 갖는 경우.</p>
<p><strong>기본값:</strong></p>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code>은 <code class="docutils literal notranslate"><span class="pre">Py_TPFLAGS_DEFAULT</span> <span class="pre">|</span> <span class="pre">Py_TPFLAGS_BASETYPE</span></code>을 사용합니다.</p>
<p><strong>비트 마스크:</strong></p>
<p>다음 비트 마스크가 현재 정의되어 있습니다; 이들은 <code class="docutils literal notranslate"><span class="pre">|</span></code> 연산자로 함께 OR 하여 <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a> 필드의 값을 형성할 수 있습니다. 매크로 <a class="reference internal" href="type.html#c.PyType_HasFeature" title="PyType_HasFeature"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_HasFeature()</span></code></a>는 형과 플래그 값 <em>tp</em>와 <em>f</em>를 취하고 <code class="docutils literal notranslate"><span class="pre">tp-&gt;tp_flags</span> <span class="pre">&amp;</span> <span class="pre">f</span></code>가 0이 아닌지 확인합니다.</p>
<dl class="data">
<dt id="Py_TPFLAGS_HEAPTYPE">
<code class="sig-name descname">Py_TPFLAGS_HEAPTYPE</code><a class="headerlink" href="#Py_TPFLAGS_HEAPTYPE" title="정의 주소">¶</a></dt>
<dd><p>이 비트는 형 객체 자체가 힙에 할당될 때 설정됩니다, 예를 들어, <a class="reference internal" href="type.html#c.PyType_FromSpec" title="PyType_FromSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromSpec()</span></code></a>을 사용하여 동적으로 만들어진 형. 이 경우, 인스턴스의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_type</span></code> 필드는 형에 대한 참조로 간주하며, 새 인스턴스가 만들어질 때 형 객체가 INCREF되고, 인스턴스가 파괴될 때 DECREF됩니다 (이는 서브 형의 인스턴스에 적용되지 않습니다; 인스턴스의 ob_type이 참조하는 형만 INCREF나 DECREF 됩니다).</p>
<p><strong>계승:</strong></p>
<p>???</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_BASETYPE">
<code class="sig-name descname">Py_TPFLAGS_BASETYPE</code><a class="headerlink" href="#Py_TPFLAGS_BASETYPE" title="정의 주소">¶</a></dt>
<dd><p>이 비트는 형을 다른 형의 베이스형으로 사용할 수 있을 때 설정됩니다. 이 비트가 설정되지 않으면 이 형으로 서브 형을 만들 수 없습니다 (Java의 &quot;final&quot; 클래스와 유사합니다).</p>
<p><strong>계승:</strong></p>
<p>???</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_READY">
<code class="sig-name descname">Py_TPFLAGS_READY</code><a class="headerlink" href="#Py_TPFLAGS_READY" title="정의 주소">¶</a></dt>
<dd><p>이 비트는 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a>에 의해 형 객체가 완전히 초기화될 때 설정됩니다.</p>
<p><strong>계승:</strong></p>
<p>???</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_READYING">
<code class="sig-name descname">Py_TPFLAGS_READYING</code><a class="headerlink" href="#Py_TPFLAGS_READYING" title="정의 주소">¶</a></dt>
<dd><p>이 비트는 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a>가 형 객체를 초기화하는 동안 설정됩니다.</p>
<p><strong>계승:</strong></p>
<p>???</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_HAVE_GC">
<code class="sig-name descname">Py_TPFLAGS_HAVE_GC</code><a class="headerlink" href="#Py_TPFLAGS_HAVE_GC" title="정의 주소">¶</a></dt>
<dd><p>이 비트는 객체가 가비지 수집을 지원할 때 설정됩니다. 이 비트가 설정되면, 인스턴스는 <a class="reference internal" href="gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_New()</span></code></a>를 사용하여 만들어져야 하고 <a class="reference internal" href="gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Del()</span></code></a>을 사용하여 파괴되어야 합니다. <a class="reference internal" href="gcsupport.html#supporting-cycle-detection"><span class="std std-ref">순환 가비지 수집 지원</span></a> 섹션에 추가 정보가 있습니다. 이 비트는 또한 GC 관련 필드 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a>와 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a>가 형 객체에 있음을 암시합니다.</p>
<p><strong>계승:</strong></p>
<p>그룹: <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_traverse</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_clear</span></code></p>
<p><a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 플래그 비트는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_traverse</span></code>와 <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_clear</span></code> 필드와 함께 상속됩니다, 즉, 서브 형에서 <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 플래그 비트가 설정되지 않고 서브 형의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_traverse</span></code>와 <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_clear</span></code> 필드가 존재하고 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 값을 갖는 경우.</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_DEFAULT">
<code class="sig-name descname">Py_TPFLAGS_DEFAULT</code><a class="headerlink" href="#Py_TPFLAGS_DEFAULT" title="정의 주소">¶</a></dt>
<dd><p>이것은 형 객체와 그 확장 구조체에서 특정 필드의 존재와 관련된 모든 비트의 비트 마스크입니다. 현재, 다음과 같은 필드를 포함합니다: <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_STACKLESS_EXTENSION</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_VERSION_TAG</span></code>.</p>
<p><strong>계승:</strong></p>
<p>???</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_METHOD_DESCRIPTOR">
<code class="sig-name descname">Py_TPFLAGS_METHOD_DESCRIPTOR</code><a class="headerlink" href="#Py_TPFLAGS_METHOD_DESCRIPTOR" title="정의 주소">¶</a></dt>
<dd><p>이 비트는 객체가 연결되지 않은 메서드(unbound method)처럼 동작함을 나타냅니다.</p>
<p>이 플래그가 <code class="docutils literal notranslate"><span class="pre">type(meth)</span></code>에 설정되면:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">meth.__get__(obj,</span> <span class="pre">cls)(*args,</span> <span class="pre">**kwds)</span></code>(<code class="docutils literal notranslate"><span class="pre">obj</span></code>가 None이 아닐 때)는 <code class="docutils literal notranslate"><span class="pre">meth(obj,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code>와 동등해야 합니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">meth.__get__(None,</span> <span class="pre">cls)(*args,</span> <span class="pre">**kwds)</span></code>는 <code class="docutils literal notranslate"><span class="pre">meth(*args,</span> <span class="pre">**kwds)</span></code>와 동등해야 합니다.</p></li>
</ul>
<p>이 플래그는 <code class="docutils literal notranslate"><span class="pre">obj.meth()</span></code>와 같은 일반적인 메서드 호출에 대한 최적화를 가능하게 합니다: <code class="docutils literal notranslate"><span class="pre">obj.meth</span></code>에 대한 임시 &quot;연결된 메서드(bound method)&quot; 객체를 만들지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
<p><strong>계승:</strong></p>
<p>이 플래그는 힙 형에 의해 상속되지 않습니다. 확장형의 경우, <a class="reference internal" href="#c.PyTypeObject.tp_descr_get" title="PyTypeObject.tp_descr_get"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descr_get</span></code></a>이 상속될 때마다 상속됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_LONG_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_LONG_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_LONG_SUBCLASS" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_LIST_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_LIST_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_LIST_SUBCLASS" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_TUPLE_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_TUPLE_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_TUPLE_SUBCLASS" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_BYTES_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_BYTES_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_BYTES_SUBCLASS" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_UNICODE_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_UNICODE_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_UNICODE_SUBCLASS" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_DICT_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_DICT_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_DICT_SUBCLASS" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_BASE_EXC_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_BASE_EXC_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_BASE_EXC_SUBCLASS" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_TYPE_SUBCLASS">
<code class="sig-name descname">Py_TPFLAGS_TYPE_SUBCLASS</code><a class="headerlink" href="#Py_TPFLAGS_TYPE_SUBCLASS" title="정의 주소">¶</a></dt>
<dd><p>이 플래그는 <a class="reference internal" href="long.html#c.PyLong_Check" title="PyLong_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyLong_Check()</span></code></a> 와 같은 함수에서 형이 내장형의 서브 클래스인지 신속하게 판별하는 데 사용됩니다; 이러한 특정 검사는 <a class="reference internal" href="object.html#c.PyObject_IsInstance" title="PyObject_IsInstance"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_IsInstance()</span></code></a>와 같은 일반 검사보다 빠릅니다. 내장에서 상속된 사용자 정의 형은 <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a>를 적절하게 설정해야 합니다, 그렇지 않으면 그러한 형과 상호 작용하는 코드가 사용되는 검사의 유형에 따라 다르게 작동합니다.</p>
</dd></dl>

<dl class="data">
<dt id="Py_TPFLAGS_HAVE_FINALIZE">
<code class="sig-name descname">Py_TPFLAGS_HAVE_FINALIZE</code><a class="headerlink" href="#Py_TPFLAGS_HAVE_FINALIZE" title="정의 주소">¶</a></dt>
<dd><p>이 비트는 <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a> 슬롯이 형 구조체에 있을 때 설정됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.8부터 폐지: </span>인터프리터는 <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a> 슬롯이 항상 형 구조체에 있다고 가정하기 때문에, 이 플래그는 더는 필요하지 않습니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="_Py_TPFLAGS_HAVE_VECTORCALL">
<code class="sig-name descname">_Py_TPFLAGS_HAVE_VECTORCALL</code><a class="headerlink" href="#_Py_TPFLAGS_HAVE_VECTORCALL" title="정의 주소">¶</a></dt>
<dd><p>이 비트는 클래스가 벡터콜 프로토콜을 구현할 때 설정됩니다. 자세한 내용은 <a class="reference internal" href="#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code></a>을 참조하십시오.</p>
<p><strong>계승:</strong></p>
<p>이 비트는 <code class="docutils literal notranslate"><span class="pre">tp_flags</span></code>가 재정의되지 않으면 <em>정적(static)</em> 서브 형에 설정됩니다: 서브 형의 <a class="reference internal" href="#c.PyTypeObject.tp_call" title="PyTypeObject.tp_call"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_call</span></code></a>이 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이고 서브 형의 <code class="docutils literal notranslate"><span class="pre">Py_TPFLAGS_HEAPTYPE</span></code>이 설정되지 않을 때 서브 형은 베이스형에서 <code class="docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code>을 상속합니다.</p>
<p><a class="reference internal" href="#id4">힙 형</a>은 <code class="docutils literal notranslate"><span class="pre">_Py_TPFLAGS_HAVE_VECTORCALL</span></code>을 상속하지 않습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 플래그는 잠정적이며 파이썬 3.9에서 다른 이름과 변경된 의미론으로 공개되리라고 봅니다. 벡터콜을 사용하면, 파이썬 3.9 용으로 코드를 갱신할 준비를 하십시오.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_doc">
const char* <code class="sig-name descname">PyTypeObject.tp_doc</code><a class="headerlink" href="#c.PyTypeObject.tp_doc" title="정의 주소">¶</a></dt>
<dd><p>이 형 객체에 대한 독스트링을 제공하는 NUL-종료 C 문자열에 대한 선택적 포인터. 이는 형과 형의 인스턴스에서 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 어트리뷰트로 노출됩니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형에 의해 상속되지 <em>않습니다</em>.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_traverse">
<a class="reference internal" href="gcsupport.html#c.traverseproc" title="traverseproc">traverseproc</a> <code class="sig-name descname">PyTypeObject.tp_traverse</code><a class="headerlink" href="#c.PyTypeObject.tp_traverse" title="정의 주소">¶</a></dt>
<dd><p>가비지 수집기의 탐색 함수에 대한 선택적 포인터. <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 플래그 비트가 설정된 경우에만 사용됩니다. 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">tp_traverse</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</pre></div>
</div>
<p>파이썬의 가비지 수집 체계에 대한 자세한 정보는 섹션 <a class="reference internal" href="gcsupport.html#supporting-cycle-detection"><span class="std std-ref">순환 가비지 수집 지원</span></a>에서 찾을 수 있습니다.</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 포인터는 가비지 수집기에서 참조 순환을 감지하는 데 사용됩니다. <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 함수의 일반적인 구현은 단순히 파이썬 객체인 각 인스턴스 멤버에 대해 <a class="reference internal" href="gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_VISIT()</span></code></a>를 호출합니다. 예를 들어, 다음은 <a class="reference internal" href="../library/_thread.html#module-_thread" title="_thread: Low-level threading API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">_thread</span></code></a> 확장 모듈의 함수 <code class="xref c c-func docutils literal notranslate"><span class="pre">local_traverse()</span></code>입니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">local_traverse</span><span class="p">(</span><span class="n">localobject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
    <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">kw</span><span class="p">);</span>
    <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_VISIT()</span></code></a>는 참조 순환에 참여할 수 있는 멤버에 대해서만 호출됨에 유의하십시오. <code class="docutils literal notranslate"><span class="pre">self-&gt;key</span></code> 멤버도 있지만, <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이나 파이썬 문자열만 가능해서 참조 순환의 일부가 될 수 없습니다.</p>
<p>반면에, 멤버가 사이클의 일부가 될 수 없다는 것을 알고 있더라도, 디버깅 지원을 위해 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 모듈의 <a class="reference internal" href="../library/gc.html#gc.get_referents" title="gc.get_referents"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_referents()</span></code></a> 함수가 그것을 포함하도록 어쨌거나 방문하고 싶을 수 있습니다.</p>
<p><a class="reference internal" href="gcsupport.html#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_VISIT()</span></code></a>는 <code class="xref c c-func docutils literal notranslate"><span class="pre">local_traverse()</span></code>의 <em>visit</em>와 <em>arg</em> 매개 변수가 이 이름일 것을 요구합니다; 다른 이름을 붙이지 마십시오.</p>
<p><strong>계승:</strong></p>
<p>그룹: <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_traverse</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_clear</span></code></p>
<p>이 필드는 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a>와 <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 플래그 비트와 함께 서브 형에 의해 상속됩니다: 플래그 비트, <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 및 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a>가 서브 형에서 모두 0이면 모두 베이스형에서 상속됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_clear">
<a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry">inquiry</a> <code class="sig-name descname">PyTypeObject.tp_clear</code><a class="headerlink" href="#c.PyTypeObject.tp_clear" title="정의 주소">¶</a></dt>
<dd><p>가비지 수집기의 정리 함수(clear function)에 대한 선택적 포인터. <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 플래그 비트가 설정된 경우에만 사용됩니다. 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">tp_clear</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 멤버 함수는 가비지 수집기에서 감지한 순환 가비지에서 참조 순환을 끊는 데 사용됩니다. 종합하여, 시스템의 모든 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 함수가 결합하여 모든 참조 순환을 끊어야 합니다. 이것은 미묘합니다, 확신이 서지 않으면 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 함수를 제공하십시오. 예를 들어, 튜플 형은 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 함수를 구현하지 않습니다. 튜플만으로는 참조 순환이 구성될 수 없음을 증명할 수 있기 때문입니다. 따라서 다른 형의 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 함수만으로 튜플을 포함하는 순환을 끊기에 충분해야 합니다. 이것은 그리 자명하지 않으며, <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a>를 구현하지 않아도 좋을 만한 이유는 거의 없습니다.</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a>의 구현은 다음 예제와 같이 파이썬 객체일 수 있는 자신의 멤버에 대한 인스턴스의 참조를 삭제하고 해당 멤버에 대한 포인터를 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정해야 합니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">local_clear</span><span class="p">(</span><span class="n">localobject</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
    <span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">);</span>
    <span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">kw</span><span class="p">);</span>
    <span class="n">Py_CLEAR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>참조 제거는 섬세한 작업이라서 <a class="reference internal" href="refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_CLEAR()</span></code></a> 매크로를 사용해야 합니다: 포함된 객체에 대한 포인터가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정될 때까지 포함된 객체에 대한 참조를 감소시키지 않아야 합니다. 이는 참조 횟수를 줄이면 포함된 객체가 버려지게 되어 임의의 파이썬 코드 호출을 포함하는 일련의 교정 활동을 촉발할 수 있기 때문입니다 (포함된 객체와 연관된 파이널라이저나 약한 참조 콜백으로 인해). 그러한 코드가 <em>self</em>를 다시 참조 할 수 있다면, 포함된 객체를 더는 사용할 수 없다는 것을 <em>self</em>가 알 수 있도록, 포함된 객체에 대한 포인터가 그 시점에 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 되는 것이 중요합니다. <a class="reference internal" href="refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_CLEAR()</span></code></a> 매크로는 안전한 순서로 작업을 수행합니다.</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a> 함수의 목표는 참조 순환을 끊는 것이기 때문에, 참조 순환에 참여할 수 없는 파이썬 문자열이나 파이썬 정수와 같은 포함된 객체를 정리할 필요는 없습니다. 반면에, 포함된 모든 파이썬 객체를 정리하고, 형의 <a class="reference internal" href="#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dealloc</span></code></a> 함수가 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a>를 호출하도록 작성하는 것이 편리할 수 있습니다.</p>
<p>파이썬의 가비지 수집 체계에 대한 자세한 정보는 섹션 <a class="reference internal" href="gcsupport.html#supporting-cycle-detection"><span class="std std-ref">순환 가비지 수집 지원</span></a>에서 찾을 수 있습니다.</p>
<p><strong>계승:</strong></p>
<p>그룹: <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_traverse</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_clear</span></code></p>
<p>이 필드는 <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a>와 <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 플래그 비트와 함께 서브 형에 의해 상속됩니다: 플래그 비트, <a class="reference internal" href="#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a> 및 <a class="reference internal" href="#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a>가 서브 형에서 모두 0이면 모두 베이스형에서 상속됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_richcompare">
<a class="reference internal" href="#c.richcmpfunc" title="richcmpfunc">richcmpfunc</a> <code class="sig-name descname">PyTypeObject.tp_richcompare</code><a class="headerlink" href="#c.PyTypeObject.tp_richcompare" title="정의 주소">¶</a></dt>
<dd><p>풍부한 비교 함수(rich comparison function)에 대한 선택적 포인터. 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">tp_richcompare</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">);</span>
</pre></div>
</div>
<p>첫 번째 매개 변수는 <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a>에 의해 정의된 형의 인스턴스임이 보장됩니다.</p>
<p>이 함수는 비교 결과(일반적으로 <code class="docutils literal notranslate"><span class="pre">Py_True</span></code>나 <code class="docutils literal notranslate"><span class="pre">Py_False</span></code>)를 반환해야 합니다. 비교가 정의되어 있지 않으면, <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code>를 반환하고, 다른 에러가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환하고 예외 조건을 설정해야 합니다.</p>
<p>다음 상수는 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a>와 <a class="reference internal" href="object.html#c.PyObject_RichCompare" title="PyObject_RichCompare"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_RichCompare()</span></code></a>의 세 번째 인자로 사용되도록 정의됩니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 57%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>상수</p></th>
<th class="head"><p>비교</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_LT</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_LE</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_EQ</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_NE</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">!=</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_GT</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_GE</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></td>
</tr>
</tbody>
</table>
<p>풍부한 비교 함수를 쉽게 작성할 수 있도록 다음 매크로가 정의됩니다:</p>
<dl class="function">
<dt id="c.Py_RETURN_RICHCOMPARE">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">Py_RETURN_RICHCOMPARE</code><span class="sig-paren">(</span>VAL_A, VAL_B, int<em> op</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_RETURN_RICHCOMPARE" title="정의 주소">¶</a></dt>
<dd><p>비교 결과에 따라, 함수에서 <code class="docutils literal notranslate"><span class="pre">Py_True</span></code>나 <code class="docutils literal notranslate"><span class="pre">Py_False</span></code>를 반환합니다. VAL_A와 VAL_B는 C 비교 연산자로 순서를 정할 수 있어야 합니다 (예를 들어, C int나 float일 수 있습니다). 세 번째 인자는 <a class="reference internal" href="object.html#c.PyObject_RichCompare" title="PyObject_RichCompare"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_RichCompare()</span></code></a>에서처럼 요청된 연산을 지정합니다.</p>
<p>반환 값의 참조 횟수가 올바르게 증가합니다.</p>
<p>에러가 발생하면, 예외를 설정하고 함수에서 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<p><strong>계승:</strong></p>
<p>그룹: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_hash</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_richcompare</span></code></p>
<p>이 필드는 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>와 함께 서브 형에 의해 상속됩니다. 서브 형의 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a>와 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>가 모두 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면 서브 형은 <a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a>와 <a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>를 상속합니다.</p>
<p><strong>기본값:</strong></p>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code>은 상속될 수 있는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_richcompare</span></code> 구현을 제공합니다. 그러나, <code class="xref py py-attr docutils literal notranslate"><span class="pre">tp_hash</span></code>만 정의하면, 상속된 함수조차 사용되지 않으며 해당 형의 인스턴스는 비교에 참여할 수 없습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_weaklistoffset">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_weaklistoffset</code><a class="headerlink" href="#c.PyTypeObject.tp_weaklistoffset" title="정의 주소">¶</a></dt>
<dd><p>이 형의 인스턴스가 약하게 참조할 수 있으면, 이 필드는 0보다 크고 약한 참조 리스트 헤드의 인스턴스 구조체에서의 오프셋을 포함합니다 (있다면 GC 헤더를 무시하고); 이 오프셋은 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_ClearWeakRefs()</span></code>와 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyWeakref_*()</span></code> 함수에서 사용됩니다. 인스턴스 구조체에는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 초기화되는 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code></a> 형의 필드가 포함되어야 합니다.</p>
<p>이 필드를 <a class="reference internal" href="#c.PyTypeObject.tp_weaklist" title="PyTypeObject.tp_weaklist"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklist</span></code></a>와 혼동하지 마십시오; 그것은 형 객체 자체에 대한 약한 참조의 리스트 헤드입니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형에 의해 상속되지만, 아래 나열된 규칙을 참조하십시오. 서브 형이 이 오프셋을 재정의할 수 있습니다; 이는 서브 형이 베이스형과 다른 약한 참조 리스트 헤드를 사용함을 의미합니다. 리스트 헤드는 항상 <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a>을 통해 발견되므로, 문제가 되지 않습니다.</p>
<p>클래스 문으로 정의된 형에 <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 선언이 없고, 그것의 베이스형 중 약한 참조 가능한 것이 없으면, 약한 참조 리스트 헤드 슬롯을 인스턴스 배치에 추가하고 해당 슬롯 오프셋의 <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a>을 설정하여 해당 형을 약하게 참조할 수 있게 만듭니다.</p>
<p>형의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code> 선언에 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__weakref__</span></code>라는 슬롯이 포함되면, 해당 슬롯은 해당 형의 인스턴스에 대한 약한 참조 리스트 헤드가 되고, 슬롯의 오프셋은 형의 <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a>에 저장됩니다.</p>
<p>형의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code> 선언에 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__weakref__</span></code>라는 슬롯이 없으면, 형은 베이스형에서 <a class="reference internal" href="#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a>을 상속합니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_iter">
<a class="reference internal" href="#c.getiterfunc" title="getiterfunc">getiterfunc</a> <code class="sig-name descname">PyTypeObject.tp_iter</code><a class="headerlink" href="#c.PyTypeObject.tp_iter" title="정의 주소">¶</a></dt>
<dd><p>객체의 이터레이터를 반환하는 함수에 대한 선택적 포인터. 그 존재는 일반적으로 이 형의 인스턴스가 이터러블이라는 신호입니다 (시퀀스는 이 함수 없이도 이터러블일 수 있지만).</p>
<p>이 함수는 <a class="reference internal" href="object.html#c.PyObject_GetIter" title="PyObject_GetIter"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetIter()</span></code></a>와 같은 서명을 갖습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">tp_iter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형으로 상속됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_iternext">
<a class="reference internal" href="#c.iternextfunc" title="iternextfunc">iternextfunc</a> <code class="sig-name descname">PyTypeObject.tp_iternext</code><a class="headerlink" href="#c.PyTypeObject.tp_iternext" title="정의 주소">¶</a></dt>
<dd><p>이터레이터의 다음 항목을 반환하는 함수에 대한 선택적 포인터. 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">tp_iternext</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>이터레이터가 소진되면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환해야 합니다; <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외가 설정될 수도, 그렇지 않을 수도 있습니다. 다른 에러가 발생하면, 역시 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환해야 합니다. 그 존재는 이 형의 인스턴스가 이터레이터라는 신호입니다.</p>
<p>이터레이터 형은 <a class="reference internal" href="#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a> 함수도 정의해야 하며, 해당 함수는 (새 이터레이터 인스턴스가 아닌) 이터레이터 인스턴스 자체를 반환해야 합니다.</p>
<p>이 함수는 <a class="reference internal" href="iter.html#c.PyIter_Next" title="PyIter_Next"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyIter_Next()</span></code></a>와 같은 서명을 갖습니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형으로 상속됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_methods">
struct <a class="reference internal" href="structures.html#c.PyMethodDef" title="PyMethodDef">PyMethodDef</a>* <code class="sig-name descname">PyTypeObject.tp_methods</code><a class="headerlink" href="#c.PyTypeObject.tp_methods" title="정의 주소">¶</a></dt>
<dd><p>이 형의 일반 메서드를 선언하는 <a class="reference internal" href="structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 구조체의 정적 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>-종료 배열에 대한 선택적 포인터.</p>
<p>배열의 항목마다, 메서드 디스크립터를 포함하는 형의 딕셔너리(아래 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a>를 참조하십시오)에 항목이 추가됩니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형에 의해 상속되지 않습니다 (메서드는 다른 메커니즘을 통해 상속됩니다).</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_members">
struct <a class="reference internal" href="structures.html#c.PyMemberDef" title="PyMemberDef">PyMemberDef</a>* <code class="sig-name descname">PyTypeObject.tp_members</code><a class="headerlink" href="#c.PyTypeObject.tp_members" title="정의 주소">¶</a></dt>
<dd><p>이 형의 인스턴스의 일반 데이터 멤버(필드나 슬롯)를 선언하는 <a class="reference internal" href="structures.html#c.PyMemberDef" title="PyMemberDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemberDef</span></code></a> 구조체의 정적 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>-종료 배열에 대한 선택적 포인터.</p>
<p>배열의 항목마다, 멤버 디스크립터를 포함하는 형의 딕셔너리(아래 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a>를 참조하십시오)에 항목이 추가됩니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형에 의해 상속되지 않습니다 (멤버는 다른 메커니즘을 통해 상속됩니다).</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_getset">
struct <a class="reference internal" href="structures.html#c.PyGetSetDef" title="PyGetSetDef">PyGetSetDef</a>* <code class="sig-name descname">PyTypeObject.tp_getset</code><a class="headerlink" href="#c.PyTypeObject.tp_getset" title="정의 주소">¶</a></dt>
<dd><p>이 형의 인스턴스의 계산된 어트리뷰트를 선언하는 <a class="reference internal" href="structures.html#c.PyGetSetDef" title="PyGetSetDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyGetSetDef</span></code></a> 구조체의 정적 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>-종료 배열에 대한 선택적 포인터.</p>
<p>배열의 항목마다, getset 디스크립터를 포함하는 형의 딕셔너리(아래 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a>를 참조하십시오)에 항목이 추가됩니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형에 의해 상속되지 않습니다 (계산된 어트리뷰트는 다른 메커니즘을 통해 상속됩니다).</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_base">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a>* <code class="sig-name descname">PyTypeObject.tp_base</code><a class="headerlink" href="#c.PyTypeObject.tp_base" title="정의 주소">¶</a></dt>
<dd><p>형 속성이 상속되는 베이스형에 대한 선택적 포인터. 이 수준에서는, 단일 상속만 지원됩니다; 다중 상속은 메타 형을 호출하여 형 객체를 동적으로 작성해야 합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>슬롯 초기화에는 전역 초기화 규칙이 적용됩니다. C99에서는 초기화자가 &quot;주소 상수(address constants)&quot;여야 합니다. 포인터로 묵시적으로 변환되는 <a class="reference internal" href="type.html#c.PyType_GenericNew" title="PyType_GenericNew"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericNew()</span></code></a>와 같은 함수 지정자는 유효한 C99 주소 상수입니다.</p>
<p>그러나, <code class="xref c c-func docutils literal notranslate"><span class="pre">PyBaseObject_Type()</span></code>과 같은 정적이지 않은 변수에 적용된 단항 '&amp;' 연산자는 주소 상수를 생성할 필요가 없습니다. 컴파일러는 이를 지원할 수 있으며 (gcc는 지원합니다), MSVC는 지원하지 않습니다. 두 컴파일러 모두 이 특정 동작에서 엄격하게 표준을 준수합니다.</p>
<p>결과적으로, <a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_base</span></code></a>는 확장 모듈의 초기화 함수에서 설정되어야 합니다.</p>
</div>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형에 의해 상속되지 않습니다 (명백히).</p>
<p><strong>기본값:</strong></p>
<p>이 필드의 기본값은 <code class="docutils literal notranslate"><span class="pre">&amp;PyBaseObject_Type</span></code>입니다 (파이썬 프로그래머에게는 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 형으로 알려져 있습니다).</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_dict">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyTypeObject.tp_dict</code><a class="headerlink" href="#c.PyTypeObject.tp_dict" title="정의 주소">¶</a></dt>
<dd><p>형의 딕셔너리는 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a>에 의해 여기에 저장됩니다.</p>
<p>이 필드는 일반적으로 PyType_Ready가 호출되기 전에 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 초기화되어야 합니다; 형의 초기 어트리뷰트를 포함하는 딕셔너리로 초기화될 수도 있습니다. 일단 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a>가 형을 초기화하면, 형에 대한 추가 어트리뷰트가 (<a class="reference internal" href="../reference/datamodel.html#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>와 같은) 오버로드된 연산에 해당하지 않는 경우에만 이 딕셔너리에 추가될 수 있습니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형에 의해 상속되지 않습니다 (여기에 정의된 어트리뷰트는 다른 메커니즘을 통해 상속됩니다).</p>
<p><strong>기본값:</strong></p>
<p>이 필드가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a>는 새 딕셔너리를 할당합니다.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p><a class="reference internal" href="dict.html#c.PyDict_SetItem" title="PyDict_SetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyDict_SetItem()</span></code></a>을 사용하거나 다른 식으로 딕셔너리 C-API로 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a>를 수정하는 것은 안전하지 않습니다.</p>
</div>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_descr_get">
<a class="reference internal" href="#c.descrgetfunc" title="descrgetfunc">descrgetfunc</a> <code class="sig-name descname">PyTypeObject.tp_descr_get</code><a class="headerlink" href="#c.PyTypeObject.tp_descr_get" title="정의 주소">¶</a></dt>
<dd><p>&quot;디스크립터 get&quot; 함수에 대한 선택적 포인터.</p>
<p>함수 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span> <span class="nf">tp_descr_get</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형으로 상속됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_descr_set">
<a class="reference internal" href="#c.descrsetfunc" title="descrsetfunc">descrsetfunc</a> <code class="sig-name descname">PyTypeObject.tp_descr_set</code><a class="headerlink" href="#c.PyTypeObject.tp_descr_set" title="정의 주소">¶</a></dt>
<dd><p>디스크립터 값을 설정하고 삭제하기 위한 함수에 대한 선택적 포인터.</p>
<p>함수 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">tp_descr_set</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p><em>value</em> 인자는 값을 삭제하기 위해 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정됩니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형으로 상속됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_dictoffset">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_dictoffset</code><a class="headerlink" href="#c.PyTypeObject.tp_dictoffset" title="정의 주소">¶</a></dt>
<dd><p>이 형의 인스턴스에 인스턴스 변수를 포함하는 딕셔너리가 있으면, 이 필드는 0이 아니며 인스턴스 변수 딕셔너리 형의 인스턴스에서의 오프셋을 포함합니다; 이 오프셋은 <a class="reference internal" href="object.html#c.PyObject_GenericGetAttr" title="PyObject_GenericGetAttr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GenericGetAttr()</span></code></a>에서 사용됩니다.</p>
<p>이 필드를 <a class="reference internal" href="#c.PyTypeObject.tp_dict" title="PyTypeObject.tp_dict"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dict</span></code></a>와 혼동하지 마십시오; 그것은 형 객체 자체의 어트리뷰트에 대한 딕셔너리입니다.</p>
<p>이 필드의 값이 0보다 크면, 인스턴스 구조체의 시작으로부터의 오프셋을 지정합니다. 값이 0보다 작으면, 인스턴스 구조체의 <em>끝</em>으로부터의 오프셋을 지정합니다. 음수 오프셋은 사용하기네 더 비싸며, 인스턴스 구조체에 가변 길이 부분이 포함될 때에만 사용해야 합니다. 예를 들어 인스턴스 변수 딕셔너리를 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>이나 <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>의 서브 형에 추가하는 데 사용됩니다. 딕셔너리가 기본 객체 배치에 포함되어 있지 않더라도, <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> 필드는 이 경우 끝에 추가된 딕셔너리를 고려해야 함에 유의하십시오. 포인터 크기가 4바이트인 시스템에서, 딕셔너리가 구조체의 맨 끝에 있음을 나타내려면 <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a>을 <code class="docutils literal notranslate"><span class="pre">-4</span></code>로 설정해야 합니다.</p>
<p>인스턴스의 실제 딕셔너리 오프셋은 다음과 같이 음의 <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a>으로 계산할 수 있습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">dictoffset</span> <span class="o">=</span> <span class="n">tp_basicsize</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">ob_size</span><span class="p">)</span><span class="o">*</span><span class="n">tp_itemsize</span> <span class="o">+</span> <span class="n">tp_dictoffset</span>
<span class="k">if</span> <span class="n">dictoffset</span> <span class="n">is</span> <span class="n">not</span> <span class="n">aligned</span> <span class="n">on</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">:</span>
    <span class="n">round</span> <span class="n">up</span> <span class="n">to</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p>여기서 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a>, <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a> 및 <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a>은 형 객체에서 취하고, <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code>는 인스턴스에서 취합니다. 정수는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code>의 부호를 사용하여 숫자의 부호를 저장하므로 절댓값이 사용됩니다. (이 계산을 직접 수행할 필요는 없습니다; <code class="xref c c-func docutils literal notranslate"><span class="pre">_PyObject_GetDictPtr()</span></code>에서 수행합니다.)</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형에 의해 상속됩니다. 하지만 아래 나열된 규칙을 참조하십시오. 서브 형이 이 오프셋을 재정의할 수 있습니다; 이는 서브 형 인스턴스가 베이스형과는 다른 오프셋에 딕셔너리를 저장함을 뜻합니다. 딕셔너리는 항상 <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a>을 통해 발견되므로, 문제가 되지 않아야 합니다.</p>
<p>클래스 문으로 정의된 형에 <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 선언이 없고, 인스턴스 변수 딕셔너리를 갖는 베이스형이 없을 때, 딕셔너리 슬롯이 인스턴스 배치에 추가되고 <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a>은 해당 슬롯의 오프셋으로 설정됩니다.</p>
<p>클래스 문으로 정의된 형에 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code> 선언이 있으면, 형은 베이스형에서 <a class="reference internal" href="#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a>을 상속합니다.</p>
<p>(<code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code> 선언에 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>라는 슬롯을 추가해도 기대하는 효과는 없고, 단지 혼란을 초래합니다. 그러나 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__weakref__</span></code>처럼 기능으로 추가해야 할 수도 있습니다.)</p>
<p><strong>기본값:</strong></p>
<p>이 슬롯에는 기본값이 없습니다. 정적 형의 경우, 이 필드가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면 인스턴스에 대해 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code>가 만들어지지 않습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_init">
<a class="reference internal" href="#c.initproc" title="initproc">initproc</a> <code class="sig-name descname">PyTypeObject.tp_init</code><a class="headerlink" href="#c.PyTypeObject.tp_init" title="정의 주소">¶</a></dt>
<dd><p>인스턴스 초기화 함수에 대한 선택적 포인터.</p>
<p>이 함수는 클래스의 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드에 해당합니다. <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>와 마찬가지로, <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>를 호출하지 않고 인스턴스를 작성할 수 있으며, <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드를 다시 호출하여 인스턴스를 다시 초기화 할 수 있습니다.</p>
<p>함수 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">tp_init</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">);</span>
</pre></div>
</div>
<p>self 인자는 초기화될 인스턴스입니다; <em>args</em>와 <em>kwds</em> 인자는 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 호출의 위치와 키워드 인자를 나타냅니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아닐 때, <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a> 함수는 형을 호출하여 인스턴스를 정상적으로 만들 때, 형의 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 함수가 형의 인스턴스를 반환한 후 호출됩니다. <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 함수가 원래 형의 서브 형이 아닌 다른 형의 인스턴스를 반환하면, 아무런 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a> 함수도 호출되지 않습니다; <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a>가 원래 형의 서브 형 인스턴스를 반환하면, 서브 형의 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a>가 호출됩니다.</p>
<p>성공하면 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환하고, 에러 시에는 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환하고 예외를 설정합니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형으로 상속됩니다.</p>
<p><strong>기본값:</strong></p>
<p>정적 형의 경우 이 필드에는 기본값이 없습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_alloc">
<a class="reference internal" href="#c.allocfunc" title="allocfunc">allocfunc</a> <code class="sig-name descname">PyTypeObject.tp_alloc</code><a class="headerlink" href="#c.PyTypeObject.tp_alloc" title="정의 주소">¶</a></dt>
<dd><p>인스턴스 할당 함수에 대한 선택적 포인터.</p>
<p>함수 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">tp_alloc</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="n">nitems</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>계승:</strong></p>
<p>이 필드는 정적 서브 형에 의해 상속되지만, 동적 서브 형(클래스 문으로 만들어진 서브 형)에는 상속되지 않습니다.</p>
<p><strong>기본값:</strong></p>
<p>동적 서브 형의 경우, 이 필드는 표준 힙 할당 전략을 강제하기 위해 항상 <a class="reference internal" href="type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericAlloc()</span></code></a>으로 설정됩니다.</p>
<p>정적 서브 형의 경우, <code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code>은 <a class="reference internal" href="type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericAlloc()</span></code></a>을 사용합니다. 이것이 정적으로 정의된 모든 형에 권장되는 값입니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_new">
<a class="reference internal" href="#c.newfunc" title="newfunc">newfunc</a> <code class="sig-name descname">PyTypeObject.tp_new</code><a class="headerlink" href="#c.PyTypeObject.tp_new" title="정의 주소">¶</a></dt>
<dd><p>인스턴스 생성 함수에 대한 선택적 포인터.</p>
<p>함수 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">tp_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">subtype</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">);</span>
</pre></div>
</div>
<p>subtype 인자는 만들어지고 있는 객체의 형입니다; <em>args</em>와 <em>kwds</em> 인자는 형 호출의 위치와 키워드 인자를 나타냅니다. 서브 형은 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 함수가 호출되는 형과 같을 필요는 없음에 유의하십시오; 이 형의 서브 형일 수 있습니다 (하지만 관련이 없는 형은 아닙니다).</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> 함수는 객체에 공간을 할당하기 위해 <code class="docutils literal notranslate"><span class="pre">subtype-&gt;tp_alloc(subtype,</span> <span class="pre">nitems)</span></code>를 호출해야 하고, 그런 다음 꼭 필요한 만큼만 추가 초기화를 수행해야 합니다. 안전하게 무시하거나 반복할 수 있는 초기화는 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a> 처리기에 배치해야 합니다. 간단한 규칙은, 불변 형의 경우 모든 초기화가 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a>에서 수행되어야 하고, 가변형의 경우 대부분 초기화는 <a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a>로 미뤄져야 합니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 <a class="reference internal" href="#c.PyTypeObject.tp_base" title="PyTypeObject.tp_base"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_base</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이나 <code class="docutils literal notranslate"><span class="pre">&amp;PyBaseObject_Type</span></code>인 정적 형에 의해 상속되지 않는 것을 제외하고 서브 형에 의해 상속됩니다.</p>
<p><strong>기본값:</strong></p>
<p>정적 형의 경우 이 필드에는 기본값이 없습니다. 이는 슬롯이 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 정의되었을 때, 새 인스턴스를 만들기 위해 형을 호출할 수 없음을 뜻합니다; 아마도 팩토리 함수와 같은, 인스턴스를 만드는 다른 방법이 있을 것입니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_free">
<a class="reference internal" href="#c.freefunc" title="freefunc">freefunc</a> <code class="sig-name descname">PyTypeObject.tp_free</code><a class="headerlink" href="#c.PyTypeObject.tp_free" title="정의 주소">¶</a></dt>
<dd><p>인스턴스 할당 해제 함수에 대한 선택적 포인터. 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">tp_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>이 서명과 호환되는 초기화자는 <a class="reference internal" href="memory.html#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a>입니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 정적 서브 형에 의해 상속되지만, 동적 서브 형(클래스 문으로 만들어진 서브 형)에는 상속되지 않습니다.</p>
<p><strong>기본값:</strong></p>
<p>동적 서브 형에서, 이 필드는 <a class="reference internal" href="type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericAlloc()</span></code></a>과 <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 플래그 비트의 값과 일치하기에 적합한 할당 해제기로 설정됩니다.</p>
<p>정적 서브 형의 경우, <code class="xref c c-type docutils literal notranslate"><span class="pre">PyBaseObject_Type</span></code>은 PyObject_Del을 사용합니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_is_gc">
<a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry">inquiry</a> <code class="sig-name descname">PyTypeObject.tp_is_gc</code><a class="headerlink" href="#c.PyTypeObject.tp_is_gc" title="정의 주소">¶</a></dt>
<dd><p>가비지 수집기에서 호출되는 함수에 대한 선택적 포인터.</p>
<p>가비지 수집기는 특정 객체가 수집 가능한지를 알아야 합니다. 일반적으로, 객체 형의 <a class="reference internal" href="#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_flags</span></code></a> 필드를 보고, <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> 플래그 비트를 확인하면 충분합니다. 그러나 일부 형에는 정적과 동적으로 할당된 인스턴스가 혼합되어 있으며, 정적으로 할당된 인스턴스는 수집할 수 없습니다. 이러한 형은 이 함수를 정의해야 합니다; 수집 가능한 인스턴스이면 <code class="docutils literal notranslate"><span class="pre">1</span></code>을, 수집 불가능한 인스턴스이면 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환해야 합니다. 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">tp_is_gc</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>(이것의 유일한 예는 형 자체입니다. 메타 형, <a class="reference internal" href="type.html#c.PyType_Type" title="PyType_Type"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyType_Type</span></code></a>은 이 함수를 정의하여 정적으로 할당된 형과 동적으로 할당된 형을 구별합니다.)</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형으로 상속됩니다.</p>
<p><strong>기본값:</strong></p>
<p>이 슬롯에는 기본값이 없습니다. 이 필드가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, <a class="reference internal" href="#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a>가 기능적 동등물로 사용됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_bases">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyTypeObject.tp_bases</code><a class="headerlink" href="#c.PyTypeObject.tp_bases" title="정의 주소">¶</a></dt>
<dd><p>베이스형의 튜플.</p>
<p>이것은 클래스 문으로 만들어진 형에 대해 설정됩니다. 정적으로 정의된 형의 경우 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이어야 합니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 상속되지 않습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_mro">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyTypeObject.tp_mro</code><a class="headerlink" href="#c.PyTypeObject.tp_mro" title="정의 주소">¶</a></dt>
<dd><p>형 자체에서 시작하여 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>로 끝나는 확장된 베이스형 집합을 포함하는 튜플.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 상속되지 않습니다; <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a>에 의해 새로 계산됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_cache">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyTypeObject.tp_cache</code><a class="headerlink" href="#c.PyTypeObject.tp_cache" title="정의 주소">¶</a></dt>
<dd><p>사용되지 않습니다. 내부 전용.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 상속되지 않습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_subclasses">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyTypeObject.tp_subclasses</code><a class="headerlink" href="#c.PyTypeObject.tp_subclasses" title="정의 주소">¶</a></dt>
<dd><p>서브 클래스에 대한 약한 참조 리스트. 내부 전용.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 상속되지 않습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_weaklist">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyTypeObject.tp_weaklist</code><a class="headerlink" href="#c.PyTypeObject.tp_weaklist" title="정의 주소">¶</a></dt>
<dd><p>이 형 객체에 대한 약한 참조를 위한 약한 참조 리스트 헤드. 상속되지 않습니다. 내부 전용.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 상속되지 않습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_del">
<a class="reference internal" href="#c.destructor" title="destructor">destructor</a> <code class="sig-name descname">PyTypeObject.tp_del</code><a class="headerlink" href="#c.PyTypeObject.tp_del" title="정의 주소">¶</a></dt>
<dd><p>이 필드는 폐지되었습니다. 대신 <a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a>를 사용하십시오.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_version_tag">
unsigned int <code class="sig-name descname">PyTypeObject.tp_version_tag</code><a class="headerlink" href="#c.PyTypeObject.tp_version_tag" title="정의 주소">¶</a></dt>
<dd><p>메서드 캐시에 인덱싱하는 데 사용됩니다. 내부 전용.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 상속되지 않습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_finalize">
<a class="reference internal" href="#c.destructor" title="destructor">destructor</a> <code class="sig-name descname">PyTypeObject.tp_finalize</code><a class="headerlink" href="#c.PyTypeObject.tp_finalize" title="정의 주소">¶</a></dt>
<dd><p>인스턴스 파이널리제이션 함수에 대한 선택적 포인터. 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">tp_finalize</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a>가 설정되면, 인터프리터는 인스턴스를 파이널라이즈 할 때 이를 한 번 호출합니다. 가비지 수집기(인스턴스가 격리된 참조 순환의 일부인 경우)나 객체가 할당 해제되기 직전에 호출됩니다. 어느 쪽이든, 참조 순환을 끊기 전에 호출되어 정상 상태에 있는 객체를 보도록 보장합니다.</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_finalize" title="PyTypeObject.tp_finalize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_finalize</span></code></a>는 현재 예외 상태를 변경하지 않아야 합니다; 따라서 사소하지 않은 파이널라이저를 작성하는 권장 방법은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">local_finalize</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">error_type</span><span class="p">,</span> <span class="o">*</span><span class="n">error_value</span><span class="p">,</span> <span class="o">*</span><span class="n">error_traceback</span><span class="p">;</span>

    <span class="cm">/* 있다면, 현재 예외를 저장합니다. */</span>
    <span class="n">PyErr_Fetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">error_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error_value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error_traceback</span><span class="p">);</span>

    <span class="cm">/* ... */</span>

    <span class="cm">/* 저장된 예외를 복원합니다. */</span>
    <span class="n">PyErr_Restore</span><span class="p">(</span><span class="n">error_type</span><span class="p">,</span> <span class="n">error_value</span><span class="p">,</span> <span class="n">error_traceback</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(상속을 통해서도) 이 필드를 고려하려면, <a class="reference internal" href="#Py_TPFLAGS_HAVE_FINALIZE" title="Py_TPFLAGS_HAVE_FINALIZE"><code class="xref py py-const docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_FINALIZE</span></code></a> 플래그 비트도 설정해야 합니다.</p>
<p><strong>계승:</strong></p>
<p>이 필드는 서브 형으로 상속됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>&quot;안전한 객체 파이널리제이션&quot; (<span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0442"><strong>PEP 442</strong></a>)</p>
</div>
</dd></dl>

<p>나머지 필드는 기능 테스트 매크로 <code class="xref py py-const docutils literal notranslate"><span class="pre">COUNT_ALLOCS</span></code>가 정의된 경우에만 정의되며, 내부 전용입니다. 그것들은 완전성을 위해 여기에서 설명합니다. 이러한 필드는 서브 형에 의해 상속되지 않습니다.</p>
<dl class="member">
<dt id="c.PyTypeObject.tp_allocs">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_allocs</code><a class="headerlink" href="#c.PyTypeObject.tp_allocs" title="정의 주소">¶</a></dt>
<dd><p>할당 수.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_frees">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_frees</code><a class="headerlink" href="#c.PyTypeObject.tp_frees" title="정의 주소">¶</a></dt>
<dd><p>할당 해제 수.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_maxalloc">
Py_ssize_t <code class="sig-name descname">PyTypeObject.tp_maxalloc</code><a class="headerlink" href="#c.PyTypeObject.tp_maxalloc" title="정의 주소">¶</a></dt>
<dd><p>동시에 할당된 최대 객체 수.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_prev">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a>* <code class="sig-name descname">PyTypeObject.tp_prev</code><a class="headerlink" href="#c.PyTypeObject.tp_prev" title="정의 주소">¶</a></dt>
<dd><p>0이 아닌 <a class="reference internal" href="#c.PyTypeObject.tp_allocs" title="PyTypeObject.tp_allocs"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_allocs</span></code></a> 필드를 가진 이전 형 객체를 가리키는 포인터.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyTypeObject.tp_next">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a>* <code class="sig-name descname">PyTypeObject.tp_next</code><a class="headerlink" href="#c.PyTypeObject.tp_next" title="정의 주소">¶</a></dt>
<dd><p>0이 아닌 <a class="reference internal" href="#c.PyTypeObject.tp_allocs" title="PyTypeObject.tp_allocs"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_allocs</span></code></a> 필드를 가진 다음 형 객체를 가리키는 포인터.</p>
</dd></dl>

<p>또한, 가비지 수집된 파이썬에서, <a class="reference internal" href="#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dealloc</span></code></a>은 객체를 만든 스레드뿐만 아니라, 모든 파이썬 스레드에서 호출될 수 있습니다 (객체가 참조 횟수 순환의 일부가 되면, 해당 순환은 모든 스레드에서의 가비지 수집으로 수집될 수 있습니다). tp_dealloc이 호출되는 스레드는 GIL(전역 인터프리터 록 - Global Interpreter Lock)을 소유하므로, 파이썬 API 호출에는 문제가 되지 않습니다. 그러나, 파괴되는 중인 객체가 다른 C나 C++ 라이브러리의 객체를 파괴하면, tp_dealloc을 호출한 스레드에서 그 객체를 파괴해도 라이브러리의 가정을 위반하지 않는지 주의해야 합니다.</p>
</div>
<div class="section" id="heap-types">
<span id="id4"></span><h2>힙 형<a class="headerlink" href="#heap-types" title="제목 주소">¶</a></h2>
<p>전통적으로, C 코드에서 정의된 형은 <em>정적(static)</em>입니다. 즉 정적 <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> 구조체는 코드에서 직접 정의되고 <a class="reference internal" href="type.html#c.PyType_Ready" title="PyType_Ready"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready()</span></code></a>를 사용하여 초기화됩니다.</p>
<p>결과적으로 파이썬에서 정의된 형에 비해 형이 제한됩니다:</p>
<ul class="simple">
<li><p>정적 형은 하나의 베이스로 제한됩니다. 즉, 다중 상속을 사용할 수 없습니다.</p></li>
<li><p>정적 형 객체(그러나 이들의 인스턴스는 아닙니다)는 불변입니다. 파이썬에서 형 객체의 어트리뷰트를 추가하거나 수정할 수 없습니다.</p></li>
<li><p>정적 형 객체는 <a class="reference internal" href="init.html#sub-interpreter-support"><span class="std std-ref">서브 인터프리터</span></a>에서 공유되므로, 서브 인터프리터 관련 상태를 포함하지 않아야 합니다.</p></li>
</ul>
<p>또한, <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a>는 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">안정 ABI</span></a>의 일부가 아니므로, 정적 형을 사용하는 확장 모듈은 특정 파이썬 부 버전(minir version)에 맞게 컴파일해야 합니다.</p>
<p>정적 형에 대한 대안은 <em>힙 할당된 형(heap-allocated types)</em>, 또는 짧게 <em>힙 형(heap types)</em>, 인데 이는 파이썬의 <code class="docutils literal notranslate"><span class="pre">class</span></code> 문으로 작성된 클래스와 밀접한 관련이 있습니다.</p>
<p><a class="reference internal" href="type.html#c.PyType_Spec" title="PyType_Spec"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyType_Spec</span></code></a> 구조체를 채우고 <a class="reference internal" href="type.html#c.PyType_FromSpecWithBases" title="PyType_FromSpecWithBases"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromSpecWithBases()</span></code></a>를 호출하면 됩니다.</p>
</div>
</div>
<div class="section" id="number-object-structures">
<span id="number-structs"></span><h1>숫자 객체 구조체<a class="headerlink" href="#number-object-structures" title="제목 주소">¶</a></h1>
<dl class="type">
<dt id="c.PyNumberMethods">
<code class="sig-name descname">PyNumberMethods</code><a class="headerlink" href="#c.PyNumberMethods" title="정의 주소">¶</a></dt>
<dd><p>이 구조체는 객체가 숫자 프로토콜을 구현하는 데 사용하는 함수에 대한 포인터를 담습니다. 각 함수는 <a class="reference internal" href="number.html#number"><span class="std std-ref">숫자 프로토콜</span></a> 섹션에서 설명하는 유사한 이름의 함수가 사용합니다.</p>
<p>구조체 정의는 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
     <span class="n">binaryfunc</span> <span class="n">nb_add</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_subtract</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_multiply</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_remainder</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_divmod</span><span class="p">;</span>
     <span class="n">ternaryfunc</span> <span class="n">nb_power</span><span class="p">;</span>
     <span class="n">unaryfunc</span> <span class="n">nb_negative</span><span class="p">;</span>
     <span class="n">unaryfunc</span> <span class="n">nb_positive</span><span class="p">;</span>
     <span class="n">unaryfunc</span> <span class="n">nb_absolute</span><span class="p">;</span>
     <span class="n">inquiry</span> <span class="n">nb_bool</span><span class="p">;</span>
     <span class="n">unaryfunc</span> <span class="n">nb_invert</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_lshift</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_rshift</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_and</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_xor</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_or</span><span class="p">;</span>
     <span class="n">unaryfunc</span> <span class="n">nb_int</span><span class="p">;</span>
     <span class="kt">void</span> <span class="o">*</span><span class="n">nb_reserved</span><span class="p">;</span>
     <span class="n">unaryfunc</span> <span class="n">nb_float</span><span class="p">;</span>

     <span class="n">binaryfunc</span> <span class="n">nb_inplace_add</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_subtract</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_multiply</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_remainder</span><span class="p">;</span>
     <span class="n">ternaryfunc</span> <span class="n">nb_inplace_power</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_lshift</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_rshift</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_and</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_xor</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_or</span><span class="p">;</span>

     <span class="n">binaryfunc</span> <span class="n">nb_floor_divide</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_true_divide</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_floor_divide</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_true_divide</span><span class="p">;</span>

     <span class="n">unaryfunc</span> <span class="n">nb_index</span><span class="p">;</span>

     <span class="n">binaryfunc</span> <span class="n">nb_matrix_multiply</span><span class="p">;</span>
     <span class="n">binaryfunc</span> <span class="n">nb_inplace_matrix_multiply</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyNumberMethods</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이항과 삼항 함수는 모든 피연산자의 형을 확인하고, 필요한 변환을 구현해야합니다 (적어도 피연산자 중 하나는 정의된 형의 인스턴스입니다). 주어진 피연산자에 대해 연산이 정의되지 않으면, 이항과 삼항 함수는 <code class="docutils literal notranslate"><span class="pre">Py_NotImplemented</span></code>를 반환해야하며, 다른 에러가 발생하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환하고 예외를 설정해야 합니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><code class="xref c c-data docutils literal notranslate"><span class="pre">nb_reserved</span></code> 필드는 항상 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이어야 합니다. 이전에는 <code class="xref c c-data docutils literal notranslate"><span class="pre">nb_long</span></code>라고 했으며, 파이썬 3.0.1에서 이름이 바뀌었습니다.</p>
</div>
</dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_add">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_add</code><a class="headerlink" href="#c.PyNumberMethods.nb_add" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_subtract">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_subtract</code><a class="headerlink" href="#c.PyNumberMethods.nb_subtract" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_multiply">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_multiply</code><a class="headerlink" href="#c.PyNumberMethods.nb_multiply" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_remainder">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_remainder</code><a class="headerlink" href="#c.PyNumberMethods.nb_remainder" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_divmod">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_divmod</code><a class="headerlink" href="#c.PyNumberMethods.nb_divmod" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_power">
<a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc">ternaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_power</code><a class="headerlink" href="#c.PyNumberMethods.nb_power" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_negative">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_negative</code><a class="headerlink" href="#c.PyNumberMethods.nb_negative" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_positive">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_positive</code><a class="headerlink" href="#c.PyNumberMethods.nb_positive" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_absolute">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_absolute</code><a class="headerlink" href="#c.PyNumberMethods.nb_absolute" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_bool">
<a class="reference internal" href="gcsupport.html#c.inquiry" title="inquiry">inquiry</a> <code class="sig-name descname">PyNumberMethods.nb_bool</code><a class="headerlink" href="#c.PyNumberMethods.nb_bool" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_invert">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_invert</code><a class="headerlink" href="#c.PyNumberMethods.nb_invert" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_lshift">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_lshift</code><a class="headerlink" href="#c.PyNumberMethods.nb_lshift" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_rshift">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_rshift</code><a class="headerlink" href="#c.PyNumberMethods.nb_rshift" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_and">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_and</code><a class="headerlink" href="#c.PyNumberMethods.nb_and" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_xor">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_xor</code><a class="headerlink" href="#c.PyNumberMethods.nb_xor" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_or">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_or</code><a class="headerlink" href="#c.PyNumberMethods.nb_or" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_int">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_int</code><a class="headerlink" href="#c.PyNumberMethods.nb_int" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_reserved">
void *<code class="sig-name descname">PyNumberMethods.nb_reserved</code><a class="headerlink" href="#c.PyNumberMethods.nb_reserved" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_float">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_float</code><a class="headerlink" href="#c.PyNumberMethods.nb_float" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_add">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_add</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_add" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_subtract">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_subtract</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_subtract" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_multiply">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_multiply</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_multiply" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_remainder">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_remainder</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_remainder" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_power">
<a class="reference internal" href="#c.ternaryfunc" title="ternaryfunc">ternaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_power</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_power" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_lshift">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_lshift</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_lshift" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_rshift">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_rshift</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_rshift" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_and">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_and</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_and" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_xor">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_xor</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_xor" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_or">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_or</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_or" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_floor_divide">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_floor_divide</code><a class="headerlink" href="#c.PyNumberMethods.nb_floor_divide" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_true_divide">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_true_divide</code><a class="headerlink" href="#c.PyNumberMethods.nb_true_divide" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_floor_divide">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_floor_divide</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_floor_divide" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_true_divide">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_true_divide</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_true_divide" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_index">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_index</code><a class="headerlink" href="#c.PyNumberMethods.nb_index" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_matrix_multiply">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_matrix_multiply</code><a class="headerlink" href="#c.PyNumberMethods.nb_matrix_multiply" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="member">
<dt id="c.PyNumberMethods.nb_inplace_matrix_multiply">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyNumberMethods.nb_inplace_matrix_multiply</code><a class="headerlink" href="#c.PyNumberMethods.nb_inplace_matrix_multiply" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="mapping-object-structures">
<span id="mapping-structs"></span><h1>매핑 객체 구조체<a class="headerlink" href="#mapping-object-structures" title="제목 주소">¶</a></h1>
<dl class="type">
<dt id="c.PyMappingMethods">
<code class="sig-name descname">PyMappingMethods</code><a class="headerlink" href="#c.PyMappingMethods" title="정의 주소">¶</a></dt>
<dd><p>이 구조체에는 객체가 매핑 프로토콜을 구현하는 데 사용하는 함수에 대한 포인터를 담습니다. 세 개의 멤버가 있습니다:</p>
</dd></dl>

<dl class="member">
<dt id="c.PyMappingMethods.mp_length">
<a class="reference internal" href="#c.lenfunc" title="lenfunc">lenfunc</a> <code class="sig-name descname">PyMappingMethods.mp_length</code><a class="headerlink" href="#c.PyMappingMethods.mp_length" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="mapping.html#c.PyMapping_Size" title="PyMapping_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMapping_Size()</span></code></a>와 <a class="reference internal" href="object.html#c.PyObject_Size" title="PyObject_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Size()</span></code></a>에서 사용되며, 같은 서명을 갖습니다. 객체에 길이가 정의되어 있지 않으면 이 슬롯을 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정할 수 있습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyMappingMethods.mp_subscript">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PyMappingMethods.mp_subscript</code><a class="headerlink" href="#c.PyMappingMethods.mp_subscript" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="object.html#c.PyObject_GetItem" title="PyObject_GetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetItem()</span></code></a>과 <a class="reference internal" href="sequence.html#c.PySequence_GetSlice" title="PySequence_GetSlice"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_GetSlice()</span></code></a>에서 사용되며, <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetItem()</span></code>과 같은 서명을 갖습니다. <a class="reference internal" href="mapping.html#c.PyMapping_Check" title="PyMapping_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMapping_Check()</span></code></a> 함수가 <code class="docutils literal notranslate"><span class="pre">1</span></code>을 반환하려면, 이 슬롯을 채워야합니다, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 수 있습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyMappingMethods.mp_ass_subscript">
<a class="reference internal" href="#c.objobjargproc" title="objobjargproc">objobjargproc</a> <code class="sig-name descname">PyMappingMethods.mp_ass_subscript</code><a class="headerlink" href="#c.PyMappingMethods.mp_ass_subscript" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="object.html#c.PyObject_SetItem" title="PyObject_SetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetItem()</span></code></a>, <a class="reference internal" href="object.html#c.PyObject_DelItem" title="PyObject_DelItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_DelItem()</span></code></a>, <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetSlice()</span></code> 및 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_DelSlice()</span></code>에서 사용됩니다. <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetItem()</span></code>과 같은 서명을 갖지만, <em>v</em>를 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정하여 항목을 삭제할 수도 있습니다. 이 슬롯이 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, 객체는 항목 대입과 삭제를 지원하지 않습니다.</p>
</dd></dl>

</div>
<div class="section" id="sequence-object-structures">
<span id="sequence-structs"></span><h1>시퀀스 객체 구조체<a class="headerlink" href="#sequence-object-structures" title="제목 주소">¶</a></h1>
<dl class="type">
<dt id="c.PySequenceMethods">
<code class="sig-name descname">PySequenceMethods</code><a class="headerlink" href="#c.PySequenceMethods" title="정의 주소">¶</a></dt>
<dd><p>이 구조체는 객체가 시퀀스 프로토콜을 구현하는 데 사용하는 함수에 대한 포인터를 담습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_length">
<a class="reference internal" href="#c.lenfunc" title="lenfunc">lenfunc</a> <code class="sig-name descname">PySequenceMethods.sq_length</code><a class="headerlink" href="#c.PySequenceMethods.sq_length" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="sequence.html#c.PySequence_Size" title="PySequence_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Size()</span></code></a>와 <a class="reference internal" href="object.html#c.PyObject_Size" title="PyObject_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Size()</span></code></a>에서 사용되며, 같은 서명을 갖습니다. 또한 <a class="reference internal" href="#c.PySequenceMethods.sq_item" title="PySequenceMethods.sq_item"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_item</span></code></a>과 <a class="reference internal" href="#c.PySequenceMethods.sq_ass_item" title="PySequenceMethods.sq_ass_item"><code class="xref c c-member docutils literal notranslate"><span class="pre">sq_ass_item</span></code></a> 슬롯을 통해 음수 인덱스를 처리하는 데 사용됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_concat">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PySequenceMethods.sq_concat</code><a class="headerlink" href="#c.PySequenceMethods.sq_concat" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="sequence.html#c.PySequence_Concat" title="PySequence_Concat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Concat()</span></code></a>에서 사용되며 같은 서명을 갖습니다. <a class="reference internal" href="#c.PyNumberMethods.nb_add" title="PyNumberMethods.nb_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_add</span></code></a> 슬롯을 통해 숫자 덧셈을 시도한 후, <code class="docutils literal notranslate"><span class="pre">+</span></code> 연산자에서도 사용됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_repeat">
<a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc">ssizeargfunc</a> <code class="sig-name descname">PySequenceMethods.sq_repeat</code><a class="headerlink" href="#c.PySequenceMethods.sq_repeat" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="sequence.html#c.PySequence_Repeat" title="PySequence_Repeat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Repeat()</span></code></a>에서 사용되며 같은 서명을 갖습니다. <a class="reference internal" href="#c.PyNumberMethods.nb_multiply" title="PyNumberMethods.nb_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_multiply</span></code></a> 슬롯을 통해 숫자 곱셈을 시도한 후, <code class="docutils literal notranslate"><span class="pre">*</span></code> 연산자에서도 사용됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_item">
<a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc">ssizeargfunc</a> <code class="sig-name descname">PySequenceMethods.sq_item</code><a class="headerlink" href="#c.PySequenceMethods.sq_item" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="sequence.html#c.PySequence_GetItem" title="PySequence_GetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_GetItem()</span></code></a>에서 사용되며 같은 서명을 갖습니다. <a class="reference internal" href="#c.PyMappingMethods.mp_subscript" title="PyMappingMethods.mp_subscript"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_subscript</span></code></a> 슬롯을 통해 서브스크립션(subscription)을 시도한 후, <a class="reference internal" href="object.html#c.PyObject_GetItem" title="PyObject_GetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetItem()</span></code></a>에서도 사용됩니다. <a class="reference internal" href="sequence.html#c.PySequence_Check" title="PySequence_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Check()</span></code></a> 함수가 <code class="docutils literal notranslate"><span class="pre">1</span></code>을 반환하려면, 이 슬롯을 채워야합니다, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 수 있습니다.</p>
<p>음의 인덱스는 다음과 같이 처리됩니다: <code class="xref py py-attr docutils literal notranslate"><span class="pre">sq_length</span></code> 슬롯이 채워지면, 이를 호출하고 시퀀스 길이를 사용하여 <code class="xref py py-attr docutils literal notranslate"><span class="pre">sq_item</span></code>에 전달되는 양의 인덱스를 계산합니다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">sq_length</span></code>가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면, 인덱스는 그대로 함수에 전달됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_ass_item">
<a class="reference internal" href="#c.ssizeobjargproc" title="ssizeobjargproc">ssizeobjargproc</a> <code class="sig-name descname">PySequenceMethods.sq_ass_item</code><a class="headerlink" href="#c.PySequenceMethods.sq_ass_item" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="sequence.html#c.PySequence_SetItem" title="PySequence_SetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_SetItem()</span></code></a>에서 사용되며 같은 서명을 갖습니다. <a class="reference internal" href="#c.PyMappingMethods.mp_ass_subscript" title="PyMappingMethods.mp_ass_subscript"><code class="xref c c-member docutils literal notranslate"><span class="pre">mp_ass_subscript</span></code></a> 슬롯을 통해 항목 대입과 삭제를 시도한 후, <a class="reference internal" href="object.html#c.PyObject_SetItem" title="PyObject_SetItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetItem()</span></code></a>과 <a class="reference internal" href="object.html#c.PyObject_DelItem" title="PyObject_DelItem"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_DelItem()</span></code></a>에서도 사용됩니다. 객체가 항목 대입과 삭제를 지원하지 않으면 이 슬롯은 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 남겨 둘 수 있습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_contains">
<a class="reference internal" href="#c.objobjproc" title="objobjproc">objobjproc</a> <code class="sig-name descname">PySequenceMethods.sq_contains</code><a class="headerlink" href="#c.PySequenceMethods.sq_contains" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="sequence.html#c.PySequence_Contains" title="PySequence_Contains"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Contains()</span></code></a>에서 사용될 수 있으며 같은 서명을 갖습니다. 이 슬롯은 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 남겨 둘 수 있습니다, 이때 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Contains()</span></code>는 일치하는 것을 찾을 때까지 시퀀스를 단순히 탐색합니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_inplace_concat">
<a class="reference internal" href="#c.binaryfunc" title="binaryfunc">binaryfunc</a> <code class="sig-name descname">PySequenceMethods.sq_inplace_concat</code><a class="headerlink" href="#c.PySequenceMethods.sq_inplace_concat" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="sequence.html#c.PySequence_InPlaceConcat" title="PySequence_InPlaceConcat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_InPlaceConcat()</span></code></a>에서 사용되며 같은 서명을 갖습니다. 첫 번째 피연산자를 수정하고 그것을 반환해야 합니다. 이 슬롯은 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 남겨 둘 수 있으며, 이때 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_InPlaceConcat()</span></code>은 <a class="reference internal" href="sequence.html#c.PySequence_Concat" title="PySequence_Concat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Concat()</span></code></a>으로 폴백 됩니다. <a class="reference internal" href="#c.PyNumberMethods.nb_inplace_add" title="PyNumberMethods.nb_inplace_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_add</span></code></a> 슬롯을 통해 숫자 제자리 덧셈을 시도한 후, 증분 대입 <code class="docutils literal notranslate"><span class="pre">+=</span></code>에서 사용됩니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PySequenceMethods.sq_inplace_repeat">
<a class="reference internal" href="#c.ssizeargfunc" title="ssizeargfunc">ssizeargfunc</a> <code class="sig-name descname">PySequenceMethods.sq_inplace_repeat</code><a class="headerlink" href="#c.PySequenceMethods.sq_inplace_repeat" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="sequence.html#c.PySequence_InPlaceRepeat" title="PySequence_InPlaceRepeat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_InPlaceRepeat()</span></code></a>에서 사용되며 같은 서명을 갖습니다. 첫 번째 피연산자를 수정하고 그것을 반환해야 합니다. 이 슬롯은 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 남겨 둘 수 있으며, 이때 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_InPlaceRepeat()</span></code>는 <a class="reference internal" href="sequence.html#c.PySequence_Repeat" title="PySequence_Repeat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySequence_Repeat()</span></code></a>로 폴백 됩니다. <a class="reference internal" href="#c.PyNumberMethods.nb_inplace_multiply" title="PyNumberMethods.nb_inplace_multiply"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_inplace_multiply</span></code></a> 슬롯을 통해 숫자 제자리 곱셈을 시도한 후, 증분 대입 <code class="docutils literal notranslate"><span class="pre">*=</span></code>에서도 사용됩니다.</p>
</dd></dl>

</div>
<div class="section" id="buffer-object-structures">
<span id="buffer-structs"></span><h1>버퍼 객체 구조체<a class="headerlink" href="#buffer-object-structures" title="제목 주소">¶</a></h1>
<dl class="type">
<dt id="c.PyBufferProcs">
<code class="sig-name descname">PyBufferProcs</code><a class="headerlink" href="#c.PyBufferProcs" title="정의 주소">¶</a></dt>
<dd><p>이 구조체는 <a class="reference internal" href="buffer.html#bufferobjects"><span class="std std-ref">버퍼 프로토콜</span></a>에 필요한 함수에 대한 포인터를 담습니다. 프로토콜은 제공자(exporter) 객체가 내부 데이터를 소비자 객체에 노출하는 방법을 정의합니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyBufferProcs.bf_getbuffer">
<a class="reference internal" href="#c.getbufferproc" title="getbufferproc">getbufferproc</a> <code class="sig-name descname">PyBufferProcs.bf_getbuffer</code><a class="headerlink" href="#c.PyBufferProcs.bf_getbuffer" title="정의 주소">¶</a></dt>
<dd><p>이 함수의 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">exporter</span><span class="p">,</span> <span class="n">Py_buffer</span> <span class="o">*</span><span class="n">view</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</pre></div>
</div>
<p><em>view</em>를 채우기 위해 <em>exporter</em>에 대한 <em>flags</em>에 지정된 요청을 처리합니다. 포인트 (3) 을 제외하고, 이 함수의 구현은 다음 단계를 반드시 수행해야 합니다:</p>
<ol class="arabic simple">
<li><p>요청을 충족할 수 있는지 확인합니다. 그렇지 않으면, <code class="xref c c-data docutils literal notranslate"><span class="pre">PyExc_BufferError</span></code>를 발생시키고 <code class="xref c c-data docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>를 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정하고 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다.</p></li>
<li><p>요청된 필드를 채웁니다.</p></li>
<li><p>내보내기 횟수에 대한 내부 카운터를 증가시킵니다.</p></li>
<li><p><code class="xref c c-data docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>를 <em>exporter</em>로 설정하고 <code class="xref c c-data docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>를 증가시킵니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다.</p></li>
</ol>
<p><em>exporter</em>가 버퍼 공급자의 체인이나 트리의 일부이면, 두 가지 주요 체계를 사용할 수 있습니다:</p>
<ul class="simple">
<li><p>다시 내보내기: 트리의 각 구성원은 제공자 객체의 역할을 하며 <code class="xref c c-data docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>를 자신에 대한 새로운 참조로 설정합니다.</p></li>
<li><p>리디렉션: 버퍼 요청이 트리의 루트 객체로 리디렉션됩니다. 여기서, <code class="xref c c-data docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>는 루트 객체에 대한 새로운 참조가 됩니다.</p></li>
</ul>
<p><em>view</em>의 개별 필드는 섹션 <a class="reference internal" href="buffer.html#buffer-structure"><span class="std std-ref">버퍼 구조체</span></a>에 설명되어 있으며, 제공자가 특정 요청에 응답해야 하는 규칙은 섹션 <a class="reference internal" href="buffer.html#buffer-request-types"><span class="std std-ref">버퍼 요청 유형</span></a>에 있습니다.</p>
<p><a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_buffer</span></code></a> 구조체에서 가리키는 모든 메모리는 제공자에게 속하며 남은 소비자가 없어질 때까지 유효해야 합니다. <a class="reference internal" href="buffer.html#c.Py_buffer.format" title="Py_buffer.format"><code class="xref c c-member docutils literal notranslate"><span class="pre">format</span></code></a>, <a class="reference internal" href="buffer.html#c.Py_buffer.shape" title="Py_buffer.shape"><code class="xref c c-member docutils literal notranslate"><span class="pre">shape</span></code></a>, <a class="reference internal" href="buffer.html#c.Py_buffer.strides" title="Py_buffer.strides"><code class="xref c c-member docutils literal notranslate"><span class="pre">strides</span></code></a>, <a class="reference internal" href="buffer.html#c.Py_buffer.suboffsets" title="Py_buffer.suboffsets"><code class="xref c c-member docutils literal notranslate"><span class="pre">suboffsets</span></code></a> 및 <a class="reference internal" href="buffer.html#c.Py_buffer.internal" title="Py_buffer.internal"><code class="xref c c-member docutils literal notranslate"><span class="pre">internal</span></code></a>은 소비자에게는 읽기 전용입니다.</p>
<p><a class="reference internal" href="buffer.html#c.PyBuffer_FillInfo" title="PyBuffer_FillInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_FillInfo()</span></code></a>는 모든 요청 유형을 올바르게 처리하면서 간단한 바이트열 버퍼를 쉽게 노출 할 수 있는 방법을 제공합니다.</p>
<p><a class="reference internal" href="buffer.html#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a>는 이 함수를 감싸는 소비자 용 인터페이스입니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyBufferProcs.bf_releasebuffer">
<a class="reference internal" href="#c.releasebufferproc" title="releasebufferproc">releasebufferproc</a> <code class="sig-name descname">PyBufferProcs.bf_releasebuffer</code><a class="headerlink" href="#c.PyBufferProcs.bf_releasebuffer" title="정의 주소">¶</a></dt>
<dd><p>이 함수의 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">exporter</span><span class="p">,</span> <span class="n">Py_buffer</span> <span class="o">*</span><span class="n">view</span><span class="p">);</span>
</pre></div>
</div>
<p>버퍼 자원 해제 요청을 처리합니다. 자원을 해제할 필요가 없으면, <a class="reference internal" href="#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyBufferProcs.bf_releasebuffer</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 수 있습니다. 그렇지 않으면, 이 함수의 표준 구현은 다음과 같은 선택적 단계를 수행합니다:</p>
<ol class="arabic simple">
<li><p>내보내기 횟수에 대한 내부 카운터를 줄입니다.</p></li>
<li><p>카운터가 <code class="docutils literal notranslate"><span class="pre">0</span></code>이면, <em>view</em>와 관련된 모든 메모리를 해제합니다.</p></li>
</ol>
<p>제공자는 반드시 <a class="reference internal" href="buffer.html#c.Py_buffer.internal" title="Py_buffer.internal"><code class="xref c c-member docutils literal notranslate"><span class="pre">internal</span></code></a> 필드를 사용하여 버퍼 특정 자원을 추적해야 합니다. 이 필드는 변경되지 않고 유지됨이 보장되지만, 소비자는 원래 버퍼의 사본을 <em>view</em> 인자로 전달할 수 있습니다.</p>
<p>이 함수는 <a class="reference internal" href="buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>에서 자동으로 수행되므로 <code class="xref c c-data docutils literal notranslate"><span class="pre">view-&gt;obj</span></code>를 절대 감소시키지 않아야 합니다 (이 체계는 참조 순환을 끊는 데 유용합니다).</p>
<p><a class="reference internal" href="buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>는 이 기능을 감싸는 소비자 용 인터페이스입니다.</p>
</dd></dl>

</div>
<div class="section" id="async-object-structures">
<span id="async-structs"></span><h1>비동기 객체 구조체<a class="headerlink" href="#async-object-structures" title="제목 주소">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<dl class="type">
<dt id="c.PyAsyncMethods">
<code class="sig-name descname">PyAsyncMethods</code><a class="headerlink" href="#c.PyAsyncMethods" title="정의 주소">¶</a></dt>
<dd><p>이 구조체는 <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a>와 <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">비동기 이터레이터</span></a> 객체를 구현하는 데 필요한 함수에 대한 포인터를 담습니다.</p>
<p>구조체 정의는 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">unaryfunc</span> <span class="n">am_await</span><span class="p">;</span>
    <span class="n">unaryfunc</span> <span class="n">am_aiter</span><span class="p">;</span>
    <span class="n">unaryfunc</span> <span class="n">am_anext</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyAsyncMethods</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="member">
<dt id="c.PyAsyncMethods.am_await">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyAsyncMethods.am_await</code><a class="headerlink" href="#c.PyAsyncMethods.am_await" title="정의 주소">¶</a></dt>
<dd><p>이 함수의 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">am_await</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p>반환된 객체는 이터레이터여야 합니다, 즉, <a class="reference internal" href="iter.html#c.PyIter_Check" title="PyIter_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyIter_Check()</span></code></a>는 반환된 객체에 대해 <code class="docutils literal notranslate"><span class="pre">1</span></code>을 반환해야 합니다.</p>
<p>객체가 <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a>이 아니면 이 슬롯을 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정할 수 있습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyAsyncMethods.am_aiter">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyAsyncMethods.am_aiter</code><a class="headerlink" href="#c.PyAsyncMethods.am_aiter" title="정의 주소">¶</a></dt>
<dd><p>이 함수의 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">am_aiter</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 객체를 반환해야 합니다. 자세한 내용은 <a class="reference internal" href="../reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>를 참조하십시오.</p>
<p>객체가 비동기 이터레이션 프로토콜을 구현하지 않으면 이 슬롯은 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정될 수 있습니다.</p>
</dd></dl>

<dl class="member">
<dt id="c.PyAsyncMethods.am_anext">
<a class="reference internal" href="#c.unaryfunc" title="unaryfunc">unaryfunc</a> <code class="sig-name descname">PyAsyncMethods.am_anext</code><a class="headerlink" href="#c.PyAsyncMethods.am_anext" title="정의 주소">¶</a></dt>
<dd><p>이 함수의 서명은 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">am_anext</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 객체를 반환해야 합니다. 자세한 내용은 <a class="reference internal" href="../reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>를 참조하십시오. 이 슬롯은 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정될 수 있습니다.</p>
</dd></dl>

</div>
<div class="section" id="slot-type-typedefs">
<span id="id5"></span><h1>슬롯 형 typedef<a class="headerlink" href="#slot-type-typedefs" title="제목 주소">¶</a></h1>
<dl class="type">
<dt id="c.allocfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*allocfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a><em> *cls</em>, Py_ssize_t<em> nitems</em><span class="sig-paren">)</span><a class="headerlink" href="#c.allocfunc" title="정의 주소">¶</a></dt>
<dd><p>이 함수의 목적은 메모리 초기화에서 메모리 할당을 분리하는 것입니다. 인스턴스에 적합한 길이의, 적절하게 정렬되고, 0으로 초기화되지만, <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_refcnt</span></code>는 <code class="docutils literal notranslate"><span class="pre">1</span></code>로 설정되고 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_type</span></code>은 형 인자로 설정된 메모리 블록에 대한 포인터를 반환해야 합니다. 형의 <a class="reference internal" href="#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_itemsize</span></code></a>가 0이 아니면, 객체의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code> 필드는 <em>nitems</em>로 초기화되고 할당된 메모리 블록의 길이는 <code class="docutils literal notranslate"><span class="pre">tp_basicsize</span> <span class="pre">+</span> <span class="pre">nitems*tp_itemsize</span></code> 여야 하는데, <code class="docutils literal notranslate"><span class="pre">sizeof(void*)</span></code>의 배수로 자리 올림 되어야 합니다; 그렇지 않으면 <em>nitems</em>가 사용되지 않으며 블록의 길이는 <a class="reference internal" href="#c.PyTypeObject.tp_basicsize" title="PyTypeObject.tp_basicsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_basicsize</span></code></a> 여야 합니다.</p>
<p>이 함수는 다른 인스턴스 초기화를 수행하지 않아야 합니다, 추가 메모리를 할당도 안 됩니다; 그것은 <a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a>에 의해 수행되어야 합니다.</p>
</dd></dl>

<dl class="type">
<dt id="c.destructor">
void <code class="sig-name descname">(*destructor)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.destructor" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.vectorcallfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*vectorcallfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *callable</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *const<em> *args</em>, size_t<em> nargsf</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *kwnames</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vectorcallfunc" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code></a>을 참조하십시오.</p>
<p><code class="docutils literal notranslate"><span class="pre">vectorcallfunc</span></code>에 대한 인자는 <a class="reference internal" href="object.html#c._PyObject_Vectorcall" title="_PyObject_Vectorcall"><code class="xref c c-func docutils literal notranslate"><span class="pre">_PyObject_Vectorcall()</span></code></a>과 같습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="type">
<dt id="c.freefunc">
void <code class="sig-name descname">(*freefunc)</code><span class="sig-paren">(</span>void<em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.freefunc" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a>를 참조하십시오.</p>
</dd></dl>

<dl class="type">
<dt id="c.newfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*newfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.newfunc" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a>를 참조하십시오.</p>
</dd></dl>

<dl class="type">
<dt id="c.initproc">
int <code class="sig-name descname">(*initproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.initproc" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_init</span></code></a>를 참조하십시오.</p>
</dd></dl>

<dl class="type">
<dt id="c.reprfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*reprfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reprfunc" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyTypeObject.tp_repr" title="PyTypeObject.tp_repr"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_repr</span></code></a>을 참조하십시오.</p>
</dd></dl>

<dl class="type">
<dt id="c.getattrfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*getattrfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *self</em>, char<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.getattrfunc" title="정의 주소">¶</a></dt>
<dd><p>객체의 명명된 어트리뷰트 값을 반환합니다.</p>
</dd></dl>

<dl class="type">
<dt id="c.setattrfunc">
int <code class="sig-name descname">(*setattrfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *self</em>, char<em> *attr</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.setattrfunc" title="정의 주소">¶</a></dt>
<dd><p>객체의 명명된 어트리뷰트 값을 설정합니다. 어트리뷰트를 삭제하려면 value 인자가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정됩니다.</p>
</dd></dl>

<dl class="type">
<dt id="c.getattrofunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*getattrofunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *self</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.getattrofunc" title="정의 주소">¶</a></dt>
<dd><p>객체의 명명된 어트리뷰트 값을 반환합니다.</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_getattro" title="PyTypeObject.tp_getattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_getattro</span></code></a>를 참조하십시오.</p>
</dd></dl>

<dl class="type">
<dt id="c.setattrofunc">
int <code class="sig-name descname">(*setattrofunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *self</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *attr</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.setattrofunc" title="정의 주소">¶</a></dt>
<dd><p>객체의 명명된 어트리뷰트 값을 설정합니다. 어트리뷰트를 삭제하려면 value 인자가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정됩니다.</p>
<p><a class="reference internal" href="#c.PyTypeObject.tp_setattro" title="PyTypeObject.tp_setattro"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_setattro</span></code></a>를 참조하십시오.</p>
</dd></dl>

<dl class="type">
<dt id="c.descrgetfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*descrgetfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.descrgetfunc" title="정의 주소">¶</a></dt>
<dd><p><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descrget</span></code>을 참조하십시오.</p>
</dd></dl>

<dl class="type">
<dt id="c.descrsetfunc">
int <code class="sig-name descname">(*descrsetfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.descrsetfunc" title="정의 주소">¶</a></dt>
<dd><p><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_descrset</span></code>을 참조하십시오.</p>
</dd></dl>

<dl class="type">
<dt id="c.hashfunc">
Py_hash_t <code class="sig-name descname">(*hashfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hashfunc" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyTypeObject.tp_hash" title="PyTypeObject.tp_hash"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_hash</span></code></a>를 참조하십시오.</p>
</dd></dl>

<dl class="type">
<dt id="c.richcmpfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*richcmpfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, int<span class="sig-paren">)</span><a class="headerlink" href="#c.richcmpfunc" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyTypeObject.tp_richcompare" title="PyTypeObject.tp_richcompare"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_richcompare</span></code></a>를 참조하십시오.</p>
</dd></dl>

<dl class="type">
<dt id="c.getiterfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*getiterfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.getiterfunc" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a>를 참조하십시오.</p>
</dd></dl>

<dl class="type">
<dt id="c.iternextfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*iternextfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iternextfunc" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iternext</span></code></a>를 참조하십시오.</p>
</dd></dl>

<dl class="type">
<dt id="c.lenfunc">
Py_ssize_t <code class="sig-name descname">(*lenfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lenfunc" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.getbufferproc">
int <code class="sig-name descname">(*getbufferproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer">Py_buffer</a><em> *</em>, int<span class="sig-paren">)</span><a class="headerlink" href="#c.getbufferproc" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.releasebufferproc">
void <code class="sig-name descname">(*releasebufferproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer">Py_buffer</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.releasebufferproc" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.unaryfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*unaryfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unaryfunc" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.binaryfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*binaryfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.binaryfunc" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.ternaryfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*ternaryfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ternaryfunc" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.ssizeargfunc">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">(*ssizeargfunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, Py_ssize_t<span class="sig-paren">)</span><a class="headerlink" href="#c.ssizeargfunc" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.ssizeobjargproc">
int <code class="sig-name descname">(*ssizeobjargproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, Py_ssize_t<span class="sig-paren">)</span><a class="headerlink" href="#c.ssizeobjargproc" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.objobjproc">
int <code class="sig-name descname">(*objobjproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.objobjproc" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="type">
<dt id="c.objobjargproc">
int <code class="sig-name descname">(*objobjargproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.objobjargproc" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="examples">
<span id="typedef-examples"></span><h1>예<a class="headerlink" href="#examples" title="제목 주소">¶</a></h1>
<p>다음은 파이썬 형 정의의 간단한 예입니다. 여기에는 여러분이 만날 수 있는 일반적인 사용법이 포함됩니다. 일부는 까다로운 코너 사례를 보여줍니다. 더 많은 예제, 실용 정보 및 자습서는 <a class="reference internal" href="../extending/newtypes_tutorial.html#defining-new-types"><span class="std std-ref">확장형 정의하기: 자습서</span></a>와 <a class="reference internal" href="../extending/newtypes.html#new-types-topics"><span class="std std-ref">확장형 정의하기: 여러 가지 주제</span></a>를 참조하십시오.</p>
<p>기본 정적 형:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">MyObject</span><span class="p">;</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">MyObject_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">.</span><span class="n">tp_name</span> <span class="o">=</span> <span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_basicsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">),</span>
    <span class="p">.</span><span class="n">tp_doc</span> <span class="o">=</span> <span class="s">&quot;My objects&quot;</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_new</span> <span class="o">=</span> <span class="n">myobj_new</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_dealloc</span> <span class="o">=</span> <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">myobj_dealloc</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_repr</span> <span class="o">=</span> <span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">myobj_repr</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>더 상세한 초기화자를 사용하는 이전 코드(특히 CPython 코드 베이스에서)를 찾을 수도 있습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">MyObject_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span>               <span class="cm">/* tp_name */</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">),</span>               <span class="cm">/* tp_basicsize */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_itemsize */</span>
    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">myobj_dealloc</span><span class="p">,</span>      <span class="cm">/* tp_dealloc */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_vectorcall_offset */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_setattr */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_as_async */</span>
    <span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">myobj_repr</span><span class="p">,</span>           <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_as_number */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_as_sequence */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_as_mapping */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_hash */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_str */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_as_buffer */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_flags */</span>
    <span class="s">&quot;My objects&quot;</span><span class="p">,</span>                   <span class="cm">/* tp_doc */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_traverse */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_clear */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_weaklistoffset */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_iternext */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_methods */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_members */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_dictoffset */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_init */</span>
    <span class="mi">0</span><span class="p">,</span>                              <span class="cm">/* tp_alloc */</span>
    <span class="n">myobj_new</span><span class="p">,</span>                      <span class="cm">/* tp_new */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>약한 참조, 인스턴스 딕셔너리 및 해싱을 지원하는 형:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">inst_dict</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">weakreflist</span><span class="p">;</span>
<span class="p">}</span> <span class="n">MyObject</span><span class="p">;</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">MyObject_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">.</span><span class="n">tp_name</span> <span class="o">=</span> <span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_basicsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">),</span>
    <span class="p">.</span><span class="n">tp_doc</span> <span class="o">=</span> <span class="s">&quot;My objects&quot;</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_weaklistoffset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">,</span> <span class="n">weakreflist</span><span class="p">),</span>
    <span class="p">.</span><span class="n">tp_dictoffset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">,</span> <span class="n">inst_dict</span><span class="p">),</span>
    <span class="p">.</span><span class="n">tp_flags</span> <span class="o">=</span> <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_BASETYPE</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_HAVE_GC</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_new</span> <span class="o">=</span> <span class="n">myobj_new</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_traverse</span> <span class="o">=</span> <span class="p">(</span><span class="n">traverseproc</span><span class="p">)</span><span class="n">myobj_traverse</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_clear</span> <span class="o">=</span> <span class="p">(</span><span class="n">inquiry</span><span class="p">)</span><span class="n">myobj_clear</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_alloc</span> <span class="o">=</span> <span class="n">PyType_GenericNew</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_dealloc</span> <span class="o">=</span> <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">myobj_dealloc</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_repr</span> <span class="o">=</span> <span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">myobj_repr</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">hashfunc</span><span class="p">)</span><span class="n">myobj_hash</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_richcompare</span> <span class="o">=</span> <span class="n">PyBaseObject_Type</span><span class="p">.</span><span class="n">tp_richcompare</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>서브 클래싱 할 수 없고 인스턴스를 만들기 위해 호출할 수 없는 str 서브 클래스 (예를 들어 별도의 팩토리 함수를 사용합니다):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyUnicodeObject</span> <span class="n">raw</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">extra</span><span class="p">;</span>
<span class="p">}</span> <span class="n">MyStr</span><span class="p">;</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">MyStr_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">.</span><span class="n">tp_name</span> <span class="o">=</span> <span class="s">&quot;mymod.MyStr&quot;</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_basicsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MyStr</span><span class="p">),</span>
    <span class="p">.</span><span class="n">tp_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>  <span class="c1">// 모듈 초기화에서 &amp;PyUnicode_Type으로 설정합니다</span>
    <span class="p">.</span><span class="n">tp_doc</span> <span class="o">=</span> <span class="s">&quot;my custom str&quot;</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_flags</span> <span class="o">=</span> <span class="n">Py_TPFLAGS_DEFAULT</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_repr</span> <span class="o">=</span> <span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">myobj_repr</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>(고정 길이 인스턴스의) 가장 간단한 정적 형:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
<span class="p">}</span> <span class="n">MyObject</span><span class="p">;</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">MyObject_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">.</span><span class="n">tp_name</span> <span class="o">=</span> <span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>(가변 길이 인스턴스의) 가장 간단한 정적 형:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">MyObject</span><span class="p">;</span>

<span class="k">static</span> <span class="n">PyTypeObject</span> <span class="n">MyObject_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">.</span><span class="n">tp_name</span> <span class="o">=</span> <span class="s">&quot;mymod.MyObject&quot;</span><span class="p">,</span>
    <span class="p">.</span><span class="n">tp_basicsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MyObject</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">),</span>
    <span class="p">.</span><span class="n">tp_itemsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">),</span>
<span class="p">};</span>
</pre></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">형 객체</a><ul>
<li><a class="reference internal" href="#quick-reference">간략 참조</a><ul>
<li><a class="reference internal" href="#tp-slots">&quot;tp 슬롯&quot;</a></li>
<li><a class="reference internal" href="#sub-slots">서브 슬롯</a></li>
<li><a class="reference internal" href="#slot-typedefs">슬롯 typedef</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pytypeobject-definition">PyTypeObject 정의</a></li>
<li><a class="reference internal" href="#pyobject-slots">PyObject 슬롯</a></li>
<li><a class="reference internal" href="#pyvarobject-slots">PyVarObject 슬롯</a></li>
<li><a class="reference internal" href="#pytypeobject-slots">PyTypeObject 슬롯</a></li>
<li><a class="reference internal" href="#heap-types">힙 형</a></li>
</ul>
</li>
<li><a class="reference internal" href="#number-object-structures">숫자 객체 구조체</a></li>
<li><a class="reference internal" href="#mapping-object-structures">매핑 객체 구조체</a></li>
<li><a class="reference internal" href="#sequence-object-structures">시퀀스 객체 구조체</a></li>
<li><a class="reference internal" href="#buffer-object-structures">버퍼 객체 구조체</a></li>
<li><a class="reference internal" href="#async-object-structures">비동기 객체 구조체</a></li>
<li><a class="reference internal" href="#slot-type-typedefs">슬롯 형 typedef</a></li>
<li><a class="reference internal" href="#examples">예</a></li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="structures.html"
                        title="이전 장">공통 객체 구조체</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="gcsupport.html"
                        title="다음 장">순환 가비지 수집 지원</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="gcsupport.html" title="순환 가비지 수집 지원"
             >다음</a> |</li>
        <li class="right" >
          <a href="structures.html" title="공통 객체 구조체"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="objimpl.html" >객체 구현 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>