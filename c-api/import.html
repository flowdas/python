
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>모듈 임포트 하기 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="데이터 마샬링 지원" href="marshal.html" />
    <link rel="prev" title="운영 체제 유틸리티" href="sys.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/c-api/import.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="marshal.html" title="데이터 마샬링 지원"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="sys.html" title="운영 체제 유틸리티"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="utilities.html" accesskey="U">유틸리티</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="importing-modules">
<span id="importing"></span><h1>모듈 임포트 하기<a class="headerlink" href="#importing-modules" title="제목 주소">¶</a></h1>
<dl class="function">
<dt id="c.PyImport_ImportModule">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_ImportModule</code><span class="sig-paren">(</span>const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_ImportModule" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p id="index-0">이것은 아래 <a class="reference internal" href="#c.PyImport_ImportModuleEx" title="PyImport_ImportModuleEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModuleEx()</span></code></a> 에 대한 단순화된 인터페이스입니다. <em>globals</em>와 <em>locals</em> 인자를 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정하고 <em>level</em>은 0으로 설정합니다. <em>name</em> 인자에 점이 포함되면 (패키지의 서브 모듈을 지정할 때), <em>fromlist</em> 인자는 리스트 <code class="docutils literal notranslate"><span class="pre">['*']</span></code>로 설정해서 반환 값이 그렇지 않았을 때 반환되는 최상위 수준 패키지 대신에 이름 지정된 모듈이 되도록 합니다. (안타깝게도, <em>name</em>이 실제로 서브 모듈 대신 서브 패키지를 지정하면 추가적인 부작용이 발생합니다: 패키지의 <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 변수에 지정된 서브 모듈들이 로드됩니다.) 임포트 한 모듈에 대한 새로운 참조를 반환하거나 실패 시 예외가 설정된 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다. 모듈을 임포트 하는 데 실패하면 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 모듈을 남기지 않습니다.</p>
<p>이 함수는 항상 절대 임포트를 사용합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_ImportModuleNoBlock">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_ImportModuleNoBlock</code><span class="sig-paren">(</span>const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_ImportModuleNoBlock" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>이 함수는 <a class="reference internal" href="#c.PyImport_ImportModule" title="PyImport_ImportModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModule()</span></code></a>의 폐지된 별칭입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>이 기능은 다른 스레드가 임포트 잠금을 보유한 경우 즉시 실패했었습니다. 그러나 파이썬 3.3에서는, 잠금 방식이 대부분의 목적에서 모듈 단위 잠금으로 전환되었기 때문에, 이 함수의 특수한 동작은 더는 필요하지 않습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_ImportModuleEx">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_ImportModuleEx</code><span class="sig-paren">(</span>const char<em> *name</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *globals</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *locals</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *fromlist</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_ImportModuleEx" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p id="index-1">모듈을 임포트 합니다. 내장 파이썬 함수 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>를 통해 가장 잘 설명할 수 있습니다.</p>
<p>반환 값은 임포트 된 모듈이나 최상위 패키지에 대한 새로운 참조, 또는 실패 시 예외가 설정된 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>입니다. <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>와 마찬가지로, 비어 있지 않은 <em>fromlist</em>가 제공되지 않는 한, 패키지의 서브 모듈이 요청되었을 때의 반환 값은 최상위 패키지입니다.</p>
<p>임포트 실패는 <a class="reference internal" href="#c.PyImport_ImportModule" title="PyImport_ImportModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModule()</span></code></a>처럼 불완전한 모듈 객체를 제거합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_ImportModuleLevelObject">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_ImportModuleLevelObject</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *name</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *globals</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *locals</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *fromlist</em>, int<em> level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_ImportModuleLevelObject" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>모듈을 임포트 합니다. 표준 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수가 이 함수를 직접 호출하기 때문에, 내장 파이썬 함수 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>를 통해 가장 잘 설명할 수 있습니다.</p>
<p>반환 값은 임포트 된 모듈이나 최상위 패키지에 대한 새로운 참조, 또는 실패 시 예외가 설정된 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>입니다. <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>와 마찬가지로, 비어 있지 않은 <em>fromlist</em>가 제공되지 않는 한, 패키지의 서브 모듈이 요청되었을 때의 반환 값은 최상위 패키지입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_ImportModuleLevel">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_ImportModuleLevel</code><span class="sig-paren">(</span>const char<em> *name</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *globals</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *locals</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *fromlist</em>, int<em> level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_ImportModuleLevel" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><a class="reference internal" href="#c.PyImport_ImportModuleLevelObject" title="PyImport_ImportModuleLevelObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModuleLevelObject()</span></code></a>와 비슷하지만, name은 유니코드 객체 대신 UTF-8로 인코딩된 문자열입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><em>level</em>의 음수 값은 더는 허용되지 않습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_Import">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_Import</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_Import" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>이것은 현재 &quot;임포트 훅 함수&quot;를 호출하는 고수준 인터페이스입니다 (명시적인 <em>level</em> 0을 사용하는데, 절대 임포트를 뜻합니다). 현재 전역의 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code>에 있는 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수를 호출합니다. 이는 현재 환경에 설치된 임포트 훅을 사용하여 임포트가 수행됨을 의미합니다.</p>
<p>이 함수는 항상 절대 임포트를 사용합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_ReloadModule">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_ReloadModule</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *m</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_ReloadModule" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>모듈을 다시 로드(reload)합니다. 다시 로드된 모듈에 대한 참조를 반환하거나, 실패 시 예외가 설정된 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다 (이때 모듈은 여전히 존재합니다).</p>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_AddModuleObject">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_AddModuleObject</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_AddModuleObject" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: Borrowed reference.</em><p>모듈 이름에 해당하는 모듈 객체를 반환합니다. <em>name</em> 인자는 <code class="docutils literal notranslate"><span class="pre">package.module</span></code> 형식일 수 있습니다. 먼저 모듈 딕셔너리에 있는지 확인하고, 없으면 새로 만들어 모듈 딕셔너리에 삽입합니다. 실패 시 예외를 설정하고 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 함수는 모듈을 로드하거나 임포트 하지 않습니다; 모듈이 아직 로드되지 않았으면, 빈 모듈 객체를 얻게 됩니다. 모듈을 임포트 하려면 <a class="reference internal" href="#c.PyImport_ImportModule" title="PyImport_ImportModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModule()</span></code></a>이나 그 변형 중 하나를 사용하십시오. <em>name</em>에서 점으로 구분된 이름으로 암시된 패키지 구조는 이미 존재하지 않는다면 만들어지지 않습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_AddModule">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_AddModule</code><span class="sig-paren">(</span>const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_AddModule" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: Borrowed reference.</em><p><a class="reference internal" href="#c.PyImport_AddModuleObject" title="PyImport_AddModuleObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_AddModuleObject()</span></code></a>와 비슷하지만, name은 유니코드 객체 대신 UTF-8로 인코딩된 문자열입니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_ExecCodeModule">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_ExecCodeModule</code><span class="sig-paren">(</span>const char<em> *name</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *co</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_ExecCodeModule" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p id="index-2">주어진 모듈 이름(name)(<code class="docutils literal notranslate"><span class="pre">package.module</span></code> 형식일 수 있습니다)과 파이썬 바이트 코드 파일에서 읽거나 내장 함수 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>로 얻은 코드 객체로, 모듈을 로드합니다. 모듈 객체에 대한 새로운 참조를 반환하거나, 또는 에러가 발생하면 예외가 설정된 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다. 에러가 발생하면 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에서 <em>name</em>이 제거됩니다, <a class="reference internal" href="#c.PyImport_ExecCodeModule" title="PyImport_ExecCodeModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ExecCodeModule()</span></code></a> 에 진입할 때 <em>name</em>이 <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 이미 있어도 그렇습니다. <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 불완전하게 초기화된 모듈을 남겨 두는 것은 위험합니다, 그러한 모듈을 임포트 할 때 모듈 객체가 알 수 없는 (그리고 아마도 모듈 작성자의 의도에 비추어볼 때 손상된) 상태에 있음을 알 방법이 없기 때문입니다.</p>
<p>모듈의 <a class="reference internal" href="../reference/import.html#__spec__" title="__spec__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code></a>과 <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a>는 아직 설정되지 않았다면 적절한 값으로 설정됩니다. 스펙의 로더는 모듈의 <code class="docutils literal notranslate"><span class="pre">__loader__</span></code>(설정되었다면)로 설정되고, 그렇지 않으면 <code class="xref py py-class docutils literal notranslate"><span class="pre">SourceFileLoader</span></code> 의 인스턴스로 설정됩니다.</p>
<p>모듈의 <a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 어트리뷰트는 코드 객체의 <code class="xref c c-member docutils literal notranslate"><span class="pre">co_filename</span></code>으로 설정됩니다. 해당한다면, <a class="reference internal" href="../reference/import.html#__cached__" title="__cached__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code></a>도 설정됩니다.</p>
<p>이 함수는 이미 임포트 되었다면 모듈을 다시 로드합니다. 모듈을 다시 로드하는 의도된 방법은 <a class="reference internal" href="#c.PyImport_ReloadModule" title="PyImport_ReloadModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ReloadModule()</span></code></a>을 참조하십시오.</p>
<p><em>name</em>이 <code class="docutils literal notranslate"><span class="pre">package.module</span></code> 형식의 점으로 구분된 이름을 가리키면, 이미 만들어지지 않은 패키지 구조는 여전히 만들어지지 않습니다.</p>
<p><a class="reference internal" href="#c.PyImport_ExecCodeModuleEx" title="PyImport_ExecCodeModuleEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ExecCodeModuleEx()</span></code></a>와 <a class="reference internal" href="#c.PyImport_ExecCodeModuleWithPathnames" title="PyImport_ExecCodeModuleWithPathnames"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ExecCodeModuleWithPathnames()</span></code></a>도 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_ExecCodeModuleEx">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_ExecCodeModuleEx</code><span class="sig-paren">(</span>const char<em> *name</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *co</em>, const char<em> *pathname</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_ExecCodeModuleEx" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><a class="reference internal" href="#c.PyImport_ExecCodeModule" title="PyImport_ExecCodeModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ExecCodeModule()</span></code></a>과 유사하지만, 모듈 객체의 <a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 어트리뷰트는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니라면 <em>pathname</em>으로 설정됩니다.</p>
<p><a class="reference internal" href="#c.PyImport_ExecCodeModuleWithPathnames" title="PyImport_ExecCodeModuleWithPathnames"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ExecCodeModuleWithPathnames()</span></code></a>도 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_ExecCodeModuleObject">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_ExecCodeModuleObject</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *name</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *co</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *pathname</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *cpathname</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_ExecCodeModuleObject" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><a class="reference internal" href="#c.PyImport_ExecCodeModuleEx" title="PyImport_ExecCodeModuleEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ExecCodeModuleEx()</span></code></a>와 유사하지만, 모듈 객체의 <a class="reference internal" href="../reference/import.html#__cached__" title="__cached__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code></a> 어트리뷰트는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니라면 <em>cpathname</em>으로 설정됩니다. 세 가지 함수 중 이것이 선호되는 것입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_ExecCodeModuleWithPathnames">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_ExecCodeModuleWithPathnames</code><span class="sig-paren">(</span>const char<em> *name</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *co</em>, const char<em> *pathname</em>, const char<em> *cpathname</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_ExecCodeModuleWithPathnames" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><a class="reference internal" href="#c.PyImport_ExecCodeModuleObject" title="PyImport_ExecCodeModuleObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ExecCodeModuleObject()</span></code></a>와 유사하지만, <em>name</em>, <em>pathname</em> 및 <em>cpathname</em>은 UTF-8로 인코딩된 문자열입니다. <em>pathname</em>의 값이 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정된 경우 어떤 값이 <em>cpathname</em>에서 와야하는지 알아내려고 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>바이트 코드 경로만 제공되면 소스 경로를 계산할 때 <a class="reference internal" href="../library/imp.html#imp.source_from_cache" title="imp.source_from_cache"><code class="xref py py-func docutils literal notranslate"><span class="pre">imp.source_from_cache()</span></code></a>를 사용합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_GetMagicNumber">
long <code class="sig-name descname">PyImport_GetMagicNumber</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_GetMagicNumber" title="정의 주소">¶</a></dt>
<dd><p>파이썬 바이트 코드 파일(일명 <code class="file docutils literal notranslate"><span class="pre">.pyc</span></code> 파일)의 매직 번호(magic number)를 반환합니다. 매직 번호는 바이트 코드 파일의 처음 4바이트에 리틀 엔디안 바이트 순서로 존재해야 합니다. 에러 시 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>실패 시 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_GetMagicTag">
const char * <code class="sig-name descname">PyImport_GetMagicTag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_GetMagicTag" title="정의 주소">¶</a></dt>
<dd><p><span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> 형식 파이썬 바이트 코드 파일 이름의 매직 태그 문자열을 반환합니다. <code class="docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code>의 값은 신뢰할 수 있고 이 함수 대신 사용해야 함에 유의하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_GetModuleDict">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_GetModuleDict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_GetModuleDict" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: Borrowed reference.</em><p>모듈 관리에 사용되는 딕셔너리(일명 <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>)를 반환합니다. 이것은 인터프리터마다 존재하는 변수임에 유의하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_GetModule">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_GetModule</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_GetModule" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>주어진 이름으로 이미 임포트 된 모듈을 반환합니다. 모듈이 아직 임포트 되지 않았다면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환하지만 에러는 설정하지 않습니다. 조회에 실패하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환하고 에러를 설정합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_GetImporter">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyImport_GetImporter</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_GetImporter" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>/<code class="xref py py-attr docutils literal notranslate"><span class="pre">pkg.__path__</span></code> 항목 <em>path</em>를 위한 파인더 객체를 반환합니다, <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 딕셔너리에서 꺼낼 수도 있습니다. 아직 캐시 되지 않았으면, 경로 항목을 처리할 수 있는 훅이 발견될 때까지 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>를 탐색합니다. 훅이 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다; 이것은 호출자에게 <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">경로 기반 파인더</span></a>가 이 경로 항목에 대한 파인더를 찾을 수 없음을 알려줍니다. <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>에 결과를 캐시 합니다. 파인더 객체에 대한 새로운 참조를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c._PyImport_Init">
void <code class="sig-name descname">_PyImport_Init</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c._PyImport_Init" title="정의 주소">¶</a></dt>
<dd><p>임포트 메커니즘을 초기화합니다. 내부 전용입니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_Cleanup">
void <code class="sig-name descname">PyImport_Cleanup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_Cleanup" title="정의 주소">¶</a></dt>
<dd><p>모듈 테이블을 비웁니다. 내부 전용입니다.</p>
</dd></dl>

<dl class="function">
<dt id="c._PyImport_Fini">
void <code class="sig-name descname">_PyImport_Fini</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c._PyImport_Fini" title="정의 주소">¶</a></dt>
<dd><p>임포트 메커니즘을 마무리합니다. 내부 전용입니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_ImportFrozenModuleObject">
int <code class="sig-name descname">PyImport_ImportFrozenModuleObject</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_ImportFrozenModuleObject" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p><em>name</em>이라는 이름의 프로즌 모듈(frozen module)을 로드합니다. 성공하면 <code class="docutils literal notranslate"><span class="pre">1</span></code>을, 모듈을 찾지 못하면 <code class="docutils literal notranslate"><span class="pre">0</span></code>을, 초기화에 실패하면 예외를 설정하고 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다. 로드가 성공할 때 임포트 된 모듈에 액세스하려면 <a class="reference internal" href="#c.PyImport_ImportModule" title="PyImport_ImportModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModule()</span></code></a>을 사용하십시오. (잘못된 이름에 주의하십시오 --- 이 함수는 모듈이 이미 임포트 되었을 때 다시 로드합니다.)</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">__file__</span></code> 어트리뷰트는 더는 모듈에 설정되지 않습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_ImportFrozenModule">
int <code class="sig-name descname">PyImport_ImportFrozenModule</code><span class="sig-paren">(</span>const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_ImportFrozenModule" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyImport_ImportFrozenModuleObject" title="PyImport_ImportFrozenModuleObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportFrozenModuleObject()</span></code></a>와 비슷하지만, name은 유니코드 객체 대신 UTF-8로 인코딩된 문자열입니다.</p>
</dd></dl>

<dl class="type">
<dt id="c._frozen">
struct <code class="sig-name descname">_frozen</code><a class="headerlink" href="#c._frozen" title="정의 주소">¶</a></dt>
<dd><p id="index-4">이것은 <strong class="program">freeze</strong> 유틸리티(파이썬 소스 배포의 <code class="file docutils literal notranslate"><span class="pre">Tools/freeze/</span></code>를 참조하십시오)가 생성한 프로즌 모듈 디스크립터를 위한 구조체 형 정의입니다. <code class="file docutils literal notranslate"><span class="pre">Include/import.h</span></code>에 있는 정의는 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">_frozen</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">code</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

<dl class="var">
<dt id="c.PyImport_FrozenModules">
const struct <a class="reference internal" href="#c._frozen" title="_frozen">_frozen</a>* <code class="sig-name descname">PyImport_FrozenModules</code><a class="headerlink" href="#c.PyImport_FrozenModules" title="정의 주소">¶</a></dt>
<dd><p>이 포인터는 <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">_frozen</span></code> 레코드의 배열을 가리키도록 초기화되는데, 멤버가 모두 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이나 0인 레코드로 끝납니다. 프로즌 모듈이 임포트 될 때, 이 테이블에서 검색됩니다. 제삼자 코드는 이것을 사용하여 동적으로 생성된 프로즌 모듈 컬렉션을 제공할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_AppendInittab">
int <code class="sig-name descname">PyImport_AppendInittab</code><span class="sig-paren">(</span>const char<em> *name</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* (<em>*initfunc</em>)(void)<span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_AppendInittab" title="정의 주소">¶</a></dt>
<dd><p>기존의 내장 모듈 테이블에 단일 모듈을 추가합니다. 이것은 <a class="reference internal" href="#c.PyImport_ExtendInittab" title="PyImport_ExtendInittab"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ExtendInittab()</span></code></a>을 감싸는 편리한 래퍼인데, 테이블을 확장할 수 없으면 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다. 새 모듈은 <em>name</em>이라는 이름으로 임포트 될 수 있으며, <em>initfunc</em> 함수를 처음 시도한 임포트에서 호출되는 초기화 함수로 사용합니다. <a class="reference internal" href="init.html#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 전에 호출해야 합니다.</p>
</dd></dl>

<dl class="type">
<dt id="c._inittab">
struct <code class="sig-name descname">_inittab</code><a class="headerlink" href="#c._inittab" title="정의 주소">¶</a></dt>
<dd><p>내장 모듈 목록에 있는 단일 항목을 기술하는 구조체. 각 구조체는 인터프리터에 내장된 모듈의 이름과 초기화 함수를 제공합니다. 이름은 ASCII로 인코딩된 문자열입니다. 파이썬을 내장하는 프로그램은 <a class="reference internal" href="#c.PyImport_ExtendInittab" title="PyImport_ExtendInittab"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ExtendInittab()</span></code></a>과 함께 이러한 구조체의 배열을 사용하여 추가 내장 모듈을 제공 할 수 있습니다. 구조체는 <code class="file docutils literal notranslate"><span class="pre">Include/import.h</span></code>에서 다음과 같이 정의됩니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">_inittab</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>           <span class="cm">/* ASCII encoded string */</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">initfunc</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyImport_ExtendInittab">
int <code class="sig-name descname">PyImport_ExtendInittab</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c._inittab" title="_inittab">_inittab</a><em> *newtab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyImport_ExtendInittab" title="정의 주소">¶</a></dt>
<dd><p>내장 모듈 테이블에 모듈 컬렉션을 추가합니다. <em>newtab</em> 배열은 <code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code> 필드에 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 포함하는 센티넬(sentinel) 항목으로 끝나야 합니다; 센티넬 값을 제공하지 않으면 메모리 오류가 발생할 수 있습니다. 성공하면 <code class="docutils literal notranslate"><span class="pre">0</span></code>을, 내부 테이블을 확장하기 위한 메모리가 충분하지 않으면 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다. 실패하면, 내부 테이블에 모듈이 추가되지 않습니다. <a class="reference internal" href="init.html#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 전에 호출해야 합니다.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>이전 항목</h4>
  <p class="topless"><a href="sys.html"
                        title="이전 장">운영 체제 유틸리티</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="marshal.html"
                        title="다음 장">데이터 마샬링 지원</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="marshal.html" title="데이터 마샬링 지원"
             >다음</a> |</li>
        <li class="right" >
          <a href="sys.html" title="운영 체제 유틸리티"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="utilities.html" >유틸리티</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>