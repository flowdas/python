
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>초기화, 파이널리제이션 및 스레드 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="파이썬 초기화 구성" href="init_config.html" />
    <link rel="prev" title="DateTime 객체" href="datetime.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/c-api/init.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="init_config.html" title="파이썬 초기화 구성"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="datetime.html" title="DateTime 객체"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬/C API 레퍼런스 설명서</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="initialization-finalization-and-threads">
<span id="initialization"></span><h1>초기화, 파이널리제이션 및 스레드<a class="headerlink" href="#initialization-finalization-and-threads" title="제목 주소">¶</a></h1>
<p><a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">파이썬 초기화 구성</span></a>도 참조하십시오.</p>
<div class="section" id="before-python-initialization">
<span id="pre-init-safe"></span><h2>파이썬 초기화 전<a class="headerlink" href="#before-python-initialization" title="제목 주소">¶</a></h2>
<p>파이썬을 내장한 응용 프로그램에서는, 다른 파이썬/C API 함수를 사용하기 전에 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 함수를 호출해야 합니다; 몇 가지 함수와 <a class="reference internal" href="#global-conf-vars"><span class="std std-ref">전역 구성 변수</span></a>는 예외입니다.</p>
<p>파이썬이 초기화되기 전에 다음 함수를 안전하게 호출할 수 있습니다:</p>
<ul class="simple">
<li><p>구성 함수:</p>
<ul>
<li><p><a class="reference internal" href="import.html#c.PyImport_AppendInittab" title="PyImport_AppendInittab"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_AppendInittab()</span></code></a></p></li>
<li><p><a class="reference internal" href="import.html#c.PyImport_ExtendInittab" title="PyImport_ExtendInittab"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ExtendInittab()</span></code></a></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInitFrozenExtensions()</span></code></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyMem_SetAllocator" title="PyMem_SetAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetAllocator()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetupDebugHooks()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyObject_SetArenaAllocator" title="PyObject_SetArenaAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetArenaAllocator()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_SetPath" title="Py_SetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetPath()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_SetPythonHome" title="Py_SetPythonHome"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetPythonHome()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_SetStandardStreamEncoding" title="Py_SetStandardStreamEncoding"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetStandardStreamEncoding()</span></code></a></p></li>
<li><p><a class="reference internal" href="sys.html#c.PySys_AddWarnOption" title="PySys_AddWarnOption"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_AddWarnOption()</span></code></a></p></li>
<li><p><a class="reference internal" href="sys.html#c.PySys_AddXOption" title="PySys_AddXOption"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_AddXOption()</span></code></a></p></li>
<li><p><a class="reference internal" href="sys.html#c.PySys_ResetWarnOptions" title="PySys_ResetWarnOptions"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_ResetWarnOptions()</span></code></a></p></li>
</ul>
</li>
<li><p>정보 함수:</p>
<ul>
<li><p><a class="reference internal" href="#c.Py_IsInitialized" title="Py_IsInitialized"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_IsInitialized()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyMem_GetAllocator" title="PyMem_GetAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_GetAllocator()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyObject_GetArenaAllocator" title="PyObject_GetArenaAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetArenaAllocator()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetBuildInfo" title="Py_GetBuildInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetBuildInfo()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetCompiler" title="Py_GetCompiler"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetCompiler()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetCopyright" title="Py_GetCopyright"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetCopyright()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetPlatform" title="Py_GetPlatform"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPlatform()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetVersion" title="Py_GetVersion"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetVersion()</span></code></a></p></li>
</ul>
</li>
<li><p>유틸리티:</p>
<ul>
<li><p><a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a></p></li>
</ul>
</li>
<li><p>메모리 할당자:</p>
<ul>
<li><p><a class="reference internal" href="memory.html#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawCalloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyMem_RawFree" title="PyMem_RawFree"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawFree()</span></code></a></p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>다음 함수는 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 전에 <strong>호출하면 안 됩니다</strong>: <a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EncodeLocale()</span></code></a>, <a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a>, <a class="reference internal" href="#c.Py_GetPrefix" title="Py_GetPrefix"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPrefix()</span></code></a>, <a class="reference internal" href="#c.Py_GetExecPrefix" title="Py_GetExecPrefix"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetExecPrefix()</span></code></a>, <a class="reference internal" href="#c.Py_GetProgramFullPath" title="Py_GetProgramFullPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetProgramFullPath()</span></code></a>, <a class="reference internal" href="#c.Py_GetPythonHome" title="Py_GetPythonHome"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPythonHome()</span></code></a>, <a class="reference internal" href="#c.Py_GetProgramName" title="Py_GetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetProgramName()</span></code></a> 및 <a class="reference internal" href="#c.PyEval_InitThreads" title="PyEval_InitThreads"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_InitThreads()</span></code></a>.</p>
</div>
</div>
<div class="section" id="global-configuration-variables">
<span id="global-conf-vars"></span><h2>전역 구성 변수<a class="headerlink" href="#global-configuration-variables" title="제목 주소">¶</a></h2>
<p>파이썬에는 다양한 기능과 옵션을 제어하기 위한 전역 구성 변수가 있습니다. 기본적으로, 이러한 플래그는 <a class="reference internal" href="../using/cmdline.html#using-on-interface-options"><span class="std std-ref">명령 줄 옵션</span></a>에 의해 제어됩니다.</p>
<p>옵션에 의해 플래그가 설정되면, 플래그 값은 옵션이 설정된 횟수입니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">-b</span></code>는 <a class="reference internal" href="#c.Py_BytesWarningFlag" title="Py_BytesWarningFlag"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_BytesWarningFlag</span></code></a> 를 1로 설정하고 <code class="docutils literal notranslate"><span class="pre">-bb</span></code>는 <a class="reference internal" href="#c.Py_BytesWarningFlag" title="Py_BytesWarningFlag"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_BytesWarningFlag</span></code></a> 를 2로 설정합니다.</p>
<dl class="var">
<dt id="c.Py_BytesWarningFlag">
int <code class="sig-name descname">Py_BytesWarningFlag</code><a class="headerlink" href="#c.Py_BytesWarningFlag" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>나 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>와 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>을, 또는 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>를 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>와 비교할 때 경고를 발행합니다. <code class="docutils literal notranslate"><span class="pre">2</span></code>보다 크거나 같으면 에러를 발행합니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-b"><code class="xref std std-option docutils literal notranslate"><span class="pre">-b</span></code></a> 옵션으로 설정합니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_DebugFlag">
int <code class="sig-name descname">Py_DebugFlag</code><a class="headerlink" href="#c.Py_DebugFlag" title="정의 주소">¶</a></dt>
<dd><p>구문 분석기 디버깅 출력을 켭니다 (전문가 전용, 컴파일 옵션에 의존합니다).</p>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-d"><code class="xref std std-option docutils literal notranslate"><span class="pre">-d</span></code></a> 옵션과 <span class="target" id="index-71"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDEBUG"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDEBUG</span></code></a> 환경 변수로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_DontWriteBytecodeFlag">
int <code class="sig-name descname">Py_DontWriteBytecodeFlag</code><a class="headerlink" href="#c.Py_DontWriteBytecodeFlag" title="정의 주소">¶</a></dt>
<dd><p>0이 아닌 값으로 설정하면, 파이썬은 소스 모듈을 임포트 할 때 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일을 쓰려고 하지 않습니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#id1"><code class="xref std std-option docutils literal notranslate"><span class="pre">-B</span></code></a> 옵션과 <span class="target" id="index-72"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDONTWRITEBYTECODE</span></code></a> 환경 변수로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_FrozenFlag">
int <code class="sig-name descname">Py_FrozenFlag</code><a class="headerlink" href="#c.Py_FrozenFlag" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a>에서 모듈 검색 경로를 계산할 때 에러 메시지를 표시하지 않습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">_freeze_importlib</span></code>와 <code class="docutils literal notranslate"><span class="pre">frozenmain</span></code> 프로그램에서 사용하는 개인 플래그입니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_HashRandomizationFlag">
int <code class="sig-name descname">Py_HashRandomizationFlag</code><a class="headerlink" href="#c.Py_HashRandomizationFlag" title="정의 주소">¶</a></dt>
<dd><p><span class="target" id="index-73"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a> 환경 변수가 비어 있지 않은 문자열로 설정되면 <code class="docutils literal notranslate"><span class="pre">1</span></code>로 설정합니다.</p>
<p>플래그가 0이 아니면, <span class="target" id="index-74"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a> 환경 변수를 읽어 비밀 해시 시드를 초기화합니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_IgnoreEnvironmentFlag">
int <code class="sig-name descname">Py_IgnoreEnvironmentFlag</code><a class="headerlink" href="#c.Py_IgnoreEnvironmentFlag" title="정의 주소">¶</a></dt>
<dd><p>설정될 수 있는 모든 <span class="target" id="index-75"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHON*</span></code> 환경 변수 (예를 들어 <span class="target" id="index-76"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a>와 <span class="target" id="index-77"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a>)를 무시합니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-e"><code class="xref std std-option docutils literal notranslate"><span class="pre">-E</span></code></a>와 <a class="reference internal" href="../using/cmdline.html#id2"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> 옵션으로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_InspectFlag">
int <code class="sig-name descname">Py_InspectFlag</code><a class="headerlink" href="#c.Py_InspectFlag" title="정의 주소">¶</a></dt>
<dd><p>스크립트가 첫 번째 인자로 전달되거나 <a class="reference internal" href="../using/cmdline.html#cmdoption-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c</span></code></a> 옵션을 사용할 때, <a class="reference internal" href="../library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a>가 터미널로 보이지 않더라도 스크립트나 명령을 실행한 후 대화 형 모드로 들어갑니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a> 옵션과 <span class="target" id="index-78"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONINSPECT"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONINSPECT</span></code></a> 환경 변수로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_InteractiveFlag">
int <code class="sig-name descname">Py_InteractiveFlag</code><a class="headerlink" href="#c.Py_InteractiveFlag" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a> 옵션으로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_IsolatedFlag">
int <code class="sig-name descname">Py_IsolatedFlag</code><a class="headerlink" href="#c.Py_IsolatedFlag" title="정의 주소">¶</a></dt>
<dd><p>격리 모드로 파이썬을 실행합니다. 격리 모드에서 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>는 스크립트의 디렉터리도 사용자의 site-packages 디렉터리도 포함하지 않습니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#id2"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> 옵션으로 설정됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="var">
<dt id="c.Py_LegacyWindowsFSEncodingFlag">
int <code class="sig-name descname">Py_LegacyWindowsFSEncodingFlag</code><a class="headerlink" href="#c.Py_LegacyWindowsFSEncodingFlag" title="정의 주소">¶</a></dt>
<dd><p>플래그가 0이 아니면, 파일 시스템 인코딩에 UTF-8 인코딩 대신 <code class="docutils literal notranslate"><span class="pre">mbcs</span></code> 인코딩을 사용합니다.</p>
<p><span class="target" id="index-79"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONLEGACYWINDOWSFSENCODING"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONLEGACYWINDOWSFSENCODING</span></code></a> 환경 변수가 비어 있지 않은 문자열로 설정되면 <code class="docutils literal notranslate"><span class="pre">1</span></code>로 설정합니다.</p>
<p>자세한 내용은 <span class="target" id="index-80"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0529"><strong>PEP 529</strong></a>를 참조하십시오.</p>
<p class="availability"><a class="reference internal" href="../library/intro.html#availability"><span class="std std-ref">가용성</span></a>: 윈도우.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_LegacyWindowsStdioFlag">
int <code class="sig-name descname">Py_LegacyWindowsStdioFlag</code><a class="headerlink" href="#c.Py_LegacyWindowsStdioFlag" title="정의 주소">¶</a></dt>
<dd><p>플래그가 0이 아니면, <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 표준 스트림을 위해 <code class="xref py py-class docutils literal notranslate"><span class="pre">WindowsConsoleIO</span></code> 대신 <a class="reference internal" href="../library/io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a>를 사용합니다.</p>
<p><span class="target" id="index-81"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONLEGACYWINDOWSSTDIO"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONLEGACYWINDOWSSTDIO</span></code></a> 환경 변수가 비어 있지 않은 문자열로 설정되면 <code class="docutils literal notranslate"><span class="pre">1</span></code>로 설정합니다.</p>
<p>자세한 내용은 <span class="target" id="index-82"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0528"><strong>PEP 528</strong></a>을 참조하십시오.</p>
<p class="availability"><a class="reference internal" href="../library/intro.html#availability"><span class="std std-ref">가용성</span></a>: 윈도우.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_NoSiteFlag">
int <code class="sig-name descname">Py_NoSiteFlag</code><a class="headerlink" href="#c.Py_NoSiteFlag" title="정의 주소">¶</a></dt>
<dd><p>모듈 <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 임포트와 이에 수반되는 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>의 사이트 종속적인 조작을 비활성화합니다. 또한 나중에 <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a>를 명시적으로 임포트 할 때도 이러한 조작을 비활성화합니다 (트리거 하려면 <a class="reference internal" href="../library/site.html#site.main" title="site.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">site.main()</span></code></a>을 호출하십시오).</p>
<p><a class="reference internal" href="../using/cmdline.html#id3"><code class="xref std std-option docutils literal notranslate"><span class="pre">-S</span></code></a> 옵션으로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_NoUserSiteDirectory">
int <code class="sig-name descname">Py_NoUserSiteDirectory</code><a class="headerlink" href="#c.Py_NoUserSiteDirectory" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/site.html#site.USER_SITE" title="site.USER_SITE"><code class="xref py py-data docutils literal notranslate"><span class="pre">사용자</span> <span class="pre">site-packages</span> <span class="pre">디렉터리</span></code></a>를 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>에 추가하지 않습니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-s"><code class="xref std std-option docutils literal notranslate"><span class="pre">-s</span></code></a>와 <a class="reference internal" href="../using/cmdline.html#id2"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> 옵션, 그리고 <span class="target" id="index-83"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONNOUSERSITE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONNOUSERSITE</span></code></a> 환경 변수로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_OptimizeFlag">
int <code class="sig-name descname">Py_OptimizeFlag</code><a class="headerlink" href="#c.Py_OptimizeFlag" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 옵션과 <span class="target" id="index-84"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONOPTIMIZE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONOPTIMIZE</span></code></a> 환경 변수로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_QuietFlag">
int <code class="sig-name descname">Py_QuietFlag</code><a class="headerlink" href="#c.Py_QuietFlag" title="정의 주소">¶</a></dt>
<dd><p>대화형 모드에서도 저작권과 버전 메시지를 표시하지 않습니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-q"><code class="xref std std-option docutils literal notranslate"><span class="pre">-q</span></code></a> 옵션으로 설정됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="var">
<dt id="c.Py_UnbufferedStdioFlag">
int <code class="sig-name descname">Py_UnbufferedStdioFlag</code><a class="headerlink" href="#c.Py_UnbufferedStdioFlag" title="정의 주소">¶</a></dt>
<dd><p>stdout과 stderr 스트림을 버퍼링 해제하도록 강제합니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-u"><code class="xref std std-option docutils literal notranslate"><span class="pre">-u</span></code></a> 옵션과 <span class="target" id="index-85"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONUNBUFFERED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONUNBUFFERED</span></code></a> 환경 변수로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_VerboseFlag">
int <code class="sig-name descname">Py_VerboseFlag</code><a class="headerlink" href="#c.Py_VerboseFlag" title="정의 주소">¶</a></dt>
<dd><p>모듈이 초기화될 때마다, 로드된 위치(파일명이나 내장 모듈)를 표시하는 메시지를 인쇄합니다. <code class="docutils literal notranslate"><span class="pre">2</span></code>보다 크거나 같으면, 모듈을 검색할 때 검사되는 각 파일에 대한 메시지를 인쇄합니다. 또한 종료 시 모듈 정리에 대한 정보를 제공합니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#id4"><code class="xref std std-option docutils literal notranslate"><span class="pre">-v</span></code></a> 옵션과 <span class="target" id="index-86"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONVERBOSE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONVERBOSE</span></code></a> 환경 변수로 설정됩니다.</p>
</dd></dl>

</div>
<div class="section" id="initializing-and-finalizing-the-interpreter">
<h2>인터프리터 초기화와 파이널리제이션<a class="headerlink" href="#initializing-and-finalizing-the-interpreter" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="c.Py_Initialize">
void <code class="sig-name descname">Py_Initialize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_Initialize" title="정의 주소">¶</a></dt>
<dd><p id="index-16">파이썬 인터프리터를 초기화합니다. 파이썬을 내장하는 응용 프로그램에서는, 다른 파이썬/C API 함수를 사용하기 전에 호출해야 합니다; 몇 가지 예외는 <a class="reference internal" href="#pre-init-safe"><span class="std std-ref">파이썬 초기화 전</span></a>을 참조하십시오.</p>
<p>이것은 로드된 모듈의 테이블(<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>)을 초기화하고, 기반 모듈 <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>, <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 및 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>를 만듭니다. 또한, 모듈 검색 경로(<code class="docutils literal notranslate"><span class="pre">sys.path</span></code>)를 초기화합니다. <code class="docutils literal notranslate"><span class="pre">sys.argv</span></code>는 설정하지 않습니다; 이를 위해서는 <a class="reference internal" href="#c.PySys_SetArgvEx" title="PySys_SetArgvEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code></a> 를 사용하십시오.  (<a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 를 먼저 호출하지 않고) 두 번째로 호출하면 아무런 일도 하지 않습니다. 반환 값이 없습니다; 초기화에 실패하면 치명적인 에러입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>윈도우에서, 콘솔 모드를 <code class="docutils literal notranslate"><span class="pre">O_TEXT</span></code>에서 <code class="docutils literal notranslate"><span class="pre">O_BINARY</span></code>로 변경합니다, C 런타임을 사용하는 콘솔의 비 파이썬 사용에도 영향을 미칩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_InitializeEx">
void <code class="sig-name descname">Py_InitializeEx</code><span class="sig-paren">(</span>int<em> initsigs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_InitializeEx" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <em>initsigs</em>가 <code class="docutils literal notranslate"><span class="pre">1</span></code>이면 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>처럼 작동합니다. <em>initsigs</em>가 <code class="docutils literal notranslate"><span class="pre">0</span></code>이면, 시그널 처리기의 초기화 등록을 건너뛰는데, 파이썬이 내장될 때 유용할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_IsInitialized">
int <code class="sig-name descname">Py_IsInitialized</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_IsInitialized" title="정의 주소">¶</a></dt>
<dd><p>파이썬 인터프리터가 초기화되었으면 참(0이 아님)을 반환하고, 그렇지 않으면 거짓(0)을 반환합니다. <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 가 호출된 후, <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>가 다시 호출될 때까지 거짓을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_FinalizeEx">
int <code class="sig-name descname">Py_FinalizeEx</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_FinalizeEx" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>와 후속 파이썬/C API 함수 사용에 의해 수행된 모든 초기화를 실행 취소하고, <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>에 대한 마지막 호출 이후 만들어졌지만, 아직 삭제되지 않은 모든 서브 인터프리터(아래 <a class="reference internal" href="#c.Py_NewInterpreter" title="Py_NewInterpreter"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreter()</span></code></a>를 참조하십시오)를 제거합니다. 이상적으로, 이것은 파이썬 인터프리터가 할당한 모든 메모리를 해제합니다.  (먼저 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>를 다시 호출하지 않고) 두 번째로 호출하면 아무런 일도 하지 않습니다. 일반적으로 반환 값은 <code class="docutils literal notranslate"><span class="pre">0</span></code>입니다. 파이널리제이션 도중 에러가 발생하면 (버퍼링 된 데이터 플러시) <code class="docutils literal notranslate"><span class="pre">-1</span></code>이 반환됩니다.</p>
<p>이 함수는 여러 가지 이유로 제공됩니다. 내장 응용 프로그램이 응용 프로그램 자체를 다시 시작하지 않고 파이썬을 다시 시작하고 싶을 수 있습니다. 동적으로 로드할 수 있는 라이브러리(또는 DLL)에서 파이썬 인터프리터를 로드한 응용 프로그램은 DLL을 언로드 하기 전에 파이썬이 할당한 모든 메모리를 해제하고 싶을 수 있습니다. 응용 프로그램에서 메모리 누수를 찾는 동안 개발자는 응용 프로그램을 종료하기 전에 파이썬에서 할당한 모든 메모리를 해제하고 싶을 것입니다.</p>
<p><strong>버그와 주의 사항:</strong> 모듈의 모듈과 객체 파괴는 임의의 순서로 수행됩니다; 이로 인해 파괴자(<a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드)가 다른 객체(함수조차)나 모듈에 의존할 때 실패할 수 있습니다. 파이썬에서 로드한 동적으로 로드된 확장 모듈은 언로드 되지 않습니다. 파이썬 인터프리터가 할당한 소량의 메모리는 해제되지 않을 수 있습니다 (누수를 발견하면, 보고해 주십시오). 객체 간의 순환 참조에 묶여있는 메모리는 해제되지 않습니다. 확장 모듈이 할당한 일부 메모리는 해제되지 않을 수 있습니다. 일부 확장은 초기화 루틴이 두 번 이상 호출되면 제대로 작동하지 않을 수 있습니다; 응용 프로그램이 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>와 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a>를 두 번 이상 호출하면 이 문제가 발생할 수 있습니다.</p>
<p class="audit-hook">인자 없이 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">cpython._PySys_ClearAuditHooks</span></code> 를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_Finalize">
void <code class="sig-name descname">Py_Finalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_Finalize" title="정의 주소">¶</a></dt>
<dd><p>이것은 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a>의 이전 버전과 호환되는 반환 값을 무시하는 버전입니다.</p>
</dd></dl>

</div>
<div class="section" id="process-wide-parameters">
<h2>프로세스 전체 매개 변수<a class="headerlink" href="#process-wide-parameters" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="c.Py_SetStandardStreamEncoding">
int <code class="sig-name descname">Py_SetStandardStreamEncoding</code><span class="sig-paren">(</span>const char<em> *encoding</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_SetStandardStreamEncoding" title="정의 주소">¶</a></dt>
<dd><p id="index-17">이 함수는 (호출한다면) <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 전에 호출해야 합니다. <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-func docutils literal notranslate"><span class="pre">str.encode()</span></code></a>에서와 같은 의미로, 표준 IO에 사용할 인코딩과 에러 처리를 지정합니다.</p>
<p><span class="target" id="index-87"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONIOENCODING"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONIOENCODING</span></code></a> 값을 재정의(overrides)하고, 환경 변수가 작동하지 않을 때 내장(embedding) 코드가 IO 인코딩을 제어할 수 있도록 합니다.</p>
<p><em>encoding</em> 및/또는 <em>errors</em>는 <span class="target" id="index-88"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONIOENCODING"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONIOENCODING</span></code></a> 및/또는 기본값(다른 설정에 따라 다릅니다)을 사용하기 위해 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 수 있습니다.</p>
<p><a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a>은 이 (또는 다른) 설정과 관계없이 항상 &quot;backslashreplace&quot; 에러 처리기를 사용함에 유의하십시오.</p>
<p><a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a>가 호출되면, 이 함수는 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>에 대한 후속 호출에 영향을 미치기 위해 다시 호출되어야 합니다.</p>
<p>성공하면 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환하고, 에러 시 (예를 들어 인터프리터가 이미 초기화된 후 호출) 0이 아닌 값을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_SetProgramName">
void <code class="sig-name descname">Py_SetProgramName</code><span class="sig-paren">(</span>const wchar_t<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_SetProgramName" title="정의 주소">¶</a></dt>
<dd><p id="index-20">(호출된다면) 이 함수는 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>가 처음으로 호출되기 전에 호출되어야 합니다. 인터프리터에게 프로그램의 <code class="xref c c-func docutils literal notranslate"><span class="pre">main()</span></code> 함수에 대한 <code class="docutils literal notranslate"><span class="pre">argv[0]</span></code> 인자의 값을 알려줍니다 (와이드 문자로 변환됩니다). 이것은 <a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a>와 아래의 다른 함수에서 인터프리터 실행 파일과 관련된 파이썬 런타임 라이브러리를 찾는 데 사용됩니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'python'</span></code>입니다. 인자는 프로그램을 실행하는 동안 내용이 변경되지 않는 정적 저장소의 0으로 끝나는 와이드 문자열을 가리켜야 합니다. 파이썬 인터프리터의 코드는 이 저장소의 내용을 변경하지 않습니다.</p>
<p>바이트 문자열을 디코딩하여 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_*</span></code> 문자열을 얻는데 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a>을 사용합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetProgramName">
wchar* <code class="sig-name descname">Py_GetProgramName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetProgramName" title="정의 주소">¶</a></dt>
<dd><p id="index-21"><a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a> 으로 설정된 프로그램 이름이나 기본값을 반환합니다. 반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는 안 됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetPrefix">
wchar_t* <code class="sig-name descname">Py_GetPrefix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetPrefix" title="정의 주소">¶</a></dt>
<dd><p>설치된 플랫폼 독립적 파일에 대한 <em>prefix</em>를 반환합니다. 이것은 <a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a> 으로 설정된 프로그램 이름과 일부 환경 변수의 여러 복잡한 규칙을 통해 파생됩니다; 예를 들어, 프로그램 이름이 <code class="docutils literal notranslate"><span class="pre">'/usr/local/bin/python'</span></code>이면, prefix는 <code class="docutils literal notranslate"><span class="pre">'/usr/local'</span></code>입니다. 반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는 안 됩니다. 이는 최상위 수준 <code class="file docutils literal notranslate"><span class="pre">Makefile</span></code>의 <strong class="makevar">prefix</strong> 변수와 빌드 시 <strong class="program">configure</strong> 스크립트의 <code class="docutils literal notranslate"><span class="pre">--prefix</span></code> 인자에 해당합니다. 이 값은 파이썬 코드에서 <code class="docutils literal notranslate"><span class="pre">sys.prefix</span></code>로 사용할 수 있습니다. 유닉스에서만 유용합니다. 다음 함수도 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetExecPrefix">
wchar_t* <code class="sig-name descname">Py_GetExecPrefix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetExecPrefix" title="정의 주소">¶</a></dt>
<dd><p>설치된 플랫폼-<em>종속적</em> 파일에 대한 <em>exec-prefix</em>를 반환합니다. 이것은 <a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a> 으로 설정된 프로그램 이름과 일부 환경 변수의 여러 복잡한 규칙을 통해 파생됩니다; 예를 들어 프로그램 이름이 <code class="docutils literal notranslate"><span class="pre">'/usr/local/bin/python'</span></code>이면, exec-prefix는 <code class="docutils literal notranslate"><span class="pre">'/usr/local'</span></code>입니다. 반환된 문자열은 정적 저장소를 가리 킵니다; 호출자는 값을 수정해서는 안 됩니다. 이는 최상위 수준 <code class="file docutils literal notranslate"><span class="pre">Makefile</span></code>의 <strong class="makevar">exec_prefix</strong> 변수와 빌드 시 <strong class="program">configure</strong> 스크립트의 <code class="docutils literal notranslate"><span class="pre">--exec-prefix</span></code> 인자에 해당합니다. 이 값은 파이썬 코드에서 <code class="docutils literal notranslate"><span class="pre">sys.exec_prefix</span></code>로 사용할 수 있습니다. 유닉스에서만 유용합니다.</p>
<p>배경: exec-prefix는 플랫폼 종속적 파일(가령 실행 파일과 공유 라이브러리)이 다른 디렉터리 트리에 설치될 때 prefix와 다릅니다. 일반 설치에서, 플랫폼 종속적 파일은 <code class="file docutils literal notranslate"><span class="pre">/usr/local/plat</span></code> 서브 트리에 설치되고 플랫폼 독립적 파일은 <code class="file docutils literal notranslate"><span class="pre">/usr/local</span></code>에 설치될 수 있습니다.</p>
<p>일반적으로 말해서, 플랫폼은 하드웨어와 소프트웨어 제품군의 조합입니다, 예를 들어 Solaris 2.x 운영 체제를 실행하는 Sparc 기계들은 같은 플랫폼으로 간주하지만, Solaris 2.x를 실행하는 Intel 기계는 다른 플랫폼이며, 리눅스를 실행하는 Intel 기계는 또 다른 플랫폼입니다. 같은 운영 체제의 서로 다른 주 개정판도 일반적으로 다른 플랫폼을 형성합니다. 비 유닉스 운영 체제는 다른 이야기입니다; 이러한 시스템의 설치 전략이 너무 다르기 때문에 prefix와 exec-prefix는 의미가 없으며, 빈 문자열로 설정됩니다. 컴파일된 파이썬 바이트 코드 파일은 플랫폼 독립적임에 유의하십시오 (그러나 이들을 컴파일하는데 사용된 파이썬 버전에는 종속적입니다!).</p>
<p>시스템 관리자는 <code class="file docutils literal notranslate"><span class="pre">/usr/local/plat</span></code>을 각 플랫폼에 대해 다른 파일 시스템으로 사용하면서 플랫폼 간에 <code class="file docutils literal notranslate"><span class="pre">/usr/local</span></code>을 공유하도록 <strong class="program">mount</strong>나 <strong class="program">automount</strong> 프로그램을 구성하는 방법을 알 것입니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetProgramFullPath">
wchar_t* <code class="sig-name descname">Py_GetProgramFullPath</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetProgramFullPath" title="정의 주소">¶</a></dt>
<dd><p id="index-22">파이썬 실행 파일의 전체 프로그램 이름을 반환합니다; 이것은 프로그램 이름(위의 <a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a> 으로 설정됩니다)에서 기본 모듈 검색 경로를 파생하는 부작용으로 계산됩니다. 반환된 문자열은 정적 저장소를 가리 킵니다; 호출자는 값을 수정해서는 안 됩니다. 이 값은 파이썬 코드에서 <code class="docutils literal notranslate"><span class="pre">sys.executable</span></code>로 사용할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetPath">
wchar_t* <code class="sig-name descname">Py_GetPath</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetPath" title="정의 주소">¶</a></dt>
<dd><p id="index-23">기본 모듈 검색 경로를 반환합니다; 이것은 프로그램 이름(위의 <a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a> 으로 설정됩니다)과 일부 환경 변수에서 계산됩니다. 반환된 문자열은 플랫폼 종속적 구분자로 분할된 일련의 디렉터리 이름으로 구성됩니다. 구분자는 유닉스와 Mac OS X에서는 <code class="docutils literal notranslate"><span class="pre">':'</span></code>, 윈도우에서는 <code class="docutils literal notranslate"><span class="pre">';'</span></code>입니다. 반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는 안 됩니다. 리스트 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>는 인터프리터 시작 시 이 값으로 초기화됩니다; 모듈을 로드하기 위한 검색 경로를 변경하기 위해 나중에 수정할 수 있습니다 (그리고 보통 그렇게 합니다).</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_SetPath">
void <code class="sig-name descname">Py_SetPath</code><span class="sig-paren">(</span>const wchar_t<em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_SetPath" title="정의 주소">¶</a></dt>
<dd><p id="index-24">기본 모듈 검색 경로를 설정합니다. 이 함수가 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 이전에 호출되면, <a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a>는 기본 검색 경로를 계산하지 않고 대신 제공된 경로를 사용합니다. 이는 모든 모듈의 위치를 완전히 알고 있는 응용 프로그램에 파이썬이 내장된 경우 유용합니다. 경로 구성 요소는 플랫폼 종속적 구분자 문자(유닉스에서는 <code class="docutils literal notranslate"><span class="pre">':'</span></code>, 윈도우에서는 <code class="docutils literal notranslate"><span class="pre">';'</span></code>)로 구분해야 합니다.</p>
<p>또한 <a class="reference internal" href="../library/sys.html#sys.executable" title="sys.executable"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.executable</span></code></a>이 프로그램 전체 경로 (<a class="reference internal" href="#c.Py_GetProgramFullPath" title="Py_GetProgramFullPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetProgramFullPath()</span></code></a> 를 참조하십시오)로 설정되고 <a class="reference internal" href="../library/sys.html#sys.prefix" title="sys.prefix"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.prefix</span></code></a>와 <a class="reference internal" href="../library/sys.html#sys.exec_prefix" title="sys.exec_prefix"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.exec_prefix</span></code></a>가 비어있도록 합니다. <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>를 호출한 후 필요할 때 이를 수정하는 것은 호출자에게 달려 있습니다.</p>
<p>바이트 문자열을 디코딩하여 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_*</span></code> 문자열을 얻는데 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a>을 사용합니다.</p>
<p>경로 인자는 내부적으로 복사되므로, 호출이 완료된 후 호출자가 할당 해제할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>이제 프로그램 이름 대신 프로그램 전체 경로가 <a class="reference internal" href="../library/sys.html#sys.executable" title="sys.executable"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.executable</span></code></a>에 사용됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetVersion">
const char* <code class="sig-name descname">Py_GetVersion</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetVersion" title="정의 주소">¶</a></dt>
<dd><p>이 파이썬 인터프리터의 버전을 반환합니다. 이것은 다음과 같은 문자열입니다</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;3.0a5+ (py3k:63103M, May 12 2008, 00:53:55) </span><span class="se">\n</span><span class="s">[GCC 4.2.3]&quot;</span>
</pre></div>
</div>
<p id="index-25">첫 번째 단어(첫 번째 스페이스 문자까지)는 현재 파이썬 버전입니다; 처음 세 문자는 마침표로 구분된 주 버전과 부 버전입니다. 반환된 문자열은 정적 저장소를 가리 킵니다; 호출자는 값을 수정해서는 안 됩니다. 이 값은 파이썬 코드에서 <a class="reference internal" href="../library/sys.html#sys.version" title="sys.version"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.version</span></code></a>으로 사용할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetPlatform">
const char* <code class="sig-name descname">Py_GetPlatform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetPlatform" title="정의 주소">¶</a></dt>
<dd><p id="index-26">현재 플랫폼의 플랫폼 식별자를 반환합니다. 유닉스에서, 이것은 운영 체제의 &quot;공식적인&quot; 이름으로 구성되며, 소문자로 변환되고, 그 뒤에 주 개정 번호가 붙습니다; 예를 들어, SunOS 5.x라고도 하는 Solaris 2.x의 경우, 값은 <code class="docutils literal notranslate"><span class="pre">'sunos5'</span></code>입니다. Mac OS X에서는, <code class="docutils literal notranslate"><span class="pre">'darwin'</span></code>입니다. 윈도우에서는, <code class="docutils literal notranslate"><span class="pre">'win'</span></code>입니다. 반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는 안 됩니다. 이 값은 파이썬 코드에서 <code class="docutils literal notranslate"><span class="pre">sys.platform</span></code>으로 사용할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetCopyright">
const char* <code class="sig-name descname">Py_GetCopyright</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetCopyright" title="정의 주소">¶</a></dt>
<dd><p>현재 파이썬 버전에 대한 공식 저작권 문자열을 반환합니다, 예를 들어</p>
<p><code class="docutils literal notranslate"><span class="pre">'Copyright</span> <span class="pre">1991-1995</span> <span class="pre">Stichting</span> <span class="pre">Mathematisch</span> <span class="pre">Centrum,</span> <span class="pre">Amsterdam'</span></code></p>
<p id="index-27">반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는 안 됩니다. 이 값은 파이썬 코드에서 <code class="docutils literal notranslate"><span class="pre">sys.copyright</span></code>로 사용할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetCompiler">
const char* <code class="sig-name descname">Py_GetCompiler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetCompiler" title="정의 주소">¶</a></dt>
<dd><p>현재 파이썬 버전을 빌드하는 데 사용된 컴파일러 표시를 대괄호 감싸서 반환합니다, 예를 들면:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;[GCC 2.7.2.2]&quot;</span>
</pre></div>
</div>
<p id="index-28">반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는 안 됩니다. 이 값은 파이썬 코드에서 변수 <code class="docutils literal notranslate"><span class="pre">sys.version</span></code>의 일부로 제공됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetBuildInfo">
const char* <code class="sig-name descname">Py_GetBuildInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetBuildInfo" title="정의 주소">¶</a></dt>
<dd><p>현재 파이썬 인터프리터 인스턴스의 시퀀스 번호와 빌드 날짜 및 시간에 대한 정보를 반환합니다, 예를 들어</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;#67, Aug  1 1997, 22:34:28&quot;</span>
</pre></div>
</div>
<p id="index-29">반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는 안 됩니다. 이 값은 파이썬 코드에서 변수 <code class="docutils literal notranslate"><span class="pre">sys.version</span></code>의 일부로 제공됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PySys_SetArgvEx">
void <code class="sig-name descname">PySys_SetArgvEx</code><span class="sig-paren">(</span>int<em> argc</em>, wchar_t<em> **argv</em>, int<em> updatepath</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PySys_SetArgvEx" title="정의 주소">¶</a></dt>
<dd><p id="index-30"><em>argc</em> 및 <em>argv</em>에 기반해서 <a class="reference internal" href="../library/sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a>를 설정합니다. 이 매개 변수는 프로그램의 <code class="xref c c-func docutils literal notranslate"><span class="pre">main()</span></code> 함수에 전달된 것과 유사하지만, 첫 번째 항목이 파이썬 인터프리터를 호스팅하는 실행 파일이 아니라 실행될 스크립트 파일을 참조해야 한다는 차이점이 있습니다. 실행할 스크립트가 없으면, <em>argv</em>의 첫 번째 항목은 빈 문자열일 수 있습니다. 이 함수가 <a class="reference internal" href="../library/sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a> 초기화에 실패하면, <a class="reference internal" href="sys.html#c.Py_FatalError" title="Py_FatalError"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FatalError()</span></code></a>를 사용하여 치명적인 조건을 표시합니다.</p>
<p><em>updatepath</em>가 0이면, 여기까지가 이 함수가 하는 모든 일입니다. <em>updatepath</em>가 0이 아니면, 함수는 다음 알고리즘에 따라 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>도 수정합니다:</p>
<ul class="simple">
<li><p>기존 스크립트의 이름이 <code class="docutils literal notranslate"><span class="pre">argv[0]</span></code>으로 전달되면, 스크립트가 있는 디렉터리의 절대 경로가 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 앞에 추가됩니다.</p></li>
<li><p>그렇지 않으면 (즉, <em>argc</em>가 <code class="docutils literal notranslate"><span class="pre">0</span></code>이거나 <code class="docutils literal notranslate"><span class="pre">argv[0]</span></code>이 기존 파일 이름을 가리키지 않으면), <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 앞에 빈 문자열이 추가됩니다, 이는 현재 작업 디렉터리(<code class="docutils literal notranslate"><span class="pre">&quot;.&quot;</span></code>)를 앞에 추가하는 것과 같습니다.</p></li>
</ul>
<p>바이트 문자열을 디코딩하여 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_*</span></code> 문자열을 얻는데 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a>을 사용합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>단일 스크립트 실행 이외의 목적으로 파이썬 인터프리터를 내장하는 응용 프로그램은 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 <em>updatepath</em>로 전달하고, 원하는 대로 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>를 스스로 갱신하는 것이 좋습니다. <a class="reference external" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5983">CVE-2008-5983</a>을 참조하십시오.</p>
<p>3.1.3 이전 버전에서는, <a class="reference internal" href="#c.PySys_SetArgv" title="PySys_SetArgv"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgv()</span></code></a>를 호출한 후 첫 번째 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 요소를 수동으로 제거하여 같은 효과를 얻을 수 있습니다, 예를 들어 다음을 사용하여:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;import sys; sys.path.pop(0)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PySys_SetArgv">
void <code class="sig-name descname">PySys_SetArgv</code><span class="sig-paren">(</span>int<em> argc</em>, wchar_t<em> **argv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PySys_SetArgv" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <strong class="program">python</strong> 인터프리터가 <a class="reference internal" href="../using/cmdline.html#id2"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a>로 시작되지 않는 한 <em>updatepath</em>가 <code class="docutils literal notranslate"><span class="pre">1</span></code>로 설정된 <a class="reference internal" href="#c.PySys_SetArgvEx" title="PySys_SetArgvEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code></a>처럼 작동합니다.</p>
<p>바이트 문자열을 디코딩하여 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_*</span></code> 문자열을 얻는데 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a>을 사용합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><em>updatepath</em> 값은 <a class="reference internal" href="../using/cmdline.html#id2"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a>에 따라 다릅니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_SetPythonHome">
void <code class="sig-name descname">Py_SetPythonHome</code><span class="sig-paren">(</span>const wchar_t<em> *home</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_SetPythonHome" title="정의 주소">¶</a></dt>
<dd><p>기본 &quot;홈&quot; 디렉터리, 즉 표준 파이썬 라이브러리의 위치를 설정합니다. 인자 문자열의 의미는 <span class="target" id="index-89"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a> 을 참조하십시오.</p>
<p>인자는 프로그램을 실행하는 동안 내용이 변경되지 않는 정적 저장소에 있는 0으로 끝나는 문자열을 가리켜야 합니다. 파이썬 인터프리터의 코드는 이 저장소의 내용을 변경하지 않습니다.</p>
<p>바이트 문자열을 디코딩하여 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_*</span></code> 문자열을 얻는데 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a>을 사용합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetPythonHome">
w_char* <code class="sig-name descname">Py_GetPythonHome</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetPythonHome" title="정의 주소">¶</a></dt>
<dd><p>기본 &quot;홈&quot;, 즉 <a class="reference internal" href="#c.Py_SetPythonHome" title="Py_SetPythonHome"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetPythonHome()</span></code></a> 에 대한 이전 호출에서 설정한 값이나 설정되었다면 <span class="target" id="index-90"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a> 환경 변수의 값을 반환합니다.</p>
</dd></dl>

</div>
<div class="section" id="thread-state-and-the-global-interpreter-lock">
<span id="threads"></span><h2>스레드 상태와 전역 인터프리터 록<a class="headerlink" href="#thread-state-and-the-global-interpreter-lock" title="제목 주소">¶</a></h2>
<p id="index-33">파이썬 인터프리터는 완전히 스레드 안전하지 않습니다. 다중 스레드 파이썬 프로그램을 지원하기 위해, 파이썬 객체에 안전하게 액세스하기 전에 현재 스레드가 보유해야 하는 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">전역 인터프리터 록</span></a> 혹은 <a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>이라고 하는 전역 록이 있습니다. 록 없이는, 가장 간단한 연산조차도 다중 스레드 프로그램에서 문제를 일으킬 수 있습니다: 예를 들어, 두 스레드가 동시에 같은 객체의 참조 횟수를 증가시키면, 참조 횟수가 두 번이 아닌 한 번만 증가할 수 있습니다.</p>
<p id="index-34">따라서, <a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>을 획득한 스레드만 파이썬 객체에서 작동하거나 파이썬/C API 함수를 호출할 수 있다는 규칙이 있습니다. 동시 실행을 모방하기 위해 인터프리터는 정기적으로 스레드 전환을 시도합니다 (<a class="reference internal" href="../library/sys.html#sys.setswitchinterval" title="sys.setswitchinterval"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setswitchinterval()</span></code></a>을 참조하십시오). 록은 파일 읽기나 쓰기와 같은 잠재적인 블로킹 I/O 연산에 대해서도 해제되므로, 그동안 다른 파이썬 스레드가 실행될 수 있습니다.</p>
<p id="index-35">파이썬 인터프리터는 <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> 라는 데이터 구조체 내에 스레드 별 부기(bookkeeping) 정보를 보관합니다. 현재 <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> 를 가리키는 하나의 전역 변수도 있습니다: <a class="reference internal" href="#c.PyThreadState_Get" title="PyThreadState_Get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Get()</span></code></a>을 사용하여 얻을 수 있습니다.</p>
<div class="section" id="releasing-the-gil-from-extension-code">
<h3>확장 코드에서 GIL 해제하기<a class="headerlink" href="#releasing-the-gil-from-extension-code" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>을 조작하는 대부분의 확장 코드는 다음과 같은 간단한 구조로 되어 있습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Save</span> <span class="n">the</span> <span class="kr">thread</span> <span class="n">state</span> <span class="n">in</span> <span class="n">a</span> <span class="n">local</span> <span class="n">variable</span><span class="p">.</span>
<span class="n">Release</span> <span class="n">the</span> <span class="n">global</span> <span class="n">interpreter</span> <span class="n">lock</span><span class="p">.</span>
<span class="p">...</span> <span class="n">Do</span> <span class="n">some</span> <span class="n">blocking</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">operation</span> <span class="p">...</span>
<span class="n">Reacquire</span> <span class="n">the</span> <span class="n">global</span> <span class="n">interpreter</span> <span class="n">lock</span><span class="p">.</span>
<span class="n">Restore</span> <span class="n">the</span> <span class="kr">thread</span> <span class="n">state</span> <span class="n">from</span> <span class="n">the</span> <span class="n">local</span> <span class="n">variable</span><span class="p">.</span>
</pre></div>
</div>
<p>이것은 매우 일반적이어서 이를 단순화하기 위해 한 쌍의 매크로가 존재합니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Py_BEGIN_ALLOW_THREADS</span>
<span class="p">...</span> <span class="n">Do</span> <span class="n">some</span> <span class="n">blocking</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">operation</span> <span class="p">...</span>
<span class="n">Py_END_ALLOW_THREADS</span>
</pre></div>
</div>
<p id="index-36"><a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> 매크로는 새 블록을 열고 숨겨진 지역 변수를 선언합니다; <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> 매크로는 블록을 닫습니다.</p>
<p>위의 블록은 다음 코드로 확장됩니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyThreadState</span> <span class="o">*</span><span class="n">_save</span><span class="p">;</span>

<span class="n">_save</span> <span class="o">=</span> <span class="n">PyEval_SaveThread</span><span class="p">();</span>
<span class="p">...</span> <span class="n">Do</span> <span class="n">some</span> <span class="n">blocking</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">operation</span> <span class="p">...</span>
<span class="n">PyEval_RestoreThread</span><span class="p">(</span><span class="n">_save</span><span class="p">);</span>
</pre></div>
</div>
<p id="index-37">이 함수들의 작동 방식은 다음과 같습니다: 전역 인터프리터 록이 현재 스레드 상태에 대한 포인터를 보호하는 데 사용됩니다. 록을 해제하고 스레드 상태를 저장할 때, 록이 해제되기 전에 현재 스레드 상태 포인터를 가져와야 합니다 (다른 스레드가 즉시 록을 획득하고 전역 변수에 자신의 스레드 상태를 저장할 수 있기 때문입니다). 반대로, 록을 획득하고 스레드 상태를 복원할 때, 스레드 상태 포인터를 저장하기 전에 록을 획득해야 합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>시스템 I/O 함수 호출은 GIL을 릴리스하는 가장 일반적인 사용 사례이지만, 메모리 버퍼를 통해 작동하는 압축이나 암호화 함수와 같이, 파이썬 객체에 액세스할 필요가 없는 장기 실행 계산을 호출하기 전에도 유용할 수 있습니다. 예를 들어, 표준 <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a>와 <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 모듈은 데이터를 압축하거나 해싱할 때 GIL을 해제합니다.</p>
</div>
</div>
<div class="section" id="non-python-created-threads">
<span id="gilstate"></span><h3>파이썬이 만들지 않은 스레드<a class="headerlink" href="#non-python-created-threads" title="제목 주소">¶</a></h3>
<p>전용 파이썬 API(가령 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 모듈)를 사용하여 스레드를 만들면, 스레드 상태가 자동으로 연결되므로 위에 표시된 코드가 올바릅니다. 그러나, 스레드가 C에서 만들어질 때 (예를 들어 자체 스레드 관리 기능이 있는 제삼자 라이브러리에 의해), GIL을 보유하지 않고, 그들을 위한 스레드 상태 구조도 없습니다.</p>
<p>이러한 스레드에서 파이썬 코드를 호출해야 하면 (종종 앞서 언급한 제삼자 라이브러리에서 제공하는 콜백 API의 일부가 됩니다), 먼저 스레드 상태 자료 구조를 만들어서 인터프리터에 이러한 스레드를 등록한 다음, GIL을 획득하고, 마지막으로 파이썬/C API 사용을 시작하기 전에 스레드 상태 포인터를 저장합니다. 완료되면, 스레드 상태 포인터를 재설정하고, GIL을 해제한 다음, 마지막으로 스레드 상태 자료 구조를 해제해야 합니다.</p>
<p><a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>와 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 함수는 위의 모든 작업을 자동으로 수행합니다. C 스레드에서 파이썬을 호출하는 일반적인 관용구는 다음과 같습니다:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyGILState_STATE</span> <span class="n">gstate</span><span class="p">;</span>
<span class="n">gstate</span> <span class="o">=</span> <span class="n">PyGILState_Ensure</span><span class="p">();</span>

<span class="cm">/* 여기에서 파이썬 작업을 수행합니다. */</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">CallSomeFunction</span><span class="p">();</span>
<span class="cm">/* result를 평가하거나 예외를 처리합니다 */</span>

<span class="cm">/* 스레드를 해제합니다. 이 시점 이후로는 파이썬 API가 허용되지 않습니다. */</span>
<span class="n">PyGILState_Release</span><span class="p">(</span><span class="n">gstate</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_*()</span></code> 함수는 (<a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>에 의해 자동으로 만들어진) 전역 인터프리터 하나만 있다고 가정함에 유의하십시오. 파이썬은 추가 인터프리터를 만드는 것을 지원하지만 (<a class="reference internal" href="#c.Py_NewInterpreter" title="Py_NewInterpreter"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreter()</span></code></a>를 사용해서), 다중 인터프리터와 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_*()</span></code> API를 혼합하는 것은 지원되지 않습니다.</p>
</div>
<div class="section" id="cautions-about-fork">
<span id="fork-and-threads"></span><h3>fork()에 대한 주의 사항<a class="headerlink" href="#cautions-about-fork" title="제목 주소">¶</a></h3>
<p>스레드에 대해 주목해야 할 또 다른 중요한 점은 C <code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code> 호출 시 스레드의 동작입니다. <code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code>를 사용하는 대부분의 시스템에서는, 프로세스가 포크한 후에 포크를 발행한 스레드만 존재합니다. 이는 록을 처리해야 하는 방법과 CPython 런타임에 저장된 모든 상태 모두에 구체적인 영향을 미칩니다.</p>
<p>&quot;현재&quot; 스레드만 남아 있다는 사실은 다른 스레드가 보유한 록이 해제되지 않음을 의미합니다. 파이썬은 포크 전에 내부적으로 사용하는 록을 획득하고 나중에 해제하여 <a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a>에 대해 이 문제를 해결합니다. 또한, 자식의 모든 <a class="reference internal" href="../library/threading.html#lock-objects"><span class="std std-ref">Lock 객체</span></a>를 재설정합니다. 파이썬을 확장하거나 내장할 때, 포크 이전에 획득하거나 이후에 재설정해야 하는 추가(비 파이썬) 록을 파이썬에 알릴 방법이 없습니다. <code class="xref c c-func docutils literal notranslate"><span class="pre">pthread_atfork()</span></code>와 같은 OS 기능을 사용하여 같은 작업을 수행해야 합니다. 또한, 파이썬을 확장하거나 내장할 때, <a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a>를 통하지 않고 직접 <code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code>를 호출하면 (그리고 파이썬으로 반환하거나 파이썬을 호출하면), 포크 이후에 사라지는 스레드가 보유하는 파이썬의 내부 록 중 하나에 의해 교착 상태가 발생할 수 있습니다. <a class="reference internal" href="sys.html#c.PyOS_AfterFork_Child" title="PyOS_AfterFork_Child"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_AfterFork_Child()</span></code></a>는 필요한 록을 재설정하려고 하지만, 항상 할 수 있는 것은 아닙니다.</p>
<p>다른 모든 스레드가 사라진다는 사실은 또한 CPython의 런타임 상태가 <a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a>와 마찬가지로 적절하게 정리되어야 함을 의미합니다. 이것은 현재 인터프리터와 다른 모든 <a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> 객체에 속하는 다른 모든 <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> 객체를 파이널리제이션 하는 것을 의미합니다. 이것과 <a class="reference internal" href="#sub-interpreter-support"><span class="std std-ref">&quot;메인&quot; 인터프리터</span></a>의 특수한 특성으로 인해, <code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code>는 CPython 전역 런타임이 원래 초기화된 인터프리터의 &quot;메인&quot; 스레드에서만 호출되어야 합니다. 유일한 예외는 <code class="xref c c-func docutils literal notranslate"><span class="pre">exec()</span></code>가 그 후에 즉시 호출되는 경우입니다.</p>
</div>
<div class="section" id="high-level-api">
<h3>고수준 API<a class="headerlink" href="#high-level-api" title="제목 주소">¶</a></h3>
<p>다음은 C 확장 코드를 작성하거나 파이썬 인터프리터를 내장할 때 가장 일반적으로 사용되는 형과 함수입니다:</p>
<dl class="type">
<dt id="c.PyInterpreterState">
<code class="sig-name descname">PyInterpreterState</code><a class="headerlink" href="#c.PyInterpreterState" title="정의 주소">¶</a></dt>
<dd><p>이 자료 구조는 여러 협력 스레드가 공유하는 상태를 나타냅니다. 같은 인터프리터에 속하는 스레드는 모듈 관리와 몇 가지 다른 내부 항목을 공유합니다. 이 구조체에는 공개 멤버가 없습니다.</p>
<p>다른 인터프리터에 속한 스레드는 사용 가능한 메모리, 열린 파일 기술자 등과 같은 프로세스 상태를 제외하고는, 처음에는 아무것도 공유하지 않습니다. 전역 인터프리터 록은 어떤 인터프리터에 속해 있는지에 관계없이 모든 스레드에서 공유됩니다.</p>
</dd></dl>

<dl class="type">
<dt id="c.PyThreadState">
<code class="sig-name descname">PyThreadState</code><a class="headerlink" href="#c.PyThreadState" title="정의 주소">¶</a></dt>
<dd><p>이 자료 구조는 단일 스레드의 상태를 나타냅니다. 유일한 공용 데이터 멤버는 이 스레드의 인터프리터 상태를 가리키는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">interp</span></code>(<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span> <span class="pre">*</span></code></a>)입니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_InitThreads">
void <code class="sig-name descname">PyEval_InitThreads</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_InitThreads" title="정의 주소">¶</a></dt>
<dd><p id="index-38">아무것도 하지 않는 폐지된 함수.</p>
<p>파이썬 3.6과 이전 버전에서는, 이 함수가 존재하지 않으면 GIL을 만들었습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>이제 이 함수는 아무 작업도 수행하지 않습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이 함수는 이제 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>에 의해 호출되어서, 여러분은 더는 직접 호출할 필요가 없습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>이 함수는 더는 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 전에 호출할 수 없습니다.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.9, will be removed in version 3.11.</span></p>
</div>
<span class="target" id="index-39"></span></dd></dl>

<dl class="function">
<dt id="c.PyEval_ThreadsInitialized">
int <code class="sig-name descname">PyEval_ThreadsInitialized</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_ThreadsInitialized" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyEval_InitThreads" title="PyEval_InitThreads"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_InitThreads()</span></code></a>가 호출되었으면, 0이 아닌 값을 반환합니다. 이 함수는 GIL을 보유하지 않고 호출할 수 있어서, 단일 스레드를 실행할 때 록 API 호출을 회피하는 데 사용할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>은 이제 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>에 의해 초기화됩니다.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.9, will be removed in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_SaveThread">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a>* <code class="sig-name descname">PyEval_SaveThread</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_SaveThread" title="정의 주소">¶</a></dt>
<dd><p>(만들었다면) 전역 인터프리터 록을 해제하고 스레드 상태를 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 재설정하고, 이전 스레드 상태(<code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아닙니다)를 반환합니다. 록이 만들어졌다면, 현재 스레드가 록을 획득했어야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_RestoreThread">
void <code class="sig-name descname">PyEval_RestoreThread</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_RestoreThread" title="정의 주소">¶</a></dt>
<dd><p>(만들었다면) 전역 인터프리터 록을 획득하고 스레드 상태를 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니어야 하는 <em>tstate</em>로 설정합니다. 록이 만들어졌다면, 현재 스레드가 이를 획득하지 않았어야 합니다, 그렇지 않으면 교착 상태가 발생합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>런타임이 파이널리제이션 될 때 스레드에서 이 함수를 호출하면, 스레드가 파이썬에 의해 만들어지지 않았더라도 스레드가 종료됩니다. 원치 않는 종료를 방지하려면 <code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_IsFinalizing()</span></code>이나 <a class="reference internal" href="../library/sys.html#sys.is_finalizing" title="sys.is_finalizing"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code></a>을 사용하여 이 함수를 호출하기 전에 인터프리터가 파이널리제이션 되고 있는지 확인할 수 있습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_Get">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a>* <code class="sig-name descname">PyThreadState_Get</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Get" title="정의 주소">¶</a></dt>
<dd><p>현재 스레드 상태를 반환합니다. 전역 인터프리터 록을 보유해야 합니다. 현재 스레드 상태가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이면 치명적인 에러가 발생합니다 (그래서 호출자가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 확인할 필요가 없습니다).</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_Swap">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a>* <code class="sig-name descname">PyThreadState_Swap</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Swap" title="정의 주소">¶</a></dt>
<dd><p>현재 스레드 상태를 인자 <em>tstate</em>(<code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 수 있습니다)가 제공하는 스레드 상태와 스와프합니다. 전역 인터프리터 록을 보유해야 하며 해제되지 않습니다.</p>
</dd></dl>

<p>다음 함수는 스레드 로컬 저장소를 사용하며, 서브 인터프리터와 호환되지 않습니다:</p>
<dl class="function">
<dt id="c.PyGILState_Ensure">
PyGILState_STATE <code class="sig-name descname">PyGILState_Ensure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyGILState_Ensure" title="정의 주소">¶</a></dt>
<dd><p>현재 스레드가 파이썬의 현재 상태나 전역 인터프리터 록과 관계없이 파이썬 C API를 호출할 준비가 되었는지 확인합니다. 이것은 각 호출이 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>에 대한 호출과 쌍을 이루는 한 스레드에서 원하는 만큼 여러 번 호출될 수 있습니다. 일반적으로, 스레드 상태가 Release() 전에 이전 상태로 복원되는 한 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>와 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 호출 간에 다른 스레드 관련 API를 사용할 수 있습니다. 예를 들어, <a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a>와 <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> 매크로의 정상적인 사용은 허용됩니다.</p>
<p>반환 값은 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>가 호출되었을 때의 스레드 상태에 대한 불투명한 &quot;핸들&quot;이며, 파이썬이 같은 상태에 있도록 하려면 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>로 전달되어야 합니다. 재귀 호출이 허용되더라도, 이 핸들들은 공유할 수 <em>없습니다</em> - <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>에 대한 각 고유 호출은 자신의 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>에 대한 호출을 위해 핸들을 저장해야 합니다.</p>
<p>함수가 반환할 때, 현재 스레드는 GIL을 보유하고 임의의 파이썬 코드를 호출할 수 있습니다. 실패는 치명적인 에러입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>런타임이 파이널리제이션 될 때 스레드에서 이 함수를 호출하면, 스레드가 파이썬에 의해 만들어지지 않았더라도 스레드가 종료됩니다. 원치 않는 종료를 방지하려면 <code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_IsFinalizing()</span></code>이나 <a class="reference internal" href="../library/sys.html#sys.is_finalizing" title="sys.is_finalizing"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code></a>을 사용하여 이 함수를 호출하기 전에 인터프리터가 파이널리제이션 되고 있는지 확인할 수 있습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyGILState_Release">
void <code class="sig-name descname">PyGILState_Release</code><span class="sig-paren">(</span>PyGILState_STATE<span class="sig-paren">)</span><a class="headerlink" href="#c.PyGILState_Release" title="정의 주소">¶</a></dt>
<dd><p>이전에 획득 한 모든 자원을 해제합니다. 이 호출 후에, 파이썬의 상태는 해당 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 호출 이전과 같습니다 (그러나 일반적으로 이 상태는 호출자에게 알려지지 않아서, GILState API를 사용합니다).</p>
<p><a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>에 대한 모든 호출은 같은 스레드에서 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>에 대한 호출과 쌍을 이뤄야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyGILState_GetThisThreadState">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a>* <code class="sig-name descname">PyGILState_GetThisThreadState</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyGILState_GetThisThreadState" title="정의 주소">¶</a></dt>
<dd><p>이 스레드의 현재 스레드 상태를 가져옵니다. 현재 스레드에서 GILState API가 사용되지 않았으면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환할 수 있습니다. 메인 스레드에서 자동 스레드 상태 호출(auto-thread-state call)이 수행되지 않은 경우에도, 메인 스레드에는 항상 이러한 스레드 상태가 있음에 유의하십시오. 이것은 주로 도우미/진단 함수입니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyGILState_Check">
int <code class="sig-name descname">PyGILState_Check</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyGILState_Check" title="정의 주소">¶</a></dt>
<dd><p>현재 스레드가 GIL을 보유하고 있으면 <code class="docutils literal notranslate"><span class="pre">1</span></code>을 반환하고 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환합니다. 이 함수는 아무 때나 모든 스레드에서 호출할 수 있습니다. 파이썬 스레드 상태가 초기화되었고 현재 GIL을 보유하고 있을 때만 <code class="docutils literal notranslate"><span class="pre">1</span></code>을 반환합니다. 이것은 주로 도우미/진단 함수입니다. 예를 들어 콜백 컨텍스트나 메모리 할당 함수에서 유용할 수 있는데, GIL이 잠겨 있다는 것을 알면 호출자가 민감한 작업을 수행하거나 그렇지 않으면 다르게 동작하도록 할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<p>다음 매크로는 일반적으로 후행 세미콜론 없이 사용됩니다; 파이썬 소스 배포에서 사용 예를 찾으십시오.</p>
<dl class="macro">
<dt id="c.Py_BEGIN_ALLOW_THREADS">
<code class="sig-name descname">Py_BEGIN_ALLOW_THREADS</code><a class="headerlink" href="#c.Py_BEGIN_ALLOW_THREADS" title="정의 주소">¶</a></dt>
<dd><p>이 매크로는 <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">PyThreadState</span> <span class="pre">*_save;</span> <span class="pre">_save</span> <span class="pre">=</span> <span class="pre">PyEval_SaveThread();</span></code> 로 확장됩니다. 여는 중괄호가 포함되어 있음에 유의하십시오; 뒤따르는 <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> 매크로와 일치해야 합니다. 이 매크로에 대한 자세한 내용은 위를 참조하십시오.</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_END_ALLOW_THREADS">
<code class="sig-name descname">Py_END_ALLOW_THREADS</code><a class="headerlink" href="#c.Py_END_ALLOW_THREADS" title="정의 주소">¶</a></dt>
<dd><p>이 매크로는 <code class="docutils literal notranslate"><span class="pre">PyEval_RestoreThread(_save);</span> <span class="pre">}</span></code>로 확장됩니다. 닫는 중괄호가 포함되어 있음에 유의하십시오; 이전 <a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> 매크로와 일치해야 합니다. 이 매크로에 대한 자세한 내용은 위를 참조하십시오.</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_BLOCK_THREADS">
<code class="sig-name descname">Py_BLOCK_THREADS</code><a class="headerlink" href="#c.Py_BLOCK_THREADS" title="정의 주소">¶</a></dt>
<dd><p>이 매크로는 <code class="docutils literal notranslate"><span class="pre">PyEval_RestoreThread(_save);</span></code> 로 확장됩니다: 닫는 중괄호가 없는 <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a>와 동등합니다.</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_UNBLOCK_THREADS">
<code class="sig-name descname">Py_UNBLOCK_THREADS</code><a class="headerlink" href="#c.Py_UNBLOCK_THREADS" title="정의 주소">¶</a></dt>
<dd><p>이 매크로는 <code class="docutils literal notranslate"><span class="pre">_save</span> <span class="pre">=</span> <span class="pre">PyEval_SaveThread();</span></code> 로 확장됩니다: 여는 중괄호와 변수 선언이 없는 <a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a>와 동등합니다.</p>
</dd></dl>

</div>
<div class="section" id="low-level-api">
<h3>저수준 API<a class="headerlink" href="#low-level-api" title="제목 주소">¶</a></h3>
<p>다음 함수는 모두 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 이후에 호출되어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>는 이제 <a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>을 초기화합니다.</p>
</div>
<dl class="function">
<dt id="c.PyInterpreterState_New">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <code class="sig-name descname">PyInterpreterState_New</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_New" title="정의 주소">¶</a></dt>
<dd><p>새 인터프리터 상태 객체를 만듭니다. 전역 인터프리터 록을 보유할 필요는 없지만, 이 함수에 대한 호출을 직렬화해야 하면 보유할 수 있습니다.</p>
<p class="audit-hook">인자 없이 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">cpython.PyInterpreterState_New</span></code>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_Clear">
void <code class="sig-name descname">PyInterpreterState_Clear</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Clear" title="정의 주소">¶</a></dt>
<dd><p>인터프리터 상태 객체의 모든 정보를 재설정합니다. 전역 인터프리터 록을 보유해야 합니다.</p>
<p class="audit-hook">인자 없이 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">cpython.PyInterpreterState_Clear</span></code>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_Delete">
void <code class="sig-name descname">PyInterpreterState_Delete</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Delete" title="정의 주소">¶</a></dt>
<dd><p>인터프리터 상태 객체를 파괴합니다. 전역 인터프리터 록은 보유할 필요 없습니다. 인터프리터 상태는 <a class="reference internal" href="#c.PyInterpreterState_Clear" title="PyInterpreterState_Clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Clear()</span></code></a>에 대한 이전 호출로 재설정되었어야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_New">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a>* <code class="sig-name descname">PyThreadState_New</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_New" title="정의 주소">¶</a></dt>
<dd><p>주어진 인터프리터 객체에 속하는 새 스레드 상태 객체를 만듭니다. 전역 인터프리터 록을 보유할 필요는 없지만, 이 함수에 대한 호출을 직렬화해야 하면 보유할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_Clear">
void <code class="sig-name descname">PyThreadState_Clear</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Clear" title="정의 주소">¶</a></dt>
<dd><p>스레드 상태 객체의 모든 정보를 재설정합니다. 전역 인터프리터 록을 보유해야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>이 함수는 이제 <code class="xref c c-member docutils literal notranslate"><span class="pre">PyThreadState.on_delete</span></code> 콜백을 호출합니다. 이전에는, <a class="reference internal" href="#c.PyThreadState_Delete" title="PyThreadState_Delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Delete()</span></code></a>에서 호출했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_Delete">
void <code class="sig-name descname">PyThreadState_Delete</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Delete" title="정의 주소">¶</a></dt>
<dd><p>스레드 상태 객체를 파괴합니다. 전역 인터프리터 록은 보유할 필요 없습니다. 스레드 상태는 <a class="reference internal" href="#c.PyThreadState_Clear" title="PyThreadState_Clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Clear()</span></code></a>에 대한 이전 호출로 재설정되었어야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_DeleteCurrent">
void <code class="sig-name descname">PyThreadState_DeleteCurrent</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_DeleteCurrent" title="정의 주소">¶</a></dt>
<dd><p>현재 스레드 상태를 파괴하고 전역 인터프리터 록을 해제합니다. <a class="reference internal" href="#c.PyThreadState_Delete" title="PyThreadState_Delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Delete()</span></code></a>와 마찬가지로, 전역 인터프리터 록은 유지할 필요 없습니다. 스레드 상태는 <a class="reference internal" href="#c.PyThreadState_Clear" title="PyThreadState_Clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Clear()</span></code></a>에 대한 이전 호출로 재설정되었어야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_GetFrame">
<a class="reference internal" href="veryhigh.html#c.PyFrameObject" title="PyFrameObject">PyFrameObject</a>* <code class="sig-name descname">PyThreadState_GetFrame</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_GetFrame" title="정의 주소">¶</a></dt>
<dd><p>파이썬 스레드 상태 <em>tstate</em>의 현재 프레임을 가져옵니다.</p>
<p>강한 참조를 반환합니다. 현재 실행 중인 프레임이 없으면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
<p><a class="reference internal" href="reflection.html#c.PyEval_GetFrame" title="PyEval_GetFrame"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_GetFrame()</span></code></a>도 참조하십시오.</p>
<p><em>tstate</em>는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_GetID">
uint64_t <code class="sig-name descname">PyThreadState_GetID</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_GetID" title="정의 주소">¶</a></dt>
<dd><p>파이썬 스레드 상태 <em>tstate</em>의 고유한 스레드 상태 식별자를 가져옵니다.</p>
<p><em>tstate</em>는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_GetInterpreter">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <code class="sig-name descname">PyThreadState_GetInterpreter</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_GetInterpreter" title="정의 주소">¶</a></dt>
<dd><p>파이썬 스레드 상태 <em>tstate</em>의 인터프리터를 가져옵니다.</p>
<p><em>tstate</em>는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_Get">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <code class="sig-name descname">PyInterpreterState_Get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Get" title="정의 주소">¶</a></dt>
<dd><p>현재 인터프리터를 가져옵니다.</p>
<p>현재 파이썬 스레드 상태가 없거나 현재 인터프리터가 없으면 치명적인 에러를 발행합니다. NULL을 반환할 수 없습니다.</p>
<p>호출자는 GIL을 보유해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_GetID">
int64_t <code class="sig-name descname">PyInterpreterState_GetID</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_GetID" title="정의 주소">¶</a></dt>
<dd><p>인터프리터의 고유 ID를 반환합니다. 그렇게 하는데 에러가 발생하면 <code class="docutils literal notranslate"><span class="pre">-1</span></code>이 반환되고 에러가 설정됩니다.</p>
<p>호출자는 GIL을 보유해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_GetDict">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyInterpreterState_GetDict</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_GetDict" title="정의 주소">¶</a></dt>
<dd><p>인터프리터별 데이터가 저장될 수 있는 딕셔너리를 반환합니다. 이 함수가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환하면 예외는 발생하지 않았고 호출자는 인터프리터별 딕셔너리를 사용할 수 없다고 가정해야 합니다.</p>
<p>이것은 확장이 인터프리터별 상태 정보를 저장하는 데 사용해야 하는 <a class="reference internal" href="module.html#c.PyModule_GetState" title="PyModule_GetState"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_GetState()</span></code></a>를 대체하는 것이 아닙니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="type">
<dt id="c._PyFrameEvalFunction">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">(*_PyFrameEvalFunction)</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em>, <a class="reference internal" href="veryhigh.html#c.PyFrameObject" title="PyFrameObject">PyFrameObject</a><em> *frame</em>, int<em> throwflag</em><span class="sig-paren">)</span><a class="headerlink" href="#c._PyFrameEvalFunction" title="정의 주소">¶</a></dt>
<dd><p>프레임 평가 함수의 형.</p>
<p><em>throwflag</em> 매개 변수는 제너레이터의 <code class="docutils literal notranslate"><span class="pre">throw()</span></code> 메서드에서 사용됩니다: 0이 아니면, 현재 예외를 처리합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>이제 함수는 <em>tstate</em> 매개 변수를 취합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c._PyInterpreterState_GetEvalFrameFunc">
<a class="reference internal" href="#c._PyFrameEvalFunction" title="_PyFrameEvalFunction">_PyFrameEvalFunction</a> <code class="sig-name descname">_PyInterpreterState_GetEvalFrameFunc</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c._PyInterpreterState_GetEvalFrameFunc" title="정의 주소">¶</a></dt>
<dd><p>프레임 평가 함수를 가져옵니다.</p>
<p><span class="target" id="index-91"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0523"><strong>PEP 523</strong></a> &quot;CPython에 프레임 평가 API 추가&quot;를 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="sig-name descname">void _PyInterpreterState_SetEvalFrameFunc(PyInterpreterState *interp, _PyFrameEvalFunction eval_frame);</code></dt>
<dd><p>프레임 평가 함수를 설정합니다.</p>
<p><span class="target" id="index-92"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0523"><strong>PEP 523</strong></a> &quot;CPython에 프레임 평가 API 추가&quot;를 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_GetDict">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyThreadState_GetDict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_GetDict" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: Borrowed reference.</em><p>확장이 스레드별 상태 정보를 저장할 수 있는 딕셔너리를 반환합니다. 각 확장은 딕셔너리에 상태를 저장하는 데 사용할 고유 키를 사용해야 합니다. 현재 스레드 상태를 사용할 수 없을 때 이 함수를 호출해도 됩니다. 이 함수가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환하면, 예외는 발생하지 않았고 호출자는 현재 스레드 상태를 사용할 수 없다고 가정해야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_SetAsyncExc">
int <code class="sig-name descname">PyThreadState_SetAsyncExc</code><span class="sig-paren">(</span>unsigned long<em> id</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *exc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_SetAsyncExc" title="정의 주소">¶</a></dt>
<dd><p>스레드에서 비동기적으로 예외를 발생시킵니다. <em>id</em> 인자는 대상 스레드의 스레드 id입니다; <em>exc</em>는 발생시킬 예외 객체입니다. 이 함수는 <em>exc</em>에 대한 어떤 참조도 훔치지 않습니다. 순진한 오용을 방지하려면, 이를 호출하는 자체 C 확장을 작성해야 합니다. GIL을 보유한 채로 호출해야 합니다. 수정된 스레드 상태 수를 반환합니다; 일반적으로 1이지만, 스레드 id를 찾지 못하면 0이 됩니다. <em>exc</em>가 <code class="xref py py-const docutils literal notranslate"><span class="pre">NULL</span></code>이면, 스레드에 대해 계류 중인 예외가 (있다면) 지워집니다. 이것은 예외를 일으키지 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>id</em> 매개 변수의 형이 <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span></code>에서 <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>으로 변경되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_AcquireThread">
void <code class="sig-name descname">PyEval_AcquireThread</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_AcquireThread" title="정의 주소">¶</a></dt>
<dd><p>전역 인터프리터 록을 획득하고 현재 스레드 상태를 <em>tstate</em>로 설정합니다. <em>tstate</em>는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니어야 합니다. 록은 이전에 만들어진 것이어야 합니다. 이 스레드에 이미 록이 있으면, 교착 상태가 발생합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>런타임이 파이널리제이션 될 때 스레드에서 이 함수를 호출하면, 스레드가 파이썬에 의해 만들어지지 않았더라도 스레드가 종료됩니다. 원치 않는 종료를 방지하려면 <code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_IsFinalizing()</span></code>이나 <a class="reference internal" href="../library/sys.html#sys.is_finalizing" title="sys.is_finalizing"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code></a>을 사용하여 이 함수를 호출하기 전에 인터프리터가 파이널리제이션 되고 있는지 확인할 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a>, <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS()</span></code></a> 및 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>와 일관되도록 갱신되었으며, 인터프리터가 파이널리제이션 하는 동안 호출되면 현재 스레드를 종료합니다.</p>
</div>
<p><a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a>는 (스레드가 초기화되지 않았을 때조차) 항상 사용할 수 있는 고수준 함수입니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_ReleaseThread">
void <code class="sig-name descname">PyEval_ReleaseThread</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_ReleaseThread" title="정의 주소">¶</a></dt>
<dd><p>현재 스레드 상태를 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 재설정하고 전역 인터프리터 록을 해제합니다. 록은 이전에 만들어졌어야 하고 현재 스레드가 보유해야 합니다. <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니어야 하는 <em>tstate</em> 인자는 현재 스레드 상태를 나타내는지 확인하는 데만 사용됩니다 --- 그렇지 않으면, 치명적인 에러가 보고됩니다.</p>
<p><a class="reference internal" href="#c.PyEval_SaveThread" title="PyEval_SaveThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SaveThread()</span></code></a>는 (스레드가 초기화되지 않은 경우에조차) 항상 사용할 수 있는 고수준 함수입니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_AcquireLock">
void <code class="sig-name descname">PyEval_AcquireLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_AcquireLock" title="정의 주소">¶</a></dt>
<dd><p>전역 인터프리터 록을 획득합니다. 록은 이전에 만들어졌어야 합니다. 이 스레드에 이미 록이 있으면, 교착 상태가 발생합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.2부터 폐지: </span>이 함수는 현재 스레드 상태를 갱신하지 않습니다. 대신 <a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a>나 <a class="reference internal" href="#c.PyEval_AcquireThread" title="PyEval_AcquireThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_AcquireThread()</span></code></a>를 사용하십시오.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>런타임이 파이널리제이션 될 때 스레드에서 이 함수를 호출하면, 스레드가 파이썬에 의해 만들어지지 않았더라도 스레드가 종료됩니다. 원치 않는 종료를 방지하려면 <code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_IsFinalizing()</span></code>이나 <a class="reference internal" href="../library/sys.html#sys.is_finalizing" title="sys.is_finalizing"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code></a>을 사용하여 이 함수를 호출하기 전에 인터프리터가 파이널리제이션 되고 있는지 확인할 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a>, <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS()</span></code></a> 및 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>와 일관되도록 갱신되었으며, 인터프리터가 파이널리제이션 하는 동안 호출되면 현재 스레드를 종료합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_ReleaseLock">
void <code class="sig-name descname">PyEval_ReleaseLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_ReleaseLock" title="정의 주소">¶</a></dt>
<dd><p>전역 인터프리터 록을 해제합니다. 록은 이전에 만들어졌어야 합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.2부터 폐지: </span>이 함수는 현재 스레드 상태를 갱신하지 않습니다. 대신 <a class="reference internal" href="#c.PyEval_SaveThread" title="PyEval_SaveThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SaveThread()</span></code></a>나 <a class="reference internal" href="#c.PyEval_ReleaseThread" title="PyEval_ReleaseThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_ReleaseThread()</span></code></a>를 사용하십시오.</p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="sub-interpreter-support">
<span id="id1"></span><h2>서브 인터프리터 지원<a class="headerlink" href="#sub-interpreter-support" title="제목 주소">¶</a></h2>
<p>대부분의 경우, 단일 파이썬 인터프리터만 내장할 것입니다만, 같은 프로세스, 어쩌면 같은 스레드에서 여러 독립 인터프리터를 만들어야 하는 경우가 있습니다. 서브 인터프리터는 그렇게 할 수 있도록 합니다.</p>
<p>&quot;메인&quot; 인터프리터는 런타임이 초기화될 때 만들어지는 첫 번째 인터프리터입니다. 보통은 프로세스에서 유일한 파이썬 인터프리터입니다. 서브 인터프리터와 달리, 메인 인터프리터는 시그널 처리와 같은 고유한 프로세스 전역 책임을 갖습니다. 또한 런타임 초기화 동안 실행을 담당하며 일반적으로 런타임 파이널리제이션 동안 활성 인터프리터입니다. <a class="reference internal" href="#c.PyInterpreterState_Main" title="PyInterpreterState_Main"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Main()</span></code></a> 함수는 그것의 상태에 대한 포인터를 반환합니다.</p>
<p><a class="reference internal" href="#c.PyThreadState_Swap" title="PyThreadState_Swap"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Swap()</span></code></a> 함수를 사용하여 서브 인터프리터 간에 전환할 수 있습니다. 다음 함수를 사용하여 만들고 파괴할 수 있습니다:</p>
<dl class="function">
<dt id="c.Py_NewInterpreter">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a>* <code class="sig-name descname">Py_NewInterpreter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_NewInterpreter" title="정의 주소">¶</a></dt>
<dd><p id="index-42">새 서브 인터프리터를 만듭니다. 이것은 파이썬 코드 실행을 위한 (거의) 완전히 분리된 환경입니다. 특히, 새 인터프리터에는 기본 모듈 <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>, <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 및 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>를 포함하여, 모든 임포트 된 모듈의 개별, 독립 버전을 갖습니다. 로드된 모듈 테이블(<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>)과 모듈 검색 경로(<code class="docutils literal notranslate"><span class="pre">sys.path</span></code>)도 별개입니다. 새 환경에는 <code class="docutils literal notranslate"><span class="pre">sys.argv</span></code> 변수가 없습니다. 새로운 표준 I/O 스트림 파일 객체 <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> 및 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>을 갖습니다 (단, 같은 하부 파일 기술자를 참조합니다).</p>
<p>반환 값은 새 서브 인터프리터에서 만들어진 첫 번째 스레드 상태를 가리킵니다. 이 스레드 상태는 현재 스레드 상태에서 만들어집니다. 실제 스레드가 만들어지지 않음에 유의하십시오; 아래 스레드 상태에 대한 설명을 참조하십시오. 새 인터프리터를 만드는 데 실패하면, <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 반환됩니다; 예외 상태는 현재 스레드 상태에 저장되고 현재 스레드 상태가 없을 수 있어서 예외가 설정되지 않습니다. (다른 모든 파이썬/C API 함수와 마찬가지로, 전역 인터프리터 록을 이 함수를 호출하기 전에 보유해야 하며 반환될 때 계속 유지됩니다; 그러나, 대부분의 다른 파이썬/C API 함수와 달리, 진입할 때 현재 스레드 상태가 있을 필요는 없습니다.)</p>
<p id="index-43">확장 모듈은 다음과 같이 (서브) 인터프리터 간에 공유됩니다:</p>
<ul>
<li><p>다단계 초기화를 사용하는 모듈의 경우, 예를 들어 <a class="reference internal" href="module.html#c.PyModule_FromDefAndSpec" title="PyModule_FromDefAndSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_FromDefAndSpec()</span></code></a>, 각 인터프리터에 대해 별도의 모듈 객체가 만들어지고 초기화됩니다. C 수준 정적과 전역 변수만 이러한 모듈 객체 간에 공유됩니다.</p></li>
<li><p>단단계 초기화를 사용하는 모듈의 경우, 예를 들어 <a class="reference internal" href="module.html#c.PyModule_Create" title="PyModule_Create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_Create()</span></code></a>, 특정 확장이 처음 임포트 될 때, 정상적으로 초기화되고, 모듈 딕셔너리의 (얕은) 사본이 저장됩니다. 다른 (서브) 인터프리터가 같은 확장을 임포트 할 때, 새 모듈이 초기화되고 이 복사본의 내용으로 채워집니다; 확장의 <code class="docutils literal notranslate"><span class="pre">init</span></code> 함수는 호출되지 않습니다. 따라서 모듈 딕셔너리의 객체는 (서브) 인터프리터 간에 공유되어, 원치 않는 동작을 일으킬 수 있습니다 (아래 <a class="reference internal" href="#bugs-and-caveats">버그와 주의 사항</a>을 참조하십시오).</p>
<p>이것은 인터프리터가 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a>와 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>를 호출하여 완전히 다시 초기화된 후 확장을 임포트 할 때 일어나는 것과 다름에 유의하십시오; 이 경우, 확장의 <code class="docutils literal notranslate"><span class="pre">initmodule</span></code> 함수가 다시 <em>호출됩니다</em>. 다단계 초기화와 마찬가지로, 이는 C 수준의 정적과 전역 변수만 이러한 모듈 간에 공유됨을 의미합니다.</p>
</li>
</ul>
<span class="target" id="index-44"></span></dd></dl>

<dl class="function">
<dt id="c.Py_EndInterpreter">
void <code class="sig-name descname">Py_EndInterpreter</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_EndInterpreter" title="정의 주소">¶</a></dt>
<dd><p id="index-45">주어진 스레드 상태로 표현되는 (서브) 인터프리터를 파괴합니다. 주어진 스레드 상태는 현재 스레드 상태여야 합니다. 아래의 스레드 상태에 대한 설명을 참조하십시오. 호출이 반환되면, 현재 스레드 상태는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>입니다. 이 인터프리터와 관련된 모든 스레드 상태가 파괴됩니다. (전역 인터프리터 록을 이 함수를 호출하기 전에 보유해야 하며 반환될 때 여전히 유지됩니다.) <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a>는 그 시점에서 명시적으로 파괴되지 않은 모든 서브 인터프리터를 파괴합니다.</p>
</dd></dl>

<div class="section" id="bugs-and-caveats">
<h3>버그와 주의 사항<a class="headerlink" href="#bugs-and-caveats" title="제목 주소">¶</a></h3>
<p>서브 인터프리터(및 메인 인터프리터)는 같은 프로세스의 일부이기 때문에, 그들 간의 절연이 완벽하지 않습니다 --- 예를 들어, <a class="reference internal" href="../library/os.html#os.close" title="os.close"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.close()</span></code></a>와 같은 저수준 파일 연산을 사용하면 서로의 열린 파일에 (실수로 혹은 악의적으로) 영향을 미칠 수 있습니다. (서브) 인터프리터 간에 확장이 공유되는 방식 때문에, 일부 확장이 제대로 작동하지 않을 수 있습니다; 이것은 특히 단단계 초기화나 (정적) 전역 변수를 사용할 때 특히 그렇습니다. 한 서브 인터프리터에서 만든 객체를 다른 (서브) 인터프리터의 이름 공간에 삽입할 수 있습니다; 가능하면 피해야 합니다.</p>
<p>서브 인터프리터 간에 사용자 정의 함수, 메서드, 인스턴스 또는 클래스를 공유하지 않도록 특별한 주의를 기울여야 합니다. 이러한 객체에 의해 실행되는 임포트 연산은 잘못된 (서브) 인터프리터의 로드된 모듈 딕셔너리에 영향을 미칠 수 있기 때문입니다. 위의 것들에서 접근할 수 있는 객체를 공유하지 않는 것도 마찬가지로 중요합니다.</p>
<p>또한 이 기능을 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_*()</span></code> API와 결합하는 것은 까다로움에 유의하십시오. 이러한 API는, 서브 인터프리터의 존재로 인해 깨어진 가정인, 파이썬 스레드 상태와 OS 수준 스레드 사이의 일대일 관계를 가정하기 때문입니다. <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>와 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 호출의 일치하는 쌍 사이에 서브 인터프리터를 전환하지 않는 것이 좋습니다. 또한, 이러한 API를 사용하여 파이썬이 아닌 스레드에서 생성된 스레드에서 파이썬 코드를 호출할 수 있도록 하는 확장(가령 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>)은 서브 인터프리터를 사용할 때 망가질 수 있습니다.</p>
</div>
</div>
<div class="section" id="asynchronous-notifications">
<h2>비동기 알림<a class="headerlink" href="#asynchronous-notifications" title="제목 주소">¶</a></h2>
<p>메인 인터프리터 스레드에 비동기 알림을 보내는 메커니즘이 제공됩니다. 이러한 알림은 함수 포인터와 void 포인터 인자의 형태를 취합니다.</p>
<dl class="function">
<dt id="c.Py_AddPendingCall">
int <code class="sig-name descname">Py_AddPendingCall</code><span class="sig-paren">(</span>int (<em>*func</em>)(void *), void<em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_AddPendingCall" title="정의 주소">¶</a></dt>
<dd><p id="index-46">메인 인터프리터 스레드에서 호출할 함수를 예약합니다. 성공하면 <code class="docutils literal notranslate"><span class="pre">0</span></code>이 반환되고 <em>func</em>는 메인 스레드에서 호출되기 위해 큐에 추가됩니다. 실패 시, 예외 설정 없이 <code class="docutils literal notranslate"><span class="pre">-1</span></code>이 반환됩니다.</p>
<p>성공적으로 큐에 넣으면, <em>func</em>는 <em>arg</em> 인자를 사용하여 <em>결국</em> 메인 인터프리터 스레드에서 호출됩니다. 정상적으로 실행되는 파이썬 코드와 비교할 때 비동기적으로 호출되지만, 다음 두 조건이 모두 충족됩니다:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">바이트 코드</span></a> 경계에서;</p></li>
<li><p>메인 스레드가 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">전역 인터프리터 록</span></a>을 보유하면서 (따라서 <em>func</em>는 전체 C API를 사용할 수 있습니다).</p></li>
</ul>
<p><em>func</em>는 성공하면 <code class="docutils literal notranslate"><span class="pre">0</span></code>을, 실패하면 예외 설정과 함께 <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환해야 합니다. <em>func</em>는 다른 비동기 알림을 재귀적으로 수행하기 위해 중단되지 않지만, 전역 인터프리터 록이 해제되면 스레드를 전환하기 위해 여전히 중단될 수 있습니다.</p>
<p>이 함수는 실행하는 데 현재 스레드 상태가 필요하지 않으며, 전역 인터프리터 록이 필요하지 않습니다.</p>
<p>서브 인터프리터에서 이 함수를 호출하려면 호출자가 GIL을 보유해야 합니다. 그렇지 않으면, 함수 <em>func</em>가 잘못된 인터프리터에서 호출되도록 예약될 수 있습니다.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>이것은 매우 특별한 경우에만 유용한, 저수준 함수입니다. <em>func</em>가 가능한 한 빨리 호출된다는 보장은 없습니다. 메인 스레드가 시스템 호출을 실행 중이라 바쁘면, 시스템 호출이 반환되기 전에 <em>func</em>가 호출되지 않습니다. 이 함수는 일반적으로 임의의 C 스레드에서 파이썬 코드를 호출하는 데 적합하지 <strong>않습니다</strong>. 대신, <a class="reference internal" href="#gilstate"><span class="std std-ref">PyGILState API</span></a>를 사용하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>이 함수가 서브 인터프리터에서 호출되면, <em>func</em> 함수는 이제 메인 인터프리터에서 호출되지 않고 서브 인터프리터에서 호출되도록 예약됩니다. 이제 각 서브 인터프리터는 자체 예약된 호출 목록을 갖습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="profiling-and-tracing">
<span id="profiling"></span><h2>프로파일링과 추적<a class="headerlink" href="#profiling-and-tracing" title="제목 주소">¶</a></h2>
<p>파이썬 인터프리터는 프로파일링과 실행 추적 기능을 연결하기 위한 몇 가지 저수준 지원을 제공합니다. 프로파일링, 디버깅 및 커버리지 분석 도구에 사용됩니다.</p>
<p>이 C 인터페이스를 사용하면 프로파일링이나 추적 코드가 파이썬 수준의 콜러블 객체를 통해 호출하는 오버헤드를 피하고, 대신 직접 C 함수를 호출할 수 있습니다. 시설의 필수 어트리뷰트는 변경되지 않았습니다; 인터페이스는 추적 함수를 스레드별로 설치할 수 있도록 하며, 추적 함수에 보고되는 기본 이벤트는 이전 버전의 파이썬 수준 추적 함수에 보고된 것과 같습니다.</p>
<dl class="type">
<dt id="c.Py_tracefunc">
int <code class="sig-name descname">(*Py_tracefunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em>, <a class="reference internal" href="veryhigh.html#c.PyFrameObject" title="PyFrameObject">PyFrameObject</a><em> *frame</em>, int<em> what</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_tracefunc" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a>과 <a class="reference internal" href="#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a>를 사용하여 등록된 추적 함수의 형입니다. 첫 번째 매개 변수는 등록 함수에 <em>obj</em>로 전달된 객체이고, <em>frame</em>은 이벤트가 관련된 프레임 객체이고, <em>what</em>은 상수 <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_CALL</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_EXCEPTION</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_LINE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_RETURN</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_CALL</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_EXCEPTION</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_RETURN</span></code> 또는 <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_OPCODE</span></code> 중 하나이고, <em>arg</em>는 <em>what</em>의 값에 따라 다릅니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><em>what</em>의 값</p></th>
<th class="head"><p><em>arg</em>의 의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_CALL</span></code></p></td>
<td><p>항상 <a class="reference internal" href="none.html#c.Py_None" title="Py_None"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_None</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_EXCEPTION</span></code></p></td>
<td><p><a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>에서 반환된 예외 정보.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_LINE</span></code></p></td>
<td><p>항상 <a class="reference internal" href="none.html#c.Py_None" title="Py_None"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_None</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_RETURN</span></code></p></td>
<td><p>호출자에게 반환되는 값, 또는 예외로 인한 것이면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_CALL</span></code></p></td>
<td><p>호출되는 함수 객체.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_EXCEPTION</span></code></p></td>
<td><p>호출되는 함수 객체.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_RETURN</span></code></p></td>
<td><p>호출되는 함수 객체.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_OPCODE</span></code></p></td>
<td><p>항상 <a class="reference internal" href="none.html#c.Py_None" title="Py_None"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_None</span></code></a>.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_CALL">
int <code class="sig-name descname">PyTrace_CALL</code><a class="headerlink" href="#c.PyTrace_CALL" title="정의 주소">¶</a></dt>
<dd><p>함수나 메서드에 대한 새 호출이 보고되거나, 제너레이터에 대한 새 항목이 보고될 때 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 함수에 대한 <em>what</em> 매개 변수의 값. 제너레이터 함수에 대한 이터레이터의 생성은 해당 프레임의 파이썬 바이트 코드로의 제어 전송이 없기 때문에 보고되지 않음에 유의하십시오.</p>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_EXCEPTION">
int <code class="sig-name descname">PyTrace_EXCEPTION</code><a class="headerlink" href="#c.PyTrace_EXCEPTION" title="정의 주소">¶</a></dt>
<dd><p>예외가 발생했을 때 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 함수에 대한 <em>what</em> 매개 변수의 값. 콜백 함수는 실행되는 프레임 내에서 바이트 코드가 처리된 후 예외가 설정될 때 <em>what</em>에 대해 이 값으로 호출됩니다. 이것의 효과는 예외 전파로 인해 파이썬 스택이 되감기는 것입니다, 예외가 전파되어 각 프레임으로 반환할 때 콜백이 호출됩니다. 추적 함수만 이러한 이벤트를 수신합니다; 프로파일러에는 필요하지 않습니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_LINE">
int <code class="sig-name descname">PyTrace_LINE</code><a class="headerlink" href="#c.PyTrace_LINE" title="정의 주소">¶</a></dt>
<dd><p>줄 번호 이벤트가 보고될 때 <em>what</em> 매개 변수로 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 함수(하지만 프로파일링 함수는 아닙니다)에 전달되는 값. 해당 프레임의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_lines</span></code>를 <em>0</em>으로 설정하여 해당 프레임에 대해 비활성화 할 수 있습니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_RETURN">
int <code class="sig-name descname">PyTrace_RETURN</code><a class="headerlink" href="#c.PyTrace_RETURN" title="정의 주소">¶</a></dt>
<dd><p>호출이 반환되려고 할 때 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 함수에 대한 <em>what</em> 매개 변수의 값.</p>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_C_CALL">
int <code class="sig-name descname">PyTrace_C_CALL</code><a class="headerlink" href="#c.PyTrace_C_CALL" title="정의 주소">¶</a></dt>
<dd><p>C 함수가 호출되려고 할 때 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 함수에 대한 <em>what</em> 매개 변수의 값.</p>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_C_EXCEPTION">
int <code class="sig-name descname">PyTrace_C_EXCEPTION</code><a class="headerlink" href="#c.PyTrace_C_EXCEPTION" title="정의 주소">¶</a></dt>
<dd><p>C 함수에서 예외가 발생했을 때 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 함수에 대한 <em>what</em> 매개 변수의 값.</p>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_C_RETURN">
int <code class="sig-name descname">PyTrace_C_RETURN</code><a class="headerlink" href="#c.PyTrace_C_RETURN" title="정의 주소">¶</a></dt>
<dd><p>C 함수가 반환했을 때 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 함수에 대한 <em>what</em> 매개 변수의 값.</p>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_OPCODE">
int <code class="sig-name descname">PyTrace_OPCODE</code><a class="headerlink" href="#c.PyTrace_OPCODE" title="정의 주소">¶</a></dt>
<dd><p>새 옵코드가 실행되려고 할 때 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 함수(하지만 프로파일링 함수는 아닙니다)에 대한 <em>what</em> 매개 변수의 값. 이 이벤트는 기본적으로 방출되지 않습니다: 프레임의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_opcodes</span></code>를 <em>1</em>로 설정하여 명시적으로 요청해야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_SetProfile">
void <code class="sig-name descname">PyEval_SetProfile</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc">Py_tracefunc</a><em> func</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_SetProfile" title="정의 주소">¶</a></dt>
<dd><p>프로파일러 함수를 <em>func</em>로 설정합니다. <em>obj</em> 매개 변수는 첫 번째 매개 변수로 함수에 전달되며, 임의의 파이썬 객체나 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 수 있습니다. 프로파일 함수가 상태를 유지해야 하면, 스레드마다 <em>obj</em>에 다른 값을 사용하면 저장하기에 편리하고 스레드 안전한 위치를 제공합니다. 프로파일 함수는 <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_LINE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_OPCODE</span></code> 및 <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_EXCEPTION</span></code>을 제외한 모든 관찰되는 이벤트에 대해 호출됩니다.</p>
<p>호출자는 <a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>을 보유하고 있어야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_SetTrace">
void <code class="sig-name descname">PyEval_SetTrace</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc">Py_tracefunc</a><em> func</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_SetTrace" title="정의 주소">¶</a></dt>
<dd><p>추적 함수를 <em>func</em>로 설정합니다. 추적 함수가 줄 번호 이벤트와 옵코드별 이벤트를 수신하지만, 호출되는 C 함수 객체와 관련된 이벤트를 수신하지 않는다는 점을 제외하면, <a class="reference internal" href="#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a>과 유사합니다. <a class="reference internal" href="#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a>를 사용하여 등록된 모든 추적 함수는 <em>what</em> 매개 변수의 값으로 <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_CALL</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_EXCEPTION</span></code> 또는 <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_RETURN</span></code>을 수신하지 않습니다.</p>
<p>호출자는 <a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>을 보유하고 있어야 합니다.</p>
</dd></dl>

</div>
<div class="section" id="advanced-debugger-support">
<span id="advanced-debugging"></span><h2>고급 디버거 지원<a class="headerlink" href="#advanced-debugger-support" title="제목 주소">¶</a></h2>
<p>이 함수들은 고급 디버깅 도구에서만 사용하기 위한 것입니다.</p>
<dl class="function">
<dt id="c.PyInterpreterState_Head">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <code class="sig-name descname">PyInterpreterState_Head</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Head" title="정의 주소">¶</a></dt>
<dd><p>인터프리터 상태 객체들의 리스트의 머리에 있는 객체를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_Main">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <code class="sig-name descname">PyInterpreterState_Main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Main" title="정의 주소">¶</a></dt>
<dd><p>메인 인터프리터 상태 객체를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_Next">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <code class="sig-name descname">PyInterpreterState_Next</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Next" title="정의 주소">¶</a></dt>
<dd><p>인터프리터 상태 객체들의 리스트에서 <em>interp</em> 이후의 다음 인터프리터 상태 객체를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_ThreadHead">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a> * <code class="sig-name descname">PyInterpreterState_ThreadHead</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_ThreadHead" title="정의 주소">¶</a></dt>
<dd><p>인터프리터 <em>interp</em>와 관련된 스레드 리스트에서 첫 번째 <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> 객체에 대한 포인터를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_Next">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a>* <code class="sig-name descname">PyThreadState_Next</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Next" title="정의 주소">¶</a></dt>
<dd><p>같은 <a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> 객체에 속하는 모든 스레드 객체 리스트에서 <em>tstate</em> 이후의 다음 스레드 상태 객체를 반환합니다.</p>
</dd></dl>

</div>
<div class="section" id="thread-local-storage-support">
<span id="thread-local-storage"></span><h2>스레드 로컬 저장소 지원<a class="headerlink" href="#thread-local-storage-support" title="제목 주소">¶</a></h2>
<p>파이썬 인터프리터는 파이썬 수준의 스레드 로컬 저장소 API(<a class="reference internal" href="../library/threading.html#threading.local" title="threading.local"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.local</span></code></a>)를 지원하기 위해 하부 네이티브 TLS 구현을 래핑하는 스레드 로컬 저장소(TLS)에 대한 저수준 지원을 제공합니다. CPython C 수준 API는 pthread와 윈도우에서 제공하는 API와 유사합니다: 스레드 키와 함수를 사용하여 스레드 당 <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> 값을 연결합니다.</p>
<p>이러한 함수를 호출할 때 GIL을 보유할 필요는 <em>없습니다</em>; 그들은 자체 록을 제공합니다.</p>
<p><code class="file docutils literal notranslate"><span class="pre">Python.h</span></code>에는 TLS API 선언이 포함되어 있지 않음에 유의하십시오, 스레드 로컬 저장소를 사용하려면 <code class="file docutils literal notranslate"><span class="pre">pythread.h</span></code>를 포함해야 합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이러한 API 함수 중 어느 것도 <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> 값을 대신해서 메모리 관리를 처리하지 않습니다. 직접 할당하고 할당 해제해야 합니다. <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> 값이 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code></a> 이라면, 이 함수들은 참조 횟수 연산도 수행하지 않습니다.</p>
</div>
<div class="section" id="thread-specific-storage-tss-api">
<span id="thread-specific-storage-api"></span><h3>스레드별 저장소 (TSS - Thread Specific Storage) API<a class="headerlink" href="#thread-specific-storage-tss-api" title="제목 주소">¶</a></h3>
<p>CPython 인터프리터 내에서 기존 TLS API의 사용을 대체하기 위해 TSS API가 도입되었습니다. 이 API는 스레드 키를 나타내기 위해 <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> 대신 새로운 형 <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a>를 사용합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>&quot;CPython의 스레드-로컬 저장소를 위한 새로운 C-API&quot; (<span class="target" id="index-93"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0539"><strong>PEP 539</strong></a>)</p>
</div>
<dl class="type">
<dt id="c.Py_tss_t">
<code class="sig-name descname">Py_tss_t</code><a class="headerlink" href="#c.Py_tss_t" title="정의 주소">¶</a></dt>
<dd><p>이 자료 구조는 스레드 키의 상태를 나타내며, 정의는 하부 TLS 구현에 따라 달라질 수 있으며, 키의 초기화 상태를 나타내는 내부 필드가 있습니다. 이 구조체에는 공개 멤버가 없습니다.</p>
<p><a class="reference internal" href="stable.html#stable"><span class="std std-ref">Py_LIMITED_API</span></a>가 정의되지 않을 때, <a class="reference internal" href="#c.Py_tss_NEEDS_INIT" title="Py_tss_NEEDS_INIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_tss_NEEDS_INIT</span></code></a>로 이 형의 정적 할당이 허용됩니다.</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_tss_NEEDS_INIT">
<code class="sig-name descname">Py_tss_NEEDS_INIT</code><a class="headerlink" href="#c.Py_tss_NEEDS_INIT" title="정의 주소">¶</a></dt>
<dd><p>이 매크로는 <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> 변수의 초기화자(initializer)로 확장됩니다. 이 매크로는 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Py_LIMITED_API</span></a>에서 정의되지 않음에 유의하십시오.</p>
</dd></dl>

<div class="section" id="dynamic-allocation">
<h4>동적 할당<a class="headerlink" href="#dynamic-allocation" title="제목 주소">¶</a></h4>
<p><a class="reference internal" href="stable.html#stable"><span class="std std-ref">Py_LIMITED_API</span></a>로 빌드된 확장 모듈에 필요한, 빌드 시점에 구현이 불투명해서 형의 정적 할당이 불가능한 <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a>의 동적 할당.</p>
<dl class="function">
<dt id="c.PyThread_tss_alloc">
<a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t">Py_tss_t</a>* <code class="sig-name descname">PyThread_tss_alloc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_alloc" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.Py_tss_NEEDS_INIT" title="Py_tss_NEEDS_INIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_tss_NEEDS_INIT</span></code></a>로 초기화된 값과 같은 상태의 값을 반환하거나, 동적 할당 실패 시 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThread_tss_free">
void <code class="sig-name descname">PyThread_tss_free</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t">Py_tss_t</a><em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_free" title="정의 주소">¶</a></dt>
<dd><p>모든 관련 스레드 로컬의 대입을 해제하도록 <a class="reference internal" href="#c.PyThread_tss_delete" title="PyThread_tss_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_delete()</span></code></a>를 먼저 호출한 후, <a class="reference internal" href="#c.PyThread_tss_alloc" title="PyThread_tss_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_alloc()</span></code></a>에 의해 할당된 주어진 <em>key</em>를 할당 해제합니다. <em>key</em> 인자가 <cite>NULL</cite>이면 아무런 일도 하지 않습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>해제된 키는 매달린(dangling) 포인터가 됩니다, 키를 <cite>NULL</cite>로 재설정해야 합니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="methods">
<h4>메서드<a class="headerlink" href="#methods" title="제목 주소">¶</a></h4>
<p>이 함수들의 매개 변수 <em>key</em>는 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아니어야 합니다. 또한, 주어진 <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a>가 <a class="reference internal" href="#c.PyThread_tss_create" title="PyThread_tss_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_create()</span></code></a>로 초기화되지 않았으면, <a class="reference internal" href="#c.PyThread_tss_set" title="PyThread_tss_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_set()</span></code></a>과 <a class="reference internal" href="#c.PyThread_tss_get" title="PyThread_tss_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_get()</span></code></a>의 동작은 정의되지 않습니다.</p>
<dl class="function">
<dt id="c.PyThread_tss_is_created">
int <code class="sig-name descname">PyThread_tss_is_created</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t">Py_tss_t</a><em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_is_created" title="정의 주소">¶</a></dt>
<dd><p>주어진 <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a>가 <a class="reference internal" href="#c.PyThread_tss_create" title="PyThread_tss_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_create()</span></code></a>로 초기화되었으면 0이 아닌 값을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThread_tss_create">
int <code class="sig-name descname">PyThread_tss_create</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t">Py_tss_t</a><em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_create" title="정의 주소">¶</a></dt>
<dd><p>TSS 키 초기화에 성공하면 0 값을 반환합니다. <em>key</em> 인자가 가리키는 값이 <a class="reference internal" href="#c.Py_tss_NEEDS_INIT" title="Py_tss_NEEDS_INIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_tss_NEEDS_INIT</span></code></a>로 초기화되지 않으면 동작이 정의되지 않습니다. 이 함수는 같은 키에서 반복적으로 호출될 수 있습니다 -- 이미 초기화된 키에 대해 호출하면 아무런 일도 하지 않으며 즉시 성공을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThread_tss_delete">
void <code class="sig-name descname">PyThread_tss_delete</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t">Py_tss_t</a><em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_delete" title="정의 주소">¶</a></dt>
<dd><p>TSS 키를 삭제하여 모든 스레드에서 키와 관련된 값을 잊게 하고, 키의 초기화 상태를 초기화되지 않음으로 변경합니다. 파괴된 키는 <a class="reference internal" href="#c.PyThread_tss_create" title="PyThread_tss_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_create()</span></code></a>로 다시 초기화할 수 있습니다. 이 함수는 같은 키에서 반복적으로 호출될 수 있습니다 -- 이미 파괴된 키에 대해 호출하면 아무런 일도 하지 않습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThread_tss_set">
int <code class="sig-name descname">PyThread_tss_set</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t">Py_tss_t</a><em> *key</em>, void<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_set" title="정의 주소">¶</a></dt>
<dd><p>현재 스레드에서 <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> 값을 TSS 키와 성공적으로 연결했음을 나타내는 0 값을 반환합니다. 각 스레드에는 키에서 <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> 값으로의 고유한 매핑이 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThread_tss_get">
void* <code class="sig-name descname">PyThread_tss_get</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t">Py_tss_t</a><em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_get" title="정의 주소">¶</a></dt>
<dd><p>현재 스레드의 TSS 키와 관련된 <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> 값을 반환합니다. 현재 스레드에 키와 연결된 값이 없으면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 반환합니다.</p>
</dd></dl>

</div>
</div>
<div class="section" id="thread-local-storage-tls-api">
<span id="thread-local-storage-api"></span><h3>스레드 로컬 저장소 (TLS) API<a class="headerlink" href="#thread-local-storage-tls-api" title="제목 주소">¶</a></h3>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.7부터 폐지: </span>이 API는 <a class="reference internal" href="#thread-specific-storage-api"><span class="std std-ref">스레드별 저장소 (TSS) API</span></a>로 대체됩니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 버전의 API는 <code class="docutils literal notranslate"><span class="pre">int</span></code>로 안전하게 캐스트 할 수 없는 방식으로 네이티브 TLS 키가 정의된 플랫폼을 지원하지 않습니다. 이러한 플랫폼에서, <a class="reference internal" href="#c.PyThread_create_key" title="PyThread_create_key"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_create_key()</span></code></a>는 실패 상태로 즉시 반환되며, 다른 TLS 함수는 이러한 플랫폼에서 모두 아무런 일도 하지 않습니다.</p>
</div>
<p>위에서 언급한 호환성 문제로 인해, 이 버전의 API를 새 코드에서 사용해서는 안 됩니다.</p>
<dl class="function">
<dt id="c.PyThread_create_key">
int <code class="sig-name descname">PyThread_create_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_create_key" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.PyThread_delete_key">
void <code class="sig-name descname">PyThread_delete_key</code><span class="sig-paren">(</span>int<em> key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_delete_key" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.PyThread_set_key_value">
int <code class="sig-name descname">PyThread_set_key_value</code><span class="sig-paren">(</span>int<em> key</em>, void<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_set_key_value" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.PyThread_get_key_value">
void* <code class="sig-name descname">PyThread_get_key_value</code><span class="sig-paren">(</span>int<em> key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_get_key_value" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.PyThread_delete_key_value">
void <code class="sig-name descname">PyThread_delete_key_value</code><span class="sig-paren">(</span>int<em> key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_delete_key_value" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.PyThread_ReInitTLS">
void <code class="sig-name descname">PyThread_ReInitTLS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_ReInitTLS" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">초기화, 파이널리제이션 및 스레드</a><ul>
<li><a class="reference internal" href="#before-python-initialization">파이썬 초기화 전</a></li>
<li><a class="reference internal" href="#global-configuration-variables">전역 구성 변수</a></li>
<li><a class="reference internal" href="#initializing-and-finalizing-the-interpreter">인터프리터 초기화와 파이널리제이션</a></li>
<li><a class="reference internal" href="#process-wide-parameters">프로세스 전체 매개 변수</a></li>
<li><a class="reference internal" href="#thread-state-and-the-global-interpreter-lock">스레드 상태와 전역 인터프리터 록</a><ul>
<li><a class="reference internal" href="#releasing-the-gil-from-extension-code">확장 코드에서 GIL 해제하기</a></li>
<li><a class="reference internal" href="#non-python-created-threads">파이썬이 만들지 않은 스레드</a></li>
<li><a class="reference internal" href="#cautions-about-fork">fork()에 대한 주의 사항</a></li>
<li><a class="reference internal" href="#high-level-api">고수준 API</a></li>
<li><a class="reference internal" href="#low-level-api">저수준 API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sub-interpreter-support">서브 인터프리터 지원</a><ul>
<li><a class="reference internal" href="#bugs-and-caveats">버그와 주의 사항</a></li>
</ul>
</li>
<li><a class="reference internal" href="#asynchronous-notifications">비동기 알림</a></li>
<li><a class="reference internal" href="#profiling-and-tracing">프로파일링과 추적</a></li>
<li><a class="reference internal" href="#advanced-debugger-support">고급 디버거 지원</a></li>
<li><a class="reference internal" href="#thread-local-storage-support">스레드 로컬 저장소 지원</a><ul>
<li><a class="reference internal" href="#thread-specific-storage-tss-api">스레드별 저장소 (TSS - Thread Specific Storage) API</a><ul>
<li><a class="reference internal" href="#dynamic-allocation">동적 할당</a></li>
<li><a class="reference internal" href="#methods">메서드</a></li>
</ul>
</li>
<li><a class="reference internal" href="#thread-local-storage-tls-api">스레드 로컬 저장소 (TLS) API</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="datetime.html"
                        title="이전 장">DateTime 객체</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="init_config.html"
                        title="다음 장">파이썬 초기화 구성</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="init_config.html" title="파이썬 초기화 구성"
             >다음</a> |</li>
        <li class="right" >
          <a href="datetime.html" title="DateTime 객체"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2021, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>