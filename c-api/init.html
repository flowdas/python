
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>초기화, 파이널리제이션 및 스레드 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="파이썬 초기화 구성" href="init_config.html" />
    <link rel="prev" title="DateTime 객체" href="datetime.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/c-api/init.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="init_config.html" title="파이썬 초기화 구성"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="datetime.html" title="DateTime 객체"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬/C API 레퍼런스 설명서</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="initialization-finalization-and-threads">
<span id="initialization"></span><h1>초기화, 파이널리제이션 및 스레드<a class="headerlink" href="#initialization-finalization-and-threads" title="제목 주소">¶</a></h1>
<p><a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">파이썬 초기화 구성</span></a>도 참조하십시오.</p>
<div class="section" id="before-python-initialization">
<span id="pre-init-safe"></span><h2>파이썬 초기화 전<a class="headerlink" href="#before-python-initialization" title="제목 주소">¶</a></h2>
<p>파이썬을 내장한 응용 프로그램에서는, 다른 파이썬/C API 함수를 사용하기 전에 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 함수를 호출해야합니다; 몇 가지 함수와 <a class="reference internal" href="#global-conf-vars"><span class="std std-ref">전역 구성 변수</span></a>는 예외입니다.</p>
<p>파이썬이 초기화되기 전에 다음 함수를 안전하게 호출할 수 있습니다.:</p>
<ul class="simple">
<li><p>구성 함수:</p>
<ul>
<li><p><a class="reference internal" href="import.html#c.PyImport_AppendInittab" title="PyImport_AppendInittab"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_AppendInittab()</span></code></a></p></li>
<li><p><a class="reference internal" href="import.html#c.PyImport_ExtendInittab" title="PyImport_ExtendInittab"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ExtendInittab()</span></code></a></p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInitFrozenExtensions()</span></code></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyMem_SetAllocator" title="PyMem_SetAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetAllocator()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetupDebugHooks()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyObject_SetArenaAllocator" title="PyObject_SetArenaAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetArenaAllocator()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_SetPath" title="Py_SetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetPath()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_SetPythonHome" title="Py_SetPythonHome"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetPythonHome()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_SetStandardStreamEncoding" title="Py_SetStandardStreamEncoding"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetStandardStreamEncoding()</span></code></a></p></li>
<li><p><a class="reference internal" href="sys.html#c.PySys_AddWarnOption" title="PySys_AddWarnOption"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_AddWarnOption()</span></code></a></p></li>
<li><p><a class="reference internal" href="sys.html#c.PySys_AddXOption" title="PySys_AddXOption"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_AddXOption()</span></code></a></p></li>
<li><p><a class="reference internal" href="sys.html#c.PySys_ResetWarnOptions" title="PySys_ResetWarnOptions"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_ResetWarnOptions()</span></code></a></p></li>
</ul>
</li>
<li><p>정보 함수:</p>
<ul>
<li><p><a class="reference internal" href="#c.Py_IsInitialized" title="Py_IsInitialized"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_IsInitialized()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyMem_GetAllocator" title="PyMem_GetAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_GetAllocator()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyObject_GetArenaAllocator" title="PyObject_GetArenaAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetArenaAllocator()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetBuildInfo" title="Py_GetBuildInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetBuildInfo()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetCompiler" title="Py_GetCompiler"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetCompiler()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetCopyright" title="Py_GetCopyright"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetCopyright()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetPlatform" title="Py_GetPlatform"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPlatform()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.Py_GetVersion" title="Py_GetVersion"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetVersion()</span></code></a></p></li>
</ul>
</li>
<li><p>유틸리티:</p>
<ul>
<li><p><a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a></p></li>
</ul>
</li>
<li><p>메모리 할당자:</p>
<ul>
<li><p><a class="reference internal" href="memory.html#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawCalloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="memory.html#c.PyMem_RawFree" title="PyMem_RawFree"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawFree()</span></code></a></p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>다음 함수는 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 전에 <strong>호출하면 안됩니다</strong>: <a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EncodeLocale()</span></code></a>, <a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a>, <a class="reference internal" href="#c.Py_GetPrefix" title="Py_GetPrefix"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPrefix()</span></code></a>, <a class="reference internal" href="#c.Py_GetExecPrefix" title="Py_GetExecPrefix"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetExecPrefix()</span></code></a>, <a class="reference internal" href="#c.Py_GetProgramFullPath" title="Py_GetProgramFullPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetProgramFullPath()</span></code></a>, <a class="reference internal" href="#c.Py_GetPythonHome" title="Py_GetPythonHome"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPythonHome()</span></code></a>, <a class="reference internal" href="#c.Py_GetProgramName" title="Py_GetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetProgramName()</span></code></a> 및 <a class="reference internal" href="#c.PyEval_InitThreads" title="PyEval_InitThreads"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_InitThreads()</span></code></a>.</p>
</div>
</div>
<div class="section" id="global-configuration-variables">
<span id="global-conf-vars"></span><h2>전역 구성 변수<a class="headerlink" href="#global-configuration-variables" title="제목 주소">¶</a></h2>
<p>파이썬에는 다양한 기능과 옵션을 제어하기위한 전역 구성 변수가 있습니다. 기본적으로, 이러한 플래그는 <a class="reference internal" href="../using/cmdline.html#using-on-interface-options"><span class="std std-ref">명령 줄 옵션</span></a>에 의해 제어됩니다.</p>
<p>옵션에 의해 플래그가 설정되면, 플래그 값은 옵션이 설정된 횟수입니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">-b</span></code>는 <a class="reference internal" href="#c.Py_BytesWarningFlag" title="Py_BytesWarningFlag"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_BytesWarningFlag</span></code></a>를 1로 설정하고 <code class="docutils literal notranslate"><span class="pre">-bb</span></code>는 <a class="reference internal" href="#c.Py_BytesWarningFlag" title="Py_BytesWarningFlag"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_BytesWarningFlag</span></code></a>를 2로 설정합니다.</p>
<dl class="var">
<dt id="c.Py_BytesWarningFlag">
<code class="sig-name descname">Py_BytesWarningFlag</code><a class="headerlink" href="#c.Py_BytesWarningFlag" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>나 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>와 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>을, 또는 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>를 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>와 비교할 때 경고를 발행합니다. <code class="docutils literal notranslate"><span class="pre">2</span></code>보다 크거나 같으면 에러를 발행합니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-b"><code class="xref std std-option docutils literal notranslate"><span class="pre">-b</span></code></a> 옵션으로 설정합니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_DebugFlag">
<code class="sig-name descname">Py_DebugFlag</code><a class="headerlink" href="#c.Py_DebugFlag" title="정의 주소">¶</a></dt>
<dd><p>구문 분석기 디버깅 출력을 켭니다 (전문가 전용, 컴파일 옵션에 의존합니다).</p>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-d"><code class="xref std std-option docutils literal notranslate"><span class="pre">-d</span></code></a> 옵션과 <span class="target" id="index-66"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDEBUG"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDEBUG</span></code></a> 환경 변수로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_DontWriteBytecodeFlag">
<code class="sig-name descname">Py_DontWriteBytecodeFlag</code><a class="headerlink" href="#c.Py_DontWriteBytecodeFlag" title="정의 주소">¶</a></dt>
<dd><p>0이 아닌 값으로 설정하면, 파이썬은 소스 모듈을 임포트 할 때 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일을 쓰려고하지 않습니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#id1"><code class="xref std std-option docutils literal notranslate"><span class="pre">-B</span></code></a> 옵션과 <span class="target" id="index-67"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDONTWRITEBYTECODE</span></code></a> 환경 변수로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_FrozenFlag">
<code class="sig-name descname">Py_FrozenFlag</code><a class="headerlink" href="#c.Py_FrozenFlag" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a>에서 모듈 검색 경로를 계산할 때 에러 메시지를 표시하지 않습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">_freeze_importlib</span></code>와 <code class="docutils literal notranslate"><span class="pre">frozenmain</span></code> 프로그램에서 사용하는 개인 플래그입니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_HashRandomizationFlag">
<code class="sig-name descname">Py_HashRandomizationFlag</code><a class="headerlink" href="#c.Py_HashRandomizationFlag" title="정의 주소">¶</a></dt>
<dd><p><span class="target" id="index-68"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a> 환경 변수가 비어 있지 않은 문자열로 설정되면 <code class="docutils literal notranslate"><span class="pre">1</span></code>로 설정합니다.</p>
<p>플래그가 0이 아니면, <span class="target" id="index-69"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a> 환경 변수를 읽어 비밀 해시 시드를 초기화합니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_IgnoreEnvironmentFlag">
<code class="sig-name descname">Py_IgnoreEnvironmentFlag</code><a class="headerlink" href="#c.Py_IgnoreEnvironmentFlag" title="정의 주소">¶</a></dt>
<dd><p>설정될 수 있는 모든 <span class="target" id="index-70"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHON*</span></code> 환경 변수 (예를 들어 <span class="target" id="index-71"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a>와 <span class="target" id="index-72"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a>)를 무시합니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-e"><code class="xref std std-option docutils literal notranslate"><span class="pre">-E</span></code></a>와 <a class="reference internal" href="../using/cmdline.html#id2"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> 옵션으로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_InspectFlag">
<code class="sig-name descname">Py_InspectFlag</code><a class="headerlink" href="#c.Py_InspectFlag" title="정의 주소">¶</a></dt>
<dd><p>스크립트가 첫 번째 인자로 전달되거나 <a class="reference internal" href="../using/cmdline.html#cmdoption-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c</span></code></a> 옵션을 사용할 때, <a class="reference internal" href="../library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a>가 터미널로 보이지 않더라도 스크립트나 명령을 실행한 후 대화 형 모드로 들어갑니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a> 옵션과 <span class="target" id="index-73"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONINSPECT"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONINSPECT</span></code></a> 환경 변수로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_InteractiveFlag">
<code class="sig-name descname">Py_InteractiveFlag</code><a class="headerlink" href="#c.Py_InteractiveFlag" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a> 옵션으로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_IsolatedFlag">
<code class="sig-name descname">Py_IsolatedFlag</code><a class="headerlink" href="#c.Py_IsolatedFlag" title="정의 주소">¶</a></dt>
<dd><p>격리 모드로 파이썬을 실행합니다. 격리 모드에서 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>는 스크립트의 디렉터리도 사용자의 site-packages 디렉터리도 포함하지 않습니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#id2"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> 옵션으로 설정됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="var">
<dt id="c.Py_LegacyWindowsFSEncodingFlag">
<code class="sig-name descname">Py_LegacyWindowsFSEncodingFlag</code><a class="headerlink" href="#c.Py_LegacyWindowsFSEncodingFlag" title="정의 주소">¶</a></dt>
<dd><p>플래그가 0이 아니면, 파일 시스템 인코딩에 UTF-8 인코딩 대신 <code class="docutils literal notranslate"><span class="pre">mbcs</span></code> 인코딩을 사용합니다.</p>
<p><span class="target" id="index-74"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONLEGACYWINDOWSFSENCODING"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONLEGACYWINDOWSFSENCODING</span></code></a> 환경 변수가 비어 있지 않은 문자열로 설정되면 <code class="docutils literal notranslate"><span class="pre">1</span></code>로 설정합니다.</p>
<p>자세한 내용은 <span class="target" id="index-75"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0529"><strong>PEP 529</strong></a>를 참조하십시오.</p>
<p class="availability"><a class="reference internal" href="../library/intro.html#availability"><span class="std std-ref">가용성</span></a>: 윈도우.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_LegacyWindowsStdioFlag">
<code class="sig-name descname">Py_LegacyWindowsStdioFlag</code><a class="headerlink" href="#c.Py_LegacyWindowsStdioFlag" title="정의 주소">¶</a></dt>
<dd><p>플래그가 0이 아니면, <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 표준 스트림을 위해 <code class="xref py py-class docutils literal notranslate"><span class="pre">WindowsConsoleIO</span></code> 대신 <a class="reference internal" href="../library/io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a>를 사용합니다.</p>
<p><span class="target" id="index-76"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONLEGACYWINDOWSSTDIO"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONLEGACYWINDOWSSTDIO</span></code></a> 환경 변수가 비어 있지 않은 문자열로 설정되면 <code class="docutils literal notranslate"><span class="pre">1</span></code>로 설정합니다.</p>
<p>자세한 내용은 <span class="target" id="index-77"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0528"><strong>PEP 528</strong></a>을 참조하십시오.</p>
<p class="availability"><a class="reference internal" href="../library/intro.html#availability"><span class="std std-ref">가용성</span></a>: 윈도우.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_NoSiteFlag">
<code class="sig-name descname">Py_NoSiteFlag</code><a class="headerlink" href="#c.Py_NoSiteFlag" title="정의 주소">¶</a></dt>
<dd><p>모듈 <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 임포트와 이에 수반되는 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>의 사이트 종속적인 조작을 비활성화합니다. 또한 나중에 <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a>를 명시적으로 임포트할 때도 이러한 조작을 비활성화합니다 (트리거하려면 <a class="reference internal" href="../library/site.html#site.main" title="site.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">site.main()</span></code></a>을 호출하십시오).</p>
<p><a class="reference internal" href="../using/cmdline.html#id3"><code class="xref std std-option docutils literal notranslate"><span class="pre">-S</span></code></a> 옵션으로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_NoUserSiteDirectory">
<code class="sig-name descname">Py_NoUserSiteDirectory</code><a class="headerlink" href="#c.Py_NoUserSiteDirectory" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/site.html#site.USER_SITE" title="site.USER_SITE"><code class="xref py py-data docutils literal notranslate"><span class="pre">사용자</span> <span class="pre">site-packages</span> <span class="pre">디렉터리</span></code></a>를 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>에 추가하지 않습니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-s"><code class="xref std std-option docutils literal notranslate"><span class="pre">-s</span></code></a>와 <a class="reference internal" href="../using/cmdline.html#id2"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> 옵션, 그리고 <span class="target" id="index-78"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONNOUSERSITE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONNOUSERSITE</span></code></a> 환경 변수로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_OptimizeFlag">
<code class="sig-name descname">Py_OptimizeFlag</code><a class="headerlink" href="#c.Py_OptimizeFlag" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 옵션과 <span class="target" id="index-79"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONOPTIMIZE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONOPTIMIZE</span></code></a> 환경 변수로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_QuietFlag">
<code class="sig-name descname">Py_QuietFlag</code><a class="headerlink" href="#c.Py_QuietFlag" title="정의 주소">¶</a></dt>
<dd><p>대화형 모드에서도 저작권과 버전 메시지를 표시하지 않습니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-q"><code class="xref std std-option docutils literal notranslate"><span class="pre">-q</span></code></a> 옵션으로 설정됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="var">
<dt id="c.Py_UnbufferedStdioFlag">
<code class="sig-name descname">Py_UnbufferedStdioFlag</code><a class="headerlink" href="#c.Py_UnbufferedStdioFlag" title="정의 주소">¶</a></dt>
<dd><p>stdout과 stderr 스트림을 버퍼링 해제하도록 강제합니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-u"><code class="xref std std-option docutils literal notranslate"><span class="pre">-u</span></code></a> 옵션과 <span class="target" id="index-80"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONUNBUFFERED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONUNBUFFERED</span></code></a> 환경 변수로 설정됩니다.</p>
</dd></dl>

<dl class="var">
<dt id="c.Py_VerboseFlag">
<code class="sig-name descname">Py_VerboseFlag</code><a class="headerlink" href="#c.Py_VerboseFlag" title="정의 주소">¶</a></dt>
<dd><p>모듈이 초기화 될 때마다, 로드 된 위치(파일명이나 또는 내장 모듈)를 표시하는 메시지를 인쇄합니다. <code class="docutils literal notranslate"><span class="pre">2</span></code>보다 크거나 같으면, 모듈을 검색할 때 검사되는 각 파일에 대한 메시지를 인쇄합니다. 또한 종료시 모듈 정리에 대한 정보를 제공합니다.</p>
<p><a class="reference internal" href="../using/cmdline.html#id4"><code class="xref std std-option docutils literal notranslate"><span class="pre">-v</span></code></a> 옵션과 <span class="target" id="index-81"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONVERBOSE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONVERBOSE</span></code></a> 환경 변수로 설정됩니다.</p>
</dd></dl>

</div>
<div class="section" id="initializing-and-finalizing-the-interpreter">
<h2>인터프리터 초기화와 파이널리제이션<a class="headerlink" href="#initializing-and-finalizing-the-interpreter" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="c.Py_Initialize">
void <code class="sig-name descname">Py_Initialize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_Initialize" title="정의 주소">¶</a></dt>
<dd><p id="index-16">파이썬 인터프리터를 초기화합니다. 파이썬을 내장하는 응용 프로그램에서는, 다른 파이썬/C API 함수를 사용하기 전에 호출해야합니다; 몇 가지 예외는 <a class="reference internal" href="#pre-init-safe"><span class="std std-ref">파이썬 초기화 전</span></a>을 참조하십시오.</p>
<p>이것은 로드된 모듈의 테이블(<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>)을 초기화하고, 기반 모듈 <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>, <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 및 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>를 만듭니다. 또한 모듈 검색 경로(<code class="docutils literal notranslate"><span class="pre">sys.path</span></code>)를 초기화합니다. <code class="docutils literal notranslate"><span class="pre">sys.argv</span></code>는 설정하지 않습니다; 이를 위해서는 <a class="reference internal" href="#c.PySys_SetArgvEx" title="PySys_SetArgvEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code></a>를 사용하십시오.  (<a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a>를 먼저 호출하지 않고) 두 번째로 호출하면 아무런 일도 하지 않습니다. 반환 값이 없습니다; 초기화에 실패하면 치명적인 에러입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>윈도우에서, 콘솔 모드를 <code class="docutils literal notranslate"><span class="pre">O_TEXT</span></code>에서 <code class="docutils literal notranslate"><span class="pre">O_BINARY</span></code>로 변경합나디, C 런타임을 사용하는 콘솔의 비 파이썬 사용에도 영향을 미칩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_InitializeEx">
void <code class="sig-name descname">Py_InitializeEx</code><span class="sig-paren">(</span>int<em> initsigs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_InitializeEx" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <em>initsigs</em>가 <code class="docutils literal notranslate"><span class="pre">1</span></code>이면 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>처럼 작동합니다. <em>initsigs</em>가 <code class="docutils literal notranslate"><span class="pre">0</span></code>이면, 시그널 처리기의 초기화 등록을 건너뛰는데, 파이썬이 내장될 때 유용할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_IsInitialized">
int <code class="sig-name descname">Py_IsInitialized</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_IsInitialized" title="정의 주소">¶</a></dt>
<dd><p>파이썬 인터프리터가 초기화되었으면 참(0이 아님)을 반환하고, 그렇지 않으면 거짓(0)을 반환합니다. <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a>가 호출 된 후, <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>가 다시 호출될 때까지 거짓을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_FinalizeEx">
int <code class="sig-name descname">Py_FinalizeEx</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_FinalizeEx" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>와 후속 파이썬/C API 함수 사용에 의해 수행된 모든 초기화를 실행 취소하고, <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>에 대한 마지막 호출 이후 만들어졌지만 아직 삭제되지 않은 모든 서브 인터프리터(아래 <a class="reference internal" href="#c.Py_NewInterpreter" title="Py_NewInterpreter"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreter()</span></code></a>를 참조하십시오)를 제거합니다. 이상적으로, 이것은 파이썬 인터프리터가 할당한 모든 메모리를 해제합니다.  (먼저 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>를 다시 호출하지 않고) 두 번째로 호출하면 아무런 일도 하지 않습니다. 일반적으로 반환 값은 <code class="docutils literal notranslate"><span class="pre">0</span></code>입니다. 파이널리제이션 중에 에러가 발생하면 (버퍼링된 데이터 플러시) <code class="docutils literal notranslate"><span class="pre">-1</span></code>이 반환됩니다.</p>
<p>이 함수는 여러 가지 이유로 제공됩니다. 내장 응용 프로그램이 응용 프로그램 자체를 다시 시작하지 않고 파이썬을 다시 시작하고 싶을 수 있습니다. 동적으로 로드할 수 있는 라이브러리(또는 DLL)에서 파이썬 인터프리터를 로드한 응용 프로그램은 DLL을 언로드하기 전에 파이썬이 할당한 모든 메모리를 해제하고 싶을 수 있습니다. 응용 프로그램에서 메모리 누수를 찾는 동안 개발자는 응용 프로그램을 종료하기 전에 파이썬에서 할당한 모든 메모리를 해제하고 싶을 것입니다.</p>
<p><strong>버그와 주의 사항:</strong> 모듈의 모듈과 객체 파괴는 임의의 순서로 수행됩니다; 이로 인해 파괴자(<a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드)가 다른 객체(함수 조차)나 모듈에 의존할 때 실패할 수 있습니다. 파이썬에서 로드한 동적으로 로드된 확장 모듈은 언로드되지 않습니다. 파이썬 인터프리터가 할당한 소량의 메모리는 해제되지 않을 수 있습니다 (누수를 발견하면, 보고해 주십시오). 객체 간의 순환 참조에 묶여있는 메모리는 해제되지 않습니다. 확장 모듈이 할당한 일부 메모리는 해제되지 않을 수 있습니다. 일부 확장은 초기화 루틴이 두 번 이상 호출되면 제대로 작동하지 않을 수 있습니다; 응용 프로그램이 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>와 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a>를 두 번 이상 호출하면 이 문제가 발생할 수 있습니다.</p>
<p class="audit-hook">인자 없이 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">cpython._PySys_ClearAuditHooks</span></code>를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_Finalize">
void <code class="sig-name descname">Py_Finalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_Finalize" title="정의 주소">¶</a></dt>
<dd><p>이것은 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a>의 이전 버전과 호환되는 반환 값을 무시하는 버전입니다.</p>
</dd></dl>

</div>
<div class="section" id="process-wide-parameters">
<h2>프로세스 전체 매개 변수<a class="headerlink" href="#process-wide-parameters" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="c.Py_SetStandardStreamEncoding">
int <code class="sig-name descname">Py_SetStandardStreamEncoding</code><span class="sig-paren">(</span>const char<em> *encoding</em>, const char<em> *errors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_SetStandardStreamEncoding" title="정의 주소">¶</a></dt>
<dd><p id="index-17">이 함수는 (호출한다면) <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 전에 호출해야합니다. <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-func docutils literal notranslate"><span class="pre">str.encode()</span></code></a>에서와 같은 의미로, 표준 IO에 사용할 인코딩과 에러 처리를 지정합니다.</p>
<p><span class="target" id="index-82"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONIOENCODING"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONIOENCODING</span></code></a> 값을 재정의(overrides)하고, 환경 변수가 작동하지 않을 때 내장(embedding) 코드가 IO 인코딩을 제어할 수 있도록합니다.</p>
<p><em>encoding</em> 및/또는 <em>errors</em>는 <span class="target" id="index-83"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONIOENCODING"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONIOENCODING</span></code></a> 및/또는 기본값(다른 설정에 따라 다릅니다)을 사용하기위해 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>일 수 있습니다.</p>
<p><a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a>은 이 (또는 다른) 설정에 관계 없이 항상 &quot;backslashreplace&quot; 에러 처리기를 사용함에 유의하십시오.</p>
<p><a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a>가 호출되면, 이 함수는 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>에 대한 후속 호출에 영향을 미치기 위해 다시 호출되어야합니다.</p>
<p>성공하면 <code class="docutils literal notranslate"><span class="pre">0</span></code>을 반환하고, 에러시 (예를 들어 인터프리터가 이미 초기화된 후 호출) 0이 아닌 값을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_SetProgramName">
void <code class="sig-name descname">Py_SetProgramName</code><span class="sig-paren">(</span>const wchar_t<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_SetProgramName" title="정의 주소">¶</a></dt>
<dd><p id="index-20">(호출된다면) 이 함수는 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>가 처음으로 호출되기 전에 호출되어야 합니다. 인터프리터에게 프로그램의 <code class="xref c c-func docutils literal notranslate"><span class="pre">main()</span></code> 함수에 대한 <code class="docutils literal notranslate"><span class="pre">argv[0]</span></code> 인자의 값을 알려줍니다 (와이드 문자로 변환됩니다). 이것은 <a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a>와 아래의 다른 함수에서 인터프리터 실행 파일과 관련된 파이썬 런타임 라이브러리를 찾는 데 사용됩니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'python'</span></code>입니다. 인자는 프로그램 실행 기간 동안 내용이 변경되지 않는 정적 저장소의 0으로 끝나는 와이드 문자열을 가리켜야 합니다. 파이썬 인터프리터의 코드는 이 저장소의 내용을 변경하지 않습니다.</p>
<p>바이트 문자열을 디코딩하여 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_*</span></code> 문자열을 얻는데 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a>을 사용합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetProgramName">
wchar* <code class="sig-name descname">Py_GetProgramName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetProgramName" title="정의 주소">¶</a></dt>
<dd><p id="index-21"><a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a>으로 설정된 프로그램 이름이나 기본값을 반환합니다. 반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는 안됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetPrefix">
wchar_t* <code class="sig-name descname">Py_GetPrefix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetPrefix" title="정의 주소">¶</a></dt>
<dd><p>설치된 플랫폼 독립적 파일에 대한 <em>prefix</em>를 반환합니다. 이것은 <a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a>로 설정된 프로그램 이름과 일부 환경 변수의 여러 복잡한 규칙을 통해 파생됩니다; 예를 들어, 프로그램 이름이 <code class="docutils literal notranslate"><span class="pre">'/usr/local/bin/python'</span></code>이면, prefix는 <code class="docutils literal notranslate"><span class="pre">'/usr/local'</span></code>입니다. 반환된 문자열은 정적 저장소를 가리킵니다; 호출자는 값을 수정해서는 안됩니다. 이는 최상위 수준 <code class="file docutils literal notranslate"><span class="pre">Makefile</span></code>의 <strong class="makevar">prefix</strong> 변수와 빌드시 <strong class="program">configure</strong> 스크립트의 <code class="docutils literal notranslate"><span class="pre">--prefix</span></code> 인자에 해당합니다. 이 값은 파이썬 코드에서 <code class="docutils literal notranslate"><span class="pre">sys.prefix</span></code>로 사용할 수 있습니다. 유닉스에서만 유용합니다. 다음 함수도 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetExecPrefix">
wchar_t* <code class="sig-name descname">Py_GetExecPrefix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetExecPrefix" title="정의 주소">¶</a></dt>
<dd><p>설치된 플랫폼-<em>종속적dependent</em> 파일에 대한 <em>exec-prefix</em>를 반환합니다. 이것은 <a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a>으로 설정된 프로그램 이름과 일부 환경 변수의 여러 복잡한 규칙을 통해 파생됩니다; 예를 들어 프로그램 이름이 <code class="docutils literal notranslate"><span class="pre">'/usr/local/bin/python'</span></code>이면, exec-prefix는 <code class="docutils literal notranslate"><span class="pre">'/usr/local'</span></code>입니다. 반환된 문자열은 정적 저장소를 가리 킵니다; 호출자는 값을 수정해서는 안됩니다. 이는 최상위 수준 <code class="file docutils literal notranslate"><span class="pre">Makefile</span></code>의 <strong class="makevar">exec_prefix</strong> 변수와 빌드시 <strong class="program">configure</strong> 스크립트의 <code class="docutils literal notranslate"><span class="pre">--exec-prefix</span></code> 인자에 해당합니다. 이 값은 파이썬 코드에서 <code class="docutils literal notranslate"><span class="pre">sys.exec_prefix</span></code>로 사용할 수 있습니다. 유닉스에서만 유용합니다.</p>
<p>배경: exec-prefix는 플랫폼 종속적 파일(가령 실행 파일과 공유 라이브러리)이 다른 디렉터리 트리에 설치될 때 prefix와 다릅니다. 일반 설치에서, 플랫폼 종속적 파일은 <code class="file docutils literal notranslate"><span class="pre">/usr/local/plat</span></code> 서브 트리에 설치되고 플랫폼 독립적 파일은 <code class="file docutils literal notranslate"><span class="pre">/usr/local</span></code>에 설치될 수 있습니다.</p>
<p>일반적으로 말해서, 플랫폼은 하드웨어와 소프트웨어 제품군의 조합입니다, 예를 들어 Solaris 2.x 운영 체제를 실행하는 Sparc 기계들은 같은 플랫폼으로 간주하지만, Solaris 2.x를 실행하는 Intel 기계는 다른 플랫폼이며, 리눅스를 실행하는 Intel 기계는 또 다른 플랫폼입니다. 같은 운영 체제의 서로 다른 주 개정판도 일반적으로 다른 플랫폼을 형성합니다. 비 유닉스 운영 체제는 다른 이야기입니다; 이러한 시스템의 설치 전략이 너무 다르기 때문에 prefix와 exec-prefix는 의미가 없으며, 빈 문자열로 설정됩니다. 컴파일 된 파이썬 바이트 코드 파일은 플랫폼 독립적임에 유의하십시오 (그러나 이들을 컴파일 하는데 사용된 파이썬 버전에는 종속적입니다!).</p>
<p>시스템 관리자는 <code class="file docutils literal notranslate"><span class="pre">/usr/local/plat</span></code>을 각 플랫폼에 대해 다른 파일 시스템으로 사용하면서 플랫폼 간에 <code class="file docutils literal notranslate"><span class="pre">/usr/local</span></code>를 공유하도록 <strong class="program">mount</strong>나 <strong class="program">automount</strong> 프로그램을 구성하는 방법을 알것입니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetProgramFullPath">
wchar_t* <code class="sig-name descname">Py_GetProgramFullPath</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetProgramFullPath" title="정의 주소">¶</a></dt>
<dd><p id="index-22">Return the full program name of the Python executable; this is  computed as a
side-effect of deriving the default module search path  from the program name
(set by <a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a> above). The returned string points into
static storage; the caller should not modify its value.  The value is available
to Python code as <code class="docutils literal notranslate"><span class="pre">sys.executable</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetPath">
wchar_t* <code class="sig-name descname">Py_GetPath</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetPath" title="정의 주소">¶</a></dt>
<dd><p id="index-23">Return the default module search path; this is computed from the program name
(set by <a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a> above) and some environment variables.
The returned string consists of a series of directory names separated by a
platform dependent delimiter character.  The delimiter character is <code class="docutils literal notranslate"><span class="pre">':'</span></code>
on Unix and Mac OS X, <code class="docutils literal notranslate"><span class="pre">';'</span></code> on Windows.  The returned string points into
static storage; the caller should not modify its value.  The list
<a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> is initialized with this value on interpreter startup; it
can be (and usually is) modified later to change the search path for loading
modules.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_SetPath">
void <code class="sig-name descname">Py_SetPath</code><span class="sig-paren">(</span>const wchar_t<em> *</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_SetPath" title="정의 주소">¶</a></dt>
<dd><p id="index-24">Set the default module search path.  If this function is called before
<a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>, then <a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a> won't attempt to compute a
default search path but uses the one provided instead.  This is useful if
Python is embedded by an application that has full knowledge of the location
of all modules.  The path components should be separated by the platform
dependent delimiter character, which is <code class="docutils literal notranslate"><span class="pre">':'</span></code> on Unix and Mac OS X, <code class="docutils literal notranslate"><span class="pre">';'</span></code>
on Windows.</p>
<p>This also causes <a class="reference internal" href="../library/sys.html#sys.executable" title="sys.executable"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.executable</span></code></a> to be set to the program
full path (see <a class="reference internal" href="#c.Py_GetProgramFullPath" title="Py_GetProgramFullPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetProgramFullPath()</span></code></a>) and for <a class="reference internal" href="../library/sys.html#sys.prefix" title="sys.prefix"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.prefix</span></code></a> and
<a class="reference internal" href="../library/sys.html#sys.exec_prefix" title="sys.exec_prefix"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.exec_prefix</span></code></a> to be empty.  It is up to the caller to modify these
if required after calling <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>.</p>
<p>바이트 문자열을 디코딩하여 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_*</span></code> 문자열을 얻는데 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a>을 사용합니다.</p>
<p>The path argument is copied internally, so the caller may free it after the
call completes.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>The program full path is now used for <a class="reference internal" href="../library/sys.html#sys.executable" title="sys.executable"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.executable</span></code></a>, instead
of the program name.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetVersion">
const char* <code class="sig-name descname">Py_GetVersion</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetVersion" title="정의 주소">¶</a></dt>
<dd><p>Return the version of this Python interpreter.  This is a string that looks
something like</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;3.0a5+ (py3k:63103M, May 12 2008, 00:53:55) </span><span class="se">\n</span><span class="s">[GCC 4.2.3]&quot;</span>
</pre></div>
</div>
<p id="index-25">The first word (up to the first space character) is the current Python version;
the first three characters are the major and minor version separated by a
period.  The returned string points into static storage; the caller should not
modify its value.  The value is available to Python code as <a class="reference internal" href="../library/sys.html#sys.version" title="sys.version"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.version</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetPlatform">
const char* <code class="sig-name descname">Py_GetPlatform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetPlatform" title="정의 주소">¶</a></dt>
<dd><p id="index-26">Return the platform identifier for the current platform.  On Unix, this is
formed from the &quot;official&quot; name of the operating system, converted to lower
case, followed by the major revision number; e.g., for Solaris 2.x, which is
also known as SunOS 5.x, the value is <code class="docutils literal notranslate"><span class="pre">'sunos5'</span></code>.  On Mac OS X, it is
<code class="docutils literal notranslate"><span class="pre">'darwin'</span></code>.  On Windows, it is <code class="docutils literal notranslate"><span class="pre">'win'</span></code>.  The returned string points into
static storage; the caller should not modify its value.  The value is available
to Python code as <code class="docutils literal notranslate"><span class="pre">sys.platform</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetCopyright">
const char* <code class="sig-name descname">Py_GetCopyright</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetCopyright" title="정의 주소">¶</a></dt>
<dd><p>Return the official copyright string for the current Python version, for example</p>
<p><code class="docutils literal notranslate"><span class="pre">'Copyright</span> <span class="pre">1991-1995</span> <span class="pre">Stichting</span> <span class="pre">Mathematisch</span> <span class="pre">Centrum,</span> <span class="pre">Amsterdam'</span></code></p>
<p id="index-27">The returned string points into static storage; the caller should not modify its
value.  The value is available to Python code as <code class="docutils literal notranslate"><span class="pre">sys.copyright</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetCompiler">
const char* <code class="sig-name descname">Py_GetCompiler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetCompiler" title="정의 주소">¶</a></dt>
<dd><p>Return an indication of the compiler used to build the current Python version,
in square brackets, for example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;[GCC 2.7.2.2]&quot;</span>
</pre></div>
</div>
<p id="index-28">The returned string points into static storage; the caller should not modify its
value.  The value is available to Python code as part of the variable
<code class="docutils literal notranslate"><span class="pre">sys.version</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetBuildInfo">
const char* <code class="sig-name descname">Py_GetBuildInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetBuildInfo" title="정의 주소">¶</a></dt>
<dd><p>Return information about the sequence number and build date and time  of the
current Python interpreter instance, for example</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;#67, Aug  1 1997, 22:34:28&quot;</span>
</pre></div>
</div>
<p id="index-29">The returned string points into static storage; the caller should not modify its
value.  The value is available to Python code as part of the variable
<code class="docutils literal notranslate"><span class="pre">sys.version</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PySys_SetArgvEx">
void <code class="sig-name descname">PySys_SetArgvEx</code><span class="sig-paren">(</span>int<em> argc</em>, wchar_t<em> **argv</em>, int<em> updatepath</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PySys_SetArgvEx" title="정의 주소">¶</a></dt>
<dd><p id="index-30">Set <a class="reference internal" href="../library/sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a> based on <em>argc</em> and <em>argv</em>.  These parameters are
similar to those passed to the program's <code class="xref c c-func docutils literal notranslate"><span class="pre">main()</span></code> function with the
difference that the first entry should refer to the script file to be
executed rather than the executable hosting the Python interpreter.  If there
isn't a script that will be run, the first entry in <em>argv</em> can be an empty
string.  If this function fails to initialize <a class="reference internal" href="../library/sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a>, a fatal
condition is signalled using <a class="reference internal" href="sys.html#c.Py_FatalError" title="Py_FatalError"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FatalError()</span></code></a>.</p>
<p>If <em>updatepath</em> is zero, this is all the function does.  If <em>updatepath</em>
is non-zero, the function also modifies <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> according to the
following algorithm:</p>
<ul class="simple">
<li><p>If the name of an existing script is passed in <code class="docutils literal notranslate"><span class="pre">argv[0]</span></code>, the absolute
path of the directory where the script is located is prepended to
<a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>.</p></li>
<li><p>Otherwise (that is, if <em>argc</em> is <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">argv[0]</span></code> doesn't point
to an existing file name), an empty string is prepended to
<a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>, which is the same as prepending the current working
directory (<code class="docutils literal notranslate"><span class="pre">&quot;.&quot;</span></code>).</p></li>
</ul>
<p>바이트 문자열을 디코딩하여 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_*</span></code> 문자열을 얻는데 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a>을 사용합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>It is recommended that applications embedding the Python interpreter
for purposes other than executing a single script pass <code class="docutils literal notranslate"><span class="pre">0</span></code> as <em>updatepath</em>,
and update <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> themselves if desired.
See <a class="reference external" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5983">CVE-2008-5983</a>.</p>
<p>On versions before 3.1.3, you can achieve the same effect by manually
popping the first <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> element after having called
<a class="reference internal" href="#c.PySys_SetArgv" title="PySys_SetArgv"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgv()</span></code></a>, for example using:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;import sys; sys.path.pop(0)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PySys_SetArgv">
void <code class="sig-name descname">PySys_SetArgv</code><span class="sig-paren">(</span>int<em> argc</em>, wchar_t<em> **argv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PySys_SetArgv" title="정의 주소">¶</a></dt>
<dd><p>This function works like <a class="reference internal" href="#c.PySys_SetArgvEx" title="PySys_SetArgvEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code></a> with <em>updatepath</em> set
to <code class="docutils literal notranslate"><span class="pre">1</span></code> unless the <strong class="program">python</strong> interpreter was started with the
<a class="reference internal" href="../using/cmdline.html#id2"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a>.</p>
<p>바이트 문자열을 디코딩하여 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_*</span></code> 문자열을 얻는데 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a>을 사용합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>The <em>updatepath</em> value depends on <a class="reference internal" href="../using/cmdline.html#id2"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_SetPythonHome">
void <code class="sig-name descname">Py_SetPythonHome</code><span class="sig-paren">(</span>const wchar_t<em> *home</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_SetPythonHome" title="정의 주소">¶</a></dt>
<dd><p>Set the default &quot;home&quot; directory, that is, the location of the standard
Python libraries.  See <span class="target" id="index-31"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a> for the meaning of the
argument string.</p>
<p>The argument should point to a zero-terminated character string in static
storage whose contents will not change for the duration of the program's
execution.  No code in the Python interpreter will change the contents of
this storage.</p>
<p>바이트 문자열을 디코딩하여 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_*</span></code> 문자열을 얻는데 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a>을 사용합니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_GetPythonHome">
w_char* <code class="sig-name descname">Py_GetPythonHome</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetPythonHome" title="정의 주소">¶</a></dt>
<dd><p>Return the default &quot;home&quot;, that is, the value set by a previous call to
<a class="reference internal" href="#c.Py_SetPythonHome" title="Py_SetPythonHome"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetPythonHome()</span></code></a>, or the value of the <span class="target" id="index-32"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a>
environment variable if it is set.</p>
</dd></dl>

</div>
<div class="section" id="thread-state-and-the-global-interpreter-lock">
<span id="threads"></span><h2>Thread State and the Global Interpreter Lock<a class="headerlink" href="#thread-state-and-the-global-interpreter-lock" title="제목 주소">¶</a></h2>
<p id="index-33">The Python interpreter is not fully thread-safe.  In order to support
multi-threaded Python programs, there's a global lock, called the <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">global
interpreter lock</span></a> or <a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>, that must be held by the current thread before
it can safely access Python objects. Without the lock, even the simplest
operations could cause problems in a multi-threaded program: for example, when
two threads simultaneously increment the reference count of the same object, the
reference count could end up being incremented only once instead of twice.</p>
<p id="index-34">Therefore, the rule exists that only the thread that has acquired the
<a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a> may operate on Python objects or call Python/C API functions.
In order to emulate concurrency of execution, the interpreter regularly
tries to switch threads (see <a class="reference internal" href="../library/sys.html#sys.setswitchinterval" title="sys.setswitchinterval"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setswitchinterval()</span></code></a>).  The lock is also
released around potentially blocking I/O operations like reading or writing
a file, so that other Python threads can run in the meantime.</p>
<p id="index-35">The Python interpreter keeps some thread-specific bookkeeping information
inside a data structure called <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a>.  There's also one
global variable pointing to the current <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a>: it can
be retrieved using <a class="reference internal" href="#c.PyThreadState_Get" title="PyThreadState_Get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Get()</span></code></a>.</p>
<div class="section" id="releasing-the-gil-from-extension-code">
<h3>Releasing the GIL from extension code<a class="headerlink" href="#releasing-the-gil-from-extension-code" title="제목 주소">¶</a></h3>
<p>Most extension code manipulating the <a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a> has the following simple
structure:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Save</span> <span class="n">the</span> <span class="kr">thread</span> <span class="n">state</span> <span class="n">in</span> <span class="n">a</span> <span class="n">local</span> <span class="n">variable</span><span class="p">.</span>
<span class="n">Release</span> <span class="n">the</span> <span class="n">global</span> <span class="n">interpreter</span> <span class="n">lock</span><span class="p">.</span>
<span class="p">...</span> <span class="n">Do</span> <span class="n">some</span> <span class="n">blocking</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">operation</span> <span class="p">...</span>
<span class="n">Reacquire</span> <span class="n">the</span> <span class="n">global</span> <span class="n">interpreter</span> <span class="n">lock</span><span class="p">.</span>
<span class="n">Restore</span> <span class="n">the</span> <span class="kr">thread</span> <span class="n">state</span> <span class="n">from</span> <span class="n">the</span> <span class="n">local</span> <span class="n">variable</span><span class="p">.</span>
</pre></div>
</div>
<p>This is so common that a pair of macros exists to simplify it:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Py_BEGIN_ALLOW_THREADS</span>
<span class="p">...</span> <span class="n">Do</span> <span class="n">some</span> <span class="n">blocking</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">operation</span> <span class="p">...</span>
<span class="n">Py_END_ALLOW_THREADS</span>
</pre></div>
</div>
<p id="index-36">The <a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> macro opens a new block and declares a
hidden local variable; the <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> macro closes the
block.</p>
<p>The block above expands to the following code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyThreadState</span> <span class="o">*</span><span class="n">_save</span><span class="p">;</span>

<span class="n">_save</span> <span class="o">=</span> <span class="n">PyEval_SaveThread</span><span class="p">();</span>
<span class="p">...</span> <span class="n">Do</span> <span class="n">some</span> <span class="n">blocking</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">operation</span> <span class="p">...</span>
<span class="n">PyEval_RestoreThread</span><span class="p">(</span><span class="n">_save</span><span class="p">);</span>
</pre></div>
</div>
<p id="index-37">Here is how these functions work: the global interpreter lock is used to protect the pointer to the
current thread state.  When releasing the lock and saving the thread state,
the current thread state pointer must be retrieved before the lock is released
(since another thread could immediately acquire the lock and store its own thread
state in the global variable). Conversely, when acquiring the lock and restoring
the thread state, the lock must be acquired before storing the thread state
pointer.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>Calling system I/O functions is the most common use case for releasing
the GIL, but it can also be useful before calling long-running computations
which don't need access to Python objects, such as compression or
cryptographic functions operating over memory buffers.  For example, the
standard <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> and <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> modules release the GIL when
compressing or hashing data.</p>
</div>
</div>
<div class="section" id="non-python-created-threads">
<span id="gilstate"></span><h3>Non-Python created threads<a class="headerlink" href="#non-python-created-threads" title="제목 주소">¶</a></h3>
<p>When threads are created using the dedicated Python APIs (such as the
<a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> module), a thread state is automatically associated to them
and the code showed above is therefore correct.  However, when threads are
created from C (for example by a third-party library with its own thread
management), they don't hold the GIL, nor is there a thread state structure
for them.</p>
<p>If you need to call Python code from these threads (often this will be part
of a callback API provided by the aforementioned third-party library),
you must first register these threads with the interpreter by
creating a thread state data structure, then acquiring the GIL, and finally
storing their thread state pointer, before you can start using the Python/C
API.  When you are done, you should reset the thread state pointer, release
the GIL, and finally free the thread state data structure.</p>
<p>The <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> and <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> functions do
all of the above automatically.  The typical idiom for calling into Python
from a C thread is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyGILState_STATE</span> <span class="n">gstate</span><span class="p">;</span>
<span class="n">gstate</span> <span class="o">=</span> <span class="n">PyGILState_Ensure</span><span class="p">();</span>

<span class="cm">/* Perform Python actions here. */</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">CallSomeFunction</span><span class="p">();</span>
<span class="cm">/* evaluate result or handle exception */</span>

<span class="cm">/* Release the thread. No Python API allowed beyond this point. */</span>
<span class="n">PyGILState_Release</span><span class="p">(</span><span class="n">gstate</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that the <code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_*()</span></code> functions assume there is only one global
interpreter (created automatically by <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>).  Python
supports the creation of additional interpreters (using
<a class="reference internal" href="#c.Py_NewInterpreter" title="Py_NewInterpreter"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreter()</span></code></a>), but mixing multiple interpreters and the
<code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_*()</span></code> API is unsupported.</p>
</div>
<div class="section" id="cautions-about-fork">
<span id="fork-and-threads"></span><h3>Cautions about fork()<a class="headerlink" href="#cautions-about-fork" title="제목 주소">¶</a></h3>
<p>Another important thing to note about threads is their behaviour in the face
of the C <code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code> call. On most systems with <code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code>, after a
process forks only the thread that issued the fork will exist.  This has a
concrete impact both on how locks must be handled and on all stored state
in CPython's runtime.</p>
<p>The fact that only the &quot;current&quot; thread remains
means any locks held by other threads will never be released. Python solves
this for <a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> by acquiring the locks it uses internally before
the fork, and releasing them afterwards. In addition, it resets any
<a class="reference internal" href="../library/threading.html#lock-objects"><span class="std std-ref">Lock 객체</span></a> in the child. When extending or embedding Python, there
is no way to inform Python of additional (non-Python) locks that need to be
acquired before or reset after a fork. OS facilities such as
<code class="xref c c-func docutils literal notranslate"><span class="pre">pthread_atfork()</span></code> would need to be used to accomplish the same thing.
Additionally, when extending or embedding Python, calling <code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code>
directly rather than through <a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> (and returning to or calling
into Python) may result in a deadlock by one of Python's internal locks
being held by a thread that is defunct after the fork.
<a class="reference internal" href="sys.html#c.PyOS_AfterFork_Child" title="PyOS_AfterFork_Child"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_AfterFork_Child()</span></code></a> tries to reset the necessary locks, but is not
always able to.</p>
<p>The fact that all other threads go away also means that CPython's
runtime state there must be cleaned up properly, which <a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a>
does.  This means finalizing all other <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> objects
belonging to the current interpreter and all other
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> objects.  Due to this and the special
nature of the <a class="reference internal" href="#sub-interpreter-support"><span class="std std-ref">&quot;main&quot; interpreter</span></a>,
<code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code> should only be called in that interpreter's &quot;main&quot;
thread, where the CPython global runtime was originally initialized.
The only exception is if <code class="xref c c-func docutils literal notranslate"><span class="pre">exec()</span></code> will be called immediately
after.</p>
</div>
<div class="section" id="high-level-api">
<h3>High-level API<a class="headerlink" href="#high-level-api" title="제목 주소">¶</a></h3>
<p>These are the most commonly used types and functions when writing C extension
code, or when embedding the Python interpreter:</p>
<dl class="type">
<dt id="c.PyInterpreterState">
<code class="sig-name descname">PyInterpreterState</code><a class="headerlink" href="#c.PyInterpreterState" title="정의 주소">¶</a></dt>
<dd><p>This data structure represents the state shared by a number of cooperating
threads.  Threads belonging to the same interpreter share their module
administration and a few other internal items. There are no public members in
this structure.</p>
<p>Threads belonging to different interpreters initially share nothing, except
process state like available memory, open file descriptors and such.  The global
interpreter lock is also shared by all threads, regardless of to which
interpreter they belong.</p>
</dd></dl>

<dl class="type">
<dt id="c.PyThreadState">
<code class="sig-name descname">PyThreadState</code><a class="headerlink" href="#c.PyThreadState" title="정의 주소">¶</a></dt>
<dd><p>This data structure represents the state of a single thread.  The only public
data member is <a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span> <span class="pre">*</span></code></a><code class="xref py py-attr docutils literal notranslate"><span class="pre">interp</span></code>, which points to
this thread's interpreter state.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_InitThreads">
void <code class="sig-name descname">PyEval_InitThreads</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_InitThreads" title="정의 주소">¶</a></dt>
<dd><p id="index-38">Deprecated function which does nothing.</p>
<p>In Python 3.6 and older, this function created the GIL if it didn't exist.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>The function now does nothing.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>This function is now called by <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>, so you don't
have to call it yourself anymore.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>This function cannot be called before <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> anymore.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.9, will be removed in version 3.11.</span></p>
</div>
<span class="target" id="index-39"></span></dd></dl>

<dl class="function">
<dt id="c.PyEval_ThreadsInitialized">
int <code class="sig-name descname">PyEval_ThreadsInitialized</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_ThreadsInitialized" title="정의 주소">¶</a></dt>
<dd><p>Returns a non-zero value if <a class="reference internal" href="#c.PyEval_InitThreads" title="PyEval_InitThreads"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_InitThreads()</span></code></a> has been called.  This
function can be called without holding the GIL, and therefore can be used to
avoid calls to the locking API when running single-threaded.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>The <a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a> is now initialized by <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.9, will be removed in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_SaveThread">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a>* <code class="sig-name descname">PyEval_SaveThread</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_SaveThread" title="정의 주소">¶</a></dt>
<dd><p>Release the global interpreter lock (if it has been created) and reset the
thread state to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, returning the previous thread state (which is not
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>).  If the lock has been created, the current thread must have
acquired it.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_RestoreThread">
void <code class="sig-name descname">PyEval_RestoreThread</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_RestoreThread" title="정의 주소">¶</a></dt>
<dd><p>Acquire the global interpreter lock (if it has been created) and set the
thread state to <em>tstate</em>, which must not be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  If the lock has been
created, the current thread must not have acquired it, otherwise deadlock
ensues.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>Calling this function from a thread when the runtime is finalizing
will terminate the thread, even if the thread was not created by Python.
You can use <code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_IsFinalizing()</span></code> or <a class="reference internal" href="../library/sys.html#sys.is_finalizing" title="sys.is_finalizing"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code></a> to
check if the interpreter is in process of being finalized before calling
this function to avoid unwanted termination.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_Get">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a>* <code class="sig-name descname">PyThreadState_Get</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Get" title="정의 주소">¶</a></dt>
<dd><p>Return the current thread state.  The global interpreter lock must be held.
When the current thread state is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, this issues a fatal error (so that
the caller needn't check for <code class="docutils literal notranslate"><span class="pre">NULL</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_Swap">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a>* <code class="sig-name descname">PyThreadState_Swap</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Swap" title="정의 주소">¶</a></dt>
<dd><p>Swap the current thread state with the thread state given by the argument
<em>tstate</em>, which may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  The global interpreter lock must be held
and is not released.</p>
</dd></dl>

<p>The following functions use thread-local storage, and are not compatible
with sub-interpreters:</p>
<dl class="function">
<dt id="c.PyGILState_Ensure">
PyGILState_STATE <code class="sig-name descname">PyGILState_Ensure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyGILState_Ensure" title="정의 주소">¶</a></dt>
<dd><p>Ensure that the current thread is ready to call the Python C API regardless
of the current state of Python, or of the global interpreter lock. This may
be called as many times as desired by a thread as long as each call is
matched with a call to <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>. In general, other
thread-related APIs may be used between <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> and
<a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> calls as long as the thread state is restored to
its previous state before the Release().  For example, normal usage of the
<a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> and <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> macros is
acceptable.</p>
<p>The return value is an opaque &quot;handle&quot; to the thread state when
<a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> was called, and must be passed to
<a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> to ensure Python is left in the same state. Even
though recursive calls are allowed, these handles <em>cannot</em> be shared - each
unique call to <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> must save the handle for its call
to <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>.</p>
<p>When the function returns, the current thread will hold the GIL and be able
to call arbitrary Python code.  Failure is a fatal error.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>Calling this function from a thread when the runtime is finalizing
will terminate the thread, even if the thread was not created by Python.
You can use <code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_IsFinalizing()</span></code> or <a class="reference internal" href="../library/sys.html#sys.is_finalizing" title="sys.is_finalizing"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code></a> to
check if the interpreter is in process of being finalized before calling
this function to avoid unwanted termination.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyGILState_Release">
void <code class="sig-name descname">PyGILState_Release</code><span class="sig-paren">(</span>PyGILState_STATE<span class="sig-paren">)</span><a class="headerlink" href="#c.PyGILState_Release" title="정의 주소">¶</a></dt>
<dd><p>Release any resources previously acquired.  After this call, Python's state will
be the same as it was prior to the corresponding <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> call
(but generally this state will be unknown to the caller, hence the use of the
GILState API).</p>
<p>Every call to <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> must be matched by a call to
<a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> on the same thread.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyGILState_GetThisThreadState">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a>* <code class="sig-name descname">PyGILState_GetThisThreadState</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyGILState_GetThisThreadState" title="정의 주소">¶</a></dt>
<dd><p>Get the current thread state for this thread.  May return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no
GILState API has been used on the current thread.  Note that the main thread
always has such a thread-state, even if no auto-thread-state call has been
made on the main thread.  This is mainly a helper/diagnostic function.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyGILState_Check">
int <code class="sig-name descname">PyGILState_Check</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyGILState_Check" title="정의 주소">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">1</span></code> if the current thread is holding the GIL and <code class="docutils literal notranslate"><span class="pre">0</span></code> otherwise.
This function can be called from any thread at any time.
Only if it has had its Python thread state initialized and currently is
holding the GIL will it return <code class="docutils literal notranslate"><span class="pre">1</span></code>.
This is mainly a helper/diagnostic function.  It can be useful
for example in callback contexts or memory allocation functions when
knowing that the GIL is locked can allow the caller to perform sensitive
actions or otherwise behave differently.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<p>The following macros are normally used without a trailing semicolon; look for
example usage in the Python source distribution.</p>
<dl class="macro">
<dt id="c.Py_BEGIN_ALLOW_THREADS">
<code class="sig-name descname">Py_BEGIN_ALLOW_THREADS</code><a class="headerlink" href="#c.Py_BEGIN_ALLOW_THREADS" title="정의 주소">¶</a></dt>
<dd><p>This macro expands to <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">PyThreadState</span> <span class="pre">*_save;</span> <span class="pre">_save</span> <span class="pre">=</span> <span class="pre">PyEval_SaveThread();</span></code>.
Note that it contains an opening brace; it must be matched with a following
<a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> macro.  See above for further discussion of this
macro.</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_END_ALLOW_THREADS">
<code class="sig-name descname">Py_END_ALLOW_THREADS</code><a class="headerlink" href="#c.Py_END_ALLOW_THREADS" title="정의 주소">¶</a></dt>
<dd><p>This macro expands to <code class="docutils literal notranslate"><span class="pre">PyEval_RestoreThread(_save);</span> <span class="pre">}</span></code>. Note that it contains
a closing brace; it must be matched with an earlier
<a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> macro.  See above for further discussion of
this macro.</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_BLOCK_THREADS">
<code class="sig-name descname">Py_BLOCK_THREADS</code><a class="headerlink" href="#c.Py_BLOCK_THREADS" title="정의 주소">¶</a></dt>
<dd><p>This macro expands to <code class="docutils literal notranslate"><span class="pre">PyEval_RestoreThread(_save);</span></code>: it is equivalent to
<a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> without the closing brace.</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_UNBLOCK_THREADS">
<code class="sig-name descname">Py_UNBLOCK_THREADS</code><a class="headerlink" href="#c.Py_UNBLOCK_THREADS" title="정의 주소">¶</a></dt>
<dd><p>This macro expands to <code class="docutils literal notranslate"><span class="pre">_save</span> <span class="pre">=</span> <span class="pre">PyEval_SaveThread();</span></code>: it is equivalent to
<a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> without the opening brace and variable
declaration.</p>
</dd></dl>

</div>
<div class="section" id="low-level-api">
<h3>Low-level API<a class="headerlink" href="#low-level-api" title="제목 주소">¶</a></h3>
<p>All of the following functions must be called after <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> now initializes the <a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>.</p>
</div>
<dl class="function">
<dt id="c.PyInterpreterState_New">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <code class="sig-name descname">PyInterpreterState_New</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_New" title="정의 주소">¶</a></dt>
<dd><p>Create a new interpreter state object.  The global interpreter lock need not
be held, but may be held if it is necessary to serialize calls to this
function.</p>
<p class="audit-hook">인자 없이 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">cpython.PyInterpreterState_New</span></code>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_Clear">
void <code class="sig-name descname">PyInterpreterState_Clear</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Clear" title="정의 주소">¶</a></dt>
<dd><p>Reset all information in an interpreter state object.  The global interpreter
lock must be held.</p>
<p class="audit-hook">인자 없이 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">cpython.PyInterpreterState_Clear</span></code>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_Delete">
void <code class="sig-name descname">PyInterpreterState_Delete</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Delete" title="정의 주소">¶</a></dt>
<dd><p>Destroy an interpreter state object.  The global interpreter lock need not be
held.  The interpreter state must have been reset with a previous call to
<a class="reference internal" href="#c.PyInterpreterState_Clear" title="PyInterpreterState_Clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Clear()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_New">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a>* <code class="sig-name descname">PyThreadState_New</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_New" title="정의 주소">¶</a></dt>
<dd><p>Create a new thread state object belonging to the given interpreter object.
The global interpreter lock need not be held, but may be held if it is
necessary to serialize calls to this function.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_Clear">
void <code class="sig-name descname">PyThreadState_Clear</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Clear" title="정의 주소">¶</a></dt>
<dd><p>Reset all information in a thread state object.  The global interpreter lock
must be held.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>This function now calls the <code class="xref c c-member docutils literal notranslate"><span class="pre">PyThreadState.on_delete</span></code> callback.
Previously, that happened in <a class="reference internal" href="#c.PyThreadState_Delete" title="PyThreadState_Delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Delete()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_Delete">
void <code class="sig-name descname">PyThreadState_Delete</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Delete" title="정의 주소">¶</a></dt>
<dd><p>Destroy a thread state object.  The global interpreter lock need not be held.
The thread state must have been reset with a previous call to
<a class="reference internal" href="#c.PyThreadState_Clear" title="PyThreadState_Clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Clear()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_DeleteCurrent">
void <code class="sig-name descname">PyThreadState_DeleteCurrent</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_DeleteCurrent" title="정의 주소">¶</a></dt>
<dd><p>Destroy the current thread state and release the global interpreter lock.
Like <a class="reference internal" href="#c.PyThreadState_Delete" title="PyThreadState_Delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Delete()</span></code></a>, the global interpreter lock need not
be held. The thread state must have been reset with a previous call
to <a class="reference internal" href="#c.PyThreadState_Clear" title="PyThreadState_Clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Clear()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_GetFrame">
<a class="reference internal" href="veryhigh.html#c.PyFrameObject" title="PyFrameObject">PyFrameObject</a>* <code class="sig-name descname">PyThreadState_GetFrame</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_GetFrame" title="정의 주소">¶</a></dt>
<dd><p>Get the current frame of the Python thread state <em>tstate</em>.</p>
<p>Return a strong reference. Return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no frame is currently
executing.</p>
<p>See also <a class="reference internal" href="reflection.html#c.PyEval_GetFrame" title="PyEval_GetFrame"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_GetFrame()</span></code></a>.</p>
<p><em>tstate</em> must not be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_GetID">
uint64_t <code class="sig-name descname">PyThreadState_GetID</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_GetID" title="정의 주소">¶</a></dt>
<dd><p>Get the unique thread state identifier of the Python thread state <em>tstate</em>.</p>
<p><em>tstate</em> must not be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_GetInterpreter">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <code class="sig-name descname">PyThreadState_GetInterpreter</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_GetInterpreter" title="정의 주소">¶</a></dt>
<dd><p>Get the interpreter of the Python thread state <em>tstate</em>.</p>
<p><em>tstate</em> must not be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_Get">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <code class="sig-name descname">PyInterpreterState_Get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Get" title="정의 주소">¶</a></dt>
<dd><p>Get the current interpreter.</p>
<p>Issue a fatal error if there no current Python thread state or no current
interpreter. It cannot return NULL.</p>
<p>The caller must hold the GIL.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_GetID">
int64_t <code class="sig-name descname">PyInterpreterState_GetID</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_GetID" title="정의 주소">¶</a></dt>
<dd><p>Return the interpreter's unique ID.  If there was any error in doing
so then <code class="docutils literal notranslate"><span class="pre">-1</span></code> is returned and an error is set.</p>
<p>The caller must hold the GIL.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_GetDict">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyInterpreterState_GetDict</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_GetDict" title="정의 주소">¶</a></dt>
<dd><p>Return a dictionary in which interpreter-specific data may be stored.
If this function returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> then no exception has been raised and
the caller should assume no interpreter-specific dict is available.</p>
<p>This is not a replacement for <a class="reference internal" href="module.html#c.PyModule_GetState" title="PyModule_GetState"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_GetState()</span></code></a>, which
extensions should use to store interpreter-specific state information.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="type">
<dt id="c._PyFrameEvalFunction">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">(*_PyFrameEvalFunction)</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em>, <a class="reference internal" href="veryhigh.html#c.PyFrameObject" title="PyFrameObject">PyFrameObject</a><em> *frame</em>, int<em> throwflag</em><span class="sig-paren">)</span><a class="headerlink" href="#c._PyFrameEvalFunction" title="정의 주소">¶</a></dt>
<dd><p>Type of a frame evaluation function.</p>
<p>The <em>throwflag</em> parameter is used by the <code class="docutils literal notranslate"><span class="pre">throw()</span></code> method of generators:
if non-zero, handle the current exception.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>The function now takes a <em>tstate</em> parameter.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c._PyInterpreterState_GetEvalFrameFunc">
<a class="reference internal" href="#c._PyFrameEvalFunction" title="_PyFrameEvalFunction">_PyFrameEvalFunction</a> <code class="sig-name descname">_PyInterpreterState_GetEvalFrameFunc</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c._PyInterpreterState_GetEvalFrameFunc" title="정의 주소">¶</a></dt>
<dd><p>Get the frame evaluation function.</p>
<p>See the <span class="target" id="index-40"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0523"><strong>PEP 523</strong></a> &quot;Adding a frame evaluation API to CPython&quot;.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="sig-name descname">void _PyInterpreterState_SetEvalFrameFunc(PyInterpreterState *interp, _PyFrameEvalFunction eval_frame);</code></dt>
<dd><p>Set the frame evaluation function.</p>
<p>See the <span class="target" id="index-41"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0523"><strong>PEP 523</strong></a> &quot;Adding a frame evaluation API to CPython&quot;.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_GetDict">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="sig-name descname">PyThreadState_GetDict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_GetDict" title="정의 주소">¶</a></dt>
<dd><em class="refcount">Return value: Borrowed reference.</em><p>Return a dictionary in which extensions can store thread-specific state
information.  Each extension should use a unique key to use to store state in
the dictionary.  It is okay to call this function when no current thread state
is available. If this function returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, no exception has been raised and
the caller should assume no current thread state is available.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_SetAsyncExc">
int <code class="sig-name descname">PyThreadState_SetAsyncExc</code><span class="sig-paren">(</span>unsigned long<em> id</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *exc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_SetAsyncExc" title="정의 주소">¶</a></dt>
<dd><p>Asynchronously raise an exception in a thread. The <em>id</em> argument is the thread
id of the target thread; <em>exc</em> is the exception object to be raised. This
function does not steal any references to <em>exc</em>. To prevent naive misuse, you
must write your own C extension to call this.  Must be called with the GIL held.
Returns the number of thread states modified; this is normally one, but will be
zero if the thread id isn't found.  If <em>exc</em> is <code class="xref py py-const docutils literal notranslate"><span class="pre">NULL</span></code>, the pending
exception (if any) for the thread is cleared. This raises no exceptions.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>The type of the <em>id</em> parameter changed from <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span></code> to
<code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_AcquireThread">
void <code class="sig-name descname">PyEval_AcquireThread</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_AcquireThread" title="정의 주소">¶</a></dt>
<dd><p>Acquire the global interpreter lock and set the current thread state to
<em>tstate</em>, which must not be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  The lock must have been created earlier.
If this thread already has the lock, deadlock ensues.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>Calling this function from a thread when the runtime is finalizing
will terminate the thread, even if the thread was not created by Python.
You can use <code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_IsFinalizing()</span></code> or <a class="reference internal" href="../library/sys.html#sys.is_finalizing" title="sys.is_finalizing"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code></a> to
check if the interpreter is in process of being finalized before calling
this function to avoid unwanted termination.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>Updated to be consistent with <a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a>,
<a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS()</span></code></a>, and <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>,
and terminate the current thread if called while the interpreter is finalizing.</p>
</div>
<p><a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a> is a higher-level function which is always
available (even when threads have not been initialized).</p>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_ReleaseThread">
void <code class="sig-name descname">PyEval_ReleaseThread</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_ReleaseThread" title="정의 주소">¶</a></dt>
<dd><p>Reset the current thread state to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and release the global interpreter
lock.  The lock must have been created earlier and must be held by the current
thread.  The <em>tstate</em> argument, which must not be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, is only used to check
that it represents the current thread state --- if it isn't, a fatal error is
reported.</p>
<p><a class="reference internal" href="#c.PyEval_SaveThread" title="PyEval_SaveThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SaveThread()</span></code></a> is a higher-level function which is always
available (even when threads have not been initialized).</p>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_AcquireLock">
void <code class="sig-name descname">PyEval_AcquireLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_AcquireLock" title="정의 주소">¶</a></dt>
<dd><p>Acquire the global interpreter lock.  The lock must have been created earlier.
If this thread already has the lock, a deadlock ensues.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.2부터 폐지: </span>This function does not update the current thread state.  Please use
<a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a> or <a class="reference internal" href="#c.PyEval_AcquireThread" title="PyEval_AcquireThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_AcquireThread()</span></code></a>
instead.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>Calling this function from a thread when the runtime is finalizing
will terminate the thread, even if the thread was not created by Python.
You can use <code class="xref c c-func docutils literal notranslate"><span class="pre">_Py_IsFinalizing()</span></code> or <a class="reference internal" href="../library/sys.html#sys.is_finalizing" title="sys.is_finalizing"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code></a> to
check if the interpreter is in process of being finalized before calling
this function to avoid unwanted termination.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>Updated to be consistent with <a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a>,
<a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS()</span></code></a>, and <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>,
and terminate the current thread if called while the interpreter is finalizing.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_ReleaseLock">
void <code class="sig-name descname">PyEval_ReleaseLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_ReleaseLock" title="정의 주소">¶</a></dt>
<dd><p>Release the global interpreter lock.  The lock must have been created earlier.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.2부터 폐지: </span>This function does not update the current thread state.  Please use
<a class="reference internal" href="#c.PyEval_SaveThread" title="PyEval_SaveThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SaveThread()</span></code></a> or <a class="reference internal" href="#c.PyEval_ReleaseThread" title="PyEval_ReleaseThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_ReleaseThread()</span></code></a>
instead.</p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="sub-interpreter-support">
<span id="id1"></span><h2>Sub-interpreter support<a class="headerlink" href="#sub-interpreter-support" title="제목 주소">¶</a></h2>
<p>While in most uses, you will only embed a single Python interpreter, there
are cases where you need to create several independent interpreters in the
same process and perhaps even in the same thread. Sub-interpreters allow
you to do that.</p>
<p>The &quot;main&quot; interpreter is the first one created when the runtime initializes.
It is usually the only Python interpreter in a process.  Unlike sub-interpreters,
the main interpreter has unique process-global responsibilities like signal
handling.  It is also responsible for execution during runtime initialization and
is usually the active interpreter during runtime finalization.  The
<a class="reference internal" href="#c.PyInterpreterState_Main" title="PyInterpreterState_Main"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Main()</span></code></a> function returns a pointer to its state.</p>
<p>You can switch between sub-interpreters using the <a class="reference internal" href="#c.PyThreadState_Swap" title="PyThreadState_Swap"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Swap()</span></code></a>
function. You can create and destroy them using the following functions:</p>
<dl class="function">
<dt id="c.Py_NewInterpreter">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a>* <code class="sig-name descname">Py_NewInterpreter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_NewInterpreter" title="정의 주소">¶</a></dt>
<dd><p id="index-42">Create a new sub-interpreter.  This is an (almost) totally separate environment
for the execution of Python code.  In particular, the new interpreter has
separate, independent versions of all imported modules, including the
fundamental modules <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>, <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> and <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>.  The
table of loaded modules (<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>) and the module search path
(<code class="docutils literal notranslate"><span class="pre">sys.path</span></code>) are also separate.  The new environment has no <code class="docutils literal notranslate"><span class="pre">sys.argv</span></code>
variable.  It has new standard I/O stream file objects <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>,
<code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> and <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> (however these refer to the same underlying
file descriptors).</p>
<p>The return value points to the first thread state created in the new
sub-interpreter.  This thread state is made in the current thread state.
Note that no actual thread is created; see the discussion of thread states
below.  If creation of the new interpreter is unsuccessful, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is
returned; no exception is set since the exception state is stored in the
current thread state and there may not be a current thread state.  (Like all
other Python/C API functions, the global interpreter lock must be held before
calling this function and is still held when it returns; however, unlike most
other Python/C API functions, there needn't be a current thread state on
entry.)</p>
<p id="index-43">Extension modules are shared between (sub-)interpreters as follows:</p>
<ul>
<li><p>For modules using multi-phase initialization,
e.g. <a class="reference internal" href="module.html#c.PyModule_FromDefAndSpec" title="PyModule_FromDefAndSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_FromDefAndSpec()</span></code></a>, a separate module object is
created and initialized for each interpreter.
Only C-level static and global variables are shared between these
module objects.</p></li>
<li><p>For modules using single-phase initialization,
e.g. <a class="reference internal" href="module.html#c.PyModule_Create" title="PyModule_Create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_Create()</span></code></a>, the first time a particular extension
is imported, it is initialized normally, and a (shallow) copy of its
module's dictionary is squirreled away.
When the same extension is imported by another (sub-)interpreter, a new
module is initialized and filled with the contents of this copy; the
extension's <code class="docutils literal notranslate"><span class="pre">init</span></code> function is not called.
Objects in the module's dictionary thus end up shared across
(sub-)interpreters, which might cause unwanted behavior (see
<a class="reference internal" href="#bugs-and-caveats">Bugs and caveats</a> below).</p>
<p>Note that this is different from what happens when an extension is
imported after the interpreter has been completely re-initialized by
calling <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> and <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>; in that
case, the extension's <code class="docutils literal notranslate"><span class="pre">initmodule</span></code> function <em>is</em> called again.
As with multi-phase initialization, this means that only C-level static
and global variables are shared between these modules.</p>
</li>
</ul>
<span class="target" id="index-44"></span></dd></dl>

<dl class="function">
<dt id="c.Py_EndInterpreter">
void <code class="sig-name descname">Py_EndInterpreter</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_EndInterpreter" title="정의 주소">¶</a></dt>
<dd><p id="index-45">Destroy the (sub-)interpreter represented by the given thread state. The given
thread state must be the current thread state.  See the discussion of thread
states below.  When the call returns, the current thread state is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  All
thread states associated with this interpreter are destroyed.  (The global
interpreter lock must be held before calling this function and is still held
when it returns.)  <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> will destroy all sub-interpreters that
haven't been explicitly destroyed at that point.</p>
</dd></dl>

<div class="section" id="bugs-and-caveats">
<h3>Bugs and caveats<a class="headerlink" href="#bugs-and-caveats" title="제목 주소">¶</a></h3>
<p>Because sub-interpreters (and the main interpreter) are part of the same
process, the insulation between them isn't perfect --- for example, using
low-level file operations like  <a class="reference internal" href="../library/os.html#os.close" title="os.close"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.close()</span></code></a> they can
(accidentally or maliciously) affect each other's open files.  Because of the
way extensions are shared between (sub-)interpreters, some extensions may not
work properly; this is especially likely when using single-phase initialization
or (static) global variables.
It is possible to insert objects created in one sub-interpreter into
a namespace of another (sub-)interpreter; this should be avoided if possible.</p>
<p>Special care should be taken to avoid sharing user-defined functions,
methods, instances or classes between sub-interpreters, since import
operations executed by such objects may affect the wrong (sub-)interpreter's
dictionary of loaded modules. It is equally important to avoid sharing
objects from which the above are reachable.</p>
<p>Also note that combining this functionality with <code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_*()</span></code> APIs
is delicate, because these APIs assume a bijection between Python thread states
and OS-level threads, an assumption broken by the presence of sub-interpreters.
It is highly recommended that you don't switch sub-interpreters between a pair
of matching <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> and <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> calls.
Furthermore, extensions (such as <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>) using these APIs to allow calling
of Python code from non-Python created threads will probably be broken when using
sub-interpreters.</p>
</div>
</div>
<div class="section" id="asynchronous-notifications">
<h2>Asynchronous Notifications<a class="headerlink" href="#asynchronous-notifications" title="제목 주소">¶</a></h2>
<p>A mechanism is provided to make asynchronous notifications to the main
interpreter thread.  These notifications take the form of a function
pointer and a void pointer argument.</p>
<dl class="function">
<dt id="c.Py_AddPendingCall">
int <code class="sig-name descname">Py_AddPendingCall</code><span class="sig-paren">(</span>int (<em>*func</em>)(void *), void<em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_AddPendingCall" title="정의 주소">¶</a></dt>
<dd><p id="index-46">Schedule a function to be called from the main interpreter thread.  On
success, <code class="docutils literal notranslate"><span class="pre">0</span></code> is returned and <em>func</em> is queued for being called in the
main thread.  On failure, <code class="docutils literal notranslate"><span class="pre">-1</span></code> is returned without setting any exception.</p>
<p>When successfully queued, <em>func</em> will be <em>eventually</em> called from the
main interpreter thread with the argument <em>arg</em>.  It will be called
asynchronously with respect to normally running Python code, but with
both these conditions met:</p>
<ul class="simple">
<li><p>on a <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> boundary;</p></li>
<li><p>with the main thread holding the <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a>
(<em>func</em> can therefore use the full C API).</p></li>
</ul>
<p><em>func</em> must return <code class="docutils literal notranslate"><span class="pre">0</span></code> on success, or <code class="docutils literal notranslate"><span class="pre">-1</span></code> on failure with an exception
set.  <em>func</em> won't be interrupted to perform another asynchronous
notification recursively, but it can still be interrupted to switch
threads if the global interpreter lock is released.</p>
<p>This function doesn't need a current thread state to run, and it doesn't
need the global interpreter lock.</p>
<p>To call this function in a subinterpreter, the caller must hold the GIL.
Otherwise, the function <em>func</em> can be scheduled to be called from the wrong
interpreter.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>This is a low-level function, only useful for very special cases.
There is no guarantee that <em>func</em> will be called as quick as
possible.  If the main thread is busy executing a system call,
<em>func</em> won't be called before the system call returns.  This
function is generally <strong>not</strong> suitable for calling Python code from
arbitrary C threads.  Instead, use the <a class="reference internal" href="#gilstate"><span class="std std-ref">PyGILState API</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>If this function is called in a subinterpreter, the function <em>func</em> is
now scheduled to be called from the subinterpreter, rather than being
called from the main interpreter. Each subinterpreter now has its own
list of scheduled calls.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="profiling-and-tracing">
<span id="profiling"></span><h2>Profiling and Tracing<a class="headerlink" href="#profiling-and-tracing" title="제목 주소">¶</a></h2>
<p>The Python interpreter provides some low-level support for attaching profiling
and execution tracing facilities.  These are used for profiling, debugging, and
coverage analysis tools.</p>
<p>This C interface allows the profiling or tracing code to avoid the overhead of
calling through Python-level callable objects, making a direct C function call
instead.  The essential attributes of the facility have not changed; the
interface allows trace functions to be installed per-thread, and the basic
events reported to the trace function are the same as had been reported to the
Python-level trace functions in previous versions.</p>
<dl class="type">
<dt id="c.Py_tracefunc">
int <code class="sig-name descname">(*Py_tracefunc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em>, <a class="reference internal" href="veryhigh.html#c.PyFrameObject" title="PyFrameObject">PyFrameObject</a><em> *frame</em>, int<em> what</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_tracefunc" title="정의 주소">¶</a></dt>
<dd><p>The type of the trace function registered using <a class="reference internal" href="#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a> and
<a class="reference internal" href="#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a>. The first parameter is the object passed to the
registration function as <em>obj</em>, <em>frame</em> is the frame object to which the event
pertains, <em>what</em> is one of the constants <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_CALL</span></code>,
<code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_EXCEPTION</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_LINE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_RETURN</span></code>,
<code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_CALL</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_EXCEPTION</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_RETURN</span></code>,
or <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_OPCODE</span></code>, and <em>arg</em> depends on the value of <em>what</em>:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value of <em>what</em></p></th>
<th class="head"><p>Meaning of <em>arg</em></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_CALL</span></code></p></td>
<td><p>Always <a class="reference internal" href="none.html#c.Py_None" title="Py_None"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_None</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_EXCEPTION</span></code></p></td>
<td><p>Exception information as returned by
<a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_LINE</span></code></p></td>
<td><p>Always <a class="reference internal" href="none.html#c.Py_None" title="Py_None"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_None</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_RETURN</span></code></p></td>
<td><p>Value being returned to the caller,
or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if caused by an exception.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_CALL</span></code></p></td>
<td><p>Function object being called.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_EXCEPTION</span></code></p></td>
<td><p>Function object being called.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_RETURN</span></code></p></td>
<td><p>Function object being called.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_OPCODE</span></code></p></td>
<td><p>Always <a class="reference internal" href="none.html#c.Py_None" title="Py_None"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_None</span></code></a>.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_CALL">
int <code class="sig-name descname">PyTrace_CALL</code><a class="headerlink" href="#c.PyTrace_CALL" title="정의 주소">¶</a></dt>
<dd><p>The value of the <em>what</em> parameter to a <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> function when a new
call to a function or method is being reported, or a new entry into a generator.
Note that the creation of the iterator for a generator function is not reported
as there is no control transfer to the Python bytecode in the corresponding
frame.</p>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_EXCEPTION">
int <code class="sig-name descname">PyTrace_EXCEPTION</code><a class="headerlink" href="#c.PyTrace_EXCEPTION" title="정의 주소">¶</a></dt>
<dd><p>The value of the <em>what</em> parameter to a <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> function when an
exception has been raised.  The callback function is called with this value for
<em>what</em> when after any bytecode is processed after which the exception becomes
set within the frame being executed.  The effect of this is that as exception
propagation causes the Python stack to unwind, the callback is called upon
return to each frame as the exception propagates.  Only trace functions receives
these events; they are not needed by the profiler.</p>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_LINE">
int <code class="sig-name descname">PyTrace_LINE</code><a class="headerlink" href="#c.PyTrace_LINE" title="정의 주소">¶</a></dt>
<dd><p>The value passed as the <em>what</em> parameter to a <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> function
(but not a profiling function) when a line-number event is being reported.
It may be disabled for a frame by setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_lines</span></code> to <em>0</em> on that frame.</p>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_RETURN">
int <code class="sig-name descname">PyTrace_RETURN</code><a class="headerlink" href="#c.PyTrace_RETURN" title="정의 주소">¶</a></dt>
<dd><p>The value for the <em>what</em> parameter to <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> functions when a
call is about to return.</p>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_C_CALL">
int <code class="sig-name descname">PyTrace_C_CALL</code><a class="headerlink" href="#c.PyTrace_C_CALL" title="정의 주소">¶</a></dt>
<dd><p>The value for the <em>what</em> parameter to <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> functions when a C
function is about to be called.</p>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_C_EXCEPTION">
int <code class="sig-name descname">PyTrace_C_EXCEPTION</code><a class="headerlink" href="#c.PyTrace_C_EXCEPTION" title="정의 주소">¶</a></dt>
<dd><p>The value for the <em>what</em> parameter to <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> functions when a C
function has raised an exception.</p>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_C_RETURN">
int <code class="sig-name descname">PyTrace_C_RETURN</code><a class="headerlink" href="#c.PyTrace_C_RETURN" title="정의 주소">¶</a></dt>
<dd><p>The value for the <em>what</em> parameter to <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> functions when a C
function has returned.</p>
</dd></dl>

<dl class="var">
<dt id="c.PyTrace_OPCODE">
int <code class="sig-name descname">PyTrace_OPCODE</code><a class="headerlink" href="#c.PyTrace_OPCODE" title="정의 주소">¶</a></dt>
<dd><p>The value for the <em>what</em> parameter to <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> functions (but not
profiling functions) when a new opcode is about to be executed.  This event is
not emitted by default: it must be explicitly requested by setting
<code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_opcodes</span></code> to <em>1</em> on the frame.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_SetProfile">
void <code class="sig-name descname">PyEval_SetProfile</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc">Py_tracefunc</a><em> func</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_SetProfile" title="정의 주소">¶</a></dt>
<dd><p>Set the profiler function to <em>func</em>.  The <em>obj</em> parameter is passed to the
function as its first parameter, and may be any Python object, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  If
the profile function needs to maintain state, using a different value for <em>obj</em>
for each thread provides a convenient and thread-safe place to store it.  The
profile function is called for all monitored events except <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_LINE</span></code>
<code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_OPCODE</span></code> and <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_EXCEPTION</span></code>.</p>
<p>The caller must hold the <a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyEval_SetTrace">
void <code class="sig-name descname">PyEval_SetTrace</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc">Py_tracefunc</a><em> func</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_SetTrace" title="정의 주소">¶</a></dt>
<dd><p>Set the tracing function to <em>func</em>.  This is similar to
<a class="reference internal" href="#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a>, except the tracing function does receive line-number
events and per-opcode events, but does not receive any event related to C function
objects being called.  Any trace function registered using <a class="reference internal" href="#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a>
will not receive <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_CALL</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_EXCEPTION</span></code> or
<code class="xref py py-const docutils literal notranslate"><span class="pre">PyTrace_C_RETURN</span></code> as a value for the <em>what</em> parameter.</p>
<p>The caller must hold the <a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>.</p>
</dd></dl>

</div>
<div class="section" id="advanced-debugger-support">
<span id="advanced-debugging"></span><h2>Advanced Debugger Support<a class="headerlink" href="#advanced-debugger-support" title="제목 주소">¶</a></h2>
<p>These functions are only intended to be used by advanced debugging tools.</p>
<dl class="function">
<dt id="c.PyInterpreterState_Head">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <code class="sig-name descname">PyInterpreterState_Head</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Head" title="정의 주소">¶</a></dt>
<dd><p>Return the interpreter state object at the head of the list of all such objects.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_Main">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <code class="sig-name descname">PyInterpreterState_Main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Main" title="정의 주소">¶</a></dt>
<dd><p>Return the main interpreter state object.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_Next">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a>* <code class="sig-name descname">PyInterpreterState_Next</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Next" title="정의 주소">¶</a></dt>
<dd><p>Return the next interpreter state object after <em>interp</em> from the list of all
such objects.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyInterpreterState_ThreadHead">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a> * <code class="sig-name descname">PyInterpreterState_ThreadHead</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState">PyInterpreterState</a><em> *interp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_ThreadHead" title="정의 주소">¶</a></dt>
<dd><p>Return the pointer to the first <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> object in the list of
threads associated with the interpreter <em>interp</em>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThreadState_Next">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a>* <code class="sig-name descname">PyThreadState_Next</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState">PyThreadState</a><em> *tstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Next" title="정의 주소">¶</a></dt>
<dd><p>Return the next thread state object after <em>tstate</em> from the list of all such
objects belonging to the same <a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> object.</p>
</dd></dl>

</div>
<div class="section" id="thread-local-storage-support">
<span id="thread-local-storage"></span><h2>Thread Local Storage Support<a class="headerlink" href="#thread-local-storage-support" title="제목 주소">¶</a></h2>
<p>The Python interpreter provides low-level support for thread-local storage
(TLS) which wraps the underlying native TLS implementation to support the
Python-level thread local storage API (<a class="reference internal" href="../library/threading.html#threading.local" title="threading.local"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.local</span></code></a>).  The
CPython C level APIs are similar to those offered by pthreads and Windows:
use a thread key and functions to associate a <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> value per
thread.</p>
<p>The GIL does <em>not</em> need to be held when calling these functions; they supply
their own locking.</p>
<p>Note that <code class="file docutils literal notranslate"><span class="pre">Python.h</span></code> does not include the declaration of the TLS APIs,
you need to include <code class="file docutils literal notranslate"><span class="pre">pythread.h</span></code> to use thread-local storage.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>None of these API functions handle memory management on behalf of the
<code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> values.  You need to allocate and deallocate them yourself.
If the <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> values happen to be <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code></a>, these
functions don't do refcount operations on them either.</p>
</div>
<div class="section" id="thread-specific-storage-tss-api">
<span id="thread-specific-storage-api"></span><h3>Thread Specific Storage (TSS) API<a class="headerlink" href="#thread-specific-storage-tss-api" title="제목 주소">¶</a></h3>
<p>TSS API is introduced to supersede the use of the existing TLS API within the
CPython interpreter.  This API uses a new type <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> instead of
<code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> to represent thread keys.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>&quot;A New C-API for Thread-Local Storage in CPython&quot; (<span class="target" id="index-47"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0539"><strong>PEP 539</strong></a>)</p>
</div>
<dl class="type">
<dt id="c.Py_tss_t">
<code class="sig-name descname">Py_tss_t</code><a class="headerlink" href="#c.Py_tss_t" title="정의 주소">¶</a></dt>
<dd><p>This data structure represents the state of a thread key, the definition of
which may depend on the underlying TLS implementation, and it has an
internal field representing the key's initialization state.  There are no
public members in this structure.</p>
<p>When <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Py_LIMITED_API</span></a> is not defined, static allocation of
this type by <a class="reference internal" href="#c.Py_tss_NEEDS_INIT" title="Py_tss_NEEDS_INIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_tss_NEEDS_INIT</span></code></a> is allowed.</p>
</dd></dl>

<dl class="macro">
<dt id="c.Py_tss_NEEDS_INIT">
<code class="sig-name descname">Py_tss_NEEDS_INIT</code><a class="headerlink" href="#c.Py_tss_NEEDS_INIT" title="정의 주소">¶</a></dt>
<dd><p>This macro expands to the initializer for <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> variables.
Note that this macro won't be defined with <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Py_LIMITED_API</span></a>.</p>
</dd></dl>

<div class="section" id="dynamic-allocation">
<h4>Dynamic Allocation<a class="headerlink" href="#dynamic-allocation" title="제목 주소">¶</a></h4>
<p>Dynamic allocation of the <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a>, required in extension modules
built with <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Py_LIMITED_API</span></a>, where static allocation of this type
is not possible due to its implementation being opaque at build time.</p>
<dl class="function">
<dt id="c.PyThread_tss_alloc">
<a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t">Py_tss_t</a>* <code class="sig-name descname">PyThread_tss_alloc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_alloc" title="정의 주소">¶</a></dt>
<dd><p>Return a value which is the same state as a value initialized with
<a class="reference internal" href="#c.Py_tss_NEEDS_INIT" title="Py_tss_NEEDS_INIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_tss_NEEDS_INIT</span></code></a>, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in the case of dynamic allocation
failure.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThread_tss_free">
void <code class="sig-name descname">PyThread_tss_free</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t">Py_tss_t</a><em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_free" title="정의 주소">¶</a></dt>
<dd><p>Free the given <em>key</em> allocated by <a class="reference internal" href="#c.PyThread_tss_alloc" title="PyThread_tss_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_alloc()</span></code></a>, after
first calling <a class="reference internal" href="#c.PyThread_tss_delete" title="PyThread_tss_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_delete()</span></code></a> to ensure any associated
thread locals have been unassigned. This is a no-op if the <em>key</em>
argument is <cite>NULL</cite>.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>A freed key becomes a dangling pointer, you should reset the key to
<cite>NULL</cite>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="methods">
<h4>Methods<a class="headerlink" href="#methods" title="제목 주소">¶</a></h4>
<p>The parameter <em>key</em> of these functions must not be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  Moreover, the
behaviors of <a class="reference internal" href="#c.PyThread_tss_set" title="PyThread_tss_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_set()</span></code></a> and <a class="reference internal" href="#c.PyThread_tss_get" title="PyThread_tss_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_get()</span></code></a> are
undefined if the given <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> has not been initialized by
<a class="reference internal" href="#c.PyThread_tss_create" title="PyThread_tss_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_create()</span></code></a>.</p>
<dl class="function">
<dt id="c.PyThread_tss_is_created">
int <code class="sig-name descname">PyThread_tss_is_created</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t">Py_tss_t</a><em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_is_created" title="정의 주소">¶</a></dt>
<dd><p>Return a non-zero value if the given <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> has been initialized
by <a class="reference internal" href="#c.PyThread_tss_create" title="PyThread_tss_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_create()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThread_tss_create">
int <code class="sig-name descname">PyThread_tss_create</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t">Py_tss_t</a><em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_create" title="정의 주소">¶</a></dt>
<dd><p>Return a zero value on successful initialization of a TSS key.  The behavior
is undefined if the value pointed to by the <em>key</em> argument is not
initialized by <a class="reference internal" href="#c.Py_tss_NEEDS_INIT" title="Py_tss_NEEDS_INIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_tss_NEEDS_INIT</span></code></a>.  This function can be called
repeatedly on the same key -- calling it on an already initialized key is a
no-op and immediately returns success.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThread_tss_delete">
void <code class="sig-name descname">PyThread_tss_delete</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t">Py_tss_t</a><em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_delete" title="정의 주소">¶</a></dt>
<dd><p>Destroy a TSS key to forget the values associated with the key across all
threads, and change the key's initialization state to uninitialized.  A
destroyed key is able to be initialized again by
<a class="reference internal" href="#c.PyThread_tss_create" title="PyThread_tss_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_create()</span></code></a>. This function can be called repeatedly on
the same key -- calling it on an already destroyed key is a no-op.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThread_tss_set">
int <code class="sig-name descname">PyThread_tss_set</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t">Py_tss_t</a><em> *key</em>, void<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_set" title="정의 주소">¶</a></dt>
<dd><p>Return a zero value to indicate successfully associating a <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code>
value with a TSS key in the current thread.  Each thread has a distinct
mapping of the key to a <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> value.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyThread_tss_get">
void* <code class="sig-name descname">PyThread_tss_get</code><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t">Py_tss_t</a><em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_get" title="정의 주소">¶</a></dt>
<dd><p>Return the <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> value associated with a TSS key in the current
thread.  This returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no value is associated with the key in the
current thread.</p>
</dd></dl>

</div>
</div>
<div class="section" id="thread-local-storage-tls-api">
<span id="thread-local-storage-api"></span><h3>Thread Local Storage (TLS) API<a class="headerlink" href="#thread-local-storage-tls-api" title="제목 주소">¶</a></h3>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.7부터 폐지: </span>This API is superseded by
<a class="reference internal" href="#thread-specific-storage-api"><span class="std std-ref">Thread Specific Storage (TSS) API</span></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>This version of the API does not support platforms where the native TLS key
is defined in a way that cannot be safely cast to <code class="docutils literal notranslate"><span class="pre">int</span></code>.  On such platforms,
<a class="reference internal" href="#c.PyThread_create_key" title="PyThread_create_key"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_create_key()</span></code></a> will return immediately with a failure status,
and the other TLS functions will all be no-ops on such platforms.</p>
</div>
<p>Due to the compatibility problem noted above, this version of the API should not
be used in new code.</p>
<dl class="function">
<dt id="c.PyThread_create_key">
int <code class="sig-name descname">PyThread_create_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_create_key" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.PyThread_delete_key">
void <code class="sig-name descname">PyThread_delete_key</code><span class="sig-paren">(</span>int<em> key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_delete_key" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.PyThread_set_key_value">
int <code class="sig-name descname">PyThread_set_key_value</code><span class="sig-paren">(</span>int<em> key</em>, void<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_set_key_value" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.PyThread_get_key_value">
void* <code class="sig-name descname">PyThread_get_key_value</code><span class="sig-paren">(</span>int<em> key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_get_key_value" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.PyThread_delete_key_value">
void <code class="sig-name descname">PyThread_delete_key_value</code><span class="sig-paren">(</span>int<em> key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_delete_key_value" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="c.PyThread_ReInitTLS">
void <code class="sig-name descname">PyThread_ReInitTLS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_ReInitTLS" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">초기화, 파이널리제이션 및 스레드</a><ul>
<li><a class="reference internal" href="#before-python-initialization">파이썬 초기화 전</a></li>
<li><a class="reference internal" href="#global-configuration-variables">전역 구성 변수</a></li>
<li><a class="reference internal" href="#initializing-and-finalizing-the-interpreter">인터프리터 초기화와 파이널리제이션</a></li>
<li><a class="reference internal" href="#process-wide-parameters">프로세스 전체 매개 변수</a></li>
<li><a class="reference internal" href="#thread-state-and-the-global-interpreter-lock">Thread State and the Global Interpreter Lock</a><ul>
<li><a class="reference internal" href="#releasing-the-gil-from-extension-code">Releasing the GIL from extension code</a></li>
<li><a class="reference internal" href="#non-python-created-threads">Non-Python created threads</a></li>
<li><a class="reference internal" href="#cautions-about-fork">Cautions about fork()</a></li>
<li><a class="reference internal" href="#high-level-api">High-level API</a></li>
<li><a class="reference internal" href="#low-level-api">Low-level API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sub-interpreter-support">Sub-interpreter support</a><ul>
<li><a class="reference internal" href="#bugs-and-caveats">Bugs and caveats</a></li>
</ul>
</li>
<li><a class="reference internal" href="#asynchronous-notifications">Asynchronous Notifications</a></li>
<li><a class="reference internal" href="#profiling-and-tracing">Profiling and Tracing</a></li>
<li><a class="reference internal" href="#advanced-debugger-support">Advanced Debugger Support</a></li>
<li><a class="reference internal" href="#thread-local-storage-support">Thread Local Storage Support</a><ul>
<li><a class="reference internal" href="#thread-specific-storage-tss-api">Thread Specific Storage (TSS) API</a><ul>
<li><a class="reference internal" href="#dynamic-allocation">Dynamic Allocation</a></li>
<li><a class="reference internal" href="#methods">Methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#thread-local-storage-tls-api">Thread Local Storage (TLS) API</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="datetime.html"
                        title="이전 장">DateTime 객체</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="init_config.html"
                        title="다음 장">파이썬 초기화 구성</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="init_config.html" title="파이썬 초기화 구성"
             >다음</a> |</li>
        <li class="right" >
          <a href="datetime.html" title="DateTime 객체"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬/C API 레퍼런스 설명서</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>