
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>doctest --- 대화형 파이썬 예제 테스트 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="unittest --- 단위 테스트 프레임워크" href="unittest.html" />
    <link rel="prev" title="pydoc --- 설명서 생성과 온라인 도움말 시스템" href="pydoc.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/doctest.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="unittest.html" title="unittest --- 단위 테스트 프레임워크"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc --- 설명서 생성과 온라인 도움말 시스템"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">개발 도구</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-doctest">
<span id="doctest-test-interactive-python-examples"></span><h1><a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> --- 대화형 파이썬 예제 테스트<a class="headerlink" href="#module-doctest" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/doctest.py">Lib/doctest.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 모듈은 대화형 파이썬 세션처럼 보이는 텍스트를 검색한 다음, 해당 세션을 실행하여 표시된 대로 정확하게 작동하는지 검증합니다. doctest를 사용하는 몇 가지 일반적인 방법이 있습니다:</p>
<ul class="simple">
<li><p>모든 대화식 예제가 설명된 대로 작동하는지 확인하여 모듈의 독스트링이 최신인지 확인합니다.</p></li>
<li><p>테스트 파일이나 테스트 객체의 대화형 예제가 예상대로 작동하는지 확인하여 회귀 테스트를 수행합니다.</p></li>
<li><p>입/출력 예제를 그대로 보여줌으로써 패키지에 대한 자습서를 작성합니다. 예제나 설명문 중 어느 것이 강조되는지에 따라, &quot;문학적 테스트(literate testing)&quot;나 &quot;실행 가능한 설명서(executable documentation)&quot;의 느낌을 줍니다.</p></li>
</ul>
<p>여기에 완전하지만 작은 예제 모듈이 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">이것은 &quot;예제&quot; 모듈입니다.</span>

<span class="sd">예제 모듈은 factorial() 함수 하나를 제공합니다. 예를 들어,</span>

<span class="sd">&gt;&gt;&gt; factorial(5)</span>
<span class="sd">120</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;n의 계승을 반환합니다, 정확한 정수 &gt;= 0.</span>

<span class="sd">    &gt;&gt;&gt; [factorial(n) for n in range(6)]</span>
<span class="sd">    [1, 1, 2, 6, 24, 120]</span>
<span class="sd">    &gt;&gt;&gt; factorial(30)</span>
<span class="sd">    265252859812191058636308480000000</span>
<span class="sd">    &gt;&gt;&gt; factorial(-1)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    ValueError: n must be &gt;= 0</span>

<span class="sd">    float의 계승도 좋습니다만, float는 정확한 정수여야 합니다:</span>
<span class="sd">    &gt;&gt;&gt; factorial(30.1)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    ValueError: n must be exact integer</span>
<span class="sd">    &gt;&gt;&gt; factorial(30.0)</span>
<span class="sd">    265252859812191058636308480000000</span>

<span class="sd">    또한 터무니없이 크지 않아야 합니다:</span>
<span class="sd">    &gt;&gt;&gt; factorial(1e100)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    OverflowError: n too large</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">math</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be &gt;= 0&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be exact integer&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>  <span class="c1"># 1e300과 같은 값을 잡아냅니다</span>
        <span class="k">raise</span> <span class="ne">OverflowError</span><span class="p">(</span><span class="s2">&quot;n too large&quot;</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">while</span> <span class="n">factor</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">*=</span> <span class="n">factor</span>
        <span class="n">factor</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="file docutils literal notranslate"><span class="pre">example.py</span></code>를 명령 줄에서 직접 실행하면, <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>가 마술을 부리기 시작합니다:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python example.py
<span class="gp">$</span>
</pre></div>
</div>
<p>출력이 없습니다! 이것이 정상이며, 모든 예제가 작동했다는 것을 뜻합니다. <code class="docutils literal notranslate"><span class="pre">-v</span></code>를 스크립트에 전달하면, <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>는 시도하고 있는 내용에 대한 자세한 로그를 출력하고 끝에 요약을 인쇄합니다.:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python example.py -v
<span class="go">Trying:</span>
<span class="go">    factorial(5)</span>
<span class="go">Expecting:</span>
<span class="go">    120</span>
<span class="go">ok</span>
<span class="go">Trying:</span>
<span class="go">    [factorial(n) for n in range(6)]</span>
<span class="go">Expecting:</span>
<span class="go">    [1, 1, 2, 6, 24, 120]</span>
<span class="go">ok</span>
</pre></div>
</div>
<p>결국, 다음과 같이 끝납니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Trying:
    factorial(1e100)
Expecting:
    Traceback (most recent call last):
        ...
    OverflowError: n too large
ok
2 items passed all tests:
   1 tests in __main__
   8 tests in __main__.factorial
9 tests in 2 items.
9 passed and 0 failed.
Test passed.
$
</pre></div>
</div>
<p>이것이 <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>를 생산적으로 사용하기 위해서 알아야 할 모든 것입니다! 시도해 보세요. 다음 절에서는 자세한 내용을 제공합니다. 표준 파이썬 테스트 스위트와 라이브러리에는 doctest 예제가 많습니다. 특히 유용한 예제는 표준 테스트 파일 <code class="file docutils literal notranslate"><span class="pre">Lib/test/test_doctest.py</span></code>에서 찾을 수 있습니다.</p>
<div class="section" id="simple-usage-checking-examples-in-docstrings">
<span id="doctest-simple-testmod"></span><h2>간단한 사용법: 독스트링에 있는 예제 확인하기<a class="headerlink" href="#simple-usage-checking-examples-in-docstrings" title="제목 주소">¶</a></h2>
<p>doctest를 사용하는 가장 간단한 방법은 (하지만 계속 이렇게 할 필요는 없습니다) 각 모듈 <code class="xref py py-mod docutils literal notranslate"><span class="pre">M</span></code>을 다음과 같이 끝내는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>
</div>
<p>그러면 <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>는 모듈 <code class="xref py py-mod docutils literal notranslate"><span class="pre">M</span></code>의 독스트링을 검사합니다.</p>
<p>모듈을 스크립트로 실행하면 독스트링의 예제가 실행되고 검증됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">M</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>예제가 실패하지 않는 한 아무것도 표시되지 않습니다, 실패하면 실패한 예제와 실패 원인이 stdout으로 출력되고, 마지막 출력 줄은 <code class="docutils literal notranslate"><span class="pre">***Test</span> <span class="pre">Failed***</span> <span class="pre">N</span> <span class="pre">failures.</span></code>입니다. 여기서 <em>N</em>은 실패한 예제의 수입니다.</p>
<p>대신 <code class="docutils literal notranslate"><span class="pre">-v</span></code> 스위치로 실행해 보십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">M</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">v</span>
</pre></div>
</div>
<p>그러면 시도한 모든 예제에 대한 자세한 보고서가 표준 출력으로 출력되고, 끝에 정돈된 요약이 붙습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">verbose=True</span></code>를 <a class="reference internal" href="#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">testmod()</span></code></a>에 전달하여 상세 모드를 강제하거나, <code class="docutils literal notranslate"><span class="pre">verbose=False</span></code>를 전달하여 상세 모드를 금지할 수 있습니다. 두 경우 모두, <code class="docutils literal notranslate"><span class="pre">sys.argv</span></code>는 <a class="reference internal" href="#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">testmod()</span></code></a>에 의해 검사되지 않습니다 (따라서 <code class="docutils literal notranslate"><span class="pre">-v</span></code>를 전달하거나 그렇지 않아도 효과가 없습니다).</p>
<p>또한 <a class="reference internal" href="#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">testmod()</span></code></a>를 실행하는 명령 줄 단축법이 있습니다. 파이썬 인터프리터에게 표준 라이브러리에서 직접 doctest 모듈을 실행하도록 지시하고 명령 줄에 모듈 이름(들)을 전달할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">doctest</span> <span class="o">-</span><span class="n">v</span> <span class="n">example</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>이렇게 하면 <code class="file docutils literal notranslate"><span class="pre">example.py</span></code>를 독립 실행형 모듈로 임포트하고, <a class="reference internal" href="#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">testmod()</span></code></a>를 실행합니다. 파일이 패키지 일부이고 그 패키지에서 다른 서브 모듈을 임포트하면, 올바르게 작동하지 않을 수 있음에 유의하십시오.</p>
<p><a class="reference internal" href="#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">testmod()</span></code></a>에 대한 자세한 내용은, <a class="reference internal" href="#doctest-basic-api"><span class="std std-ref">기본 API</span></a> 절을 참조하십시오.</p>
</div>
<div class="section" id="simple-usage-checking-examples-in-a-text-file">
<span id="doctest-simple-testfile"></span><h2>간단한 사용법: 텍스트 파일에 있는 예제 확인하기<a class="headerlink" href="#simple-usage-checking-examples-in-a-text-file" title="제목 주소">¶</a></h2>
<p>doctest의 또 다른 간단한 활용은 텍스트 파일에 있는 대화형 예제를 테스트하는 것입니다. 이것은 <a class="reference internal" href="#doctest.testfile" title="doctest.testfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">testfile()</span></code></a> 함수로 수행할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">doctest</span>
<span class="n">doctest</span><span class="o">.</span><span class="n">testfile</span><span class="p">(</span><span class="s2">&quot;example.txt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>이 짧은 스크립트는 <code class="file docutils literal notranslate"><span class="pre">example.txt</span></code> 파일에 들어있는 대화형 파이썬 예제를 실행하고 검증합니다. 파일 내용은 하나의 거대한 독스트링인 것처럼 취급됩니다; 파일이 파이썬 프로그램일 필요가 없습니다! 예를 들어, <code class="file docutils literal notranslate"><span class="pre">example.txt</span></code>에 다음과 같은 것이 들어있습니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The ``example`` module
======================

Using ``factorial``
-------------------

This is an example text file in reStructuredText format.  First import
``factorial`` from the ``example`` module:

    &gt;&gt;&gt; from example import factorial

Now use it:

    &gt;&gt;&gt; factorial(6)
    120
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">doctest.testfile(&quot;example.txt&quot;)</span></code>를 실행하면 이 문서에 있는 에러를 찾습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">File</span> <span class="s2">&quot;./example.txt&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">14</span><span class="p">,</span> <span class="ow">in</span> <span class="n">example</span><span class="o">.</span><span class="n">txt</span>
<span class="n">Failed</span> <span class="n">example</span><span class="p">:</span>
    <span class="n">factorial</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">Expected</span><span class="p">:</span>
    <span class="mi">120</span>
<span class="n">Got</span><span class="p">:</span>
    <span class="mi">720</span>
</pre></div>
</div>
<p><a class="reference internal" href="#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">testmod()</span></code></a>와 마찬가지로, <a class="reference internal" href="#doctest.testfile" title="doctest.testfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">testfile()</span></code></a>은 예제가 실패하지 않는 한 아무것도 표시하지 않습니다. 예제가 실패하면, 실패한 예제와 실패 원인이 <a class="reference internal" href="#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">testmod()</span></code></a>와 같은 형식을 사용하여 stdout에 인쇄됩니다.</p>
<p>기본적으로, <a class="reference internal" href="#doctest.testfile" title="doctest.testfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">testfile()</span></code></a>은 호출하는 모듈의 디렉터리에서 파일을 찾습니다. 다른 위치에서 파일을 찾도록 지시하는 데 사용할 수 있는 선택적 인자에 대한 설명은 <a class="reference internal" href="#doctest-basic-api"><span class="std std-ref">기본 API</span></a> 절을 참조하십시오.</p>
<p><a class="reference internal" href="#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">testmod()</span></code></a>와 마찬가지로, <a class="reference internal" href="#doctest.testfile" title="doctest.testfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">testfile()</span></code></a>의 상세도는 <code class="docutils literal notranslate"><span class="pre">-v</span></code> 명령 줄 스위치나 선택적 키워드 인자 <em>verbose</em>를 사용하여 설정할 수 있습니다.</p>
<p>또한 <a class="reference internal" href="#doctest.testfile" title="doctest.testfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">testfile()</span></code></a>를 실행하는 명령 줄 단축법이 있습니다. 파이썬 인터프리터에게 표준 라이브러리에서 직접 doctest 모듈을 실행하도록 지시하고 명령 줄에 파일 이름(들)을 전달할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">doctest</span> <span class="o">-</span><span class="n">v</span> <span class="n">example</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>파일 이름은 <code class="file docutils literal notranslate"><span class="pre">.py</span></code>로 끝나지 않으므로, <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>는 <a class="reference internal" href="#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">testmod()</span></code></a>가 아니라 <a class="reference internal" href="#doctest.testfile" title="doctest.testfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">testfile()</span></code></a>로 실행되어야 한다고 추론합니다.</p>
<p><a class="reference internal" href="#doctest.testfile" title="doctest.testfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">testfile()</span></code></a>에 대한 자세한 내용은, <a class="reference internal" href="#doctest-basic-api"><span class="std std-ref">기본 API</span></a> 절을 참조하십시오.</p>
</div>
<div class="section" id="how-it-works">
<span id="doctest-how-it-works"></span><h2>작동 방법<a class="headerlink" href="#how-it-works" title="제목 주소">¶</a></h2>
<p>이 절에서는 doctest가 어떻게 작동하는지 자세히 설명합니다: 어떤 독스트링을 살피는지, 대화형 예제를 어떻게 찾는지, 사용하는 실행 컨텍스트는 무엇인지, 예외를 어떻게 처리하는지, 어떻게 옵션 플래그를 사용하여 동작을 제어하는지. 이것은 doctest 예제를 작성하기 위해 알아야 할 정보입니다; 이러한 예제에 대해 실제로 doctest를 실행하는 방법에 대한 자세한 내용은 다음 절을 참조하십시오.</p>
<div class="section" id="which-docstrings-are-examined">
<span id="doctest-which-docstrings"></span><h3>어떤 독스트링을 검사합니까?<a class="headerlink" href="#which-docstrings-are-examined" title="제목 주소">¶</a></h3>
<p>모듈 독스트링과 모든 함수, 클래스 및 메서드 독스트링이 검색됩니다. 모듈로 임포트 된 객체는 검색되지 않습니다.</p>
<p>또한, <code class="docutils literal notranslate"><span class="pre">M.__test__</span></code>가 존재하고 &quot;참이면&quot;, 딕셔너리이어야 하고 각 항목은 (문자열) 이름을 함수 객체, 클래스 객체 또는 문자열에 매핑합니다. <code class="docutils literal notranslate"><span class="pre">M.__test__</span></code>에서 발견된 함수와 클래스 객체 독스트링이 검색되고, 문자열은 독스트링인 것처럼 처리됩니다. 출력에서, <code class="docutils literal notranslate"><span class="pre">M.__test__</span></code>의 키 <code class="docutils literal notranslate"><span class="pre">K</span></code>가 이름으로 나타납니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">name</span> <span class="n">of</span> <span class="n">M</span><span class="o">&gt;.</span><span class="n">__test__</span><span class="o">.</span><span class="n">K</span>
</pre></div>
</div>
<p>발견된 모든 클래스는 포함된 메서드와 중첩된 클래스의 독스트링을 테스트하기 위해 유사하게 재귀적으로 검색됩니다.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> 버전 3.4 이전에는, C로 작성된 확장 모듈은 doctest가 완전히 검색하지 못했습니다.</p>
</div>
</div>
<div class="section" id="how-are-docstring-examples-recognized">
<span id="doctest-finding-examples"></span><h3>독스트링 예제는 어떻게 인식됩니까?<a class="headerlink" href="#how-are-docstring-examples-recognized" title="제목 주소">¶</a></h3>
<p>대부분 대화형 콘솔 세션의 복사하여 붙여넣기가 잘 작동하지만, doctest는 특정 파이썬 셸의 정확한 에뮬레이션을 시도하지 않습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># comments are ignored</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">13</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;yes&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NO&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NO!!!&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">no</span>
<span class="go">NO</span>
<span class="go">NO!!!</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p id="index-0">모든 예상 출력은 코드가 포함된 마지막 <code class="docutils literal notranslate"><span class="pre">'&gt;&gt;&gt;</span> <span class="pre">'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'...</span> <span class="pre">'</span></code> 줄 바로 다음에 나와야 하며, (있다면) 예상 출력은 다음 <code class="docutils literal notranslate"><span class="pre">'&gt;&gt;&gt;</span> <span class="pre">'</span></code> 나 전체 공백 줄까지 확장됩니다.</p>
<p>세부 사항:</p>
<ul>
<li><p>예상 출력은 전체 공백 줄을 포함할 수 없습니다. 그러한 줄은 예상 출력의 끝으로 인식되기 때문입니다. 예상 출력이 빈 줄을 포함하면, doctest 예제에서 빈 줄이 나타나는 곳에 <code class="docutils literal notranslate"><span class="pre">&lt;BLANKLINE&gt;</span></code>을 넣으십시오.</p></li>
<li><p>모든 하드 탭 문자는 8열 탭 정지를 사용하여 스페이스로 확장됩니다. 테스트 된 코드에 의해 생성된 출력의 탭은 수정되지 않습니다. 샘플 출력의 모든 하드 탭이 <em>확장되므로</em>, 이것은 코드 출력에 하드 탭이 포함될 때 doctest가 통과할 수 있는 유일한 방법은, <a class="reference internal" href="#doctest.NORMALIZE_WHITESPACE" title="doctest.NORMALIZE_WHITESPACE"><code class="xref py py-const docutils literal notranslate"><span class="pre">NORMALIZE_WHITESPACE</span></code></a> 옵션이나 <a class="reference internal" href="#doctest-directives"><span class="std std-ref">지시자</span></a>가 유효한 경우뿐임을 의미합니다. 또는, 출력을 캡처하여 테스트 일부로 예상값과 비교하도록 테스트를 다시 작성할 수 있습니다. 이러한 소스의 탭 처리는 시행착오를 거쳐 얻어진 것이며, 가장 에러가 발생하지 않는 방법으로 입증되었습니다. 사용자 정의 <a class="reference internal" href="#doctest.DocTestParser" title="doctest.DocTestParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestParser</span></code></a> 클래스를 작성하여 탭 처리에 다른 알고리즘을 사용하는 것도 가능합니다.</p></li>
<li><p>stdout으로의 출력은 캡처되지만, stderr로의 출력은 그렇지 않습니다 (예외 트레이스백은 다른 수단을 통해 캡처됩니다).</p></li>
<li><p>대화식 세션에서 역 슬래시를 통해 줄을 계속하거나, 다른 이유로 백 슬래시를 사용하면, 날 독스트링(raw docstring)을 사용해서 역 슬래시를 입력한 그대로 유지해야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;Backslashes in a raw docstring: m\n&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
<span class="go">Backslashes in a raw docstring: m\n</span>
</pre></div>
</div>
<p>그렇지 않으면, 백 슬래시가 문자열 일부로 해석됩니다. 예를 들어, 위의 <code class="docutils literal notranslate"><span class="pre">\n</span></code>은 개행 문자로 해석됩니다. 또는, doctest 버전에서 각 백 슬래시를 중복시킬 수 있습니다 (그리고 날 문자열은 사용하지 않습니다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&#39;&#39;&#39;Backslashes in a raw docstring: m\\n&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
<span class="go">Backslashes in a raw docstring: m\n</span>
</pre></div>
</div>
</li>
<li><p>시작 열은 중요하지 않습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="s2">&quot;Easy!&quot;</span>
<span class="go">      &gt;&gt;&gt; import math</span>
<span class="go">          &gt;&gt;&gt; math.floor(1.9)</span>
<span class="go">          1</span>
</pre></div>
</div>
<p>그리고 예제를 시작한 초기 <code class="docutils literal notranslate"><span class="pre">'&gt;&gt;&gt;</span> <span class="pre">'</span></code> 줄에 나타나는 것만큼의 선행 공백을 예상 출력에서 제거합니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>여기서, 초기 <code class="docutils literal notranslate"><span class="pre">'&gt;&gt;&gt;</span> <span class="pre">'</span></code> 줄은 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 문이 아니라 <code class="docutils literal notranslate"><span class="pre">math.floor(1.9)</span></code> 줄을 뜻합니다.
즉 예상 출력을 만드는 직전의 <code class="docutils literal notranslate"><span class="pre">'&gt;&gt;&gt;</span> <span class="pre">'</span></code> 줄을 뜻합니다. &quot;초기&quot;라는 단어는 <code class="docutils literal notranslate"><span class="pre">'...</span> <span class="pre">'</span></code> 이
사용될 때를 고려한 것입니다.</p>
</div>
</li>
</ul>
</div>
<div class="section" id="what-s-the-execution-context">
<span id="doctest-execution-context"></span><h3>실행 컨텍스트란 무엇입니까?<a class="headerlink" href="#what-s-the-execution-context" title="제목 주소">¶</a></h3>
<p>기본적으로, <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>가 테스트할 독스트링을 찾을 때마다, <code class="xref py py-mod docutils literal notranslate"><span class="pre">M</span></code>의 전역 이름 공간(globals)의 <em>앝은 복사</em>를 사용하므로, 실행 중인 테스트는 모듈의 실제 전역을 변경하지 않고, <code class="xref py py-mod docutils literal notranslate"><span class="pre">M</span></code>의 한 테스트가 실수로 다른 테스트가 작동하도록 만드는 부스러기를 남기지 않습니다. 이는 예제가 <code class="xref py py-mod docutils literal notranslate"><span class="pre">M</span></code>에서 최상위 수준에 정의된 이름과 실행 중인 독스트링에서 앞서 정의한 이름을 자유롭게 사용할 수 있음을 의미합니다. 예제는 다른 독스트링에 정의된 이름을 볼 수 없습니다.</p>
<p>대신 <code class="docutils literal notranslate"><span class="pre">globs=your_dict</span></code>를 <a class="reference internal" href="#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">testmod()</span></code></a>나 <a class="reference internal" href="#doctest.testfile" title="doctest.testfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">testfile()</span></code></a>로 전달하여 실행 컨텍스트로 여러분 자신의 딕셔너리를 사용하도록 할 수 있습니다.</p>
</div>
<div class="section" id="what-about-exceptions">
<span id="doctest-exceptions"></span><h3>예외는 어떻게 됩니까?<a class="headerlink" href="#what-about-exceptions" title="제목 주소">¶</a></h3>
<p>문제없습니다, 트레이스백이 예제에 의해 생성된 유일한 출력이기만 하면 됩니다: 그냥 트레이스백을 붙여넣으십시오. <a class="footnote-reference brackets" href="#id2" id="id1">1</a> 트레이스백에는 빠르게 변할 가능성이 있는 세부 사항(예를 들어, 정확한 파일 경로와 줄 번호)이 포함되어 있으므로, 이것은 doctest가 수락할 내용에 유연하도록 신경 써야 하는 한 가지 사례입니다.</p>
<p>간단한 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">list.remove(x): x not in list</span>
</pre></div>
</div>
<p>이 doctest는 <code class="docutils literal notranslate"><span class="pre">list.remove(x):</span> <span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">list</span></code> 세부 정보를 포함하는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생하면 성공합니다.</p>
<p>예외의 예상 출력은 다음 두 줄 중 한 가지가 예제의 첫 번째 줄과 같게 들여쓰기 된 트레이스백 헤더로 시작해야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">innermost</span> <span class="n">last</span><span class="p">):</span>
</pre></div>
</div>
<p>트레이스백 헤더 다음에는 선택적인 트레이스백 스택이 오며, 그 내용은 doctest가 무시합니다. 보통 트레이스백 스택은 생략되거나, 대화형 세션에서 그대로 복사됩니다.</p>
<p>트레이스백 스택 다음에는 가장 흥미로운 부분이 옵니다: 예외 형과 세부 사항이 있는 줄. 대개 이것은 트레이스백의 마지막 줄이지만, 예외에 여러 줄로 구성된 세부 사항이 있으면 여러 줄로 확장될 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;multi</span><span class="se">\n</span><span class="s1">    line</span><span class="se">\n</span><span class="s1">detail&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">multi</span>
<span class="go">    line</span>
<span class="go">detail</span>
</pre></div>
</div>
<p>(<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>로 시작하는) 마지막 세 줄이 예외의 형 및 세부 사항과 비교되고, 나머지는 무시됩니다.</p>
<p>모범 사례는 예제에 중요한 설명으로서의 가치를 추가하지 않는 한 트레이스백 스택을 생략하는 것입니다. 따라서 마지막 예제는 이렇게 하는 것이 더 좋습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;multi</span><span class="se">\n</span><span class="s1">    line</span><span class="se">\n</span><span class="s1">detail&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">multi</span>
<span class="go">    line</span>
<span class="go">detail</span>
</pre></div>
</div>
<p>트레이스백이 매우 특별하게 취급된다는 점에 유의하십시오. 특히, 다시 작성된 예제에서, <code class="docutils literal notranslate"><span class="pre">...</span></code>의 사용은 doctest의 <a class="reference internal" href="#doctest.ELLIPSIS" title="doctest.ELLIPSIS"><code class="xref py py-const docutils literal notranslate"><span class="pre">ELLIPSIS</span></code></a> 옵션과 무관합니다. 이 예제의 줄임표는 생략하거나, 3개(혹은 300개)의 쉼표나 숫자 또는 몬티 파이썬 쇼의 들여쓰기 된 대본이어도 똑같이 잘 동작합니다.</p>
<p>한 번쯤 읽어야 할 세부 정보이지만, 기억할 필요는 없습니다:</p>
<ul class="simple">
<li><p>Doctest는 예상 출력이 예외 트레이스백에서 온 것인지 일반 인쇄에서 온 것인지 추측할 수 없습니다. 그래서, 예를 들어, <code class="docutils literal notranslate"><span class="pre">ValueError:</span> <span class="pre">42</span> <span class="pre">is</span> <span class="pre">prime</span></code>을 예상하는 예제는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 실제로 발생해도 통과하지만, 예제가 단지 그 트레이스백 텍스트를 출력해도 통과합니다. 실제로는, 일반 출력은 거의 트레이스백 헤더 줄로 시작하지 않으므로, 실제 문제가 되지는 않습니다.</p></li>
<li><p>(있다면) 트레이스백 스택의 각 줄은 예제의 첫 번째 줄보다 더 들여쓰기 되거나, <em>또는</em> 영숫자(alphanumeric)가 아닌 문자로 시작해야 합니다. 트레이스백 헤더 뒤에 같은 정도로 들여쓰기 되고, 영숫자로 시작하는 첫 번째 줄은 예외 세부 사항의 시작으로 간주합니다. 물론 이것은 진짜 트레이스백에 잘 들어맞습니다.</p></li>
<li><p><a class="reference internal" href="#doctest.IGNORE_EXCEPTION_DETAIL" title="doctest.IGNORE_EXCEPTION_DETAIL"><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORE_EXCEPTION_DETAIL</span></code></a> doctest 옵션을 지정하면, 가장 왼쪽 콜론 다음에 오는 모든 것과 예외 이름의 모듈 정보가 무시됩니다.</p></li>
<li><p>대화형 셸은 일부 <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>에서 트레이스백 헤더 줄을 생략합니다. 그러나 doctest는 트레이스백 헤더 줄을 사용하여 예외를 비 예외와 구별합니다. 따라서 트레이스백 헤더를 생략하는 <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>를 테스트해야 하는 드문 경우에는, 트레이스백 헤더 줄을 수동으로 테스트 예제에 추가해야 합니다.</p></li>
</ul>
<ul id="index-1">
<li><p>일부 <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>의 경우, 파이썬은 <code class="docutils literal notranslate"><span class="pre">^</span></code> 마커를 사용하여 구문 에러의 문자 위치를 표시합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="mi">1</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
    <span class="mi">1</span> <span class="mi">1</span>
      <span class="o">^</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid syntax</span>
</pre></div>
</div>
<p>에러의 위치를 나타내는 줄은 예외 형과 세부 사항 앞에 오므로, doctest가 점검하지 않습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">^</span></code> 마커를 잘못된 위치에 넣어도, 다음 테스트가 통과합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="mi">1</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
    <span class="mi">1</span> <span class="mi">1</span>
    <span class="o">^</span>
<span class="gr">SyntaxError</span>: <span class="n">invalid syntax</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="option-flags">
<span id="doctest-options"></span><span id="option-flags-and-directives"></span><h3>옵션 플래그<a class="headerlink" href="#option-flags" title="제목 주소">¶</a></h3>
<p>많은 옵션 플래그가 doctest의 다양한 동작을 제어합니다. 플래그의 기호 이름은 모듈 상수로 제공되며, 함께 <a class="reference internal" href="../reference/expressions.html#bitwise"><span class="std std-ref">비트별 OR</span></a>되어 다양한 함수로 전달될 수 있습니다. 이 이름은 <a class="reference internal" href="#doctest-directives"><span class="std std-ref">doctest 지시자</span></a>에서도 사용될 수 있으며, <code class="docutils literal notranslate"><span class="pre">-o</span></code> 옵션을 통해 doctest 명령 줄 인터페이스로 전달될 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가: </span><code class="docutils literal notranslate"><span class="pre">-o</span></code> 명령 줄 옵션.</p>
</div>
<p>첫 번째 옵션 그룹은 테스트의 의미를 정의하는데, doctest가 실제 출력이 예제의 예상 출력과 일치하는지를 결정하는 측면을 제어합니다:</p>
<dl class="data">
<dt id="doctest.DONT_ACCEPT_TRUE_FOR_1">
<code class="descclassname">doctest.</code><code class="descname">DONT_ACCEPT_TRUE_FOR_1</code><a class="headerlink" href="#doctest.DONT_ACCEPT_TRUE_FOR_1" title="정의 주소">¶</a></dt>
<dd><p>기본적으로, 예상 출력 블록에 <code class="docutils literal notranslate"><span class="pre">1</span></code> 만 있으면, 단지 <code class="docutils literal notranslate"><span class="pre">1</span></code>이나 <code class="docutils literal notranslate"><span class="pre">True</span></code> 만 포함된 실제 출력 블록을 일치하는 것으로 간주하며, <code class="docutils literal notranslate"><span class="pre">0</span></code>과 <code class="docutils literal notranslate"><span class="pre">False</span></code>도 유사하게 다룹니다. <a class="reference internal" href="#doctest.DONT_ACCEPT_TRUE_FOR_1" title="doctest.DONT_ACCEPT_TRUE_FOR_1"><code class="xref py py-const docutils literal notranslate"><span class="pre">DONT_ACCEPT_TRUE_FOR_1</span></code></a>이 지정되면, 두 치환 모두 허용되지 않습니다. 기본 동작은 파이썬이 많은 함수의 반환형을 정수에서 논릿값으로 변경했다는 것을 반영합니다; &quot;작은 정수&quot; 출력을 예상하는 doctest가 이러한 경우에 여전히 작동합니다. 아마도 이 옵션은 사라지게 되겠지만, 몇 년 동안은 남아있을 겁니다.</p>
</dd></dl>

<span class="target" id="index-2"></span><dl class="data">
<dt id="doctest.DONT_ACCEPT_BLANKLINE">
<code class="descclassname">doctest.</code><code class="descname">DONT_ACCEPT_BLANKLINE</code><a class="headerlink" href="#doctest.DONT_ACCEPT_BLANKLINE" title="정의 주소">¶</a></dt>
<dd><p>기본적으로, 예상 출력 블록에 <code class="docutils literal notranslate"><span class="pre">&lt;BLANKLINE&gt;</span></code> 문자열만 포함된 줄이 있으면, 해당하는 줄은 실제 출력의 빈 줄과 일치합니다. 진짜 빈 줄은 예상 출력을 끝내므로, 이것이 빈 줄을 예상하는 유일한 방법입니다. <a class="reference internal" href="#doctest.DONT_ACCEPT_BLANKLINE" title="doctest.DONT_ACCEPT_BLANKLINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">DONT_ACCEPT_BLANKLINE</span></code></a>이 지정되면, 이 치환은 허용되지 않습니다.</p>
</dd></dl>

<dl class="data">
<dt id="doctest.NORMALIZE_WHITESPACE">
<code class="descclassname">doctest.</code><code class="descname">NORMALIZE_WHITESPACE</code><a class="headerlink" href="#doctest.NORMALIZE_WHITESPACE" title="정의 주소">¶</a></dt>
<dd><p>지정되면, 모든 공백(빈칸과 개행) 시퀀스는 같게 취급됩니다. 예상 출력 내의 모든 공백 시퀀스는 실제 출력 내의 모든 공백 시퀀스와 일치합니다. 기본적으로, 공백은 정확히 일치해야 합니다. <a class="reference internal" href="#doctest.NORMALIZE_WHITESPACE" title="doctest.NORMALIZE_WHITESPACE"><code class="xref py py-const docutils literal notranslate"><span class="pre">NORMALIZE_WHITESPACE</span></code></a>는 예상 출력 줄이 매우 길고 소스의 여러 줄에 걸쳐 줄넘김하려는 경우에 특히 유용합니다.</p>
</dd></dl>

<span class="target" id="index-3"></span><dl class="data">
<dt id="doctest.ELLIPSIS">
<code class="descclassname">doctest.</code><code class="descname">ELLIPSIS</code><a class="headerlink" href="#doctest.ELLIPSIS" title="정의 주소">¶</a></dt>
<dd><p>지정되면, 예상 출력의 줄임표(<code class="docutils literal notranslate"><span class="pre">...</span></code>)가 실제 출력의 모든 부분 문자열과 일치 할 수 있습니다. 여기에는 줄 경계를 넘는 부분 문자열과 빈 부분 문자열이 포함되므로, 사용을 간단하게 유지하는 것이 가장 좋습니다. 복잡한 사용은 정규식에서 <code class="docutils literal notranslate"><span class="pre">.*</span></code>를 쓸 때처럼 &quot;이런, 너무 많이 일치하는군!&quot; 과 같은 상황을 만들 수 있습니다.</p>
</dd></dl>

<dl class="data">
<dt id="doctest.IGNORE_EXCEPTION_DETAIL">
<code class="descclassname">doctest.</code><code class="descname">IGNORE_EXCEPTION_DETAIL</code><a class="headerlink" href="#doctest.IGNORE_EXCEPTION_DETAIL" title="정의 주소">¶</a></dt>
<dd><p>지정하면, 예외를 예상하는 예제가, 예외 세부 사항이 일치하지 않아도 예상 형의 예외가 발생하면 통과합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">ValueError:</span> <span class="pre">42</span></code>를 예상하는 예제는 발생한 실제 예외가 <code class="docutils literal notranslate"><span class="pre">ValueError:</span> <span class="pre">3*14</span></code>이면 통과하지만, 예를 들어 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생하면 실패합니다.</p>
<p>또한, 파이썬 3 doctest 보고서에 사용된 모듈 이름도 무시합니다. 따라서 이 두 변형은 이 플래그가 지정되면 테스트가 파이썬 2.7이나 파이썬 3.2(또는 이후 버전)에서 실행되는지와 관계없이 작동합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">raise</span> <span class="n">CustomError</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">CustomError</span>: <span class="n">message</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">raise</span> <span class="n">CustomError</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">my_module.CustomError</span>: <span class="n">message</span>
</pre></div>
</div>
<p><a class="reference internal" href="#doctest.ELLIPSIS" title="doctest.ELLIPSIS"><code class="xref py py-const docutils literal notranslate"><span class="pre">ELLIPSIS</span></code></a>를 사용하여 예외 메시지의 세부 사항을 무시할 수도 있지만, 그러한 테스트는 모듈 세부 사항이 예외 이름의 일부로 인쇄되는지에 따라 여전히 실패할 수 있음에 유의하십시오. <a class="reference internal" href="#doctest.IGNORE_EXCEPTION_DETAIL" title="doctest.IGNORE_EXCEPTION_DETAIL"><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORE_EXCEPTION_DETAIL</span></code></a>과 파이썬 2.3의 세부 사항을 사용하는 것은 또한 예외 세부 사항에 신경 쓰지 않고 여전히 파이썬 2.3이나 그 이전 버전(이 배포는 <a class="reference internal" href="#doctest-directives"><span class="std std-ref">doctest 지시자</span></a>를 지원하지 않고 무의미한 주석으로 무시합니다)에서 통과하는 doctest를 작성하는 유일하게 명확한 방법입니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;moo&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object doesn&#39;t support item assignment</span>
</pre></div>
</div>
<p>는 플래그가 지정될 때 파이썬 2.3 이후 버전에서 통과합니다. 파이썬 2.4에서 세부 사항이 &quot;doesn't&quot; 대신 &quot;does not&quot;으로 변경되었음에도 통과합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><a class="reference internal" href="#doctest.IGNORE_EXCEPTION_DETAIL" title="doctest.IGNORE_EXCEPTION_DETAIL"><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORE_EXCEPTION_DETAIL</span></code></a>은 이제 테스트 중인 예외를 포함하는 모듈과 관련된 정보도 무시합니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="doctest.SKIP">
<code class="descclassname">doctest.</code><code class="descname">SKIP</code><a class="headerlink" href="#doctest.SKIP" title="정의 주소">¶</a></dt>
<dd><p>지정되면, 예제를 전혀 실행하지 않습니다. 이것은 doctest 예제가 설명서와 테스트 케이스의 두 가지 역할을 하는 문맥에서, 설명을 위해 예제를 포함해야 하지만 검사하지는 않아야 할 때 유용할 수 있습니다. 예를 들어, 예제의 출력이 임의적일 수 있습니다; 또는 예제가 테스트 구동기에서 사용할 수 없는 자원에 의존할 수 있습니다.</p>
<p>SKIP 플래그는 임시로 &quot;주석 처리한&quot; 예제를 위해 사용될 수도 있습니다.</p>
</dd></dl>

<dl class="data">
<dt id="doctest.COMPARISON_FLAGS">
<code class="descclassname">doctest.</code><code class="descname">COMPARISON_FLAGS</code><a class="headerlink" href="#doctest.COMPARISON_FLAGS" title="정의 주소">¶</a></dt>
<dd><p>위의 모든 비교 플래그를 함께 OR 한 비트 마스크.</p>
</dd></dl>

<p>두 번째 옵션 그룹은 테스트 실패가 보고되는 방식을 제어합니다:</p>
<dl class="data">
<dt id="doctest.REPORT_UDIFF">
<code class="descclassname">doctest.</code><code class="descname">REPORT_UDIFF</code><a class="headerlink" href="#doctest.REPORT_UDIFF" title="정의 주소">¶</a></dt>
<dd><p>지정되면, 여러 줄의 예상 및 실제 출력을 수반하는 실패가 통합(unified) diff를 사용하여 표시됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="doctest.REPORT_CDIFF">
<code class="descclassname">doctest.</code><code class="descname">REPORT_CDIFF</code><a class="headerlink" href="#doctest.REPORT_CDIFF" title="정의 주소">¶</a></dt>
<dd><p>지정되면, 여러 줄의 예상 및 실제 출력을 수반하는 실패가 문맥(context) diff를 사용하여 표시됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="doctest.REPORT_NDIFF">
<code class="descclassname">doctest.</code><code class="descname">REPORT_NDIFF</code><a class="headerlink" href="#doctest.REPORT_NDIFF" title="정의 주소">¶</a></dt>
<dd><p>지정되면, 차이점은 널리 사용되는 <code class="file docutils literal notranslate"><span class="pre">ndiff.py</span></code> 유틸리티와 같은 알고리즘을 사용하여, <code class="docutils literal notranslate"><span class="pre">difflib.Differ</span></code>로 계산됩니다. 이 방법은 줄 간의 차이뿐만 아니라 줄 안에서의 차이점을 표시하는 유일한 방법입니다. 예를 들어, 예상 출력 줄에 숫자 <code class="docutils literal notranslate"><span class="pre">1</span></code>이 포함된 줄에 실제 출력이 문자 <code class="docutils literal notranslate"><span class="pre">l</span></code>을 포함하고 있으면, 일치하지 않는 열 위치를 나타내는 캐럿(caret)이 들어간 줄이 삽입됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="doctest.REPORT_ONLY_FIRST_FAILURE">
<code class="descclassname">doctest.</code><code class="descname">REPORT_ONLY_FIRST_FAILURE</code><a class="headerlink" href="#doctest.REPORT_ONLY_FIRST_FAILURE" title="정의 주소">¶</a></dt>
<dd><p>지정되면, 각 doctest에서 실패한 첫 번째 예제를 표시하지만, 나머지 모든 예제에 대해서는 출력을 억제합니다. 이렇게 하면 doctest가 이전의 실패로 인해 망가진 올바른 예제를 보고하지 않게 되지만, 첫 번째 실패와 무관하게 실패한 잘못된 예제를 숨길 수도 있습니다. <a class="reference internal" href="#doctest.REPORT_ONLY_FIRST_FAILURE" title="doctest.REPORT_ONLY_FIRST_FAILURE"><code class="xref py py-const docutils literal notranslate"><span class="pre">REPORT_ONLY_FIRST_FAILURE</span></code></a>가 지정될 때, 나머지 예제는 여전히 실행되며, 보고된 총실패 수에 포함됩니다; 출력만 억제됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="doctest.FAIL_FAST">
<code class="descclassname">doctest.</code><code class="descname">FAIL_FAST</code><a class="headerlink" href="#doctest.FAIL_FAST" title="정의 주소">¶</a></dt>
<dd><p>지정되면, 첫 번째 실패 예제 후에 종료하고, 나머지 예제를 실행하지 않습니다. 따라서, 보고되는 실패 횟수는 최대 1입니다. 이 플래그는 디버깅 중에 유용할 수 있습니다, 첫 번째 실패 이후의 예제는 디버깅 출력조차 생성하지 않기 때문입니다.</p>
<p>doctest 명령 줄은 옵션 <code class="docutils literal notranslate"><span class="pre">-f</span></code>를 <code class="docutils literal notranslate"><span class="pre">-o</span> <span class="pre">FAIL_FAST</span></code>의 축약으로 받아들입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="doctest.REPORTING_FLAGS">
<code class="descclassname">doctest.</code><code class="descname">REPORTING_FLAGS</code><a class="headerlink" href="#doctest.REPORTING_FLAGS" title="정의 주소">¶</a></dt>
<dd><p>위의 모든 보고(reporting) 플래그를 함께 OR 한 비트 마스크.</p>
</dd></dl>

<p>새로운 옵션 플래그 이름을 등록하는 방법도 있습니다만, 서브 클래스를 통해 <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 내부를 확장하려고 하지 않는 한 유용하지는 않습니다:</p>
<dl class="function">
<dt id="doctest.register_optionflag">
<code class="descclassname">doctest.</code><code class="descname">register_optionflag</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.register_optionflag" title="정의 주소">¶</a></dt>
<dd><p>지정된 이름으로 새로운 옵션 플래그를 만들고, 새로운 플래그의 정숫값을 반환합니다. <a class="reference internal" href="#doctest.register_optionflag" title="doctest.register_optionflag"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_optionflag()</span></code></a>은 <a class="reference internal" href="#doctest.OutputChecker" title="doctest.OutputChecker"><code class="xref py py-class docutils literal notranslate"><span class="pre">OutputChecker</span></code></a>나 <a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>를 서브 클래싱할 때 서브 클래스가 지원하는 새 옵션을 만들 때 사용할 수 있습니다. <a class="reference internal" href="#doctest.register_optionflag" title="doctest.register_optionflag"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_optionflag()</span></code></a>는 항상 다음의 관용구를 사용하여 호출해야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">MY_FLAG</span> <span class="o">=</span> <span class="n">register_optionflag</span><span class="p">(</span><span class="s1">&#39;MY_FLAG&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="directives">
<span id="doctest-directives"></span><span id="index-4"></span><h3>지시자<a class="headerlink" href="#directives" title="제목 주소">¶</a></h3>
<p>Doctest 지시자를 사용하면 개별 예제의 <a class="reference internal" href="#doctest-options"><span class="std std-ref">옵션 플래그</span></a>를 수정할 수 있습니다. Doctest 지시자는 예제의 소스 코드 뒤에 오는 특수한 파이썬 주석입니다:</p>
<pre>
<strong id="grammar-token-directive">directive            </strong> ::=  &quot;#&quot; &quot;doctest:&quot; <a class="reference internal" href="#grammar-token-directive-options"><code class="xref docutils literal notranslate"><span class="pre">directive_options</span></code></a>
<strong id="grammar-token-directive-options">directive_options    </strong> ::=  <a class="reference internal" href="#grammar-token-directive-option"><code class="xref docutils literal notranslate"><span class="pre">directive_option</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-directive-option"><code class="xref docutils literal notranslate"><span class="pre">directive_option</span></code></a>)\*
<strong id="grammar-token-directive-option">directive_option     </strong> ::=  <a class="reference internal" href="#grammar-token-on-or-off"><code class="xref docutils literal notranslate"><span class="pre">on_or_off</span></code></a> <a class="reference internal" href="#grammar-token-directive-option-name"><code class="xref docutils literal notranslate"><span class="pre">directive_option_name</span></code></a>
<strong id="grammar-token-on-or-off">on_or_off            </strong> ::=  &quot;+&quot; \| &quot;-&quot;
<strong id="grammar-token-directive-option-name">directive_option_name</strong> ::=  &quot;DONT_ACCEPT_BLANKLINE&quot; \| &quot;NORMALIZE_WHITESPACE&quot; \| ...
</pre>
<p><code class="docutils literal notranslate"><span class="pre">+</span></code>나 <code class="docutils literal notranslate"><span class="pre">-</span></code>와 지시자 옵션 이름 사이의 공백은 허용되지 않습니다. 지시자 옵션 이름은 위에 설명된 옵션 플래그 이름 중 하나일 수 있습니다.</p>
<p>예제의 doctest 지시자는 그 단일 예제에 대한 doctest의 동작을 수정합니다. 이름 붙인 동작을 활성화하려면 <code class="docutils literal notranslate"><span class="pre">+</span></code>를 사용하고, 비활성화하려면 <code class="docutils literal notranslate"><span class="pre">-</span></code>를 사용하십시오.</p>
<p>예를 들어, 이 테스트는 통과합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))</span> 
<span class="go">[0,   1,  2,  3,  4,  5,  6,  7,  8,  9,</span>
<span class="go">10,  11, 12, 13, 14, 15, 16, 17, 18, 19]</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>doctest 지시자는 테스트를 위한 것이기 때문에 설명서로 렌더링할 때는 표시하지 않습니다.
바람직한 동작이기는 하지만 doctest 지시자 자체를 설명할 때는 문제가 됩니다.
실제로는 이렇게 지시자가 들어가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))</span> <span class="c1"># doctest: +NORMALIZE_WHITESPACE</span>
</pre></div>
</div>
</div>
<p>지시자가 없으면 실패하는데, 실제 출력에는 한 자리 숫자 리스트 요소 앞에 두 개의 공백이 없기도 하고, 실제 출력은 한 줄이기 때문입니다. 이 테스트도 통과하는데, 그러기 위해서 역시 지시자가 필요합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))</span> 
<span class="go">[0, 1, ..., 18, 19]</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>실제로는 이렇게 지시자가 들어가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))</span> <span class="c1"># doctest: +ELLIPSIS</span>
</pre></div>
</div>
</div>
<p>하나의 물리적 줄에 여러 개의 지시자를 쉼표로 구분하여 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))</span> 
<span class="go">[0,    1, ...,   18,    19]</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>실제로는 이렇게 지시자가 들어가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))</span> <span class="c1"># doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
</pre></div>
</div>
</div>
<p>하나의 예제에 여러 개의 지시자 주석이 사용되면, 모두 결합합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))</span> 
<span class="gp">... </span>                       
<span class="go">[0,    1, ...,   18,    19]</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>실제로는 이렇게 지시자가 들어가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))</span> <span class="c1"># doctest: +ELLIPSIS</span>
                       <span class="c1"># doctest: +NORMALIZE_WHITESPACE</span>
</pre></div>
</div>
</div>
<p>앞의 예가 보여주듯이, 여러분의 예제에 지시자만 포함된 <code class="docutils literal notranslate"><span class="pre">...</span></code> 줄을 추가할 수 있습니다. 예가 너무 길어서 지시자가 같은 줄에 편안하게 들어갈 수 없을 때 유용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">)))</span>
<span class="gp">... </span>
<span class="go">[0, ..., 4, 10, ..., 19, 30, ..., 39]</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>실제로는 이렇게 지시자가 들어가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">)))</span>
<span class="c1"># doctest: +ELLIPSIS</span>
</pre></div>
</div>
</div>
<p>모든 옵션은 기본적으로 비활성화되고, 지시자가 표시된 예제에만 적용되므로, (지시자에 <code class="docutils literal notranslate"><span class="pre">+</span></code>를 통해) 옵션을 활성화하는 것이 일반적으로 유일한 의미 있는 선택입니다. 하지만, doctest를 실행하는 함수에 옵션 플래그를 전달하여 다른 기본값을 설정할 수도 있습니다. 이럴 때, 지시자에서 <code class="docutils literal notranslate"><span class="pre">-</span></code>를 통해 옵션을 비활성화하는 것이 유용할 수 있습니다.</p>
</div>
<div class="section" id="warnings">
<span id="doctest-warnings"></span><h3>경고<a class="headerlink" href="#warnings" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>는 예상 출력에서 정확한 일치를 요구하는 것에 심각합니다. 단일 문자가 일치하지 않아도 테스트가 실패합니다. 여러분이 출력에 있어서 파이썬이 정확히 무엇을 보장하고 무엇을 보장하지 않는지 배워감에 따라, 이것은 아마도 여러분을 몇 번 놀라게 할 것입니다. 예를 들어, 집합을 인쇄할 때, 파이썬은 원소가 특정 순서로 인쇄되는 것을 보장하지 않으므로, 다음과 같은 테스트는</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span>
<span class="go">{&quot;Hermione&quot;, &quot;Harry&quot;}</span>
</pre></div>
</div>
<p>취약합니다! 한 가지 해결 방법은 다음과 같습니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">()</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;Hermione&quot;</span><span class="p">,</span> <span class="s2">&quot;Harry&quot;</span><span class="p">}</span>
<span class="go">True</span>
</pre></div>
</div>
<p>대신에. 또 다른 방법은</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">foo</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">[&#39;Harry&#39;, &#39;Hermione&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>파이썬 3.6 이전에는, 딕셔너리를 인쇄할 때, 파이썬은 키-값 쌍이 특정 순서로 인쇄되는 것을 보증하지 않았습니다.</p>
</div>
<p>다른 것들도 있지만, 아마 아이디어를 얻었을 겁니다.</p>
<p>또 다른 나쁜 생각은 객체 주소를 포함하는 것들을 출력하는 것입니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="c1"># 때로 실패할 것이 확실합니다</span>
<span class="go">7948648</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="p">()</span>   <span class="c1"># 인스턴스에 대한 기본 repr()은 주소를 포함합니다</span>
<span class="go">&lt;__main__.C instance at 0x00AC18F0&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#doctest.ELLIPSIS" title="doctest.ELLIPSIS"><code class="xref py py-const docutils literal notranslate"><span class="pre">ELLIPSIS</span></code></a> 지시자는 마지막 예제를 다루는 좋은 접근법을 제공합니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="p">()</span> 
<span class="go">&lt;__main__.C instance at 0x...&gt;</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>실제로는 이렇게 지시자가 들어가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">()</span> <span class="c1">#doctest: +ELLIPSIS</span>
</pre></div>
</div>
</div>
<p>부동 소수점 숫자도 플랫폼에 따라 약간의 출력 변동이 있습니다. 파이썬이 float 포매팅을 플랫폼 C 라이브러리에 위임하고 있고, 이때 C 라이브러리의 품질이 크게 다르기 때문입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.</span><span class="o">/</span><span class="mi">7</span>  <span class="c1"># 위험합니다</span>
<span class="go">0.14285714285714285</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mi">7</span><span class="p">)</span> <span class="c1"># 더 안전합니다</span>
<span class="go">0.142857142857</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span> <span class="c1"># 훨씬 더 안전합니다</span>
<span class="go">0.142857</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">I/2.**J</span></code> 형식의 숫자는 모든 플랫폼에서 안전하며, 저는 종종 이런 형식의 숫자를 만들도록 doctest 예제를 꾸밉니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">3.</span><span class="o">/</span><span class="mi">4</span>  <span class="c1"># 완전히 안전합니다</span>
<span class="go">0.75</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>정수(또는 정숫값을 갖는 float)를 2의 거듭제곱으로 나눈 값은, 유효 숫자가 충분하다면 이진 부동 소수점으로 정확히 표현되고,
십진수로 변환할 때 자리 올림 오차가 발생하지 않습니다.</p>
</div>
<p>간단한 분수는 또한 사람들이 이해하기가 더 쉬우므로, 더 좋은 설명서가 되도록 합니다.</p>
</div>
</div>
<div class="section" id="basic-api">
<span id="doctest-basic-api"></span><h2>기본 API<a class="headerlink" href="#basic-api" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">testmod()</span></code></a>와 <a class="reference internal" href="#doctest.testfile" title="doctest.testfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">testfile()</span></code></a> 함수는 대부분 기본 사용에 충분한 doctest에 대한 간단한 인터페이스를 제공합니다. 이 두 함수에 대한 덜 형식적인 소개는 섹션 <a class="reference internal" href="#doctest-simple-testmod"><span class="std std-ref">간단한 사용법: 독스트링에 있는 예제 확인하기</span></a>와 <a class="reference internal" href="#doctest-simple-testfile"><span class="std std-ref">간단한 사용법: 텍스트 파일에 있는 예제 확인하기</span></a>를 참조하십시오.</p>
<dl class="function">
<dt id="doctest.testfile">
<code class="descclassname">doctest.</code><code class="descname">testfile</code><span class="sig-paren">(</span><em>filename</em>, <em>module_relative=True</em>, <em>name=None</em>, <em>package=None</em>, <em>globs=None</em>, <em>verbose=None</em>, <em>report=True</em>, <em>optionflags=0</em>, <em>extraglobs=None</em>, <em>raise_on_error=False</em>, <em>parser=DocTestParser()</em>, <em>encoding=None</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.testfile" title="정의 주소">¶</a></dt>
<dd><p><em>filename</em>를 제외한 모든 인자는 선택적이며 키워드 형식으로 지정해야 합니다.</p>
<p><em>filename</em> 파일에 있는 예제를 테스트합니다. <code class="docutils literal notranslate"><span class="pre">(failure_count,</span> <span class="pre">test_count)</span></code>를 반환합니다.</p>
<p>선택적 인자 <em>module_relative</em>는 filename을 해석하는 방법을 지정합니다:</p>
<ul class="simple">
<li><p><em>module_relative</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>(기본값)이면, <em>filename</em>는 OS 독립적 모듈 상대 경로를 지정합니다. 기본적으로, 이 경로는 호출하는 모듈의 디렉터리에 상대적입니다; 그러나 <em>package</em> 인자가 지정되면, 해당 패키지에 상대적입니다. OS 독립성을 보장하기 위해, <em>filename</em>은 <code class="docutils literal notranslate"><span class="pre">/</span></code> 문자를 사용하여 경로 세그먼트를 분리해야 하며, 절대 경로일 수 없습니다 (즉, <code class="docutils literal notranslate"><span class="pre">/</span></code>로 시작할 수 없습니다).</p></li>
<li><p><em>module_relative</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, <em>filename</em>은 OS 특정 경로를 지정합니다. 경로는 절대나 상대일 수 있습니다; 상대 경로는 현재 작업 디렉터리를 기준으로 해석됩니다.</p></li>
</ul>
<p>선택적 인자 <em>name</em>은 테스트의 이름을 제공합니다; 기본적으로, 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, <code class="docutils literal notranslate"><span class="pre">os.path.basename(filename)</span></code>이 사용됩니다.</p>
<p>선택적 인자 <em>package</em>는 디렉터리가 모듈 상대 filename의 기본 디렉터리로 사용될 파이썬 패키지나 파이썬 패키지의 이름입니다. 패키지를 지정하지 않으면, 호출하는 모듈의 디렉터리가 모듈 상대 filename의 기본 디렉터리로 사용됩니다. <em>module_relative</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>일 때 <em>package</em>를 지정하는 것은 에러입니다.</p>
<p>선택적 인자 <em>globs</em>는 예제를 실행할 때 전역으로 사용될 딕셔너리를 제공합니다. doctest를 위해 이 딕셔너리의 새 얕은 사본이 만들어지므로, 예제는 깨끗한 서판으로 시작합니다. 기본적으로, 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, 새 빈 딕셔너리가 사용됩니다.</p>
<p>선택적 인자 <em>extraglobs</em>는 예제를 실행하는 데 사용되는 전역에 병합될 딕셔너리를 제공합니다. 이것은 <a class="reference internal" href="stdtypes.html#dict.update" title="dict.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.update()</span></code></a>처럼 작동합니다: <em>globs</em>와 <em>extraglobs</em>에 공통 키가 있으면, <em>extraglobs</em>의 연관된 값이 병합된 딕셔너리에 나타납니다. 기본적으로, 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, 추가 전역은 사용되지 않습니다. doctest의 매개 변수화를 허용하는 고급 기능입니다. 예를 들어, doctest는 클래스의 일반 이름을 사용하여 베이스 클래스용으로 작성할 수 있습니다, 그런 다음 일반 이름을 테스트할 서브 클래스에 매핑하는 <em>extraglobs</em> 딕셔너리를 전달하여 임의의 수의 서브 클래스를 테스트하는데 재사용할 수 있습니다.</p>
<p>선택적 인자 <em>verbose</em>가 참이면 많은 것들을 인쇄하고, 거짓이면 실패만 인쇄합니다; 기본적으로, 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, <code class="docutils literal notranslate"><span class="pre">'-v'</span></code>가 <code class="docutils literal notranslate"><span class="pre">sys.argv</span></code>에 있을 때만 참입니다.</p>
<p>선택적 인자 <em>report</em>가 참이면 끝에 요약을 인쇄하고, 그렇지 않으면 끝에 아무것도 인쇄하지 않습니다. verbose 모드에서는 요약 정보가 상세히 표시되며, 그렇지 않으면 요약 정보는 매우 간단합니다 (사실, 모든 테스트가 통과되면 비어 있습니다).</p>
<p>선택적 인자 <em>optionflags</em>(기본값은 0)는 옵션 플래그의 <a class="reference internal" href="../reference/expressions.html#bitwise"><span class="std std-ref">비트별 OR</span></a>를 취합니다. <a class="reference internal" href="#doctest-options"><span class="std std-ref">옵션 플래그</span></a> 절을 참조하십시오.</p>
<p>선택적 인자 <em>raise_on_error</em>의 기본값은 거짓입니다. 참이면, 예제에서 첫 번째 실패나 예기치 않은 예외가 발생할 때 예외가 발생합니다. 이것은 실패를 사후(post-mortem) 디버깅할 수 있도록 합니다. 기본 동작은 예제를 계속 실행하는 것입니다.</p>
<p>선택적 인자 <em>parser</em>는 파일에서 테스트를 추출하는 데 사용할 <a class="reference internal" href="#doctest.DocTestParser" title="doctest.DocTestParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestParser</span></code></a>(또는 서브 클래스)를 지정합니다. 기본값은 일반 파서(즉, <code class="docutils literal notranslate"><span class="pre">DocTestParser()</span></code>)입니다.</p>
<p>선택적 인자 <em>encoding</em>은 파일을 유니코드로 변환하는 데 사용할 인코딩을 지정합니다.</p>
</dd></dl>

<dl class="function">
<dt id="doctest.testmod">
<code class="descclassname">doctest.</code><code class="descname">testmod</code><span class="sig-paren">(</span><em>m=None</em>, <em>name=None</em>, <em>globs=None</em>, <em>verbose=None</em>, <em>report=True</em>, <em>optionflags=0</em>, <em>extraglobs=None</em>, <em>raise_on_error=False</em>, <em>exclude_empty=False</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.testmod" title="정의 주소">¶</a></dt>
<dd><p>모든 인자는 선택적이며, <em>m</em>을 제외한 모든 인자는 키워드 형식으로 지정해야 합니다.</p>
<p>모듈 <em>m</em>(또는 <em>m</em>가 제공되지 않았거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면 모듈 <a class="reference internal" href="__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a>)에서 도달할 수 있는 함수와 클래스의 독스트링에 있는 예제를 테스트합니다. <code class="docutils literal notranslate"><span class="pre">m.__doc__</span></code>으로 시작합니다.</p>
<p>딕셔너리 <code class="docutils literal notranslate"><span class="pre">m.__test__</span></code>이 존재하고 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면, 여기에서 도달할 수 있는 예제도 테스트합니다. <code class="docutils literal notranslate"><span class="pre">m.__test__</span></code>는 이름(문자열)을 함수, 클래스 및 문자열에 매핑합니다; 함수와 클래스 독스트링에서 예제를 검색합니다; 문자열은 그것이 독스트링인 것처럼 직접 검색합니다.</p>
<p>모듈 <em>m</em>에 속하는 객체에 연결된 독스트링 만 검색합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">(failure_count,</span> <span class="pre">test_count)</span></code>를 반환합니다.</p>
<p>선택적 인자 <em>name</em>은 모듈의 이름을 제공합니다; 기본적으로, 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, <code class="docutils literal notranslate"><span class="pre">m.__name__</span></code>이 사용됩니다.</p>
<p>선택적 인자 <em>exclude_empty</em>의 기본값은 거짓입니다. 참이면, doctest가 발견되지 않은 객체는 고려 대상에서 제외됩니다. 기본값은 이전 버전과의 호환성을 위한 해킹입니다, 여전히 <a class="reference internal" href="#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">testmod()</span></code></a>와 함께 <code class="xref py py-meth docutils literal notranslate"><span class="pre">doctest.master.summarize()</span></code>를 사용하는 코드는 테스트가 없는 객체에 대해 계속 출력합니다. 새로운 <a class="reference internal" href="#doctest.DocTestFinder" title="doctest.DocTestFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestFinder</span></code></a> 생성자에 대한 <em>exclude_empty</em> 인자의 기본값은 참입니다.</p>
<p>선택적 인자 <em>extraglobs</em>, <em>verbose</em>, <em>report</em>, <em>optionflags</em>, <em>raise_on_error</em> 및 <em>globs</em>는 위의 함수 <a class="reference internal" href="#doctest.testfile" title="doctest.testfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">testfile()</span></code></a>와 같습니다만, <em>globs</em>의 기본값이 <code class="docutils literal notranslate"><span class="pre">m.__dict__</span></code>인 점이 다릅니다.</p>
</dd></dl>

<dl class="function">
<dt id="doctest.run_docstring_examples">
<code class="descclassname">doctest.</code><code class="descname">run_docstring_examples</code><span class="sig-paren">(</span><em>f</em>, <em>globs</em>, <em>verbose=False</em>, <em>name=&quot;NoName&quot;</em>, <em>compileflags=None</em>, <em>optionflags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.run_docstring_examples" title="정의 주소">¶</a></dt>
<dd><p>객체 <em>f</em>와 관련된 예제를 테스트합니다. 여기서, <em>f</em>는 문자열, 모듈, 함수 또는 클래스 객체일 수 있습니다.</p>
<p>딕셔너리 인자 <em>globs</em>의 얕은 사본이 실행 컨텍스트에 사용됩니다.</p>
<p>선택적 인자 <em>name</em>은 실패 메시지에서 사용되며, 기본값은 <code class="docutils literal notranslate"><span class="pre">&quot;NoName&quot;</span></code>입니다.</p>
<p>선택적 인자 <em>verbose</em>가 참이면, 실패가 없어도 출력이 생성됩니다. 기본적으로, 출력은 예제가 실패할 때만 생성됩니다.</p>
<p>선택적 인자 <em>compileflags</em>는 예제를 실행할 때 파이썬 컴파일러에서 사용해야 하는 플래그 집합을 제공합니다. 기본적으로, 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, <em>globs</em>에서 발견되는 퓨처 기능 집합에 해당하는 플래그가 추론됩니다.</p>
<p>선택적 인자 <em>optionflags</em>는 위의 함수 <a class="reference internal" href="#doctest.testfile" title="doctest.testfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">testfile()</span></code></a>에서 처럼 작동합니다.</p>
</dd></dl>

</div>
<div class="section" id="unittest-api">
<span id="doctest-unittest-api"></span><h2>Unittest API<a class="headerlink" href="#unittest-api" title="제목 주소">¶</a></h2>
<p>doctest된 모듈 모음이 늘어남에 따라, 모든 doctest를 체계적으로 실행하는 방법이 필요합니다. <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>는 doctest가 포함된 모듈과 텍스트 파일로부터 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 테스트 스위트를 만드는 데 사용할 수 있는 두 가지 함수를 제공합니다. <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 테스트 탐색과 통합하려면, 테스트 모듈에 <code class="xref py py-func docutils literal notranslate"><span class="pre">load_tests()</span></code> 함수를 포함하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">import</span> <span class="nn">doctest</span>
<span class="kn">import</span> <span class="nn">my_module_with_doctests</span>

<span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">tests</span><span class="p">,</span> <span class="n">ignore</span><span class="p">):</span>
    <span class="n">tests</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">doctest</span><span class="o">.</span><span class="n">DocTestSuite</span><span class="p">(</span><span class="n">my_module_with_doctests</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tests</span>
</pre></div>
</div>
<p>Doctest가 있는 텍스트 파일과 모듈로부터 <a class="reference internal" href="unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a> 인스턴스를 만드는 두 가지 주요 함수가 있습니다:</p>
<dl class="function">
<dt id="doctest.DocFileSuite">
<code class="descclassname">doctest.</code><code class="descname">DocFileSuite</code><span class="sig-paren">(</span><em>*paths</em>, <em>module_relative=True</em>, <em>package=None</em>, <em>setUp=None</em>, <em>tearDown=None</em>, <em>globs=None</em>, <em>optionflags=0</em>, <em>parser=DocTestParser()</em>, <em>encoding=None</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocFileSuite" title="정의 주소">¶</a></dt>
<dd><p>하나 이상의 텍스트 파일로부터 doctest 테스트를 <a class="reference internal" href="unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a>로 변환합니다.</p>
<p>반환된 <a class="reference internal" href="unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a>는 unittest 프레임워크에 의해 실행되고, 각 파일에 있는 대화식 예제를 실행합니다. 어떤 파일의 예제가 실패하면, 합성된 단위 테스트가 실패하고, 테스트를 포함하는 파일의 이름과 (때로는 근사치인) 줄 번호를 보여주는 <code class="xref py py-exc docutils literal notranslate"><span class="pre">failureException</span></code> 예외가 발생합니다.</p>
<p>검사할 텍스트 파일을 하나 이상의 paths(문자열)로 전달합니다.</p>
<p>옵션은 키워드 인자로 제공될 수 있습니다:</p>
<p>선택적 인자 <em>module_relative</em>는 <em>paths</em>에 있는 파일명을 해석하는 방법을 지정합니다:</p>
<ul class="simple">
<li><p><em>module_relative</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>(기본값)이면, <em>paths</em>의 각 파일명은 OS 독립적 모듈 상대 경로를 지정합니다. 기본적으로, 이 경로는 호출하는 모듈의 디렉터리에 상대적입니다; 그러나 <em>package</em> 인자가 지정되면, 해당 패키지에 상대적입니다. OS 독립성을 보장하기 위해, 각 파일명은 <code class="docutils literal notranslate"><span class="pre">/</span></code> 문자를 사용하여 경로 세그먼트를 분리해야 하며, 절대 경로일 수 없습니다 (즉, <code class="docutils literal notranslate"><span class="pre">/</span></code>로 시작할 수 없습니다).</p></li>
<li><p><em>module_relative</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, <em>paths</em>의 각 파일명은 OS 특정 경로를 지정합니다. 경로는 절대나 상대일 수 있습니다; 상대 경로는 현재 작업 디렉터리를 기준으로 해석됩니다.</p></li>
</ul>
<p>선택적 인자 <em>package</em>는 디렉터리가 <em>paths</em>의 모듈 상대 파일명의 기본 디렉터리로 사용될 파이썬 패키지나 파이썬 패키지의 이름입니다. 패키지를 지정하지 않으면, 호출하는 모듈의 디렉터리가 모듈 상대 파일명의 기본 디렉터리로 사용됩니다. <em>module_relative</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>일 때 <em>package</em>를 지정하는 것은 에러입니다.</p>
<p>선택적 인자 <em>setUp</em>은 테스트 스위트에 대한 사전 설정(set-up) 함수를 지정합니다. 이것은 각 파일에서 테스트를 실행하기 전에 호출됩니다. <em>setUp</em> 함수로 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a> 객체가 전달됩니다. setUp 함수는 전달된 테스트의 <em>globs</em> 어트리뷰트를 통해 테스트 전역에 액세스할 수 있습니다.</p>
<p>선택적 인자 <em>tearDown</em>은 테스트 스위트에 사후 정리(tear-down) 함수를 지정합니다. 이것은 각 파일에서 테스트를 실행한 후에 호출됩니다. <em>tearDown</em> 함수로 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a> 객체가 전달됩니다. tearDown 함수는 전달된 테스트의 <em>globs</em> 어트리뷰트를 통해 테스트 전역에 액세스할 수 있습니다.</p>
<p>선택적 인자 <em>globs</em>는 테스트의 초기 전역 변수를 포함하는 딕셔너리입니다. 이 딕셔너리의 새 사본이 테스트마다 만들어집니다. 기본적으로, <em>globs</em>는 새로운 빈 딕셔너리입니다.</p>
<p>선택적 인자 <em>optionflags</em>는 테스트에 대한 기본 doctest 옵션을 지정하는데, 개별 옵션 플래그를 함께 OR 해서 만들어집니다. <a class="reference internal" href="#doctest-options"><span class="std std-ref">옵션 플래그</span></a> 절을 참조하십시오. 보고(reporting) 옵션을 설정하는 더 좋은 방법은 아래 함수 <a class="reference internal" href="#doctest.set_unittest_reportflags" title="doctest.set_unittest_reportflags"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_unittest_reportflags()</span></code></a>를 참조하십시오.</p>
<p>선택적 인자 <em>parser</em>는 파일에서 테스트를 추출하는 데 사용할 <a class="reference internal" href="#doctest.DocTestParser" title="doctest.DocTestParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestParser</span></code></a>(또는 서브 클래스)를 지정합니다. 기본값은 일반 파서(즉, <code class="docutils literal notranslate"><span class="pre">DocTestParser()</span></code>)입니다.</p>
<p>선택적 인자 <em>encoding</em>은 파일을 유니코드로 변환하는 데 사용할 인코딩을 지정합니다.</p>
<p>전역 <code class="docutils literal notranslate"><span class="pre">__file__</span></code>이 <a class="reference internal" href="#doctest.DocFileSuite" title="doctest.DocFileSuite"><code class="xref py py-func docutils literal notranslate"><span class="pre">DocFileSuite()</span></code></a>를 사용하여 텍스트 파일에서 로드된 doctest에 제공된 전역에 추가됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="doctest.DocTestSuite">
<code class="descclassname">doctest.</code><code class="descname">DocTestSuite</code><span class="sig-paren">(</span><em>module=None</em>, <em>globs=None</em>, <em>extraglobs=None</em>, <em>test_finder=None</em>, <em>setUp=None</em>, <em>tearDown=None</em>, <em>checker=None</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTestSuite" title="정의 주소">¶</a></dt>
<dd><p>모듈에 대한 doctest 테스트를 <a class="reference internal" href="unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a>로 변환합니다.</p>
<p>반환된 <a class="reference internal" href="unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a>는 unittest 프레임워크에 의해 실행되고, 모듈에 있는 각 doctest를 실행합니다. 어떤 doctest가 실패하면, 합성된 단위 테스트가 실패하고, 테스트를 포함하는 파일의 이름과 (때로는 근사치인) 줄 번호를 보여주는 <code class="xref py py-exc docutils literal notranslate"><span class="pre">failureException</span></code> 예외가 발생합니다.</p>
<p>선택적 인자 <em>module</em>은 테스트할 모듈을 제공합니다. 모듈 객체나 (점으로 구분될 수 있는) 모듈 이름일 수 있습니다. 지정하지 않으면, 이 함수를 호출하는 모듈이 사용됩니다.</p>
<p>선택적 인자 <em>globs</em>는 테스트의 초기 전역 변수를 포함하는 딕셔너리입니다. 이 딕셔너리의 새 사본이 테스트마다 만들어집니다. 기본적으로, <em>globs</em>는 새로운 빈 딕셔너리입니다.</p>
<p>선택적 인자 <em>extraglobs</em>는 <em>globs</em>에 병합되는 전역 변수의 추가 집합을 지정합니다. 기본적으로, 추가 전역 변수는 사용되지 않습니다.</p>
<p>선택적 인자 <em>test_finder</em>는 모듈에서 doctest를 추출하는 데 사용되는 <a class="reference internal" href="#doctest.DocTestFinder" title="doctest.DocTestFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestFinder</span></code></a> 객체(또는 드롭 인 대체)입니다.</p>
<p>선택적 인자 <em>setUp</em>, <em>tearDown</em> 및 <em>optionflags</em>는 위의 함수 <a class="reference internal" href="#doctest.DocFileSuite" title="doctest.DocFileSuite"><code class="xref py py-func docutils literal notranslate"><span class="pre">DocFileSuite()</span></code></a>와 같습니다.</p>
<p>이 함수는 <a class="reference internal" href="#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">testmod()</span></code></a>와 같은 검색 기법을 사용합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><em>module</em>에 독스트링이 없으면 <a class="reference internal" href="#doctest.DocTestSuite" title="doctest.DocTestSuite"><code class="xref py py-func docutils literal notranslate"><span class="pre">DocTestSuite()</span></code></a>는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시키는 대신 빈 <a class="reference internal" href="unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a>를 반환합니다.</p>
</div>
</dd></dl>

<p>수면 아래에서, <a class="reference internal" href="#doctest.DocTestSuite" title="doctest.DocTestSuite"><code class="xref py py-func docutils literal notranslate"><span class="pre">DocTestSuite()</span></code></a>는 <code class="xref py py-class docutils literal notranslate"><span class="pre">doctest.DocTestCase</span></code> 인스턴스에서 <a class="reference internal" href="unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a>를 만들고, <code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestCase</span></code>는 <a class="reference internal" href="unittest.html#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a>의 서브 클래스입니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestCase</span></code>는 여기에서 설명되지는 않지만 (내부 세부 사항입니다), 그것의 코드를 살펴보면 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 통합의 정확한 세부 사항에 대한 질문에 대한 답을 얻을 수 있습니다.</p>
<p>마찬가지로, <a class="reference internal" href="#doctest.DocFileSuite" title="doctest.DocFileSuite"><code class="xref py py-func docutils literal notranslate"><span class="pre">DocFileSuite()</span></code></a>는 <code class="xref py py-class docutils literal notranslate"><span class="pre">doctest.DocFileCase</span></code> 인스턴스에서 <a class="reference internal" href="unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a>를 만들고, <code class="xref py py-class docutils literal notranslate"><span class="pre">DocFileCase</span></code>는 <code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestCase</span></code>의 서브 클래스입니다.</p>
<p>따라서 <a class="reference internal" href="unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a>를 만드는 두 가지 방법 모두 <code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestCase</span></code>의 인스턴스를 실행합니다. 이것은 미묘한 이유로 중요합니다: 여러분이 <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 함수를 직접 실행할 때, 옵션 플래그를 <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 함수에 전달하여 사용 중인 <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 옵션을 직접 제어할 수 있습니다. 그러나, <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 프레임워크를 작성한다면, <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>가 테스트가 언제 어떻게 실행되는지 궁극적으로 제어합니다. 프레임워크 저자는 일반적으로 <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> (아마도, 예를 들어, 명령 줄 옵션으로 지정하는) 보고(reporting) 옵션을 제어하려고 하지만, <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>를 통해 <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 테스트 실행기로 옵션을 전달할 방법이 없습니다.</p>
<p>이러한 이유로, <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>는 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 지원에 특화된 <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 보고(reporting) 플래그 개념을 다음 함수를 통해 지원합니다:</p>
<dl class="function">
<dt id="doctest.set_unittest_reportflags">
<code class="descclassname">doctest.</code><code class="descname">set_unittest_reportflags</code><span class="sig-paren">(</span><em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.set_unittest_reportflags" title="정의 주소">¶</a></dt>
<dd><p>사용할 <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 보고 플래그를 설정합니다.</p>
<p>인자 <em>flags</em>는 옵션 플래그의 <a class="reference internal" href="../reference/expressions.html#bitwise"><span class="std std-ref">비트별 OR</span></a>를 취합니다. <a class="reference internal" href="#doctest-options"><span class="std std-ref">옵션 플래그</span></a> 절을 참조하십시오. &quot;보고 플래그&quot;만 사용할 수 있습니다.</p>
<p>이것은 모듈 전역 설정이며, 모듈 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>에 의해 실행되는 모든 미래의 doctest에 영향을 줍니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestCase</span></code>의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">runTest()</span></code> 메서드는 <code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestCase</span></code> 인스턴스가 생성될 때 테스트 케이스에 대해 지정된 옵션 플래그를 봅니다. 보고 플래그가 지정되지 않았으면 (이것이 일반적이고 예상되는 경우입니다), <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>의 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>보고 플래그는 옵션 플래그에 <a class="reference internal" href="../reference/expressions.html#bitwise"><span class="std std-ref">비트별 OR</span></a>되고, 이렇게 손질된 옵션 플래그가 doctest를 실행하기 위해 만들어진 <a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a> 인스턴스로 전달됩니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestCase</span></code> 인스턴스가 생성될 때 보고 플래그가 지정되었으면, <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>의 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 보고 플래그는 무시됩니다.</p>
<p>함수가 호출되기 전에 유효했던 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 보고 플래그의 값이 함수에 의해 반환됩니다.</p>
</dd></dl>

</div>
<div class="section" id="advanced-api">
<span id="doctest-advanced-api"></span><h2>고급 API<a class="headerlink" href="#advanced-api" title="제목 주소">¶</a></h2>
<p>기본 API는 doctest를 사용하기 쉽게 하기 위한 간단한 래퍼입니다. 그것은 매우 유연하며, 대부분 사용자의 요구를 충족시켜야 합니다; 그러나, 테스팅에 대한 세밀한 제어가 필요하거나, doctest의 기능을 확장하려면, 고급 API를 사용해야 합니다.</p>
<p>고급 API는 doctest 케이스에서 추출한 대화식 예제를 저장하는 데 사용되는 두 개의 컨테이너 클래스를 중심으로 돌아갑니다:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#doctest.Example" title="doctest.Example"><code class="xref py py-class docutils literal notranslate"><span class="pre">Example</span></code></a>: 예상 출력과 쌍을 이루는 단일 파이썬 <a class="reference internal" href="../glossary.html#term-statement"><span class="xref std std-term">문장</span></a>.</p></li>
<li><p><a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>: 일반적으로 단일 독스트링이나 텍스트 파일에서 추출된 <a class="reference internal" href="#doctest.Example" title="doctest.Example"><code class="xref py py-class docutils literal notranslate"><span class="pre">Example</span></code></a>의 모음.</p></li>
</ul>
<p>doctest 예제를 찾고, 구문 분석하고, 실행하고, 검사하기 위해 추가 처리 클래스가 정의됩니다:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#doctest.DocTestFinder" title="doctest.DocTestFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestFinder</span></code></a>: 주어진 모듈에서 모든 독스트링을 찾고, <a class="reference internal" href="#doctest.DocTestParser" title="doctest.DocTestParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestParser</span></code></a>를 사용하여 대화식 예제가 들어있는 모든 독스트링에서 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>를 만듭니다.</p></li>
<li><p><a class="reference internal" href="#doctest.DocTestParser" title="doctest.DocTestParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestParser</span></code></a>: 문자열(가령 객체의 독스트링)에서 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a> 객체를 만듭니다.</p></li>
<li><p><a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>: <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>에 있는 예제를 실행하고, <a class="reference internal" href="#doctest.OutputChecker" title="doctest.OutputChecker"><code class="xref py py-class docutils literal notranslate"><span class="pre">OutputChecker</span></code></a>를 사용하여 출력을 확인합니다.</p></li>
<li><p><a class="reference internal" href="#doctest.OutputChecker" title="doctest.OutputChecker"><code class="xref py py-class docutils literal notranslate"><span class="pre">OutputChecker</span></code></a>: doctest 예제의 실제 출력을 예상 출력과 비교하고, 그들이 일치하는지 결정합니다.</p></li>
</ul>
<p>이러한 처리 클래스 간의 관계는 다음 도표에 요약되어 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>                            <span class="nb">list</span> <span class="n">of</span><span class="p">:</span>
<span class="o">+------+</span>                   <span class="o">+---------+</span>
<span class="o">|</span><span class="n">module</span><span class="o">|</span> <span class="o">--</span><span class="n">DocTestFinder</span><span class="o">-&gt;</span> <span class="o">|</span> <span class="n">DocTest</span> <span class="o">|</span> <span class="o">--</span><span class="n">DocTestRunner</span><span class="o">-&gt;</span> <span class="n">results</span>
<span class="o">+------+</span>    <span class="o">|</span>        <span class="o">^</span>     <span class="o">+---------+</span>     <span class="o">|</span>       <span class="o">^</span>    <span class="p">(</span><span class="n">printed</span><span class="p">)</span>
            <span class="o">|</span>        <span class="o">|</span>     <span class="o">|</span> <span class="n">Example</span> <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>
            <span class="n">v</span>        <span class="o">|</span>     <span class="o">|</span>   <span class="o">...</span>   <span class="o">|</span>     <span class="n">v</span>       <span class="o">|</span>
           <span class="n">DocTestParser</span>   <span class="o">|</span> <span class="n">Example</span> <span class="o">|</span>   <span class="n">OutputChecker</span>
                           <span class="o">+---------+</span>
</pre></div>
</div>
<div class="section" id="doctest-objects">
<span id="doctest-doctest"></span><h3>DocTest 객체<a class="headerlink" href="#doctest-objects" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="doctest.DocTest">
<em class="property">class </em><code class="descclassname">doctest.</code><code class="descname">DocTest</code><span class="sig-paren">(</span><em>examples</em>, <em>globs</em>, <em>name</em>, <em>filename</em>, <em>lineno</em>, <em>docstring</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTest" title="정의 주소">¶</a></dt>
<dd><p>단일 이름 공간에서 실행되어야 하는 doctest 예제의 모음. 생성자 인자는 같은 이름의 어트리뷰트를 초기화하는 데 사용됩니다.</p>
<p><a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>는 다음 어트리뷰트를 정의합니다. 이들은 생성자에 의해 초기화되며, 직접 수정하면 안 됩니다.</p>
<dl class="attribute">
<dt id="doctest.DocTest.examples">
<code class="descname">examples</code><a class="headerlink" href="#doctest.DocTest.examples" title="정의 주소">¶</a></dt>
<dd><p>이 테스트가 실행해야 하는 개별 대화형 파이썬 예제를 인코딩하는 <a class="reference internal" href="#doctest.Example" title="doctest.Example"><code class="xref py py-class docutils literal notranslate"><span class="pre">Example</span></code></a> 객체의 리스트.</p>
</dd></dl>

<dl class="attribute">
<dt id="doctest.DocTest.globs">
<code class="descname">globs</code><a class="headerlink" href="#doctest.DocTest.globs" title="정의 주소">¶</a></dt>
<dd><p>예제가 실행되어야 하는 이름 공간 (일명 전역). 이름을 값에 매핑하는 딕셔너리입니다. 예제가 만든 이름 공간의 모든 변경 사항(가령 새 변수 바인딩)은 테스트가 실행된 후 <a class="reference internal" href="#doctest.DocTest.globs" title="doctest.DocTest.globs"><code class="xref py py-attr docutils literal notranslate"><span class="pre">globs</span></code></a>에 반영됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="doctest.DocTest.name">
<code class="descname">name</code><a class="headerlink" href="#doctest.DocTest.name" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>를 식별하는 문자열 이름. 일반적으로, 테스트가 추출된 객체나 파일의 이름입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="doctest.DocTest.filename">
<code class="descname">filename</code><a class="headerlink" href="#doctest.DocTest.filename" title="정의 주소">¶</a></dt>
<dd><p>이 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>가 추출된 파일의 이름; 또는 파일 이름을 알 수 없거나 파일에서 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>가 추출되지 않았으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="doctest.DocTest.lineno">
<code class="descname">lineno</code><a class="headerlink" href="#doctest.DocTest.lineno" title="정의 주소">¶</a></dt>
<dd><p>이 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>가 시작되는 <a class="reference internal" href="#doctest.DocTest.filename" title="doctest.DocTest.filename"><code class="xref py py-attr docutils literal notranslate"><span class="pre">filename</span></code></a> 내의 줄 번호, 또는 줄 번호가 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>. 이 줄 번호는 파일의 시작 부분을 기준으로 0에서 시작합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="doctest.DocTest.docstring">
<code class="descname">docstring</code><a class="headerlink" href="#doctest.DocTest.docstring" title="정의 주소">¶</a></dt>
<dd><p>테스트가 추출된 문자열, 또는 문자열이 없거나 테스트가 문자열에서 추출되지 않았으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="example-objects">
<span id="doctest-example"></span><h3>Example 객체<a class="headerlink" href="#example-objects" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="doctest.Example">
<em class="property">class </em><code class="descclassname">doctest.</code><code class="descname">Example</code><span class="sig-paren">(</span><em>source</em>, <em>want</em>, <em>exc_msg=None</em>, <em>lineno=0</em>, <em>indent=0</em>, <em>options=None</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.Example" title="정의 주소">¶</a></dt>
<dd><p>파이썬 문장과 예상 출력으로 구성된 단일 대화형 예제. 생성자 인자는 같은 이름의 어트리뷰트를 초기화하는 데 사용됩니다.</p>
<p><a class="reference internal" href="#doctest.Example" title="doctest.Example"><code class="xref py py-class docutils literal notranslate"><span class="pre">Example</span></code></a>는 다음 어트리뷰트를 정의합니다. 이들은 생성자에 의해 초기화되며, 직접 수정하면 안 됩니다.</p>
<dl class="attribute">
<dt id="doctest.Example.source">
<code class="descname">source</code><a class="headerlink" href="#doctest.Example.source" title="정의 주소">¶</a></dt>
<dd><p>예제의 소스 코드가 포함된 문자열. 이 소스 코드는 단일 파이썬 문으로 구성되며 항상 개행으로 끝납니다; 생성자는 필요하면 개행 문자를 추가합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="doctest.Example.want">
<code class="descname">want</code><a class="headerlink" href="#doctest.Example.want" title="정의 주소">¶</a></dt>
<dd><p>예제의 소스 코드를 실행할 때 (stdout이나 예외 발생 시 트레이스백으로부터) 예상되는 출력. <a class="reference internal" href="#doctest.Example.want" title="doctest.Example.want"><code class="xref py py-attr docutils literal notranslate"><span class="pre">want</span></code></a>는 출력이 예상되지 않으면 빈 문자열이고, 그렇지 않으면 개행으로 끝납니다. 생성자는 필요하면 개행을 추가합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="doctest.Example.exc_msg">
<code class="descname">exc_msg</code><a class="headerlink" href="#doctest.Example.exc_msg" title="정의 주소">¶</a></dt>
<dd><p>예제가 예외를 생성할 것으로 예상되면, 예제에서 생성된 예외 메시지; 또는 예외를 생성할 것으로 예상되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>. 이 예외 메시지는 <a class="reference internal" href="traceback.html#traceback.format_exception_only" title="traceback.format_exception_only"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.format_exception_only()</span></code></a>의 반환 값과 비교됩니다. <a class="reference internal" href="#doctest.Example.exc_msg" title="doctest.Example.exc_msg"><code class="xref py py-attr docutils literal notranslate"><span class="pre">exc_msg</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면 개행으로 끝납니다. 생성자는 필요하면 개행을 추가합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="doctest.Example.lineno">
<code class="descname">lineno</code><a class="headerlink" href="#doctest.Example.lineno" title="정의 주소">¶</a></dt>
<dd><p>이 예제가 시작하는 이 예제를 포함하는 문자열 내의 줄 번호. 이 줄 번호는 포함하는 문자열의 시작 부분을 기준으로 0에서 시작합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="doctest.Example.indent">
<code class="descname">indent</code><a class="headerlink" href="#doctest.Example.indent" title="정의 주소">¶</a></dt>
<dd><p>포함하는 문자열 내에서의 이 예제의 들여쓰기, 즉 예제의 첫 번째 프롬프트 앞에 오는 스페이스 문자의 수.</p>
</dd></dl>

<dl class="attribute">
<dt id="doctest.Example.options">
<code class="descname">options</code><a class="headerlink" href="#doctest.Example.options" title="정의 주소">¶</a></dt>
<dd><p>옵션 플래그에서 <code class="docutils literal notranslate"><span class="pre">True</span></code>나 <code class="docutils literal notranslate"><span class="pre">False</span></code> 로 매핑하는 딕셔너리, 이 예제의 기본 옵션을 재정의하는 데 사용됩니다. 이 딕셔너리에 포함되지 않은 옵션 플래그는 (<a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">optionflags</span></code>에 지정된 대로) 기본값으로 남습니다. 기본적으로, 아무런 옵션도 설정되지 않습니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="doctestfinder-objects">
<span id="doctest-doctestfinder"></span><h3>DocTestFinder 객체<a class="headerlink" href="#doctestfinder-objects" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="doctest.DocTestFinder">
<em class="property">class </em><code class="descclassname">doctest.</code><code class="descname">DocTestFinder</code><span class="sig-paren">(</span><em>verbose=False</em>, <em>parser=DocTestParser()</em>, <em>recurse=True</em>, <em>exclude_empty=True</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTestFinder" title="정의 주소">¶</a></dt>
<dd><p>주어진 객체에 관련된 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>를 그것의 독스트링과 그것이 포함하는 객체의 독스트링으로부터 추출하기 위해서 사용되는 처리 클래스. <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>는 모듈, 클래스, 함수, 메서드, 정적 메서드, 클래스 메서드 및 프로퍼티에서 추출할 수 있습니다.</p>
<p>선택적 인자 <em>verbose</em>는 파인더가 검색한 객체를 표시하는 데 사용될 수 있습니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code> (출력 없음)입니다.</p>
<p>선택적 인자 <em>parser</em>는 독스트링에서 doctest를 추출하는 데 사용되는 <a class="reference internal" href="#doctest.DocTestParser" title="doctest.DocTestParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestParser</span></code></a> 객체 (또는 드롭 인 대체)를 지정합니다.</p>
<p>선택적 인자 <em>recurse</em>가 거짓이면, <a class="reference internal" href="#doctest.DocTestFinder.find" title="doctest.DocTestFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DocTestFinder.find()</span></code></a>는 오직 주어진 객체만을 검사 할 뿐, 포함된 객체는 검사하지 않습니다.</p>
<p>선택적 인자 <em>exclude_empty</em>가 거짓이면, <a class="reference internal" href="#doctest.DocTestFinder.find" title="doctest.DocTestFinder.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DocTestFinder.find()</span></code></a>는 빈 독스트링을 가진 객체에 대한 테스트를 포함합니다.</p>
<p><a class="reference internal" href="#doctest.DocTestFinder" title="doctest.DocTestFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestFinder</span></code></a>는 다음 메서드를 정의합니다:</p>
<dl class="method">
<dt id="doctest.DocTestFinder.find">
<code class="descname">find</code><span class="sig-paren">(</span><em>obj[, name][, module][, globs][, extraglobs]</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTestFinder.find" title="정의 주소">¶</a></dt>
<dd><p><em>obj</em>의 독스트링이나 포함된 객체의 독스트링으로 정의된 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>의 리스트를 반환합니다.</p>
<p>선택적 인자 <em>name</em>은 객체의 이름을 지정합니다. 이 이름은 반환된 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>의 이름을 구성하는 데 사용됩니다. <em>name</em>이 지정되지 않으면, <code class="docutils literal notranslate"><span class="pre">obj.__name__</span></code>이 사용됩니다.</p>
<p>선택적 매개 변수 <em>module</em>은 주어진 객체를 포함하는 모듈입니다. 모듈이 지정되지 않거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, 테스트 파인더는 자동으로 올바른 모듈을 판별하려고 시도합니다. 객체의 모듈은 다음과 같이 사용됩니다:</p>
<ul class="simple">
<li><p><em>globs</em>가 지정되지 않으면, 기본 이름 공간으로.</p></li>
<li><p>DocTestFinder가 다른 모듈에서 임포트 된 객체에서 DocTest를 추출하지 못하도록 하려고. (<em>module</em>이 아닌 다른 모듈을 가진 포함 된 객체는 무시됩니다.)</p></li>
<li><p>객체를 포함하는 파일의 이름을 찾으려고.</p></li>
<li><p>해당 파일 내에서 객체의 줄 번호를 찾는 데 도움이 됩니다.</p></li>
</ul>
<p><em>module</em>이 <code class="docutils literal notranslate"><span class="pre">False</span></code>면, 모듈을 찾으려고 시도하지 않습니다. 이것은 눈에 띄지 않는데, 대부분 doctest 자체를 테스트할 때 사용합니다: <em>module</em>이 <code class="docutils literal notranslate"><span class="pre">False</span></code>이거나, <code class="docutils literal notranslate"><span class="pre">None</span></code>이지만 자동으로 찾을 수 없으면, 모든 객체는 (존재하지 않는) 모듈에 속한 것으로 간주하므로, 포함된 모든 객체에서 (재귀적으로) doctest를 검색합니다.</p>
<p>각 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>에 대한 전역은 <em>globs</em>와 <em>extraglobs</em>(<em>extraglobs</em>의 바인딩이 <em>globs</em>의 바인딩에 우선합니다)를 결합하여 구성됩니다. 각 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>마다 전역 딕셔너리의 새 얕은 복사본이 만들어집니다. <em>globs</em>를 지정하지 않으면, 기본값은 모듈이 지정되었다면 모듈의 <em>__dict__</em>, 또는 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">{}</span></code>입니다. <em>extraglobs</em>가 지정되지 않으면, 기본값은 <code class="docutils literal notranslate"><span class="pre">{}</span></code>입니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="doctestparser-objects">
<span id="doctest-doctestparser"></span><h3>DocTestParser 객체<a class="headerlink" href="#doctestparser-objects" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="doctest.DocTestParser">
<em class="property">class </em><code class="descclassname">doctest.</code><code class="descname">DocTestParser</code><a class="headerlink" href="#doctest.DocTestParser" title="정의 주소">¶</a></dt>
<dd><p>문자열에서 대화형 예제를 추출하고, 이를 사용하여 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a> 객체를 만드는 데 사용되는 처리 클래스.</p>
<p><a class="reference internal" href="#doctest.DocTestParser" title="doctest.DocTestParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestParser</span></code></a>는 다음 메서드를 정의합니다:</p>
<dl class="method">
<dt id="doctest.DocTestParser.get_doctest">
<code class="descname">get_doctest</code><span class="sig-paren">(</span><em>string</em>, <em>globs</em>, <em>name</em>, <em>filename</em>, <em>lineno</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTestParser.get_doctest" title="정의 주소">¶</a></dt>
<dd><p>주어진 문자열에서 모든 doctest 예제를 추출하고, 이를 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a> 객체로 모읍니다.</p>
<p><em>globs</em>, <em>name</em>, <em>filename</em> 및 <em>lineno</em>는 새 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a> 객체의 어트리뷰트입니다. 자세한 내용은 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a> 설명서를 참조하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="doctest.DocTestParser.get_examples">
<code class="descname">get_examples</code><span class="sig-paren">(</span><em>string</em>, <em>name='&lt;string&gt;'</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTestParser.get_examples" title="정의 주소">¶</a></dt>
<dd><p>주어진 문자열에서 모든 doctest 예제를 추출하고, 이를 <a class="reference internal" href="#doctest.Example" title="doctest.Example"><code class="xref py py-class docutils literal notranslate"><span class="pre">Example</span></code></a> 객체의 리스트로 반환합니다. 줄 번호는 0부터 시작합니다. 선택적 인자 <em>name</em>은, 이 문자열을 식별하는 이름이며, 에러 메시지에만 사용됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="doctest.DocTestParser.parse">
<code class="descname">parse</code><span class="sig-paren">(</span><em>string</em>, <em>name='&lt;string&gt;'</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTestParser.parse" title="정의 주소">¶</a></dt>
<dd><p>주어진 문자열을 예제와 중간에 있는 텍스트로 나누고, 이를 <a class="reference internal" href="#doctest.Example" title="doctest.Example"><code class="xref py py-class docutils literal notranslate"><span class="pre">Example</span></code></a>와 문자열이 번갈아 나오는 리스트로 반환합니다. <a class="reference internal" href="#doctest.Example" title="doctest.Example"><code class="xref py py-class docutils literal notranslate"><span class="pre">Example</span></code></a>의 줄 번호는 0부터 시작합니다. 선택적 인자 <em>name</em>은, 이 문자열을 식별하는 이름이며, 에러 메시지에만 사용됩니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="doctestrunner-objects">
<span id="doctest-doctestrunner"></span><h3>DocTestRunner 객체<a class="headerlink" href="#doctestrunner-objects" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="doctest.DocTestRunner">
<em class="property">class </em><code class="descclassname">doctest.</code><code class="descname">DocTestRunner</code><span class="sig-paren">(</span><em>checker=None</em>, <em>verbose=None</em>, <em>optionflags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTestRunner" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a>에 있는 대화형 예제를 실행하고 검증하는 데 사용되는 처리 클래스.</p>
<p>예상 출력과 실제 출력 간의 비교는 <a class="reference internal" href="#doctest.OutputChecker" title="doctest.OutputChecker"><code class="xref py py-class docutils literal notranslate"><span class="pre">OutputChecker</span></code></a>에 의해 수행됩니다. 이 비교는 여러 옵션 플래그로 사용자 정의할 수 있습니다; 자세한 내용은 <a class="reference internal" href="#doctest-options"><span class="std std-ref">옵션 플래그</span></a> 절을 참조하십시오. 옵션 플래그로 충분하지 않으면, <a class="reference internal" href="#doctest.OutputChecker" title="doctest.OutputChecker"><code class="xref py py-class docutils literal notranslate"><span class="pre">OutputChecker</span></code></a>의 서브 클래스를 생성자에 전달하여 비교를 사용자 정의할 수도 있습니다.</p>
<p>테스트 실행기의 디스플레이 출력은 두 가지 방법으로 제어할 수 있습니다. 첫째, 출력 함수를 <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestRunner.run()</span></code>로 전달할 수 있습니다; 이 함수는 표시되어야 하는 문자열로 호출됩니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">sys.stdout.write</span></code>입니다. 출력을 캡처하는 것으로 충분하지 않으면, DocTestRunner를 서브 클래싱하고 <a class="reference internal" href="#doctest.DocTestRunner.report_start" title="doctest.DocTestRunner.report_start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">report_start()</span></code></a>, <a class="reference internal" href="#doctest.DocTestRunner.report_success" title="doctest.DocTestRunner.report_success"><code class="xref py py-meth docutils literal notranslate"><span class="pre">report_success()</span></code></a>, <a class="reference internal" href="#doctest.DocTestRunner.report_unexpected_exception" title="doctest.DocTestRunner.report_unexpected_exception"><code class="xref py py-meth docutils literal notranslate"><span class="pre">report_unexpected_exception()</span></code></a> 및 <a class="reference internal" href="#doctest.DocTestRunner.report_failure" title="doctest.DocTestRunner.report_failure"><code class="xref py py-meth docutils literal notranslate"><span class="pre">report_failure()</span></code></a> 메서드를 재정의하여 디스플레이 출력을 사용자 정의할 수 있습니다.</p>
<p>선택적 키워드 인자 <em>checker</em>는 예상 출력을 doctest 예제의 실제 출력과 비교하는 데 사용되는 <a class="reference internal" href="#doctest.OutputChecker" title="doctest.OutputChecker"><code class="xref py py-class docutils literal notranslate"><span class="pre">OutputChecker</span></code></a> 객체(또는 드롭 인 대체)를 지정합니다.</p>
<p>선택적 키워드 인자 <em>verbose</em>는 <a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>의 상세도를 제어합니다. <em>verbose</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, 실행될 때 각 예제에 대한 정보가 인쇄됩니다. <em>verbose</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, 실패만 인쇄됩니다. <em>verbose</em>가 지정되지 않거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, 명령 줄 스위치 <code class="docutils literal notranslate"><span class="pre">-v</span></code>가 사용될 때만 상세 출력이 사용됩니다.</p>
<p>선택적 키워드 인자 <em>optionflags</em>는 테스트 실행기가 예상 출력을 실제 출력과 비교하는 방법과 실패를 표시하는 방법을 제어하는 데 사용할 수 있습니다. 자세한 내용은 <a class="reference internal" href="#doctest-options"><span class="std std-ref">옵션 플래그</span></a> 절을 참조하십시오.</p>
<p><a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>는 다음 메서드를 정의합니다:</p>
<dl class="method">
<dt id="doctest.DocTestRunner.report_start">
<code class="descname">report_start</code><span class="sig-paren">(</span><em>out</em>, <em>test</em>, <em>example</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTestRunner.report_start" title="정의 주소">¶</a></dt>
<dd><p>테스트 러너가 주어진 예제를 처리하려고 한다고 보고합니다. 이 메서드는 <a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>의 서브 클래스가 출력을 사용자 정의할 수 있도록 제공됩니다; 직접 호출해서는 안 됩니다.</p>
<p><em>example</em>은 처리될 예제입니다. <em>test</em>는 <em>예제를 포함하는</em> 테스트입니다. <em>out</em>은 <a class="reference internal" href="#doctest.DocTestRunner.run" title="doctest.DocTestRunner.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DocTestRunner.run()</span></code></a>에 전달된 출력 함수입니다.</p>
</dd></dl>

<dl class="method">
<dt id="doctest.DocTestRunner.report_success">
<code class="descname">report_success</code><span class="sig-paren">(</span><em>out</em>, <em>test</em>, <em>example</em>, <em>got</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTestRunner.report_success" title="정의 주소">¶</a></dt>
<dd><p>주어진 예제가 성공적으로 실행되었음을 보고합니다. 이 메서드는 <a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>의 서브 클래스가 출력을 사용자 정의할 수 있도록 제공됩니다; 직접 호출해서는 안 됩니다.</p>
<p><em>example</em>은 처리될 예제입니다. <em>got</em>은 예제의 실제 출력입니다. <em>test</em>는 <em>example</em>을 포함하는 테스트입니다. <em>out</em>은 <a class="reference internal" href="#doctest.DocTestRunner.run" title="doctest.DocTestRunner.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DocTestRunner.run()</span></code></a>에 전달된 출력 함수입니다.</p>
</dd></dl>

<dl class="method">
<dt id="doctest.DocTestRunner.report_failure">
<code class="descname">report_failure</code><span class="sig-paren">(</span><em>out</em>, <em>test</em>, <em>example</em>, <em>got</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTestRunner.report_failure" title="정의 주소">¶</a></dt>
<dd><p>주어진 예제가 실패했음을 보고합니다. 이 메서드는 <a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>의 서브 클래스가 출력을 사용자 정의할 수 있도록 제공됩니다; 직접 호출해서는 안 됩니다.</p>
<p><em>example</em>은 처리될 예제입니다. <em>got</em>은 예제의 실제 출력입니다. <em>test</em>는 <em>example</em>을 포함하는 테스트입니다. <em>out</em>은 <a class="reference internal" href="#doctest.DocTestRunner.run" title="doctest.DocTestRunner.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DocTestRunner.run()</span></code></a>에 전달된 출력 함수입니다.</p>
</dd></dl>

<dl class="method">
<dt id="doctest.DocTestRunner.report_unexpected_exception">
<code class="descname">report_unexpected_exception</code><span class="sig-paren">(</span><em>out</em>, <em>test</em>, <em>example</em>, <em>exc_info</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTestRunner.report_unexpected_exception" title="정의 주소">¶</a></dt>
<dd><p>주어진 예제가 예기치 않은 예외를 발생시켰다고 보고합니다. 이 메서드는 <a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>의 서브 클래스가 출력을 사용자 정의할 수 있도록 제공됩니다; 직접 호출해서는 안 됩니다.</p>
<p><em>example</em>은 처리될 예제입니다. <em>exc_info</em>는 예기치 않은 예외에 대한 정보를 포함하는 튜플입니다 (<a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>에 의해 반환되는 것). <em>test</em>는 <em>example</em>을 포함하는 테스트입니다. <em>out</em>은 <a class="reference internal" href="#doctest.DocTestRunner.run" title="doctest.DocTestRunner.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DocTestRunner.run()</span></code></a>에 전달된 출력 함수입니다.</p>
</dd></dl>

<dl class="method">
<dt id="doctest.DocTestRunner.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>test</em>, <em>compileflags=None</em>, <em>out=None</em>, <em>clear_globs=True</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTestRunner.run" title="정의 주소">¶</a></dt>
<dd><p><em>test</em>(<a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a> 객체)에 있는 예제를 실행하고, 출력 함수 <em>out</em>을 사용하여 결과를 표시합니다.</p>
<p>예제는 이름 공간 <code class="docutils literal notranslate"><span class="pre">test.globs</span></code>에서 실행됩니다. <em>clear_globs</em>가 참(기본값)이면, 가비지 수집을 돕기 위해 테스트가 실행된 후 이 이름 공간이 지워집니다. 테스트가 완료된 후에 이름 공간을 검사하려면 <em>clear_globs=False</em>를 사용하십시오.</p>
<p><em>compileflags</em>는 예제를 실행할 때 파이썬 컴파일러에서 사용해야 하는 플래그 집합을 제공합니다. 지정되지 않으면, <em>globs</em>에 적용되는 퓨처-임포트 플래그 집합이 기본값이 됩니다.</p>
<p>각 예제의 출력은 <a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>의 출력 검사기를 사용하여 검사되며, 결과는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">DocTestRunner.report_*()</span></code> 메서드로 포맷됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="doctest.DocTestRunner.summarize">
<code class="descname">summarize</code><span class="sig-paren">(</span><em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTestRunner.summarize" title="정의 주소">¶</a></dt>
<dd><p>이 DocTestRunner가 실행 한 모든 테스트 케이스의 요약을 인쇄하고, <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> <code class="docutils literal notranslate"><span class="pre">TestResults(failed,</span> <span class="pre">attempted)</span></code>를 반환합니다.</p>
<p>선택적 <em>verbose</em> 인자는 요약이 얼마나 상세할지를 제어합니다. 상세도가 지정되지 않으면, <a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>의 상세도가 사용됩니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="outputchecker-objects">
<span id="doctest-outputchecker"></span><h3>OutputChecker 객체<a class="headerlink" href="#outputchecker-objects" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="doctest.OutputChecker">
<em class="property">class </em><code class="descclassname">doctest.</code><code class="descname">OutputChecker</code><a class="headerlink" href="#doctest.OutputChecker" title="정의 주소">¶</a></dt>
<dd><p>doctest 예제의 실제 출력이 예상 출력과 일치하는지를 확인하는 데 사용되는 클래스. <a class="reference internal" href="#doctest.OutputChecker" title="doctest.OutputChecker"><code class="xref py py-class docutils literal notranslate"><span class="pre">OutputChecker</span></code></a>는 두 가지 메서드를 정의합니다: <a class="reference internal" href="#doctest.OutputChecker.check_output" title="doctest.OutputChecker.check_output"><code class="xref py py-meth docutils literal notranslate"><span class="pre">check_output()</span></code></a>은 주어진 출력 쌍을 비교하고 일치하면 참을 반환합니다; <a class="reference internal" href="#doctest.OutputChecker.output_difference" title="doctest.OutputChecker.output_difference"><code class="xref py py-meth docutils literal notranslate"><span class="pre">output_difference()</span></code></a>는 두 출력 간의 차이를 설명하는 문자열을 반환합니다.</p>
<p><a class="reference internal" href="#doctest.OutputChecker" title="doctest.OutputChecker"><code class="xref py py-class docutils literal notranslate"><span class="pre">OutputChecker</span></code></a>는 다음 메서드를 정의합니다:</p>
<dl class="method">
<dt id="doctest.OutputChecker.check_output">
<code class="descname">check_output</code><span class="sig-paren">(</span><em>want</em>, <em>got</em>, <em>optionflags</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.OutputChecker.check_output" title="정의 주소">¶</a></dt>
<dd><p>예제의 실제 출력(<em>got</em>)이 예상 출력(<em>want</em>)과 일치할 때만 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다. 이 문자열은 같으면 항상 일치하는 것으로 간주합니다; 그러나 테스트 실행기가 사용하는 옵션 플래그에 따라 몇 가지 정확하지 않은 일치 유형도 가능합니다. 옵션 플래그에 대한 자세한 정보는 <a class="reference internal" href="#doctest-options"><span class="std std-ref">옵션 플래그</span></a> 절을 참조하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="doctest.OutputChecker.output_difference">
<code class="descname">output_difference</code><span class="sig-paren">(</span><em>example</em>, <em>got</em>, <em>optionflags</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.OutputChecker.output_difference" title="정의 주소">¶</a></dt>
<dd><p>주어진 예제(<em>example</em>)에 대한 예상 출력과 실제 출력(<em>got</em>)의 차이를 설명하는 문자열을 반환합니다. <em>optionflags</em>는 <em>want</em>와 <em>got</em>을 비교하는 데 사용되는 옵션 플래그 집합입니다.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="debugging">
<span id="doctest-debugging"></span><h2>디버깅<a class="headerlink" href="#debugging" title="제목 주소">¶</a></h2>
<p>Doctest는 doctest 예제를 디버깅하기 위한 몇 가지 메커니즘을 제공합니다:</p>
<ul>
<li><p>몇몇 함수는 doctest를 파이썬 디버거 <a class="reference internal" href="pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a>에서 실행할 수 있는 실행 가능한 파이썬 프로그램으로 변환합니다.</p></li>
<li><p><a class="reference internal" href="#doctest.DebugRunner" title="doctest.DebugRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DebugRunner</span></code></a> 클래스는 첫 번째 실패한 예제에 대한 예외를 발생시키는 <a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>의 서브 클래스이며 해당 예제에 대한 정보가 들어 있습니다. 이 정보는 예제에서 사후 디버깅을 수행하는 데 사용될 수 있습니다.</p></li>
<li><p><a class="reference internal" href="#doctest.DocTestSuite" title="doctest.DocTestSuite"><code class="xref py py-func docutils literal notranslate"><span class="pre">DocTestSuite()</span></code></a>에 의해 생성된 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 케이스는 <a class="reference internal" href="unittest.html#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a>에 의해 정의된 <a class="reference internal" href="#doctest.debug" title="doctest.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a> 메서드를 지원합니다.</p></li>
<li><p>doctest 예제에 <a class="reference internal" href="pdb.html#pdb.set_trace" title="pdb.set_trace"><code class="xref py py-func docutils literal notranslate"><span class="pre">pdb.set_trace()</span></code></a>에 대한 호출을 추가 할 수 있습니다. 그러면 해당하는 줄이 실행될 때 파이썬 디버거로 들어갑니다. 그런 다음 변수의 현재 값을 검사하는 등의 일을 할 수 있습니다. 예를 들어, <code class="file docutils literal notranslate"><span class="pre">a.py</span></code>가 다음과 같은 모듈 독스트링을 포함한다고 가정합시다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&gt;&gt;&gt; def f(x):</span>
<span class="sd">...     g(x*2)</span>
<span class="sd">&gt;&gt;&gt; def g(x):</span>
<span class="sd">...     print(x+3)</span>
<span class="sd">...     import pdb; pdb.set_trace()</span>
<span class="sd">&gt;&gt;&gt; f(3)</span>
<span class="sd">9</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>그러면 대화형 파이썬 세션은 이런 식이 됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">a</span><span class="o">,</span> <span class="nn">doctest</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">--Return--</span>
<span class="go">&gt; &lt;doctest a[1]&gt;(3)g()-&gt;None</span>
<span class="go">-&gt; import pdb; pdb.set_trace()</span>
<span class="go">(Pdb) list</span>
<span class="go">  1     def g(x):</span>
<span class="go">  2         print(x+3)</span>
<span class="go">  3  -&gt;     import pdb; pdb.set_trace()</span>
<span class="go">[EOF]</span>
<span class="go">(Pdb) p x</span>
<span class="go">6</span>
<span class="go">(Pdb) step</span>
<span class="go">--Return--</span>
<span class="go">&gt; &lt;doctest a[0]&gt;(2)f()-&gt;None</span>
<span class="go">-&gt; g(x*2)</span>
<span class="go">(Pdb) list</span>
<span class="go">  1     def f(x):</span>
<span class="go">  2  -&gt;     g(x*2)</span>
<span class="go">[EOF]</span>
<span class="go">(Pdb) p x</span>
<span class="go">3</span>
<span class="go">(Pdb) step</span>
<span class="go">--Return--</span>
<span class="go">&gt; &lt;doctest a[2]&gt;(1)?()-&gt;None</span>
<span class="go">-&gt; f(3)</span>
<span class="go">(Pdb) cont</span>
<span class="go">(0, 3)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</li>
</ul>
<p>Doctest를 파이썬 코드로 변환하고, 디버거에서 합성 코드를 실행할 수 있는 함수들:</p>
<dl class="function">
<dt id="doctest.script_from_examples">
<code class="descclassname">doctest.</code><code class="descname">script_from_examples</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.script_from_examples" title="정의 주소">¶</a></dt>
<dd><p>예제가 있는 텍스트를 스크립트로 변환합니다.</p>
<p>인자 <em>s</em>는 doctest 예제를 포함하는 문자열입니다. 문자열은 파이썬 스크립트로 변환됩니다. 여기서 <em>s</em>의 doctest 예제는 일반 코드로 변환되고, 나머지는 파이썬 주석으로 변환됩니다. 생성된 스크립트는 문자열로 반환됩니다. 예를 들어,</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">doctest</span>
<span class="nb">print</span><span class="p">(</span><span class="n">doctest</span><span class="o">.</span><span class="n">script_from_examples</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Set x and y to 1 and 2.</span>
<span class="s2">    &gt;&gt;&gt; x, y = 1, 2</span>

<span class="s2">    Print their sum:</span>
<span class="s2">    &gt;&gt;&gt; print(x+y)</span>
<span class="s2">    3</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>는 다음과 같이 출력합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set x and y to 1 and 2.</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
<span class="c1">#</span>
<span class="c1"># Print their sum:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="c1"># Expected:</span>
<span class="c1">## 3</span>
</pre></div>
</div>
<p>이 함수는 다른 함수(아래 참조)에서 내부적으로 사용되지만, 대화형 파이썬 세션을 파이썬 스크립트로 변환하려고 할 때도 유용합니다.</p>
</dd></dl>

<dl class="function">
<dt id="doctest.testsource">
<code class="descclassname">doctest.</code><code class="descname">testsource</code><span class="sig-paren">(</span><em>module</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.testsource" title="정의 주소">¶</a></dt>
<dd><p>객체에 대한 doctest를 스크립트로 변환합니다.</p>
<p>인자 <em>module</em>은 doctest가 관심 대상인 객체를 포함하는 모듈 객체나 모듈의 점으로 구분된 이름입니다. 인자 <em>name</em>은 doctest가 관심 대상인 객체의 (모듈 내에서의) 이름입니다. 결과는 위의 <a class="reference internal" href="#doctest.script_from_examples" title="doctest.script_from_examples"><code class="xref py py-func docutils literal notranslate"><span class="pre">script_from_examples()</span></code></a>에서 설명한 대로 파이썬 스크립트로 변환된 객체의 독스트링을 포함하는 문자열입니다. 예를 들어, 모듈 <code class="file docutils literal notranslate"><span class="pre">a.py</span></code>에 최상위 함수 <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code>가 포함되었다면,</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">a</span><span class="o">,</span> <span class="nn">doctest</span>
<span class="nb">print</span><span class="p">(</span><span class="n">doctest</span><span class="o">.</span><span class="n">testsource</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;a.f&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>는 doctest가 코드로 변환되고 나머지는 주석으로 배치된, 함수 <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code>의 독스트링의 스크립트 버전을 인쇄합니다.</p>
</dd></dl>

<dl class="function">
<dt id="doctest.debug">
<code class="descclassname">doctest.</code><code class="descname">debug</code><span class="sig-paren">(</span><em>module</em>, <em>name</em>, <em>pm=False</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.debug" title="정의 주소">¶</a></dt>
<dd><p>객체의 doctest를 디버그합니다.</p>
<p><em>module</em>과 <em>name</em> 인자는 위의 함수 <a class="reference internal" href="#doctest.testsource" title="doctest.testsource"><code class="xref py py-func docutils literal notranslate"><span class="pre">testsource()</span></code></a>와 같습니다. 명명된 객체의 독스트링에 대한 합성된 파이썬 스크립트가 임시 파일에 기록되고, 그 파일을 파이썬 디버거 <a class="reference internal" href="pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a>의 제어하에 실행합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">module.__dict__</span></code>의 얕은 사본이 지역과 전역 실행 컨텍스트 모두에 사용됩니다.</p>
<p>선택적 인자 <em>pm</em>은 사후 디버깅이 사용되는지를 제어합니다. <em>pm</em>이 참값이면, 스크립트 파일은 직접 실행되고, 처리되지 않은 예외를 발생시켜 스크립트가 종료될 때만 디버거가 개입합니다. 그럴 때, 사후 디버깅이 <a class="reference internal" href="pdb.html#pdb.post_mortem" title="pdb.post_mortem"><code class="xref py py-func docutils literal notranslate"><span class="pre">pdb.post_mortem()</span></code></a>를 통해 호출되어, 처리되지 않은 예외로부터 온 트레이스백 객체를 전달합니다. <em>pm</em>이 지정되지 않았거나 거짓이면, 스크립트는 적절한 <a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 호출을 <a class="reference internal" href="pdb.html#pdb.run" title="pdb.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">pdb.run()</span></code></a>에 전달하여 시작부터 디버거에서 실행됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="doctest.debug_src">
<code class="descclassname">doctest.</code><code class="descname">debug_src</code><span class="sig-paren">(</span><em>src</em>, <em>pm=False</em>, <em>globs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.debug_src" title="정의 주소">¶</a></dt>
<dd><p>문자열에 있는 doctest를 디버그합니다.</p>
<p>doctest 예제를 포함하는 문자열이 <em>src</em> 인자를 통해 직접 지정된다는 점을 제외하면, 위의 함수 <a class="reference internal" href="#doctest.debug" title="doctest.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>과 같습니다.</p>
<p>선택적 인자 <em>pm</em>은 위의 함수 <a class="reference internal" href="#doctest.debug" title="doctest.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>에서와 같은 의미를 가집니다.</p>
<p>선택적 인자 <em>globs</em>는 지역과 전역 실행 컨텍스트 모두에 사용할 딕셔너리를 제공합니다. 지정되지 않거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, 빈 딕셔너리가 사용됩니다. 지정되면, 딕셔너리의 얕은 사본이 사용됩니다.</p>
</dd></dl>

<p><a class="reference internal" href="#doctest.DebugRunner" title="doctest.DebugRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DebugRunner</span></code></a> 클래스와 이 클래스가 발생시킬 수 있는 특별한 예외는 주로 테스트 프레임워크 작성자가 관심을 가지며, 여기에서는 대략적으로만 다룰 예정입니다. 자세한 내용은 소스 코드, 특히 <a class="reference internal" href="#doctest.DebugRunner" title="doctest.DebugRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DebugRunner</span></code></a>의 독스트링(doctest입니다!)을 참조하십시오:</p>
<dl class="class">
<dt id="doctest.DebugRunner">
<em class="property">class </em><code class="descclassname">doctest.</code><code class="descname">DebugRunner</code><span class="sig-paren">(</span><em>checker=None</em>, <em>verbose=None</em>, <em>optionflags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DebugRunner" title="정의 주소">¶</a></dt>
<dd><p>실패를 만나자마자 예외를 발생시키는 <a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>의 서브 클래스. 예기치 않은 예외가 발생하면, 테스트, 예제 및 원래 예외가 포함된 <a class="reference internal" href="#doctest.UnexpectedException" title="doctest.UnexpectedException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnexpectedException</span></code></a> 예외가 발생합니다. 출력이 일치하지 않으면, 테스트, 예제 및 실제 출력을 포함하는 <a class="reference internal" href="#doctest.DocTestFailure" title="doctest.DocTestFailure"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DocTestFailure</span></code></a> 예외가 발생합니다.</p>
<p>생성자 매개 변수와 메서드에 대한 자세한 내용은 <a class="reference internal" href="#doctest-advanced-api"><span class="std std-ref">고급 API</span></a> 절의 <a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a> 설명서를 참조하십시오.</p>
</dd></dl>

<p><a class="reference internal" href="#doctest.DebugRunner" title="doctest.DebugRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DebugRunner</span></code></a> 인스턴스가 발생시킬 수 있는 두 가지 예외가 있습니다:</p>
<dl class="exception">
<dt id="doctest.DocTestFailure">
<em class="property">exception </em><code class="descclassname">doctest.</code><code class="descname">DocTestFailure</code><span class="sig-paren">(</span><em>test</em>, <em>example</em>, <em>got</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.DocTestFailure" title="정의 주소">¶</a></dt>
<dd><p>doctest 예제의 실제 출력이 예상 출력과 일치하지 않는다는 것을 알리기 위해 <a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>가 발생시키는 예외. 생성자 인자는 같은 이름의 어트리뷰트를 초기화하는 데 사용됩니다.</p>
</dd></dl>

<p><a class="reference internal" href="#doctest.DocTestFailure" title="doctest.DocTestFailure"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DocTestFailure</span></code></a>는 다음 어트리뷰트를 정의합니다:</p>
<dl class="attribute">
<dt id="doctest.DocTestFailure.test">
<code class="descclassname">DocTestFailure.</code><code class="descname">test</code><a class="headerlink" href="#doctest.DocTestFailure.test" title="정의 주소">¶</a></dt>
<dd><p>예제가 실패했을 때 실행 중이던 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a> 객체.</p>
</dd></dl>

<dl class="attribute">
<dt id="doctest.DocTestFailure.example">
<code class="descclassname">DocTestFailure.</code><code class="descname">example</code><a class="headerlink" href="#doctest.DocTestFailure.example" title="정의 주소">¶</a></dt>
<dd><p>실패한 <a class="reference internal" href="#doctest.Example" title="doctest.Example"><code class="xref py py-class docutils literal notranslate"><span class="pre">Example</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="doctest.DocTestFailure.got">
<code class="descclassname">DocTestFailure.</code><code class="descname">got</code><a class="headerlink" href="#doctest.DocTestFailure.got" title="정의 주소">¶</a></dt>
<dd><p>예제의 실제 출력.</p>
</dd></dl>

<dl class="exception">
<dt id="doctest.UnexpectedException">
<em class="property">exception </em><code class="descclassname">doctest.</code><code class="descname">UnexpectedException</code><span class="sig-paren">(</span><em>test</em>, <em>example</em>, <em>exc_info</em><span class="sig-paren">)</span><a class="headerlink" href="#doctest.UnexpectedException" title="정의 주소">¶</a></dt>
<dd><p>doctest 예제가 예기치 않은 예외를 발생시켰음을 알리기 위해 <a class="reference internal" href="#doctest.DocTestRunner" title="doctest.DocTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code></a>가 발생시키는 예외. 생성자 인자는 같은 이름의 어트리뷰트를 초기화하는 데 사용됩니다.</p>
</dd></dl>

<p><a class="reference internal" href="#doctest.UnexpectedException" title="doctest.UnexpectedException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnexpectedException</span></code></a>는 다음 어트리뷰트를 정의합니다:</p>
<dl class="attribute">
<dt id="doctest.UnexpectedException.test">
<code class="descclassname">UnexpectedException.</code><code class="descname">test</code><a class="headerlink" href="#doctest.UnexpectedException.test" title="정의 주소">¶</a></dt>
<dd><p>예제가 실패했을 때 실행 중이던 <a class="reference internal" href="#doctest.DocTest" title="doctest.DocTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTest</span></code></a> 객체.</p>
</dd></dl>

<dl class="attribute">
<dt id="doctest.UnexpectedException.example">
<code class="descclassname">UnexpectedException.</code><code class="descname">example</code><a class="headerlink" href="#doctest.UnexpectedException.example" title="정의 주소">¶</a></dt>
<dd><p>실패한 <a class="reference internal" href="#doctest.Example" title="doctest.Example"><code class="xref py py-class docutils literal notranslate"><span class="pre">Example</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="doctest.UnexpectedException.exc_info">
<code class="descclassname">UnexpectedException.</code><code class="descname">exc_info</code><a class="headerlink" href="#doctest.UnexpectedException.exc_info" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>에 의해 반환되는 것과 같은, 예기치 않은 예외에 대한 정보가 포함된 튜플.</p>
</dd></dl>

</div>
<div class="section" id="soapbox">
<span id="doctest-soapbox"></span><h2>맺음말<a class="headerlink" href="#soapbox" title="제목 주소">¶</a></h2>
<p>소개에서 언급했듯이, <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>는 다음 세 가지 주요 용도로 성장했습니다:</p>
<ol class="arabic simple">
<li><p>독스트링에 있는 예제 검사.</p></li>
<li><p>회귀 테스트.</p></li>
<li><p>실행 가능한 문서/문학적(literate) 테스트.</p></li>
</ol>
<p>이러한 용도들은 다른 요구 사항을 가지며, 이를 구별하는 것이 중요합니다. 특히, 모호한 테스트 케이스로 독스트링을 채우는 것은 나쁜 설명서를 만듭니다.</p>
<p>독스트링을 작성할 때, 독스트링 예제를 주의해서 선택하십시오. 여기에는 배울 필요가 있는 기술이 있습니다---처음에는 자연스럽지 않을 수도 있습니다. 예제는 설명서에 진짜 가치를 부여해야 합니다. 좋은 예제는 종종 많은 단어의 가치가 있습니다. 주의 깊게 작업 된다면, 예제는 사용자에게 매우 가치 있을 것이며, 몇 년이 지나고 변함에 따라 여러 번 수집하는 데 드는 시간을 갚을 것입니다. 제 <a class="reference internal" href="#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 예제 중 하나가 &quot;해가 없는&quot; 변경 후에 얼마나 자주 작동을 멈추는지 지금도 놀라울 뿐입니다.</p>
<p>Doctest는 회귀 테스트를 위한 훌륭한 도구도 제공합니다. 특히 설명 텍스트를 생략하지 않는다면 더욱더 그렇습니다. 설명과 예제를 번갈아 보여줌으로써, 실제로 무엇이 왜 테스트 되는지를 추적하기가 훨씬 쉬워집니다. 테스트가 실패할 때, 좋은 설명은 문제가 무엇인지, 어떻게 고쳐야 하는지를 쉽게 파악할 수 있게 해줍니다. 코드 기반 테스트에 광범위한 주석을 쓸 수는 있는 것은 사실이지만, 그렇게 하는 프로그래머는 거의 없습니다. 많은 사람이 doctest 접근법을 사용하는 것이 훨씬 더 명확한 테스트를 유도한다는 것을 발견했습니다. 어쩌면 단순히 doctest가 설명을 작성하는 것을 코드를 작성하는 것보다 조금 더 쉽게 만들고, 코드에 주석을 쓰는 것이 조금 더 어렵기 때문일 것입니다. 저는 단지 그것보다는 더 깊이 들어간다고 생각합니다: doctest 기반 테스트를 작성할 때의 자연스러운 태도는 소프트웨어의 미세한 포인트를 설명하고 그것을 예제로 보여주는 것입니다. 이것은 자연스럽게 가장 간단한 기능으로 시작하고, 복잡하고 지엽적인 경우까지 논리적으로 진행되는 테스트 파일로 이어집니다. 무작위로 보이는 격리된 기능 조각을 테스트하는 격리된 함수들의 모음 대신에, 일관된 내러티브가 얻어집니다. 이것은 다른 태도이며, 테스트와 설명의 구별을 모호하게 하면서 다른 결과를 낳습니다.</p>
<p>회귀 테스트는 전용 객체나 파일로 제한하는 것이 가장 좋습니다. 테스트 구성을 위한 몇 가지 옵션이 있습니다.:</p>
<ul class="simple">
<li><p>대화형 예제로 테스트 케이스가 들어있는 텍스트 파일을 작성하고, <a class="reference internal" href="#doctest.testfile" title="doctest.testfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">testfile()</span></code></a>이나 <a class="reference internal" href="#doctest.DocFileSuite" title="doctest.DocFileSuite"><code class="xref py py-func docutils literal notranslate"><span class="pre">DocFileSuite()</span></code></a>를 사용하여 파일을 테스트하십시오. doctest를 처음부터 사용하도록 고안된 새로운 프로젝트에서 가장 쉬운 방법이지만, 이 방법을 권장합니다.</p></li>
<li><p>명명된 주제에 대한 테스트 케이스를 포함하는 단일 독스트링으로 구성된 <code class="docutils literal notranslate"><span class="pre">_regrtest_topic</span></code>이라는 함수를 정의하십시오. 이 함수들은 모듈과 같은 파일에 포함되거나 별도의 테스트 파일로 분리될 수 있습니다.</p></li>
<li><p>회귀 테스트 주제에서 테스트 케이스가 포함된 독스트링에 대한 <code class="docutils literal notranslate"><span class="pre">__test__</span></code> 딕셔너리 매핑을 정의하십시오.</p></li>
</ul>
<p>테스트를 모듈에 배치할 때, 모듈 자체가 테스트 실행기가 될 수 있습니다. 테스트가 실패할 때, 문제를 디버깅하는 동안 실패한 doctest 만 다시 실행하도록 테스트 실행기를 조정할 수 있습니다. 다음은 그러한 테스트 실행기의 최소 예입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">doctest</span><span class="o">.</span><span class="n">REPORT_NDIFF</span><span class="o">|</span><span class="n">doctest</span><span class="o">.</span><span class="n">FAIL_FAST</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">():</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">__test__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">doctest</span><span class="o">.</span><span class="n">run_docstring_examples</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                                       <span class="n">optionflags</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fail</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span><span class="n">optionflags</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> failures out of </span><span class="si">{}</span><span class="s2"> tests&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fail</span><span class="p">,</span> <span class="n">total</span><span class="p">))</span>
</pre></div>
</div>
<p class="rubric">각주</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>예상 출력과 예외를 모두 포함하는 예제는 지원되지 않습니다. 어디에서 하나가 끝나고 다른 하나가 시작되는지 추측하는 것은 너무 에러가 발생하기 쉽고, 이것은 또한 혼란스러운 테스트를 만들게 됩니다.</p>
</dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code> --- 대화형 파이썬 예제 테스트</a><ul>
<li><a class="reference internal" href="#simple-usage-checking-examples-in-docstrings">간단한 사용법: 독스트링에 있는 예제 확인하기</a></li>
<li><a class="reference internal" href="#simple-usage-checking-examples-in-a-text-file">간단한 사용법: 텍스트 파일에 있는 예제 확인하기</a></li>
<li><a class="reference internal" href="#how-it-works">작동 방법</a><ul>
<li><a class="reference internal" href="#which-docstrings-are-examined">어떤 독스트링을 검사합니까?</a></li>
<li><a class="reference internal" href="#how-are-docstring-examples-recognized">독스트링 예제는 어떻게 인식됩니까?</a></li>
<li><a class="reference internal" href="#what-s-the-execution-context">실행 컨텍스트란 무엇입니까?</a></li>
<li><a class="reference internal" href="#what-about-exceptions">예외는 어떻게 됩니까?</a></li>
<li><a class="reference internal" href="#option-flags">옵션 플래그</a></li>
<li><a class="reference internal" href="#directives">지시자</a></li>
<li><a class="reference internal" href="#warnings">경고</a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-api">기본 API</a></li>
<li><a class="reference internal" href="#unittest-api">Unittest API</a></li>
<li><a class="reference internal" href="#advanced-api">고급 API</a><ul>
<li><a class="reference internal" href="#doctest-objects">DocTest 객체</a></li>
<li><a class="reference internal" href="#example-objects">Example 객체</a></li>
<li><a class="reference internal" href="#doctestfinder-objects">DocTestFinder 객체</a></li>
<li><a class="reference internal" href="#doctestparser-objects">DocTestParser 객체</a></li>
<li><a class="reference internal" href="#doctestrunner-objects">DocTestRunner 객체</a></li>
<li><a class="reference internal" href="#outputchecker-objects">OutputChecker 객체</a></li>
</ul>
</li>
<li><a class="reference internal" href="#debugging">디버깅</a></li>
<li><a class="reference internal" href="#soapbox">맺음말</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="pydoc.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> --- 설명서 생성과 온라인 도움말 시스템</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="unittest.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> --- 단위 테스트 프레임워크</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="unittest.html" title="unittest --- 단위 테스트 프레임워크"
             >다음</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc --- 설명서 생성과 온라인 도움말 시스템"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >개발 도구</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>