
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>tarfile --- tar 아카이브 파일 읽기와 쓰기 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="파일 형식" href="fileformats.html" />
    <link rel="prev" title="zipfile --- ZIP 아카이브 작업" href="zipfile.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/tarfile.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="fileformats.html" title="파일 형식"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="zipfile.html" title="zipfile --- ZIP 아카이브 작업"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="archiving.html" accesskey="U">데이터 압축 및 보관</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-tarfile">
<span id="tarfile-read-and-write-tar-archive-files"></span><h1><a class="reference internal" href="#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> --- tar 아카이브 파일 읽기와 쓰기<a class="headerlink" href="#module-tarfile" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/tarfile.py">Lib/tarfile.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 모듈을 사용하면 gzip, bz2 및 lzma 압축을 사용하는 것을 포함하여, tar 아카이브를 읽고 쓸 수 있습니다. <code class="file docutils literal notranslate"><span class="pre">.zip</span></code> 파일을 읽거나 쓰려면 <a class="reference internal" href="zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> 모듈이나 <a class="reference internal" href="shutil.html#archiving-operations"><span class="std std-ref">shutil</span></a>에 있는 고수준 함수를 사용하십시오.</p>
<p>몇 가지 세부 사항:</p>
<ul class="simple">
<li><p>해당 모듈을 사용할 수 있으면 <a class="reference internal" href="gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gzip</span></code></a>, <a class="reference internal" href="bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a> 및 <a class="reference internal" href="lzma.html#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lzma</span></code></a> 압축 아카이브를 읽고 씁니다.</p></li>
<li><p>POSIX.1-1988 (ustar) 형식에 대한 읽기/쓰기 지원.</p></li>
<li><p><em>longname</em>과 <em>longlink</em> 확장을 포함한 GNU tar 형식에 대한 읽기/쓰기 지원, 스파스(sparse) 파일 복원을 포함하여 모든 <em>sparse</em> 확장 변형에 대한 읽기 전용 지원.</p></li>
<li><p>POSIX.1-2001 (pax) 형식에 대한 읽기/쓰기 지원.</p></li>
<li><p>디렉터리, 일반 파일, 하드 링크, 심볼릭 링크, fifo, 문자 장치 및 블록 장치를 처리하고 타임 스탬프, 액세스 권한 및 소유자와 같은 파일 정보를 획득하고 복원할 수 있습니다.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><a class="reference internal" href="lzma.html#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lzma</span></code></a> 압축에 대한 지원이 추가되었습니다.</p>
</div>
<dl class="function">
<dt id="tarfile.open">
<code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param">name=None</em>, <em class="sig-param">mode='r'</em>, <em class="sig-param">fileobj=None</em>, <em class="sig-param">bufsize=10240</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.open" title="정의 주소">¶</a></dt>
<dd><p>경로명 <em>name</em>에 대한 <a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a> 객체를 반환합니다. <a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a> 객체와 허용되는 키워드 인자에 대한 자세한 정보는 <a class="reference internal" href="#tarfile-objects"><span class="std std-ref">TarFile 객체</span></a>를 참조하십시오.</p>
<p><em>mode</em>는 <code class="docutils literal notranslate"><span class="pre">'filemode[:compression]'</span></code> 형식의 문자열이어야 하며, 기본값은 <code class="docutils literal notranslate"><span class="pre">'r'</span></code>입니다. 다음은 mode 조합의 전체 목록입니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>모드</p></th>
<th class="head"><p>동작</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'r'</span> <span class="pre">또는</span> <span class="pre">'r:*'</span></code></p></td>
<td><p>투명한 압축으로 읽기 위해 엽니다 (권장합니다).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'r:'</span></code></p></td>
<td><p>압축하지 않고 독점적으로 읽기 위해 엽니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'r:gz'</span></code></p></td>
<td><p>gzip 압축으로 읽기 위해 엽니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'r:bz2'</span></code></p></td>
<td><p>bzip2 압축으로 읽기 위해 엽니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'r:xz'</span></code></p></td>
<td><p>lzma 압축으로 읽기 위해 엽니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'x'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'x:'</span></code></p></td>
<td><p>압축하지 않고 독점적으로 tar 파일을 만듭니다. 이미 있으면 <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileExistsError</span></code></a> 예외를 발생시킵니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'x:gz'</span></code></p></td>
<td><p>gzip 압축으로 tar 파일을 만듭니다. 이미 있으면 <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileExistsError</span></code></a> 예외를 발생시킵니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'x:bz2'</span></code></p></td>
<td><p>bzip2 압축으로 tar 파일을 만듭니다. 이미 있으면 <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileExistsError</span></code></a> 예외를 발생시킵니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'x:xz'</span></code></p></td>
<td><p>lzma 압축으로 tar 파일을 만듭니다. 이미 있으면 <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileExistsError</span></code></a> 예외를 발생시킵니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'a'</span> <span class="pre">또는</span> <span class="pre">'a:'</span></code></p></td>
<td><p>압축하지 않고 추가하기 위해 엽니다. 파일이 없으면 만들어집니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'w'</span> <span class="pre">또는</span> <span class="pre">'w:'</span></code></p></td>
<td><p>압축되지 않은 쓰기를 위해 엽니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'w:gz'</span></code></p></td>
<td><p>gzip 압축 쓰기를 위해 엽니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'w:bz2'</span></code></p></td>
<td><p>bzip2 압축 쓰기를 위해 엽니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'w:xz'</span></code></p></td>
<td><p>lzma 압축 쓰기를 위해 엽니다.</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">'a:gz'</span></code>, <code class="docutils literal notranslate"><span class="pre">'a:bz2'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'a:xz'</span></code>는 불가능함에 유의하십시오. <em>mode</em>가 특정 (압축된) 파일을 읽기 위해 여는 데 적합하지 않으면 <a class="reference internal" href="#tarfile.ReadError" title="tarfile.ReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ReadError</span></code></a>가 발생합니다. 이것을 피하려면 <em>mode</em> <code class="docutils literal notranslate"><span class="pre">'r'</span></code>을 사용하십시오. 압축 방법이 지원되지 않으면, <a class="reference internal" href="#tarfile.CompressionError" title="tarfile.CompressionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CompressionError</span></code></a>가 발생합니다.</p>
<p><em>fileobj</em>가 지정되면, <em>name</em>에 대해 바이너리 모드로 열린 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a>의 대안으로 사용됩니다. 위치 0에 있다고 가정합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">'w:gz'</span></code>, <code class="docutils literal notranslate"><span class="pre">'r:gz'</span></code>, <code class="docutils literal notranslate"><span class="pre">'w:bz2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'r:bz2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x:gz'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x:bz2'</span></code> 모드의 경우, <a class="reference internal" href="#tarfile.open" title="tarfile.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">tarfile.open()</span></code></a>은 파일의 압축 수준을 지정하는 키워드 인자 <em>compresslevel</em>(기본값 <code class="docutils literal notranslate"><span class="pre">9</span></code>)을 받아들입니다.</p>
<p>특별한 목적으로, <em>mode</em>에는 두 번째 형식이 있습니다: <code class="docutils literal notranslate"><span class="pre">'filemode|[compression]'</span></code>. <a class="reference internal" href="#tarfile.open" title="tarfile.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">tarfile.open()</span></code></a>은 데이터를 블록 스트림으로 처리하는 <a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a> 객체를 반환합니다. 파일에서 무작위 탐색(random seeking)을 수행하지 않습니다. 주어지면,, <em>fileobj</em>는 (<em>mode</em>에 따라) <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code>나 <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> 메서드가 있는 임의의 객체일 수 있습니다. <em>bufsize</em>는 블록 크기를 지정하고 기본값은 <code class="docutils literal notranslate"><span class="pre">20</span> <span class="pre">*</span> <span class="pre">512</span></code> 바이트입니다. 이 변형을 예를 들어 <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, 소켓 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a> 또는 테이프 장치와 함께 사용하십시오. 그러나, 이러한 <a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a> 객체는 무작위 액세스를 허용하지 않는다는 제한이 있습니다 (<a class="reference internal" href="#tar-examples"><span class="std std-ref">예</span></a>를 참조하십시오). 현재 가능한 모드는 다음과 같습니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>모드</p></th>
<th class="head"><p>동작</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'r|*'</span></code></p></td>
<td><p>투명한 압축으로 읽기 위해 tar 블록의 <em>스트림</em>을 엽니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'r|'</span></code></p></td>
<td><p>읽기 위해 압축되지 않은 tar 블록의 <em>스트림</em>을 엽니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'r|gz'</span></code></p></td>
<td><p>읽기 위해 gzip 압축 <em>스트림</em>을 엽니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'r|bz2'</span></code></p></td>
<td><p>읽기 위해 bzip2 압축 <em>스트림</em>을 엽니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'r|xz'</span></code></p></td>
<td><p>읽기 위해 lzma 압축 <em>스트림</em>을 엽니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'w|'</span></code></p></td>
<td><p>쓰기 위해 압축되지 않은 <em>스트림</em>을 엽니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'w|gz'</span></code></p></td>
<td><p>쓰기 위해 gzip 압축 <em>스트림</em>을 엽니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'w|bz2'</span></code></p></td>
<td><p>쓰기 위해 bzip2 압축 <em>스트림</em>을 엽니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'w|xz'</span></code></p></td>
<td><p>쓰기 위해 lzma 압축 <em>스트림</em>을 엽니다.</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'x'</span></code> (독점 생성) 모드가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><em>name</em> 매개 변수는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="tarfile.TarFile">
<em class="property">class </em><code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">TarFile</code><a class="headerlink" href="#tarfile.TarFile" title="정의 주소">¶</a></dt>
<dd><p>tar 아카이브를 읽고 쓰는 클래스. 이 클래스를 직접 사용하지 마십시오: 대신 <a class="reference internal" href="#tarfile.open" title="tarfile.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">tarfile.open()</span></code></a>을 사용하십시오. <a class="reference internal" href="#tarfile-objects"><span class="std std-ref">TarFile 객체</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="tarfile.is_tarfile">
<code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">is_tarfile</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.is_tarfile" title="정의 주소">¶</a></dt>
<dd><p><em>name</em>이 <a class="reference internal" href="#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 모듈이 읽을 수 있는 tar 아카이브 파일이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다.</p>
</dd></dl>

<p><a class="reference internal" href="#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 모듈은 다음 예외를 정의합니다:</p>
<dl class="exception">
<dt id="tarfile.TarError">
<em class="property">exception </em><code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">TarError</code><a class="headerlink" href="#tarfile.TarError" title="정의 주소">¶</a></dt>
<dd><p>모든 <a class="reference internal" href="#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 예외의 베이스 클래스.</p>
</dd></dl>

<dl class="exception">
<dt id="tarfile.ReadError">
<em class="property">exception </em><code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">ReadError</code><a class="headerlink" href="#tarfile.ReadError" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 모듈에서 처리할 수 없거나 어떤 식으로든 유효하지 않은 tar 아카이브가 열릴 때 발생합니다.</p>
</dd></dl>

<dl class="exception">
<dt id="tarfile.CompressionError">
<em class="property">exception </em><code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">CompressionError</code><a class="headerlink" href="#tarfile.CompressionError" title="정의 주소">¶</a></dt>
<dd><p>압축 방법이 지원되지 않거나 데이터를 올바르게 디코딩할 수 없을 때 발생합니다.</p>
</dd></dl>

<dl class="exception">
<dt id="tarfile.StreamError">
<em class="property">exception </em><code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">StreamError</code><a class="headerlink" href="#tarfile.StreamError" title="정의 주소">¶</a></dt>
<dd><p>스트림류 <a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a> 객체에 일반적인 제한 사항으로 인해 발생합니다.</p>
</dd></dl>

<dl class="exception">
<dt id="tarfile.ExtractError">
<em class="property">exception </em><code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">ExtractError</code><a class="headerlink" href="#tarfile.ExtractError" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#tarfile.TarFile.extract" title="tarfile.TarFile.extract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TarFile.extract()</span></code></a>를 사용할 때 <em>치명적이지 않은</em> 에러에 대해 발생하지만, <code class="xref py py-attr docutils literal notranslate"><span class="pre">TarFile.errorlevel</span></code><code class="docutils literal notranslate"><span class="pre">==</span> <span class="pre">2</span></code>일 때만 발생합니다.</p>
</dd></dl>

<dl class="exception">
<dt id="tarfile.HeaderError">
<em class="property">exception </em><code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">HeaderError</code><a class="headerlink" href="#tarfile.HeaderError" title="정의 주소">¶</a></dt>
<dd><p>버퍼가 유효하지 않을 때 <a class="reference internal" href="#tarfile.TarInfo.frombuf" title="tarfile.TarInfo.frombuf"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TarInfo.frombuf()</span></code></a>에 의해 발생합니다.</p>
</dd></dl>

<p>모듈 수준에서 다음 상수를 사용할 수 있습니다:</p>
<dl class="data">
<dt id="tarfile.ENCODING">
<code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">ENCODING</code><a class="headerlink" href="#tarfile.ENCODING" title="정의 주소">¶</a></dt>
<dd><p>기본 문자 인코딩: 윈도우의 경우 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>, 그렇지 않으면 <a class="reference internal" href="sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code></a> 이 반환하는 값.</p>
</dd></dl>

<p>다음의 각 상수는 <a class="reference internal" href="#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 모듈이 만들 수 있는 tar 아카이브 형식을 정의합니다. 자세한 내용은 <a class="reference internal" href="#tar-formats"><span class="std std-ref">지원되는 tar 형식</span></a> 섹션을 참조하십시오.</p>
<dl class="data">
<dt id="tarfile.USTAR_FORMAT">
<code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">USTAR_FORMAT</code><a class="headerlink" href="#tarfile.USTAR_FORMAT" title="정의 주소">¶</a></dt>
<dd><p>POSIX.1-1988 (ustar) 형식.</p>
</dd></dl>

<dl class="data">
<dt id="tarfile.GNU_FORMAT">
<code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">GNU_FORMAT</code><a class="headerlink" href="#tarfile.GNU_FORMAT" title="정의 주소">¶</a></dt>
<dd><p>GNU tar 형식.</p>
</dd></dl>

<dl class="data">
<dt id="tarfile.PAX_FORMAT">
<code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">PAX_FORMAT</code><a class="headerlink" href="#tarfile.PAX_FORMAT" title="정의 주소">¶</a></dt>
<dd><p>POSIX.1-2001 (pax) 형식.</p>
</dd></dl>

<dl class="data">
<dt id="tarfile.DEFAULT_FORMAT">
<code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">DEFAULT_FORMAT</code><a class="headerlink" href="#tarfile.DEFAULT_FORMAT" title="정의 주소">¶</a></dt>
<dd><p>아카이브를 만들기 위한 기본 형식. 이것은 현재 <a class="reference internal" href="#tarfile.PAX_FORMAT" title="tarfile.PAX_FORMAT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PAX_FORMAT</span></code></a>입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>새 아카이브의 기본 형식이 <a class="reference internal" href="#tarfile.GNU_FORMAT" title="tarfile.GNU_FORMAT"><code class="xref py py-const docutils literal notranslate"><span class="pre">GNU_FORMAT</span></code></a>에서 <a class="reference internal" href="#tarfile.PAX_FORMAT" title="tarfile.PAX_FORMAT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PAX_FORMAT</span></code></a>으로 변경되었습니다.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt>모듈 <a class="reference internal" href="zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a></dt><dd><p><a class="reference internal" href="zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> 표준 모듈의 설명서.</p>
</dd>
<dt><a class="reference internal" href="shutil.html#archiving-operations"><span class="std std-ref">Archiving operations</span></a></dt><dd><p>표준 <a class="reference internal" href="shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> 모듈이 제공하는 고수준 아카이브 기능에 대한 설명서.</p>
</dd>
<dt><a class="reference external" href="https://www.gnu.org/software/tar/manual/html_node/Standard.html">GNU tar manual, Basic Tar Format</a></dt><dd><p>GNU tar 확장을 포함한, tar 아카이브 파일에 대한 설명서.</p>
</dd>
</dl>
</div>
<div class="section" id="tarfile-objects">
<span id="id1"></span><h2>TarFile 객체<a class="headerlink" href="#tarfile-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a> 객체는 tar 아카이브에 대한 인터페이스를 제공합니다. tar 아카이브는 블록의 시퀀스입니다. 아카이브 멤버(저장된 파일)는 헤더 블록과 그 뒤에 오는 데이터 블록으로 구성됩니다. tar 아카이브에 파일을 여러 번 저장할 수 있습니다. 각 아카이브 멤버는 <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체로 표현됩니다. 세부 사항은 <a class="reference internal" href="#tarinfo-objects"><span class="std std-ref">TarInfo 객체</span></a>를 참조하십시오.</p>
<p><a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a> 객체는 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문에서 컨텍스트 관리자로 사용될 수 있습니다. 블록이 완료되면 자동으로 닫힙니다. 예외가 있는 경우, 쓰기 위해 열린 아카이브는 마무리되지 않음에 유의하십시오; 내부적으로 사용된 파일 객체만 닫힙니다. 사용 사례는 <a class="reference internal" href="#tar-examples"><span class="std std-ref">예</span></a> 섹션을 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가: </span>컨텍스트 관리 프로토콜에 대한 지원이 추가되었습니다.</p>
</div>
<dl class="class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">TarFile</code><span class="sig-paren">(</span><em class="sig-param">name=None</em>, <em class="sig-param">mode='r'</em>, <em class="sig-param">fileobj=None</em>, <em class="sig-param">format=DEFAULT_FORMAT</em>, <em class="sig-param">tarinfo=TarInfo</em>, <em class="sig-param">dereference=False</em>, <em class="sig-param">ignore_zeros=False</em>, <em class="sig-param">encoding=ENCODING</em>, <em class="sig-param">errors='surrogateescape'</em>, <em class="sig-param">pax_headers=None</em>, <em class="sig-param">debug=0</em>, <em class="sig-param">errorlevel=0</em><span class="sig-paren">)</span></dt>
<dd><p>다음의 모든 인자는 선택적이며 인스턴스 어트리뷰트로도 액세스 할 수 있습니다.</p>
<p><em>name</em>은 아카이브의 경로명입니다. <em>name</em>은 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>일 수 있습니다. <em>fileobj</em>가 주어지면 생략할 수 있습니다. 이 경우, 파일 객체의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code> 어트리뷰트가 있다면 사용됩니다.</p>
<p><em>mode</em>는 기존 아카이브에서 읽는 <code class="docutils literal notranslate"><span class="pre">'r'</span></code>, 기존 파일에 데이터를 추가하는 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, 기존 파일을 덮어쓰는 새 파일을 만드는 <code class="docutils literal notranslate"><span class="pre">'w'</span></code> 또는 존재하지 않을 때만 새 파일을 만드는 <code class="docutils literal notranslate"><span class="pre">'x'</span></code>입니다.</p>
<p><em>fileobj</em>가 주어지면, 데이터를 읽거나 쓰는 데 사용됩니다. 그것이 결정될 수 있다면, <em>mode</em>는 <em>fileobj</em>의 모드에 의해 재정의됩니다. <em>fileobj</em>는 위치 0에서 사용됩니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a>이 닫힐 때, <em>fileobj</em>는 닫히지 않습니다.</p>
</div>
<p><em>format</em>은 쓰기를 위한 아카이브 형식을 제어합니다. 모듈 수준에서 정의되는 상수 <a class="reference internal" href="#tarfile.USTAR_FORMAT" title="tarfile.USTAR_FORMAT"><code class="xref py py-const docutils literal notranslate"><span class="pre">USTAR_FORMAT</span></code></a>, <a class="reference internal" href="#tarfile.GNU_FORMAT" title="tarfile.GNU_FORMAT"><code class="xref py py-const docutils literal notranslate"><span class="pre">GNU_FORMAT</span></code></a> 또는 <a class="reference internal" href="#tarfile.PAX_FORMAT" title="tarfile.PAX_FORMAT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PAX_FORMAT</span></code></a> 중 하나여야 합니다. 읽을 때, 형식은 자동 감지됩니다, 단일 아카이브에 다른 형식이 존재할 때조차 그렇습니다.</p>
<p><em>tarinfo</em> 인자를 사용하여 기본 <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 클래스를 다른 클래스로 바꿀 수 있습니다.</p>
<p><em>dereference</em>가 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>이면, 아카이브에 심볼릭과 하드 링크를 추가합니다. <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>이면, 대상 파일의 내용을 아카이브에 추가합니다. 이는 심볼릭 링크를 지원하지 않는 시스템에는 영향을 미치지 않습니다.</p>
<p><em>ignore_zeros</em>가 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>이면, 빈 블록을 아카이브의 끝으로 처리합니다. <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>이면, 비어있는 (그래서 잘못된) 블록을 건너뛰고 최대한 많은 멤버를 확보하려고 합니다. 이어붙였거나 손상된 아카이브를 읽을 때만 유용합니다.</p>
<p><em>debug</em>는 <code class="docutils literal notranslate"><span class="pre">0</span></code>(디버그 메시지 없음)에서 <code class="docutils literal notranslate"><span class="pre">3</span></code>(모든 디버그 메시지)까지 설정할 수 있습니다. 메시지는 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>에 기록됩니다.</p>
<p><em>errorlevel</em>이 <code class="docutils literal notranslate"><span class="pre">0</span></code>이면, <a class="reference internal" href="#tarfile.TarFile.extract" title="tarfile.TarFile.extract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TarFile.extract()</span></code></a>를 사용할 때 모든 에러가 무시됩니다. 그런데도, 디버깅이 활성화되면, 디버그 출력에 에러 메시지로 나타납니다. <code class="docutils literal notranslate"><span class="pre">1</span></code>이면, 모든 <em>치명적</em> 에러가 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 예외로 발생합니다. <code class="docutils literal notranslate"><span class="pre">2</span></code>이면, 모든 <em>치명적이지 않은</em> 에러도 <a class="reference internal" href="#tarfile.TarError" title="tarfile.TarError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TarError</span></code></a> 예외로 발생합니다.</p>
<p><em>encoding</em>과 <em>errors</em> 인자는 아카이브를 읽거나 쓰는 데 사용되는 문자 인코딩과 변환 에러 처리 방법을 정의합니다. 기본 설정은 대부분의 사용자에게 적용됩니다. 자세한 정보는 <a class="reference internal" href="#tar-unicode"><span class="std std-ref">유니코드 문제</span></a> 섹션을 참조하십시오.</p>
<p><em>pax_headers</em> 인자는 선택적인 문자열의 딕셔너리로, <em>format</em>이 <a class="reference internal" href="#tarfile.PAX_FORMAT" title="tarfile.PAX_FORMAT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PAX_FORMAT</span></code></a>이면 pax 전역 헤더로 추가됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>errors</em> 인자의 기본값으로 <code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code>를 사용합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'x'</span></code> (독점 생성) 모드가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><em>name</em> 매개 변수는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarFile.open">
<em class="property">classmethod </em><code class="sig-prename descclassname">TarFile.</code><code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param">...</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarFile.open" title="정의 주소">¶</a></dt>
<dd><p>대체 생성자. <a class="reference internal" href="#tarfile.open" title="tarfile.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">tarfile.open()</span></code></a> 함수는 실제로 이 클래스 메서드의 바로 가기입니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarFile.getmember">
<code class="sig-prename descclassname">TarFile.</code><code class="sig-name descname">getmember</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarFile.getmember" title="정의 주소">¶</a></dt>
<dd><p>멤버 <em>name</em>에 대한 <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체를 반환합니다. 아카이브에서 <em>name</em>을 찾을 수 없으면 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>가 발생합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>아카이브에서 멤버가 두 번 이상 등장하면, 마지막 등장을 최신 버전으로 간주합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarFile.getmembers">
<code class="sig-prename descclassname">TarFile.</code><code class="sig-name descname">getmembers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarFile.getmembers" title="정의 주소">¶</a></dt>
<dd><p>아카이브 멤버를 <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체의 리스트로 반환합니다. 리스트는 아카이브의 멤버와 순서가 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarFile.getnames">
<code class="sig-prename descclassname">TarFile.</code><code class="sig-name descname">getnames</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarFile.getnames" title="정의 주소">¶</a></dt>
<dd><p>멤버를 이름의 리스트로 반환합니다. <a class="reference internal" href="#tarfile.TarFile.getmembers" title="tarfile.TarFile.getmembers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getmembers()</span></code></a>가 반환하는 리스트와 순서가 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarFile.list">
<code class="sig-prename descclassname">TarFile.</code><code class="sig-name descname">list</code><span class="sig-paren">(</span><em class="sig-param">verbose=True</em>, <em class="sig-param">*</em>, <em class="sig-param">members=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarFile.list" title="정의 주소">¶</a></dt>
<dd><p>목차를 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>으로 인쇄합니다. <em>verbose</em>가 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>이면, 멤버 이름만 인쇄됩니다. <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>이면, <strong class="program">ls -l</strong>과 유사한 출력이 생성됩니다. 선택적 <em>members</em>가 제공되면, <a class="reference internal" href="#tarfile.TarFile.getmembers" title="tarfile.TarFile.getmembers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getmembers()</span></code></a>가 반환한 리스트의 부분집합이어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><em>members</em> 매개 변수를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarFile.next">
<code class="sig-prename descclassname">TarFile.</code><code class="sig-name descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarFile.next" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a>을 읽기 위해 열었을 때, 아카이브의 다음 멤버를 <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체로 반환합니다. 더는 없으면, <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarFile.extractall">
<code class="sig-prename descclassname">TarFile.</code><code class="sig-name descname">extractall</code><span class="sig-paren">(</span><em class="sig-param">path=&quot;.&quot;</em>, <em class="sig-param">members=None</em>, <em class="sig-param">*</em>, <em class="sig-param">numeric_owner=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarFile.extractall" title="정의 주소">¶</a></dt>
<dd><p>아카이브의 모든 멤버(members)를 현재 작업 디렉터리나 디렉터리 <em>path</em>로 추출합니다. 선택적 <em>members</em>가 제공되면, <a class="reference internal" href="#tarfile.TarFile.getmembers" title="tarfile.TarFile.getmembers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getmembers()</span></code></a>가 반환하는 리스트의 부분집합이어야 합니다. 소유자, 수정 시간 및 권한과 같은 디렉터리 정보는 모든 멤버가 추출된 후에 설정됩니다. 이것은 두 가지 문제를 해결하기 위한 것입니다: 디렉터리의 수정 시간은 파일이 생성될 때마다 재설정됩니다. 또한 디렉터리의 권한이 쓰기를 허용하지 않으면, 파일 추출이 실패합니다.</p>
<p><em>numeric_owner</em>가 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>이면, tar 파일의 uid와 gid 번호는 추출된 파일의 소유자/그룹을 설정하는 데 사용됩니다. 그렇지 않으면, tar 파일의 이름값이 사용됩니다.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>사전 검사 없이 신뢰할 수 없는 출처에서 온 아카이브를 추출하지 마십시오. 파일이 <em>path</em> 외부에 만들어질 수 있습니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">&quot;/&quot;</span></code>로 시작하는 절대 파일명이나 두 개의 점 <code class="docutils literal notranslate"><span class="pre">&quot;..&quot;</span></code>이 포함된 파일명을 가진 멤버.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><em>numeric_owner</em> 매개 변수를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><em>path</em> 매개 변수는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarFile.extract">
<code class="sig-prename descclassname">TarFile.</code><code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param">member</em>, <em class="sig-param">path=&quot;&quot;</em>, <em class="sig-param">set_attrs=True</em>, <em class="sig-param">*</em>, <em class="sig-param">numeric_owner=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarFile.extract" title="정의 주소">¶</a></dt>
<dd><p>전체 이름을 사용하여, 아카이브에서 현재 작업 디렉터리로 멤버(member)를 추출합니다. 파일 정보는 최대한 정확하게 추출됩니다. <em>member</em>는 파일명이나 <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체일 수 있습니다. <em>path</em>를 사용하여 다른 디렉터리를 지정할 수 있습니다. <em>path</em>는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>일 수 있습니다. <em>set_attrs</em>가 거짓이 아닌 한 파일 어트리뷰트(소유자, 수정 시간, 모드)가 설정됩니다.</p>
<p><em>numeric_owner</em>가 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>이면, tar 파일의 uid와 gid 번호는 추출된 파일의 소유자/그룹을 설정하는 데 사용됩니다. 그렇지 않으면, tar 파일의 이름값이 사용됩니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#tarfile.TarFile.extract" title="tarfile.TarFile.extract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extract()</span></code></a> 메서드는 여러 추출 문제를 처리하지 않습니다. 대부분의 경우 <a class="reference internal" href="#tarfile.TarFile.extractall" title="tarfile.TarFile.extractall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extractall()</span></code></a> 메서드 사용을 고려해야 합니다.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p><a class="reference internal" href="#tarfile.TarFile.extractall" title="tarfile.TarFile.extractall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extractall()</span></code></a>에 대한 경고를 참조하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>set_attrs</em> 매개 변수를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><em>numeric_owner</em> 매개 변수를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><em>path</em> 매개 변수는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarFile.extractfile">
<code class="sig-prename descclassname">TarFile.</code><code class="sig-name descname">extractfile</code><span class="sig-paren">(</span><em class="sig-param">member</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarFile.extractfile" title="정의 주소">¶</a></dt>
<dd><p>아카이브에서 멤버(member)를 파일 객체로 추출합니다. <em>member</em>는 파일명이나 <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체일 수 있습니다. <em>member</em>가 일반 파일이나 링크이면, <a class="reference internal" href="io.html#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedReader</span></code></a> 객체가 반환됩니다. 그렇지 않으면, <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>이 반환됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><a class="reference internal" href="io.html#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedReader</span></code></a> 객체를 반환합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarFile.add">
<code class="sig-prename descclassname">TarFile.</code><code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">arcname=None</em>, <em class="sig-param">recursive=True</em>, <em class="sig-param">*</em>, <em class="sig-param">filter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarFile.add" title="정의 주소">¶</a></dt>
<dd><p><em>name</em> 파일을 아카이브에 추가합니다. <em>name</em>은 모든 유형의 파일(디렉터리, fifo, 심볼릭 링크 등)일 수 있습니다. 지정되면, <em>arcname</em>은 아카이브에 있는 파일의 대체 이름을 지정합니다. 디렉터리는 기본적으로 재귀적으로 추가됩니다. <em>recursive</em>를 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>로 설정하면, 이를 피할 수 있습니다. 재귀는 항목을 정렬된 순서로 추가합니다. <em>filter</em>가 제공되면, <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체 인자를 취하고 변경된 <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체를 반환하는 함수여야 합니다. 이것이 대신 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환하면, <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체가 아카이브에서 제외됩니다. 예는 <a class="reference internal" href="#tar-examples"><span class="std std-ref">예</span></a>를 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>filter</em> 매개 변수를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>재귀는 항목을 정렬된 순서로 추가합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarFile.addfile">
<code class="sig-prename descclassname">TarFile.</code><code class="sig-name descname">addfile</code><span class="sig-paren">(</span><em class="sig-param">tarinfo</em>, <em class="sig-param">fileobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarFile.addfile" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체 <em>tarinfo</em>를 아카이브에 추가합니다. <em>fileobj</em>가 제공되면, <a class="reference internal" href="../glossary.html#term-binary-file"><span class="xref std std-term">바이너리 파일</span></a>이어야 하고, 여기서 <code class="docutils literal notranslate"><span class="pre">tarinfo.size</span></code> 바이트를 읽어서 아카이브에 추가합니다. <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체를 직접 혹은 <a class="reference internal" href="#tarfile.TarFile.gettarinfo" title="tarfile.TarFile.gettarinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gettarinfo()</span></code></a>를 사용하여  만들 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarFile.gettarinfo">
<code class="sig-prename descclassname">TarFile.</code><code class="sig-name descname">gettarinfo</code><span class="sig-paren">(</span><em class="sig-param">name=None</em>, <em class="sig-param">arcname=None</em>, <em class="sig-param">fileobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarFile.gettarinfo" title="정의 주소">¶</a></dt>
<dd><p>기존 파일에서 <a class="reference internal" href="os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a>이나 이와 동등한 것의 결과로부터 <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체를 만듭니다. 파일은 <em>name</em>으로 이름을 지정하거나, 파일 기술자를 갖는 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a> <em>fileobj</em>로 지정됩니다. <em>name</em>은 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>일 수 있습니다. 주어지면, <em>arcname</em>은 아카이브에 있는 파일의 대체 이름을 지정하고, 그렇지 않으면, 이름은 <em>fileobj</em>의 <a class="reference internal" href="io.html#io.FileIO.name" title="io.FileIO.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> 어트리뷰트나 <em>name</em> 인자에서 취합니다. 이름은 텍스트 문자열이어야 합니다.</p>
<p><a class="reference internal" href="#tarfile.TarFile.addfile" title="tarfile.TarFile.addfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addfile()</span></code></a>을 사용하여 추가하기 전에 <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a>의 일부 어트리뷰트를 수정할 수 있습니다. 파일 객체가 파일의 시작 부분에 위치한 일반 파일 객체가 아니면, <a class="reference internal" href="#tarfile.TarInfo.size" title="tarfile.TarInfo.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a>와 같은 어트리뷰트를 수정해야 할 수 있습니다. <a class="reference internal" href="gzip.html#gzip.GzipFile" title="gzip.GzipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">GzipFile</span></code></a>과 같은 객체가 이 상황에 해당합니다. <a class="reference internal" href="#tarfile.TarInfo.name" title="tarfile.TarInfo.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a>도 수정될 수 있으며, 이 경우 <em>arcname</em>은 더미 문자열일 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><em>name</em> 매개 변수는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarFile.close">
<code class="sig-prename descclassname">TarFile.</code><code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarFile.close" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a>을 닫습니다. 쓰기 모드에서는, 두 개의 마무리 0블록이 아카이브에 추가됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="tarfile.TarFile.pax_headers">
<code class="sig-prename descclassname">TarFile.</code><code class="sig-name descname">pax_headers</code><a class="headerlink" href="#tarfile.TarFile.pax_headers" title="정의 주소">¶</a></dt>
<dd><p>pax 전역 헤더의 키-값 쌍을 포함하는 딕셔너리.</p>
</dd></dl>

</div>
<div class="section" id="tarinfo-objects">
<span id="id2"></span><h2>TarInfo 객체<a class="headerlink" href="#tarinfo-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체는 <a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a>에 있는 하나의 멤버를 나타냅니다. 파일의 모든 필수 어트리뷰트(파일 유형, 크기, 시간, 권한, 소유자 등과 같은)를 저장하는 것 외에도, 파일 유형을 결정하는 유용한 메서드를 제공합니다. 파일의 데이터 자체를 포함하지 <em>않습니다</em>.</p>
<p><a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체는 <a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a>의 메서드 <code class="xref py py-meth docutils literal notranslate"><span class="pre">getmember()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">getmembers()</span></code> 및 <code class="xref py py-meth docutils literal notranslate"><span class="pre">gettarinfo()</span></code>에 의해 반환됩니다.</p>
<dl class="class">
<dt id="tarfile.TarInfo">
<em class="property">class </em><code class="sig-prename descclassname">tarfile.</code><code class="sig-name descname">TarInfo</code><span class="sig-paren">(</span><em class="sig-param">name=&quot;&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarInfo" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체를 만듭니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarInfo.frombuf">
<em class="property">classmethod </em><code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">frombuf</code><span class="sig-paren">(</span><em class="sig-param">buf</em>, <em class="sig-param">encoding</em>, <em class="sig-param">errors</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarInfo.frombuf" title="정의 주소">¶</a></dt>
<dd><p>문자열 버퍼 <em>buf</em>에서 <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체를 만들고 반환합니다.</p>
<p>버퍼가 유효하지 않으면 <a class="reference internal" href="#tarfile.HeaderError" title="tarfile.HeaderError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HeaderError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarInfo.fromtarfile">
<em class="property">classmethod </em><code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">fromtarfile</code><span class="sig-paren">(</span><em class="sig-param">tarfile</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarInfo.fromtarfile" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a> 객체 <em>tarfile</em>에서 다음 멤버를 읽고 <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체로 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarInfo.tobuf">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">tobuf</code><span class="sig-paren">(</span><em class="sig-param">format=DEFAULT_FORMAT</em>, <em class="sig-param">encoding=ENCODING</em>, <em class="sig-param">errors='surrogateescape'</em><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarInfo.tobuf" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체에서 문자열 버퍼를 만듭니다. 인자에 대한 정보는 <a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a> 클래스의 생성자를 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>errors</em> 인자의 기본값으로 <code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code>를 사용합니다.</p>
</div>
</dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">TarInfo</span></code> 객체에는 다음과 같은 공개 데이터 어트리뷰트가 있습니다:</p>
<dl class="attribute">
<dt id="tarfile.TarInfo.name">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">name</code><a class="headerlink" href="#tarfile.TarInfo.name" title="정의 주소">¶</a></dt>
<dd><p>아카이브 멤버의 이름</p>
</dd></dl>

<dl class="attribute">
<dt id="tarfile.TarInfo.size">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">size</code><a class="headerlink" href="#tarfile.TarInfo.size" title="정의 주소">¶</a></dt>
<dd><p>바이트 단위의 크기.</p>
</dd></dl>

<dl class="attribute">
<dt id="tarfile.TarInfo.mtime">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">mtime</code><a class="headerlink" href="#tarfile.TarInfo.mtime" title="정의 주소">¶</a></dt>
<dd><p>마지막 수정 시간.</p>
</dd></dl>

<dl class="attribute">
<dt id="tarfile.TarInfo.mode">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">mode</code><a class="headerlink" href="#tarfile.TarInfo.mode" title="정의 주소">¶</a></dt>
<dd><p>권한 비트.</p>
</dd></dl>

<dl class="attribute">
<dt id="tarfile.TarInfo.type">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">type</code><a class="headerlink" href="#tarfile.TarInfo.type" title="정의 주소">¶</a></dt>
<dd><p>파일 유형. <em>type</em>은 일반적으로 다음 상수 중 하나입니다: <code class="xref py py-const docutils literal notranslate"><span class="pre">REGTYPE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">AREGTYPE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">LNKTYPE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">SYMTYPE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">DIRTYPE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">FIFOTYPE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">CONTTYPE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">CHRTYPE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">BLKTYPE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">GNUTYPE_SPARSE</span></code>. <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체의 유형을 더 편리하게 결정하려면, 아래 <code class="docutils literal notranslate"><span class="pre">is*()</span></code> 메서드를 사용하십시오.</p>
</dd></dl>

<dl class="attribute">
<dt id="tarfile.TarInfo.linkname">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">linkname</code><a class="headerlink" href="#tarfile.TarInfo.linkname" title="정의 주소">¶</a></dt>
<dd><p>대상 파일 이름의 이름, <code class="xref py py-const docutils literal notranslate"><span class="pre">LNKTYPE</span></code>과 <code class="xref py py-const docutils literal notranslate"><span class="pre">SYMTYPE</span></code> 유형의 <a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체에만 존재합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="tarfile.TarInfo.uid">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">uid</code><a class="headerlink" href="#tarfile.TarInfo.uid" title="정의 주소">¶</a></dt>
<dd><p>이 멤버를 처음 저장한 사용자의 사용자 ID.</p>
</dd></dl>

<dl class="attribute">
<dt id="tarfile.TarInfo.gid">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">gid</code><a class="headerlink" href="#tarfile.TarInfo.gid" title="정의 주소">¶</a></dt>
<dd><p>이 멤버를 처음 저장한 사용자의 그룹 ID.</p>
</dd></dl>

<dl class="attribute">
<dt id="tarfile.TarInfo.uname">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">uname</code><a class="headerlink" href="#tarfile.TarInfo.uname" title="정의 주소">¶</a></dt>
<dd><p>사용자 이름.</p>
</dd></dl>

<dl class="attribute">
<dt id="tarfile.TarInfo.gname">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">gname</code><a class="headerlink" href="#tarfile.TarInfo.gname" title="정의 주소">¶</a></dt>
<dd><p>그룹 이름.</p>
</dd></dl>

<dl class="attribute">
<dt id="tarfile.TarInfo.pax_headers">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">pax_headers</code><a class="headerlink" href="#tarfile.TarInfo.pax_headers" title="정의 주소">¶</a></dt>
<dd><p>연관된 pax 확장 헤더의 키-값 쌍을 포함하는 딕셔너리.</p>
</dd></dl>

<p><a class="reference internal" href="#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 객체는 편리한 조회 메서드도 제공합니다:</p>
<dl class="method">
<dt id="tarfile.TarInfo.isfile">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">isfile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarInfo.isfile" title="정의 주소">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tarinfo</span></code> 객체가 일반 파일이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarInfo.isreg">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">isreg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarInfo.isreg" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#tarfile.TarInfo.isfile" title="tarfile.TarInfo.isfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isfile()</span></code></a>과 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarInfo.isdir">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">isdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarInfo.isdir" title="정의 주소">¶</a></dt>
<dd><p>디렉터리이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarInfo.issym">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">issym</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarInfo.issym" title="정의 주소">¶</a></dt>
<dd><p>심볼릭 링크이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarInfo.islnk">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">islnk</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarInfo.islnk" title="정의 주소">¶</a></dt>
<dd><p>하드 링크이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarInfo.ischr">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">ischr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarInfo.ischr" title="정의 주소">¶</a></dt>
<dd><p>문자 장치이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarInfo.isblk">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">isblk</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarInfo.isblk" title="정의 주소">¶</a></dt>
<dd><p>블록 장치이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarInfo.isfifo">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">isfifo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarInfo.isfifo" title="정의 주소">¶</a></dt>
<dd><p>FIFO이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="tarfile.TarInfo.isdev">
<code class="sig-prename descclassname">TarInfo.</code><code class="sig-name descname">isdev</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tarfile.TarInfo.isdev" title="정의 주소">¶</a></dt>
<dd><p>문자 장치, 블록 장치 또는 FIFO 중 하나이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다.</p>
</dd></dl>

</div>
<div class="section" id="command-line-interface">
<span id="tarfile-commandline"></span><h2>명령 줄 인터페이스<a class="headerlink" href="#command-line-interface" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<p><a class="reference internal" href="#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 모듈은 tar 아카이브와 상호 작용하기 위한 간단한 명령 줄 인터페이스를 제공합니다.</p>
<p>새 tar 아카이브를 만들려면, <a class="reference internal" href="#cmdoption-tarfile-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c</span></code></a> 옵션 뒤에 이름을 지정한 다음 포함해야 하는 파일 이름을 나열하십시오:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m tarfile -c monty.tar  spam.txt eggs.txt
</pre></div>
</div>
<p>디렉터리 전달도 허용됩니다:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m tarfile -c monty.tar life-of-brian_1979/
</pre></div>
</div>
<p>tar 아카이브를 현재 디렉터리로 추출하려면, <a class="reference internal" href="#cmdoption-tarfile-e"><code class="xref std std-option docutils literal notranslate"><span class="pre">-e</span></code></a> 옵션을 사용하십시오:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m tarfile -e monty.tar
</pre></div>
</div>
<p>디렉터리 이름을 전달하여 tar 아카이브를 다른 디렉터리로 추출할 수도 있습니다:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m tarfile -e monty.tar  other-dir/
</pre></div>
</div>
<p>tar 아카이브에 있는 파일 목록을 보려면, <a class="reference internal" href="#cmdoption-tarfile-l"><code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code></a> 옵션을 사용하십시오:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m tarfile -l monty.tar
</pre></div>
</div>
<div class="section" id="command-line-options">
<h3>명령 줄 옵션<a class="headerlink" href="#command-line-options" title="제목 주소">¶</a></h3>
<dl class="cmdoption">
<dt id="cmdoption-tarfile-l">
<code class="sig-name descname">-l</code><code class="sig-prename descclassname"> &lt;tarfile&gt;</code><a class="headerlink" href="#cmdoption-tarfile-l" title="정의 주소">¶</a></dt>
<dt id="cmdoption-tarfile-list">
<code class="sig-name descname">--list</code><code class="sig-prename descclassname"> &lt;tarfile&gt;</code><a class="headerlink" href="#cmdoption-tarfile-list" title="정의 주소">¶</a></dt>
<dd><p>tarfile에 있는 파일을 나열합니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-tarfile-c">
<code class="sig-name descname">-c</code><code class="sig-prename descclassname"> &lt;tarfile&gt; &lt;source1&gt; ... &lt;sourceN&gt;</code><a class="headerlink" href="#cmdoption-tarfile-c" title="정의 주소">¶</a></dt>
<dt id="cmdoption-tarfile-create">
<code class="sig-name descname">--create</code><code class="sig-prename descclassname"> &lt;tarfile&gt; &lt;source1&gt; ... &lt;sourceN&gt;</code><a class="headerlink" href="#cmdoption-tarfile-create" title="정의 주소">¶</a></dt>
<dd><p>소스 파일에서 tarfile을 만듭니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-tarfile-e">
<code class="sig-name descname">-e</code><code class="sig-prename descclassname"> &lt;tarfile&gt; [&lt;output_dir&gt;]</code><a class="headerlink" href="#cmdoption-tarfile-e" title="정의 주소">¶</a></dt>
<dt id="cmdoption-tarfile-extract">
<code class="sig-name descname">--extract</code><code class="sig-prename descclassname"> &lt;tarfile&gt; [&lt;output_dir&gt;]</code><a class="headerlink" href="#cmdoption-tarfile-extract" title="정의 주소">¶</a></dt>
<dd><p><em>output_dir</em>이 지정되지 않으면 tarfile을 현재 디렉터리로 추출합니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-tarfile-t">
<code class="sig-name descname">-t</code><code class="sig-prename descclassname"> &lt;tarfile&gt;</code><a class="headerlink" href="#cmdoption-tarfile-t" title="정의 주소">¶</a></dt>
<dt id="cmdoption-tarfile-test">
<code class="sig-name descname">--test</code><code class="sig-prename descclassname"> &lt;tarfile&gt;</code><a class="headerlink" href="#cmdoption-tarfile-test" title="정의 주소">¶</a></dt>
<dd><p>tarfile이 유효한지 테스트합니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-tarfile-v">
<code class="sig-name descname">-v</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--verbose</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-tarfile-v" title="정의 주소">¶</a></dt>
<dd><p>상세한 출력.</p>
</dd></dl>

</div>
</div>
<div class="section" id="examples">
<span id="tar-examples"></span><h2>예<a class="headerlink" href="#examples" title="제목 주소">¶</a></h2>
<p>전체 tar 아카이브를 현재 작업 디렉터리로 추출하는 방법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tarfile</span>
<span class="n">tar</span> <span class="o">=</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;sample.tar.gz&quot;</span><span class="p">)</span>
<span class="n">tar</span><span class="o">.</span><span class="n">extractall</span><span class="p">()</span>
<span class="n">tar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>리스트 대신 제너레이터 함수를 사용하여 <a class="reference internal" href="#tarfile.TarFile.extractall" title="tarfile.TarFile.extractall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TarFile.extractall()</span></code></a>로 tar 아카이브의 부분집합을 추출하는 방법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">tarfile</span>

<span class="k">def</span> <span class="nf">py_files</span><span class="p">(</span><span class="n">members</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">tarinfo</span> <span class="ow">in</span> <span class="n">members</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">tarinfo</span><span class="o">.</span><span class="n">name</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.py&quot;</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">tarinfo</span>

<span class="n">tar</span> <span class="o">=</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;sample.tar.gz&quot;</span><span class="p">)</span>
<span class="n">tar</span><span class="o">.</span><span class="n">extractall</span><span class="p">(</span><span class="n">members</span><span class="o">=</span><span class="n">py_files</span><span class="p">(</span><span class="n">tar</span><span class="p">))</span>
<span class="n">tar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>파일명 리스트로 압축되지 않은 tar 아카이브를 만드는 방법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tarfile</span>
<span class="n">tar</span> <span class="o">=</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;sample.tar&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="s2">&quot;quux&quot;</span><span class="p">]:</span>
    <span class="n">tar</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="n">tar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문을 사용한 같은 예제:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tarfile</span>
<span class="k">with</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;sample.tar&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tar</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="s2">&quot;quux&quot;</span><span class="p">]:</span>
        <span class="n">tar</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>gzip 압축 tar 아카이브를 읽고 일부 멤버 정보를 표시하는 방법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tarfile</span>
<span class="n">tar</span> <span class="o">=</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;sample.tar.gz&quot;</span><span class="p">,</span> <span class="s2">&quot;r:gz&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tarinfo</span> <span class="ow">in</span> <span class="n">tar</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tarinfo</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="n">tarinfo</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s2">&quot;bytes in size and is&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tarinfo</span><span class="o">.</span><span class="n">isreg</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;a regular file.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">tarinfo</span><span class="o">.</span><span class="n">isdir</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;a directory.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;something else.&quot;</span><span class="p">)</span>
<span class="n">tar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="#tarfile.TarFile.add" title="tarfile.TarFile.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TarFile.add()</span></code></a>의 <em>filter</em> 매개 변수를 사용하여 아카이브를 만들고 사용자 정보를 재설정하는 방법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tarfile</span>
<span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="n">tarinfo</span><span class="p">):</span>
    <span class="n">tarinfo</span><span class="o">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">tarinfo</span><span class="o">.</span><span class="n">gid</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tarinfo</span><span class="o">.</span><span class="n">uname</span> <span class="o">=</span> <span class="n">tarinfo</span><span class="o">.</span><span class="n">gname</span> <span class="o">=</span> <span class="s2">&quot;root&quot;</span>
    <span class="k">return</span> <span class="n">tarinfo</span>
<span class="n">tar</span> <span class="o">=</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;sample.tar.gz&quot;</span><span class="p">,</span> <span class="s2">&quot;w:gz&quot;</span><span class="p">)</span>
<span class="n">tar</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="n">reset</span><span class="p">)</span>
<span class="n">tar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="supported-tar-formats">
<span id="tar-formats"></span><h2>지원되는 tar 형식<a class="headerlink" href="#supported-tar-formats" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 모듈로 만들 수 있는 tar 형식은 세 가지입니다:</p>
<ul>
<li><p>POSIX.1-1988 ustar 형식 (<a class="reference internal" href="#tarfile.USTAR_FORMAT" title="tarfile.USTAR_FORMAT"><code class="xref py py-const docutils literal notranslate"><span class="pre">USTAR_FORMAT</span></code></a>). 최대 256자 길이의 파일명과 최대 100자 링크 이름을 지원합니다. 최대 파일 크기는 8 GiB입니다. 이것은 오래되고 제한적이지만 널리 지원되는 형식입니다.</p></li>
<li><p>GNU tar 형식 (<a class="reference internal" href="#tarfile.GNU_FORMAT" title="tarfile.GNU_FORMAT"><code class="xref py py-const docutils literal notranslate"><span class="pre">GNU_FORMAT</span></code></a>). 긴 파일명과 링크 이름, 8GiB보다 큰 파일과 스파스(sparse) 파일을 지원합니다. 이것은 GNU/Linux 시스템에서 사실상 표준입니다. <a class="reference internal" href="#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a>은 긴 이름에 대한 GNU tar 확장을 완전히 지원하며 스파스(sparse) 파일 지원은 읽기 전용입니다.</p></li>
<li><p>POSIX.1-2001 pax 형식 (<a class="reference internal" href="#tarfile.PAX_FORMAT" title="tarfile.PAX_FORMAT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PAX_FORMAT</span></code></a>). 사실상 제한이 없는 가장 유연한 형식입니다. 긴 파일명과 링크 이름, 큰 파일을 지원하며 경로명을 이식성 있는 방식으로 저장합니다. GNU tar, bsdtar/libarchive 및 star를 포함한 최신 tar 구현은 확장된 <em>pax</em> 기능을 완벽하게 지원합니다; 일부 오래되었거나 유지 관리되지 않는 라이브러리는 그렇지 않을 수 있지만, <em>pax</em> 아카이브를 마치 범용적으로 지원되는 <em>ustar</em> 형식인 것처럼 취급해야 합니다. 새 아카이브의 현재 기본 형식입니다.</p>
<p>다른 방법으로 저장할 수 없는 정보를 위해 추가 헤더를 사용하여 기존 <em>ustar</em> 형식을 확장합니다. pax 헤더에는 두 가지 종류가 있습니다: 확장(extended) 헤더는 후속 파일 헤더에만 영향을 미치며, 전역(global) 헤더는 전체 아카이브에 유효하며 뒤따르는 파일 모두에 영향을 미칩니다. pax 헤더의 모든 데이터는 이식성의 이유로 <em>UTF-8</em>로 인코딩됩니다.</p>
</li>
</ul>
<p>읽을 수는 있지만 만들 수 없는 tar 형식의 변형이 더 있습니다:</p>
<ul class="simple">
<li><p>고대 V7 형식. 이것은 일반 파일과 디렉터리 만 저장하는 유닉스 7판(Unix Seventh Edition)에서 온 첫 번째 tar 형식입니다. 이름은 100자 이하여야 합니다. 사용자/그룹 이름 정보는 없습니다. ASCII가 아닌 문자가 있는 필드의 경우 일부 아카이브에서 헤더 체크섬이 잘못 계산되었습니다.</p></li>
<li><p>SunOS tar 확장 형식. 이 형식은 POSIX.1-2001 pax 형식의 변형이지만, 호환되지 않습니다.</p></li>
</ul>
</div>
<div class="section" id="unicode-issues">
<span id="tar-unicode"></span><h2>유니코드 문제<a class="headerlink" href="#unicode-issues" title="제목 주소">¶</a></h2>
<p>tar 형식은 원래 파일 시스템 정보 보존에 중점을 두고 테이프 드라이브에서 백업하기 위해 고안되었습니다. 현재 tar 아카이브는 일반적으로 파일 배포와 네트워크를 통한 아카이브 교환에 사용됩니다. 원래 형식(다른 모든 형식의 기초)의 한 가지 문제점은 다른 문자 인코딩을 지원한다는 개념이 없다는 것입니다. 예를 들어, <em>UTF-8</em> 시스템에서 만들어진 일반 tar 아카이브는 <em>ASCII</em>가 아닌 문자가 포함되면 <em>Latin-1</em> 시스템에서 올바르게 읽을 수 없습니다. (파일명, 링크 이름, 사용자/그룹 이름과 같은) 텍스트 메타 데이터가 손상된 것으로 나타납니다. 불행히도, 아카이브의 인코딩을 자동 감지하는 방법은 없습니다. pax 형식은 이 문제를 해결하도록 설계되었습니다. 범용 문자 인코딩 <em>UTF-8</em>을 사용하여 ASCII가 아닌 메타 데이터를 저장합니다.</p>
<p><a class="reference internal" href="#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a>에서 문자 변환의 세부 사항은 <a class="reference internal" href="#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a> 클래스의 <em>encoding</em>과 <em>errors</em> 키워드 인자에 의해 제어됩니다.</p>
<p><em>encoding</em>은 아카이브의 메타 데이터에 사용할 문자 인코딩을 정의합니다. 기본값은 <a class="reference internal" href="sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code></a> 이고, 또는 폴 백으로 <code class="docutils literal notranslate"><span class="pre">'ascii'</span></code>입니다. 아카이브를 읽거나 쓰는지에 따라, 메타 데이터를 디코딩하거나 인코딩해야 합니다. <em>encoding</em>이 올바르게 설정되지 않으면, 이 변환이 실패 할 수 있습니다.</p>
<p><em>errors</em> 인자는 변환할 수 없는 문자를 처리하는 방법을 정의합니다. 가능한 값은 섹션 <a class="reference internal" href="codecs.html#error-handlers"><span class="std std-ref">Error Handlers</span></a>에 나열되어 있습니다. 기본 체계는 파이썬은 파일 시스템 호출에도 사용하는 <code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code>입니다, <a class="reference internal" href="os.html#os-filenames"><span class="std std-ref">파일명, 명령 줄 인자 및 환경 변수</span></a>를 참조하십시오.</p>
<p><a class="reference internal" href="#tarfile.PAX_FORMAT" title="tarfile.PAX_FORMAT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PAX_FORMAT</span></code></a> 아카이브(기본값)의 경우, 모든 메타 데이터가 <em>UTF-8</em>을 사용하여 저장기 때문에 <em>encoding</em>은 일반적으로 필요하지 않습니다. <em>encoding</em>은 바이너리 pax 헤더가 디코딩되거나 서로게이트 문자가 있는 문자열이 저장될 때와 같은 드문 경우에만 사용됩니다.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code> --- tar 아카이브 파일 읽기와 쓰기</a><ul>
<li><a class="reference internal" href="#tarfile-objects">TarFile 객체</a></li>
<li><a class="reference internal" href="#tarinfo-objects">TarInfo 객체</a></li>
<li><a class="reference internal" href="#command-line-interface">명령 줄 인터페이스</a><ul>
<li><a class="reference internal" href="#command-line-options">명령 줄 옵션</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">예</a></li>
<li><a class="reference internal" href="#supported-tar-formats">지원되는 tar 형식</a></li>
<li><a class="reference internal" href="#unicode-issues">유니코드 문제</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="zipfile.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code> --- ZIP 아카이브 작업</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="fileformats.html"
                        title="다음 장">파일 형식</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="fileformats.html" title="파일 형식"
             >다음</a> |</li>
        <li class="right" >
          <a href="zipfile.html" title="zipfile --- ZIP 아카이브 작업"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="archiving.html" >데이터 압축 및 보관</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>