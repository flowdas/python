
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>19.5.1. 베이스 이벤트 루프 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="19.5.2. Event loops" href="asyncio-eventloops.html" />
    <link rel="prev" title="19.5. asyncio --- 비동기 I/O, 이벤트 루프, 코루틴과 태스크" href="asyncio.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/library/asyncio-eventloop.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-eventloops.html" title="19.5.2. Event loops"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="asyncio.html" title="19.5. asyncio --- 비동기 I/O, 이벤트 루프, 코루틴과 태스크"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >19. 프로세스 간 통신과 네트워킹</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U">19.5. <code class="docutils literal"><span class="pre">asyncio</span></code> --- 비동기 I/O, 이벤트 루프, 코루틴과 태스크</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="base-event-loop">
<span id="asyncio-event-loop"></span><h1>19.5.1. 베이스 이벤트 루프<a class="headerlink" href="#base-event-loop" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/asyncio/events.py">Lib/asyncio/events.py</a></p>
<p>이벤트 루프는 <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 가 제공하는 중앙 실행 장치입니다. 다음과 같은 여러 시설을 제공합니다:</p>
<ul class="simple">
<li>지연된 호출(시간 제한)을 등록, 실행, 취소하기.</li>
<li>다양한 종류의 통신을 위한 클라이언트와 서버 <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">트랜스포트</span></a> 만들기.</li>
<li>외부 프로그램과의 통신을 위해 서브 프로세스와 관련 <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">트랜스포트</span></a> 시작하기.</li>
<li>비싼 함수 호출을 스레드 풀에 위임하기.</li>
</ul>
<dl class="class">
<dt id="asyncio.BaseEventLoop">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">BaseEventLoop</code><a class="headerlink" href="#asyncio.BaseEventLoop" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 구현 세부 사항입니다. <a class="reference internal" href="#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code class="xref py py-class docutils literal"><span class="pre">AbstractEventLoop</span></code></a> 의 서브 클래스이며, <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 에서 발견되는 구상 이벤트 루프 구현의 베이스 클래스가 될 수 있습니다. 직접적으로 사용해서는 안됩니다; 대신 <a class="reference internal" href="#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code class="xref py py-class docutils literal"><span class="pre">AbstractEventLoop</span></code></a> 를 사용하십시오. <code class="docutils literal"><span class="pre">BaseEventLoop</span></code> 는 제삼자 코드에 의해 서브 클래싱 되어서는 안됩니다; 내부 인터페이스는 안정적이지 않습니다.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.AbstractEventLoop">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">AbstractEventLoop</code><a class="headerlink" href="#asyncio.AbstractEventLoop" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프의 추상 베이스 클래스입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">다음에 소개되는 <a class="reference internal" href="#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code class="xref py py-class docutils literal"><span class="pre">AbstractEventLoop</span></code></a> 클래스의 모든 메서드는 추상 메서드입니다.
여러분이 직접 이벤트 루프를 제작하려고 하면 모든 메서드들 구현해야한다는 뜻입니다.</p>
</div>
<p>이 클래스는 <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">쓰레드 안전하지 않습니다</span></a>.</p>
</dd></dl>

<div class="section" id="run-an-event-loop">
<h2>19.5.1.1. 이벤트 루프 실행<a class="headerlink" href="#run-an-event-loop" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.run_forever">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">run_forever</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.run_forever" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.AbstractEventLoop.stop" title="asyncio.AbstractEventLoop.stop"><code class="xref py py-meth docutils literal"><span class="pre">stop()</span></code></a> 이 호출 될 때까지 실행합니다. <a class="reference internal" href="#asyncio.AbstractEventLoop.run_forever" title="asyncio.AbstractEventLoop.run_forever"><code class="xref py py-meth docutils literal"><span class="pre">run_forever()</span></code></a> 가 호출되기 전에 <a class="reference internal" href="#asyncio.AbstractEventLoop.stop" title="asyncio.AbstractEventLoop.stop"><code class="xref py py-meth docutils literal"><span class="pre">stop()</span></code></a> 이 호출되었으면, 이것은 시간 제한 0으로 I/O 셀렉터를 한 번 폴링하고, I/O 이벤트에 따라 스케줄된 모든 콜백(과 이미 스케쥴된 것들)을 실행한 다음 종료합니다. 만약 <a class="reference internal" href="#asyncio.AbstractEventLoop.stop" title="asyncio.AbstractEventLoop.stop"><code class="xref py py-meth docutils literal"><span class="pre">stop()</span></code></a> 이 <a class="reference internal" href="#asyncio.AbstractEventLoop.run_forever" title="asyncio.AbstractEventLoop.run_forever"><code class="xref py py-meth docutils literal"><span class="pre">run_forever()</span></code></a> 가 실행 중일 때 호출되면, 현재 걸려있는 콜백들을 실행 한 다음 종료합니다. 콜백에 의해 스케줄되는 콜백은 이 경우 실행되지 않습니다; 그 것들은 다음에 <a class="reference internal" href="#asyncio.AbstractEventLoop.run_forever" title="asyncio.AbstractEventLoop.run_forever"><code class="xref py py-meth docutils literal"><span class="pre">run_forever()</span></code></a> 가 호출될 때 실행됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p>여기에서 구체적으로 제한하고 있지는 않지만, <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 에서 제공되는 모든 이벤트 루프는
재진입할 수 없습니다. 즉 이벤트 루프가 실행중일 때 자신 또는 다른 이벤트 루프의 <a class="reference internal" href="#asyncio.AbstractEventLoop.run_forever" title="asyncio.AbstractEventLoop.run_forever"><code class="xref py py-meth docutils literal"><span class="pre">run_forever()</span></code></a>
메서드를 호출하면 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> 예외를 일으킵니다. 이 제약은 <a class="reference internal" href="#asyncio.AbstractEventLoop.run_until_complete" title="asyncio.AbstractEventLoop.run_until_complete"><code class="xref py py-meth docutils literal"><span class="pre">run_until_complete()</span></code></a>
에도 동일하게 적용됩니다.</p>
<p class="last">이 제약은 많은 상황에서 동기 코드내에서 비동기 코드를 호출할 수 없도록 만드는데, 그 반대의 경우는
항상 실행기(executor)를 사용할 수 있다는 점에서 비대칭적입니다. 파이썬의 비대칭적인 비동기 구현을
결함으로 보는 시각도 있습니다. 실제로 이런 비대칭성은 디스크립터와 같은 언어 기능에서도 문제를 일으킵니다.
하지만 이런 제약은 언어 자체에서 오는 것이 아니라 <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 의 구현에서 오는 것입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5.1으로 변경.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.run_until_complete">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">run_until_complete</code><span class="sig-paren">(</span><em>future</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.run_until_complete" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a> 가 완료 될 때까지 실행합니다.</p>
<p>인자가 <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">코루틴 객체</span></a> 면, <a class="reference internal" href="asyncio-task.html#asyncio.ensure_future" title="asyncio.ensure_future"><code class="xref py py-func docutils literal"><span class="pre">ensure_future()</span></code></a> 로 쌉니다.</p>
<p>퓨처의 결과를 반환하거나 퓨처의 예외를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.is_running">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">is_running</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.is_running" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프의 실행 상태를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.stop">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.stop" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프 실행을 중지합니다.</p>
<p><a class="reference internal" href="#asyncio.AbstractEventLoop.run_forever" title="asyncio.AbstractEventLoop.run_forever"><code class="xref py py-meth docutils literal"><span class="pre">run_forever()</span></code></a> 가 다음 적절한 기회에 종료하도록 합니다 (자세한 내용은 그 메서드를 보세요).</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5.1으로 변경.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.is_closed">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">is_closed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.is_closed" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프가 닫혔으면 <code class="docutils literal"><span class="pre">True</span></code> 를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.close">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.close" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프를 닫습니다. 루프가 실행중이어서는 안됩니다. 계류중인 콜백이 손실됩니다.</p>
<p>이것은 큐를 비우고 실행기를 종료하지만, 실행기가 완료할 때까지 기다리지 않습니다.</p>
<p>이것은 멱등적(itempotent)이고 되돌릴 수 없습니다. 이것 이후에 다른 메서드를 호출해서는 안됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">여기서 멱등적이란, 한번 호출하나 여러번 호출하나 같은 결과를 준다는 뜻입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.shutdown_asyncgens">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">shutdown_asyncgens</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.shutdown_asyncgens" title="정의 주소">¶</a></dt>
<dd><p>현재 열려있는 <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">비동기 제너레이터</span></a> 객체를 모두 <a class="reference internal" href="../reference/expressions.html#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal"><span class="pre">aclose()</span></code></a> 호출로 닫도록 스케쥴합니다. 이 메서드를 호출한 후에는, 새 비동기 생성기가 이터레이트 될 때마다 이벤트 루프에서 경고를 보냅니다. 스케쥴된 모든 비동기 제너레이터를 신뢰성있게 종료하는데 사용해야합니다. 예:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">shutdown_asyncgens</span><span class="p">())</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="calls">
<span id="asyncio-pass-keywords"></span><h2>19.5.1.2. 호출<a class="headerlink" href="#calls" title="제목 주소">¶</a></h2>
<p>대부분 <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 함수는 키워드를 받아들이지 않습니다. 여러분의 콜백에 키워드를 전달하려면, <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal"><span class="pre">functools.partial()</span></code></a> 을 사용하십시오. 예를 들어, <code class="docutils literal"><span class="pre">loop.call_soon(functools.partial(print,</span> <span class="pre">&quot;Hello&quot;,</span> <span class="pre">flush=True))</span></code> 는 <code class="docutils literal"><span class="pre">print(&quot;Hello&quot;,</span> <span class="pre">flush=True)</span></code> 를 호출합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal"><span class="pre">functools.partial()</span></code></a> 은 <code class="docutils literal"><span class="pre">lambda</span></code> 함수보다 낫습니다. <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 는 디버그 모드에서 매개 변수를 표시하기 위해 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal"><span class="pre">functools.partial()</span></code></a> 객체를 검사할 수 있는 반면, <code class="docutils literal"><span class="pre">lambda</span></code> 함수는 표현이 부족하기 때문입니다.</p>
</div>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.call_soon">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">call_soon</code><span class="sig-paren">(</span><em>callback</em>, <em>*args</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.call_soon" title="정의 주소">¶</a></dt>
<dd><p>콜백을 가능한 한 빨리 호출 할 수 있도록 배치합니다. 콜백은 <a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon" title="asyncio.AbstractEventLoop.call_soon"><code class="xref py py-meth docutils literal"><span class="pre">call_soon()</span></code></a> 이 반환되고, 제어가 이벤트 루프로 돌아 오면 호출됩니다.</p>
<p>이것은 <abbr title="first-in, first-out - 선입 선출">FIFO</abbr> 큐로 작동하며, 콜백은 등록 된 순서대로 호출됩니다. 각 콜백은 정확히 한 번 호출됩니다.</p>
<p>callback 이후의 모든 위치 인자는 호출될 때 콜백에 전달됩니다.</p>
<p>선택적인 키워드 전용 <em>context</em> 인자는 <em>callback</em> 을 실행할 사용자 정의 <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal"><span class="pre">contextvars.Context</span></code></a> 를 지정할 수 있게 합니다. <em>context</em> 가 제공되지 않을 때는 현재 컨텍스트가 사용됩니다.</p>
<p><a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Handle</span></code></a> 인스턴스가 반환되는데, 콜백을 취소하는 데 사용할 수 있습니다.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">functools.partial을 사용하여 키워드를 콜백에 전달하십시오</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>context</em> 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 <span class="target" id="index-9"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a> 을 보십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.call_soon_threadsafe">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">call_soon_threadsafe</code><span class="sig-paren">(</span><em>callback</em>, <em>*args</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.call_soon_threadsafe" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon" title="asyncio.AbstractEventLoop.call_soon"><code class="xref py py-meth docutils literal"><span class="pre">call_soon()</span></code></a> 과 같지만, 스레드 안전합니다.</p>
<p>설명서의 <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">동시성과 다중 스레딩</span></a> 절을 참고하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>context</em> 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 <span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a> 을 보십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="delayed-calls">
<span id="asyncio-delayed-calls"></span><h2>19.5.1.3. 지연된 호출<a class="headerlink" href="#delayed-calls" title="제목 주소">¶</a></h2>
<p>이벤트 루프에는 시간 제한 계산을 위한 자체 내부 시계가 있습니다. 사용되는 시계는 (플랫폼 특정) 이벤트 루프 구현에 따라 다릅니다; 이상적으로는 단조증가하는 시계입니다. 이것은 일반적으로 <a class="reference internal" href="time.html#time.time" title="time.time"><code class="xref py py-func docutils literal"><span class="pre">time.time()</span></code></a> 과 다른 시계입니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">제한 시간(상대적인 <em>delay</em> 나 절대적인 <em>when</em>)은 1일을 초과하지 않아야합니다.</p>
</div>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.call_later">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">call_later</code><span class="sig-paren">(</span><em>delay</em>, <em>callback</em>, <em>*args</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.call_later" title="정의 주소">¶</a></dt>
<dd><p>지정된 <em>delay</em> 초 (int 또는 float) 뒤에 <em>callback</em> 이 호출되도록 배치합니다.</p>
<p><a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal"><span class="pre">asyncio.TimerHandle</span></code></a> 의 인스턴스가 반환되든데, 콜백을 취소하는 데 사용할 수 있습니다.</p>
<p><em>callback</em> 은 <a class="reference internal" href="#asyncio.AbstractEventLoop.call_later" title="asyncio.AbstractEventLoop.call_later"><code class="xref py py-meth docutils literal"><span class="pre">call_later()</span></code></a> 호출 당 정확히 한번 호출됩니다. 두 콜백이 정확히 같은 시간에 스케줄되면, 어떤 것이 먼저 호출되는지는 정의되지 않습니다.</p>
<p>선택적 위치 <em>args</em> 는 호출 될 때 콜백에 전달됩니다. 콜백을 이름있는 인자로 호출하고 싶으면 클로저나 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal"><span class="pre">functools.partial()</span></code></a> 를 사용하십시오.</p>
<p>선택적인 키워드 전용 <em>context</em> 인자는 <em>callback</em> 을 실행할 사용자 정의 <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal"><span class="pre">contextvars.Context</span></code></a> 를 지정할 수 있게 합니다. <em>context</em> 가 제공되지 않을 때는 현재 컨텍스트가 사용됩니다.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">functools.partial을 사용하여 키워드를 콜백에 전달하십시오</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>context</em> 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 <span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a> 을 보십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.call_at">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">call_at</code><span class="sig-paren">(</span><em>when</em>, <em>callback</em>, <em>*args</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.call_at" title="정의 주소">¶</a></dt>
<dd><p>지정된 절대 타임스탬프 <em>when</em> (int 또는 float) 에 <em>callback</em> 이 호출되도록 배치합니다. <a class="reference internal" href="#asyncio.AbstractEventLoop.time" title="asyncio.AbstractEventLoop.time"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.time()</span></code></a> 와 같은 시간 참조를 사용하십시오.</p>
<p>이 메서드의 동작은 <a class="reference internal" href="#asyncio.AbstractEventLoop.call_later" title="asyncio.AbstractEventLoop.call_later"><code class="xref py py-meth docutils literal"><span class="pre">call_later()</span></code></a> 와 같습니다.</p>
<p><a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal"><span class="pre">asyncio.TimerHandle</span></code></a> 의 인스턴스가 반환되든데, 콜백을 취소하는 데 사용할 수 있습니다.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">functools.partial을 사용하여 키워드를 콜백에 전달하십시오</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>context</em> 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 <span class="target" id="index-12"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a> 을 보십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.time">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.time" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프의 내부 시계에 따라, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 값으로 현재 시간을 반환합니다.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="asyncio-task.html#asyncio.sleep" title="asyncio.sleep"><code class="xref py py-func docutils literal"><span class="pre">asyncio.sleep()</span></code></a> 함수.</p>
</div>
</div>
<div class="section" id="futures">
<h2>19.5.1.4. 퓨처<a class="headerlink" href="#futures" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.create_future">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">create_future</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.create_future" title="정의 주소">¶</a></dt>
<dd><p>루프에 연결된 <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Future</span></code></a> 객체를 만듭니다.</p>
<p>이벤트 루프 구현이 Future 클래스의 다른 구현(더 나은 성능이나 인스트루멘테이션)을 제공 할 수 있기 때문에, asyncio에서 퓨처를 만드는 데 선호되는 방법입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="tasks">
<h2>19.5.1.5. 태스크<a class="headerlink" href="#tasks" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.create_task">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">create_task</code><span class="sig-paren">(</span><em>coro</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.create_task" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">코루틴 객체</span></a> 의 실행을 스케쥴합니다: 퓨처로 쌉니다. <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> 객체를 반환합니다.</p>
<p>제삼자 이벤트 루프는 상호 운용성을 위해 자신만의 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> 의 서브 클래스를 사용할 수 있습니다. 이 경우, 결과 형은 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> 의 서브 클래스입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.set_task_factory">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">set_task_factory</code><span class="sig-paren">(</span><em>factory</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.set_task_factory" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.AbstractEventLoop.create_task" title="asyncio.AbstractEventLoop.create_task"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_task()</span></code></a> 에 의해 사용되는 태스크 팩토리를 설정합니다.</p>
<p><em>factory</em> 가 <code class="docutils literal"><span class="pre">None</span></code> 이면 기본 태스크 팩토리가 설정됩니다.</p>
<p><em>factory</em> 가 <em>콜러블</em> 이면, <code class="docutils literal"><span class="pre">(loop,</span> <span class="pre">coro)</span></code> 과 일치하는 서명을 가져야합니다. 여기서 <em>loop</em> 는 활성 이벤트 루프에 대한 참조가 되고, <em>coro</em> 는 코루틴 객체가됩니다. 콜러블은 <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Future</span></code></a> 호환 객체를 반환해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.get_task_factory">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">get_task_factory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.get_task_factory" title="정의 주소">¶</a></dt>
<dd><p>태스크 팩토리를 반환하거나, 기본값이 사용 중이면 <code class="docutils literal"><span class="pre">None</span></code> 을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.4에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="creating-connections">
<h2>19.5.1.6. 연결 만들기<a class="headerlink" href="#creating-connections" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.create_connection">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">create_connection</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>host=None</em>, <em>port=None</em>, <em>*</em>, <em>ssl=None</em>, <em>family=0</em>, <em>proto=0</em>, <em>flags=0</em>, <em>sock=None</em>, <em>local_addr=None</em>, <em>server_hostname=None</em>, <em>ssl_handshake_timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.create_connection" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>host</em> 와 <em>port</em> 로의 스트리밍 트랜스포트 연결을 만듭니다: <em>host</em> 에 따라 소켓 패밀리 <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal"><span class="pre">AF_INET</span></code></a> 또는 <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal"><span class="pre">AF_INET6</span></code></a> (또는 지정된 경우 <em>family</em>), 소켓 유형 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal"><span class="pre">SOCK_STREAM</span></code></a>. <em>protocol_factory</em> 는 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜</span></a> 인스턴스을 반환하는 콜러블이어야합니다.</p>
<p>이 메서드는 백그라운드에서 연결을 맺으려고 시도합니다. 성공하면, <code class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다.</p>
<p>하부 연산의 시간순 개요는 다음과 같습니다:</p>
<ol class="arabic simple">
<li>연결이 맺어지고, 이를 표현하기 위한 <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">트랜스포트(transport)</span></a> 가 만들어집니다.</li>
<li><em>protocol_factory</em> 가 인자없이 호출되고, <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜(protocol)</span></a> 인스턴스을 반환해야합니다.</li>
<li>프로토콜 인스턴스는 트랜스포트에 묶여있고, <code class="xref py py-meth docutils literal"><span class="pre">connection_made()</span></code> 메서드가 호출됩니다.</li>
<li>코루틴은 성공적으로 <code class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다.</li>
</ol>
<p>만들어진 트랜스포트는 구현 의존적인 양방향 스트림입니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><em>protocol_factory</em> 는 모든 종류의 콜러블일 수 있고, 꼭 클래스 일 필요는 없습니다. 예를 들어, 미리 만들어진 프로토콜 인스턴스를 사용하려면, <code class="docutils literal"><span class="pre">lambda:</span> <span class="pre">my_protocol</span></code> 을 전달하면 됩니다.</p>
</div>
<p>연결 생성 방법을 변경하는 옵션:</p>
<ul>
<li><p class="first"><em>ssl</em>: 주어지고 거짓이 아니면, SSL/TLS 트랜스포트가 만들어집니다 (기본적으로는 평범한 TCP 트랜스포트가 만들어집니다). <em>ssl</em> 이 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">ssl.SSLContext</span></code></a> 객체면, 트랜스포트를 만들 때 이 컨텍스트가 사용됩니다; <em>ssl</em> 이 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> 면, 지정되지 않은 기본 설정의 컨텍스트가 사용됩니다.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">SSL/TLS 보안 고려 사항</span></a></p>
</div>
</li>
<li><p class="first"><em>server_hostname</em> 은 <em>ssl</em> 과 함께 사용하기위한 것이며 대상 서버의 인증서가 일치 될 호스트 이름을 설정하거나 바꿉니다. 기본적으로 <em>host</em> 인자의 값이 사용됩니다. <em>host</em> 가 비어 있으면, 기본값이 없고 <em>server_hostname</em> 값을 전달해야합니다. <em>server_hostname</em> 이 빈 문자열이면, 호스트 이름 일치가 비활성화됩니다 (이것은 심각한 보안 위험으로, 중간자 공격을 허용하게 됩니다).</p>
</li>
<li><p class="first"><em>family</em>, <em>proto</em>, <em>flags</em> 는 <em>host</em> 결정을 위해 getaddrinfo() 에 전달할 선택적 주소 패밀리, 프로토콜, 플래그입니다. 주어지면, 이것들은 모두 해당하는 <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> 모듈 상수에 대응하는 정수여야 합니다.</p>
</li>
<li><p class="first"><em>sock</em> 이 주어지면, 트랜스포트가 사용할, 기존의 이미 연결된 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> 객체여야 합니다. <em>sock</em> 이 주어지면, <em>host</em>, <em>port</em>, <em>family</em>, <em>proto</em>, <em>flags</em>, <em>local_addr</em> 를 지정해서는 안됩니다.</p>
</li>
<li><p class="first"><em>local_addr</em> 이 주어지면, 소켓을 로컬에 바인드하는데 사용되는 <code class="docutils literal"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> 튜플이어야합니다. <em>local_host</em> 와 <em>local_port</em> 는 <em>host</em> 및 <em>port</em> 와 유사하게 getaddrinfo() 를 사용하여 조회됩니다.</p>
</li>
<li><p class="first"><em>ssl_handshake_timeout</em> 은 (SSL 연결의 경우) 연결을 중단하기 전에 SSL 핸드 셰이크가 완료 될 때까지 대기하는 시간(초)입니다. <code class="docutils literal"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal"><span class="pre">60.0</span></code> 초가 사용됩니다.</p>
</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>윈도우에서 <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a> 을 사용할 때, 이제 SSL/TLS가 지원됩니다.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal"><span class="pre">open_connection()</span></code></a> 함수는 프로토콜 대신 (<a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a>) 쌍을 얻는 데 사용할 수 있습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.create_datagram_endpoint">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">create_datagram_endpoint</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>local_addr=None</em>, <em>remote_addr=None</em>, <em>*</em>, <em>family=0</em>, <em>proto=0</em>, <em>flags=0</em>, <em>reuse_address=None</em>, <em>reuse_port=None</em>, <em>allow_broadcast=None</em>, <em>sock=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.create_datagram_endpoint" title="정의 주소">¶</a></dt>
<dd><p>데이터 그램 연결을 만듭니다: <em>host</em> (또는 주어진 경우 <em>family</em>) 에 따라 소켓 패밀리 <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal"><span class="pre">AF_INET</span></code></a>, <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal"><span class="pre">AF_INET6</span></code></a> 또는 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal"><span class="pre">AF_UNIX</span></code></a>, 소켓 유형 <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-data docutils literal"><span class="pre">SOCK_DGRAM</span></code></a>. <em>protocol_factory</em> 는 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜</span></a> 인스턴스을 반환하는 콜러블이어야합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">스트림 소켓은 유닉스 도메인 소켓(<a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal"><span class="pre">AF_UNIX</span></code></a>)이 별도의 메서드
<a class="reference internal" href="#asyncio.AbstractEventLoop.create_unix_connection" title="asyncio.AbstractEventLoop.create_unix_connection"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_unix_connection()</span></code></a> 로 분리되어 있으나,
데이터 그램 소켓의 경우는 이 메서드에서 모두 다룹니다. 하지만 소켓 유형
<a class="reference internal" href="socket.html#socket.SOCK_SEQPACKET" title="socket.SOCK_SEQPACKET"><code class="xref py py-data docutils literal"><span class="pre">SOCK_SEQPACKET</span></code></a> 을 지원하지 않습니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><em>host</em> 라는 인자는 없습니다. <em>host</em> 는 <em>local_addr</em> 이나 <em>remote_addr</em> 에 포함된
<em>local_host</em> 와 <em>remote_host</em> 를 뜻합니다.</p>
</div>
<p>이 메서드는 백그라운드에서 연결을 맺으려고 시도합니다. 성공하면, <code class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">데이터 그램 소켓에서, 연결한다는 것은 데이터 그램을 전송할 대상을 <em>remote_addr</em> 로 고정한다는 의미입니다.
따라서 <em>remote_addr</em> 이 제공되지 않으면 연결되지 않은 데이터 그램 소켓이 만들어지는데, 이 경우도
성공적인 것으로 판단합니다.</p>
</div>
<p>연결 생성 방법을 변경하는 옵션:</p>
<ul>
<li><p class="first"><em>local_addr</em> 이 주어지면, 소켓을 로컬에 바인드하는 데 사용되는 <code class="docutils literal"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> 튜플입니다. <em>local_host</em> 와 <em>local_port</em> 는 <a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code class="xref py py-meth docutils literal"><span class="pre">getaddrinfo()</span></code></a> 를 사용하여 조회됩니다.</p>
</li>
<li><p class="first"><em>remote_addr</em> 이 주어지면, 소켓을 원격 주소에 연결하는 데 사용되는 <code class="docutils literal"><span class="pre">(remote_host,</span> <span class="pre">remote_port)</span></code> 튜플입니다. <em>remote_host</em> 와 <em>remote_port</em> 는 <a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code class="xref py py-meth docutils literal"><span class="pre">getaddrinfo()</span></code></a> 를 사용하여 조회됩니다.</p>
</li>
<li><p class="first"><em>family</em>, <em>proto</em>, <em>flags</em> 는 <em>host</em> 결정을 위해 <a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code class="xref py py-meth docutils literal"><span class="pre">getaddrinfo()</span></code></a> 에 전달할 선택적 주소 패밀리, 프로토콜, 플래그입니다. 주어지면, 이것들은 모두 해당하는 <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> 모듈 상수에 대응하는 정수여야 합니다.</p>
</li>
<li><p class="first"><em>reuse_address</em> 는, 일반적인 시간 제한이 만료 될 때까지 기다리지 않고, TIME_WAIT 상태의 로컬 소켓을 재사용하도록 커널에게 알려줍니다. 지정하지 않으면 유닉스에서 자동으로 <code class="docutils literal"><span class="pre">True</span></code> 로 설정됩니다.</p>
</li>
<li><p class="first"><em>reuse_port</em> 는 모두 만들 때 이 플래그를 설정하는 한, 이 말단이 다른 기존 말단이 바인드된 것과 같은 포트에 바인드되도록 허용하도록 커널에게 알려줍니다. 이 옵션은 윈도우나 일부 유닉스에서는 지원되지 않습니다. <code class="xref py py-data docutils literal"><span class="pre">SO_REUSEPORT</span></code> 상수가 정의되어 있지 않으면, 이 기능은 지원되지 않는 것입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">지원되지 않는 경우 이 옵션을 지정하면 예외를 일으킵니다.</p>
</div>
</li>
<li><p class="first"><em>allow_broadcast</em> 는 이 말단이 브로드 캐스트 주소로 메시지를 보낼 수 있도록 커널에 알립니다.</p>
</li>
<li><p class="first"><em>sock</em> 은 트랜스포트가 사용할 소켓 객체로, 기존의 이미 연결된 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> 객체를 사용하기 위해 선택적으로 지정할 수 있습니다. 지정되면 <em>local_addr</em> 과 <em>remote_addr</em> 를 생략해야합니다 (반드시 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> 이어야 합니다).</p>
</li>
</ul>
<p>윈도우에서 <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a> 를 사용할 때, 이 메서드는 지원되지 않습니다.</p>
<p><a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-client-protocol"><span class="std std-ref">UDP 에코 클라이언트 프로토콜</span></a> 과 <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-server-protocol"><span class="std std-ref">UDP 에코 서버 프로토콜</span></a> 예제를 참고하세요.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4.4으로 변경: </span><em>family</em>, <em>proto</em>, <em>flags</em>, <em>reuse_address</em>, <em>reuse_port</em>, <em>allow_broadcast</em>, <em>sock</em> 매개 변수가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.create_unix_connection">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">create_unix_connection</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>path=None</em>, <em>*</em>, <em>ssl=None</em>, <em>sock=None</em>, <em>server_hostname=None</em>, <em>ssl_handshake_timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.create_unix_connection" title="정의 주소">¶</a></dt>
<dd><p>유닉스 연결을 만듭니다: 소켓 패밀리 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal"><span class="pre">AF_UNIX</span></code></a>, 소켓 유형 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal"><span class="pre">SOCK_STREAM</span></code></a>. 같은 기계의 프로세스 간에 효율적으로 통신하기 위해 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal"><span class="pre">AF_UNIX</span></code></a> 소켓 패밀리가 사용됩니다.</p>
<p>이 메서드는 백그라운드에서 연결을 맺으려고 시도합니다. 성공하면, <code class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다.</p>
<p><em>path</em> 는 유닉스 도메인 소켓의 이름이며, <em>sock</em> 매개 변수가 지정되지 않으면 필수입니다. 추상 유닉스 소켓, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">Path</span></code></a> 경로가 지원됩니다.</p>
<p>매개 변수는 <a class="reference internal" href="#asyncio.AbstractEventLoop.create_connection" title="asyncio.AbstractEventLoop.create_connection"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_connection()</span></code></a> 메서드를 참조하십시오.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>path</em> 매개 변수는 이제 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a> 가 될 수 있습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="creating-listening-connections">
<h2>19.5.1.7. 리스닝 연결 만들기<a class="headerlink" href="#creating-listening-connections" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.create_server">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">create_server</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>host=None</em>, <em>port=None</em>, <em>*</em>, <em>family=socket.AF_UNSPEC</em>, <em>flags=socket.AI_PASSIVE</em>, <em>sock=None</em>, <em>backlog=100</em>, <em>ssl=None</em>, <em>reuse_address=None</em>, <em>reuse_port=None</em>, <em>ssl_handshake_timeout=None</em>, <em>start_serving=True</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.create_server" title="정의 주소">¶</a></dt>
<dd><p><em>host</em> 와 <em>port</em> 에 바인드된 TCP 서버(소켓 유형 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal"><span class="pre">SOCK_STREAM</span></code></a>)를 만듭니다.</p>
<p><a class="reference internal" href="#asyncio.Server" title="asyncio.Server"><code class="xref py py-class docutils literal"><span class="pre">Server</span></code></a> 객체를 반환합니다. <a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><code class="xref py py-attr docutils literal"><span class="pre">sockets</span></code></a> 어트리뷰트에 생성된 소켓이 저장됩니다. 서버를 종료하려면 <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal"><span class="pre">Server.close()</span></code></a> 메서드를 사용하십시오: 리스닝 소켓을 닫습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><code class="xref py py-attr docutils literal"><span class="pre">sockets</span></code></a> 어트리뷰트는 리스트입니다. 한 서버는 여러개의 소켓을 동시에
리스닝할 수 있습니다.</p>
</div>
<p>매개 변수:</p>
<ul>
<li><p class="first"><em>host</em> 매개 변수는 문자열일 수 있습니다. 이 경우 TCP 서버는 <em>host</em> 와 <em>port</em> 에 바인드됩니다. <em>host</em> 매개 변수는 문자열의 시퀀스일 수도 있으며, 이 경우 TCP 서버는 시퀀스의 모든 호스트에 바이드됩니다. <em>host</em> 가 빈 문자열이거나 <code class="docutils literal"><span class="pre">None</span></code> 이면, 모든 인터페이스가 사용되는 것으로 가정하고, 여러 소켓의 리스트가 반환됩니다 (대체로 IPv4 하나와 IPv6 하나).</p>
</li>
<li><p class="first"><em>family</em> 는 <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal"><span class="pre">socket.AF_INET</span></code></a> 또는 <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal"><span class="pre">AF_INET6</span></code></a> 중 하나로 설정되어, 소켓이 IPv4 또는 IPv6을 사용하게 할 수 있습니다. 설정되지 않으면 host 에 의해 결정됩니다(기본값 <code class="xref py py-data docutils literal"><span class="pre">socket.AF_UNSPEC</span></code>).</p>
</li>
<li><p class="first"><em>flags</em> 은 <a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code class="xref py py-meth docutils literal"><span class="pre">getaddrinfo()</span></code></a> 를 위한 비트 마스크입니다.</p>
</li>
<li><p class="first"><em>sock</em> 은 기존 소켓 객체를 사용하기 위해 선택적으로 지정할 수 있습니다. 지정되면, <em>host</em> 및 <em>port</em> 를 생략해야합니다 (반드시 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> 이어야 합니다).</p>
</li>
<li><p class="first"><em>backlog</em> 는 <a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal"><span class="pre">listen()</span></code></a> 으로 전달되는 최대 대기 연결 연결 수 입니다 (기본값은 100).</p>
</li>
<li><p class="first"><em>ssl</em> 을 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> 로 설정하면, 들어오는 연결에 SSL을 사용합니다.</p>
</li>
<li><p class="first"><em>reuse_address</em> 는, 일반적인 시간 제한이 만료 될 때까지 기다리지 않고, TIME_WAIT 상태의 로컬 소켓을 재사용하도록 커널에게 알려줍니다. 지정하지 않으면 유닉스에서 자동으로 <code class="docutils literal"><span class="pre">True</span></code> 로 설정됩니다.</p>
</li>
<li><p class="first"><em>reuse_port</em> 는 모두 만들 때 이 플래그를 설정하는 한, 이 말단이 다른 기존 말단이 바인드된 것과 같은 포트에 바인드되도록 허용하도록 커널에게 알려줍니다. 이 옵션은 윕도우에서 지원되지 않습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">지원되지 않는 경우 이 옵션을 지정하면 예외를 일으킵니다.</p>
</div>
</li>
<li><p class="first"><em>ssl_handshake_timeout</em> 은 (SSL 서버의 경우) 연결을 중단하기 전에 SSL 핸드 셰이크가 완료 될 때까지 대기하는 시간(초)입니다. <code class="docutils literal"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal"><span class="pre">60.0</span></code> 초가 사용됩니다.</p>
</li>
<li><p class="first"><em>start_serving</em> 을 <code class="docutils literal"><span class="pre">True</span></code> (기본값) 로 설정하면, 생성된 서버가 즉시 연결을 받아들입니다. <code class="docutils literal"><span class="pre">False</span></code> 로 설정되면, 사용자는 서버가 연결을 받기 시작하도록 <a class="reference internal" href="#asyncio.Server.start_serving" title="asyncio.Server.start_serving"><code class="xref py py-meth docutils literal"><span class="pre">Server.start_serving()</span></code></a> 이나 <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal"><span class="pre">Server.serve_forever()</span></code></a> 를 await 해야합니다.</p>
</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 과 <em>start_serving</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>윈도우에서 <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a> 을 사용할 때, 이제 SSL/TLS가 지원됩니다.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last">함수 <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal"><span class="pre">start_server()</span></code></a> 는 (<a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a>) 쌍을 만들고, 이 쌍으로 콜백 함수를 호출합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5.1으로 변경: </span><em>host</em> 매개 변수는 이제 문자열의 시퀀스가 될 수 있습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.create_unix_server">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">create_unix_server</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>path=None</em>, <em>*</em>, <em>sock=None</em>, <em>backlog=100</em>, <em>ssl=None</em>, <em>ssl_handshake_timeout=None</em>, <em>start_serving=True</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.create_unix_server" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_server()</span></code></a> 와 유사하지만, 소켓 패밀리 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal"><span class="pre">AF_UNIX</span></code></a> 전용입니다.</p>
<p><em>path</em> 는 유닉스 도메인 소켓의 이름이며, <em>sock</em> 매개 변수가 지정되지 않으면 필수입니다. 추상 유닉스 소켓, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">Path</span></code></a> 경로가 지원됩니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 과 <em>start_serving</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>path</em> 매개 변수는 이제 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">Path</span></code></a> 객체일 수 있습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.connect_accepted_socket">
<em class="property">coroutine </em><code class="descclassname">BaseEventLoop.</code><code class="descname">connect_accepted_socket</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>sock</em>, <em>*</em>, <em>ssl=None</em>, <em>ssl_handshake_timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseEventLoop.connect_accepted_socket" title="정의 주소">¶</a></dt>
<dd><p>받아들인 연결을 처리합니다.</p>
<p>이것은 asyncio 밖에서 연결을 받아들이지만 그 연결을 처리하는데 asyncio 를 사용하는 서버에서 사용됩니다.</p>
<p>매개 변수:</p>
<ul class="simple">
<li><em>sock</em> 은 <code class="docutils literal"><span class="pre">accept</span></code> 이 반환한 기존 소켓 객체입니다.</li>
<li><em>ssl</em> 을 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> 로 설정하면, 들어오는 연결에 SSL을 사용합니다.</li>
<li><em>ssl_handshake_timeout</em> 은 (SSL 연결의 경우) 연결을 중단하기 전에 SSL 핸드 셰이크가 완료 될 때까지 대기하는 시간(초)입니다. <code class="docutils literal"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal"><span class="pre">60.0</span></code> 초가 사용됩니다.</li>
</ul>
<p>완료되면 <code class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 매개 변수.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5.3에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="file-transferring">
<h2>19.5.1.8. 파일 전송<a class="headerlink" href="#file-transferring" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.sendfile">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">sendfile</code><span class="sig-paren">(</span><em>transport</em>, <em>file</em>, <em>offset=0</em>, <em>count=None</em>, <em>*</em>, <em>fallback=True</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.sendfile" title="정의 주소">¶</a></dt>
<dd><p><em>file</em> 을 <em>transport</em> 로 보내고, 전송된 총 바이트 수를 반환합니다.</p>
<p>이 메서드는 가능한 경우 고성능 <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-meth docutils literal"><span class="pre">os.sendfile()</span></code></a> 을 사용합니다.</p>
<p><em>file</em> 는 바이너리 모드로 열린 일반 파일 객체여야 합니다.</p>
<p><em>offset</em> 은 파일 읽기 시작할 위치를 알려줍니다. <em>count</em> 를 제공하면, EOF에 도달 할 때까지 파일을 보내는 대신, 전송할 총 바이트 수를 지정합니다. 반환할 때나 오류가 발생했을 때 파일의 위치가 갱신됩니다. 이 경우 <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal"><span class="pre">file.tell()</span></code></a> 는 전송된 바이트 수를 계산하는 데 사용될 수 있습니다.</p>
<p><em>fallback</em> 을 <code class="docutils literal"><span class="pre">True</span></code> 로 설정하면, 플랫폼이 sendfile 시스템 호출을 지원하지 않을 때 (가령 유닉스에서 SSL 소켓을 사용하거나 윈도우인 경우), asyncio 가 파일을 수동으로 읽고 보내도록합니다.</p>
<p>시스템이 <em>sendfile</em> 시스템 호출을 지원하지 않고 <em>fallback</em> 이 <code class="docutils literal"><span class="pre">False</span></code> 면 <a class="reference internal" href="#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal"><span class="pre">SendfileNotAvailableError</span></code></a> 를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="tls-upgrade">
<h2>19.5.1.9. TLS 업그레이드<a class="headerlink" href="#tls-upgrade" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.start_tls">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">start_tls</code><span class="sig-paren">(</span><em>transport</em>, <em>protocol</em>, <em>sslcontext</em>, <em>*</em>, <em>server_side=False</em>, <em>server_hostname=None</em>, <em>ssl_handshake_timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.start_tls" title="정의 주소">¶</a></dt>
<dd><p>기존 연결을 TLS로 업그레이드합니다.</p>
<p><em>protocol</em> 이 <em>await</em> 의 직후에 사용해야하는 새로운 트랜스포트 인스턴스를 반환합니다. <em>start_tls</em> 메서드에 전달 된 <em>transport</em> 인스턴스는 절대로 다시 사용해서는 안됩니다.</p>
<p>매개 변수:</p>
<ul class="simple">
<li><a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code class="xref py py-meth docutils literal"><span class="pre">create_server()</span></code></a> 와 <a class="reference internal" href="#asyncio.AbstractEventLoop.create_connection" title="asyncio.AbstractEventLoop.create_connection"><code class="xref py py-meth docutils literal"><span class="pre">create_connection()</span></code></a> 같은 메서드가 반환하는 <em>transport</em> 와 <em>protocol</em> 인스턴스.</li>
<li><em>sslcontext</em>: 구성된 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> 의 인스턴스.</li>
<li>(<a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code class="xref py py-meth docutils literal"><span class="pre">create_server()</span></code></a> 에 의해 생성 된 것과 같은) 서버 측 연결이 업그레이드될 때 <em>server_side</em> 에 <code class="docutils literal"><span class="pre">True</span></code> 를 전달합니다.</li>
<li><em>server_hostname</em>: 대상 서버의 인증서가 일치 될 호스트 이름을 설정하거나 대체합니다.</li>
<li><em>ssl_handshake_timeout</em> 은 (SSL 연결의 경우) 연결을 중단하기 전에 SSL 핸드 셰이크가 완료 될 때까지 대기하는 시간(초)입니다. <code class="docutils literal"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal"><span class="pre">60.0</span></code> 초가 사용됩니다.</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="watch-file-descriptors">
<h2>19.5.1.10. Watch file descriptors<a class="headerlink" href="#watch-file-descriptors" title="제목 주소">¶</a></h2>
<p>On Windows with <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a>, only socket handles are supported
(ex: pipe file descriptors are not supported).</p>
<p>On Windows with <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a>, these methods are not supported.</p>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.add_reader">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">add_reader</code><span class="sig-paren">(</span><em>fd</em>, <em>callback</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.add_reader" title="정의 주소">¶</a></dt>
<dd><p>Start watching the file descriptor for read availability and then call the
<em>callback</em> with specified arguments.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">functools.partial을 사용하여 키워드를 콜백에 전달하십시오</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.remove_reader">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">remove_reader</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.remove_reader" title="정의 주소">¶</a></dt>
<dd><p>Stop watching the file descriptor for read availability.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.add_writer">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">add_writer</code><span class="sig-paren">(</span><em>fd</em>, <em>callback</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.add_writer" title="정의 주소">¶</a></dt>
<dd><p>Start watching the file descriptor for write availability and then call the
<em>callback</em> with specified arguments.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">functools.partial을 사용하여 키워드를 콜백에 전달하십시오</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.remove_writer">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">remove_writer</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.remove_writer" title="정의 주소">¶</a></dt>
<dd><p>Stop watching the file descriptor for write availability.</p>
</dd></dl>

<p>The <a class="reference internal" href="#asyncio-watch-read-event"><span class="std std-ref">watch a file descriptor for read events</span></a>
example uses the low-level <a class="reference internal" href="#asyncio.AbstractEventLoop.add_reader" title="asyncio.AbstractEventLoop.add_reader"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.add_reader()</span></code></a> method to register
the file descriptor of a socket.</p>
</div>
<div class="section" id="low-level-socket-operations">
<h2>19.5.1.11. Low-level socket operations<a class="headerlink" href="#low-level-socket-operations" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.sock_recv">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">sock_recv</code><span class="sig-paren">(</span><em>sock</em>, <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.sock_recv" title="정의 주소">¶</a></dt>
<dd><p>Receive data from the socket.  Modeled after blocking
<a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.recv()</span></code></a> method.</p>
<p>The return value is a bytes object
representing the data received.  The maximum amount of data to be received
at once is specified by <em>nbytes</em>.</p>
<p>With <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a> event loop, the socket <em>sock</em> must be
non-blocking.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>Even though the method was always documented as a coroutine
method, before Python 3.7 it returned a <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a>.
Since Python 3.7, this is an <code class="docutils literal"><span class="pre">async</span> <span class="pre">def</span></code> method.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.sock_recv_into">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">sock_recv_into</code><span class="sig-paren">(</span><em>sock</em>, <em>buf</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.sock_recv_into" title="정의 주소">¶</a></dt>
<dd><p>Receive data from the socket.  Modeled after blocking
<a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.recv_into()</span></code></a> method.</p>
<p>The received data is written into <em>buf</em> (a writable buffer).
The return value is the number of bytes written.</p>
<p>With <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a> event loop, the socket <em>sock</em> must be
non-blocking.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.sock_sendall">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">sock_sendall</code><span class="sig-paren">(</span><em>sock</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.sock_sendall" title="정의 주소">¶</a></dt>
<dd><p>Send data to the socket.  Modeled after blocking
<a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.sendall()</span></code></a> method.</p>
<p>The socket must be connected to a remote socket.
This method continues to send data from <em>data</em> until either all data has
been sent or an error occurs.  <code class="docutils literal"><span class="pre">None</span></code> is returned on success.  On error,
an exception is raised, and there is no way to determine how much data, if
any, was successfully processed by the receiving end of the connection.</p>
<p>With <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a> event loop, the socket <em>sock</em> must be
non-blocking.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>Even though the method was always documented as a coroutine
method, before Python 3.7 it returned an <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a>.
Since Python 3.7, this is an <code class="docutils literal"><span class="pre">async</span> <span class="pre">def</span></code> method.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.sock_connect">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">sock_connect</code><span class="sig-paren">(</span><em>sock</em>, <em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.sock_connect" title="정의 주소">¶</a></dt>
<dd><p>Connect to a remote socket at <em>address</em>.  Modeled after
blocking <a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.connect()</span></code></a> method.</p>
<p>With <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a> event loop, the socket <em>sock</em> must be
non-blocking.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5.2으로 변경: </span><code class="docutils literal"><span class="pre">address</span></code> no longer needs to be resolved.  <code class="docutils literal"><span class="pre">sock_connect</span></code>
will try to check if the <em>address</em> is already resolved by calling
<a class="reference internal" href="socket.html#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal"><span class="pre">socket.inet_pton()</span></code></a>.  If not,
<a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.getaddrinfo()</span></code></a> will be used to resolve the
<em>address</em>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="#asyncio.AbstractEventLoop.create_connection" title="asyncio.AbstractEventLoop.create_connection"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_connection()</span></code></a>
and  <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal"><span class="pre">asyncio.open_connection()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.sock_accept">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">sock_accept</code><span class="sig-paren">(</span><em>sock</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.sock_accept" title="정의 주소">¶</a></dt>
<dd><p>Accept a connection.  Modeled after blocking
<a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.accept()</span></code></a>.</p>
<p>The socket must be bound to an address and listening
for connections. The return value is a pair <code class="docutils literal"><span class="pre">(conn,</span> <span class="pre">address)</span></code> where <em>conn</em>
is a <em>new</em> socket object usable to send and receive data on the connection,
and <em>address</em> is the address bound to the socket on the other end of the
connection.</p>
<p>The socket <em>sock</em> must be non-blocking.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>Even though the method was always documented as a coroutine
method, before Python 3.7 it returned a <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a>.
Since Python 3.7, this is an <code class="docutils literal"><span class="pre">async</span> <span class="pre">def</span></code> method.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_server()</span></code></a> and <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal"><span class="pre">start_server()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.sock_sendfile">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">sock_sendfile</code><span class="sig-paren">(</span><em>sock</em>, <em>file</em>, <em>offset=0</em>, <em>count=None</em>, <em>*</em>, <em>fallback=True</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.sock_sendfile" title="정의 주소">¶</a></dt>
<dd><p>Send a file using high-performance <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal"><span class="pre">os.sendfile</span></code></a> if possible
and return the total number of bytes which were sent.</p>
<p>Asynchronous version of <a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.sendfile()</span></code></a>.</p>
<p><em>sock</em> must be non-blocking <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket</span></code></a> of
<a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">socket.SOCK_STREAM</span></code></a> type.</p>
<p><em>file</em> 는 바이너리 모드로 열린 일반 파일 객체여야 합니다.</p>
<p><em>offset</em> 은 파일 읽기 시작할 위치를 알려줍니다. <em>count</em> 를 제공하면, EOF에 도달 할 때까지 파일을 보내는 대신, 전송할 총 바이트 수를 지정합니다. 반환할 때나 오류가 발생했을 때 파일의 위치가 갱신됩니다. 이 경우 <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal"><span class="pre">file.tell()</span></code></a> 는 전송된 바이트 수를 계산하는 데 사용될 수 있습니다.</p>
<p><em>fallback</em> 을 <code class="docutils literal"><span class="pre">True</span></code> 로 설정하면, 플랫폼이 sendfile 시스템 호출을 지원하지 않을 때 (가령 유닉스에서 SSL 소켓을 사용하거나 윈도우인 경우), asyncio 가 파일을 수동으로 읽고 보내도록합니다.</p>
<p>시스템이 <em>sendfile</em> 시스템 호출을 지원하지 않고 <em>fallback</em> 이 <code class="docutils literal"><span class="pre">False</span></code> 면 <a class="reference internal" href="#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal"><span class="pre">SendfileNotAvailableError</span></code></a> 를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="resolve-host-name">
<h2>19.5.1.12. Resolve host name<a class="headerlink" href="#resolve-host-name" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.getaddrinfo">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">getaddrinfo</code><span class="sig-paren">(</span><em>host</em>, <em>port</em>, <em>*</em>, <em>family=0</em>, <em>type=0</em>, <em>proto=0</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.getaddrinfo" title="정의 주소">¶</a></dt>
<dd><p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">coroutine</span></a>, similar to
<a class="reference internal" href="socket.html#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-meth docutils literal"><span class="pre">socket.getaddrinfo()</span></code></a> function but non-blocking.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.getnameinfo">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">getnameinfo</code><span class="sig-paren">(</span><em>sockaddr</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.getnameinfo" title="정의 주소">¶</a></dt>
<dd><p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">coroutine</span></a>, similar to
<a class="reference internal" href="socket.html#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-meth docutils literal"><span class="pre">socket.getnameinfo()</span></code></a> function but non-blocking.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>Both <em>getaddrinfo</em> and <em>getnameinfo</em> methods were always documented
to return a coroutine, but prior to Python 3.7 they were, in fact,
returning <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Future</span></code></a> objects.  Starting with Python 3.7
both methods are coroutines.</p>
</div>
</div>
<div class="section" id="connect-pipes">
<h2>19.5.1.13. Connect pipes<a class="headerlink" href="#connect-pipes" title="제목 주소">¶</a></h2>
<p>On Windows with <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a>, these methods are not supported.
Use <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a> to support pipes on Windows.</p>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.connect_read_pipe">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">connect_read_pipe</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.connect_read_pipe" title="정의 주소">¶</a></dt>
<dd><p>Register read pipe in eventloop.</p>
<p><em>protocol_factory</em> should instantiate object with <a class="reference internal" href="asyncio-protocol.html#asyncio.Protocol" title="asyncio.Protocol"><code class="xref py py-class docutils literal"><span class="pre">Protocol</span></code></a>
interface.  <em>pipe</em> is a <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file-like object</span></a>.
Return pair <code class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, where <em>transport</em> supports the
<a class="reference internal" href="asyncio-protocol.html#asyncio.ReadTransport" title="asyncio.ReadTransport"><code class="xref py py-class docutils literal"><span class="pre">ReadTransport</span></code></a> interface.</p>
<p>With <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a> event loop, the <em>pipe</em> is set to
non-blocking mode.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.connect_write_pipe">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">connect_write_pipe</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.connect_write_pipe" title="정의 주소">¶</a></dt>
<dd><p>Register write pipe in eventloop.</p>
<p><em>protocol_factory</em> should instantiate object with <code class="xref py py-class docutils literal"><span class="pre">BaseProtocol</span></code>
interface. <em>pipe</em> is <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file-like object</span></a>.
Return pair <code class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, where <em>transport</em> supports
<a class="reference internal" href="asyncio-protocol.html#asyncio.WriteTransport" title="asyncio.WriteTransport"><code class="xref py py-class docutils literal"><span class="pre">WriteTransport</span></code></a> interface.</p>
<p>With <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a> event loop, the <em>pipe</em> is set to
non-blocking mode.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last">The <a class="reference internal" href="asyncio-subprocess.html#asyncio.AbstractEventLoop.subprocess_exec" title="asyncio.AbstractEventLoop.subprocess_exec"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.subprocess_exec()</span></code></a> and
<a class="reference internal" href="asyncio-subprocess.html#asyncio.AbstractEventLoop.subprocess_shell" title="asyncio.AbstractEventLoop.subprocess_shell"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.subprocess_shell()</span></code></a> methods.</p>
</div>
</div>
<div class="section" id="unix-signals">
<h2>19.5.1.14. UNIX signals<a class="headerlink" href="#unix-signals" title="제목 주소">¶</a></h2>
<p>Availability: UNIX only.</p>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.add_signal_handler">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">add_signal_handler</code><span class="sig-paren">(</span><em>signum</em>, <em>callback</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.add_signal_handler" title="정의 주소">¶</a></dt>
<dd><p>Add a handler for a signal.</p>
<p>Raise <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> if the signal number is invalid or uncatchable.
Raise <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> if there is a problem setting up the handler.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">functools.partial을 사용하여 키워드를 콜백에 전달하십시오</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.remove_signal_handler">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">remove_signal_handler</code><span class="sig-paren">(</span><em>sig</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.remove_signal_handler" title="정의 주소">¶</a></dt>
<dd><p>Remove a handler for a signal.</p>
<p>Return <code class="docutils literal"><span class="pre">True</span></code> if a signal handler was removed, <code class="docutils literal"><span class="pre">False</span></code> if not.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last">The <a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal"><span class="pre">signal</span></code></a> module.</p>
</div>
</div>
<div class="section" id="executor">
<h2>19.5.1.15. Executor<a class="headerlink" href="#executor" title="제목 주소">¶</a></h2>
<p>Call a function in an <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Executor" title="concurrent.futures.Executor"><code class="xref py py-class docutils literal"><span class="pre">Executor</span></code></a> (pool of threads or
pool of processes). By default, an event loop uses a thread pool executor
(<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal"><span class="pre">ThreadPoolExecutor</span></code></a>).</p>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.run_in_executor">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">run_in_executor</code><span class="sig-paren">(</span><em>executor</em>, <em>func</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.run_in_executor" title="정의 주소">¶</a></dt>
<dd><p>Arrange for a <em>func</em> to be called in the specified executor.</p>
<p>The <em>executor</em> argument should be an <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Executor" title="concurrent.futures.Executor"><code class="xref py py-class docutils literal"><span class="pre">Executor</span></code></a>
instance. The default executor is used if <em>executor</em> is <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">Use functools.partial to pass keywords to the *func*</span></a>.</p>
<p>This method returns a <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Future</span></code></a> object.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5.3으로 변경: </span><code class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.run_in_executor()</span></code> no longer configures the
<code class="docutils literal"><span class="pre">max_workers</span></code> of the thread pool executor it creates, instead
leaving it up to the thread pool executor
(<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal"><span class="pre">ThreadPoolExecutor</span></code></a>) to set the
default.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.set_default_executor">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">set_default_executor</code><span class="sig-paren">(</span><em>executor</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.set_default_executor" title="정의 주소">¶</a></dt>
<dd><p>Set the default executor used by <a class="reference internal" href="#asyncio.AbstractEventLoop.run_in_executor" title="asyncio.AbstractEventLoop.run_in_executor"><code class="xref py py-meth docutils literal"><span class="pre">run_in_executor()</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="error-handling-api">
<h2>19.5.1.16. Error Handling API<a class="headerlink" href="#error-handling-api" title="제목 주소">¶</a></h2>
<p>Allows customizing how exceptions are handled in the event loop.</p>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.set_exception_handler">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">set_exception_handler</code><span class="sig-paren">(</span><em>handler</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.set_exception_handler" title="정의 주소">¶</a></dt>
<dd><p>Set <em>handler</em> as the new event loop exception handler.</p>
<p>If <em>handler</em> is <code class="docutils literal"><span class="pre">None</span></code>, the default exception handler will
be set.</p>
<p>If <em>handler</em> is a callable object, it should have a
matching signature to <code class="docutils literal"><span class="pre">(loop,</span> <span class="pre">context)</span></code>, where <code class="docutils literal"><span class="pre">loop</span></code>
will be a reference to the active event loop, <code class="docutils literal"><span class="pre">context</span></code>
will be a <code class="docutils literal"><span class="pre">dict</span></code> object (see <a class="reference internal" href="#asyncio.AbstractEventLoop.call_exception_handler" title="asyncio.AbstractEventLoop.call_exception_handler"><code class="xref py py-meth docutils literal"><span class="pre">call_exception_handler()</span></code></a>
documentation for details about context).</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.get_exception_handler">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">get_exception_handler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.get_exception_handler" title="정의 주소">¶</a></dt>
<dd><p>Return the exception handler, or <code class="docutils literal"><span class="pre">None</span></code> if the default one
is in use.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.default_exception_handler">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">default_exception_handler</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.default_exception_handler" title="정의 주소">¶</a></dt>
<dd><p>Default exception handler.</p>
<p>This is called when an exception occurs and no exception
handler is set, and can be called by a custom exception
handler that wants to defer to the default behavior.</p>
<p><em>context</em> parameter has the same meaning as in
<a class="reference internal" href="#asyncio.AbstractEventLoop.call_exception_handler" title="asyncio.AbstractEventLoop.call_exception_handler"><code class="xref py py-meth docutils literal"><span class="pre">call_exception_handler()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.call_exception_handler">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">call_exception_handler</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.call_exception_handler" title="정의 주소">¶</a></dt>
<dd><p>Call the current event loop exception handler.</p>
<p><em>context</em> is a <code class="docutils literal"><span class="pre">dict</span></code> object containing the following keys
(new keys may be introduced later):</p>
<ul class="simple">
<li>'message': Error message;</li>
<li>'exception' (optional): Exception object;</li>
<li>'future' (optional): <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Future</span></code></a> instance;</li>
<li>'handle' (optional): <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Handle</span></code></a> instance;</li>
<li>'protocol' (optional): <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">Protocol</span></a> instance;</li>
<li>'transport' (optional): <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">Transport</span></a> instance;</li>
<li>'socket' (optional): <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> instance.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">Note: this method should not be overloaded in subclassed
event loops.  For any custom exception handling, use
<a class="reference internal" href="#asyncio.AbstractEventLoop.set_exception_handler" title="asyncio.AbstractEventLoop.set_exception_handler"><code class="xref py py-meth docutils literal"><span class="pre">set_exception_handler()</span></code></a> method.</p>
</div>
</dd></dl>

</div>
<div class="section" id="debug-mode">
<h2>19.5.1.17. Debug mode<a class="headerlink" href="#debug-mode" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.get_debug">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">get_debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.get_debug" title="정의 주소">¶</a></dt>
<dd><p>Get the debug mode (<a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-class docutils literal"><span class="pre">bool</span></code></a>) of the event loop.</p>
<p>The default value is <code class="docutils literal"><span class="pre">True</span></code> if the environment variable
<span class="target" id="index-4"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONASYNCIODEBUG"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONASYNCIODEBUG</span></code></a> is set to a non-empty string, <code class="docutils literal"><span class="pre">False</span></code>
otherwise.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.set_debug">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">set_debug</code><span class="sig-paren">(</span><em>enabled: bool</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.set_debug" title="정의 주소">¶</a></dt>
<dd><p>Set the debug mode of the event loop.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.2에 추가.</span></p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last">The <a class="reference internal" href="asyncio-dev.html#asyncio-debug-mode"><span class="std std-ref">debug mode of asyncio</span></a>.</p>
</div>
</div>
<div class="section" id="server">
<h2>19.5.1.18. Server<a class="headerlink" href="#server" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="asyncio.Server">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">Server</code><a class="headerlink" href="#asyncio.Server" title="정의 주소">¶</a></dt>
<dd><p>Server listening on sockets.</p>
<p>Object created by <a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_server()</span></code></a>,
<a class="reference internal" href="#asyncio.AbstractEventLoop.create_unix_server" title="asyncio.AbstractEventLoop.create_unix_server"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_unix_server()</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal"><span class="pre">start_server()</span></code></a>,
and <a class="reference internal" href="asyncio-stream.html#asyncio.start_unix_server" title="asyncio.start_unix_server"><code class="xref py py-func docutils literal"><span class="pre">start_unix_server()</span></code></a> functions.  Don't instantiate the class
directly.</p>
<p><em>Server</em> objects are asynchronous context managers.  When used in an
<code class="docutils literal"><span class="pre">async</span> <span class="pre">with</span></code> statement, it's guaranteed that the Server object is
closed and not accepting new connections when the <code class="docutils literal"><span class="pre">async</span> <span class="pre">with</span></code>
statement is completed:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">srv</span><span class="p">:</span>
    <span class="c1"># some code</span>

<span class="c1"># At this point, srv is closed and no longer accepts new connections.</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>Server object is an asynchronous context manager since Python 3.7.</p>
</div>
<dl class="method">
<dt id="asyncio.Server.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.close" title="정의 주소">¶</a></dt>
<dd><p>Stop serving: close listening sockets and set the <a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><code class="xref py py-attr docutils literal"><span class="pre">sockets</span></code></a>
attribute to <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p>The sockets that represent existing incoming client connections are left
open.</p>
<p>The server is closed asynchronously, use the <a class="reference internal" href="#asyncio.Server.wait_closed" title="asyncio.Server.wait_closed"><code class="xref py py-meth docutils literal"><span class="pre">wait_closed()</span></code></a>
coroutine to wait until the server is closed.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.get_loop">
<code class="descname">get_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.get_loop" title="정의 주소">¶</a></dt>
<dd><p>Gives the event loop associated with the server object.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.start_serving">
<em class="property">coroutine </em><code class="descname">start_serving</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.start_serving" title="정의 주소">¶</a></dt>
<dd><p>Start accepting connections.</p>
<p>This method is idempotent, so it can be called when
the server is already being serving.</p>
<p>The new <em>start_serving</em> keyword-only parameter to
<a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_server()</span></code></a> and
<a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-meth docutils literal"><span class="pre">asyncio.start_server()</span></code></a> allows to create a Server object
that is not accepting connections right away.  In which case
this method, or <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal"><span class="pre">Server.serve_forever()</span></code></a> can be used
to make the Server object to start accepting connections.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.serve_forever">
<em class="property">coroutine </em><code class="descname">serve_forever</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.serve_forever" title="정의 주소">¶</a></dt>
<dd><p>Start accepting connections until the coroutine is cancelled.
Cancellation of <code class="docutils literal"><span class="pre">serve_forever</span></code> task causes the server
to be closed.</p>
<p>This method can be called if the server is already accepting
connections.  Only one <code class="docutils literal"><span class="pre">serve_forever</span></code> task can exist per
one <em>Server</em> object.</p>
<p>Example:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">client_connected</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
    <span class="c1"># Communicate with the client with</span>
    <span class="c1"># reader/writer streams.  For example:</span>
    <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">start_server</span><span class="p">(</span>
        <span class="n">client_connected</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">srv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.is_serving">
<code class="descname">is_serving</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.is_serving" title="정의 주소">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the server is accepting new connections.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.wait_closed">
<em class="property">coroutine </em><code class="descname">wait_closed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.wait_closed" title="정의 주소">¶</a></dt>
<dd><p>Wait until the <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> method completes.</p>
</dd></dl>

<dl class="attribute">
<dt id="asyncio.Server.sockets">
<code class="descname">sockets</code><a class="headerlink" href="#asyncio.Server.sockets" title="정의 주소">¶</a></dt>
<dd><p>List of <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> objects the server is listening to, or
<code class="docutils literal"><span class="pre">None</span></code> if the server is closed.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>Prior to Python 3.7 <code class="docutils literal"><span class="pre">Server.sockets</span></code> used to return the
internal list of server's sockets directly.  In 3.7 a copy
of that list is returned.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="handle">
<h2>19.5.1.19. Handle<a class="headerlink" href="#handle" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="asyncio.Handle">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">Handle</code><a class="headerlink" href="#asyncio.Handle" title="정의 주소">¶</a></dt>
<dd><p>A callback wrapper object returned by <a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon" title="asyncio.AbstractEventLoop.call_soon"><code class="xref py py-func docutils literal"><span class="pre">AbstractEventLoop.call_soon()</span></code></a>,
<a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon_threadsafe" title="asyncio.AbstractEventLoop.call_soon_threadsafe"><code class="xref py py-func docutils literal"><span class="pre">AbstractEventLoop.call_soon_threadsafe()</span></code></a>.</p>
<dl class="method">
<dt id="asyncio.Handle.cancel">
<code class="descname">cancel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancel" title="정의 주소">¶</a></dt>
<dd><p>Cancel the call.  If the callback is already canceled or executed,
this method has no effect.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Handle.cancelled">
<code class="descname">cancelled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancelled" title="정의 주소">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the call was cancelled.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="asyncio.TimerHandle">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">TimerHandle</code><a class="headerlink" href="#asyncio.TimerHandle" title="정의 주소">¶</a></dt>
<dd><p>A callback wrapper object returned by <a class="reference internal" href="#asyncio.AbstractEventLoop.call_later" title="asyncio.AbstractEventLoop.call_later"><code class="xref py py-func docutils literal"><span class="pre">AbstractEventLoop.call_later()</span></code></a>,
and <a class="reference internal" href="#asyncio.AbstractEventLoop.call_at" title="asyncio.AbstractEventLoop.call_at"><code class="xref py py-func docutils literal"><span class="pre">AbstractEventLoop.call_at()</span></code></a>.</p>
<p>The class is inherited from <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal"><span class="pre">Handle</span></code></a>.</p>
<dl class="method">
<dt id="asyncio.TimerHandle.when">
<code class="descname">when</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.TimerHandle.when" title="정의 주소">¶</a></dt>
<dd><p>Return a scheduled callback time as <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> seconds.</p>
<p>The time is an absolute timestamp, using the same time
reference as <a class="reference internal" href="#asyncio.AbstractEventLoop.time" title="asyncio.AbstractEventLoop.time"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.time()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sendfilenotavailableerror">
<h2>19.5.1.20. SendfileNotAvailableError<a class="headerlink" href="#sendfilenotavailableerror" title="제목 주소">¶</a></h2>
<dl class="exception">
<dt id="asyncio.SendfileNotAvailableError">
<em class="property">exception </em><code class="descclassname">asyncio.</code><code class="descname">SendfileNotAvailableError</code><a class="headerlink" href="#asyncio.SendfileNotAvailableError" title="정의 주소">¶</a></dt>
<dd><p>Sendfile syscall is not available, subclass of <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a>.</p>
<p>Raised if the OS does not support sendfile syscall for
given socket or file type.</p>
</dd></dl>

</div>
<div class="section" id="event-loop-examples">
<h2>19.5.1.21. Event loop examples<a class="headerlink" href="#event-loop-examples" title="제목 주소">¶</a></h2>
<div class="section" id="hello-world-with-call-soon">
<span id="asyncio-hello-world-callback"></span><h3>19.5.1.21.1. Hello World with call_soon()<a class="headerlink" href="#hello-world-with-call-soon" title="제목 주소">¶</a></h3>
<p>Example using the <a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon" title="asyncio.AbstractEventLoop.call_soon"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.call_soon()</span></code></a> method to schedule a
callback. The callback displays <code class="docutils literal"><span class="pre">&quot;Hello</span> <span class="pre">World&quot;</span></code> and then stops the event
loop:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="c1"># Schedule a call to hello_world()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">hello_world</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Blocking call interrupted by loop.stop()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last">The <a class="reference internal" href="asyncio-task.html#asyncio-hello-world-coroutine"><span class="std std-ref">Hello World coroutine</span></a> example
uses a <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">coroutine</span></a>.</p>
</div>
</div>
<div class="section" id="display-the-current-date-with-call-later">
<span id="asyncio-date-callback"></span><h3>19.5.1.21.2. Display the current date with call_later()<a class="headerlink" href="#display-the-current-date-with-call-later" title="제목 주소">¶</a></h3>
<p>Example of callback displaying the current date every second. The callback uses
the <a class="reference internal" href="#asyncio.AbstractEventLoop.call_later" title="asyncio.AbstractEventLoop.call_later"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.call_later()</span></code></a> method to reschedule itself during 5
seconds, and then stops the event loop:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">def</span> <span class="nf">display_date</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end_time</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="c1"># Schedule the first call to display_date()</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.0</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Blocking call interrupted by loop.stop()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last">The <a class="reference internal" href="asyncio-task.html#asyncio-date-coroutine"><span class="std std-ref">coroutine displaying the current date</span></a> example uses a <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">coroutine</span></a>.</p>
</div>
</div>
<div class="section" id="watch-a-file-descriptor-for-read-events">
<span id="asyncio-watch-read-event"></span><h3>19.5.1.21.3. Watch a file descriptor for read events<a class="headerlink" href="#watch-a-file-descriptor-for-read-events" title="제목 주소">¶</a></h3>
<p>Wait until a file descriptor received some data using the
<a class="reference internal" href="#asyncio.AbstractEventLoop.add_reader" title="asyncio.AbstractEventLoop.add_reader"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.add_reader()</span></code></a> method and then close the event loop:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">socket</span> <span class="k">import</span> <span class="n">socketpair</span>

<span class="c1"># Create a pair of connected file descriptors</span>
<span class="n">rsock</span><span class="p">,</span> <span class="n">wsock</span> <span class="o">=</span> <span class="n">socketpair</span><span class="p">()</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">reader</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">rsock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Received:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>
    <span class="c1"># We are done: unregister the file descriptor</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">remove_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">)</span>
    <span class="c1"># Stop the event loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="c1"># Register the file descriptor for read event</span>
<span class="n">loop</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">,</span> <span class="n">reader</span><span class="p">)</span>

<span class="c1"># Simulate the reception of data from the network</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">wsock</span><span class="o">.</span><span class="n">send</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="c1"># Run the event loop</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>

<span class="c1"># We are done, close sockets and the event loop</span>
<span class="n">rsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">wsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p>The <a class="reference internal" href="asyncio-protocol.html#asyncio-register-socket"><span class="std std-ref">register an open socket to wait for data using a protocol</span></a> example uses a low-level protocol created by the
<a class="reference internal" href="#asyncio.AbstractEventLoop.create_connection" title="asyncio.AbstractEventLoop.create_connection"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_connection()</span></code></a> method.</p>
<p class="last">The <a class="reference internal" href="asyncio-stream.html#asyncio-register-socket-streams"><span class="std std-ref">register an open socket to wait for data using streams</span></a> example uses high-level streams
created by the <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal"><span class="pre">open_connection()</span></code></a> function in a coroutine.</p>
</div>
</div>
<div class="section" id="set-signal-handlers-for-sigint-and-sigterm">
<h3>19.5.1.21.4. Set signal handlers for SIGINT and SIGTERM<a class="headerlink" href="#set-signal-handlers-for-sigint-and-sigterm" title="제목 주소">¶</a></h3>
<p>Register handlers for signals <code class="xref py py-data docutils literal"><span class="pre">SIGINT</span></code> and <code class="xref py py-data docutils literal"><span class="pre">SIGTERM</span></code> using
the <a class="reference internal" href="#asyncio.AbstractEventLoop.add_signal_handler" title="asyncio.AbstractEventLoop.add_signal_handler"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.add_signal_handler()</span></code></a> method:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">signal</span>

<span class="k">def</span> <span class="nf">ask_exit</span><span class="p">(</span><span class="n">signame</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;got signal </span><span class="si">%s</span><span class="s2">: exit&quot;</span> <span class="o">%</span> <span class="n">signame</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="k">for</span> <span class="n">signame</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;SIGINT&#39;</span><span class="p">,</span> <span class="s1">&#39;SIGTERM&#39;</span><span class="p">):</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signame</span><span class="p">),</span>
                            <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">ask_exit</span><span class="p">,</span> <span class="n">signame</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Event loop running forever, press Ctrl+C to interrupt.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pid </span><span class="si">%s</span><span class="s2">: send SIGINT or SIGTERM to exit.&quot;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>This example only works on UNIX.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">19.5.1. 베이스 이벤트 루프</a><ul>
<li><a class="reference internal" href="#run-an-event-loop">19.5.1.1. 이벤트 루프 실행</a></li>
<li><a class="reference internal" href="#calls">19.5.1.2. 호출</a></li>
<li><a class="reference internal" href="#delayed-calls">19.5.1.3. 지연된 호출</a></li>
<li><a class="reference internal" href="#futures">19.5.1.4. 퓨처</a></li>
<li><a class="reference internal" href="#tasks">19.5.1.5. 태스크</a></li>
<li><a class="reference internal" href="#creating-connections">19.5.1.6. 연결 만들기</a></li>
<li><a class="reference internal" href="#creating-listening-connections">19.5.1.7. 리스닝 연결 만들기</a></li>
<li><a class="reference internal" href="#file-transferring">19.5.1.8. 파일 전송</a></li>
<li><a class="reference internal" href="#tls-upgrade">19.5.1.9. TLS 업그레이드</a></li>
<li><a class="reference internal" href="#watch-file-descriptors">19.5.1.10. Watch file descriptors</a></li>
<li><a class="reference internal" href="#low-level-socket-operations">19.5.1.11. Low-level socket operations</a></li>
<li><a class="reference internal" href="#resolve-host-name">19.5.1.12. Resolve host name</a></li>
<li><a class="reference internal" href="#connect-pipes">19.5.1.13. Connect pipes</a></li>
<li><a class="reference internal" href="#unix-signals">19.5.1.14. UNIX signals</a></li>
<li><a class="reference internal" href="#executor">19.5.1.15. Executor</a></li>
<li><a class="reference internal" href="#error-handling-api">19.5.1.16. Error Handling API</a></li>
<li><a class="reference internal" href="#debug-mode">19.5.1.17. Debug mode</a></li>
<li><a class="reference internal" href="#server">19.5.1.18. Server</a></li>
<li><a class="reference internal" href="#handle">19.5.1.19. Handle</a></li>
<li><a class="reference internal" href="#sendfilenotavailableerror">19.5.1.20. SendfileNotAvailableError</a></li>
<li><a class="reference internal" href="#event-loop-examples">19.5.1.21. Event loop examples</a><ul>
<li><a class="reference internal" href="#hello-world-with-call-soon">19.5.1.21.1. Hello World with call_soon()</a></li>
<li><a class="reference internal" href="#display-the-current-date-with-call-later">19.5.1.21.2. Display the current date with call_later()</a></li>
<li><a class="reference internal" href="#watch-a-file-descriptor-for-read-events">19.5.1.21.3. Watch a file descriptor for read events</a></li>
<li><a class="reference internal" href="#set-signal-handlers-for-sigint-and-sigterm">19.5.1.21.4. Set signal handlers for SIGINT and SIGTERM</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="asyncio.html"
                        title="이전 장">19.5. <code class="docutils literal"><span class="pre">asyncio</span></code> --- 비동기 I/O, 이벤트 루프, 코루틴과 태스크</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="asyncio-eventloops.html"
                        title="다음 장">19.5.2. Event loops</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-eventloops.html" title="19.5.2. Event loops"
             >다음</a> |</li>
        <li class="right" >
          <a href="asyncio.html" title="19.5. asyncio --- 비동기 I/O, 이벤트 루프, 코루틴과 태스크"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >19. 프로세스 간 통신과 네트워킹</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" >19.5. <code class="docutils literal"><span class="pre">asyncio</span></code> --- 비동기 I/O, 이벤트 루프, 코루틴과 태스크</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2018, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 를 사용해서 만들었습니다.
    </div>

  </body>
</html>