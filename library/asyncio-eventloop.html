
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>19.5.1. 베이스 이벤트 루프 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="19.5.2. Event loops" href="asyncio-eventloops.html" />
    <link rel="prev" title="19.5. asyncio --- 비동기 I/O, 이벤트 루프, 코루틴과 태스크" href="asyncio.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/library/asyncio-eventloop.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-eventloops.html" title="19.5.2. Event loops"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="asyncio.html" title="19.5. asyncio --- 비동기 I/O, 이벤트 루프, 코루틴과 태스크"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >19. 프로세스 간 통신과 네트워킹</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U">19.5. <code class="docutils literal"><span class="pre">asyncio</span></code> --- 비동기 I/O, 이벤트 루프, 코루틴과 태스크</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="base-event-loop">
<span id="asyncio-event-loop"></span><h1>19.5.1. 베이스 이벤트 루프<a class="headerlink" href="#base-event-loop" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/asyncio/events.py">Lib/asyncio/events.py</a></p>
<p>이벤트 루프는 <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 가 제공하는 중앙 실행 장치입니다. 다음과 같은 여러 시설을 제공합니다:</p>
<ul class="simple">
<li>지연된 호출(시간제한)을 등록, 실행, 취소하기.</li>
<li>다양한 종류의 통신을 위한 클라이언트와 서버 <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">트랜스포트</span></a> 만들기.</li>
<li>외부 프로그램과의 통신을 위해 서브 프로세스와 관련 <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">트랜스포트</span></a> 시작하기.</li>
<li>비싼 함수 호출을 스레드 풀에 위임하기.</li>
</ul>
<dl class="class">
<dt id="asyncio.BaseEventLoop">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">BaseEventLoop</code><a class="headerlink" href="#asyncio.BaseEventLoop" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 구현 세부 사항입니다. <a class="reference internal" href="#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code class="xref py py-class docutils literal"><span class="pre">AbstractEventLoop</span></code></a> 의 서브 클래스이며, <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 에서 발견되는 구상 이벤트 루프 구현의 베이스 클래스가 될 수 있습니다. 직접 사용해서는 안 됩니다; 대신 <a class="reference internal" href="#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code class="xref py py-class docutils literal"><span class="pre">AbstractEventLoop</span></code></a>를 사용하십시오. <code class="docutils literal"><span class="pre">BaseEventLoop</span></code> 는 제삼자 코드에 의해 서브 클래싱 되어서는 안 됩니다; 내부 인터페이스는 안정적이지 않습니다.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.AbstractEventLoop">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">AbstractEventLoop</code><a class="headerlink" href="#asyncio.AbstractEventLoop" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프의 추상 베이스 클래스입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">다음에 소개되는 <a class="reference internal" href="#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code class="xref py py-class docutils literal"><span class="pre">AbstractEventLoop</span></code></a> 클래스의 모든 메서드는 추상 메서드입니다.
여러분이 직접 이벤트 루프를 제작하려고 하면 모든 메서드들 구현해야한다는 뜻입니다.</p>
</div>
<p>이 클래스는 <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">스레드 안전하지 않습니다</span></a>.</p>
</dd></dl>

<div class="section" id="run-an-event-loop">
<h2>19.5.1.1. 이벤트 루프 실행<a class="headerlink" href="#run-an-event-loop" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.run_forever">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">run_forever</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.run_forever" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.AbstractEventLoop.stop" title="asyncio.AbstractEventLoop.stop"><code class="xref py py-meth docutils literal"><span class="pre">stop()</span></code></a> 이 호출 될 때까지 실행합니다. <a class="reference internal" href="#asyncio.AbstractEventLoop.run_forever" title="asyncio.AbstractEventLoop.run_forever"><code class="xref py py-meth docutils literal"><span class="pre">run_forever()</span></code></a> 가 호출되기 전에 <a class="reference internal" href="#asyncio.AbstractEventLoop.stop" title="asyncio.AbstractEventLoop.stop"><code class="xref py py-meth docutils literal"><span class="pre">stop()</span></code></a> 이 호출되었으면, 이것은 시간제한 0으로 I/O 셀렉터를 한 번 폴링하고, I/O 이벤트에 따라 스케줄 된 모든 콜백(과 이미 스케줄 된 것들)을 실행한 다음 종료합니다. 만약 <a class="reference internal" href="#asyncio.AbstractEventLoop.stop" title="asyncio.AbstractEventLoop.stop"><code class="xref py py-meth docutils literal"><span class="pre">stop()</span></code></a> 이 <a class="reference internal" href="#asyncio.AbstractEventLoop.run_forever" title="asyncio.AbstractEventLoop.run_forever"><code class="xref py py-meth docutils literal"><span class="pre">run_forever()</span></code></a> 가 실행 중일 때 호출되면, 현재 걸려있는 콜백들을 실행한 다음 종료합니다. 콜백에 의해 스케줄 되는 콜백은 이 경우 실행되지 않습니다; 그것들은 다음에 <a class="reference internal" href="#asyncio.AbstractEventLoop.run_forever" title="asyncio.AbstractEventLoop.run_forever"><code class="xref py py-meth docutils literal"><span class="pre">run_forever()</span></code></a> 가 호출될 때 실행됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p>여기에서 구체적으로 제한하고 있지는 않지만, <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 에서 제공되는 모든 이벤트 루프는
재진입할 수 없습니다. 즉 이벤트 루프가 실행중일 때 자신 또는 다른 이벤트 루프의 <a class="reference internal" href="#asyncio.AbstractEventLoop.run_forever" title="asyncio.AbstractEventLoop.run_forever"><code class="xref py py-meth docutils literal"><span class="pre">run_forever()</span></code></a>
메서드를 호출하면 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> 예외를 일으킵니다. 이 제약은 <a class="reference internal" href="#asyncio.AbstractEventLoop.run_until_complete" title="asyncio.AbstractEventLoop.run_until_complete"><code class="xref py py-meth docutils literal"><span class="pre">run_until_complete()</span></code></a>
에도 동일하게 적용됩니다.</p>
<p class="last">이 제약은 많은 상황에서 동기 코드내에서 비동기 코드를 호출할 수 없도록 만드는데, 그 반대의 경우는
항상 실행기(executor)를 사용할 수 있다는 점에서 비대칭적입니다. 파이썬의 비대칭적인 비동기 구현을
결함으로 보는 시각도 있습니다. 실제로 이런 비대칭성은 디스크립터와 같은 언어 기능에서도 문제를 일으킵니다.
하지만 이런 제약은 언어 자체에서 오는 것이 아니라 <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 의 구현에서 오는 것입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5.1으로 변경.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.run_until_complete">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">run_until_complete</code><span class="sig-paren">(</span><em>future</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.run_until_complete" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a> 가 완료될 때까지 실행합니다.</p>
<p>인자가 <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">코루틴 객체</span></a> 면, <a class="reference internal" href="asyncio-task.html#asyncio.ensure_future" title="asyncio.ensure_future"><code class="xref py py-func docutils literal"><span class="pre">ensure_future()</span></code></a>로 쌉니다.</p>
<p>퓨처의 결과를 반환하거나 퓨처의 예외를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.is_running">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">is_running</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.is_running" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프의 실행 상태를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.stop">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.stop" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프 실행을 중지합니다.</p>
<p><a class="reference internal" href="#asyncio.AbstractEventLoop.run_forever" title="asyncio.AbstractEventLoop.run_forever"><code class="xref py py-meth docutils literal"><span class="pre">run_forever()</span></code></a> 가 다음 적절한 기회에 종료하도록 합니다 (자세한 내용은 그 메서드를 보세요).</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5.1으로 변경.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.is_closed">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">is_closed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.is_closed" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프가 닫혔으면 <code class="docutils literal"><span class="pre">True</span></code> 를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.close">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.close" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프를 닫습니다. 루프가 실행 중이어서는 안 됩니다. 계류 중인 콜백이 손실됩니다.</p>
<p>이것은 큐를 비우고 실행기를 종료하지만, 실행기가 완료할 때까지 기다리지 않습니다.</p>
<p>이것은 멱등적(itempotent)이고 되돌릴 수 없습니다. 이것 이후에 다른 메서드를 호출해서는 안 됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">여기서 멱등적이란, 한번 호출하나 여러번 호출하나 같은 결과를 준다는 뜻입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.shutdown_asyncgens">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">shutdown_asyncgens</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.shutdown_asyncgens" title="정의 주소">¶</a></dt>
<dd><p>현재 열려있는 <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">비동기 제너레이터</span></a> 객체를 모두 <a class="reference internal" href="../reference/expressions.html#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal"><span class="pre">aclose()</span></code></a> 호출로 닫도록 스케줄 합니다. 이 메서드를 호출한 후에는, 새 비동기 생성기가 이터레이트 될 때마다 이벤트 루프에서 경고를 보냅니다. 스케줄 된 모든 비동기 제너레이터를 신뢰성 있게 종료하는 데 사용해야 합니다. 예:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">shutdown_asyncgens</span><span class="p">())</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="calls">
<span id="asyncio-pass-keywords"></span><h2>19.5.1.2. 호출<a class="headerlink" href="#calls" title="제목 주소">¶</a></h2>
<p>대부분 <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 함수는 키워드를 받아들이지 않습니다. 여러분의 콜백에 키워드를 전달하려면, <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal"><span class="pre">functools.partial()</span></code></a> 을 사용하십시오. 예를 들어, <code class="docutils literal"><span class="pre">loop.call_soon(functools.partial(print,</span> <span class="pre">&quot;Hello&quot;,</span> <span class="pre">flush=True))</span></code> 는 <code class="docutils literal"><span class="pre">print(&quot;Hello&quot;,</span> <span class="pre">flush=True)</span></code> 를 호출합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal"><span class="pre">functools.partial()</span></code></a> 은 <code class="docutils literal"><span class="pre">lambda</span></code> 함수보다 낫습니다. <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 는 디버그 모드에서 매개 변수를 표시하기 위해 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal"><span class="pre">functools.partial()</span></code></a> 객체를 검사할 수 있지만, <code class="docutils literal"><span class="pre">lambda</span></code> 함수는 표현이 부족하기 때문입니다.</p>
</div>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.call_soon">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">call_soon</code><span class="sig-paren">(</span><em>callback</em>, <em>*args</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.call_soon" title="정의 주소">¶</a></dt>
<dd><p>콜백을 가능한 한 빨리 호출 할 수 있도록 배치합니다. 콜백은 <a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon" title="asyncio.AbstractEventLoop.call_soon"><code class="xref py py-meth docutils literal"><span class="pre">call_soon()</span></code></a> 이 반환되고, 제어가 이벤트 루프로 돌아오면 호출됩니다.</p>
<p>이것은 <abbr title="first-in, first-out - 선입 선출">FIFO</abbr> 큐로 작동하며, 콜백은 등록된 순서대로 호출됩니다. 각 콜백은 정확히 한 번 호출됩니다.</p>
<p>callback 이후의 모든 위치 인자는 호출될 때 콜백에 전달됩니다.</p>
<p>선택적인 키워드 전용 <em>context</em> 인자는 <em>callback</em> 을 실행할 사용자 정의 <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal"><span class="pre">contextvars.Context</span></code></a> 를 지정할 수 있게 합니다. <em>context</em> 가 제공되지 않을 때는 현재 컨텍스트가 사용됩니다.</p>
<p><a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Handle</span></code></a> 인스턴스가 반환되는데, 콜백을 취소하는 데 사용할 수 있습니다.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">functools.partial을 사용하여 키워드를 콜백에 전달하십시오</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>context</em> 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 <span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a>을 보십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.call_soon_threadsafe">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">call_soon_threadsafe</code><span class="sig-paren">(</span><em>callback</em>, <em>*args</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.call_soon_threadsafe" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon" title="asyncio.AbstractEventLoop.call_soon"><code class="xref py py-meth docutils literal"><span class="pre">call_soon()</span></code></a>과 같지만, 스레드 안전합니다.</p>
<p>설명서의 <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">동시성과 다중 스레딩</span></a> 절을 참고하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>context</em> 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 <span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a>을 보십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="delayed-calls">
<span id="asyncio-delayed-calls"></span><h2>19.5.1.3. 지연된 호출<a class="headerlink" href="#delayed-calls" title="제목 주소">¶</a></h2>
<p>이벤트 루프에는 시간제한 계산을 위한 자체 내부 시계가 있습니다. 사용되는 시계는 (플랫폼 특정) 이벤트 루프 구현에 따라 다릅니다; 이상적으로는 단조증가 하는 시계입니다. 이것은 일반적으로 <a class="reference internal" href="time.html#time.time" title="time.time"><code class="xref py py-func docutils literal"><span class="pre">time.time()</span></code></a> 과 다른 시계입니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">제한 시간(상대적인 <em>delay</em> 나 절대적인 <em>when</em>)은 1일을 초과하지 않아야 합니다.</p>
</div>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.call_later">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">call_later</code><span class="sig-paren">(</span><em>delay</em>, <em>callback</em>, <em>*args</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.call_later" title="정의 주소">¶</a></dt>
<dd><p>지정된 <em>delay</em> 초 (int 또는 float) 뒤에 <em>callback</em> 이 호출되도록 배치합니다.</p>
<p><a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal"><span class="pre">asyncio.TimerHandle</span></code></a> 의 인스턴스가 반환되는데, 콜백을 취소하는 데 사용할 수 있습니다.</p>
<p><em>callback</em> 은 <a class="reference internal" href="#asyncio.AbstractEventLoop.call_later" title="asyncio.AbstractEventLoop.call_later"><code class="xref py py-meth docutils literal"><span class="pre">call_later()</span></code></a> 호출 당 정확히 한번 호출됩니다. 두 콜백이 정확히 같은 시간에 스케줄 되면, 어떤 것이 먼저 호출되는지는 정의되지 않습니다.</p>
<p>선택적 위치 <em>args</em> 는 호출 될 때 콜백에 전달됩니다. 콜백을 이름있는 인자로 호출하고 싶으면 클로저나 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal"><span class="pre">functools.partial()</span></code></a> 를 사용하십시오.</p>
<p>선택적인 키워드 전용 <em>context</em> 인자는 <em>callback</em> 을 실행할 사용자 정의 <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal"><span class="pre">contextvars.Context</span></code></a> 를 지정할 수 있게 합니다. <em>context</em> 가 제공되지 않을 때는 현재 컨텍스트가 사용됩니다.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">functools.partial을 사용하여 키워드를 콜백에 전달하십시오</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>context</em> 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 <span class="target" id="index-12"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a>을 보십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.call_at">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">call_at</code><span class="sig-paren">(</span><em>when</em>, <em>callback</em>, <em>*args</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.call_at" title="정의 주소">¶</a></dt>
<dd><p>지정된 절대 타임스탬프 <em>when</em>(int 또는 float)에 <em>callback</em> 이 호출되도록 배치합니다. <a class="reference internal" href="#asyncio.AbstractEventLoop.time" title="asyncio.AbstractEventLoop.time"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.time()</span></code></a> 와 같은 시간 참조를 사용하십시오.</p>
<p>이 메서드의 동작은 <a class="reference internal" href="#asyncio.AbstractEventLoop.call_later" title="asyncio.AbstractEventLoop.call_later"><code class="xref py py-meth docutils literal"><span class="pre">call_later()</span></code></a>와 같습니다.</p>
<p><a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal"><span class="pre">asyncio.TimerHandle</span></code></a> 의 인스턴스가 반환되는데, 콜백을 취소하는 데 사용할 수 있습니다.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">functools.partial을 사용하여 키워드를 콜백에 전달하십시오</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>context</em> 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 <span class="target" id="index-13"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a>을 보십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.time">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.time" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프의 내부 시계에 따라, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 값으로 현재 시각을 반환합니다.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="asyncio-task.html#asyncio.sleep" title="asyncio.sleep"><code class="xref py py-func docutils literal"><span class="pre">asyncio.sleep()</span></code></a> 함수.</p>
</div>
</div>
<div class="section" id="futures">
<h2>19.5.1.4. 퓨처<a class="headerlink" href="#futures" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.create_future">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">create_future</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.create_future" title="정의 주소">¶</a></dt>
<dd><p>루프에 연결된 <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Future</span></code></a> 객체를 만듭니다.</p>
<p>이벤트 루프 구현이 Future 클래스의 다른 구현(더 나은 성능이나 인스트루멘테이션)을 제공 할 수 있으므로, asyncio에서 퓨처를 만드는 데 선호되는 방법입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="tasks">
<h2>19.5.1.5. 태스크<a class="headerlink" href="#tasks" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.create_task">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">create_task</code><span class="sig-paren">(</span><em>coro</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.create_task" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">코루틴 객체</span></a> 의 실행을 스케줄 합니다: 퓨처로 쌉니다. <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> 객체를 반환합니다.</p>
<p>제삼자 이벤트 루프는 상호 운용성을 위해 자신만의 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> 의 서브 클래스를 사용할 수 있습니다. 이 경우, 결과 형은 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> 의 서브 클래스입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.set_task_factory">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">set_task_factory</code><span class="sig-paren">(</span><em>factory</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.set_task_factory" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.AbstractEventLoop.create_task" title="asyncio.AbstractEventLoop.create_task"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_task()</span></code></a> 에 의해 사용되는 태스크 팩토리를 설정합니다.</p>
<p><em>factory</em> 가 <code class="docutils literal"><span class="pre">None</span></code> 이면 기본 태스크 팩토리가 설정됩니다.</p>
<p><em>factory</em> 가 <em>콜러블</em> 이면, <code class="docutils literal"><span class="pre">(loop,</span> <span class="pre">coro)</span></code> 과 일치하는 서명을 가져야 합니다. 여기서 <em>loop</em> 는 활성 이벤트 루프에 대한 참조가 되고, <em>coro</em> 는 코루틴 객체가 됩니다. 콜러블은 <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Future</span></code></a> 호환 객체를 반환해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.get_task_factory">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">get_task_factory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.get_task_factory" title="정의 주소">¶</a></dt>
<dd><p>태스크 팩토리를 반환하거나, 기본값이 사용 중이면 <code class="docutils literal"><span class="pre">None</span></code> 을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.4에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="creating-connections">
<h2>19.5.1.6. 연결 만들기<a class="headerlink" href="#creating-connections" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.create_connection">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">create_connection</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>host=None</em>, <em>port=None</em>, <em>*</em>, <em>ssl=None</em>, <em>family=0</em>, <em>proto=0</em>, <em>flags=0</em>, <em>sock=None</em>, <em>local_addr=None</em>, <em>server_hostname=None</em>, <em>ssl_handshake_timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.create_connection" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>host</em> 와 <em>port</em> 로의 스트리밍 트랜스포트 연결을 만듭니다: <em>host</em> 에 따라 소켓 패밀리 <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal"><span class="pre">AF_INET</span></code></a> 또는 <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal"><span class="pre">AF_INET6</span></code></a> (또는 지정된 경우 <em>family</em>), 소켓 유형 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal"><span class="pre">SOCK_STREAM</span></code></a>. <em>protocol_factory</em> 는 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜</span></a> 인스턴스를 반환하는 콜러블이어야 합니다.</p>
<p>이 메서드는 백그라운드에서 연결을 맺으려고 시도합니다. 성공하면, <code class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다.</p>
<p>하부 연산의 시간순 개요는 다음과 같습니다:</p>
<ol class="arabic simple">
<li>연결이 맺어지고, 이를 표현하기 위한 <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">트랜스포트(transport)</span></a> 가 만들어집니다.</li>
<li><em>protocol_factory</em> 가 인자 없이 호출되고, <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜(protocol)</span></a> 인스턴스를 반환해야 합니다.</li>
<li>프로토콜 인스턴스는 트랜스포트에 묶여있고, <code class="xref py py-meth docutils literal"><span class="pre">connection_made()</span></code> 메서드가 호출됩니다.</li>
<li>코루틴은 성공적으로 <code class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다.</li>
</ol>
<p>만들어진 트랜스포트는 구현 의존적인 양방향 스트림입니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><em>protocol_factory</em> 는 모든 종류의 콜러블일 수 있고, 꼭 클래스 일 필요는 없습니다. 예를 들어, 미리 만들어진 프로토콜 인스턴스를 사용하려면, <code class="docutils literal"><span class="pre">lambda:</span> <span class="pre">my_protocol</span></code> 을 전달하면 됩니다.</p>
</div>
<p>연결 생성 방법을 변경하는 옵션:</p>
<ul>
<li><p class="first"><em>ssl</em>: 주어지고 거짓이 아니면, SSL/TLS 트랜스포트가 만들어집니다 (기본적으로는 평범한 TCP 트랜스포트가 만들어집니다). <em>ssl</em> 이 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">ssl.SSLContext</span></code></a> 객체면, 트랜스포트를 만들 때 이 컨텍스트가 사용됩니다; <em>ssl</em> 이 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> 면, 지정되지 않은 기본 설정의 컨텍스트가 사용됩니다.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">SSL/TLS 보안 고려 사항</span></a></p>
</div>
</li>
<li><p class="first"><em>server_hostname</em> 은 <em>ssl</em> 과 함께 사용하기 위한 것이며 대상 서버의 인증서가 일치될 호스트 이름을 설정하거나 바꿉니다. 기본적으로 <em>host</em> 인자의 값이 사용됩니다. <em>host</em> 가 비어 있으면, 기본값이 없고 <em>server_hostname</em> 값을 전달해야 합니다. <em>server_hostname</em> 이 빈 문자열이면, 호스트 이름 일치가 비활성화됩니다 (이것은 심각한 보안 위험으로, 중간자 공격을 허용하게 됩니다).</p>
</li>
<li><p class="first"><em>family</em>, <em>proto</em>, <em>flags</em> 는 <em>host</em> 결정을 위해 getaddrinfo() 에 전달할 선택적 주소 패밀리, 프로토콜, 플래그입니다. 주어지면, 이것들은 모두 해당하는 <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> 모듈 상수에 대응하는 정수여야 합니다.</p>
</li>
<li><p class="first"><em>sock</em> 이 주어지면, 트랜스포트가 사용할, 기존의 이미 연결된 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> 객체여야 합니다. <em>sock</em> 이 주어지면, <em>host</em>, <em>port</em>, <em>family</em>, <em>proto</em>, <em>flags</em>, <em>local_addr</em> 를 지정해서는 안 됩니다.</p>
</li>
<li><p class="first"><em>local_addr</em> 이 주어지면, 소켓을 로컬에 바인드하는데 사용되는 <code class="docutils literal"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> 튜플이어야 합니다. <em>local_host</em> 와 <em>local_port</em> 는 <em>host</em> 및 <em>port</em> 와 유사하게 getaddrinfo() 를 사용하여 조회됩니다.</p>
</li>
<li><p class="first"><em>ssl_handshake_timeout</em> 은 (SSL 연결의 경우) 연결을 중단하기 전에 SSL 핸드 셰이크가 완료될 때까지 대기하는 시간(초)입니다. <code class="docutils literal"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal"><span class="pre">60.0</span></code> 초가 사용됩니다.</p>
</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>윈도우에서 <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a>를 사용할 때, 이제 SSL/TLS가 지원됩니다.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal"><span class="pre">open_connection()</span></code></a> 함수는 프로토콜 대신 (<a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a>) 쌍을 얻는 데 사용할 수 있습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.create_datagram_endpoint">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">create_datagram_endpoint</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>local_addr=None</em>, <em>remote_addr=None</em>, <em>*</em>, <em>family=0</em>, <em>proto=0</em>, <em>flags=0</em>, <em>reuse_address=None</em>, <em>reuse_port=None</em>, <em>allow_broadcast=None</em>, <em>sock=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.create_datagram_endpoint" title="정의 주소">¶</a></dt>
<dd><p>데이터 그램 연결을 만듭니다: <em>host</em>(또는 주어지면 <em>family</em>)에 따라 소켓 패밀리 <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal"><span class="pre">AF_INET</span></code></a>, <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal"><span class="pre">AF_INET6</span></code></a> 또는 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal"><span class="pre">AF_UNIX</span></code></a>, 소켓 유형 <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-data docutils literal"><span class="pre">SOCK_DGRAM</span></code></a>. <em>protocol_factory</em> 는 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜</span></a> 인스턴스를 반환하는 콜러블이어야 합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">스트림 소켓은 유닉스 도메인 소켓(<a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal"><span class="pre">AF_UNIX</span></code></a>)이 별도의 메서드
<a class="reference internal" href="#asyncio.AbstractEventLoop.create_unix_connection" title="asyncio.AbstractEventLoop.create_unix_connection"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_unix_connection()</span></code></a> 로 분리되어 있으나,
데이터 그램 소켓의 경우는 이 메서드에서 모두 다룹니다. 하지만 소켓 유형
<a class="reference internal" href="socket.html#socket.SOCK_SEQPACKET" title="socket.SOCK_SEQPACKET"><code class="xref py py-data docutils literal"><span class="pre">SOCK_SEQPACKET</span></code></a> 을 지원하지 않습니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><em>host</em> 라는 인자는 없습니다. <em>host</em> 는 <em>local_addr</em> 이나 <em>remote_addr</em> 에 포함된
<em>local_host</em> 와 <em>remote_host</em> 를 뜻합니다.</p>
</div>
<p>이 메서드는 백그라운드에서 연결을 맺으려고 시도합니다. 성공하면, <code class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">데이터 그램 소켓에서, 연결한다는 것은 데이터 그램을 전송할 대상을 <em>remote_addr</em> 로 고정한다는 의미입니다.
따라서 <em>remote_addr</em> 이 제공되지 않으면 연결되지 않은 데이터 그램 소켓이 만들어지는데, 이 경우도
성공적인 것으로 판단합니다.</p>
</div>
<p>연결 생성 방법을 변경하는 옵션:</p>
<ul>
<li><p class="first"><em>local_addr</em> 이 주어지면, 소켓을 로컬에 바인드하는 데 사용되는 <code class="docutils literal"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> 튜플입니다. <em>local_host</em> 와 <em>local_port</em> 는 <a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code class="xref py py-meth docutils literal"><span class="pre">getaddrinfo()</span></code></a>를 사용하여 조회됩니다.</p>
</li>
<li><p class="first"><em>remote_addr</em> 이 주어지면, 소켓을 원격 주소에 연결하는 데 사용되는 <code class="docutils literal"><span class="pre">(remote_host,</span> <span class="pre">remote_port)</span></code> 튜플입니다. <em>remote_host</em> 와 <em>remote_port</em> 는 <a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code class="xref py py-meth docutils literal"><span class="pre">getaddrinfo()</span></code></a>를 사용하여 조회됩니다.</p>
</li>
<li><p class="first"><em>family</em>, <em>proto</em>, <em>flags</em> 는 <em>host</em> 결정을 위해 <a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code class="xref py py-meth docutils literal"><span class="pre">getaddrinfo()</span></code></a> 에 전달할 선택적 주소 패밀리, 프로토콜, 플래그입니다. 주어지면, 이것들은 모두 해당하는 <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> 모듈 상수에 대응하는 정수여야 합니다.</p>
</li>
<li><p class="first"><em>reuse_address</em> 는, 일반적인 시간제한이 만료될 때까지 기다리지 않고, TIME_WAIT 상태의 로컬 소켓을 재사용하도록 커널에 알려줍니다. 지정하지 않으면 유닉스에서 자동으로 <code class="docutils literal"><span class="pre">True</span></code> 로 설정됩니다.</p>
</li>
<li><p class="first"><em>reuse_port</em> 는 모두 만들 때 이 플래그를 설정하는 한, 이 말단이 다른 기존 말단이 바인드 된 것과 같은 포트에 바인드 되도록 허용하도록 커널에 알려줍니다. 이 옵션은 윈도우나 일부 유닉스에서는 지원되지 않습니다. <code class="xref py py-data docutils literal"><span class="pre">SO_REUSEPORT</span></code> 상수가 정의되어 있지 않으면, 이 기능은 지원되지 않는 것입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">지원되지 않는 경우 이 옵션을 지정하면 예외를 일으킵니다.</p>
</div>
</li>
<li><p class="first"><em>allow_broadcast</em> 는 이 말단이 브로드 캐스트 주소로 메시지를 보낼 수 있도록 커널에 알립니다.</p>
</li>
<li><p class="first"><em>sock</em> 은 트랜스포트가 사용할 소켓 객체로, 기존의 이미 연결된 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> 객체를 사용하기 위해 선택적으로 지정할 수 있습니다. 지정되면 <em>local_addr</em> 과 <em>remote_addr</em> 를 생략해야 합니다 (반드시 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> 이어야 합니다).</p>
</li>
</ul>
<p>윈도우에서 <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a>를 사용할 때, 이 메서드는 지원되지 않습니다.</p>
<p><a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-client-protocol"><span class="std std-ref">UDP 에코 클라이언트 프로토콜</span></a> 과 <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-server-protocol"><span class="std std-ref">UDP 에코 서버 프로토콜</span></a> 예제를 참고하세요.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4.4으로 변경: </span><em>family</em>, <em>proto</em>, <em>flags</em>, <em>reuse_address</em>, <em>reuse_port</em>, <em>allow_broadcast</em>, <em>sock</em> 매개 변수가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.create_unix_connection">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">create_unix_connection</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>path=None</em>, <em>*</em>, <em>ssl=None</em>, <em>sock=None</em>, <em>server_hostname=None</em>, <em>ssl_handshake_timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.create_unix_connection" title="정의 주소">¶</a></dt>
<dd><p>유닉스 연결을 만듭니다: 소켓 패밀리 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal"><span class="pre">AF_UNIX</span></code></a>, 소켓 유형 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal"><span class="pre">SOCK_STREAM</span></code></a>. 같은 기계의 프로세스 간에 효율적으로 통신하기 위해 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal"><span class="pre">AF_UNIX</span></code></a> 소켓 패밀리가 사용됩니다.</p>
<p>이 메서드는 백그라운드에서 연결을 맺으려고 시도합니다. 성공하면, <code class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다.</p>
<p><em>path</em> 는 유닉스 도메인 소켓의 이름이며, <em>sock</em> 매개 변수가 지정되지 않으면 필수입니다. 추상 유닉스 소켓, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">Path</span></code></a> 경로가 지원됩니다.</p>
<p>매개 변수는 <a class="reference internal" href="#asyncio.AbstractEventLoop.create_connection" title="asyncio.AbstractEventLoop.create_connection"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_connection()</span></code></a> 메서드를 참조하십시오.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>path</em> 매개 변수는 이제 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a> 가 될 수 있습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="creating-listening-connections">
<h2>19.5.1.7. 리스닝 연결 만들기<a class="headerlink" href="#creating-listening-connections" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.create_server">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">create_server</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>host=None</em>, <em>port=None</em>, <em>*</em>, <em>family=socket.AF_UNSPEC</em>, <em>flags=socket.AI_PASSIVE</em>, <em>sock=None</em>, <em>backlog=100</em>, <em>ssl=None</em>, <em>reuse_address=None</em>, <em>reuse_port=None</em>, <em>ssl_handshake_timeout=None</em>, <em>start_serving=True</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.create_server" title="정의 주소">¶</a></dt>
<dd><p><em>host</em> 와 <em>port</em> 에 바인드 된 TCP 서버(소켓 유형 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal"><span class="pre">SOCK_STREAM</span></code></a>)를 만듭니다.</p>
<p><a class="reference internal" href="#asyncio.Server" title="asyncio.Server"><code class="xref py py-class docutils literal"><span class="pre">Server</span></code></a> 객체를 반환합니다. <a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><code class="xref py py-attr docutils literal"><span class="pre">sockets</span></code></a> 어트리뷰트에 생성된 소켓이 저장됩니다. 서버를 종료하려면 <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal"><span class="pre">Server.close()</span></code></a> 메서드를 사용하십시오: 리스닝 소켓을 닫습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><code class="xref py py-attr docutils literal"><span class="pre">sockets</span></code></a> 어트리뷰트는 리스트입니다. 한 서버는 여러개의 소켓을 동시에
리스닝할 수 있습니다.</p>
</div>
<p>매개 변수:</p>
<ul>
<li><p class="first"><em>host</em> 매개 변수는 문자열일 수 있습니다. 이 경우 TCP 서버는 <em>host</em> 와 <em>port</em> 에 바인드 됩니다. <em>host</em> 매개 변수는 문자열의 시퀀스일 수도 있으며, 이 경우 TCP 서버는 시퀀스의 모든 호스트에 바인드 됩니다. <em>host</em> 가 빈 문자열이거나 <code class="docutils literal"><span class="pre">None</span></code> 이면, 모든 인터페이스가 사용되는 것으로 가정하고, 여러 소켓의 리스트가 반환됩니다 (대체로 IPv4 하나와 IPv6 하나).</p>
</li>
<li><p class="first"><em>family</em> 는 <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal"><span class="pre">socket.AF_INET</span></code></a> 또는 <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal"><span class="pre">AF_INET6</span></code></a> 중 하나로 설정되어, 소켓이 IPv4 또는 IPv6을 사용하게 할 수 있습니다. 설정되지 않으면 host에 의해 결정됩니다(기본값 <code class="xref py py-data docutils literal"><span class="pre">socket.AF_UNSPEC</span></code>).</p>
</li>
<li><p class="first"><em>flags</em> 은 <a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code class="xref py py-meth docutils literal"><span class="pre">getaddrinfo()</span></code></a>를 위한 비트 마스크입니다.</p>
</li>
<li><p class="first"><em>sock</em> 은 기존 소켓 객체를 사용하기 위해 선택적으로 지정할 수 있습니다. 지정되면, <em>host</em> 및 <em>port</em> 를 생략해야 합니다 (반드시 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> 이어야 합니다).</p>
</li>
<li><p class="first"><em>backlog</em> 는 <a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal"><span class="pre">listen()</span></code></a> 으로 전달되는 최대 대기 연결 수 입니다 (기본값은 100).</p>
</li>
<li><p class="first"><em>ssl</em> 을 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> 로 설정하면, 들어오는 연결에 SSL을 사용합니다.</p>
</li>
<li><p class="first"><em>reuse_address</em> 는, 일반적인 시간제한이 만료될 때까지 기다리지 않고, TIME_WAIT 상태의 로컬 소켓을 재사용하도록 커널에 알려줍니다. 지정하지 않으면 유닉스에서 자동으로 <code class="docutils literal"><span class="pre">True</span></code> 로 설정됩니다.</p>
</li>
<li><p class="first"><em>reuse_port</em> 는 모두 만들 때 이 플래그를 설정하는 한, 이 말단이 다른 기존 말단이 바인드 된 것과 같은 포트에 바인드 되도록 허용하도록 커널에 알려줍니다. 이 옵션은 윈도우에서 지원되지 않습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">지원되지 않는 경우 이 옵션을 지정하면 예외를 일으킵니다.</p>
</div>
</li>
<li><p class="first"><em>ssl_handshake_timeout</em> 은 (SSL 서버의 경우) 연결을 중단하기 전에 SSL 핸드 셰이크가 완료될 때까지 대기하는 시간(초)입니다. <code class="docutils literal"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal"><span class="pre">60.0</span></code> 초가 사용됩니다.</p>
</li>
<li><p class="first"><em>start_serving</em> 을 <code class="docutils literal"><span class="pre">True</span></code> (기본값) 로 설정하면, 생성된 서버가 즉시 연결을 받아들입니다. <code class="docutils literal"><span class="pre">False</span></code> 로 설정되면, 사용자는 서버가 연결을 받기 시작하도록 <a class="reference internal" href="#asyncio.Server.start_serving" title="asyncio.Server.start_serving"><code class="xref py py-meth docutils literal"><span class="pre">Server.start_serving()</span></code></a> 이나 <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal"><span class="pre">Server.serve_forever()</span></code></a>를 await 해야 합니다.</p>
</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 과 <em>start_serving</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>윈도우에서 <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a>를 사용할 때, 이제 SSL/TLS가 지원됩니다.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last">함수 <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal"><span class="pre">start_server()</span></code></a> 는 (<a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a>) 쌍을 만들고, 이 쌍으로 콜백 함수를 호출합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5.1으로 변경: </span><em>host</em> 매개 변수는 이제 문자열의 시퀀스가 될 수 있습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.create_unix_server">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">create_unix_server</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>path=None</em>, <em>*</em>, <em>sock=None</em>, <em>backlog=100</em>, <em>ssl=None</em>, <em>ssl_handshake_timeout=None</em>, <em>start_serving=True</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.create_unix_server" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_server()</span></code></a>와 유사하지만, 소켓 패밀리 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal"><span class="pre">AF_UNIX</span></code></a> 전용입니다.</p>
<p><em>path</em> 는 유닉스 도메인 소켓의 이름이며, <em>sock</em> 매개 변수가 지정되지 않으면 필수입니다. 추상 유닉스 소켓, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">Path</span></code></a> 경로가 지원됩니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 과 <em>start_serving</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>path</em> 매개 변수는 이제 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">Path</span></code></a> 객체일 수 있습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.connect_accepted_socket">
<em class="property">coroutine </em><code class="descclassname">BaseEventLoop.</code><code class="descname">connect_accepted_socket</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>sock</em>, <em>*</em>, <em>ssl=None</em>, <em>ssl_handshake_timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseEventLoop.connect_accepted_socket" title="정의 주소">¶</a></dt>
<dd><p>받아들인 연결을 처리합니다.</p>
<p>이것은 asyncio 밖에서 연결을 받아들이지만, 그 연결을 처리하는데 asyncio 를 사용하는 서버에서 사용됩니다.</p>
<p>매개 변수:</p>
<ul class="simple">
<li><em>sock</em> 은 <code class="docutils literal"><span class="pre">accept</span></code> 이 반환한 기존 소켓 객체입니다.</li>
<li><em>ssl</em> 을 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> 로 설정하면, 들어오는 연결에 SSL을 사용합니다.</li>
<li><em>ssl_handshake_timeout</em> 은 (SSL 연결의 경우) 연결을 중단하기 전에 SSL 핸드 셰이크가 완료될 때까지 대기하는 시간(초)입니다. <code class="docutils literal"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal"><span class="pre">60.0</span></code> 초가 사용됩니다.</li>
</ul>
<p>완료되면 <code class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 매개 변수.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5.3에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="file-transferring">
<h2>19.5.1.8. 파일 전송<a class="headerlink" href="#file-transferring" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.sendfile">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">sendfile</code><span class="sig-paren">(</span><em>transport</em>, <em>file</em>, <em>offset=0</em>, <em>count=None</em>, <em>*</em>, <em>fallback=True</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.sendfile" title="정의 주소">¶</a></dt>
<dd><p><em>file</em> 을 <em>transport</em> 로 보내고, 전송된 총 바이트 수를 반환합니다.</p>
<p>이 메서드는 가능한 경우 고성능 <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-meth docutils literal"><span class="pre">os.sendfile()</span></code></a> 을 사용합니다.</p>
<p><em>file</em> 는 바이너리 모드로 열린 일반 파일 객체여야 합니다.</p>
<p><em>offset</em> 은 파일 읽기 시작할 위치를 알려줍니다. <em>count</em> 를 제공하면, EOF에 도달할 때까지 파일을 보내는 대신, 전송할 총 바이트 수를 지정합니다. 반환할 때나 오류가 발생했을 때 파일의 위치가 갱신됩니다. 이 경우 <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal"><span class="pre">file.tell()</span></code></a> 는 전송된 바이트 수를 계산하는 데 사용될 수 있습니다.</p>
<p><em>fallback</em> 을 <code class="docutils literal"><span class="pre">True</span></code> 로 설정하면, 플랫폼이 sendfile 시스템 호출을 지원하지 않을 때 (가령 유닉스에서 SSL 소켓을 사용하거나 윈도우인 경우), asyncio 가 파일을 수동으로 읽고 보내도록 합니다.</p>
<p>시스템이 <em>sendfile</em> 시스템 호출을 지원하지 않고 <em>fallback</em> 이 <code class="docutils literal"><span class="pre">False</span></code> 면 <a class="reference internal" href="#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal"><span class="pre">SendfileNotAvailableError</span></code></a> 를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="tls-upgrade">
<h2>19.5.1.9. TLS 업그레이드<a class="headerlink" href="#tls-upgrade" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.start_tls">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">start_tls</code><span class="sig-paren">(</span><em>transport</em>, <em>protocol</em>, <em>sslcontext</em>, <em>*</em>, <em>server_side=False</em>, <em>server_hostname=None</em>, <em>ssl_handshake_timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.start_tls" title="정의 주소">¶</a></dt>
<dd><p>기존 연결을 TLS로 업그레이드합니다.</p>
<p><em>protocol</em> 이 <em>await</em> 의 직후에 사용해야 하는 새로운 트랜스포트 인스턴스를 반환합니다. <em>start_tls</em> 메서드에 전달된 <em>transport</em> 인스턴스는 절대로 다시 사용해서는 안 됩니다.</p>
<p>매개 변수:</p>
<ul class="simple">
<li><a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code class="xref py py-meth docutils literal"><span class="pre">create_server()</span></code></a>와 <a class="reference internal" href="#asyncio.AbstractEventLoop.create_connection" title="asyncio.AbstractEventLoop.create_connection"><code class="xref py py-meth docutils literal"><span class="pre">create_connection()</span></code></a> 같은 메서드가 반환하는 <em>transport</em> 와 <em>protocol</em> 인스턴스.</li>
<li><em>sslcontext</em>: 구성된 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> 의 인스턴스.</li>
<li>(<a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code class="xref py py-meth docutils literal"><span class="pre">create_server()</span></code></a> 에 의해 생성된 것과 같은) 서버 측 연결이 업그레이드될 때 <em>server_side</em> 에 <code class="docutils literal"><span class="pre">True</span></code> 를 전달합니다.</li>
<li><em>server_hostname</em>: 대상 서버의 인증서가 일치될 호스트 이름을 설정하거나 대체합니다.</li>
<li><em>ssl_handshake_timeout</em> 은 (SSL 연결의 경우) 연결을 중단하기 전에 SSL 핸드 셰이크가 완료될 때까지 대기하는 시간(초)입니다. <code class="docutils literal"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal"><span class="pre">60.0</span></code> 초가 사용됩니다.</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="watch-file-descriptors">
<h2>19.5.1.10. 파일 기술자 관찰하기<a class="headerlink" href="#watch-file-descriptors" title="제목 주소">¶</a></h2>
<p>윈도우에서 <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a>를 사용할 때, 소켓 핸들만 지원됩니다 (예를 들어, 파이프 파일 기술자는 지원되지 않습니다).</p>
<p>윈도우에서 <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a>를 사용할 때, 이 메서드는 지원되지 않습니다.</p>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.add_reader">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">add_reader</code><span class="sig-paren">(</span><em>fd</em>, <em>callback</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.add_reader" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자가 읽기 가능한지 관찰하기 시작하고, 그런 다음 지정한 인자로 <em>callback</em> 을 호출합니다.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">functools.partial을 사용하여 키워드를 콜백에 전달하십시오</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.remove_reader">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">remove_reader</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.remove_reader" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자가 읽기 가능한지 관찰하는 것을 중단합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.add_writer">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">add_writer</code><span class="sig-paren">(</span><em>fd</em>, <em>callback</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.add_writer" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자가 쓰기 가능한지 관찰하기 시작하고, 그런 다음 지정한 인자로 <em>callback</em> 을 호출합니다.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">functools.partial을 사용하여 키워드를 콜백에 전달하십시오</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.remove_writer">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">remove_writer</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.remove_writer" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자가 쓰기 가능한지 관찰하는 것을 중단합니다.</p>
</dd></dl>

<p><a class="reference internal" href="#asyncio-watch-read-event"><span class="std std-ref">파일 기술자에서 읽기 이벤트를 관찰하기</span></a> 예제는 저수준의 <a class="reference internal" href="#asyncio.AbstractEventLoop.add_reader" title="asyncio.AbstractEventLoop.add_reader"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.add_reader()</span></code></a> 메서드를 사용하여 소켓의 파일 기술자를 등록합니다.</p>
</div>
<div class="section" id="low-level-socket-operations">
<h2>19.5.1.11. 저수준 소켓 연산<a class="headerlink" href="#low-level-socket-operations" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.sock_recv">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">sock_recv</code><span class="sig-paren">(</span><em>sock</em>, <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.sock_recv" title="정의 주소">¶</a></dt>
<dd><p>소켓에서 데이터를 수신합니다. 블로킹 <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.recv()</span></code></a> 메서드를 따라 만들어졌습니다.</p>
<p>반환 값은 수신된 데이터를 나타내는 바이트열 객체입니다. 한 번에 수신 할 수 있는 최대 데이터 크기는 <em>nbytes</em> 로 지정됩니다.</p>
<p><a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a> 이벤트 루프를 사용할 때, 소켓 <em>sock</em> 은 비 블로킹(non-blocking)이어야합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a>를 반환했습니다. 파이썬 3.7부터, 이것은 <code class="docutils literal"><span class="pre">async</span> <span class="pre">def</span></code> 메서드입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.sock_recv_into">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">sock_recv_into</code><span class="sig-paren">(</span><em>sock</em>, <em>buf</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.sock_recv_into" title="정의 주소">¶</a></dt>
<dd><p>소켓에서 데이터를 수신합니다. 블로킹 <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.recv_into()</span></code></a> 메서드를 따라 만들어졌습니다.</p>
<p>수신된 데이터는 <em>buf</em> (쓰기 가능한 버퍼)에 기록됩니다. 반환 값은 기록된 바이트 수입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">소켓 IO 의 성능은 수반되는 복사에 크게 영향을 받습니다. <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.recv()</span></code></a>
메서드는 수신 데이터를 반환값으로 제공하기 때문에 <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.recv_into()</span></code></a>
메서드에 비해 복사가 한 번 더 일어날 수 있습니다. 하지만 여전히
<a class="reference internal" href="socket.html#socket.socket.recvmsg_into" title="socket.socket.recvmsg_into"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.recvmsg_into()</span></code></a> 메서드를 사용하는 Scatter/Gather IO는
제공되지 않고 있습니다.</p>
</div>
<p><a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a> 이벤트 루프를 사용할 때, 소켓 <em>sock</em> 은 비 블로킹(non-blocking)이어야합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.sock_sendall">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">sock_sendall</code><span class="sig-paren">(</span><em>sock</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.sock_sendall" title="정의 주소">¶</a></dt>
<dd><p>소켓으로 데이터를 보냅니다. 블로킹 <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.sendall()</span></code></a> 메서드를 따라 만들어졌습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">역시 <a class="reference internal" href="socket.html#socket.socket.sendmsg" title="socket.socket.sendmsg"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.sendmsg()</span></code></a> 메서드를 사용하는 Scatter/Gather IO는
지원되지 않습니다.</p>
</div>
<p>소켓은 원격 소켓에 연결되어 있어야만 합니다. 이 메서드는 모든 데이터가 송신되거나 오류가 발생할 때까지 <em>data</em> 에서 데이터를 계속 송신합니다. 성공하면 <code class="docutils literal"><span class="pre">None</span></code> 이 반환됩니다. 오류가 발생하면 예외가 발생하고, 연결의 수신 단에서 성공적으로 처리한 (있기는 하다면) 데이터의 크기를 확인하는 방법은 없습니다.</p>
<p><a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a> 이벤트 루프를 사용할 때, 소켓 <em>sock</em> 은 비 블로킹(non-blocking)이어야합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a>를 반환했습니다. 파이썬 3.7부터, 이것은 <code class="docutils literal"><span class="pre">async</span> <span class="pre">def</span></code> 메서드입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.sock_connect">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">sock_connect</code><span class="sig-paren">(</span><em>sock</em>, <em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.sock_connect" title="정의 주소">¶</a></dt>
<dd><p><em>address</em> 에 있는 원격 소켓에 연결합니다. 블로킹 <a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.connect()</span></code></a> 메서드를 따라 만들어졌습니다.</p>
<p><a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a> 이벤트 루프를 사용할 때, 소켓 <em>sock</em> 은 비 블로킹(non-blocking)이어야합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5.2으로 변경: </span><code class="docutils literal"><span class="pre">address</span></code> 는 더는 결정될 필요가 없습니다. <code class="docutils literal"><span class="pre">sock_connect</span></code> 는 <a class="reference internal" href="socket.html#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal"><span class="pre">socket.inet_pton()</span></code></a>을 호출하여 <em>address</em> 가 이미 결정되었는지를 검사합니다. 그렇지 않으면, <a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.getaddrinfo()</span></code></a> 가 <em>address</em> 를 결정하는 데 사용됩니다.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="#asyncio.AbstractEventLoop.create_connection" title="asyncio.AbstractEventLoop.create_connection"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_connection()</span></code></a>과 <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal"><span class="pre">asyncio.open_connection()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.sock_accept">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">sock_accept</code><span class="sig-paren">(</span><em>sock</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.sock_accept" title="정의 주소">¶</a></dt>
<dd><p>연결을 받아들입니다. 블로킹 <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.accept()</span></code></a> 를 따라 만들어졌습니다.</p>
<p>소켓은 주소에 바인드 되어 연결을 리스닝해야 합니다. 반환 값은 <code class="docutils literal"><span class="pre">(conn,</span> <span class="pre">address)</span></code> 쌍인데, <em>conn</em> 은 연결로 데이터를 주고받을 수 있는 <em>새</em> 소켓 객체이고, <em>address</em> 는 연결의 반대편 끝의 소켓에 바인드 된 주소입니다.</p>
<p>소켓 <em>sock</em> 은 비 블로킹이어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a>를 반환했습니다. 파이썬 3.7부터, 이것은 <code class="docutils literal"><span class="pre">async</span> <span class="pre">def</span></code> 메서드입니다.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_server()</span></code></a>와 <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal"><span class="pre">start_server()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.sock_sendfile">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">sock_sendfile</code><span class="sig-paren">(</span><em>sock</em>, <em>file</em>, <em>offset=0</em>, <em>count=None</em>, <em>*</em>, <em>fallback=True</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.sock_sendfile" title="정의 주소">¶</a></dt>
<dd><p>가능하면 고성능 <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal"><span class="pre">os.sendfile</span></code></a> 을 사용하여 파일을 보내고, 전송된 총 바이트 수를 반환합니다.</p>
<p><a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.sendfile()</span></code></a> 의 비동기 버전.</p>
<p><em>sock</em> 은 반드시 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal"><span class="pre">socket.SOCK_STREAM</span></code></a> 유형의 비 블로킹 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket</span></code></a> 이어야 합니다.</p>
<p><em>file</em> 는 바이너리 모드로 열린 일반 파일 객체여야 합니다.</p>
<p><em>offset</em> 은 파일 읽기 시작할 위치를 알려줍니다. <em>count</em> 를 제공하면, EOF에 도달할 때까지 파일을 보내는 대신, 전송할 총 바이트 수를 지정합니다. 반환할 때나 오류가 발생했을 때 파일의 위치가 갱신됩니다. 이 경우 <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal"><span class="pre">file.tell()</span></code></a> 는 전송된 바이트 수를 계산하는 데 사용될 수 있습니다.</p>
<p><em>fallback</em> 을 <code class="docutils literal"><span class="pre">True</span></code> 로 설정하면, 플랫폼이 sendfile 시스템 호출을 지원하지 않을 때 (가령 유닉스에서 SSL 소켓을 사용하거나 윈도우인 경우), asyncio 가 파일을 수동으로 읽고 보내도록 합니다.</p>
<p>시스템이 <em>sendfile</em> 시스템 호출을 지원하지 않고 <em>fallback</em> 이 <code class="docutils literal"><span class="pre">False</span></code> 면 <a class="reference internal" href="#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal"><span class="pre">SendfileNotAvailableError</span></code></a> 를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="resolve-host-name">
<h2>19.5.1.12. 호스트 이름 결정<a class="headerlink" href="#resolve-host-name" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.getaddrinfo">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">getaddrinfo</code><span class="sig-paren">(</span><em>host</em>, <em>port</em>, <em>*</em>, <em>family=0</em>, <em>type=0</em>, <em>proto=0</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.getaddrinfo" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">코루틴</span></a> 입니다. <a class="reference internal" href="socket.html#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-meth docutils literal"><span class="pre">socket.getaddrinfo()</span></code></a> 함수와 비슷하지만, 비 블로킹입니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.getnameinfo">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">getnameinfo</code><span class="sig-paren">(</span><em>sockaddr</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.getnameinfo" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">코루틴</span></a> 입니다. <a class="reference internal" href="socket.html#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-meth docutils literal"><span class="pre">socket.getnameinfo()</span></code></a> 함수와 비슷하지만, 비 블로킹입니다.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>getaddrinfo</em> 와 <em>getnameinfo</em> 메서드는 모두 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에 실제로는 <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Future</span></code></a> 객체를 반환했습니다. Python 3.7부터 두 가지 메서드 모두 코루틴입니다.</p>
</div>
</div>
<div class="section" id="connect-pipes">
<h2>19.5.1.13. 파이프 연결<a class="headerlink" href="#connect-pipes" title="제목 주소">¶</a></h2>
<p>윈도우에서 <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a>를 사용할 때, 이 메서드는 지원되지 않습니다. 윈도우에서 파이프를 지원하려면 <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a>를 사용하십시오.</p>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.connect_read_pipe">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">connect_read_pipe</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.connect_read_pipe" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프에 읽기 파이프를 등록합니다.</p>
<p><em>protocol_factory</em> 는 <a class="reference internal" href="asyncio-protocol.html#asyncio.Protocol" title="asyncio.Protocol"><code class="xref py py-class docutils literal"><span class="pre">Protocol</span></code></a> 인터페이스를 갖는 객체의 인스턴스를 만들어야 합니다. <em>pipe</em> 는 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일류 객체</span></a> 입니다. <code class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환하는데, <em>transport</em> 는 <a class="reference internal" href="asyncio-protocol.html#asyncio.ReadTransport" title="asyncio.ReadTransport"><code class="xref py py-class docutils literal"><span class="pre">ReadTransport</span></code></a> 인터페이스를 지원합니다.</p>
<p><a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a> 이벤트 루프를 사용하면, <em>pipe</em> 는 비 블로킹 모드로 설정됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.connect_write_pipe">
<em class="property">coroutine </em><code class="descclassname">AbstractEventLoop.</code><code class="descname">connect_write_pipe</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.connect_write_pipe" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프에 쓰기 파이프를 등록합니다.</p>
<p><em>protocol_factory</em> 는 <code class="xref py py-class docutils literal"><span class="pre">BaseProtocol</span></code> 인터페이스를 갖는 객체의 인스턴스를 만들어야 합니다. <em>pipe</em> 는 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일류 객체</span></a> 입니다. <code class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환하는데, <em>transport</em> 는 <a class="reference internal" href="asyncio-protocol.html#asyncio.WriteTransport" title="asyncio.WriteTransport"><code class="xref py py-class docutils literal"><span class="pre">WriteTransport</span></code></a> 인터페이스를 지원합니다.</p>
<p><a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a> 이벤트 루프를 사용하면, <em>pipe</em> 는 비 블로킹 모드로 설정됩니다.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="asyncio-subprocess.html#asyncio.AbstractEventLoop.subprocess_exec" title="asyncio.AbstractEventLoop.subprocess_exec"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.subprocess_exec()</span></code></a> 와 <a class="reference internal" href="asyncio-subprocess.html#asyncio.AbstractEventLoop.subprocess_shell" title="asyncio.AbstractEventLoop.subprocess_shell"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.subprocess_shell()</span></code></a> 메서드.</p>
</div>
</div>
<div class="section" id="unix-signals">
<h2>19.5.1.14. 유닉스 시그널<a class="headerlink" href="#unix-signals" title="제목 주소">¶</a></h2>
<p>가용성: 유닉스 전용.</p>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.add_signal_handler">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">add_signal_handler</code><span class="sig-paren">(</span><em>signum</em>, <em>callback</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.add_signal_handler" title="정의 주소">¶</a></dt>
<dd><p>시그널 처리기를 추가합니다.</p>
<p>시그널 번호가 유효하지 않거나 잡을 수 없으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 발생시킵니다. 처리기를 설정하는 데 문제가 있는 경우 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> 를 발생시킵니다.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">functools.partial을 사용하여 키워드를 콜백에 전달하십시오</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.remove_signal_handler">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">remove_signal_handler</code><span class="sig-paren">(</span><em>sig</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.remove_signal_handler" title="정의 주소">¶</a></dt>
<dd><p>시그널 처리기를 제거합니다.</p>
<p>시그널 처리기가 제거되면 <code class="docutils literal"><span class="pre">True</span></code> 를, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code> 를 반환합니다.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal"><span class="pre">signal</span></code></a> 모듈.</p>
</div>
</div>
<div class="section" id="executor">
<h2>19.5.1.15. 실행기<a class="headerlink" href="#executor" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="concurrent.futures.html#concurrent.futures.Executor" title="concurrent.futures.Executor"><code class="xref py py-class docutils literal"><span class="pre">Executor</span></code></a>(스레드 풀 또는 프로세스 풀)에서 함수를 호출합니다. 기본적으로, 이벤트 루프는 스레드 풀 실행기(<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal"><span class="pre">ThreadPoolExecutor</span></code></a>)를 사용합니다.</p>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.run_in_executor">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">run_in_executor</code><span class="sig-paren">(</span><em>executor</em>, <em>func</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.run_in_executor" title="정의 주소">¶</a></dt>
<dd><p>지정된 실행기에서 <em>func</em> 가 호출되도록 배치합니다.</p>
<p><em>executor</em> 인자는 <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Executor" title="concurrent.futures.Executor"><code class="xref py py-class docutils literal"><span class="pre">Executor</span></code></a> 인스턴스여야 합니다. <em>executor</em> 가 <code class="docutils literal"><span class="pre">None</span></code> 이면 기본 실행기가 사용됩니다.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">functools.partial을 사용하여 키워드를 *func* 에 전달하십시오</span></a>.</p>
<p>이 메서드는 <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Future</span></code></a> 객체를 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5.3으로 변경: </span><code class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.run_in_executor()</span></code> 는 더는 자신이 만드는 스레드 풀 실행기의 <code class="docutils literal"><span class="pre">max_workers</span></code> 를 설정하지 않습니다. 대신 스레드 풀 실행기(<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal"><span class="pre">ThreadPoolExecutor</span></code></a>)가 스스로 기본값을 설정하도록 합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.set_default_executor">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">set_default_executor</code><span class="sig-paren">(</span><em>executor</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.set_default_executor" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.AbstractEventLoop.run_in_executor" title="asyncio.AbstractEventLoop.run_in_executor"><code class="xref py py-meth docutils literal"><span class="pre">run_in_executor()</span></code></a> 가 사용하는 기본 실행기를 설정합니다.</p>
</dd></dl>

</div>
<div class="section" id="error-handling-api">
<h2>19.5.1.16. 에러 처리 API<a class="headerlink" href="#error-handling-api" title="제목 주소">¶</a></h2>
<p>이벤트 루프에서 예외를 처리하는 방법을 사용자 정의 할 수 있습니다.</p>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.set_exception_handler">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">set_exception_handler</code><span class="sig-paren">(</span><em>handler</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.set_exception_handler" title="정의 주소">¶</a></dt>
<dd><p><em>handler</em> 를 새 이벤트 루프 예외 처리기로 설정합니다.</p>
<p><em>handler</em> 가 <code class="docutils literal"><span class="pre">None</span></code> 이면 기본 예외 처리기가 설정됩니다.</p>
<p><em>handler</em> 가 콜러블 객체면, <code class="docutils literal"><span class="pre">(loop,</span> <span class="pre">context)</span></code> 와 일치하는 서명을 가져야 합니다. 여기서 <code class="docutils literal"><span class="pre">loop</span></code> 는 활성 이벤트 루프에 대한 참조가 될 것이고, <code class="docutils literal"><span class="pre">context</span></code> 는 <code class="docutils literal"><span class="pre">dict</span></code> 객체가 됩니다 (context에 대한 자세한 내용은 <a class="reference internal" href="#asyncio.AbstractEventLoop.call_exception_handler" title="asyncio.AbstractEventLoop.call_exception_handler"><code class="xref py py-meth docutils literal"><span class="pre">call_exception_handler()</span></code></a> 문서를 참조하십시오).</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.get_exception_handler">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">get_exception_handler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.get_exception_handler" title="정의 주소">¶</a></dt>
<dd><p>예외 처리기를 반환하거나, 기본값이 사용 중이면 <code class="docutils literal"><span class="pre">None</span></code> 을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.default_exception_handler">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">default_exception_handler</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.default_exception_handler" title="정의 주소">¶</a></dt>
<dd><p>기본 예외 처리기.</p>
<p>예외가 발생하고 예외 처리기가 설정되지 않았을 때 호출됩니다. 기본 동작으로 위임하려는 사용자 정의 예외 처리기가 호출할 수 있습니다.</p>
<p><em>context</em> 매개 변수는 <a class="reference internal" href="#asyncio.AbstractEventLoop.call_exception_handler" title="asyncio.AbstractEventLoop.call_exception_handler"><code class="xref py py-meth docutils literal"><span class="pre">call_exception_handler()</span></code></a> 에서와 같은 의미입니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.call_exception_handler">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">call_exception_handler</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.call_exception_handler" title="정의 주소">¶</a></dt>
<dd><p>현재 이벤트 루프 예외 처리기를 호출합니다.</p>
<p><em>context</em> 는 다음 키를 포함하는 <code class="docutils literal"><span class="pre">dict</span></code> 객체입니다 (새 키가 나중에 추가될 수 있습니다):</p>
<ul class="simple">
<li>'message': 에러 메시지;</li>
<li>'exception' (선택적): 예외 객체;</li>
<li>'future' (선택적): <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Future</span></code></a> 인스턴스;</li>
<li>'handle' (선택적): <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal"><span class="pre">asyncio.Handle</span></code></a> 인스턴스;</li>
<li>'protocol' (선택적): <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜</span></a> 인스턴스;</li>
<li>'transport' (선택적): <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">트랜스포트</span></a> 인스턴스;</li>
<li>'socket' (선택적): <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> 인스턴스.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드는 서브 클래스 된 이벤트 루프에서 재정의되지 않아야 합니다. 사용자 정의 예외 처리를 위해서는 <a class="reference internal" href="#asyncio.AbstractEventLoop.set_exception_handler" title="asyncio.AbstractEventLoop.set_exception_handler"><code class="xref py py-meth docutils literal"><span class="pre">set_exception_handler()</span></code></a> 메서드를 사용하십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="debug-mode">
<h2>19.5.1.17. 디버그 모드<a class="headerlink" href="#debug-mode" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="asyncio.AbstractEventLoop.get_debug">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">get_debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.get_debug" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프의 디버그 모드(<a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-class docutils literal"><span class="pre">bool</span></code></a>)를 가져옵니다.</p>
<p>기본값은 환경 변수 <span class="target" id="index-14"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONASYNCIODEBUG"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONASYNCIODEBUG</span></code></a> 가 비어 있지 않은 문자열로 설정되면 <code class="docutils literal"><span class="pre">True</span></code> 이고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code> 입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoop.set_debug">
<code class="descclassname">AbstractEventLoop.</code><code class="descname">set_debug</code><span class="sig-paren">(</span><em>enabled: bool</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoop.set_debug" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프의 디버그 모드를 설정합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.2에 추가.</span></p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="asyncio-dev.html#asyncio-debug-mode"><span class="std std-ref">asyncio의 디버그 모드</span></a>.</p>
</div>
</div>
<div class="section" id="server">
<h2>19.5.1.18. Server<a class="headerlink" href="#server" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="asyncio.Server">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">Server</code><a class="headerlink" href="#asyncio.Server" title="정의 주소">¶</a></dt>
<dd><p>소켓을 리스닝하는 서버.</p>
<p><a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_server()</span></code></a>, <a class="reference internal" href="#asyncio.AbstractEventLoop.create_unix_server" title="asyncio.AbstractEventLoop.create_unix_server"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_unix_server()</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal"><span class="pre">start_server()</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.start_unix_server" title="asyncio.start_unix_server"><code class="xref py py-func docutils literal"><span class="pre">start_unix_server()</span></code></a> 함수가 만드는 객체. 클래스의 인스턴스를 직접 만들지 마십시오.</p>
<p><em>Server</em> 객체는 비동기 컨텍스트 관리자입니다. <code class="docutils literal"><span class="pre">async</span> <span class="pre">with</span></code> 문에서 사용될 때, <code class="docutils literal"><span class="pre">async</span> <span class="pre">with</span></code> 문이 완료되면 서버 객체가 닫혀 있고 새 연결을 받아들이지 않는다는 것이 보장됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">srv</span><span class="p">:</span>
    <span class="c1"># 코드</span>

<span class="c1"># 이 지점에서, srv 는 닫혔고 더는 새 연결을 받아들이지 않습니다.</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>Server 객체는 파이썬 3.7부터 비동기 컨텍스트 관리자입니다.</p>
</div>
<dl class="method">
<dt id="asyncio.Server.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.close" title="정의 주소">¶</a></dt>
<dd><p>서버를 중지합니다: 리스닝 소켓을 닫고 <a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><code class="xref py py-attr docutils literal"><span class="pre">sockets</span></code></a> 어트리뷰트를 <code class="docutils literal"><span class="pre">None</span></code> 으로 설정합니다.</p>
<p>이미 받아들여진 클라이언트 연결을 나타내는 소켓은 열린 채로 있습니다.</p>
<p>서버는 비동기적으로 닫힙니다. 서버가 닫힐 때까지 대기하려면 <a class="reference internal" href="#asyncio.Server.wait_closed" title="asyncio.Server.wait_closed"><code class="xref py py-meth docutils literal"><span class="pre">wait_closed()</span></code></a> 코루틴을 사용하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.get_loop">
<code class="descname">get_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.get_loop" title="정의 주소">¶</a></dt>
<dd><p>서버 객체와 연관된 이벤트 루프를 제공합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.start_serving">
<em class="property">coroutine </em><code class="descname">start_serving</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.start_serving" title="정의 주소">¶</a></dt>
<dd><p>연결을 받아들이기 시작합니다.</p>
<p>이 메서드는 멱등적이라서, 서버가 이미 시작되었을 때도 호출 할 수 있습니다.</p>
<p><a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_server()</span></code></a>와 <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-meth docutils literal"><span class="pre">asyncio.start_server()</span></code></a> 의 새로운 <em>start_serving</em> 키워드 전용 매개 변수는 즉시 연결을 받아들이지 않는 서버 객체를 만들 수 있도록 합니다. 이 경우, 이 메서드나 <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal"><span class="pre">Server.serve_forever()</span></code></a>를 사용하여 Server 객체가 연결을 받아들이기 시작하도록 할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.serve_forever">
<em class="property">coroutine </em><code class="descname">serve_forever</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.serve_forever" title="정의 주소">¶</a></dt>
<dd><p>코루틴이 취소될 때까지 연결을 받아들이기 시작합니다. <code class="docutils literal"><span class="pre">serve_forever</span></code> 태스크를 취소하면 서버가 닫힙니다.</p>
<p>이 메서드는 서버가 이미 연결을 받아들이고 있어도 호출 할 수 있습니다. 하나의 <em>Server</em> 객체 당 하나의 <code class="docutils literal"><span class="pre">serve_forever</span></code> 태스크만 존재할 수 있습니다.</p>
<p>예:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">client_connected</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
    <span class="c1"># reader/writer 스트림으로 클라이언트와</span>
    <span class="c1"># 통신합니다. 예를 들어:</span>
    <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">start_server</span><span class="p">(</span>
        <span class="n">client_connected</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">srv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.is_serving">
<code class="descname">is_serving</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.is_serving" title="정의 주소">¶</a></dt>
<dd><p>서버가 새 연결을 받아들이고 있으면 <code class="docutils literal"><span class="pre">True</span></code> 를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.wait_closed">
<em class="property">coroutine </em><code class="descname">wait_closed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.wait_closed" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> 메서드가 완료될 때까지 기다립니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="asyncio.Server.sockets">
<code class="descname">sockets</code><a class="headerlink" href="#asyncio.Server.sockets" title="정의 주소">¶</a></dt>
<dd><p>서버가 리스닝하고 있는 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> 객체의 리스트, 또는 서버가 닫혀 있다면 <code class="docutils literal"><span class="pre">None</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>Python 3.7 이전에는 <code class="docutils literal"><span class="pre">Server.sockets</span></code> 가 서버 소켓의 내부 리스트를 직접 반환했습니다. 3.7에서는 그 리스트의 복사본이 반환됩니다.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="handle">
<h2>19.5.1.19. Handle<a class="headerlink" href="#handle" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="asyncio.Handle">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">Handle</code><a class="headerlink" href="#asyncio.Handle" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon" title="asyncio.AbstractEventLoop.call_soon"><code class="xref py py-func docutils literal"><span class="pre">AbstractEventLoop.call_soon()</span></code></a>, <a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon_threadsafe" title="asyncio.AbstractEventLoop.call_soon_threadsafe"><code class="xref py py-func docutils literal"><span class="pre">AbstractEventLoop.call_soon_threadsafe()</span></code></a> 에 의해 반환되는 콜백 래퍼 객체.</p>
<dl class="method">
<dt id="asyncio.Handle.cancel">
<code class="descname">cancel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancel" title="정의 주소">¶</a></dt>
<dd><p>호출을 취소합니다. 콜백이 이미 취소되었거나 실행되었다면 이 메서드는 아무 효과가 없습니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Handle.cancelled">
<code class="descname">cancelled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancelled" title="정의 주소">¶</a></dt>
<dd><p>호출이 취소되었으면 <code class="docutils literal"><span class="pre">True</span></code> 을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="asyncio.TimerHandle">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">TimerHandle</code><a class="headerlink" href="#asyncio.TimerHandle" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.AbstractEventLoop.call_later" title="asyncio.AbstractEventLoop.call_later"><code class="xref py py-func docutils literal"><span class="pre">AbstractEventLoop.call_later()</span></code></a> 및 <a class="reference internal" href="#asyncio.AbstractEventLoop.call_at" title="asyncio.AbstractEventLoop.call_at"><code class="xref py py-func docutils literal"><span class="pre">AbstractEventLoop.call_at()</span></code></a> 에 의해 반환되는 콜백 래퍼 객체.</p>
<p>이 클래스는 <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal"><span class="pre">Handle</span></code></a>을 상속합니다.</p>
<dl class="method">
<dt id="asyncio.TimerHandle.when">
<code class="descname">when</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.TimerHandle.when" title="정의 주소">¶</a></dt>
<dd><p>스케줄 된 콜백 시간을 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 초로 반환합니다.</p>
<p>시간은 절대 타임스탬프입니다. <a class="reference internal" href="#asyncio.AbstractEventLoop.time" title="asyncio.AbstractEventLoop.time"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.time()</span></code></a> 과 같은 시간 참조를 사용합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sendfilenotavailableerror">
<h2>19.5.1.20. SendfileNotAvailableError<a class="headerlink" href="#sendfilenotavailableerror" title="제목 주소">¶</a></h2>
<dl class="exception">
<dt id="asyncio.SendfileNotAvailableError">
<em class="property">exception </em><code class="descclassname">asyncio.</code><code class="descname">SendfileNotAvailableError</code><a class="headerlink" href="#asyncio.SendfileNotAvailableError" title="정의 주소">¶</a></dt>
<dd><p>Sendfile 시스템 호출을 사용할 수 없습니다. <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> 의 서브 클래스.</p>
<p>OS가 주어진 소켓 또는 파일 유형에 대해 sendfile 시스템 호출을 지원하지 않는 경우 발생합니다.</p>
</dd></dl>

</div>
<div class="section" id="event-loop-examples">
<h2>19.5.1.21. 이벤트 루프 예제<a class="headerlink" href="#event-loop-examples" title="제목 주소">¶</a></h2>
<div class="section" id="hello-world-with-call-soon">
<span id="asyncio-hello-world-callback"></span><h3>19.5.1.21.1. call_soon()을 사용하는 Hello World<a class="headerlink" href="#hello-world-with-call-soon" title="제목 주소">¶</a></h3>
<p>콜백을 스케줄 하기 위해 <a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon" title="asyncio.AbstractEventLoop.call_soon"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.call_soon()</span></code></a> 메서드를 사용하는 예제. 콜백은 <code class="docutils literal"><span class="pre">&quot;Hello</span> <span class="pre">World&quot;</span></code> 를 표시한 다음 이벤트 루프를 중지합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="c1"># hello_world() 호출을 스케쥴합니다</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">hello_world</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># 블로킹 호출이 loop.stop() 에 의해 중단됩니다</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="asyncio-task.html#asyncio-hello-world-coroutine"><span class="std std-ref">Hello World 코루틴</span></a> 예제는 <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">코루틴</span></a> 을 사용합니다.</p>
</div>
</div>
<div class="section" id="display-the-current-date-with-call-later">
<span id="asyncio-date-callback"></span><h3>19.5.1.21.2. call_later()로 현재 날짜를 표시합니다.<a class="headerlink" href="#display-the-current-date-with-call-later" title="제목 주소">¶</a></h3>
<p>초마다 현재 날짜를 표시하는 콜백의 예입니다. 콜백은 <a class="reference internal" href="#asyncio.AbstractEventLoop.call_later" title="asyncio.AbstractEventLoop.call_later"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.call_later()</span></code></a> 메서드를 사용하여 5초 동안 자신을 다시 스케줄 한 다음 이벤트 루프를 중지합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">def</span> <span class="nf">display_date</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end_time</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="c1"># 첫번째 display_date() 호출을 스케쥴합니다</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.0</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># 블로킹 호출이 loop.stop() 에 의해 중단됩니다</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="asyncio-task.html#asyncio-date-coroutine"><span class="std std-ref">현재 날짜를 표시하는 코루틴</span></a> 예제는 <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">코루틴</span></a> 을 사용합니다.</p>
</div>
</div>
<div class="section" id="watch-a-file-descriptor-for-read-events">
<span id="asyncio-watch-read-event"></span><h3>19.5.1.21.3. 파일 기술자에서 읽기 이벤트를 관찰하기<a class="headerlink" href="#watch-a-file-descriptor-for-read-events" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#asyncio.AbstractEventLoop.add_reader" title="asyncio.AbstractEventLoop.add_reader"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.add_reader()</span></code></a> 메서드를 사용하여 파일 기술자가 데이터를 수신할 때까지 기다렸다가 이벤트 루프를 닫습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">socket</span> <span class="k">import</span> <span class="n">socketpair</span>

<span class="c1"># 연결된 파일 기술자 쌍을 만듭니다</span>
<span class="n">rsock</span><span class="p">,</span> <span class="n">wsock</span> <span class="o">=</span> <span class="n">socketpair</span><span class="p">()</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">reader</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">rsock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Received:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>
    <span class="c1"># 할 일을 끝냈습니다: 파일 기술자를 등록 취소합니다</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">remove_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">)</span>
    <span class="c1"># 이벤트 루프를 중지합니다</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="c1"># 읽기 이벤트를 위해 파일 기술자를 등록합니다</span>
<span class="n">loop</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">,</span> <span class="n">reader</span><span class="p">)</span>

<span class="c1"># 네트웍으로 부터의 데이터 수신을 흉내냅니다</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">wsock</span><span class="o">.</span><span class="n">send</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="c1"># 이벤트 루프를 실행합니다</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>

<span class="c1"># 할 일을 끝냈습니다, 소켓과 이벤트 루프를 닫습니다</span>
<span class="n">rsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">wsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p><a class="reference internal" href="asyncio-protocol.html#asyncio-register-socket"><span class="std std-ref">프로토콜을 사용하여 데이터를 기다리는 열린 소켓 등록</span></a> 예제는 <a class="reference internal" href="#asyncio.AbstractEventLoop.create_connection" title="asyncio.AbstractEventLoop.create_connection"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.create_connection()</span></code></a> 메서드에 의해 생성된 저수준 프로토콜을 사용합니다.</p>
<p class="last"><a class="reference internal" href="asyncio-stream.html#asyncio-register-socket-streams"><span class="std std-ref">스트림을 사용하여 데이터를 기다리는 열린 소켓 등록</span></a> 예제는 코루틴에서 <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal"><span class="pre">open_connection()</span></code></a> 함수에 의해 생성된 고수준 스트림을 사용합니다.</p>
</div>
</div>
<div class="section" id="set-signal-handlers-for-sigint-and-sigterm">
<h3>19.5.1.21.4. SIGINT 및 SIGTERM에 대한 시그널 처리기 설정<a class="headerlink" href="#set-signal-handlers-for-sigint-and-sigterm" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#asyncio.AbstractEventLoop.add_signal_handler" title="asyncio.AbstractEventLoop.add_signal_handler"><code class="xref py py-meth docutils literal"><span class="pre">AbstractEventLoop.add_signal_handler()</span></code></a> 메서드를 사용하여 <code class="xref py py-data docutils literal"><span class="pre">SIGINT</span></code>와 <code class="xref py py-data docutils literal"><span class="pre">SIGTERM</span></code> 시그널을 위한 처리기를 등록합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">signal</span>

<span class="k">def</span> <span class="nf">ask_exit</span><span class="p">(</span><span class="n">signame</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;got signal </span><span class="si">%s</span><span class="s2">: exit&quot;</span> <span class="o">%</span> <span class="n">signame</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="k">for</span> <span class="n">signame</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;SIGINT&#39;</span><span class="p">,</span> <span class="s1">&#39;SIGTERM&#39;</span><span class="p">):</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signame</span><span class="p">),</span>
                            <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">ask_exit</span><span class="p">,</span> <span class="n">signame</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Event loop running forever, press Ctrl+C to interrupt.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pid </span><span class="si">%s</span><span class="s2">: send SIGINT or SIGTERM to exit.&quot;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>이 예제는 유닉스에서만 작동합니다.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">19.5.1. 베이스 이벤트 루프</a><ul>
<li><a class="reference internal" href="#run-an-event-loop">19.5.1.1. 이벤트 루프 실행</a></li>
<li><a class="reference internal" href="#calls">19.5.1.2. 호출</a></li>
<li><a class="reference internal" href="#delayed-calls">19.5.1.3. 지연된 호출</a></li>
<li><a class="reference internal" href="#futures">19.5.1.4. 퓨처</a></li>
<li><a class="reference internal" href="#tasks">19.5.1.5. 태스크</a></li>
<li><a class="reference internal" href="#creating-connections">19.5.1.6. 연결 만들기</a></li>
<li><a class="reference internal" href="#creating-listening-connections">19.5.1.7. 리스닝 연결 만들기</a></li>
<li><a class="reference internal" href="#file-transferring">19.5.1.8. 파일 전송</a></li>
<li><a class="reference internal" href="#tls-upgrade">19.5.1.9. TLS 업그레이드</a></li>
<li><a class="reference internal" href="#watch-file-descriptors">19.5.1.10. 파일 기술자 관찰하기</a></li>
<li><a class="reference internal" href="#low-level-socket-operations">19.5.1.11. 저수준 소켓 연산</a></li>
<li><a class="reference internal" href="#resolve-host-name">19.5.1.12. 호스트 이름 결정</a></li>
<li><a class="reference internal" href="#connect-pipes">19.5.1.13. 파이프 연결</a></li>
<li><a class="reference internal" href="#unix-signals">19.5.1.14. 유닉스 시그널</a></li>
<li><a class="reference internal" href="#executor">19.5.1.15. 실행기</a></li>
<li><a class="reference internal" href="#error-handling-api">19.5.1.16. 에러 처리 API</a></li>
<li><a class="reference internal" href="#debug-mode">19.5.1.17. 디버그 모드</a></li>
<li><a class="reference internal" href="#server">19.5.1.18. Server</a></li>
<li><a class="reference internal" href="#handle">19.5.1.19. Handle</a></li>
<li><a class="reference internal" href="#sendfilenotavailableerror">19.5.1.20. SendfileNotAvailableError</a></li>
<li><a class="reference internal" href="#event-loop-examples">19.5.1.21. 이벤트 루프 예제</a><ul>
<li><a class="reference internal" href="#hello-world-with-call-soon">19.5.1.21.1. call_soon()을 사용하는 Hello World</a></li>
<li><a class="reference internal" href="#display-the-current-date-with-call-later">19.5.1.21.2. call_later()로 현재 날짜를 표시합니다.</a></li>
<li><a class="reference internal" href="#watch-a-file-descriptor-for-read-events">19.5.1.21.3. 파일 기술자에서 읽기 이벤트를 관찰하기</a></li>
<li><a class="reference internal" href="#set-signal-handlers-for-sigint-and-sigterm">19.5.1.21.4. SIGINT 및 SIGTERM에 대한 시그널 처리기 설정</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="asyncio.html"
                        title="이전 장">19.5. <code class="docutils literal"><span class="pre">asyncio</span></code> --- 비동기 I/O, 이벤트 루프, 코루틴과 태스크</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="asyncio-eventloops.html"
                        title="다음 장">19.5.2. Event loops</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-eventloops.html" title="19.5.2. Event loops"
             >다음</a> |</li>
        <li class="right" >
          <a href="asyncio.html" title="19.5. asyncio --- 비동기 I/O, 이벤트 루프, 코루틴과 태스크"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >19. 프로세스 간 통신과 네트워킹</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" >19.5. <code class="docutils literal"><span class="pre">asyncio</span></code> --- 비동기 I/O, 이벤트 루프, 코루틴과 태스크</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2018, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 를 사용해서 만들었습니다.
    </div>

  </body>
</html>