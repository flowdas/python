
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>이벤트 루프 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="퓨처" href="asyncio-future.html" />
    <link rel="prev" title="예외" href="asyncio-exceptions.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/asyncio-eventloop.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="퓨처"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="asyncio-exceptions.html" title="예외"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> --- 비동기 I/O</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="event-loop">
<h1>이벤트 루프<a class="headerlink" href="#event-loop" title="제목 주소">¶</a></h1>
<p class="rubric">머리말</p>
<p>이벤트 루프는 모든 asyncio 응용 프로그램의 핵심입니다. 이벤트 루프는 비동기 태스크 및 콜백을 실행하고 네트워크 IO 연산을 수행하며 자식 프로세스를 실행합니다.</p>
<p>응용 프로그램 개발자는 일반적으로 <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>과 같은 고수준의 asyncio 함수를 사용해야 하며, 루프 객체를 참조하거나 메서드를 호출할 필요가 거의 없습니다. 이 절은 주로 이벤트 루프 동작을 세부적으로 제어해야 하는 저수준 코드, 라이브러리 및 프레임워크의 작성자를 대상으로 합니다.</p>
<p class="rubric">이벤트 루프 얻기</p>
<p>다음 저수준 함수를 사용하여 이벤트 루프를 가져오거나 설정하거나 만들 수 있습니다.:</p>
<dl class="function">
<dt id="asyncio.get_running_loop">
<code class="descclassname">asyncio.</code><code class="descname">get_running_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_running_loop" title="정의 주소">¶</a></dt>
<dd><p>현재 OS 스레드에서 실행 중인 이벤트 루프를 반환합니다.</p>
<p>실행 중인 이벤트 루프가 없으면 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생합니다. 이 함수는 코루틴이나 콜백에서만 호출할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="asyncio.get_event_loop">
<code class="descclassname">asyncio.</code><code class="descname">get_event_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_event_loop" title="정의 주소">¶</a></dt>
<dd><p>현재의 이벤트 루프를 가져옵니다. 현재 OS 스레드에 현재 이벤트 루프가 설정되어 있지 않고 <a class="reference internal" href="#asyncio.set_event_loop" title="asyncio.set_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_event_loop()</span></code></a>가 아직 호출되지 않았으면, asyncio는 새 이벤트 루프를 만들어 현재 이벤트 루프로 설정합니다.</p>
<p>이 함수는 (특히 사용자 정의 이벤트 루프 정책을 사용할 때) 다소 복잡한 동작을 하므로, 코루틴과 콜백에서 <a class="reference internal" href="#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a>보다 <a class="reference internal" href="#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a> 함수를 사용하는 것이 좋습니다.</p>
<p>저수준 함수를 사용하여 수동으로 이벤트 루프를 만들고 닫는 대신 <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> 함수를 사용하는 것도 고려하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="asyncio.set_event_loop">
<code class="descclassname">asyncio.</code><code class="descname">set_event_loop</code><span class="sig-paren">(</span><em>loop</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.set_event_loop" title="정의 주소">¶</a></dt>
<dd><p><em>loop</em>를 현재 OS 스레드의 현재 이벤트 루프로 설정합니다.</p>
</dd></dl>

<dl class="function">
<dt id="asyncio.new_event_loop">
<code class="descclassname">asyncio.</code><code class="descname">new_event_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.new_event_loop" title="정의 주소">¶</a></dt>
<dd><p>새 이벤트 루프 객체를 만듭니다.</p>
</dd></dl>

<p><a class="reference internal" href="#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a>, <a class="reference internal" href="#asyncio.set_event_loop" title="asyncio.set_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_event_loop()</span></code></a> 및 <a class="reference internal" href="#asyncio.new_event_loop" title="asyncio.new_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">new_event_loop()</span></code></a> 함수의 동작은 <a class="reference internal" href="asyncio-policy.html#asyncio-policies"><span class="std std-ref">사용자 정의 이벤트 루프 정책 설정</span></a>에 의해 변경될 수 있음에 유의하십시오.</p>
<p class="rubric">목차</p>
<p>이 설명서 페이지는 다음과 같은 절로 구성됩니다:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#event-loop-methods">이벤트 루프 메서드</a> 절은 이벤트 루프 API의 레퍼런스 설명서입니다.</p></li>
<li><p><a class="reference internal" href="#callback-handles">콜백 핸들</a> 절은 <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> 및 <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a>와 같은 예약 메서드에서 반환된 <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a> 및 <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimerHandle</span></code></a> 인스턴스를 설명합니다.</p></li>
<li><p><a class="reference internal" href="#server-objects">서버 객체</a> 절은 <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>와 같은 이벤트 루프 메서드에서 반환되는 형을 설명합니다.</p></li>
<li><p><a class="reference internal" href="#event-loop-implementations">이벤트 루프 구현</a> 절은 <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 및 <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> 클래스를 설명합니다.</p></li>
<li><p><a class="reference internal" href="#examples">예제</a> 절에서는 일부 이벤트 루프 API로 작업하는 방법을 보여줍니다.</p></li>
</ul>
<div class="section" id="event-loop-methods">
<span id="asyncio-event-loop"></span><h2>이벤트 루프 메서드<a class="headerlink" href="#event-loop-methods" title="제목 주소">¶</a></h2>
<p>이벤트 루프에는 다음과 같은 <strong>저수준</strong> API가 있습니다:</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#running-and-stopping-the-loop" id="id1">루프 실행 및 중지</a></p></li>
<li><p><a class="reference internal" href="#scheduling-callbacks" id="id2">콜백 예약하기</a></p></li>
<li><p><a class="reference internal" href="#scheduling-delayed-callbacks" id="id3">지연된 콜백 예약</a></p></li>
<li><p><a class="reference internal" href="#creating-futures-and-tasks" id="id4">퓨처와 태스크 만들기</a></p></li>
<li><p><a class="reference internal" href="#opening-network-connections" id="id5">네트워크 연결 열기</a></p></li>
<li><p><a class="reference internal" href="#creating-network-servers" id="id6">네트워크 서버 만들기</a></p></li>
<li><p><a class="reference internal" href="#transferring-files" id="id7">파일 전송</a></p></li>
<li><p><a class="reference internal" href="#tls-upgrade" id="id8">TLS 업그레이드</a></p></li>
<li><p><a class="reference internal" href="#watching-file-descriptors" id="id9">파일 기술자 관찰하기</a></p></li>
<li><p><a class="reference internal" href="#working-with-socket-objects-directly" id="id10">소켓 객체로 직접 작업하기</a></p></li>
<li><p><a class="reference internal" href="#dns" id="id11">DNS</a></p></li>
<li><p><a class="reference internal" href="#working-with-pipes" id="id12">파이프로 작업하기</a></p></li>
<li><p><a class="reference internal" href="#unix-signals" id="id13">유닉스 시그널</a></p></li>
<li><p><a class="reference internal" href="#executing-code-in-thread-or-process-pools" id="id14">스레드 또는 프로세스 풀에서 코드를 실행하기</a></p></li>
<li><p><a class="reference internal" href="#error-handling-api" id="id15">에러 처리 API</a></p></li>
<li><p><a class="reference internal" href="#enabling-debug-mode" id="id16">디버그 모드 활성화</a></p></li>
<li><p><a class="reference internal" href="#running-subprocesses" id="id17">자식 프로세스 실행하기</a></p></li>
</ul>
</div>
<div class="section" id="running-and-stopping-the-loop">
<h3><a class="toc-backref" href="#id1">루프 실행 및 중지</a><a class="headerlink" href="#running-and-stopping-the-loop" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.loop.run_until_complete">
<code class="descclassname">loop.</code><code class="descname">run_until_complete</code><span class="sig-paren">(</span><em>future</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_until_complete" title="정의 주소">¶</a></dt>
<dd><p><em>future</em>(<a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>의 인스턴스)가 완료할 때까지 실행합니다.</p>
<p>인자가 <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">코루틴 객체</span></a> 면, <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>로 실행되도록 묵시적으로 예약 됩니다.</p>
<p>퓨처의 결과를 반환하거나 퓨처의 예외를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.run_forever">
<code class="descclassname">loop.</code><code class="descname">run_forever</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_forever" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a>가 호출될 때까지 이벤트 루프를 실행합니다.</p>
<p><a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> 가 호출되기 전에 <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> 이 호출되었으면, 루프는 시간제한 0으로 I/O 셀렉터를 한 번 폴링하고, I/O 이벤트에 따라 예약된 모든 콜백(과 이미 예약된 것들)을 실행한 다음 종료합니다.</p>
<p>만약 <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> 이 <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> 가 실행 중일 때 호출되면, 루프는 현재 걸려있는 콜백들을 실행한 다음 종료합니다. 콜백에 의해 예약되는 새 콜백은 이 경우 실행되지 않습니다; 대신 그것들은 다음에 <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a>나 <a class="reference internal" href="#asyncio.loop.run_until_complete" title="asyncio.loop.run_until_complete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_until_complete()</span></code></a>가 호출될 때 실행됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>여기에서 구체적으로 제한하고 있지는 않지만, <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> 에서 제공되는 모든 이벤트 루프는
재진입할 수 없습니다. 즉 이벤트 루프가 실행중일 때 자신 또는 다른 이벤트 루프의 <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a>
메서드를 호출하면 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 예외를 일으킵니다. 이 제약은 <a class="reference internal" href="#asyncio.loop.run_until_complete" title="asyncio.loop.run_until_complete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_until_complete()</span></code></a>
에도 동일하게 적용됩니다.</p>
<p>이 제약은 많은 상황에서 동기 코드내에서 비동기 코드를 호출할 수 없도록 만드는데, 그 반대의 경우는
항상 실행기(executor)를 사용할 수 있다는 점에서 비대칭적입니다. 파이썬의 비대칭적인 비동기 구현을
결함으로 보는 시각도 있습니다. 실제로 이런 비대칭성은 디스크립터와 같은 언어 기능에서도 문제를 일으킵니다.
하지만 이런 제약은 언어 자체에서 오는 것이 아니라 <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> 의 구현에서 오는 것입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.stop">
<code class="descclassname">loop.</code><code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.stop" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프를 중지합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.is_running">
<code class="descclassname">loop.</code><code class="descname">is_running</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.is_running" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프가 현재 실행 중이면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.is_closed">
<code class="descclassname">loop.</code><code class="descname">is_closed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.is_closed" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프가 닫혔으면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.close">
<code class="descclassname">loop.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.close" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프를 닫습니다.</p>
<p>이 함수를 호출할 때 루프는 반드시 실행 중이지 않아야 합니다. 계류 중인 모든 콜백을 버립니다.</p>
<p>이 메서드는 모든 큐를 비우고 실행기를 종료하지만, 실행기가 완료할 때까지 기다리지 않습니다.</p>
<p>이 메서드는 멱등적(itempotent)이고 되돌릴 수 없습니다. 이벤트 루프가 닫힌 후에 다른 메서드를 호출해서는 안 됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>여기서 멱등적이란, 한번 호출하나 여러번 호출하나 같은 결과를 준다는 뜻입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.shutdown_asyncgens">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">shutdown_asyncgens</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.shutdown_asyncgens" title="정의 주소">¶</a></dt>
<dd><p>현재 열려있는 <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">비동기 제너레이터</span></a> 객체를 모두 <a class="reference internal" href="../reference/expressions.html#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> 호출로 닫도록 예약 합니다. 이 메서드를 호출한 후에는, 새 비동기 생성기가 이터레이트 되면 이벤트 루프에서 경고를 보냅니다. 예약된 모든 비동기 제너레이터를 신뢰성 있게 종료하는 데 사용해야 합니다.</p>
<p><a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>가 사용될 때 이 함수를 호출할 필요는 없다는 점에 유의하세요.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">shutdown_asyncgens</span><span class="p">())</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="scheduling-callbacks">
<h3><a class="toc-backref" href="#id2">콜백 예약하기</a><a class="headerlink" href="#scheduling-callbacks" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.loop.call_soon">
<code class="descclassname">loop.</code><code class="descname">call_soon</code><span class="sig-paren">(</span><em>callback</em>, <em>*args</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_soon" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프의 다음 이터레이션 때 <em>args</em> 인자로 호출할 <em>callback</em>을 예약합니다.</p>
<p>콜백은 등록된 순서대로 호출됩니다. 각 콜백은 정확히 한 번 호출됩니다.</p>
<p>선택적인 키워드 전용 <em>context</em> 인자는 <em>callback</em> 을 실행할 사용자 정의 <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> 를 지정할 수 있게 합니다. <em>context</em> 가 제공되지 않을 때는 현재 컨텍스트가 사용됩니다.</p>
<p><a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Handle</span></code></a> 인스턴스가 반환되는데, 나중에 콜백을 취소하는 데 사용할 수 있습니다.</p>
<p>이 메서드는 스레드 안전하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.call_soon_threadsafe">
<code class="descclassname">loop.</code><code class="descname">call_soon_threadsafe</code><span class="sig-paren">(</span><em>callback</em>, <em>*args</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_soon_threadsafe" title="정의 주소">¶</a></dt>
<dd><p>스레드 안전한 <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon()</span></code></a> 변형입니다. <em>다른 스레드에서</em> 콜백을 예약하는 데 사용해야 합니다.</p>
<p>설명서의 <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">동시성과 다중 스레딩</span></a> 절을 참고하십시오.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>context</em> 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 <span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a>을 보십시오.</p>
</div>
<div class="admonition note" id="asyncio-pass-keywords">
<p class="admonition-title">참고</p>
<p>대부분 <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> 예약 함수는 키워드 인자 전달을 허용하지 않습니다. 그렇게 하려면 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>을 사용하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &quot;print(&quot;Hello&quot;, flush=True)&quot; 를 스케줄합니다</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span>
    <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
<p>asyncio는 디버그 및 오류 메시지에서 partial 객체를 더욱 잘 표시할 수 있으므로, partial 객체를 사용하는 것이 람다를 사용하는 것보다 편리합니다.</p>
</div>
</div>
<div class="section" id="scheduling-delayed-callbacks">
<span id="asyncio-delayed-calls"></span><h3><a class="toc-backref" href="#id3">지연된 콜백 예약</a><a class="headerlink" href="#scheduling-delayed-callbacks" title="제목 주소">¶</a></h3>
<p>이벤트 루프는 콜백 함수가 미래의 어떤 시점에서 호출되도록 예약하는 메커니즘을 제공합니다. 이벤트 루프는 단조 시계를 사용하여 시간을 추적합니다.</p>
<dl class="method">
<dt id="asyncio.loop.call_later">
<code class="descclassname">loop.</code><code class="descname">call_later</code><span class="sig-paren">(</span><em>delay</em>, <em>callback</em>, <em>*args</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_later" title="정의 주소">¶</a></dt>
<dd><p>지정된 <em>delay</em> 초 (int 또는 float) 뒤에 <em>callback</em> 이 호출되도록 예약합니다.</p>
<p><a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TimerHandle</span></code></a> 의 인스턴스가 반환되는데, 콜백을 취소하는 데 사용할 수 있습니다.</p>
<p><em>callback</em> 은 정확히 한번 호출됩니다. 두 콜백이 정확히 같은 시간에 예약되면, 어떤 것이 먼저 호출되는지는 정의되지 않습니다.</p>
<p>선택적 위치 <em>args</em> 는 호출 될 때 콜백에 전달됩니다. 콜백을 키워드 인자로 호출하고 싶으면 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> 를 사용하십시오.</p>
<p>선택적인 키워드 전용 <em>context</em> 인자는 <em>callback</em> 을 실행할 사용자 정의 <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> 를 지정할 수 있게 합니다. <em>context</em> 가 제공되지 않을 때는 현재 컨텍스트가 사용됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>context</em> 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 <span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a>을 보십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>파이썬 3.7 및 이전 버전에서 기본 이벤트 루프 구현을 사용할 때, <em>delay</em>는 하루를 초과할 수 없었습니다. 이 문제는 파이썬 3.8에서 수정되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.call_at">
<code class="descclassname">loop.</code><code class="descname">call_at</code><span class="sig-paren">(</span><em>when</em>, <em>callback</em>, <em>*args</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_at" title="정의 주소">¶</a></dt>
<dd><p>지정된 절대 타임스탬프 <em>when</em>(int 또는 float)에 <em>callback</em> 이 호출되도록 예약합니다. <a class="reference internal" href="#asyncio.loop.time" title="asyncio.loop.time"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.time()</span></code></a> 과 같은 시간 참조를 사용하십시오.</p>
<p>이 메서드의 동작은 <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_later()</span></code></a>와 같습니다.</p>
<p><a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TimerHandle</span></code></a> 의 인스턴스가 반환되는데, 콜백을 취소하는 데 사용할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>context</em> 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 <span class="target" id="index-12"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a>을 보십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>파이썬 3.7 및 이전 버전에서 기본 이벤트 루프 구현을 사용할 때, <em>when</em>와 현재 시각의 차이는 하루를 초과할 수 없었습니다. 이 문제는 파이썬 3.8에서 수정되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.time">
<code class="descclassname">loop.</code><code class="descname">time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.time" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프의 내부 단조 시계에 따라, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 값으로 현재 시각을 반환합니다.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">참고</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>파이썬 3.7 및 이전 버전에서 제한 시간(상대적인 <em>delay</em> 나 절대적인 <em>when</em>)은 1일을 초과하지 않아야 했습니다. 이 문제는 파이썬 3.8에서 수정되었습니다.</p>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="asyncio-task.html#asyncio.sleep" title="asyncio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.sleep()</span></code></a> 함수.</p>
</div>
</div>
<div class="section" id="creating-futures-and-tasks">
<h3><a class="toc-backref" href="#id4">퓨처와 태스크 만들기</a><a class="headerlink" href="#creating-futures-and-tasks" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.loop.create_future">
<code class="descclassname">loop.</code><code class="descname">create_future</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_future" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프에 연결된 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 객체를 만듭니다.</p>
<p>이것이 asyncio에서 퓨처를 만드는 데 선호되는 방법입니다. 이렇게 하면 제삼자 이벤트 루프가 Future 객체의 다른 구현(더 나은 성능이나 계측(instrumentation))을 제공할 수 있습니다</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.create_task">
<code class="descclassname">loop.</code><code class="descname">create_task</code><span class="sig-paren">(</span><em>coro</em>, <em>*</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_task" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">코루틴</span></a> 의 실행을 예약합니다. <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> 객체를 반환합니다.</p>
<p>제삼자 이벤트 루프는 상호 운용성을 위해 자신만의 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> 의 서브 클래스를 사용할 수 있습니다. 이 경우, 결과 형은 <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> 의 서브 클래스입니다.</p>
<p>If the <em>name</em> argument is provided and not <code class="docutils literal notranslate"><span class="pre">None</span></code>, it is set as
the name of the task using <a class="reference internal" href="asyncio-task.html#asyncio.Task.set_name" title="asyncio.Task.set_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.set_name()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>Added the <code class="docutils literal notranslate"><span class="pre">name</span></code> parameter.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.set_task_factory">
<code class="descclassname">loop.</code><code class="descname">set_task_factory</code><span class="sig-paren">(</span><em>factory</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_task_factory" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.loop.create_task" title="asyncio.loop.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_task()</span></code></a> 에 의해 사용되는 태스크 팩토리를 설정합니다.</p>
<p><em>factory</em> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면 기본 태스크 팩토리가 설정됩니다. 그렇지 않으면, <em>factory</em> 는 반드시 <em>콜러블</em> 이어야 하고, <code class="docutils literal notranslate"><span class="pre">(loop,</span> <span class="pre">coro)</span></code> 과 일치하는 서명을 가져야 합니다. 여기서 <em>loop</em> 는 활성 이벤트 루프에 대한 참조가 되고, <em>coro</em> 는 코루틴 객체가 됩니다. 콜러블은 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 호환 객체를 반환해야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.get_task_factory">
<code class="descclassname">loop.</code><code class="descname">get_task_factory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_task_factory" title="정의 주소">¶</a></dt>
<dd><p>태스크 팩토리를 반환하거나, 기본값이 사용 중이면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 반환합니다.</p>
</dd></dl>

</div>
<div class="section" id="opening-network-connections">
<h3><a class="toc-backref" href="#id5">네트워크 연결 열기</a><a class="headerlink" href="#opening-network-connections" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.loop.create_connection">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">create_connection</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>host=None</em>, <em>port=None</em>, <em>*</em>, <em>ssl=None</em>, <em>family=0</em>, <em>proto=0</em>, <em>flags=0</em>, <em>sock=None</em>, <em>local_addr=None</em>, <em>server_hostname=None</em>, <em>ssl_handshake_timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_connection" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>host</em> 와 <em>port</em>로 지정된 주소로의 스트리밍 트랜스포트 연결을 엽니다.</p>
<p>소켓 패밀리는 <em>host</em>(또는 지정된 경우 <em>family</em>)에 따라 <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET</span></code></a> 또는 <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>일 수 있습니다.</p>
<p>소켓 유형은 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>이 됩니다.</p>
<p><em>protocol_factory</em> 는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio 프로토콜</span></a> 구현을 반환하는 콜러블이어야 합니다.</p>
<p>이 메서드는 백그라운드에서 연결을 맺으려고 시도합니다. 성공하면, <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다.</p>
<p>하부 연산의 시간순 개요는 다음과 같습니다:</p>
<ol class="arabic simple">
<li><p>연결이 맺어지고, 이를 위한 <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">트랜스포트(transport)</span></a> 가 만들어집니다.</p></li>
<li><p><em>protocol_factory</em> 가 인자 없이 호출되고, <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜(protocol)</span></a> 인스턴스를 반환할 것으로 기대됩니다.</p></li>
<li><p>프로토콜 인스턴스는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">connection_made()</span></code> 메서드를 호출함으로써 트랜스포트와 연결됩니다.</p></li>
<li><p>성공하면 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 튜플이 반환됩니다.</p></li>
</ol>
<p>만들어진 트랜스포트는 구현 의존적인 양방향 스트림입니다.</p>
<p>다른 인자들:</p>
<ul>
<li><p><em>ssl</em>: 주어지고 거짓이 아니면, SSL/TLS 트랜스포트가 만들어집니다 (기본적으로는 평범한 TCP 트랜스포트가 만들어집니다). <em>ssl</em> 이 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 객체면, 트랜스포트를 만들 때 이 컨텍스트가 사용됩니다; <em>ssl</em> 이 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 면, <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> 가 반환하는 기본 컨텍스트가 사용됩니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">SSL/TLS 보안 고려 사항</span></a></p>
</div>
</li>
<li><p><em>server_hostname</em>는 대상 서버의 인증서가 일치될 호스트 이름을 설정하거나 대체합니다. <em>ssl</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아닐 때만 전달되어야 합니다. 기본적으로 <em>host</em> 인자의 값이 사용됩니다. <em>host</em> 가 비어 있으면, 기본값이 없고 <em>server_hostname</em> 값을 전달해야 합니다. <em>server_hostname</em> 이 빈 문자열이면, 호스트 이름 일치가 비활성화됩니다 (이것은 심각한 보안 위험으로, 잠재적인 중간자 공격을 허용하게 됩니다).</p></li>
<li><p><em>family</em>, <em>proto</em>, <em>flags</em> 는 <em>host</em> 결정을 위해 getaddrinfo() 에 전달할 선택적 주소 패밀리, 프로토콜, 플래그입니다. 주어지면, 이것들은 모두 해당하는 <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 모듈 상수에 대응하는 정수여야 합니다.</p></li>
<li><p><em>happy_eyeballs_delay</em>, if given, enables Happy Eyeballs for this
connection. It should
be a floating-point number representing the amount of time in seconds
to wait for a connection attempt to complete, before starting the next
attempt in parallel. This is the &quot;Connection Attempt Delay&quot; as defined
in <span class="target" id="index-3"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc8305.html"><strong>RFC 8305</strong></a>. A sensible default value recommended by the RFC is <code class="docutils literal notranslate"><span class="pre">0.25</span></code>
(250 milliseconds).</p></li>
<li><p><em>interleave</em> controls address reordering when a host name resolves to
multiple IP addresses.
If <code class="docutils literal notranslate"><span class="pre">0</span></code> or unspecified, no reordering is done, and addresses are
tried in the order returned by <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>. If a positive integer
is specified, the addresses are interleaved by address family, and the
given integer is interpreted as &quot;First Address Family Count&quot; as defined
in <span class="target" id="index-4"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc8305.html"><strong>RFC 8305</strong></a>. The default is <code class="docutils literal notranslate"><span class="pre">0</span></code> if <em>happy_eyeballs_delay</em> is not
specified, and <code class="docutils literal notranslate"><span class="pre">1</span></code> if it is.</p></li>
<li><p><em>sock</em> 이 주어지면, 트랜스포트가 사용할, 기존의 이미 연결된 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> 객체여야 합니다. <em>sock</em> 이 주어지면, <em>host</em>, <em>port</em>, <em>family</em>, <em>proto</em>, <em>flags</em>, <em>happy_eyeballs_delay</em>, <em>interleave</em>, <em>local_addr</em> 를 지정해서는 안 됩니다.</p></li>
<li><p><em>local_addr</em> 이 주어지면, 소켓을 로컬에 바인드 하는데 사용되는 <code class="docutils literal notranslate"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> 튜플이어야 합니다. <em>local_host</em> 와 <em>local_port</em> 는 <em>host</em> 및 <em>port</em> 와 유사하게 <code class="docutils literal notranslate"><span class="pre">getaddrinfo()</span></code> 를 사용하여 조회됩니다.</p></li>
<li><p><em>ssl_handshake_timeout</em> 은 (TLS 연결의 경우) 연결을 중단하기 전에 TLS 핸드 셰이크가 완료될 때까지 대기하는 시간(초)입니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal notranslate"><span class="pre">60.0</span></code> 초가 사용됩니다.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가: </span>The <em>happy_eyeballs_delay</em> and <em>interleave</em> parameters.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>소켓 옵션 <code class="xref py py-data docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code>는 기본적으로 모든 TCP 연결에 대해 설정됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>에 SSL/TLS에 대한 지원이 추가되었습니다.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_connection()</span></code></a> 함수는 고수준 대안 API입니다. async/await 코드에서 직접 사용할 수 있는 (<a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>) 쌍을 반환합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.create_datagram_endpoint">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">create_datagram_endpoint</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>local_addr=None</em>, <em>remote_addr=None</em>, <em>*</em>, <em>family=0</em>, <em>proto=0</em>, <em>flags=0</em>, <em>reuse_address=None</em>, <em>reuse_port=None</em>, <em>allow_broadcast=None</em>, <em>sock=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_datagram_endpoint" title="정의 주소">¶</a></dt>
<dd><p>데이터 그램 연결을 만듭니다.</p>
<p>소켓 패밀리는 <em>host</em>(또는 주어지면 <em>family</em>)에 따라 <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET</span></code></a>, <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> 또는 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>일 수 있습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><em>host</em> 라는 인자는 없습니다. <em>host</em> 는 <em>local_addr</em> 이나 <em>remote_addr</em> 에 포함된
<em>local_host</em> 와 <em>remote_host</em> 를 뜻합니다.</p>
</div>
<p>소켓 유형은 <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code></a>이 됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>스트림 소켓은 유닉스 도메인 소켓(<a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>)이 별도의 메서드
<code class="xref py py-meth docutils literal notranslate"><span class="pre">AbstractEventLoop.create_unix_connection()</span></code> 로 분리되어 있으나,
데이터 그램 소켓의 경우는 이 메서드에서 모두 다룹니다. 하지만 소켓 유형
<a class="reference internal" href="socket.html#socket.SOCK_SEQPACKET" title="socket.SOCK_SEQPACKET"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_SEQPACKET</span></code></a> 을 지원하지 않습니다.</p>
</div>
<p><em>protocol_factory</em> 는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜</span></a> 구현을 반환하는 콜러블이어야 합니다.</p>
<p>성공하면 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 튜플이 반환됩니다.</p>
<p>다른 인자들:</p>
<ul>
<li><p><em>local_addr</em> 이 주어지면, 소켓을 로컬에 바인드 하는 데 사용되는 <code class="docutils literal notranslate"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> 튜플입니다. <em>local_host</em> 와 <em>local_port</em> 는 <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>를 사용하여 조회됩니다.</p></li>
<li><p><em>remote_addr</em> 이 주어지면, 소켓을 원격 주소에 연결하는 데 사용되는 <code class="docutils literal notranslate"><span class="pre">(remote_host,</span> <span class="pre">remote_port)</span></code> 튜플입니다. <em>remote_host</em> 와 <em>remote_port</em> 는 <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>를 사용하여 조회됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>데이터 그램 소켓에서, 연결한다는 것은 데이터 그램을 전송할 대상을 <em>remote_addr</em> 로 고정한다는 의미입니다.
따라서 <em>remote_addr</em> 이 제공되지 않으면 연결되지 않은 데이터 그램 소켓이 만들어지는데, 이 경우도
성공적인 것으로 판단합니다.</p>
</div>
</li>
<li><p><em>family</em>, <em>proto</em>, <em>flags</em> 는 <em>host</em> 결정을 위해 <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> 에 전달할 선택적 주소 패밀리, 프로토콜, 플래그입니다. 주어지면, 이것들은 모두 해당하는 <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 모듈 상수에 대응하는 정수여야 합니다.</p></li>
<li><p><em>reuse_address</em> 는, 일반적인 시간제한이 만료될 때까지 기다리지 않고, <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code> 상태의 로컬 소켓을 재사용하도록 커널에 알려줍니다. 지정하지 않으면 유닉스에서 자동으로 <code class="docutils literal notranslate"><span class="pre">True</span></code> 로 설정됩니다.</p></li>
<li><p><em>reuse_port</em> 는 모두 만들 때 이 플래그를 설정하는 한, 이 말단이 다른 기존 말단이 바인드 된 것과 같은 포트에 바인드 되도록 허용하도록 커널에 알려줍니다. 이 옵션은 윈도우나 일부 유닉스에서는 지원되지 않습니다. <code class="xref py py-data docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code> 상수가 정의되어 있지 않으면, 이 기능은 지원되지 않는 것입니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>지원되지 않는 경우 이 옵션을 지정하면 예외를 일으킵니다.</p>
</div>
</li>
<li><p><em>allow_broadcast</em> 는 이 말단이 브로드캐스트 주소로 메시지를 보낼 수 있도록 커널에 알립니다.</p></li>
<li><p><em>sock</em> 은 트랜스포트가 사용할 소켓 객체로, 기존의 이미 연결된 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> 객체를 사용하기 위해 선택적으로 지정할 수 있습니다. 지정되면 <em>local_addr</em> 과 <em>remote_addr</em> 를 생략해야 합니다 (반드시 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이어야 합니다).</p></li>
</ul>
<p><a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-client-protocol"><span class="std std-ref">UDP 메아리 클라이언트 프로토콜</span></a> 과 <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-server-protocol"><span class="std std-ref">UDP 메아리 서버 프로토콜</span></a> 예제를 참고하세요.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4.4에서 변경: </span><em>family</em>, <em>proto</em>, <em>flags</em>, <em>reuse_address</em>, <em>reuse_port</em>, <em>allow_broadcast</em>, <em>sock</em> 매개 변수가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>Added support for Windows.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.create_unix_connection">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">create_unix_connection</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>path=None</em>, <em>*</em>, <em>ssl=None</em>, <em>sock=None</em>, <em>server_hostname=None</em>, <em>ssl_handshake_timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_unix_connection" title="정의 주소">¶</a></dt>
<dd><p>유닉스 연결을 만듭니다.</p>
<p>소켓 패밀리는 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>가 됩니다; 소켓 유형은 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>이 됩니다.</p>
<p>성공하면 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 튜플이 반환됩니다.</p>
<p><em>path</em> 는 유닉스 도메인 소켓의 이름이며, <em>sock</em> 매개 변수가 지정되지 않으면 필수입니다. 추상 유닉스 소켓, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> 경로가 지원됩니다.</p>
<p>이 메서드의 인자에 관한 정보는 <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> 메서드의 설명서를 참조하십시오.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>path</em> 매개 변수는 이제 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a> 가 될 수 있습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="creating-network-servers">
<h3><a class="toc-backref" href="#id6">네트워크 서버 만들기</a><a class="headerlink" href="#creating-network-servers" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.loop.create_server">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">create_server</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>host=None</em>, <em>port=None</em>, <em>*</em>, <em>family=socket.AF_UNSPEC</em>, <em>flags=socket.AI_PASSIVE</em>, <em>sock=None</em>, <em>backlog=100</em>, <em>ssl=None</em>, <em>reuse_address=None</em>, <em>reuse_port=None</em>, <em>ssl_handshake_timeout=None</em>, <em>start_serving=True</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_server" title="정의 주소">¶</a></dt>
<dd><p><em>host</em> 주소의 <em>port</em> 에서 리스닝하는 TCP 서버(소켓 유형 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>)를 만듭니다.</p>
<p><a class="reference internal" href="#asyncio.Server" title="asyncio.Server"><code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code></a> 객체를 반환합니다.</p>
<p>인자:</p>
<ul>
<li><p><em>protocol_factory</em> 는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜</span></a> 구현을 반환하는 콜러블이어야 합니다.</p></li>
<li><p><em>host</em> 매개 변수는 서버가 리스닝할 위치를 결정하는 여러 형으로 설정할 수 있습니다.:</p>
<ul class="simple">
<li><p><em>host</em>가 문자열이면, TCP 서버는 <em>host</em>로 지정된 단일 네트워크 인터페이스에 바인딩 됩니다.</p></li>
<li><p><em>host</em>가 문자열의 시퀀스면, TCP 서버는 시퀀스로 지정된 모든 네트워크 인터페이스에 바인딩 됩니다.</p></li>
<li><p><em>host</em>가 빈 문자열이거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, 모든 인터페이스가 사용되는 것으로 가정하고, 여러 소켓의 리스트가 반환됩니다 (대체로 IPv4 하나와 IPv6 하나).</p></li>
</ul>
</li>
<li><p><em>family</em> 는 <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal notranslate"><span class="pre">socket.AF_INET</span></code></a> 또는 <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> 중 하나로 설정되어, 소켓이 IPv4 또는 IPv6을 사용하게 할 수 있습니다. 설정되지 않으면, <em>family</em> 는 호스트 이름에 의해 결정됩니다(기본값 <code class="xref py py-data docutils literal notranslate"><span class="pre">socket.AF_UNSPEC</span></code>).</p></li>
<li><p><em>flags</em> 은 <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>를 위한 비트 마스크입니다.</p></li>
<li><p><em>sock</em> 은 기존 소켓 객체를 사용하기 위해 선택적으로 지정할 수 있습니다. 지정되면, <em>host</em> 및 <em>port</em> 는 지정할 수 없습니다.</p></li>
<li><p><em>backlog</em> 는 <a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a> 으로 전달되는 최대 대기 연결 수 입니다 (기본값은 100).</p></li>
<li><p><em>ssl</em> 을 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 인스턴스로 설정하면, 들어오는 연결에 TLS를 사용합니다.</p></li>
<li><p><em>reuse_address</em> 는, 일반적인 시간제한이 만료될 때까지 기다리지 않고, <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code> 상태의 로컬 소켓을 재사용하도록 커널에 알려줍니다. 지정하지 않으면 유닉스에서 자동으로 <code class="docutils literal notranslate"><span class="pre">True</span></code> 로 설정됩니다.</p></li>
<li><p><em>reuse_port</em> 는 모두 만들 때 이 플래그를 설정하는 한, 이 말단이 다른 기존 말단이 바인드 된 것과 같은 포트에 바인드 되도록 허용하도록 커널에 알려줍니다. 이 옵션은 윈도우에서 지원되지 않습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>지원되지 않는 경우 이 옵션을 지정하면 예외를 일으킵니다.</p>
</div>
</li>
<li><p><em>ssl_handshake_timeout</em> 은 (TLS 서버의 경우) 연결을 중단하기 전에 TLS 핸드 셰이크가 완료될 때까지 대기하는 시간(초)입니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal notranslate"><span class="pre">60.0</span></code> 초가 사용됩니다.</p></li>
<li><p><em>start_serving</em> 을 <code class="docutils literal notranslate"><span class="pre">True</span></code> (기본값) 로 설정하면, 생성된 서버가 즉시 연결을 받아들입니다. <code class="docutils literal notranslate"><span class="pre">False</span></code> 로 설정되면, 사용자는 서버가 연결을 받기 시작하도록 <a class="reference internal" href="#asyncio.Server.start_serving" title="asyncio.Server.start_serving"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.start_serving()</span></code></a> 이나 <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.serve_forever()</span></code></a>를 await 해야 합니다.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 과 <em>start_serving</em> 매개 변수 추가.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>소켓 옵션 <code class="xref py py-data docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code>는 기본적으로 모든 TCP 연결에 대해 설정됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>에 SSL/TLS에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5.1에서 변경: </span><em>host</em> 매개 변수는 문자열의 시퀀스가 될 수 있습니다.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a> 함수는 async/await 코드에서 사용할 수 있는 <a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> 및 <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> 쌍을 반환하는 고수준의 대체 API입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.create_unix_server">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">create_unix_server</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>path=None</em>, <em>*</em>, <em>sock=None</em>, <em>backlog=100</em>, <em>ssl=None</em>, <em>ssl_handshake_timeout=None</em>, <em>start_serving=True</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_unix_server" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>와 유사하지만, 소켓 패밀리 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> 용입니다.</p>
<p><em>path</em> 는 유닉스 도메인 소켓의 이름이며, <em>sock</em> 매개 변수가 제공되지 않으면 필수입니다. 추상 유닉스 소켓, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> 경로가 지원됩니다.</p>
<p>이 메서드의 인자에 대한 정보는 <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> 메서드의 설명서를 참조하십시오.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 과 <em>start_serving</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>path</em> 매개 변수는 이제 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> 객체일 수 있습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.connect_accepted_socket">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">connect_accepted_socket</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>sock</em>, <em>*</em>, <em>ssl=None</em>, <em>ssl_handshake_timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_accepted_socket" title="정의 주소">¶</a></dt>
<dd><p>이미 받아들인 연결을 트랜스포트/프로토콜 쌍으로 래핑합니다.</p>
<p>이 메서드는 asyncio 밖에서 연결을 받아들이지만, 그 연결을 처리하는데 asyncio 를 사용하는 서버에서 사용됩니다.</p>
<p>매개 변수:</p>
<ul class="simple">
<li><p><em>protocol_factory</em> 는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜</span></a> 구현을 반환하는 콜러블이어야 합니다.</p></li>
<li><p><em>sock</em> 은 <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.accept</span></code></a> 가 반환한 기존 소켓 객체입니다.</p></li>
<li><p><em>ssl</em> 을 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 로 설정하면, 들어오는 연결에 SSL을 사용합니다.</p></li>
<li><p><em>ssl_handshake_timeout</em> 은 (SSL 연결의 경우) 연결을 중단하기 전에 SSL 핸드 셰이크가 완료될 때까지 대기하는 시간(초)입니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal notranslate"><span class="pre">60.0</span></code> 초가 사용됩니다.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span><em>ssl_handshake_timeout</em> 매개 변수.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.3에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="transferring-files">
<h3><a class="toc-backref" href="#id7">파일 전송</a><a class="headerlink" href="#transferring-files" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.loop.sendfile">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">sendfile</code><span class="sig-paren">(</span><em>transport</em>, <em>file</em>, <em>offset=0</em>, <em>count=None</em>, <em>*</em>, <em>fallback=True</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sendfile" title="정의 주소">¶</a></dt>
<dd><p><em>file</em> 을 <em>transport</em> 로 보냅니다. 전송된 총 바이트 수를 반환합니다.</p>
<p>이 메서드는 가능한 경우 고성능 <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">os.sendfile()</span></code></a> 을 사용합니다.</p>
<p><em>file</em> 는 바이너리 모드로 열린 일반 파일 객체여야 합니다.</p>
<p><em>offset</em> 은 파일 읽기 시작할 위치를 알려줍니다. <em>count</em> 를 제공하면, EOF에 도달할 때까지 파일을 보내는 대신, 전송할 총 바이트 수를 지정합니다. 파일의 위치가 갱신됩니다, 이 메서드가 에러를 일으킬 때조차. 그리고, <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> 는 실제 전송된 바이트 수를 얻는 데 사용될 수 있습니다.</p>
<p><em>fallback</em> 을 <code class="docutils literal notranslate"><span class="pre">True</span></code> 로 설정하면, 플랫폼이 sendfile 시스템 호출을 지원하지 않을 때 (가령 유닉스에서 SSL 소켓을 사용하거나 윈도우인 경우), asyncio 가 파일을 수동으로 읽고 보내도록 합니다.</p>
<p>시스템이 <em>sendfile</em> 시스템 호출을 지원하지 않고 <em>fallback</em> 이 <code class="docutils literal notranslate"><span class="pre">False</span></code> 면 <a class="reference internal" href="asyncio-exceptions.html#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SendfileNotAvailableError</span></code></a> 를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="tls-upgrade">
<h3><a class="toc-backref" href="#id8">TLS 업그레이드</a><a class="headerlink" href="#tls-upgrade" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.loop.start_tls">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">start_tls</code><span class="sig-paren">(</span><em>transport</em>, <em>protocol</em>, <em>sslcontext</em>, <em>*</em>, <em>server_side=False</em>, <em>server_hostname=None</em>, <em>ssl_handshake_timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.start_tls" title="정의 주소">¶</a></dt>
<dd><p>기존 트랜스포트 기반 연결을 TLS로 업그레이드합니다.</p>
<p><em>protocol</em> 이 <em>await</em> 의 직후에 사용해야 하는 새로운 트랜스포트 인스턴스를 반환합니다. <em>start_tls</em> 메서드에 전달된 <em>transport</em> 인스턴스는 절대로 다시 사용해서는 안 됩니다.</p>
<p>매개 변수:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a>와 <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_connection()</span></code></a> 같은 메서드가 반환하는 <em>transport</em> 와 <em>protocol</em> 인스턴스.</p></li>
<li><p><em>sslcontext</em>: 구성된 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 의 인스턴스.</p></li>
<li><p>(<a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a> 에 의해 생성된 것과 같은) 서버 측 연결이 업그레이드될 때 <em>server_side</em> 에 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 전달합니다.</p></li>
<li><p><em>server_hostname</em>: 대상 서버의 인증서가 일치될 호스트 이름을 설정하거나 대체합니다.</p></li>
<li><p><em>ssl_handshake_timeout</em> 은 (TLS 연결의 경우) 연결을 중단하기 전에 TLS 핸드 셰이크가 완료될 때까지 대기하는 시간(초)입니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> (기본값) 이면 <code class="docutils literal notranslate"><span class="pre">60.0</span></code> 초가 사용됩니다.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="watching-file-descriptors">
<h3><a class="toc-backref" href="#id9">파일 기술자 관찰하기</a><a class="headerlink" href="#watching-file-descriptors" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.loop.add_reader">
<code class="descclassname">loop.</code><code class="descname">add_reader</code><span class="sig-paren">(</span><em>fd</em>, <em>callback</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_reader" title="정의 주소">¶</a></dt>
<dd><p><em>fd</em> 파일 기술자가 읽기 가능한지 관찰하기 시작하고, 일단 <em>fd</em>가 읽기 가능해지면 지정한 인자로 <em>callback</em> 을 호출합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.remove_reader">
<code class="descclassname">loop.</code><code class="descname">remove_reader</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_reader" title="정의 주소">¶</a></dt>
<dd><p><em>fd</em> 파일 기술자가 읽기 가능한지 관찰하는 것을 중단합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.add_writer">
<code class="descclassname">loop.</code><code class="descname">add_writer</code><span class="sig-paren">(</span><em>fd</em>, <em>callback</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_writer" title="정의 주소">¶</a></dt>
<dd><p><em>fd</em> 파일 기술자가 쓰기 가능한지 관찰하기 시작하고, 일단 <em>fd</em>가 쓰기 가능해지면 지정한 인자로 <em>callback</em> 을 호출합니다.</p>
<p><em>callback</em> 에 <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">키워드 인자를 전달하려면</span></a> <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>를 사용하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.remove_writer">
<code class="descclassname">loop.</code><code class="descname">remove_writer</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_writer" title="정의 주소">¶</a></dt>
<dd><p><em>fd</em> 파일 기술자가 쓰기 가능한지 관찰하는 것을 중단합니다.</p>
</dd></dl>

<p>이 메서드의 일부 제한 사항은 <a class="reference internal" href="asyncio-platforms.html#asyncio-platform-support"><span class="std std-ref">플랫폼 지원</span></a> 절을 참조하십시오.</p>
</div>
<div class="section" id="working-with-socket-objects-directly">
<h3><a class="toc-backref" href="#id10">소켓 객체로 직접 작업하기</a><a class="headerlink" href="#working-with-socket-objects-directly" title="제목 주소">¶</a></h3>
<p>일반적으로 <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> 및 <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>와 같은 트랜스포트 기반 API를 사용하는 프로토콜 구현은 소켓을 직접 사용하는 구현보다 빠릅니다. 그러나, 성능이 결정적이지 않고 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 객체로 직접 작업하는 것이 더 편리한 사용 사례가 있습니다.</p>
<dl class="method">
<dt id="asyncio.loop.sock_recv">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">sock_recv</code><span class="sig-paren">(</span><em>sock</em>, <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recv" title="정의 주소">¶</a></dt>
<dd><p><em>sock</em> 에서 최대 <em>nbytes</em> 를 수신합니다. <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv()</span></code></a> 의 비동기 버전.</p>
<p>수신한 데이터를 바이트열 객체로 반환합니다.</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>를 반환했습니다. 파이썬 3.7부터, 이것은 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 메서드입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.sock_recv_into">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">sock_recv_into</code><span class="sig-paren">(</span><em>sock</em>, <em>buf</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recv_into" title="정의 주소">¶</a></dt>
<dd><p><em>sock</em> 에서 <em>buf</em> 버퍼로 데이터를 수신합니다. 블로킹 <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv_into()</span></code></a> 메서드를 따라 만들어졌습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>소켓 IO 의 성능은 수반되는 복사에 크게 영향을 받습니다. <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.recv()</span></code></a>
메서드는 수신 데이터를 반환값으로 제공하기 때문에 <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.recv_into()</span></code></a>
메서드에 비해 복사가 한 번 더 일어날 수 있습니다. 하지만 여전히
<a class="reference internal" href="socket.html#socket.socket.recvmsg_into" title="socket.socket.recvmsg_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.recvmsg_into()</span></code></a> 메서드를 사용하는 Scatter/Gather IO는
제공되지 않고 있습니다.</p>
</div>
<p>버퍼에 기록된 바이트 수를 돌려줍니다.</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.sock_sendall">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">sock_sendall</code><span class="sig-paren">(</span><em>sock</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendall" title="정의 주소">¶</a></dt>
<dd><p><em>data</em> 를 <em>sock</em> 소켓으로 보냅니다. <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendall()</span></code></a> 의 비동기 버전.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>역시 <a class="reference internal" href="socket.html#socket.socket.sendmsg" title="socket.socket.sendmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.sendmsg()</span></code></a> 메서드를 사용하는 Scatter/Gather IO는
지원되지 않습니다.</p>
</div>
<p>이 메서드는 <em>data</em> 의 모든 데이터가 송신되거나 에러가 발생할 때까지 소켓으로 계속 송신합니다. 성공하면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 반환됩니다. 에러가 발생하면 예외가 발생합니다. 또한, 연결의 수신 단에서 성공적으로 처리한 (있기는 하다면) 데이터의 크기를 확인하는 방법은 없습니다.</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>를 반환했습니다. 파이썬 3.7부터, 이것은 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 메서드입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.sock_connect">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">sock_connect</code><span class="sig-paren">(</span><em>sock</em>, <em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_connect" title="정의 주소">¶</a></dt>
<dd><p><em>sock</em>을 <em>address</em>에 있는 원격 소켓에 연결합니다.</p>
<p><a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code></a> 의 비동기 버전.</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5.2에서 변경: </span><code class="docutils literal notranslate"><span class="pre">address</span></code> 는 더는 결정될 필요가 없습니다. <code class="docutils literal notranslate"><span class="pre">sock_connect</span></code> 는 <a class="reference internal" href="socket.html#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.inet_pton()</span></code></a>을 호출하여 <em>address</em> 가 이미 결정되었는지를 검사합니다. 그렇지 않으면, <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.getaddrinfo()</span></code></a> 가 <em>address</em> 를 결정하는 데 사용됩니다.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>과 <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.sock_accept">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">sock_accept</code><span class="sig-paren">(</span><em>sock</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_accept" title="정의 주소">¶</a></dt>
<dd><p>연결을 받아들입니다. 블로킹 <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.accept()</span></code></a> 메서드를 따라 만들어졌습니다.</p>
<p>소켓은 주소에 바인드 되어 연결을 리스닝해야 합니다. 반환 값은 <code class="docutils literal notranslate"><span class="pre">(conn,</span> <span class="pre">address)</span></code> 쌍인데, <em>conn</em> 은 연결로 데이터를 주고받을 수 있는 <em>새</em> 소켓 객체이고, <em>address</em> 는 연결의 반대편 끝의 소켓에 바인드 된 주소입니다.</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>를 반환했습니다. 파이썬 3.7부터, 이것은 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> 메서드입니다.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>와 <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.sock_sendfile">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">sock_sendfile</code><span class="sig-paren">(</span><em>sock</em>, <em>file</em>, <em>offset=0</em>, <em>count=None</em>, <em>*</em>, <em>fallback=True</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendfile" title="정의 주소">¶</a></dt>
<dd><p>가능하면 고성능 <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a> 을 사용하여 파일을 보냅니다. 전송된 총 바이트 수를 반환합니다.</p>
<p><a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendfile()</span></code></a>의 비동기 버전.</p>
<p><em>sock</em> 은 반드시 비 블로킹 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code></a> <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 이어야 합니다.</p>
<p><em>file</em> 는 바이너리 모드로 열린 일반 파일 객체여야 합니다.</p>
<p><em>offset</em> 은 파일 읽기 시작할 위치를 알려줍니다. <em>count</em> 를 제공하면, EOF에 도달할 때까지 파일을 보내는 대신, 전송할 총 바이트 수를 지정합니다. 파일의 위치가 갱신됩니다, 이 메서드가 에러를 일으킬 때조차. 그리고, <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> 는 실제 전송된 바이트 수를 얻는 데 사용될 수 있습니다.</p>
<p><em>fallback</em> 을 <code class="docutils literal notranslate"><span class="pre">True</span></code> 로 설정하면, 플랫폼이 sendfile 시스템 호출을 지원하지 않을 때 (가령 유닉스에서 SSL 소켓을 사용하거나 윈도우인 경우), asyncio 가 파일을 수동으로 읽고 보내도록 합니다.</p>
<p>시스템이 <em>sendfile</em> 시스템 호출을 지원하지 않고 <em>fallback</em> 이 <code class="docutils literal notranslate"><span class="pre">False</span></code> 면 <a class="reference internal" href="asyncio-exceptions.html#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SendfileNotAvailableError</span></code></a> 를 발생시킵니다.</p>
<p><em>sock</em> 은 반드시 비 블로킹 소켓이어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="dns">
<h3><a class="toc-backref" href="#id11">DNS</a><a class="headerlink" href="#dns" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.loop.getaddrinfo">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">getaddrinfo</code><span class="sig-paren">(</span><em>host</em>, <em>port</em>, <em>*</em>, <em>family=0</em>, <em>type=0</em>, <em>proto=0</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.getaddrinfo" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="socket.html#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getaddrinfo()</span></code></a> 의 비동기 버전.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.getnameinfo">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">getnameinfo</code><span class="sig-paren">(</span><em>sockaddr</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.getnameinfo" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="socket.html#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getnameinfo()</span></code></a> 의 비동기 버전.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>getaddrinfo</em> 와 <em>getnameinfo</em> 메서드는 모두 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에 실제로는 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 객체를 반환했습니다. 파이썬 3.7부터 두 가지 메서드 모두 코루틴입니다.</p>
</div>
</div>
<div class="section" id="working-with-pipes">
<h3><a class="toc-backref" href="#id12">파이프로 작업하기</a><a class="headerlink" href="#working-with-pipes" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.loop.connect_read_pipe">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">connect_read_pipe</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_read_pipe" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프에 <em>pipe</em>의 읽기용 끝을 등록합니다.</p>
<p><em>protocol_factory</em> 는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio 프로토콜</span></a> 구현을 반환하는 콜러블이어야 합니다.</p>
<p><em>pipe</em>는 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일류 객체</span></a>입니다.</p>
<p>쌍 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>를 반환합니다. 여기서 <em>transport</em>는 <a class="reference internal" href="asyncio-protocol.html#asyncio.ReadTransport" title="asyncio.ReadTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReadTransport</span></code></a> 인터페이스를 지원하고, <em>protocol</em>은 <em>protocol_factory</em>에 의해 인스턴스로 만들어진 객체입니다.</p>
<p><a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 이벤트 루프를 사용하면, <em>pipe</em> 는 비 블로킹 모드로 설정됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.connect_write_pipe">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">connect_write_pipe</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_write_pipe" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프에 <em>pipe</em>의 쓰기용 끝을 등록합니다.</p>
<p><em>protocol_factory</em> 는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio 프로토콜</span></a> 구현을 반환하는 콜러블이어야 합니다.</p>
<p><em>pipe</em>는 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일류 객체</span></a>입니다.</p>
<p>쌍 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>를 반환합니다. 여기서 <em>transport</em>는 <a class="reference internal" href="asyncio-protocol.html#asyncio.WriteTransport" title="asyncio.WriteTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">WriteTransport</span></code></a> 인터페이스를 지원하고, <em>protocol</em>은 <em>protocol_factory</em>에 의해 인스턴스로 만들어진 객체입니다.</p>
<p><a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 이벤트 루프를 사용하면, <em>pipe</em> 는 비 블로킹 모드로 설정됩니다.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">참고</p>
<p>윈도우에서 <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a>는 위의 메서드들을 지원하지 않습니다. 윈도우에서는 대신 <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>를 사용하십시오.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a> 와 <a class="reference internal" href="#asyncio.loop.subprocess_shell" title="asyncio.loop.subprocess_shell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_shell()</span></code></a> 메서드.</p>
</div>
</div>
<div class="section" id="unix-signals">
<h3><a class="toc-backref" href="#id13">유닉스 시그널</a><a class="headerlink" href="#unix-signals" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.loop.add_signal_handler">
<code class="descclassname">loop.</code><code class="descname">add_signal_handler</code><span class="sig-paren">(</span><em>signum</em>, <em>callback</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_signal_handler" title="정의 주소">¶</a></dt>
<dd><p><em>callback</em>을 <em>signum</em> 시그널의 처리기로 설정합니다.</p>
<p>콜백은 다른 대기 중인 콜백과 해당 이벤트 루프의 실행 가능한 코루틴과 함께 <em>loop</em>에 의해 호출됩니다. <a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a>을 사용하여 등록된 시그널 처리기와 달리, 이 함수로 등록된 콜백은 이벤트 루프와 상호 작용할 수 있습니다.</p>
<p>시그널 번호가 유효하지 않거나 잡을 수 없으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 를 발생시킵니다. 처리기를 설정하는 데 문제가 있는 경우 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 를 발생시킵니다.</p>
<p><em>callback</em> 에 <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">키워드 인자를 전달하려면</span></a> <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>를 사용하십시오.</p>
<p><a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a>와 마찬가지로, 이 함수는 메인 스레드에서 호출되어야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.remove_signal_handler">
<code class="descclassname">loop.</code><code class="descname">remove_signal_handler</code><span class="sig-paren">(</span><em>sig</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_signal_handler" title="정의 주소">¶</a></dt>
<dd><p><em>sig</em> 시그널의 처리기를 제거합니다.</p>
<p>시그널 처리기가 제거되면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를, 주어진 시그널에 처리기가 설정되지 않았으면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 를 반환합니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 모듈.</p>
</div>
</div>
<div class="section" id="executing-code-in-thread-or-process-pools">
<h3><a class="toc-backref" href="#id14">스레드 또는 프로세스 풀에서 코드를 실행하기</a><a class="headerlink" href="#executing-code-in-thread-or-process-pools" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.loop.run_in_executor">
<em class="property">awaitable </em><code class="descclassname">loop.</code><code class="descname">run_in_executor</code><span class="sig-paren">(</span><em>executor</em>, <em>func</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_in_executor" title="정의 주소">¶</a></dt>
<dd><p>지정된 실행기에서 <em>func</em> 가 호출되도록 배치합니다.</p>
<p><em>executor</em> 인자는 <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Executor" title="concurrent.futures.Executor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Executor</span></code></a> 인스턴스여야 합니다. <em>executor</em> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면 기본 실행기가 사용됩니다.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span>

<span class="k">def</span> <span class="nf">blocking_io</span><span class="p">():</span>
    <span class="c1"># 파일 연산(가령 로깅)은 이벤트 루프를 블록할 수 있습니다:</span>
    <span class="c1"># 스레드 풀에서 실행하십시오.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/dev/urandom&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cpu_bound</span><span class="p">():</span>
    <span class="c1"># CPU 병목 작업은 이벤트 루프를 블록합니다:</span>
    <span class="c1"># 일반적으로 프로세스 풀에서 실행하는 것이 좋습니다.</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">7</span><span class="p">))</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="c1">## 선택지:</span>

    <span class="c1"># 1. 기본 루프의 실행기에서 실행:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span> <span class="n">blocking_io</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;default thread pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 2. 사용자 정의 스레드 풀에서 실행:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">blocking_io</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom thread pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 3. 사용자 정의 프로세스 풀에서 실행:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">cpu_bound</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom process pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p>이 메서드는 <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 객체를 반환합니다.</p>
<p><em>func</em> 에 <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">키워드 인자를 전달하려면</span></a> <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>를 사용하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5.3에서 변경: </span><a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a> 는 더는 자신이 만드는 스레드 풀 실행기의 <code class="docutils literal notranslate"><span class="pre">max_workers</span></code> 를 설정하지 않습니다. 대신 스레드 풀 실행기(<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>)가 스스로 기본값을 설정하도록 합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.set_default_executor">
<code class="descclassname">loop.</code><code class="descname">set_default_executor</code><span class="sig-paren">(</span><em>executor</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_default_executor" title="정의 주소">¶</a></dt>
<dd><p><em>executor</em>를 <a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_in_executor()</span></code></a>에서 사용하는 기본 실행기로 설정합니다. <em>executor</em>는 <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>의 인스턴스여야 합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.8부터 폐지: </span><a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a> 인스턴스가 아닌 실행기의 사용은 폐지되었고, 파이썬 3.9에서는 에러를 일으키게 됩니다.</p>
</div>
<p><em>executor</em>는 반드시 <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.ThreadPoolExecutor</span></code></a>의 인스턴스여야 합니다.</p>
</dd></dl>

</div>
<div class="section" id="error-handling-api">
<h3><a class="toc-backref" href="#id15">에러 처리 API</a><a class="headerlink" href="#error-handling-api" title="제목 주소">¶</a></h3>
<p>이벤트 루프에서 예외를 처리하는 방법을 사용자 정의 할 수 있습니다.</p>
<dl class="method">
<dt id="asyncio.loop.set_exception_handler">
<code class="descclassname">loop.</code><code class="descname">set_exception_handler</code><span class="sig-paren">(</span><em>handler</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_exception_handler" title="정의 주소">¶</a></dt>
<dd><p><em>handler</em> 를 새 이벤트 루프 예외 처리기로 설정합니다.</p>
<p><em>handler</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, 기본 예외 처리기가 설정됩니다. 그렇지 않으면, <em>handler</em>는 반드시 <code class="docutils literal notranslate"><span class="pre">(loop,</span> <span class="pre">context)</span></code> 와 일치하는 서명을 가진 콜러블이어야 합니다. 여기서 <code class="docutils literal notranslate"><span class="pre">loop</span></code>는 활성 이벤트 루프에 대한 참조가 될 것이고, <code class="docutils literal notranslate"><span class="pre">context</span></code> 는 예외에 관한 세부 정보를 담고 있는 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 객체가 됩니다 (context에 대한 자세한 내용은 <a class="reference internal" href="#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_exception_handler()</span></code></a> 문서를 참조하십시오).</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.get_exception_handler">
<code class="descclassname">loop.</code><code class="descname">get_exception_handler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_exception_handler" title="정의 주소">¶</a></dt>
<dd><p>현재 예외 처리기를 반환하거나, 사용자 정의 예외 처리기가 설정되지 않았으면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.default_exception_handler">
<code class="descclassname">loop.</code><code class="descname">default_exception_handler</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.default_exception_handler" title="정의 주소">¶</a></dt>
<dd><p>기본 예외 처리기.</p>
<p>예외가 발생하고 예외 처리기가 설정되지 않았을 때 호출됩니다. 기본 동작으로 위임하려는 사용자 정의 예외 처리기가 호출할 수 있습니다.</p>
<p><em>context</em> 매개 변수는 <a class="reference internal" href="#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_exception_handler()</span></code></a> 에서와 같은 의미입니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.call_exception_handler">
<code class="descclassname">loop.</code><code class="descname">call_exception_handler</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_exception_handler" title="정의 주소">¶</a></dt>
<dd><p>현재 이벤트 루프 예외 처리기를 호출합니다.</p>
<p><em>context</em> 는 다음 키를 포함하는 <code class="docutils literal notranslate"><span class="pre">dict</span></code> 객체입니다 (새 키가 미래의 파이썬 버전에서 추가될 수 있습니다):</p>
<ul class="simple">
<li><p>'message': 에러 메시지;</p></li>
<li><p>'exception' (선택적): 예외 객체;</p></li>
<li><p>'future' (선택적): <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 인스턴스;</p></li>
<li><p>'handle' (선택적): <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Handle</span></code></a> 인스턴스;</p></li>
<li><p>'protocol' (선택적): <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">프로토콜</span></a> 인스턴스;</p></li>
<li><p>'transport' (선택적): <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">트랜스포트</span></a> 인스턴스;</p></li>
<li><p>'socket' (선택적): <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> 인스턴스.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 메서드는 서브 클래스 된 이벤트 루프에서 재정의되지 않아야 합니다. 사용자 정의 예외 처리를 위해서는 <a class="reference internal" href="#asyncio.loop.set_exception_handler" title="asyncio.loop.set_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_exception_handler()</span></code></a> 메서드를 사용하십시오.</p>
</div>
</dd></dl>

</div>
<div class="section" id="enabling-debug-mode">
<h3><a class="toc-backref" href="#id16">디버그 모드 활성화</a><a class="headerlink" href="#enabling-debug-mode" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.loop.get_debug">
<code class="descclassname">loop.</code><code class="descname">get_debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_debug" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프의 디버그 모드(<a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>)를 가져옵니다.</p>
<p>기본값은 환경 변수 <span class="target" id="index-13"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONASYNCIODEBUG"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONASYNCIODEBUG</span></code></a> 가 비어 있지 않은 문자열로 설정되면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 이고, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 입니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.set_debug">
<code class="descclassname">loop.</code><code class="descname">set_debug</code><span class="sig-paren">(</span><em>enabled: bool</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_debug" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프의 디버그 모드를 설정합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이제 새로운 <code class="docutils literal notranslate"><span class="pre">-X</span> <span class="pre">dev</span></code> 명령 줄 옵션을 사용하여 디버그 모드를 활성화할 수 있습니다.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="asyncio-dev.html#asyncio-debug-mode"><span class="std std-ref">asyncio의 디버그 모드</span></a>.</p>
</div>
</div>
<div class="section" id="running-subprocesses">
<h3><a class="toc-backref" href="#id17">자식 프로세스 실행하기</a><a class="headerlink" href="#running-subprocesses" title="제목 주소">¶</a></h3>
<p>이 하위 절에서 설명하는 메서드는 저수준입니다. 일반적인 async/await 코드에서는 대신 고수준의 <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_shell" title="asyncio.create_subprocess_shell"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_shell()</span></code></a> 및 <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_exec" title="asyncio.create_subprocess_exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_exec()</span></code></a> 편리 함수를 사용하는 것을 고려하십시오.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><strong>Windows</strong> 의 기본 asyncio 이벤트 루프는 자식 프로세스를 지원하지 않습니다. 자세한 내용은 <a class="reference internal" href="asyncio-platforms.html#asyncio-windows-subprocess"><span class="std std-ref">윈도우에서의 자식 프로세스 지원</span></a>을 참조하십시오.</p>
</div>
<dl class="method">
<dt id="asyncio.loop.subprocess_exec">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">subprocess_exec</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>*args</em>, <em>stdin=subprocess.PIPE</em>, <em>stdout=subprocess.PIPE</em>, <em>stderr=subprocess.PIPE</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.subprocess_exec" title="정의 주소">¶</a></dt>
<dd><p><em>args</em>로 지정된 하나 이상의 문자열 인자로 서브 프로세스를 만듭니다.</p>
<p><em>args</em>는 반드시 다음과 같은 것으로 표현되는 문자열의 목록이어야 합니다:</p>
<ul class="simple">
<li><p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>;</p></li>
<li><p>또는 <a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">파일 시스템 인코딩</span></a>으로로 인코딩된 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p></li>
</ul>
<p>첫 번째 문자열은 프로그램 실행 파일을 지정하고, 나머지 문자열은 인자를 지정합니다. 함께, 문자열 인자들은 프로그램의 <code class="docutils literal notranslate"><span class="pre">argv</span></code>를 구성합니다.</p>
<p>이것은 <code class="docutils literal notranslate"><span class="pre">shell=False</span></code>와 문자열의 목록을 첫 번째 인자로 호출된 표준 라이브러리 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 클래스와 유사합니다. 그러나 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">Popen</span></code></a>이 문자열 목록인 단일 인자를 받아들이지만, <em>subprocess_exec</em>는 여러 문자열 인자를 받아들입니다.</p>
<p><em>protocol_factory</em>는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessProtocol</span></code></a> 클래스의 서브 클래스를 반환하는 콜러블이어야 합니다.</p>
<p>다른 매개 변수:</p>
<ul>
<li><p><em>stdin</em> can be any of these:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_write_pipe()</span></code></a>를 사용하여 자식 프로세스의 표준 입력 스트림에 연결될 파이프를 나타내는 파일류 객체</p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> 상수 (기본값), 새 파이프를 만들고 연결합니다,</p></li>
<li><p>the value <code class="docutils literal notranslate"><span class="pre">None</span></code> which will make the subprocess inherit the file
descriptor from this process</p></li>
<li><p>the <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> constant which indicates that the
special <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> file will be used</p></li>
</ul>
</li>
<li><p><em>stdout</em> can be any of these:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_write_pipe()</span></code></a>를 사용하여 자식 프로세스의 표준 출력 스트림에 연결될 파이프를 나타내는 파일류 객체</p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> 상수 (기본값), 새 파이프를 만들고 연결합니다,</p></li>
<li><p>the value <code class="docutils literal notranslate"><span class="pre">None</span></code> which will make the subprocess inherit the file
descriptor from this process</p></li>
<li><p>the <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> constant which indicates that the
special <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> file will be used</p></li>
</ul>
</li>
<li><p><em>stderr</em> can be any of these:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_write_pipe()</span></code></a>를 사용하여 자식 프로세스의 표준 에러 스트림에 연결될 파이프를 나타내는 파일류 객체</p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> 상수 (기본값), 새 파이프를 만들고 연결합니다,</p></li>
<li><p>the value <code class="docutils literal notranslate"><span class="pre">None</span></code> which will make the subprocess inherit the file
descriptor from this process</p></li>
<li><p>the <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> constant which indicates that the
special <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> file will be used</p></li>
<li><p><a class="reference internal" href="subprocess.html#subprocess.STDOUT" title="subprocess.STDOUT"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.STDOUT</span></code></a> 상수, 표준 에러 스트림을 프로세스의 표준 출력 스트림에 연결합니다</p></li>
</ul>
</li>
<li><p>다른 모든 키워드 인자는 해석 없이 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a>로 전달됩니다. 다만, <em>bufsize</em>, <em>universal_newlines</em>, <em>shell</em>, <em>text</em>, <em>encoding</em> 및 <em>errors</em>는 예외인데, 이것들은 지정되지 않아야 합니다.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">asyncio</span></code> subprocess API does not support decoding the streams
as text. <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> can be used to convert the bytes returned
from the stream to text.</p>
</li>
</ul>
<p>다른 인자에 관한 설명은 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 클래스의 생성자를 참조하십시오.</p>
<p><code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다. 여기에서 <em>transport</em>는 <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessTransport</span></code></a> 베이스 클래스를 따르고, <em>protocol</em>은 <em>protocol_factory</em>에 의해 인스턴스로 만들어진 객체입니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.loop.subprocess_shell">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">subprocess_shell</code><span class="sig-paren">(</span><em>protocol_factory</em>, <em>cmd</em>, <em>*</em>, <em>stdin=subprocess.PIPE</em>, <em>stdout=subprocess.PIPE</em>, <em>stderr=subprocess.PIPE</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.subprocess_shell" title="정의 주소">¶</a></dt>
<dd><p>플랫폼의 &quot;셸&quot; 구문을 사용하는 <em>cmd</em>로 자식 프로세스를 만듭니다. <em>cmd</em>는 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>이나 <a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">파일 시스템 인코딩</span></a>으로 인코딩된 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 일 수 있습니다.</p>
<p>이것은 <code class="docutils literal notranslate"><span class="pre">shell=True</span></code>로 호출된 표준 라이브러리 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 클래스와 유사합니다.</p>
<p><em>protocol_factory</em>는 반드시 <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessProtocol</span></code></a> 클래스의 서브 클래스를 반환하는 콜러블이어야 합니다.</p>
<p>나머지 인자에 관한 자세한 내용은 <a class="reference internal" href="#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess_exec()</span></code></a>를 참조하십시오.</p>
<p><code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> 쌍을 반환합니다. 여기서 <em>transport</em>는 <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessTransport</span></code></a> 베이스 클래스를 따르고, <em>protocol</em>은 <em>protocol_factory</em>에 의해 인스턴스로 만들어진 객체입니다.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Shell_injection#Shell_injection">셸 주입</a> 취약점을 피하고자 모든 공백과 특수 문자를 적절하게 따옴표 처리하는 것은 응용 프로그램의 책임입니다. <a class="reference internal" href="shlex.html#shlex.quote" title="shlex.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">shlex.quote()</span></code></a> 함수를 사용하여 셸 명령을 구성하는 데 사용될 문자열에 있는 공백 및 특수 문자를 올바르게 이스케이프 할 수 있습니다.</p>
</div>
</div>
</div>
<div class="section" id="callback-handles">
<h2>콜백 핸들<a class="headerlink" href="#callback-handles" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="asyncio.Handle">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">Handle</code><a class="headerlink" href="#asyncio.Handle" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a>, <a class="reference internal" href="#asyncio.loop.call_soon_threadsafe" title="asyncio.loop.call_soon_threadsafe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon_threadsafe()</span></code></a> 에 의해 반환되는 콜백 래퍼 객체.</p>
<dl class="method">
<dt id="asyncio.Handle.cancel">
<code class="descname">cancel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancel" title="정의 주소">¶</a></dt>
<dd><p>콜백을 취소합니다. 콜백이 이미 취소되었거나 실행되었다면 이 메서드는 아무 효과가 없습니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Handle.cancelled">
<code class="descname">cancelled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancelled" title="정의 주소">¶</a></dt>
<dd><p>콜백이 취소되었으면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="asyncio.TimerHandle">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">TimerHandle</code><a class="headerlink" href="#asyncio.TimerHandle" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a> 및 <a class="reference internal" href="#asyncio.loop.call_at" title="asyncio.loop.call_at"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_at()</span></code></a> 에 의해 반환되는 콜백 래퍼 객체.</p>
<p>이 클래스는 <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a>의 서브 클래스입니다.</p>
<dl class="method">
<dt id="asyncio.TimerHandle.when">
<code class="descname">when</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.TimerHandle.when" title="정의 주소">¶</a></dt>
<dd><p>예약된 콜백 시간을 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 초로 반환합니다.</p>
<p>시간은 절대 타임스탬프입니다. <a class="reference internal" href="#asyncio.loop.time" title="asyncio.loop.time"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.time()</span></code></a> 과 같은 시간 참조를 사용합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="server-objects">
<h2>서버 객체<a class="headerlink" href="#server-objects" title="제목 주소">¶</a></h2>
<p>Server 객체는 <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>, <a class="reference internal" href="#asyncio.loop.create_unix_server" title="asyncio.loop.create_unix_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_server()</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.start_unix_server" title="asyncio.start_unix_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_unix_server()</span></code></a>로 만듭니다.</p>
<p>클래스의 인스턴스를 직접 만들지 마십시오.</p>
<dl class="class">
<dt id="asyncio.Server">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">Server</code><a class="headerlink" href="#asyncio.Server" title="정의 주소">¶</a></dt>
<dd><p><em>Server</em> 객체는 비동기 컨텍스트 관리자입니다. <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 문에서 사용될 때, <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> 문이 완료되면 서버 객체가 닫혀 있고 새 연결을 받아들이지 않는다는 것이 보장됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">srv</span><span class="p">:</span>
    <span class="c1"># 코드</span>

<span class="c1"># 이 지점에서, srv 는 닫혔고 더는 새 연결을 받아들이지 않습니다.</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Server 객체는 파이썬 3.7부터 비동기 컨텍스트 관리자입니다.</p>
</div>
<dl class="method">
<dt id="asyncio.Server.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.close" title="정의 주소">¶</a></dt>
<dd><p>서버를 중지합니다: 리스닝 소켓을 닫고 <a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sockets</span></code></a> 어트리뷰트를 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정합니다.</p>
<p>이미 받아들여진 클라이언트 연결을 나타내는 소켓은 열린 채로 있습니다.</p>
<p>서버는 비동기적으로 닫힙니다. 서버가 닫힐 때까지 대기하려면 <a class="reference internal" href="#asyncio.Server.wait_closed" title="asyncio.Server.wait_closed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_closed()</span></code></a> 코루틴을 사용하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.get_loop">
<code class="descname">get_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.get_loop" title="정의 주소">¶</a></dt>
<dd><p>서버 객체와 연관된 이벤트 루프를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.start_serving">
<em class="property">coroutine </em><code class="descname">start_serving</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.start_serving" title="정의 주소">¶</a></dt>
<dd><p>연결을 받아들이기 시작합니다.</p>
<p>이 메서드는 멱등적이라서, 서버가 이미 시작되었을 때도 호출 할 수 있습니다.</p>
<p><a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>와 <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.start_server()</span></code></a> 의 <em>start_serving</em> 키워드 전용 매개 변수는 즉시 연결을 받아들이지 않는 서버 객체를 만들 수 있도록 합니다. 이 경우 <code class="docutils literal notranslate"><span class="pre">Server.start_serving()</span></code>, 또는 <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.serve_forever()</span></code></a>를 사용하여 Server가 연결을 받아들이기 시작하도록 할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.serve_forever">
<em class="property">coroutine </em><code class="descname">serve_forever</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.serve_forever" title="정의 주소">¶</a></dt>
<dd><p>코루틴이 취소될 때까지 연결을 받아들이기 시작합니다. <code class="docutils literal notranslate"><span class="pre">serve_forever</span></code> 태스크를 취소하면 서버가 닫힙니다.</p>
<p>이 메서드는 서버가 이미 연결을 받아들이고 있어도 호출 할 수 있습니다. 하나의 <em>Server</em> 객체 당 하나의 <code class="docutils literal notranslate"><span class="pre">serve_forever</span></code> 태스크만 존재할 수 있습니다.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">client_connected</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
    <span class="c1"># reader/writer 스트림으로 클라이언트와</span>
    <span class="c1"># 통신합니다. 예를 들어:</span>
    <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">start_server</span><span class="p">(</span>
        <span class="n">client_connected</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">srv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.is_serving">
<code class="descname">is_serving</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.is_serving" title="정의 주소">¶</a></dt>
<dd><p>서버가 새 연결을 받아들이고 있으면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.wait_closed">
<em class="property">coroutine </em><code class="descname">wait_closed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.wait_closed" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 메서드가 완료될 때까지 기다립니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="asyncio.Server.sockets">
<code class="descname">sockets</code><a class="headerlink" href="#asyncio.Server.sockets" title="정의 주소">¶</a></dt>
<dd><p>서버가 리스닝하고 있는 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> 객체의 리스트.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>파이썬 3.7 이전에는 <code class="docutils literal notranslate"><span class="pre">Server.sockets</span></code> 가 서버 소켓의 내부 리스트를 직접 반환했습니다. 3.7에서는 그 리스트의 복사본이 반환됩니다.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="event-loop-implementations">
<span id="asyncio-event-loops"></span><h2>이벤트 루프 구현<a class="headerlink" href="#event-loop-implementations" title="제목 주소">¶</a></h2>
<p>asyncio에는 두 가지 이벤트 루프 구현이 함께 제공됩니다: <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> 및 <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>.</p>
<p>기본적으로 asyncio는 모든 플랫폼에서 <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a>를 사용하도록 구성됩니다.</p>
<dl class="class">
<dt id="asyncio.SelectorEventLoop">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">SelectorEventLoop</code><a class="headerlink" href="#asyncio.SelectorEventLoop" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a> 모듈을 기반으로 하는 이벤트 루프.</p>
<p>주어진 플랫폼에서 사용할 수 있는 가장 효율적인 <em>selector</em>를 사용합니다. 정확한 셀렉터 구현을 수동으로 구성하여 사용할 수도 있습니다.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">selectors</span>

<span class="n">selector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">SelectSelector</span><span class="p">()</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">SelectorEventLoop</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
</pre></div>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스, 윈도우.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.ProactorEventLoop">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">ProactorEventLoop</code><a class="headerlink" href="#asyncio.ProactorEventLoop" title="정의 주소">¶</a></dt>
<dd><p>&quot;I/O 완료 포트&quot;(IOCP)를 사용하는 윈도우용 이벤트 루프.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 윈도우.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference external" href="https://docs.microsoft.com/en-ca/windows/desktop/FileIO/i-o-completion-ports">I/O 완료 포트에 관한 MSDN 설명서</a>.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="asyncio.AbstractEventLoop">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">AbstractEventLoop</code><a class="headerlink" href="#asyncio.AbstractEventLoop" title="정의 주소">¶</a></dt>
<dd><p>asyncio 호환 이벤트 루프의 추상 베이스 클래스.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>다음에 소개되는 <a class="reference internal" href="#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractEventLoop</span></code></a> 클래스의 모든 메서드는 추상 메서드입니다.
여러분이 직접 이벤트 루프를 제작하려고 하면 모든 메서드를 구현해야한다는 뜻입니다.</p>
</div>
<p><a class="reference internal" href="#asyncio-event-loop"><span class="std std-ref">이벤트 루프 메서드</span></a> 절은 <code class="docutils literal notranslate"><span class="pre">AbstractEventLoop</span></code>의 다른 구현이 정의해야 하는 모든 메서드를 나열합니다.</p>
</dd></dl>

</div>
<div class="section" id="examples">
<h2>예제<a class="headerlink" href="#examples" title="제목 주소">¶</a></h2>
<p>이 절의 모든 예는 <strong>의도적으로</strong> <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_forever()</span></code></a> 및 <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a>와 같은 저수준 이벤트 루프 API를 사용하는 방법을 보여줍니다. 현대 asyncio 응용 프로그램은 거의 이런 식으로 작성할 필요가 없습니다; <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>과 같은 고수준 함수를 사용하는 것을 고려하십시오.</p>
<div class="section" id="hello-world-with-call-soon">
<span id="asyncio-example-lowlevel-helloworld"></span><h3>call_soon()을 사용하는 Hello World<a class="headerlink" href="#hello-world-with-call-soon" title="제목 주소">¶</a></h3>
<p>콜백을 예약하기 위해 <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> 메서드를 사용하는 예제. 콜백은 <code class="docutils literal notranslate"><span class="pre">&quot;Hello</span> <span class="pre">World&quot;</span></code> 를 표시한 다음 이벤트 루프를 중지합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A callback to print &#39;Hello World&#39; and stop the event loop&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="c1"># hello_world() 호출을 스케쥴합니다</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">hello_world</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># 블로킹 호출이 loop.stop() 에 의해 중단됩니다</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>코루틴과 <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> 함수로 작성된 유사한 <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">Hello World</span></a> 예제.</p>
</div>
</div>
<div class="section" id="display-the-current-date-with-call-later">
<span id="asyncio-example-call-later"></span><h3>call_later()로 현재 날짜를 표시합니다.<a class="headerlink" href="#display-the-current-date-with-call-later" title="제목 주소">¶</a></h3>
<p>초마다 현재 날짜를 표시하는 콜백의 예입니다. 콜백은 <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a> 메서드를 사용하여 5초 동안 자신을 다시 예약한 다음 이벤트 루프를 중지합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">def</span> <span class="nf">display_date</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end_time</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="c1"># 첫번째 display_date() 호출을 스케쥴합니다</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.0</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># 블로킹 호출이 loop.stop() 에 의해 중단됩니다</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>코루틴과 <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> 함수로 작성된 유사한 <a class="reference internal" href="asyncio-task.html#asyncio-example-sleep"><span class="std std-ref">현재 날짜</span></a> 예제.</p>
</div>
</div>
<div class="section" id="watch-a-file-descriptor-for-read-events">
<span id="asyncio-example-watch-fd"></span><h3>파일 기술자에서 읽기 이벤트를 관찰하기<a class="headerlink" href="#watch-a-file-descriptor-for-read-events" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#asyncio.loop.add_reader" title="asyncio.loop.add_reader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_reader()</span></code></a> 메서드를 사용하여 파일 기술자가 데이터를 수신할 때까지 기다렸다가 이벤트 루프를 닫습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">socket</span> <span class="k">import</span> <span class="n">socketpair</span>

<span class="c1"># 연결된 파일 기술자 쌍을 만듭니다</span>
<span class="n">rsock</span><span class="p">,</span> <span class="n">wsock</span> <span class="o">=</span> <span class="n">socketpair</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">reader</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">rsock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Received:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>

    <span class="c1"># 할 일을 끝냈습니다: 파일 기술자를 등록 취소합니다</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">remove_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">)</span>

    <span class="c1"># 이벤트 루프를 중지합니다</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="c1"># 읽기 이벤트를 위해 파일 기술자를 등록합니다</span>
<span class="n">loop</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">,</span> <span class="n">reader</span><span class="p">)</span>

<span class="c1"># 네트웍으로 부터의 데이터 수신을 흉내냅니다</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">wsock</span><span class="o">.</span><span class="n">send</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># 이벤트 루프를 실행합니다</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="c1"># 할 일을 끝냈습니다, 소켓과 이벤트 루프를 닫습니다</span>
    <span class="n">rsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">wsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<ul class="simple">
<li><p>트랜스포트, 프로토콜, <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> 메서드를 사용한 유사한 <a class="reference internal" href="asyncio-protocol.html#asyncio-example-create-connection"><span class="std std-ref">예제</span></a>.</p></li>
<li><p>고수준의 <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a> 함수와 스트림을 사용하는 또 다른 유사한 <a class="reference internal" href="asyncio-stream.html#asyncio-example-create-connection-streams"><span class="std std-ref">예제</span></a>.</p></li>
</ul>
</div>
</div>
<div class="section" id="set-signal-handlers-for-sigint-and-sigterm">
<span id="asyncio-example-unix-signals"></span><h3>SIGINT 및 SIGTERM에 대한 시그널 처리기 설정<a class="headerlink" href="#set-signal-handlers-for-sigint-and-sigterm" title="제목 주소">¶</a></h3>
<p>(이 <code class="docutils literal notranslate"><span class="pre">signals</span></code> 예제는 유닉스에서만 작동합니다.)</p>
<p><a class="reference internal" href="#asyncio.loop.add_signal_handler" title="asyncio.loop.add_signal_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_signal_handler()</span></code></a> 메서드를 사용하여 <code class="xref py py-data docutils literal notranslate"><span class="pre">SIGINT</span></code>와 <code class="xref py py-data docutils literal notranslate"><span class="pre">SIGTERM</span></code> 시그널을 위한 처리기를 등록합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">signal</span>

<span class="k">def</span> <span class="nf">ask_exit</span><span class="p">(</span><span class="n">signame</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;got signal </span><span class="si">%s</span><span class="s2">: exit&quot;</span> <span class="o">%</span> <span class="n">signame</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">signame</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;SIGINT&#39;</span><span class="p">,</span> <span class="s1">&#39;SIGTERM&#39;</span><span class="p">}:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signame</span><span class="p">),</span>
            <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">ask_exit</span><span class="p">,</span> <span class="n">signame</span><span class="p">,</span> <span class="n">loop</span><span class="p">))</span>

    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Event loop running for 1 hour, press Ctrl+C to interrupt.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;pid {os.getpid()}: send SIGINT or SIGTERM to exit.&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">이벤트 루프</a><ul>
<li><a class="reference internal" href="#event-loop-methods">이벤트 루프 메서드</a><ul>
<li><a class="reference internal" href="#running-and-stopping-the-loop">루프 실행 및 중지</a></li>
<li><a class="reference internal" href="#scheduling-callbacks">콜백 예약하기</a></li>
<li><a class="reference internal" href="#scheduling-delayed-callbacks">지연된 콜백 예약</a></li>
<li><a class="reference internal" href="#creating-futures-and-tasks">퓨처와 태스크 만들기</a></li>
<li><a class="reference internal" href="#opening-network-connections">네트워크 연결 열기</a></li>
<li><a class="reference internal" href="#creating-network-servers">네트워크 서버 만들기</a></li>
<li><a class="reference internal" href="#transferring-files">파일 전송</a></li>
<li><a class="reference internal" href="#tls-upgrade">TLS 업그레이드</a></li>
<li><a class="reference internal" href="#watching-file-descriptors">파일 기술자 관찰하기</a></li>
<li><a class="reference internal" href="#working-with-socket-objects-directly">소켓 객체로 직접 작업하기</a></li>
<li><a class="reference internal" href="#dns">DNS</a></li>
<li><a class="reference internal" href="#working-with-pipes">파이프로 작업하기</a></li>
<li><a class="reference internal" href="#unix-signals">유닉스 시그널</a></li>
<li><a class="reference internal" href="#executing-code-in-thread-or-process-pools">스레드 또는 프로세스 풀에서 코드를 실행하기</a></li>
<li><a class="reference internal" href="#error-handling-api">에러 처리 API</a></li>
<li><a class="reference internal" href="#enabling-debug-mode">디버그 모드 활성화</a></li>
<li><a class="reference internal" href="#running-subprocesses">자식 프로세스 실행하기</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callback-handles">콜백 핸들</a></li>
<li><a class="reference internal" href="#server-objects">서버 객체</a></li>
<li><a class="reference internal" href="#event-loop-implementations">이벤트 루프 구현</a></li>
<li><a class="reference internal" href="#examples">예제</a><ul>
<li><a class="reference internal" href="#hello-world-with-call-soon">call_soon()을 사용하는 Hello World</a></li>
<li><a class="reference internal" href="#display-the-current-date-with-call-later">call_later()로 현재 날짜를 표시합니다.</a></li>
<li><a class="reference internal" href="#watch-a-file-descriptor-for-read-events">파일 기술자에서 읽기 이벤트를 관찰하기</a></li>
<li><a class="reference internal" href="#set-signal-handlers-for-sigint-and-sigterm">SIGINT 및 SIGTERM에 대한 시그널 처리기 설정</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="asyncio-exceptions.html"
                        title="이전 장">예외</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="asyncio-future.html"
                        title="다음 장">퓨처</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="퓨처"
             >다음</a> |</li>
        <li class="right" >
          <a href="asyncio-exceptions.html" title="예외"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> --- 비동기 I/O</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>