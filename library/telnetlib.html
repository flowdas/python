
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>telnetlib --- 텔넷 클라이언트 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="uuid --- RFC 4122 에 따른 UUID 객체" href="uuid.html" />
    <link rel="prev" title="smtpd --- SMTP Server" href="smtpd.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/library/telnetlib.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="uuid.html" title="uuid --- RFC 4122 에 따른 UUID 객체"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="smtpd.html" title="smtpd --- SMTP Server"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-telnetlib">
<span id="telnetlib-telnet-client"></span><h1><a class="reference internal" href="#module-telnetlib" title="telnetlib: Telnet client class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">telnetlib</span></code></a> --- 텔넷 클라이언트<a class="headerlink" href="#module-telnetlib" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/telnetlib.py">Lib/telnetlib.py</a></p>
<hr class="docutils" id="index-0" />
<p><a class="reference internal" href="#module-telnetlib" title="telnetlib: Telnet client class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">telnetlib</span></code></a> 모듈은 텔넷 프로토콜을 구현하는 <a class="reference internal" href="#telnetlib.Telnet" title="telnetlib.Telnet"><code class="xref py py-class docutils literal notranslate"><span class="pre">Telnet</span></code></a> 클래스를 제공합니다. 프로토콜에 대한 자세한 내용은 <span class="target" id="index-4"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc854.html"><strong>RFC 854</strong></a>를 참조하십시오. 또한, 프로토콜 문자(아래를 보십시오)와 텔넷 옵션을 위한 기호 상수를 제공합니다. 텔넷 옵션의 기호 이름은 <code class="docutils literal notranslate"><span class="pre">arpa/telnet.h</span></code>의 정의를 따르며, 선행 <code class="docutils literal notranslate"><span class="pre">TELOPT_</span></code>는 제거됩니다. 전통적으로 <code class="docutils literal notranslate"><span class="pre">arpa/telnet.h</span></code>에 포함되지 않는 옵션의 기호 이름에 대해서는 모듈 소스 자체를 참조하십시오.</p>
<p>텔넷 명령을 위한 기호 상수는 다음과 같습니다: IAC, DONT, DO, WONT, WILL, SE (Subnegotiation End), NOP (No Operation), DM (Data Mark), BRK (Break), IP (Interrupt process), AO (Abort output), AYT (Are You There), EC (Erase Character), EL (Erase Line), GA (Go Ahead), SB (Subnegotiation Begin).</p>
<dl class="class">
<dt id="telnetlib.Telnet">
<em class="property">class </em><code class="descclassname">telnetlib.</code><code class="descname">Telnet</code><span class="sig-paren">(</span><em>host=None</em>, <em>port=0</em><span class="optional">[</span>, <em>timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#telnetlib.Telnet" title="telnetlib.Telnet"><code class="xref py py-class docutils literal notranslate"><span class="pre">Telnet</span></code></a>는 텔넷 서버와의 연결을 나타냅니다. 인스턴스는 기본적으로 처음에는 연결되지 않습니다; 연결하려면 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> 메서드를 사용해야 합니다. 또는, 호스트 이름과 선택적 포트 번호를 생성자에게 전달할 수 있는데, 이때는 생성자가 반환되기 전에 서버와 연결합니다. 선택적 <em>timeout</em> 매개 변수는 연결 시도와 같은 블로킹 연산에 대한 시간제한을 초로 지정합니다 (지정하지 않으면, 전역 기본 시간제한 설정이 사용됩니다).</p>
<p>이미 연결된 인스턴스를 다시 열지 마십시오.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><em>host</em> 인자를 제공해서 서버와 연결된 인스턴스에 대해 <a class="reference internal" href="#telnetlib.Telnet.open" title="telnetlib.Telnet.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Telnet.open()</span></code></a> 메서드를 호출하지 말라는 뜻입니다.</p>
</div>
<p>이 클래스에는 많은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read_*()</span></code> 메서드가 있습니다. 이들 중 일부는 연결의 끝을 읽을 때 <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>를 발생시킴에 유의하십시오. 다른 이유로 빈 문자열을 반환할 수 있기 때문입니다. 아래의 개별 설명을 참조하십시오.</p>
<p><a class="reference internal" href="#telnetlib.Telnet" title="telnetlib.Telnet"><code class="xref py py-class docutils literal notranslate"><span class="pre">Telnet</span></code></a> 객체는 컨텍스트 관리자이며 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문에서 사용할 수 있습니다. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 블록이 끝날 때, <a class="reference internal" href="#telnetlib.Telnet.close" title="telnetlib.Telnet.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 메서드가 호출됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">telnetlib</span> <span class="k">import</span> <span class="n">Telnet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Telnet</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span> <span class="k">as</span> <span class="n">tn</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">tn</span><span class="o">.</span><span class="n">interact</span><span class="p">()</span>
<span class="gp">...</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>컨텍스트 관리자 지원을 추가했습니다</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<dl class="last docutils">
<dt><span class="target" id="index-2"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc854.html"><strong>RFC 854</strong></a> - Telnet Protocol Specification</dt>
<dd>텔넷 프로토콜의 정의.</dd>
</dl>
</div>
<div class="section" id="telnet-objects">
<span id="id1"></span><h2>텔넷 객체<a class="headerlink" href="#telnet-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#telnetlib.Telnet" title="telnetlib.Telnet"><code class="xref py py-class docutils literal notranslate"><span class="pre">Telnet</span></code></a> 인스턴스에는 다음과 같은 메서드가 있습니다.:</p>
<dl class="method">
<dt id="telnetlib.Telnet.read_until">
<code class="descclassname">Telnet.</code><code class="descname">read_until</code><span class="sig-paren">(</span><em>expected</em>, <em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.read_until" title="정의 주소">¶</a></dt>
<dd><p>주어진 바이트열 <em>expected</em>를 만나거나 <em>timeout</em> 초가 경과 할 때까지 읽습니다.</p>
<p>일치하는 것을 찾을 수 없으면, 사용 가능한 것을 대신 반환합니다. 빈 바이트열도 가능합니다. 연결이 닫혀 있고 사용할 수 있는 요리된 데이터가 없으면 <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.read_all">
<code class="descclassname">Telnet.</code><code class="descname">read_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.read_all" title="정의 주소">¶</a></dt>
<dd><p>EOF까지 모든 데이터를 바이트열로 읽습니다; 연결이 닫힐 때까지 블록합니다.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.read_some">
<code class="descclassname">Telnet.</code><code class="descname">read_some</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.read_some" title="정의 주소">¶</a></dt>
<dd><p>EOF를 만나지 않으면 적어도 1바이트의 요리된 데이터를 읽습니다. EOF를 만나면 <code class="docutils literal notranslate"><span class="pre">b''</span></code>를 반환합니다. 즉시 사용할 수 있는 데이터가 없으면 블록합니다.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.read_very_eager">
<code class="descclassname">Telnet.</code><code class="descname">read_very_eager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.read_very_eager" title="정의 주소">¶</a></dt>
<dd><p>I/O에서 블록하지 않고 읽을 수 있는 모든 것을 읽습니다 (eager).</p>
<p>연결이 닫혀 있고 사용할 수 있는 요리된 데이터가 없으면 <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>를 발생시킵니다. 그렇지 않고 사용할 수 있는 요리된 데이터가 없으면 <code class="docutils literal notranslate"><span class="pre">b''</span></code>를 반환합니다. IAC 시퀀스의 중간에 있지 않으면 블록하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.read_eager">
<code class="descclassname">Telnet.</code><code class="descname">read_eager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.read_eager" title="정의 주소">¶</a></dt>
<dd><p>쉽게 사용할 수 있는 데이터를 읽습니다.</p>
<p>연결이 닫혀 있고 사용할 수 있는 요리된 데이터가 없으면 <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>를 발생시킵니다. 그렇지 않고 사용할 수 있는 요리된 데이터가 없으면 <code class="docutils literal notranslate"><span class="pre">b''</span></code>를 반환합니다. IAC 시퀀스의 중간에 있지 않으면 블록하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.read_lazy">
<code class="descclassname">Telnet.</code><code class="descname">read_lazy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.read_lazy" title="정의 주소">¶</a></dt>
<dd><p>이미 큐에 있는 데이터를 처리하고 반환합니다 (lazy).</p>
<p>연결이 닫혀 있고 사용할 수 있는 데이터가 없으면 <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>를 발생시킵니다. 그렇지 않고 사용할 수 있는 요리된 데이터가 없으면 <code class="docutils literal notranslate"><span class="pre">b''</span></code>를 반환합니다. IAC 시퀀스의 중간에 있지 않으면 블록하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.read_very_lazy">
<code class="descclassname">Telnet.</code><code class="descname">read_very_lazy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.read_very_lazy" title="정의 주소">¶</a></dt>
<dd><p>요리된 큐에 있는 모든 데이터를 반환합니다 (very lazy).</p>
<p>연결이 닫혀 있고 사용할 수 있는 데이터가 없으면 <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>를 발생시킵니다. 그렇지 않고 사용할 수 있는 요리된 데이터가 없으면 <code class="docutils literal notranslate"><span class="pre">b''</span></code>를 반환합니다. 이 메서드는 절대 블록하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.read_sb_data">
<code class="descclassname">Telnet.</code><code class="descname">read_sb_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.read_sb_data" title="정의 주소">¶</a></dt>
<dd><p>SB/SE 쌍(suboption begin/end)간에 수집된 데이터를 반환합니다. <code class="docutils literal notranslate"><span class="pre">SE</span></code> 명령으로 호출되었을 때 콜백은 이 데이터에 액세스해야 합니다. 이 방법은 절대 블록하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.open">
<code class="descclassname">Telnet.</code><code class="descname">open</code><span class="sig-paren">(</span><em>host</em>, <em>port=0</em><span class="optional">[</span>, <em>timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.open" title="정의 주소">¶</a></dt>
<dd><p>호스트에 연결합니다. 선택적 두 번째 인자는 포트 번호이며, 기본값은 표준 텔넷 포트(23)입니다. 선택적 <em>timeout</em> 매개 변수는 연결 시도와 같은 블로킹 연산에 대한 시간제한을 초로 지정합니다 (지정하지 않으면, 전역 기본 시간제한 설정이 사용됩니다).</p>
<p>이미 연결된 인스턴스를 다시 열려고 하지 마십시오.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.msg">
<code class="descclassname">Telnet.</code><code class="descname">msg</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.msg" title="정의 주소">¶</a></dt>
<dd><p>디버그 수준이 <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 0 일 때 디버그 메시지를 인쇄합니다. 추가 인자가 있으면, 표준 문자열 포매팅 연산자를 사용하여 메시지에 치환됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">표준 문자열 포매팅 연산자란 <code class="docutils literal notranslate"><span class="pre">%</span></code> 연산자를 뜻합니다. 즉 <code class="docutils literal notranslate"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">args</span></code> 가 인쇄됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.set_debuglevel">
<code class="descclassname">Telnet.</code><code class="descname">set_debuglevel</code><span class="sig-paren">(</span><em>debuglevel</em><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.set_debuglevel" title="정의 주소">¶</a></dt>
<dd><p>디버그 수준을 설정합니다. <em>debuglevel</em>의 값이 클수록, 더 많은 디버그 출력을 얻을 수 있습니다 (<code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>으로).</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.close">
<code class="descclassname">Telnet.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.close" title="정의 주소">¶</a></dt>
<dd><p>연결을 닫습니다.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.get_socket">
<code class="descclassname">Telnet.</code><code class="descname">get_socket</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.get_socket" title="정의 주소">¶</a></dt>
<dd><p>내부적으로 사용되는 소켓 객체를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.fileno">
<code class="descclassname">Telnet.</code><code class="descname">fileno</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.fileno" title="정의 주소">¶</a></dt>
<dd><p>내부적으로 사용되는 소켓 객체의 파일 기술자를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.write">
<code class="descclassname">Telnet.</code><code class="descname">write</code><span class="sig-paren">(</span><em>buffer</em><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.write" title="정의 주소">¶</a></dt>
<dd><p>IAC 문자를 중복(doubling)해서 소켓에 바이트열을 기록합니다. 연결이 블록 되면 블록 할 수 있습니다. 연결이 닫히면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>이 메서드는 방법은 <a class="reference internal" href="socket.html#socket.error" title="socket.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.error</span></code></a>를 발생시켰습니다. 이제는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 별칭입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.interact">
<code class="descclassname">Telnet.</code><code class="descname">interact</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.interact" title="정의 주소">¶</a></dt>
<dd><p>상호 작용 함수, 매우 단순한 텔넷 클라이언트를 에뮬레이션합니다.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.mt_interact">
<code class="descclassname">Telnet.</code><code class="descname">mt_interact</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.mt_interact" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#telnetlib.Telnet.interact" title="telnetlib.Telnet.interact"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interact()</span></code></a>의 다중 스레드 버전.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.expect">
<code class="descclassname">Telnet.</code><code class="descname">expect</code><span class="sig-paren">(</span><em>list</em>, <em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.expect" title="정의 주소">¶</a></dt>
<dd><p>정규식 리스트 중 하나가 일치할 때까지 읽습니다.</p>
<p>첫 번째 인자는 컴파일되었거나 (<a class="reference internal" href="re.html#re-objects"><span class="std std-ref">정규식 객체</span></a>) 컴파일되지 않은 (바이트열) 정규식의 리스트입니다. 선택적 두 번째 인자는 초 단위의 시간제한입니다; 기본값은 무기한 블록 하는 것입니다.</p>
<p>세 항목의 튜플을 반환합니다: 일치하는 첫 번째 정규식의 리스트 인덱스; 반환된 일치 객체; 그리고 일치를 포함해서 그때까지 읽은 바이트열.</p>
<p>파일의 끝이 발견되고 아무런 바이트도 읽히지 않았으면, <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>를 발생시킵니다. 그렇지 않으면, 아무것도 일치하지 않을 때, <code class="docutils literal notranslate"><span class="pre">(-1,</span> <span class="pre">None,</span> <span class="pre">data)</span></code>를 반환합니다. 여기서 <em>data</em>는 지금까지 받은 바이트열입니다 (시간 초과가 발생하면 빈 바이트열일 수 있습니다).</p>
<p>정규식이 탐욕적인 일치(가령 <code class="docutils literal notranslate"><span class="pre">.*</span></code>)로 끝나거나 둘 이상의 정규식이 같은 입력과 일치 할 수 있으면, 결과는 비결정적이며, I/O 타이밍에 따라 달라질 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="telnetlib.Telnet.set_option_negotiation_callback">
<code class="descclassname">Telnet.</code><code class="descname">set_option_negotiation_callback</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.set_option_negotiation_callback" title="정의 주소">¶</a></dt>
<dd><p>입력 흐름에서 텔넷 옵션을 읽을 때마다, 이 <em>callback</em>(설정되었다면)은 다음과 같은 매개 변수로 호출됩니다: callback(telnet socket, command (DO/DONT/WILL/WONT), option). telnetlib은 나중에 다른 작업을 수행하지 않습니다.</p>
</dd></dl>

</div>
<div class="section" id="telnet-example">
<span id="id2"></span><h2>텔넷 예제<a class="headerlink" href="#telnet-example" title="제목 주소">¶</a></h2>
<p>일반적인 사용을 보여주는 간단한 예제:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">getpass</span>
<span class="kn">import</span> <span class="nn">telnetlib</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s2">&quot;localhost&quot;</span>
<span class="n">user</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Enter your remote account: &quot;</span><span class="p">)</span>
<span class="n">password</span> <span class="o">=</span> <span class="n">getpass</span><span class="o">.</span><span class="n">getpass</span><span class="p">()</span>

<span class="n">tn</span> <span class="o">=</span> <span class="n">telnetlib</span><span class="o">.</span><span class="n">Telnet</span><span class="p">(</span><span class="n">HOST</span><span class="p">)</span>

<span class="n">tn</span><span class="o">.</span><span class="n">read_until</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;login: &quot;</span><span class="p">)</span>
<span class="n">tn</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">password</span><span class="p">:</span>
    <span class="n">tn</span><span class="o">.</span><span class="n">read_until</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Password: &quot;</span><span class="p">)</span>
    <span class="n">tn</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">password</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">tn</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;ls</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">tn</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;exit</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">tn</span><span class="o">.</span><span class="n">read_all</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">telnetlib</span></code> --- 텔넷 클라이언트</a><ul>
<li><a class="reference internal" href="#telnet-objects">텔넷 객체</a></li>
<li><a class="reference internal" href="#telnet-example">텔넷 예제</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="smtpd.html"
                        title="이전 장"><code class="docutils literal notranslate"><span class="pre">smtpd</span></code> --- SMTP Server</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="uuid.html"
                        title="다음 장"><code class="docutils literal notranslate"><span class="pre">uuid</span></code> --- <strong>RFC 4122</strong> 에 따른 UUID 객체</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="uuid.html" title="uuid --- RFC 4122 에 따른 UUID 객체"
             >다음</a> |</li>
        <li class="right" >
          <a href="smtpd.html" title="smtpd --- SMTP Server"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1 를 사용해서 만들었습니다.
    </div>

  </body>
</html>