
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>typing --- 형 힌트 지원 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="pydoc --- 설명서 생성과 온라인 도움말 시스템" href="pydoc.html" />
    <link rel="prev" title="개발 도구" href="development.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/typing.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc --- 설명서 생성과 온라인 도움말 시스템"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="development.html" title="개발 도구"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">개발 도구</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-typing">
<span id="typing-support-for-type-hints"></span><h1><a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> --- 형 힌트 지원<a class="headerlink" href="#module-typing" title="제목 주소">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/typing.py">Lib/typing.py</a></p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>typing 모듈은 <a class="reference internal" href="../glossary.html#term-provisional-api"><span class="xref std std-term">잠정적</span></a>으로 표준 라이브러리에 포함되었습니다. 코어 개발자들이 필요하다고 판단하면 새로운 기능이 추가될 수 있으며 API는 마이너 배포 사이에서도 변경 될 수 있습니다.</p>
</div>
<hr class="docutils" />
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>대표적인 정적 형 검사기는 <a class="reference external" href="http://mypy-lang.org/">mypy</a>입니다.</p>
</div>
<p>이 모듈은 <span class="target" id="index-43"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>, <span class="target" id="index-44"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>, <span class="target" id="index-45"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0544"><strong>PEP 544</strong></a>, <span class="target" id="index-46"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0586"><strong>PEP 586</strong></a>, <span class="target" id="index-47"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0589"><strong>PEP 589</strong></a> 및 <span class="target" id="index-48"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0591"><strong>PEP 591</strong></a>로 지정된 형 힌트에 대한 런타임 지원을 제공합니다. 가장 기본적인 지원은 형 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, <a class="reference internal" href="#typing.Union" title="typing.Union"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code></a>, <a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code></a>, <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a>, <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 및 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>으로 구성됩니다. 전체 명세는 <span class="target" id="index-49"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>를 참조하십시오. 형 힌트에 대한 간략한 소개는 <span class="target" id="index-50"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0483"><strong>PEP 483</strong></a>을 참조하십시오.</p>
<p>아래의 함수는 문자열을 취하고 반환하며 다음과 같이 어노테이트되었습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greeting</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s1">&#39;Hello &#39;</span> <span class="o">+</span> <span class="n">name</span>
</pre></div>
</div>
<p>함수 <code class="docutils literal notranslate"><span class="pre">greeting</span></code>에서, 인자 <code class="docutils literal notranslate"><span class="pre">name</span></code>은 형 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로, 반환 형은 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로 기대됩니다. 서브 형은 인자로 허용됩니다.</p>
<div class="section" id="type-aliases">
<h2>형 에일리어스<a class="headerlink" href="#type-aliases" title="제목 주소">¶</a></h2>
<p>형 에일리어스는 별칭에 형을 대입하여 정의됩니다. 이 예에서, <code class="docutils literal notranslate"><span class="pre">Vector</span></code>와 <code class="docutils literal notranslate"><span class="pre">List[float]</span></code>는 교환 가능한 동의어로 취급됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span>
<span class="n">Vector</span> <span class="o">=</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">scalar</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>

<span class="c1"># 형 검사 통과; float의 리스트는 Vector로 적합합니다.</span>
<span class="n">new_vector</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.2</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">])</span>
</pre></div>
</div>
<p>형 에일리어스는 복잡한 형 서명을 단순화하는 데 유용합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="n">ConnectionOptions</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">Address</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="n">Server</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Address</span><span class="p">,</span> <span class="n">ConnectionOptions</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Server</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># 정적 형 검사기는 이전 형 서명을 이것과 정확히 동등한 것으로 취급합니다.</span>
<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span>
        <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>형 힌트로서의 <code class="docutils literal notranslate"><span class="pre">None</span></code>은 특별한 경우이며 <code class="docutils literal notranslate"><span class="pre">type(None)</span></code>으로 치환됨에 유의하십시오.</p>
</div>
<div class="section" id="newtype">
<span id="distinct"></span><h2>NewType<a class="headerlink" href="#newtype" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-func docutils literal notranslate"><span class="pre">NewType()</span></code></a> 도우미 함수를 사용하여 다른 형을 만드십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">some_id</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">524313</span><span class="p">)</span>
</pre></div>
</div>
<p>정적 형 검사기는 새 형을 원래 형의 서브 클래스인 것처럼 다룹니다. 논리 에러를 잡는 데 유용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_user_name</span><span class="p">(</span><span class="n">user_id</span><span class="p">:</span> <span class="n">UserId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># 형 검사 통과</span>
<span class="n">user_a</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="n">UserId</span><span class="p">(</span><span class="mi">42351</span><span class="p">))</span>

<span class="c1"># 형 검사 실패; int는 UserId가 아닙니다</span>
<span class="n">user_b</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">UserId</span></code> 형의 변수에 대해 모든 <code class="docutils literal notranslate"><span class="pre">int</span></code> 연산을 여전히 수행할 수 있지만, 결과는 항상 <code class="docutils literal notranslate"><span class="pre">int</span></code> 형이 됩니다. 이것은 <code class="docutils literal notranslate"><span class="pre">int</span></code>가 기대되는 모든 곳에 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>를 전달할 수 있지만, 잘못된 방식으로 의도하지 않게 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>를 만들지 않도록합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &#39;output&#39;은 형 &#39;int&#39;입니다, &#39;UserId&#39;가 아닙니다</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">23413</span><span class="p">)</span> <span class="o">+</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">54341</span><span class="p">)</span>
</pre></div>
</div>
<p>이러한 검사는 정적 형 검사기에서만 적용됨에 유의하십시오. 실행 시간에, 문장 <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Base)</span></code>는 <code class="docutils literal notranslate"><span class="pre">Derived</span></code>를 전달하는 매개 변수를 즉시 반환하는 함수로 만듭니다. 이것은 <code class="docutils literal notranslate"><span class="pre">Derived(some_value)</span></code> 표현식이 새로운 클래스를 만들거나 일반 함수 호출을 넘어서는 오버 헤드를 발생시키지 않음을 의미합니다.</p>
<p>보다 정확하게, 표현식 <code class="docutils literal notranslate"><span class="pre">some_value</span> <span class="pre">is</span> <span class="pre">Derived(some_value)</span></code>는 실행 시간에 항상 참입니다.</p>
<p>이것은 또한 <code class="docutils literal notranslate"><span class="pre">Derived</span></code>의 서브 형을 만들 수 없다는 것을 의미하는데, 실행 시간에 항등 함수(identity function)일뿐 실제 형이 아니기 때문입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="c1"># 실행 시간에 실패하고 형 검사를 통과하지 못합니다</span>
<span class="k">class</span> <span class="nc">AdminUserId</span><span class="p">(</span><span class="n">UserId</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</div>
<p>그러나, '파생 된' <code class="docutils literal notranslate"><span class="pre">NewType</span></code>을 기반으로 <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-func docutils literal notranslate"><span class="pre">NewType()</span></code></a>을 만들 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="n">ProUserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;ProUserId&#39;</span><span class="p">,</span> <span class="n">UserId</span><span class="p">)</span>
</pre></div>
</div>
<p>그리고 <code class="docutils literal notranslate"><span class="pre">ProUserId</span></code>에 대한 형 검사는 예상대로 작동합니다.</p>
<p>자세한 내용은 <span class="target" id="index-51"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>를 참조하십시오.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>형 에일리어스를 사용하면 두 형이 서로 <em>동등한</em> 것으로 선언됨을 상기하십시오. <code class="docutils literal notranslate"><span class="pre">Alias</span> <span class="pre">=</span> <span class="pre">Original</span></code>는 모든 경우 정적 형 검사기가 <code class="docutils literal notranslate"><span class="pre">Alias</span></code>를 <code class="docutils literal notranslate"><span class="pre">Original</span></code>와 <em>정확히 동등한</em> 것으로 취급하게 합니다. 이것은 복잡한 형 서명을 단순화하려는 경우에 유용합니다.</p>
<p>반면에, <code class="docutils literal notranslate"><span class="pre">NewType</span></code>은 한 형을 다른 형의 <em>서브 형</em>으로 선언합니다. <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Original)</span></code>은 정적 형 검사기가 <code class="docutils literal notranslate"><span class="pre">Derived</span></code>를 <code class="docutils literal notranslate"><span class="pre">Original</span></code>의 <em>서브 클래스</em>로 취급하게 합니다. 이는 <code class="docutils literal notranslate"><span class="pre">Original</span></code> 형의 값이 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 형의 값이 예상되는 위치에서 사용될 수 없음을 의미합니다. 실행 시간 비용을 최소화하면서 논리 에러를 방지하려는 경우에 유용합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</div>
<div class="section" id="callable">
<h2>Callable<a class="headerlink" href="#callable" title="제목 주소">¶</a></h2>
<p>특정 서명의 콜백 함수를 기대하는 프레임워크는 <code class="docutils literal notranslate"><span class="pre">Callable[[Arg1Type,</span> <span class="pre">Arg2Type],</span> <span class="pre">ReturnType]</span></code>을 사용하여 형 힌트를 제공할 수 있습니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">feeder</span><span class="p">(</span><span class="n">get_next_item</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># 바디</span>

<span class="k">def</span> <span class="nf">async_query</span><span class="p">(</span><span class="n">on_success</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">on_error</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># 바디</span>
</pre></div>
</div>
<p>형 힌트에서 인자 리스트를 리터럴 줄임표(ellipsis)로 대체하여 호출 서명을 지정하지 않고 콜러블의 반환 값을 선언할 수 있습니다: <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">ReturnType]</span></code>.</p>
</div>
<div class="section" id="generics">
<span id="id1"></span><h2>제네릭<a class="headerlink" href="#generics" title="제목 주소">¶</a></h2>
<p>컨테이너에 보관된 객체에 대한 형 정보는 일반적인 방식으로 정적으로 유추될 수 없기 때문에, 컨테이너 요소에 대해 기대되는 형을 나타내는 서명을 지원하도록 추상 베이스 클래스가 확장되었습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">def</span> <span class="nf">notify_by_email</span><span class="p">(</span><span class="n">employees</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Employee</span><span class="p">],</span>
                    <span class="n">overrides</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>제네릭은 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>라는 typing에서 제공되는 새로운 팩토리를 사용하여 매개 변수화 될 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>      <span class="c1"># 형 변수를 선언합니다</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>   <span class="c1"># 제네릭 함수</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="user-defined-generic-types">
<h2>사용자 정의 제네릭 형<a class="headerlink" href="#user-defined-generic-types" title="제목 주소">¶</a></h2>
<p>사용자 정의 클래스는 제네릭 클래스로 정의 할 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="k">import</span> <span class="n">Logger</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LoggedVar</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Set &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Get &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p>베이스 클래스로서의 <code class="docutils literal notranslate"><span class="pre">Generic[T]</span></code>는 클래스 <code class="docutils literal notranslate"><span class="pre">LoggedVar</span></code>가 단일 형 매개 변수 <code class="docutils literal notranslate"><span class="pre">T</span></code>를 취한다는 것을 정의합니다. 이는 또한 <code class="docutils literal notranslate"><span class="pre">T</span></code>를 클래스 바디 내에서 형으로 유효하게 만듭니다.</p>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 베이스 클래스는 <code class="docutils literal notranslate"><span class="pre">LoggedVar[t]</span></code>가 형으로 유효하도록 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>을 정의하는 메타 클래스를 사용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Iterable</span>

<span class="k">def</span> <span class="nf">zero_all_vars</span><span class="p">(</span><span class="nb">vars</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">LoggedVar</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">var</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>제네릭 형은 임의의 수의 형 변수를 가질 수 있으며, 형 변수는 제한될 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">StrangePair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>에 대한 각 형 변수 인자는 달라야합니다. 그래서 이것은 잘못되었습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>   <span class="c1"># 유효하지 않습니다</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>으로 다중 상속을 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Sized</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>제네릭 클래스에서 상속 할 때, 일부 형 변수를 고정할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Mapping</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MyDict</span><span class="p">(</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>이 경우 <code class="docutils literal notranslate"><span class="pre">MyDict</span></code>는 단일 매개 변수 <code class="docutils literal notranslate"><span class="pre">T</span></code>를 갖습니다.</p>
<p>형 매개 변수를 지정하지 않고 제네릭 클래스를 사용하는 것은 각 위치에 대해 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>를 가정합니다. 다음 예제에서, <code class="docutils literal notranslate"><span class="pre">MyIterable</span></code>은 제네릭이 아니지만 <code class="docutils literal notranslate"><span class="pre">Iterable[Any]</span></code>를 묵시적으로 상속합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">MyIterable</span><span class="p">(</span><span class="n">Iterable</span><span class="p">):</span> <span class="c1"># Iterable[Any]와 같습니다</span>
</pre></div>
</div>
<p>사용자 정의 제네릭 형 에릴리어스도 지원됩니다. 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="n">Response</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span>

<span class="c1"># 여기서 반환형은 Union[Iterable[str], int]와 같습니다</span>
<span class="k">def</span> <span class="nf">response</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>
<span class="n">Vec</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">inproduct</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="c1"># Iterable[Tuple[T, T]]와 같습니다</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>에서 사용되는 메타 클래스는 <a class="reference internal" href="abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABCMeta</span></code></a>의 서브 클래스입니다. 제네릭 클래스는 추상 메서드나 프로퍼티를 포함하여 ABC가 될 수 있으며, 제네릭 클래스는 메타 클래스 충돌없이 베이스 클래스로 여러 ABC를 가질 수 있습니다. 제네릭 메타 클래스는 지원되지 않습니다. 제네릭을 매개 변수화한 결과는 캐시되며, typing 모듈의 대부분 형은 해시 가능하고 동등(equality) 비교할 수 있습니다.</p>
</div>
<div class="section" id="the-any-type">
<h2><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 형<a class="headerlink" href="#the-any-type" title="제목 주소">¶</a></h2>
<p>특수한 종류의 형은 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>입니다. 정적 형 검사기는 모든 형을 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>와 호환되는 것으로, <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>를 모든 형과 호환되는 것으로 취급합니다.</p>
<p>이것은 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 형의 값에 대해 어떤 연산이나 메서드 호출을 수행하고, 그것을 임의의 변수에 대입할 수 있다는 것을 의미합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Any</span>

<span class="n">a</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># type: Any</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1"># OK</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>       <span class="c1"># OK</span>

<span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>      <span class="c1"># type: str</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">a</span>       <span class="c1"># OK</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># 형 검사 통과; &#39;item&#39;은 임의의 형이 될 수 있습니다,</span>
    <span class="c1"># 그리고 그 형은 &#39;bar&#39; 메서드를 가질 수 있습니다</span>
    <span class="n">item</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 형의 값을 보다 구체적인 형에 대입할 때 형 검사가 수행되지 않음에 유의하십시오. 예를 들어, 정적 형 검사기는 <code class="docutils literal notranslate"><span class="pre">s</span></code>가 형 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로 선언되고 실행 시간에 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 값을 수신하더라도 <code class="docutils literal notranslate"><span class="pre">a</span></code>를 <code class="docutils literal notranslate"><span class="pre">s</span></code>에 대입할 때 에러를 보고하지 않았습니다!</p>
<p>또한, 반환 형이나 매개 변수 형이 없는 모든 함수는 묵시적으로 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 기본값을 사용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="c1"># 정적 형 검사기는 위의 것이 다음과 같은 서명을 가진 것으로 취급합니다:</span>
<span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p>이 동작은 여러분이 동적으로 형이 지정되는 코드와 정적으로 형이 지정되는 코드를 혼합해야 할 때 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>를 <em>탈출구</em>로 사용할 수 있도록 합니다.</p>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>의 동작과 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>의 동작을 대조하십시오. <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>와 유사하게, 모든 형은 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>의 서브 형입니다. 그러나, <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>와는 달리, 그 반대는 사실이 아닙니다: <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>는 다른 모든 형의 서브 형이 <em>아닙</em>니다.</p>
<p>이것은 값의 형이 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>일 때, 형 검사기가 그것에 대한 거의 모든 연산을 거부하고, 그것을 더 특수한 형의 변수에 대입(또는 그것을 반환 값으로 사용)하는 것이 형 에러임을 의미합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hash_a</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># 실패; object에는 &#39;magic&#39; 메서드가 없습니다.</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">hash_b</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># 형 검사 통과</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="c1"># 형 검사 통과, int와 str이 object의 서브 클래스이기 때문</span>
<span class="n">hash_a</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_a</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># 형 검사 통과, Any가 모든 형과 호환되기 때문</span>
<span class="n">hash_b</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_b</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>값이 형 안전한 방식으로 모든 형이 될 수 있음을 표시하려면 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>를 사용하십시오. 값이 동적으로 형이 지정됨을 표시하려면 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>를 사용하십시오.</p>
</div>
<div class="section" id="nominal-vs-structural-subtyping">
<h2>명목적 대 구조적 서브 타이핑<a class="headerlink" href="#nominal-vs-structural-subtyping" title="제목 주소">¶</a></h2>
<p>처음에는 <span class="target" id="index-52"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>가 파이썬 정적 형 시스템을 <em>명목적 서브 타이핑(nominal subtyping)</em>을 사용하는 것으로 정의했습니다. 이것은 오직 <code class="docutils literal notranslate"><span class="pre">A</span></code>가 <code class="docutils literal notranslate"><span class="pre">B</span></code>의 서브 클래스일 때만 클래스 <code class="docutils literal notranslate"><span class="pre">B</span></code>가 기대되는 곳에 클래스 <code class="docutils literal notranslate"><span class="pre">A</span></code>가 허용됨을 의미합니다.</p>
<p>이 요구 사항은 이전에 <a class="reference internal" href="#typing.Iterable" title="typing.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>과 같은 추상 베이스 클래스에도 적용되었습니다. 이 접근 방식의 문제점은 이것을 지원하려면 클래스를 명시적으로 표시해야만 한다는 점입니다. 이는 파이썬답지 않고 관용적인 동적으로 형이 지정된 파이썬 코드에서 일반적으로 수행하는 것과는 다릅니다. 예를 들어, 이것은 <span class="target" id="index-53"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>를 만족합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="k">class</span> <span class="nc">Bucket</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p><span class="target" id="index-54"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0544"><strong>PEP 544</strong></a>는 사용자가 클래스 정의에서 명시적인 베이스 클래스 없이 위의 코드를 작성할 수 있게함으로써 이 문제를 풀도록합니다. 정적 형 검사기가 <code class="docutils literal notranslate"><span class="pre">Bucket</span></code>을 <code class="docutils literal notranslate"><span class="pre">Sized</span></code>와 <code class="docutils literal notranslate"><span class="pre">Iterable[int]</span></code>의 서브 형으로 묵시적으로 취급하도록 합니다. 이것은 <em>구조적 서브 타이핑(structural subtyping)</em>(또는 정적 덕 타이핑)으로 알려져 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">Bucket</span><span class="p">:</span>  <span class="c1"># 참고: 베이스 클래스가 없습니다</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">Bucket</span><span class="p">())</span>  <span class="c1"># 형 검사를 통과합니다</span>
</pre></div>
</div>
<p>또한, 특별한 클래스 <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>을 서브 클래싱함으로써, 사용자는 새로운 사용자 정의 프로토콜을 정의하여 구조적 서브 타이핑을 완전히 누릴 수 있습니다 (아래 예를 참조하십시오).</p>
</div>
<div class="section" id="classes-functions-and-decorators">
<h2>클래스, 함수 및 데코레이터<a class="headerlink" href="#classes-functions-and-decorators" title="제목 주소">¶</a></h2>
<p>모듈은 다음 클래스, 함수 및 데코레이터를 정의합니다:</p>
<dl class="class">
<dt id="typing.TypeVar">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">TypeVar</code><a class="headerlink" href="#typing.TypeVar" title="정의 주소">¶</a></dt>
<dd><p>형 변수.</p>
<p>용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># 무엇이든 될 수 있습니다</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># str이나 bytes여야 합니다</span>
</pre></div>
</div>
<p>형 변수는 주로 정적 형 검사기를 위해 존재합니다. 이들은 제네릭 함수 정의뿐만 아니라 제네릭 형의 매개 변수 역할을 합니다. 제네릭 형에 대한 자세한 내용은 Generic 클래스를 참조하십시오. 제네릭 함수는 다음과 같이 작동합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;x에 대한 n개의 참조가 포함된 리스트를 반환합니다.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>

<span class="k">def</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;두 문자열 중 가장 긴 문자열을 반환합니다.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>
</div>
<p>후자의 예의 서명은 기본적으로 <code class="docutils literal notranslate"><span class="pre">(str,</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></code>과 <code class="docutils literal notranslate"><span class="pre">(bytes,</span> <span class="pre">bytes)</span> <span class="pre">-&gt;</span> <span class="pre">bytes</span></code>의 오버로딩입니다. 또한 인자가 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>의 어떤 서브 클래스의 인스턴스면 반환 형은 여전히 일반 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>임에 유의하십시오.</p>
<p>실행 시간에, <code class="docutils literal notranslate"><span class="pre">isinstance(x,</span> <span class="pre">T)</span></code>는 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다. 일반적으로, <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>와 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>는 형과 함께 사용하면 안됩니다.</p>
<p>형 변수는 <code class="docutils literal notranslate"><span class="pre">covariant=True</span></code>나 <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code>를 전달하여 공변적(covariant)이나 반변적(contravariant)으로 표시될 수 있습니다. 자세한 내용은 <span class="target" id="index-55"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>를 참조하십시오. 기본적으로 형 변수는 불변적(invariant)입니다. 대안적으로, 형 변수는 <code class="docutils literal notranslate"><span class="pre">bound=&lt;type&gt;</span></code>를 사용하여 상한을 지정할 수 있습니다. 이것은 형 변수에 (명시적으로나 묵시적으로) 치환되는 실제 형이 상한 형의 서브 클래스여야 함을 의미합니다, <span class="target" id="index-56"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>를 참조하십시오.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>제네릭 형의 공변성(covariancy)은 세 가지 상태를 갖습니다: 불변적(invariant),
공변적(covariant), 반변적(contravariant). 형 변수에서 지정되기는 하지만, 공변성은
형 변수의 성질이라기보다는, 이 변수를 사용하여 선언되는 제네릭 형의 성질입니다. 다만,
여러 개의 형 변수를 사용하는 제네릭 형은 형 변수마다 다른 공변성을 가질 수 있기 때문에,
형 변수를 통해 지정합니다. 또한 제네릭 함수에 사용되는 형 변수는 <code class="docutils literal notranslate"><span class="pre">covariant</span></code>나
<code class="docutils literal notranslate"><span class="pre">contravariant</span></code>를 지정하지 않아야 합니다.</p>
<p>제네릭 형이 불변적(기본값)이면 형 변수에 치환되는 실제 형은 선언된 형과 정확히 일치해야 합니다.
공변적이면 실제 형은 선언된 형의 서브 형이 허용됩니다. 반변적인 것은 공변적인 것과 정확히
반대의 성질을 가집니다.</p>
<p>공변성은 간단한 형의 서브 타이핑 관계와 이를 사용한 복잡한 형의 서브 타이핑 관계가 어떻게
연관되는지를 정의합니다. 예를 들어 두 클래스 <code class="docutils literal notranslate"><span class="pre">Base</span></code> 와 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 가 있고,
<code class="docutils literal notranslate"><span class="pre">Base</span></code> 가 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 의 베이스 클래스라고 합시다. <code class="docutils literal notranslate"><span class="pre">Base</span></code>라고 형을 선언한
변수에는 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 형의 값을 대입할 수 있습니다. 이것이 간단한 형의 서브 타이핑 관계입니다.</p>
<p>이제 <code class="docutils literal notranslate"><span class="pre">List[Base]</span></code>라고 형을 선언한 변수를 생각해 봅시다. 이 변수에 <code class="docutils literal notranslate"><span class="pre">List[Derived]</span></code>
형의 값을 대입하도록 허락해야 할까요? 만약 허락한다면 (이것을 공변적이라고 합니다), 이후에
<code class="docutils literal notranslate"><span class="pre">List[Base]</span></code>라고 선언된 변수의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> 메서드 호출도 허용해야 하는데,
이 메서드는 당연히 <code class="docutils literal notranslate"><span class="pre">Base</span></code> 형의 값을 리스트에 추가할 수 있습니다. 그러면 메서드 호출 이후에
<code class="docutils literal notranslate"><span class="pre">List[Derived]</span></code>라고 형이 선언된 값에 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 가 아니라, 단순히 <code class="docutils literal notranslate"><span class="pre">Base</span></code> 형의
값이 들어가게 되었습니다. 하지만, <code class="docutils literal notranslate"><span class="pre">List[Derived]</span></code>라고 선언하는 것은, 이 리스트에는
<code class="docutils literal notranslate"><span class="pre">Derived</span></code>나 <code class="docutils literal notranslate"><span class="pre">Derived</span></code>의 서브 클래스만 넣겠다는 의사 표현일 수도 있습니다. 이런
관점에서 본다면 앞의 대입은 금지되어야 합니다 (실행 시간에 금지되지는 않습니다. 형 검사가 실패로
간주할 뿐입니다). 이 때문에 <a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a>에서 정의되는 모든 가변(mutable) 컨테이너들은 불변적(invariant)
입니다.</p>
<p>하지만 모든 컨테이너가 불변적(invariant)일 필요는 없습니다. 앞에서 예시한 문제는 컨테이너를 수정할 때만 발생함에
유의하십시오. 튜플 같은 불변(immutable) 컨테이너에서는 이런 문제가 없습니다. 따라서 <a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a>에서
정의되는 모든 불변(immutable) 컨테이너는 공변적(covariant)으로 정의되어 있습니다.</p>
<p>반변적(contravariant)인 관계는 약간 복잡해 보이지만 설명해 보겠습니다. <a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 모듈에서 제공되는
반변성은 <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>와 이와 유사한 제네릭 형(<a class="reference internal" href="#typing.AsyncGenerator" title="typing.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncGenerator</span></code></a>, <a class="reference internal" href="#typing.Coroutine" title="typing.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Coroutine</span></code></a>, ...)에서
찾을 수 있습니다. <code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code> 메서드의 인자로 전달되는 형이 반변적입니다. 이 형(<code class="docutils literal notranslate"><span class="pre">SendType</span></code>)을
<code class="docutils literal notranslate"><span class="pre">Derived</span></code>라고 선언한 제너레이터(<code class="docutils literal notranslate"><span class="pre">Generator[...,</span> <span class="pre">SendType,</span> <span class="pre">...]</span></code>)를 저장하는 변수 <code class="docutils literal notranslate"><span class="pre">g</span></code>를 생각해 봅시다.
이 변수를 사용하는 코드는 <code class="docutils literal notranslate"><span class="pre">g.send(Derived())</span></code> 와 같은 호출을 하고 있을 겁니다. 한편, 이 변수에 대입되는
제너레이터의 코드는 <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">yield</span></code> 와 같은 식으로 <code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code>가 보낸 값을 받을 겁니다.
만약 <code class="docutils literal notranslate"><span class="pre">v</span></code>의 형이 <code class="docutils literal notranslate"><span class="pre">Base</span></code>로 선언되어 있더라도, <code class="docutils literal notranslate"><span class="pre">Derived()</span></code>가 대입되는 것은 문제가 되지 않습니다.
하지만 <code class="docutils literal notranslate"><span class="pre">v</span></code>의 형이 <code class="docutils literal notranslate"><span class="pre">Derived</span></code>의 서브 클래스 (<code class="docutils literal notranslate"><span class="pre">MoreDerived</span></code>)라면 문제가 됩니다. 이는 변수 <code class="docutils literal notranslate"><span class="pre">g</span></code>에
<code class="docutils literal notranslate"><span class="pre">Generator[...,</span> <span class="pre">Base,</span> <span class="pre">...]</span></code>를 대입하는 것은 허락해야 하지만, <code class="docutils literal notranslate"><span class="pre">Generator[...,</span> <span class="pre">MoreDerived,</span> <span class="pre">...]</span></code>를
대입하는 것은 금지해야 한다는 뜻이 됩니다. 이것이 <code class="docutils literal notranslate"><span class="pre">SendType</span></code>이 반변적이어야 하는 이유입니다.</p>
<p>제네릭 형에서 형 변수들의 공변성은 중요합니다. 설명서에서 따로 명시하고 있지는 않지만, 공변적인 형 변수에는 <code class="docutils literal notranslate"><span class="pre">_co</span></code> 접미사를,
반변적인 형 변수에는 <code class="docutils literal notranslate"><span class="pre">_contra</span></code> 접미사를 붙이고, 불변적인 형 변수는 접미사 없이 표현하고 있습니다. 여러분의 코드에서도
이런 규칙을 지키는 것이 좋습니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Generic">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Generic</code><a class="headerlink" href="#typing.Generic" title="정의 주소">¶</a></dt>
<dd><p>제네릭 형을 위한 추상 베이스 클래스.</p>
<p>제네릭 형은 일반적으로 이 클래스를 하나 이상의 형 변수로 인스턴스화한 것을 상속하여 선언됩니다. 예를 들어, 제네릭 매핑 형은 다음과 같이 정의할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># 등등.</span>
</pre></div>
</div>
<p>이 클래스는 다음과 같이 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lookup_name</span><span class="p">(</span><span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Y</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Protocol">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Protocol</code><span class="sig-paren">(</span><em>Generic</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Protocol" title="정의 주소">¶</a></dt>
<dd><p>프로토콜 클래스의 베이스 클래스입. 프로토콜 클래스는 다음과 같이 정의됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Proto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>이러한 클래스는 주로 구조적 서브 타이핑(정적 덕 타이핑)을 인식하는 정적 형 검사기와 함께 사용됩니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Proto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>

<span class="n">func</span><span class="p">(</span><span class="n">C</span><span class="p">())</span>  <span class="c1"># 정적 형 검사를 통과합니다</span>
</pre></div>
</div>
<p>자세한 내용은 <span class="target" id="index-57"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0544"><strong>PEP 544</strong></a>를 참조하십시오. <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a>(아래에서 설명합니다)로 데코레이트된 프로토콜 클래스는 주어진 어트리뷰트의 존재 여부만 확인하고 형 서명을 무시하는 단순한 실행 시간 프로토콜로 작동합니다.</p>
<p>프로토콜 클래스는 제네릭할 수 있습니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GenProto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Type">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Type</code><span class="sig-paren">(</span><em>Generic[CT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Type" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">C</span></code>로 어노테이트된 변수는 <code class="docutils literal notranslate"><span class="pre">C</span></code> 형의 값을 받아들일 수 있습니다. 대조적으로, <code class="docutils literal notranslate"><span class="pre">Type[C]</span></code>로 어노테이트된 변수는 클래스 자신인 값을 받아들일 수 있습니다 -- 구체적으로, <code class="docutils literal notranslate"><span class="pre">C</span></code>의 <em>클래스 객체</em>를 허용합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>         <span class="c1"># 형 &#39;int&#39; 입니다</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">int</span>       <span class="c1"># 형 &#39;Type[int]&#39; 입니다</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># 역시 형 &#39;Type[int]&#39; 입니다</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Type[C]</span></code>는 공변적(covariant)입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">BasicUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">ProUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">TeamUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>

<span class="c1"># User, BasicUser, ProUser, TeamUser, ... 를 허용합니다</span>
<span class="k">def</span> <span class="nf">make_new_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">User</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">User</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">user_class</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Type[C]</span></code>가 공변적(covariant)이라는 사실은 <code class="docutils literal notranslate"><span class="pre">C</span></code>의 모든 서브 클래스가 <code class="docutils literal notranslate"><span class="pre">C</span></code>와 같은 생성자 서명과 클래스 메서드 서명을 구현해야 함을 의미합니다. 형 검사기는 이 위반을 표시해야하지만, 표시된 베이스 클래스의 생성자 호출과 일치하는 서브 클래스의 생성자 호출을 허용해야합니다. 이 특별한 경우를 처리하기 위한 형 검사기의 요구 사항은 향후 <span class="target" id="index-58"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> 개정판에서 변경 될 수 있습니다.</p>
<p><a class="reference internal" href="#typing.Type" title="typing.Type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Type</span></code></a>의 합법적인 매개 변수는 클래스, <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, <a class="reference internal" href="#generics"><span class="std std-ref">형 변수</span></a> 및 이러한 형들의 공용체(union)분 입니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">new_non_team_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">BaseUser</span><span class="p">,</span> <span class="n">ProUser</span><span class="p">]]):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Type[Any]</span></code>는 <code class="docutils literal notranslate"><span class="pre">Type</span></code>와 동등하며, 이는 다시 파이썬의 메타 클래스 계층 구조의 루트인 <code class="docutils literal notranslate"><span class="pre">type</span></code>과 동등합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Iterable">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Iterable</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterable" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Iterator">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Iterator</code><span class="sig-paren">(</span><em>Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterator" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Reversible">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Reversible</code><span class="sig-paren">(</span><em>Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Reversible" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsInt">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsInt</code><a class="headerlink" href="#typing.SupportsInt" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__int__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsFloat">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsFloat</code><a class="headerlink" href="#typing.SupportsFloat" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__float__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsComplex">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsComplex</code><a class="headerlink" href="#typing.SupportsComplex" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__complex__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsBytes">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsBytes</code><a class="headerlink" href="#typing.SupportsBytes" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__bytes__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsIndex">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsIndex</code><a class="headerlink" href="#typing.SupportsIndex" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__index__</span></code>를 가진 ABC.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsAbs">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsAbs</code><a class="headerlink" href="#typing.SupportsAbs" title="정의 주소">¶</a></dt>
<dd><p>반환 형이 공변적(covariant)인 하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__abs__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsRound">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsRound</code><a class="headerlink" href="#typing.SupportsRound" title="정의 주소">¶</a></dt>
<dd><p>반환 형이 공변적(covariant)인 하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__round__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Container">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Container</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Container" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Hashable">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Hashable</code><a class="headerlink" href="#typing.Hashable" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Hashable</span></code></a>에 대한 별칭</p>
</dd></dl>

<dl class="class">
<dt id="typing.Sized">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Sized</code><a class="headerlink" href="#typing.Sized" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></a>에 대한 별칭</p>
</dd></dl>

<dl class="class">
<dt id="typing.Collection">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Collection</code><span class="sig-paren">(</span><em>Sized, Iterable[T_co], Container[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Collection" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a>의 제네릭 버전</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.0에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AbstractSet">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AbstractSet</code><span class="sig-paren">(</span><em>Sized, Collection[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AbstractSet" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.MutableSet">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MutableSet</code><span class="sig-paren">(</span><em>AbstractSet[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSet" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Mapping">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Mapping</code><span class="sig-paren">(</span><em>Sized, Collection[KT], Generic[VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Mapping" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a>의 제네릭 버전. 이 형은 다음과 같이 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_position_in_index</span><span class="p">(</span><span class="n">word_list</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">word_list</span><span class="p">[</span><span class="n">word</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.MutableMapping">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MutableMapping</code><span class="sig-paren">(</span><em>Mapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableMapping" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Sequence">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Sequence</code><span class="sig-paren">(</span><em>Reversible[T_co], Collection[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Sequence" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.MutableSequence">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MutableSequence</code><span class="sig-paren">(</span><em>Sequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSequence" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.ByteString">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ByteString</code><span class="sig-paren">(</span><em>Sequence[int]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ByteString" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ByteString</span></code></a>의 제네릭 버전.</p>
<p>이 형은 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 및 <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 형을 나타냅니다.</p>
<p>이 형의 줄임 표현으로, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>는 위에 언급된 모든 형의 인자를 어노테이트하는 데 사용될 수 있습니다.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Deque">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Deque</code><span class="sig-paren">(</span><em>deque, MutableSequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Deque" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.List">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">List</code><span class="sig-paren">(</span><em>list, MutableSequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.List" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>의 제네릭 버전. 반환형을 어노테이트하는 데 유용합니다. 인자를 어노테이트 하려면 <a class="reference internal" href="#typing.Sequence" title="typing.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a>나 <a class="reference internal" href="#typing.Iterable" title="typing.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>과 같은 추상 컬렉션 형을 사용하는 것이 좋습니다.</p>
<p>이 형은 다음과 같이 사용될 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">vec2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">keep_positives</span><span class="p">(</span><span class="n">vector</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">vector</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Set">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Set</code><span class="sig-paren">(</span><em>set, MutableSet[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Set" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a>의 제네릭 버전. 반환형을 어노테이트하는 데 유용합니다. 인자를 어노테이트 하려면 <a class="reference internal" href="#typing.AbstractSet" title="typing.AbstractSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractSet</span></code></a>과 같은 추상 컬렉션 형을 사용하는 것이 좋습니다.</p>
</dd></dl>

<dl class="class">
<dt id="typing.FrozenSet">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">FrozenSet</code><span class="sig-paren">(</span><em>frozenset, AbstractSet[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.FrozenSet" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.MappingView">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MappingView</code><span class="sig-paren">(</span><em>Sized, Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MappingView" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.KeysView">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">KeysView</code><span class="sig-paren">(</span><em>MappingView[KT_co], AbstractSet[KT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.KeysView" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.ItemsView">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ItemsView</code><span class="sig-paren">(</span><em>MappingView, Generic[KT_co, VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ItemsView" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.ValuesView">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ValuesView</code><span class="sig-paren">(</span><em>MappingView[VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ValuesView" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Awaitable">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Awaitable</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Awaitable" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Coroutine">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Coroutine</code><span class="sig-paren">(</span><em>Awaitable[V_co], Generic[T_co T_contra, V_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Coroutine" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a>의 제네릭 버전. 형 변수의 변화와 순서는 <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>의 것과 같습니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Coroutine</span>
<span class="n">c</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># type: Coroutine[List[str], str, int]</span>
<span class="o">...</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hi&#39;</span><span class="p">)</span> <span class="c1"># type: List[str]</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="k">await</span> <span class="n">c</span> <span class="c1"># type: int</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncIterable">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AsyncIterable</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterable" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncIterator">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AsyncIterator</code><span class="sig-paren">(</span><em>AsyncIterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterator" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.ContextManager">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ContextManager</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ContextManager" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.0에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncContextManager">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AsyncContextManager</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncContextManager" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Dict">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Dict</code><span class="sig-paren">(</span><em>dict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Dict" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>의 제네릭 버전. 반환형을 어노테이트하는 데 유용합니다. 인자를 어노테이트 하려면 <a class="reference internal" href="#typing.Mapping" title="typing.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a>과 같은 추상 컬렉션 형을 사용하는 것이 좋습니다.</p>
<p>이 형은 다음과 같이 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_words</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.DefaultDict">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">DefaultDict</code><span class="sig-paren">(</span><em>collections.defaultdict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.DefaultDict" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.OrderedDict">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">OrderedDict</code><span class="sig-paren">(</span><em>collections.OrderedDict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.OrderedDict" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Counter">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Counter</code><span class="sig-paren">(</span><em>collections.Counter, Dict[T, int]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Counter" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.ChainMap">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ChainMap</code><span class="sig-paren">(</span><em>collections.ChainMap, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ChainMap" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Generator">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Generator</code><span class="sig-paren">(</span><em>Iterator[T_co], Generic[T_co, T_contra, V_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Generator" title="정의 주소">¶</a></dt>
<dd><p>제너레이터는 제네릭 형 <code class="docutils literal notranslate"><span class="pre">Generator[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></code>으로 어노테이트할 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Done&#39;</span>
</pre></div>
</div>
<p>typing 모듈의 다른 많은 제네릭과 달리 <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">SendType</span></code>는 공변적(covariant)이거나 불변적(invariant)이 아니라 반변적(contravariant)으로 행동함에 유의하십시오.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>이에 대한 설명은 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>에 붙인 주석을 참조하십시오.</p>
</div>
<p>제너레이터가 값을 일드(yield)하기만 하면, <code class="docutils literal notranslate"><span class="pre">SendType</span></code>과 <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code>을 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>또는, <code class="docutils literal notranslate"><span class="pre">Iterable[YieldType]</span></code>이나 <code class="docutils literal notranslate"><span class="pre">Iterator[YieldType]</span></code> 중 하나의 반환형을 갖는 것으로 제너레이터를 어노테이트 하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncGenerator">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AsyncGenerator</code><span class="sig-paren">(</span><em>AsyncIterator[T_co], Generic[T_co, T_contra]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncGenerator" title="정의 주소">¶</a></dt>
<dd><p>비동기 제너레이터는 제네릭 형 <code class="docutils literal notranslate"><span class="pre">AsyncGenerator[YieldType,</span> <span class="pre">SendType]</span></code>으로 어노테이트할 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">rounded</span> <span class="o">=</span> <span class="k">await</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">rounded</span>
</pre></div>
</div>
<p>일반 제너레이터와 달리, 비동기 제너레이터는 값을 반환 할 수 없으므로, <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> 형 매개 변수가 없습니다. <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>와 마찬가지로, <code class="docutils literal notranslate"><span class="pre">SendType</span></code>은 반변적(contravariant)으로 행동합니다.</p>
<p>제너레이터가 값을 일드(yield)하기만 하면, <code class="docutils literal notranslate"><span class="pre">SendType</span></code>을 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<p>또는, <code class="docutils literal notranslate"><span class="pre">AsyncIterable[YieldType]</span></code>이나 <code class="docutils literal notranslate"><span class="pre">AsyncIterator[YieldType]</span></code> 중 하나의 반환형을 갖는 것으로 제너레이터를 어노테이트 하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Text">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Text</code><a class="headerlink" href="#typing.Text" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Text</span></code>는 <code class="docutils literal notranslate"><span class="pre">str</span></code>의 별칭입니다. 파이썬 2 코드를 위한 상위 호환 경로를 제공하기 위해 제공됩니다: 파이썬 2에서, <code class="docutils literal notranslate"><span class="pre">Text</span></code>는 <code class="docutils literal notranslate"><span class="pre">unicode</span></code>의 별칭입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">Text</span></code>를 사용하여 값이 파이썬 2와 파이썬 3 모두와 호환되는 방식으로 유니코드 문자열을 포함해야 함을 나타내십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_unicode_checkmark</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Text</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">text</span> <span class="o">+</span> <span class="sa">u</span><span class="s1">&#39; </span><span class="se">\u2713</span><span class="s1">&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.IO">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">IO</code><a class="headerlink" href="#typing.IO" title="정의 주소">¶</a></dt>
<dt id="typing.TextIO">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">TextIO</code><a class="headerlink" href="#typing.TextIO" title="정의 주소">¶</a></dt>
<dt id="typing.BinaryIO">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">BinaryIO</code><a class="headerlink" href="#typing.BinaryIO" title="정의 주소">¶</a></dt>
<dd><p>제네릭 형 <code class="docutils literal notranslate"><span class="pre">IO[AnyStr]</span></code>와 서브 클래스 <code class="docutils literal notranslate"><span class="pre">TextIO(IO[str])</span></code> 및 <code class="docutils literal notranslate"><span class="pre">BinaryIO(IO[bytes])</span></code>는 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>에 의해 반환되는 것과 같은 I/O 스트림 형을 나타냅니다.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Pattern">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Pattern</code><a class="headerlink" href="#typing.Pattern" title="정의 주소">¶</a></dt>
<dt id="typing.Match">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Match</code><a class="headerlink" href="#typing.Match" title="정의 주소">¶</a></dt>
<dd><p>이 형 에일리어스는 <a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>과 <a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a>의 반환 형에 해당합니다. 이러한 형(및 해당 함수)은 <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code>로 제네릭하며 <code class="docutils literal notranslate"><span class="pre">Pattern[str]</span></code>, <code class="docutils literal notranslate"><span class="pre">Pattern[bytes]</span></code>, <code class="docutils literal notranslate"><span class="pre">Match[str]</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">Match[bytes]</span></code>로 써서 구체적으로 만들 수 있습니다.</p>
</dd></dl>

<dl class="class">
<dt id="typing.NamedTuple">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">NamedTuple</code><a class="headerlink" href="#typing.NamedTuple" title="정의 주소">¶</a></dt>
<dd><p>형 지정된(typed) <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a> 버전.</p>
<p>용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>이것은 다음과 동등합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>필드에 기본값을 부여하려면, 클래스 바디에서 그 값을 대입할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">employee</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">employee</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p>기본값이 있는 필드는 기본값이 없는 모든 필드 뒤에 와야합니다.</p>
<p>결과 클래스에는 필드 이름을 필드 형에 매핑하는 딕셔너리를 제공하는 추가 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code>가 있습니다. (필드 이름은 <code class="docutils literal notranslate"><span class="pre">_fields</span></code> 어트리뷰트에 있고 기본값은 <code class="docutils literal notranslate"><span class="pre">_field_defaults</span></code> 어트리뷰트에 있는데, 모두 namedtuple API의 일부입니다.)</p>
<p><code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> 서브 클래스는 독스트링과 메서드도 가질 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;종업원을 나타냅니다.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="s1">&#39;&lt;Employee </span><span class="si">{self.name}</span><span class="s1">, id=</span><span class="si">{self.id}</span><span class="s1">&gt;&#39;</span>
</pre></div>
</div>
<p>이전 버전과 호환되는 사용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><span class="target" id="index-59"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> 변수 어노테이션 문법 지원을 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6.1에서 변경: </span>기본값, 메서드 및 독스트링에 대한 지원을 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><code class="docutils literal notranslate"><span class="pre">_field_types</span></code> 어트리뷰트를 폐지하고, 같은 정보를 가지는 더 표준적인 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 어트리뷰트로 대체했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><code class="docutils literal notranslate"><span class="pre">_field_types</span></code>과 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 어트리뷰트는 이제 <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code> 인스턴스가 아닌 일반 딕셔너리입니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.TypedDict">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">TypedDict</code><span class="sig-paren">(</span><em>dict</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypedDict" title="정의 주소">¶</a></dt>
<dd><p>간단한 현 지정된(typed) 이름 공간. 실행 시간에 일반 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>와 동등합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>는 모든 인스턴스가 각 키가 일관된 형의 값에 연관되는, 특정한 키 집합을 갖도록 기대되는 딕셔너리 형을 만듭니다. 이 기대는 실행 시간에는 검사되지 않고, 형 검사기에서만 강제됩니다. 사용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;good&#39;</span><span class="p">}</span>  <span class="c1"># OK</span>
<span class="n">b</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;bad&#39;</span><span class="p">}</span>           <span class="c1"># 형 검사에 실패합니다</span>

<span class="k">assert</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>인트로스펙션을 위한 형 정보는 <code class="docutils literal notranslate"><span class="pre">Point2D.__annotations__</span></code>와 <code class="docutils literal notranslate"><span class="pre">Point2D.__total__</span></code>을 통해 액세스할 수 있습니다. <span class="target" id="index-60"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>을 지원하지 않는 이전 버전의 파이썬에서 이 기능을 사용하도록 하기 위해, <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>는 두 개의 추가 문법 형식을 지원합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})</span>
</pre></div>
</div>
<p>추가 예제와 형 검사기에서 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>를 사용하는 자세한 규칙은 <span class="target" id="index-61"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0589"><strong>PEP 589</strong></a>를 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.ForwardRef">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ForwardRef</code><a class="headerlink" href="#typing.ForwardRef" title="정의 주소">¶</a></dt>
<dd><p>문자열 전방 참조의 내부 typing 표현에 사용되는 클래스. 예를 들어, <code class="docutils literal notranslate"><span class="pre">List[&quot;SomeClass&quot;]</span></code>는 묵시적으로 <code class="docutils literal notranslate"><span class="pre">List[ForwardRef(&quot;SomeClass&quot;)]</span></code>로 변환됩니다. 이 클래스는 사용자가 인스턴스화해서는 안되지만, 인트로스팩션 도구에서 사용할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="typing.NewType">
<code class="descclassname">typing.</code><code class="descname">NewType</code><span class="sig-paren">(</span><em>typ</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.NewType" title="정의 주소">¶</a></dt>
<dd><p>형 검사기에 구별되는 형을 가리키는 도우미 함수, <a class="reference internal" href="#distinct"><span class="std std-ref">NewType</span></a>을 참조하십시오. 실행 시간에 인자를 반환하는 함수를 반환합니다. 용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">first_user</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.cast">
<code class="descclassname">typing.</code><code class="descname">cast</code><span class="sig-paren">(</span><em>typ</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.cast" title="정의 주소">¶</a></dt>
<dd><p>값을 형으로 변환합니다.</p>
<p>값을 변경하지 않고 반환합니다. 형 검사기에서는 반환값이 지정된 형임을 나타내지만, 실행 시간에는 의도적으로 아무 것도 확인하지 않습니다 (우리는 이 것이 가능한 한 빠르기를 원합니다).</p>
</dd></dl>

<dl class="function">
<dt id="typing.get_type_hints">
<code class="descclassname">typing.</code><code class="descname">get_type_hints</code><span class="sig-paren">(</span><em>obj</em><span class="optional">[</span>, <em>globals</em><span class="optional">[</span>, <em>locals</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_type_hints" title="정의 주소">¶</a></dt>
<dd><p>Return a dictionary containing type hints for a function, method, module
or class object.</p>
<p>This is often the same as <code class="docutils literal notranslate"><span class="pre">obj.__annotations__</span></code>. In addition,
forward references encoded as string literals are handled by evaluating
them in <code class="docutils literal notranslate"><span class="pre">globals</span></code> and <code class="docutils literal notranslate"><span class="pre">locals</span></code> namespaces. If necessary,
<code class="docutils literal notranslate"><span class="pre">Optional[t]</span></code> is added for function and method annotations if a default
value equal to <code class="docutils literal notranslate"><span class="pre">None</span></code> is set. For a class <code class="docutils literal notranslate"><span class="pre">C</span></code>, return
a dictionary constructed by merging all the <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> along
<code class="docutils literal notranslate"><span class="pre">C.__mro__</span></code> in reverse order.</p>
</dd></dl>

<dl class="function">
<dt id="typing.get_origin">
<code class="descclassname">typing.</code><code class="descname">get_origin</code><span class="sig-paren">(</span><em>typ</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_origin" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="typing.get_args">
<code class="descclassname">typing.</code><code class="descname">get_args</code><span class="sig-paren">(</span><em>typ</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_args" title="정의 주소">¶</a></dt>
<dd><p>Provide basic introspection for generic types and special typing forms.</p>
<p>For a typing object of the form <code class="docutils literal notranslate"><span class="pre">X[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> these functions return
<code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code>. If <code class="docutils literal notranslate"><span class="pre">X</span></code> is a generic alias for a builtin or
<a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> class, it gets normalized to the original class.
For unsupported objects return <code class="docutils literal notranslate"><span class="pre">None</span></code> and <code class="docutils literal notranslate"><span class="pre">()</span></code> correspondingly.
Examples:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Union</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.overload">
<code class="descclassname">&#64;</code><code class="descclassname">typing.</code><code class="descname">overload</code><a class="headerlink" href="#typing.overload" title="정의 주소">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> decorator allows describing functions and methods
that support multiple different combinations of argument types. A series
of <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated definitions must be followed by exactly one
non-<code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated definition (for the same function/method).
The <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated definitions are for the benefit of the
type checker only, since they will be overwritten by the
non-<code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated definition, while the latter is used at
runtime but should be ignored by a type checker.  At runtime, calling
a <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated function directly will raise
<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>. An example of overload that gives a more
precise type than can be expressed using a union or a type variable:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">actual</span> <span class="n">implementation</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>See <span class="target" id="index-19"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> for details and comparison with other typing semantics.</p>
</dd></dl>

<dl class="function">
<dt id="typing.final">
<code class="descclassname">&#64;</code><code class="descclassname">typing.</code><code class="descname">final</code><a class="headerlink" href="#typing.final" title="정의 주소">¶</a></dt>
<dd><p>A decorator to indicate to type checkers that the decorated method
cannot be overridden, and the decorated class cannot be subclassed.
For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>
<span class="k">class</span> <span class="nc">Sub</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Error reported by type checker</span>
          <span class="o">...</span>

<span class="nd">@final</span>
<span class="k">class</span> <span class="nc">Leaf</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">class</span> <span class="nc">Other</span><span class="p">(</span><span class="n">Leaf</span><span class="p">):</span>  <span class="c1"># Error reported by type checker</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>There is no runtime checking of these properties. See <span class="target" id="index-20"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0591"><strong>PEP 591</strong></a> for
more details.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.no_type_check">
<code class="descclassname">&#64;</code><code class="descclassname">typing.</code><code class="descname">no_type_check</code><a class="headerlink" href="#typing.no_type_check" title="정의 주소">¶</a></dt>
<dd><p>Decorator to indicate that annotations are not type hints.</p>
<p>This works as class or function <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>.  With a class, it
applies recursively to all methods defined in that class (but not
to methods defined in its superclasses or subclasses).</p>
<p>This mutates the function(s) in place.</p>
</dd></dl>

<dl class="function">
<dt id="typing.no_type_check_decorator">
<code class="descclassname">&#64;</code><code class="descclassname">typing.</code><code class="descname">no_type_check_decorator</code><a class="headerlink" href="#typing.no_type_check_decorator" title="정의 주소">¶</a></dt>
<dd><p>Decorator to give another decorator the <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a> effect.</p>
<p>This wraps the decorator with something that wraps the decorated
function in <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="typing.type_check_only">
<code class="descclassname">&#64;</code><code class="descclassname">typing.</code><code class="descname">type_check_only</code><a class="headerlink" href="#typing.type_check_only" title="정의 주소">¶</a></dt>
<dd><p>Decorator to mark a class or function to be unavailable at runtime.</p>
<p>This decorator is itself not available at runtime. It is mainly
intended to mark classes that are defined in type stub files if
an implementation returns an instance of a private class:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@type_check_only</span>
<span class="k">class</span> <span class="nc">Response</span><span class="p">:</span>  <span class="c1"># private or not available at runtime</span>
    <span class="n">code</span><span class="p">:</span> <span class="nb">int</span>
    <span class="k">def</span> <span class="nf">get_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">fetch_response</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>Note that returning instances of private classes is not recommended.
It is usually preferable to make such classes public.</p>
</dd></dl>

<dl class="function">
<dt id="typing.runtime_checkable">
<code class="descclassname">&#64;</code><code class="descclassname">typing.</code><code class="descname">runtime_checkable</code><a class="headerlink" href="#typing.runtime_checkable" title="정의 주소">¶</a></dt>
<dd><p>Mark a protocol class as a runtime protocol.</p>
<p>Such a protocol can be used with <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> and <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>.
This raises <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> when applied to a non-protocol class.  This
allows a simple-minded structural check, very similar to &quot;one trick ponies&quot;
in <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> such as <a class="reference internal" href="#typing.Iterable" title="typing.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>.  For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">Closable</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/some/file&#39;</span><span class="p">),</span> <span class="n">Closable</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Warning:</strong> this will check only the presence of the required methods,
not their type signatures!</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Any">
<code class="descclassname">typing.</code><code class="descname">Any</code><a class="headerlink" href="#typing.Any" title="정의 주소">¶</a></dt>
<dd><p>Special type indicating an unconstrained type.</p>
<ul class="simple">
<li><p>Every type is compatible with <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> is compatible with every type.</p></li>
</ul>
</dd></dl>

<dl class="data">
<dt id="typing.NoReturn">
<code class="descclassname">typing.</code><code class="descname">NoReturn</code><a class="headerlink" href="#typing.NoReturn" title="정의 주소">¶</a></dt>
<dd><p>Special type indicating that a function never returns.
For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NoReturn</span>

<span class="k">def</span> <span class="nf">stop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;no way&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Union">
<code class="descclassname">typing.</code><code class="descname">Union</code><a class="headerlink" href="#typing.Union" title="정의 주소">¶</a></dt>
<dd><p>Union type; <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">Y]</span></code> means either X or Y.</p>
<p>To define a union, use e.g. <code class="docutils literal notranslate"><span class="pre">Union[int,</span> <span class="pre">str]</span></code>.  Details:</p>
<ul>
<li><p>The arguments must be types and there must be at least one.</p></li>
<li><p>Unions of unions are flattened, e.g.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>Unions of a single argument vanish, e.g.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span>  <span class="c1"># The constructor actually returns int</span>
</pre></div>
</div>
</li>
<li><p>Redundant arguments are skipped, e.g.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>When comparing unions, the argument order is ignored, e.g.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>You cannot subclass or instantiate a union.</p></li>
<li><p>You cannot write <code class="docutils literal notranslate"><span class="pre">Union[X][Y]</span></code>.</p></li>
<li><p>You can use <code class="docutils literal notranslate"><span class="pre">Optional[X]</span></code> as a shorthand for <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">None]</span></code>.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Don't remove explicit subclasses from unions at runtime.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Optional">
<code class="descclassname">typing.</code><code class="descname">Optional</code><a class="headerlink" href="#typing.Optional" title="정의 주소">¶</a></dt>
<dd><p>Optional type.</p>
<p><code class="docutils literal notranslate"><span class="pre">Optional[X]</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">None]</span></code>.</p>
<p>Note that this is not the same concept as an optional argument,
which is one that has a default.  An optional argument with a
default does not require the <code class="docutils literal notranslate"><span class="pre">Optional</span></code> qualifier on its type
annotation just because it is optional. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>On the other hand, if an explicit value of <code class="docutils literal notranslate"><span class="pre">None</span></code> is allowed, the
use of <code class="docutils literal notranslate"><span class="pre">Optional</span></code> is appropriate, whether the argument is optional
or not. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Tuple">
<code class="descclassname">typing.</code><code class="descname">Tuple</code><a class="headerlink" href="#typing.Tuple" title="정의 주소">¶</a></dt>
<dd><p>Tuple type; <code class="docutils literal notranslate"><span class="pre">Tuple[X,</span> <span class="pre">Y]</span></code> is the type of a tuple of two items
with the first item of type X and the second of type Y.</p>
<p>Example: <code class="docutils literal notranslate"><span class="pre">Tuple[T1,</span> <span class="pre">T2]</span></code> is a tuple of two elements corresponding
to type variables T1 and T2.  <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">float,</span> <span class="pre">str]</span></code> is a tuple
of an int, a float and a string.</p>
<p>To specify a variable-length tuple of homogeneous type,
use literal ellipsis, e.g. <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">...]</span></code>. A plain <a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code></a>
is equivalent to <code class="docutils literal notranslate"><span class="pre">Tuple[Any,</span> <span class="pre">...]</span></code>, and in turn to <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>.</p>
</dd></dl>

<dl class="data">
<dt id="typing.Callable">
<code class="descclassname">typing.</code><code class="descname">Callable</code><a class="headerlink" href="#typing.Callable" title="정의 주소">¶</a></dt>
<dd><p>Callable type; <code class="docutils literal notranslate"><span class="pre">Callable[[int],</span> <span class="pre">str]</span></code> is a function of (int) -&gt; str.</p>
<p>The subscription syntax must always be used with exactly two
values: the argument list and the return type.  The argument list
must be a list of types or an ellipsis; the return type must be
a single type.</p>
<p>There is no syntax to indicate optional or keyword arguments;
such function types are rarely used as callback types.
<code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">ReturnType]</span></code> (literal ellipsis) can be used to
type hint a callable taking any number of arguments and returning
<code class="docutils literal notranslate"><span class="pre">ReturnType</span></code>.  A plain <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a> is equivalent to
<code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">Any]</span></code>, and in turn to
<a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a>.</p>
</dd></dl>

<dl class="data">
<dt id="typing.Literal">
<code class="descclassname">typing.</code><code class="descname">Literal</code><a class="headerlink" href="#typing.Literal" title="정의 주소">¶</a></dt>
<dd><p>A type that can be used to indicate to type checkers that the
corresponding variable or function parameter has a value equivalent to
the provided literal (or one of several literals). For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">validate_simple</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]:</span>  <span class="c1"># always returns True</span>
    <span class="o">...</span>

<span class="n">MODE</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">open_helper</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">MODE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/some/path&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>  <span class="c1"># Passes type check</span>
<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/other/path&#39;</span><span class="p">,</span> <span class="s1">&#39;typo&#39;</span><span class="p">)</span>  <span class="c1"># Error in type checker</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> cannot be subclassed. At runtime, an arbitrary value
is allowed as type argument to <code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code>, but type checkers may
impose restrictions. See <span class="target" id="index-21"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0586"><strong>PEP 586</strong></a> for more details about literal types.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.ClassVar">
<code class="descclassname">typing.</code><code class="descname">ClassVar</code><a class="headerlink" href="#typing.ClassVar" title="정의 주소">¶</a></dt>
<dd><p>Special type construct to mark class variables.</p>
<p>As introduced in <span class="target" id="index-22"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>, a variable annotation wrapped in ClassVar
indicates that a given attribute is intended to be used as a class variable
and should not be set on instances of that class. Usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Starship</span><span class="p">:</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># class variable</span>
    <span class="n">damage</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>                     <span class="c1"># instance variable</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> accepts only types and cannot be further subscribed.</p>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> is not a class itself, and should not
be used with <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> or <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>.
<a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> does not change Python runtime behavior, but
it can be used by third-party type checkers. For example, a type checker
might flag the following code as an error:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">enterprise_d</span> <span class="o">=</span> <span class="n">Starship</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>
<span class="n">enterprise_d</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Error, setting class variable on instance</span>
<span class="n">Starship</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>     <span class="c1"># This is OK</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Final">
<code class="descclassname">typing.</code><code class="descname">Final</code><a class="headerlink" href="#typing.Final" title="정의 주소">¶</a></dt>
<dd><p>A special typing construct to indicate to type checkers that a name
cannot be re-assigned or overridden in a subclass. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">MAX_SIZE</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="mi">9000</span>
<span class="n">MAX_SIZE</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Error reported by type checker</span>

<span class="k">class</span> <span class="nc">Connection</span><span class="p">:</span>
    <span class="n">TIMEOUT</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">class</span> <span class="nc">FastConnector</span><span class="p">(</span><span class="n">Connection</span><span class="p">):</span>
    <span class="n">TIMEOUT</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Error reported by type checker</span>
</pre></div>
</div>
<p>There is no runtime checking of these properties. See <span class="target" id="index-23"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0591"><strong>PEP 591</strong></a> for
more details.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.AnyStr">
<code class="descclassname">typing.</code><code class="descname">AnyStr</code><a class="headerlink" href="#typing.AnyStr" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> is a type variable defined as
<code class="docutils literal notranslate"><span class="pre">AnyStr</span> <span class="pre">=</span> <span class="pre">TypeVar('AnyStr',</span> <span class="pre">str,</span> <span class="pre">bytes)</span></code>.</p>
<p>It is meant to be used for functions that may accept any kind of string
without allowing different kinds of strings to mix. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">concat</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Ok, output has type &#39;unicode&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Ok, output has type &#39;bytes&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Error, cannot mix unicode and bytes</span>
</pre></div>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.TYPE_CHECKING">
<code class="descclassname">typing.</code><code class="descname">TYPE_CHECKING</code><a class="headerlink" href="#typing.TYPE_CHECKING" title="정의 주소">¶</a></dt>
<dd><p>A special constant that is assumed to be <code class="docutils literal notranslate"><span class="pre">True</span></code> by 3rd party static
type checkers. It is <code class="docutils literal notranslate"><span class="pre">False</span></code> at runtime. Usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">expensive_mod</span>

<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="s1">&#39;expensive_mod.SomeType&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">local_var</span><span class="p">:</span> <span class="n">expensive_mod</span><span class="o">.</span><span class="n">AnotherType</span> <span class="o">=</span> <span class="n">other_fun</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that the first type annotation must be enclosed in quotes, making it a
&quot;forward reference&quot;, to hide the <code class="docutils literal notranslate"><span class="pre">expensive_mod</span></code> reference from the
interpreter runtime.  Type annotations for local variables are not
evaluated, so the second annotation does not need to be enclosed in quotes.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> --- 형 힌트 지원</a><ul>
<li><a class="reference internal" href="#type-aliases">형 에일리어스</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#callable">Callable</a></li>
<li><a class="reference internal" href="#generics">제네릭</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">사용자 정의 제네릭 형</a></li>
<li><a class="reference internal" href="#the-any-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code> 형</a></li>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping">명목적 대 구조적 서브 타이핑</a></li>
<li><a class="reference internal" href="#classes-functions-and-decorators">클래스, 함수 및 데코레이터</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="development.html"
                        title="이전 장">개발 도구</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="pydoc.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> --- 설명서 생성과 온라인 도움말 시스템</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc --- 설명서 생성과 온라인 도움말 시스템"
             >다음</a> |</li>
        <li class="right" >
          <a href="development.html" title="개발 도구"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >개발 도구</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>