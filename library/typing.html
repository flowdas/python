
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>typing --- 형 힌트 지원 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="pydoc --- 설명서 생성과 온라인 도움말 시스템" href="pydoc.html" />
    <link rel="prev" title="개발 도구" href="development.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/typing.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc --- 설명서 생성과 온라인 도움말 시스템"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="development.html" title="개발 도구"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">개발 도구</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-typing">
<span id="typing-support-for-type-hints"></span><h1><a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> --- 형 힌트 지원<a class="headerlink" href="#module-typing" title="제목 주소">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/typing.py">Lib/typing.py</a></p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>파이썬 런타임은 함수와 변수 형 어노테이션을 강제하지 않습니다. 형 어노테이션은 형 검사기, IDE, 린터(linter) 등과 같은 제삼자 도구에서 사용할 수 있습니다.</p>
</div>
<hr class="docutils" />
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>파이썬 3.5 이전 버전을 위한 <a class="reference external" href="https://pypi.org/project/typing/">역 이식</a> 도
제공됩니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>대표적인 정적 형 검사기는 <a class="reference external" href="http://mypy-lang.org/">mypy</a>입니다.</p>
</div>
<p>이 모듈은 <span class="target" id="index-52"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>, <span class="target" id="index-53"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>, <span class="target" id="index-54"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0544"><strong>PEP 544</strong></a>, <span class="target" id="index-55"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0586"><strong>PEP 586</strong></a>, <span class="target" id="index-56"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0589"><strong>PEP 589</strong></a> 및 <span class="target" id="index-57"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0591"><strong>PEP 591</strong></a>로 지정된 형 힌트에 대한 런타임 지원을 제공합니다. 가장 기본적인 지원은 형 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, <a class="reference internal" href="#typing.Union" title="typing.Union"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code></a>, <a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code></a>, <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a>, <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 및 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>으로 구성됩니다. 전체 명세는 <span class="target" id="index-58"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>를 참조하십시오. 형 힌트에 대한 간략한 소개는 <span class="target" id="index-59"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0483"><strong>PEP 483</strong></a>을 참조하십시오.</p>
<p>아래의 함수는 문자열을 취하고 반환하며 다음과 같이 어노테이트 되었습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greeting</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s1">&#39;Hello &#39;</span> <span class="o">+</span> <span class="n">name</span>
</pre></div>
</div>
<p>함수 <code class="docutils literal notranslate"><span class="pre">greeting</span></code>에서, 인자 <code class="docutils literal notranslate"><span class="pre">name</span></code>은 형 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로, 반환형은 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로 기대됩니다. 서브 형은 인자로 허용됩니다.</p>
<div class="section" id="type-aliases">
<h2>형 에일리어스<a class="headerlink" href="#type-aliases" title="제목 주소">¶</a></h2>
<p>형 에일리어스는 별칭에 형을 대입하여 정의됩니다. 이 예에서, <code class="docutils literal notranslate"><span class="pre">Vector</span></code>와 <code class="docutils literal notranslate"><span class="pre">List[float]</span></code>는 교환 가능한 동의어로 취급됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span>
<span class="n">Vector</span> <span class="o">=</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">scalar</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>

<span class="c1"># 형 검사 통과; float의 리스트는 Vector로 적합합니다.</span>
<span class="n">new_vector</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.2</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">])</span>
</pre></div>
</div>
<p>형 에일리어스는 복잡한 형 서명을 단순화하는 데 유용합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="n">ConnectionOptions</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">Address</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="n">Server</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Address</span><span class="p">,</span> <span class="n">ConnectionOptions</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Server</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># 정적 형 검사기는 이전 형 서명을 이것과 정확히 동등한 것으로 취급합니다.</span>
<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span>
        <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>형 힌트로서의 <code class="docutils literal notranslate"><span class="pre">None</span></code>은 특별한 경우이며 <code class="docutils literal notranslate"><span class="pre">type(None)</span></code>으로 치환됨에 유의하십시오.</p>
</div>
<div class="section" id="newtype">
<span id="distinct"></span><h2>NewType<a class="headerlink" href="#newtype" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-func docutils literal notranslate"><span class="pre">NewType()</span></code></a> 도우미 함수를 사용하여 다른 형을 만드십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">some_id</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">524313</span><span class="p">)</span>
</pre></div>
</div>
<p>정적 형 검사기는 새 형을 원래 형의 서브 클래스인 것처럼 다룹니다. 논리 에러를 잡는 데 유용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_user_name</span><span class="p">(</span><span class="n">user_id</span><span class="p">:</span> <span class="n">UserId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># 형 검사 통과</span>
<span class="n">user_a</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="n">UserId</span><span class="p">(</span><span class="mi">42351</span><span class="p">))</span>

<span class="c1"># 형 검사 실패; int는 UserId가 아닙니다</span>
<span class="n">user_b</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">UserId</span></code> 형의 변수에 대해 모든 <code class="docutils literal notranslate"><span class="pre">int</span></code> 연산을 여전히 수행할 수 있지만, 결과는 항상 <code class="docutils literal notranslate"><span class="pre">int</span></code> 형이 됩니다. 이것은 <code class="docutils literal notranslate"><span class="pre">int</span></code>가 기대되는 모든 곳에 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>를 전달할 수 있지만, 잘못된 방식으로 의도하지 않게 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>를 만들지 않도록 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &#39;output&#39;은 형 &#39;int&#39;입니다, &#39;UserId&#39;가 아닙니다</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">23413</span><span class="p">)</span> <span class="o">+</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">54341</span><span class="p">)</span>
</pre></div>
</div>
<p>이러한 검사는 정적 형 검사기에서만 적용됨에 유의하십시오. 실행 시간에, 문장 <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Base)</span></code>는 <code class="docutils literal notranslate"><span class="pre">Derived</span></code>를 전달하는 매개 변수를 즉시 반환하는 함수로 만듭니다. 이것은 <code class="docutils literal notranslate"><span class="pre">Derived(some_value)</span></code> 표현식이 새로운 클래스를 만들거나 일반 함수 호출을 넘어서는 오버헤드를 발생시키지 않음을 의미합니다.</p>
<p>더욱 정확하게, 표현식 <code class="docutils literal notranslate"><span class="pre">some_value</span> <span class="pre">is</span> <span class="pre">Derived(some_value)</span></code>는 실행 시간에 항상 참입니다.</p>
<p>이것은 또한 <code class="docutils literal notranslate"><span class="pre">Derived</span></code>의 서브 형을 만들 수 없다는 것을 의미하는데, 실행 시간에 항등함수(identity function)일 뿐 실제 형이 아니기 때문입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="c1"># 실행 시간에 실패하고 형 검사를 통과하지 못합니다</span>
<span class="k">class</span> <span class="nc">AdminUserId</span><span class="p">(</span><span class="n">UserId</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</div>
<p>그러나, '파생된' <code class="docutils literal notranslate"><span class="pre">NewType</span></code>을 기반으로 <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-func docutils literal notranslate"><span class="pre">NewType()</span></code></a>을 만들 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="n">ProUserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;ProUserId&#39;</span><span class="p">,</span> <span class="n">UserId</span><span class="p">)</span>
</pre></div>
</div>
<p>그리고 <code class="docutils literal notranslate"><span class="pre">ProUserId</span></code>에 대한 형 검사는 예상대로 작동합니다.</p>
<p>자세한 내용은 <span class="target" id="index-60"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>를 참조하십시오.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>형 에일리어스를 사용하면 두 형이 서로 <em>동등한</em> 것으로 선언됨을 상기하십시오. <code class="docutils literal notranslate"><span class="pre">Alias</span> <span class="pre">=</span> <span class="pre">Original</span></code>은 모든 경우 정적 형 검사기가 <code class="docutils literal notranslate"><span class="pre">Alias</span></code>를 <code class="docutils literal notranslate"><span class="pre">Original</span></code>과 <em>정확히 동등한</em> 것으로 취급하게 합니다. 이것은 복잡한 형 서명을 단순화하려는 경우에 유용합니다.</p>
<p>반면에, <code class="docutils literal notranslate"><span class="pre">NewType</span></code>은 한 형을 다른 형의 <em>서브 형</em>으로 선언합니다. <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Original)</span></code>은 정적 형 검사기가 <code class="docutils literal notranslate"><span class="pre">Derived</span></code>를 <code class="docutils literal notranslate"><span class="pre">Original</span></code>의 <em>서브 클래스</em>로 취급하게 합니다. 이는 <code class="docutils literal notranslate"><span class="pre">Original</span></code> 형의 값이 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 형의 값이 예상되는 위치에서 사용될 수 없음을 의미합니다. 실행 시간 비용을 최소화하면서 논리 에러를 방지하려는 경우에 유용합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</div>
<div class="section" id="callable">
<h2>Callable<a class="headerlink" href="#callable" title="제목 주소">¶</a></h2>
<p>특정 서명의 콜백 함수를 기대하는 프레임워크는 <code class="docutils literal notranslate"><span class="pre">Callable[[Arg1Type,</span> <span class="pre">Arg2Type],</span> <span class="pre">ReturnType]</span></code>을 사용하여 형 힌트를 제공할 수 있습니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">feeder</span><span class="p">(</span><span class="n">get_next_item</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># 바디</span>

<span class="k">def</span> <span class="nf">async_query</span><span class="p">(</span><span class="n">on_success</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">on_error</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># 바디</span>
</pre></div>
</div>
<p>형 힌트에서 인자 리스트를 리터럴 줄임표(ellipsis)로 대체하여 호출 서명을 지정하지 않고 콜러블의 반환 값을 선언할 수 있습니다: <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">ReturnType]</span></code>.</p>
</div>
<div class="section" id="generics">
<span id="id2"></span><h2>제네릭<a class="headerlink" href="#generics" title="제목 주소">¶</a></h2>
<p>컨테이너에 보관된 객체에 대한 형 정보는 일반적인 방식으로 정적으로 유추될 수 없기 때문에, 컨테이너 요소에 대해 기대되는 형을 나타내는 서명을 지원하도록 추상 베이스 클래스가 확장되었습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">def</span> <span class="nf">notify_by_email</span><span class="p">(</span><span class="n">employees</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Employee</span><span class="p">],</span>
                    <span class="n">overrides</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>제네릭은 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>라는 typing에서 제공되는 새로운 팩토리를 사용하여 매개 변수화될 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>      <span class="c1"># 형 변수를 선언합니다</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>   <span class="c1"># 제네릭 함수</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="user-defined-generic-types">
<h2>사용자 정의 제네릭 형<a class="headerlink" href="#user-defined-generic-types" title="제목 주소">¶</a></h2>
<p>사용자 정의 클래스는 제네릭 클래스로 정의 할 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="k">import</span> <span class="n">Logger</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LoggedVar</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Set &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Get &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p>베이스 클래스로서의 <code class="docutils literal notranslate"><span class="pre">Generic[T]</span></code>는 클래스 <code class="docutils literal notranslate"><span class="pre">LoggedVar</span></code>가 단일한 형 매개 변수 <code class="docutils literal notranslate"><span class="pre">T</span></code>를 취한다는 것을 정의합니다. 이는 또한 <code class="docutils literal notranslate"><span class="pre">T</span></code>를 클래스 바디 내에서 형으로 유효하게 만듭니다.</p>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 베이스 클래스는 <code class="docutils literal notranslate"><span class="pre">LoggedVar[t]</span></code>가 형으로 유효하도록 <a class="reference internal" href="../reference/datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>을 정의합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Iterable</span>

<span class="k">def</span> <span class="nf">zero_all_vars</span><span class="p">(</span><span class="nb">vars</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">LoggedVar</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">var</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>제네릭 형은 임의 개수의 형 변수를 가질 수 있으며, 형 변수는 제한될 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">StrangePair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>에 대한 각 형 변수 인자는 달라야 합니다. 그래서 이것은 잘못되었습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>   <span class="c1"># 유효하지 않습니다</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>으로 다중 상속을 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Sized</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>제네릭 클래스에서 상속할 때, 일부 형 변수를 고정할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Mapping</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MyDict</span><span class="p">(</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>이 경우 <code class="docutils literal notranslate"><span class="pre">MyDict</span></code>는 단일 매개 변수 <code class="docutils literal notranslate"><span class="pre">T</span></code>를 갖습니다.</p>
<p>형 매개 변수를 지정하지 않고 제네릭 클래스를 사용하는 것은 각 위치에 대해 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>를 가정합니다. 다음 예제에서, <code class="docutils literal notranslate"><span class="pre">MyIterable</span></code>은 제네릭이 아니지만 <code class="docutils literal notranslate"><span class="pre">Iterable[Any]</span></code>를 묵시적으로 상속합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">MyIterable</span><span class="p">(</span><span class="n">Iterable</span><span class="p">):</span> <span class="c1"># Iterable[Any]와 같습니다</span>
</pre></div>
</div>
<p>사용자 정의 제네릭 형 에일리어스도 지원됩니다. 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="n">Response</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span>

<span class="c1"># 여기서 반환형은 Union[Iterable[str], int]와 같습니다</span>
<span class="k">def</span> <span class="nf">response</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>
<span class="n">Vec</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">inproduct</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="c1"># Iterable[Tuple[T, T]]와 같습니다</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>에는 더는 사용자 정의 메타 클래스가 없습니다.</p>
</div>
<p>사용자 정의 제네릭 클래스는 메타 클래스 충돌 없이 베이스 클래스로 ABC를 가질 수 있습니다. 제네릭 메타 클래스는 지원되지 않습니다. 제네릭을 매개 변수화한 결과가 캐시 되며, typing 모듈의 대부분 형이 해시 가능하고 동등성을 비교할 수 있습니다.</p>
</div>
<div class="section" id="the-any-type">
<h2><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 형<a class="headerlink" href="#the-any-type" title="제목 주소">¶</a></h2>
<p>특수한 종류의 형은 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>입니다. 정적 형 검사기는 모든 형을 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>와 호환되는 것으로, <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>를 모든 형과 호환되는 것으로 취급합니다.</p>
<p>이것은 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 형의 값에 대해 어떤 연산이나 메서드 호출을 수행하고, 그것을 임의의 변수에 대입할 수 있다는 것을 의미합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Any</span>

<span class="n">a</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># type: Any</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1"># OK</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>       <span class="c1"># OK</span>

<span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>      <span class="c1"># type: str</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">a</span>       <span class="c1"># OK</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># 형 검사 통과; &#39;item&#39;은 임의의 형이 될 수 있습니다,</span>
    <span class="c1"># 그리고 그 형은 &#39;bar&#39; 메서드를 가질 수 있습니다</span>
    <span class="n">item</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 형의 값을 보다 구체적인 형에 대입할 때 형 검사가 수행되지 않음에 유의하십시오. 예를 들어, 정적 형 검사기는 <code class="docutils literal notranslate"><span class="pre">s</span></code>가 형 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로 선언되고 실행 시간에 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 값을 수신하더라도 <code class="docutils literal notranslate"><span class="pre">a</span></code>를 <code class="docutils literal notranslate"><span class="pre">s</span></code>에 대입할 때 에러를 보고하지 않았습니다!</p>
<p>또한, 반환형이나 매개 변수 형이 없는 모든 함수는 묵시적으로 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 기본값을 사용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="c1"># 정적 형 검사기는 위의 것이 다음과 같은 서명을 가진 것으로 취급합니다:</span>
<span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p>이 동작은 여러분이 동적으로 형이 지정되는 코드와 정적으로 형이 지정되는 코드를 혼합해야 할 때 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>를 <em>탈출구</em>로 사용할 수 있도록 합니다.</p>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>의 동작과 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>의 동작을 대조하십시오. <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>와 유사하게, 모든 형은 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>의 서브 형입니다. 그러나, <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>와는 달리, 그 반대는 사실이 아닙니다: <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>는 다른 모든 형의 서브 형이 <em>아닙</em>니다.</p>
<p>이것은 값의 형이 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>일 때, 형 검사기가 그것에 대한 거의 모든 연산을 거부하고, 그것을 더 특수한 형의 변수에 대입(또는 그것을 반환 값으로 사용)하는 것이 형 에러임을 의미합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hash_a</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># 실패; object에는 &#39;magic&#39; 메서드가 없습니다.</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">hash_b</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># 형 검사 통과</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="c1"># 형 검사 통과, int와 str이 object의 서브 클래스이기 때문</span>
<span class="n">hash_a</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_a</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># 형 검사 통과, Any가 모든 형과 호환되기 때문</span>
<span class="n">hash_b</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_b</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>값이 형 안전한 방식으로 모든 형이 될 수 있음을 표시하려면 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>를 사용하십시오. 값이 동적으로 형이 지정됨을 표시하려면 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>를 사용하십시오.</p>
</div>
<div class="section" id="nominal-vs-structural-subtyping">
<h2>명목적 대 구조적 서브 타이핑<a class="headerlink" href="#nominal-vs-structural-subtyping" title="제목 주소">¶</a></h2>
<p>처음에는 <span class="target" id="index-61"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>가 파이썬 정적 형 시스템을 <em>명목적 서브 타이핑(nominal subtyping)</em>을 사용하는 것으로 정의했습니다. 이것은 오직 <code class="docutils literal notranslate"><span class="pre">A</span></code>가 <code class="docutils literal notranslate"><span class="pre">B</span></code>의 서브 클래스일 때만 클래스 <code class="docutils literal notranslate"><span class="pre">B</span></code>가 기대되는 곳에 클래스 <code class="docutils literal notranslate"><span class="pre">A</span></code>가 허용됨을 의미합니다.</p>
<p>이 요구 사항은 이전에 <a class="reference internal" href="#typing.Iterable" title="typing.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>과 같은 추상 베이스 클래스에도 적용되었습니다. 이 접근 방식의 문제점은 이것을 지원하려면 클래스를 명시적으로 표시해야만 한다는 점입니다. 이는 파이썬답지 않고 관용적인 동적으로 형이 지정된 파이썬 코드에서 일반적으로 수행하는 것과는 다릅니다. 예를 들어, 이것은 <span class="target" id="index-62"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>를 만족합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="k">class</span> <span class="nc">Bucket</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p><span class="target" id="index-63"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0544"><strong>PEP 544</strong></a>는 사용자가 클래스 정의에서 명시적인 베이스 클래스 없이 위의 코드를 작성할 수 있게 함으로써 이 문제를 풀도록 합니다. 정적 형 검사기가 <code class="docutils literal notranslate"><span class="pre">Bucket</span></code>을 <code class="docutils literal notranslate"><span class="pre">Sized</span></code>와 <code class="docutils literal notranslate"><span class="pre">Iterable[int]</span></code>의 서브 형으로 묵시적으로 취급하도록 합니다. 이것은 <em>구조적 서브 타이핑(structural subtyping)</em>(또는 정적 덕 타이핑)으로 알려져 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">Bucket</span><span class="p">:</span>  <span class="c1"># 참고: 베이스 클래스가 없습니다</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">Bucket</span><span class="p">())</span>  <span class="c1"># 형 검사를 통과합니다</span>
</pre></div>
</div>
<p>또한, 특별한 클래스 <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>을 서브 클래싱 함으로써, 사용자는 새로운 사용자 정의 프로토콜을 정의하여 구조적 서브 타이핑을 완전히 누릴 수 있습니다 (아래 예를 참조하십시오).</p>
</div>
<div class="section" id="classes-functions-and-decorators">
<h2>클래스, 함수 및 데코레이터<a class="headerlink" href="#classes-functions-and-decorators" title="제목 주소">¶</a></h2>
<p>모듈은 다음 클래스, 함수 및 데코레이터를 정의합니다:</p>
<dl class="class">
<dt id="typing.TypeVar">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">TypeVar</code><a class="headerlink" href="#typing.TypeVar" title="정의 주소">¶</a></dt>
<dd><p>형 변수.</p>
<p>용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># 무엇이든 될 수 있습니다</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># str이나 bytes여야 합니다</span>
</pre></div>
</div>
<p>형 변수는 주로 정적 형 검사기를 위해 존재합니다. 이들은 제네릭 함수 정의뿐만 아니라 제네릭 형의 매개 변수 역할을 합니다. 제네릭 형에 대한 자세한 내용은 Generic 클래스를 참조하십시오. 제네릭 함수는 다음과 같이 작동합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;x에 대한 n개의 참조가 포함된 리스트를 반환합니다.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>

<span class="k">def</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;두 문자열 중 가장 긴 문자열을 반환합니다.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>
</div>
<p>후자의 예의 서명은 기본적으로 <code class="docutils literal notranslate"><span class="pre">(str,</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></code>과 <code class="docutils literal notranslate"><span class="pre">(bytes,</span> <span class="pre">bytes)</span> <span class="pre">-&gt;</span> <span class="pre">bytes</span></code>의 오버로딩입니다. 또한 인자가 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>의 어떤 서브 클래스의 인스턴스면 반환형은 여전히 일반 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>임에 유의하십시오.</p>
<p>실행 시간에, <code class="docutils literal notranslate"><span class="pre">isinstance(x,</span> <span class="pre">T)</span></code>는 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다. 일반적으로, <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>와 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>는 형과 함께 사용하면 안 됩니다.</p>
<p>형 변수는 <code class="docutils literal notranslate"><span class="pre">covariant=True</span></code>나 <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code>를 전달하여 공변적(covariant)이나 반변적(contravariant)으로 표시될 수 있습니다. 자세한 내용은 <span class="target" id="index-64"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>를 참조하십시오. 기본적으로 형 변수는 불변적(invariant)입니다. 대안적으로, 형 변수는 <code class="docutils literal notranslate"><span class="pre">bound=&lt;type&gt;</span></code>을 사용하여 상한을 지정할 수 있습니다. 이것은 형 변수에 (명시적으로나 묵시적으로) 치환되는 실제 형이 상한 형의 서브 클래스여야 함을 의미합니다, <span class="target" id="index-65"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>를 참조하십시오.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>제네릭 형의 공변성(covariancy)은 세 가지 상태를 갖습니다: 불변적(invariant),
공변적(covariant), 반변적(contravariant). 형 변수에서 지정되기는 하지만, 공변성은
형 변수의 성질이라기보다는, 이 변수를 사용하여 선언되는 제네릭 형의 성질입니다. 다만,
여러 개의 형 변수를 사용하는 제네릭 형은 형 변수마다 다른 공변성을 가질 수 있기 때문에,
형 변수를 통해 지정합니다. 또한 제네릭 함수에 사용되는 형 변수는 <code class="docutils literal notranslate"><span class="pre">covariant</span></code>나
<code class="docutils literal notranslate"><span class="pre">contravariant</span></code>를 지정하지 않아야 합니다.</p>
<p>제네릭 형이 불변적(기본값)이면 형 변수에 치환되는 실제 형은 선언된 형과 정확히 일치해야 합니다.
공변적이면 실제 형은 선언된 형의 서브 형이 허용됩니다. 반변적인 것은 공변적인 것과 정확히
반대의 성질을 가집니다.</p>
<p>공변성은 간단한 형의 서브 타이핑 관계와 이를 사용한 복잡한 형의 서브 타이핑 관계가 어떻게
연관되는지를 정의합니다. 예를 들어 두 클래스 <code class="docutils literal notranslate"><span class="pre">Base</span></code> 와 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 가 있고,
<code class="docutils literal notranslate"><span class="pre">Base</span></code> 가 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 의 베이스 클래스라고 합시다. <code class="docutils literal notranslate"><span class="pre">Base</span></code>라고 형을 선언한
변수에는 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 형의 값을 대입할 수 있습니다. 이것이 간단한 형의 서브 타이핑 관계입니다.</p>
<p>이제 <code class="docutils literal notranslate"><span class="pre">List[Base]</span></code>라고 형을 선언한 변수를 생각해 봅시다. 이 변수에 <code class="docutils literal notranslate"><span class="pre">List[Derived]</span></code>
형의 값을 대입하도록 허락해야 할까요? 만약 허락한다면 (이것을 공변적이라고 합니다), 이후에
<code class="docutils literal notranslate"><span class="pre">List[Base]</span></code>라고 선언된 변수의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> 메서드 호출도 허용해야 하는데,
이 메서드는 당연히 <code class="docutils literal notranslate"><span class="pre">Base</span></code> 형의 값을 리스트에 추가할 수 있습니다. 그러면 메서드 호출 이후에
<code class="docutils literal notranslate"><span class="pre">List[Derived]</span></code>라고 형이 선언된 값에 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 가 아니라, 단순히 <code class="docutils literal notranslate"><span class="pre">Base</span></code> 형의
값이 들어가게 되었습니다. 하지만, <code class="docutils literal notranslate"><span class="pre">List[Derived]</span></code>라고 선언하는 것은, 이 리스트에는
<code class="docutils literal notranslate"><span class="pre">Derived</span></code>나 <code class="docutils literal notranslate"><span class="pre">Derived</span></code>의 서브 클래스만 넣겠다는 의사 표현일 수도 있습니다. 이런
관점에서 본다면 앞의 대입은 금지되어야 합니다 (실행 시간에 금지되지는 않습니다. 형 검사가 실패로
간주할 뿐입니다). 이 때문에 <a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a>에서 정의되는 모든 가변(mutable) 컨테이너들은 불변적(invariant)
입니다.</p>
<p>하지만 모든 컨테이너가 불변적(invariant)일 필요는 없습니다. 앞에서 예시한 문제는 컨테이너를 수정할 때만 발생함에
유의하십시오. 튜플 같은 불변(immutable) 컨테이너에서는 이런 문제가 없습니다. 따라서 <a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a>에서
정의되는 모든 불변(immutable) 컨테이너는 공변적(covariant)으로 정의되어 있습니다.</p>
<p>반변적(contravariant)인 관계는 약간 복잡해 보이지만 설명해 보겠습니다. <a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 모듈에서 제공되는
반변성은 <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>와 이와 유사한 제네릭 형(<a class="reference internal" href="#typing.AsyncGenerator" title="typing.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncGenerator</span></code></a>, <a class="reference internal" href="#typing.Coroutine" title="typing.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Coroutine</span></code></a>, ...)에서
찾을 수 있습니다. <code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code> 메서드의 인자로 전달되는 형이 반변적입니다. 이 형(<code class="docutils literal notranslate"><span class="pre">SendType</span></code>)을
<code class="docutils literal notranslate"><span class="pre">Derived</span></code>라고 선언한 제너레이터(<code class="docutils literal notranslate"><span class="pre">Generator[...,</span> <span class="pre">SendType,</span> <span class="pre">...]</span></code>)를 저장하는 변수 <code class="docutils literal notranslate"><span class="pre">g</span></code>를 생각해 봅시다.
이 변수를 사용하는 코드는 <code class="docutils literal notranslate"><span class="pre">g.send(Derived())</span></code> 와 같은 호출을 하고 있을 겁니다. 한편, 이 변수에 대입되는
제너레이터의 코드는 <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">yield</span></code> 와 같은 식으로 <code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code>가 보낸 값을 받을 겁니다.
만약 <code class="docutils literal notranslate"><span class="pre">v</span></code>의 형이 <code class="docutils literal notranslate"><span class="pre">Base</span></code>로 선언되어 있더라도, <code class="docutils literal notranslate"><span class="pre">Derived()</span></code>가 대입되는 것은 문제가 되지 않습니다.
하지만 <code class="docutils literal notranslate"><span class="pre">v</span></code>의 형이 <code class="docutils literal notranslate"><span class="pre">Derived</span></code>의 서브 클래스 (<code class="docutils literal notranslate"><span class="pre">MoreDerived</span></code>)라면 문제가 됩니다. 이는 변수 <code class="docutils literal notranslate"><span class="pre">g</span></code>에
<code class="docutils literal notranslate"><span class="pre">Generator[...,</span> <span class="pre">Base,</span> <span class="pre">...]</span></code>를 대입하는 것은 허락해야 하지만, <code class="docutils literal notranslate"><span class="pre">Generator[...,</span> <span class="pre">MoreDerived,</span> <span class="pre">...]</span></code>를
대입하는 것은 금지해야 한다는 뜻이 됩니다. 이것이 <code class="docutils literal notranslate"><span class="pre">SendType</span></code>이 반변적이어야 하는 이유입니다.</p>
<p>제네릭 형에서 형 변수들의 공변성은 중요합니다. 설명서에서 따로 명시하고 있지는 않지만, 공변적인 형 변수에는 <code class="docutils literal notranslate"><span class="pre">_co</span></code> 접미사를,
반변적인 형 변수에는 <code class="docutils literal notranslate"><span class="pre">_contra</span></code> 접미사를 붙이고, 불변적인 형 변수는 접미사 없이 표현하고 있습니다. 여러분의 코드에서도
이런 규칙을 지키는 것이 좋습니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Generic">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Generic</code><a class="headerlink" href="#typing.Generic" title="정의 주소">¶</a></dt>
<dd><p>제네릭 형을 위한 추상 베이스 클래스.</p>
<p>제네릭 형은 일반적으로 이 클래스를 하나 이상의 형 변수로 인스턴스 화한 것을 상속하여 선언됩니다. 예를 들어, 제네릭 매핑형은 다음과 같이 정의할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># 등등.</span>
</pre></div>
</div>
<p>이 클래스는 다음과 같이 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lookup_name</span><span class="p">(</span><span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Y</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Protocol">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Protocol</code><span class="sig-paren">(</span><em class="sig-param">Generic</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Protocol" title="정의 주소">¶</a></dt>
<dd><p>프로토콜 클래스의 베이스 클래스. 프로토콜 클래스는 다음과 같이 정의됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Proto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>이러한 클래스는 주로 구조적 서브 타이핑(정적 덕 타이핑)을 인식하는 정적 형 검사기와 함께 사용됩니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Proto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>

<span class="n">func</span><span class="p">(</span><span class="n">C</span><span class="p">())</span>  <span class="c1"># 정적 형 검사를 통과합니다</span>
</pre></div>
</div>
<p>자세한 내용은 <span class="target" id="index-66"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0544"><strong>PEP 544</strong></a>를 참조하십시오. <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a>(아래에서 설명합니다)로 데코레이트 된 프로토콜 클래스는 주어진 어트리뷰트의 존재 여부만 확인하고 형 서명을 무시하는 단순한 실행 시간 프로토콜로 작동합니다.</p>
<p>프로토콜 클래스는 제네릭일 수 있습니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GenProto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Type">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Type</code><span class="sig-paren">(</span><em class="sig-param">Generic[CT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Type" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">C</span></code>로 어노테이트 된 변수는 <code class="docutils literal notranslate"><span class="pre">C</span></code> 형의 값을 받아들일 수 있습니다. 대조적으로, <code class="docutils literal notranslate"><span class="pre">Type[C]</span></code>로 어노테이트 된 변수는 클래스 자신인 값을 받아들일 수 있습니다 -- 구체적으로, <code class="docutils literal notranslate"><span class="pre">C</span></code>의 <em>클래스 객체</em>를 허용합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>         <span class="c1"># 형 &#39;int&#39; 입니다</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">int</span>       <span class="c1"># 형 &#39;Type[int]&#39; 입니다</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># 역시 형 &#39;Type[int]&#39; 입니다</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Type[C]</span></code>는 공변적(covariant)입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">BasicUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">ProUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">TeamUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>

<span class="c1"># User, BasicUser, ProUser, TeamUser, ... 를 허용합니다</span>
<span class="k">def</span> <span class="nf">make_new_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">User</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">User</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">user_class</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Type[C]</span></code>가 공변적(covariant)이라는 사실은 <code class="docutils literal notranslate"><span class="pre">C</span></code>의 모든 서브 클래스가 <code class="docutils literal notranslate"><span class="pre">C</span></code>와 같은 생성자 서명과 클래스 메서드 서명을 구현해야 함을 의미합니다. 형 검사기는 이 위반을 표시해야 하지만, 표시된 베이스 클래스의 생성자 호출과 일치하는 서브 클래스의 생성자 호출을 허용해야 합니다. 이 특별한 경우를 처리하기 위한 형 검사기의 요구 사항은 향후 <span class="target" id="index-67"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> 개정판에서 변경될 수 있습니다.</p>
<p><a class="reference internal" href="#typing.Type" title="typing.Type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Type</span></code></a>의 합법적인 매개 변수는 클래스, <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, <a class="reference internal" href="#generics"><span class="std std-ref">형 변수</span></a> 및 이러한 형들의 공용체(union)뿐입니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">new_non_team_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">BaseUser</span><span class="p">,</span> <span class="n">ProUser</span><span class="p">]]):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Type[Any]</span></code>는 <code class="docutils literal notranslate"><span class="pre">Type</span></code>과 동등하며, 이는 다시 파이썬의 메타 클래스 계층 구조의 루트인 <code class="docutils literal notranslate"><span class="pre">type</span></code>과 동등합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Iterable">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Iterable</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterable" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Iterator">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Iterator</code><span class="sig-paren">(</span><em class="sig-param">Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterator" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Reversible">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Reversible</code><span class="sig-paren">(</span><em class="sig-param">Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Reversible" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsInt">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsInt</code><a class="headerlink" href="#typing.SupportsInt" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__int__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsFloat">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsFloat</code><a class="headerlink" href="#typing.SupportsFloat" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__float__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsComplex">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsComplex</code><a class="headerlink" href="#typing.SupportsComplex" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__complex__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsBytes">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsBytes</code><a class="headerlink" href="#typing.SupportsBytes" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__bytes__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsIndex">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsIndex</code><a class="headerlink" href="#typing.SupportsIndex" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__index__</span></code>를 가진 ABC.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsAbs">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsAbs</code><a class="headerlink" href="#typing.SupportsAbs" title="정의 주소">¶</a></dt>
<dd><p>반환형이 공변적(covariant)인 하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__abs__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsRound">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsRound</code><a class="headerlink" href="#typing.SupportsRound" title="정의 주소">¶</a></dt>
<dd><p>반환형이 공변적(covariant)인 하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__round__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Container">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Container</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Container" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Hashable">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Hashable</code><a class="headerlink" href="#typing.Hashable" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Hashable</span></code></a>에 대한 별칭</p>
</dd></dl>

<dl class="class">
<dt id="typing.Sized">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Sized</code><a class="headerlink" href="#typing.Sized" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></a>에 대한 별칭</p>
</dd></dl>

<dl class="class">
<dt id="typing.Collection">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Collection</code><span class="sig-paren">(</span><em class="sig-param">Sized, Iterable[T_co], Container[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Collection" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a>의 제네릭 버전</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.0에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AbstractSet">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AbstractSet</code><span class="sig-paren">(</span><em class="sig-param">Sized, Collection[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AbstractSet" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.MutableSet">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">MutableSet</code><span class="sig-paren">(</span><em class="sig-param">AbstractSet[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSet" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Mapping">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Mapping</code><span class="sig-paren">(</span><em class="sig-param">Sized, Collection[KT], Generic[VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Mapping" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a>의 제네릭 버전. 이 형은 다음과 같이 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_position_in_index</span><span class="p">(</span><span class="n">word_list</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">word_list</span><span class="p">[</span><span class="n">word</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.MutableMapping">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">MutableMapping</code><span class="sig-paren">(</span><em class="sig-param">Mapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableMapping" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Sequence">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Sequence</code><span class="sig-paren">(</span><em class="sig-param">Reversible[T_co], Collection[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Sequence" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.MutableSequence">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">MutableSequence</code><span class="sig-paren">(</span><em class="sig-param">Sequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSequence" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.ByteString">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ByteString</code><span class="sig-paren">(</span><em class="sig-param">Sequence[int]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ByteString" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ByteString</span></code></a>의 제네릭 버전.</p>
<p>이 형은 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 및 <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 형을 나타냅니다.</p>
<p>이 형의 줄임 표현으로, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>는 위에 언급된 모든 형의 인자를 어노테이트하는 데 사용될 수 있습니다.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Deque">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Deque</code><span class="sig-paren">(</span><em class="sig-param">deque, MutableSequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Deque" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.List">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">List</code><span class="sig-paren">(</span><em class="sig-param">list, MutableSequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.List" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>의 제네릭 버전. 반환형을 어노테이트하는 데 유용합니다. 인자를 어노테이트 하려면 <a class="reference internal" href="#typing.Sequence" title="typing.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a>나 <a class="reference internal" href="#typing.Iterable" title="typing.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>과 같은 추상 컬렉션 형을 사용하는 것이 좋습니다.</p>
<p>이 형은 다음과 같이 사용될 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">vec2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">keep_positives</span><span class="p">(</span><span class="n">vector</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">vector</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Set">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Set</code><span class="sig-paren">(</span><em class="sig-param">set, MutableSet[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Set" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a>의 제네릭 버전. 반환형을 어노테이트하는 데 유용합니다. 인자를 어노테이트 하려면 <a class="reference internal" href="#typing.AbstractSet" title="typing.AbstractSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractSet</span></code></a>과 같은 추상 컬렉션 형을 사용하는 것이 좋습니다.</p>
</dd></dl>

<dl class="class">
<dt id="typing.FrozenSet">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">FrozenSet</code><span class="sig-paren">(</span><em class="sig-param">frozenset, AbstractSet[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.FrozenSet" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.MappingView">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">MappingView</code><span class="sig-paren">(</span><em class="sig-param">Sized, Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MappingView" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.KeysView">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">KeysView</code><span class="sig-paren">(</span><em class="sig-param">MappingView[KT_co], AbstractSet[KT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.KeysView" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.ItemsView">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ItemsView</code><span class="sig-paren">(</span><em class="sig-param">MappingView, Generic[KT_co, VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ItemsView" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.ValuesView">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ValuesView</code><span class="sig-paren">(</span><em class="sig-param">MappingView[VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ValuesView" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a>의 제네릭 버전.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Awaitable">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Awaitable</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Awaitable" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Coroutine">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Coroutine</code><span class="sig-paren">(</span><em class="sig-param">Awaitable[V_co], Generic[T_co T_contra, V_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Coroutine" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a>의 제네릭 버전. 형 변수의 변화와 순서는 <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>의 것과 같습니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Coroutine</span>
<span class="n">c</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># type: Coroutine[List[str], str, int]</span>
<span class="o">...</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hi&#39;</span><span class="p">)</span> <span class="c1"># type: List[str]</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="k">await</span> <span class="n">c</span> <span class="c1"># type: int</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncIterable">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AsyncIterable</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterable" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncIterator">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AsyncIterator</code><span class="sig-paren">(</span><em class="sig-param">AsyncIterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterator" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.ContextManager">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ContextManager</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ContextManager" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a> 의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.0에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncContextManager">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AsyncContextManager</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncContextManager" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a> 의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Dict">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Dict</code><span class="sig-paren">(</span><em class="sig-param">dict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Dict" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>의 제네릭 버전. 반환형을 어노테이트하는 데 유용합니다. 인자를 어노테이트 하려면 <a class="reference internal" href="#typing.Mapping" title="typing.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a>과 같은 추상 컬렉션 형을 사용하는 것이 좋습니다.</p>
<p>이 형은 다음과 같이 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_words</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.DefaultDict">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">DefaultDict</code><span class="sig-paren">(</span><em class="sig-param">collections.defaultdict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.DefaultDict" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.OrderedDict">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">OrderedDict</code><span class="sig-paren">(</span><em class="sig-param">collections.OrderedDict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.OrderedDict" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Counter">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Counter</code><span class="sig-paren">(</span><em class="sig-param">collections.Counter, Dict[T, int]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Counter" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.ChainMap">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ChainMap</code><span class="sig-paren">(</span><em class="sig-param">collections.ChainMap, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ChainMap" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Generator">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Generator</code><span class="sig-paren">(</span><em class="sig-param">Iterator[T_co], Generic[T_co, T_contra, V_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Generator" title="정의 주소">¶</a></dt>
<dd><p>제너레이터는 제네릭 형 <code class="docutils literal notranslate"><span class="pre">Generator[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></code>으로 어노테이트할 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Done&#39;</span>
</pre></div>
</div>
<p>typing 모듈의 다른 많은 제네릭과 달리 <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">SendType</span></code>은 공변적(covariant)이거나 불변적(invariant)이 아니라 반변적(contravariant)으로 행동함에 유의하십시오.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>이에 대한 설명은 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>에 붙인 주석을 참조하십시오.</p>
</div>
<p>제너레이터가 값을 일드(yield)하기만 하면, <code class="docutils literal notranslate"><span class="pre">SendType</span></code>과 <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code>을 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>또는, <code class="docutils literal notranslate"><span class="pre">Iterable[YieldType]</span></code>이나 <code class="docutils literal notranslate"><span class="pre">Iterator[YieldType]</span></code> 중 하나의 반환형을 갖는 것으로 제너레이터를 어노테이트 하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncGenerator">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AsyncGenerator</code><span class="sig-paren">(</span><em class="sig-param">AsyncIterator[T_co], Generic[T_co, T_contra]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncGenerator" title="정의 주소">¶</a></dt>
<dd><p>비동기 제너레이터는 제네릭 형 <code class="docutils literal notranslate"><span class="pre">AsyncGenerator[YieldType,</span> <span class="pre">SendType]</span></code>으로 어노테이트할 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">rounded</span> <span class="o">=</span> <span class="k">await</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">rounded</span>
</pre></div>
</div>
<p>일반 제너레이터와 달리, 비동기 제너레이터는 값을 반환할 수 없기 때문에, <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> 형 매개 변수가 없습니다. <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>와 마찬가지로, <code class="docutils literal notranslate"><span class="pre">SendType</span></code>은 반변적(contravariant)으로 행동합니다.</p>
<p>제너레이터가 값을 일드(yield)하기만 하면, <code class="docutils literal notranslate"><span class="pre">SendType</span></code>을 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<p>또는, <code class="docutils literal notranslate"><span class="pre">AsyncIterable[YieldType]</span></code>이나 <code class="docutils literal notranslate"><span class="pre">AsyncIterator[YieldType]</span></code> 중 하나의 반환형을 갖는 것으로 제너레이터를 어노테이트 하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Text">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Text</code><a class="headerlink" href="#typing.Text" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Text</span></code>는 <code class="docutils literal notranslate"><span class="pre">str</span></code>의 별칭입니다. 파이썬 2 코드를 위한 상위 호환 경로를 제공하기 위해 제공됩니다: 파이썬 2에서, <code class="docutils literal notranslate"><span class="pre">Text</span></code>는 <code class="docutils literal notranslate"><span class="pre">unicode</span></code>의 별칭입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">Text</span></code>를 사용하여 값이 파이썬 2와 파이썬 3 모두와 호환되는 방식으로 유니코드 문자열을 포함해야 함을 나타내십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_unicode_checkmark</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Text</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">text</span> <span class="o">+</span> <span class="sa">u</span><span class="s1">&#39; </span><span class="se">\u2713</span><span class="s1">&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.IO">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">IO</code><a class="headerlink" href="#typing.IO" title="정의 주소">¶</a></dt>
<dt id="typing.TextIO">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">TextIO</code><a class="headerlink" href="#typing.TextIO" title="정의 주소">¶</a></dt>
<dt id="typing.BinaryIO">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">BinaryIO</code><a class="headerlink" href="#typing.BinaryIO" title="정의 주소">¶</a></dt>
<dd><p>제네릭 형 <code class="docutils literal notranslate"><span class="pre">IO[AnyStr]</span></code>와 서브 클래스 <code class="docutils literal notranslate"><span class="pre">TextIO(IO[str])</span></code> 및 <code class="docutils literal notranslate"><span class="pre">BinaryIO(IO[bytes])</span></code>는 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>에 의해 반환되는 것과 같은 I/O 스트림 형을 나타냅니다.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Pattern">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Pattern</code><a class="headerlink" href="#typing.Pattern" title="정의 주소">¶</a></dt>
<dt id="typing.Match">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Match</code><a class="headerlink" href="#typing.Match" title="정의 주소">¶</a></dt>
<dd><p>이 형 에일리어스는 <a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>과 <a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a>의 반환형에 해당합니다. 이러한 형(및 해당 함수)은 <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code>로 제네릭하며 <code class="docutils literal notranslate"><span class="pre">Pattern[str]</span></code>, <code class="docutils literal notranslate"><span class="pre">Pattern[bytes]</span></code>, <code class="docutils literal notranslate"><span class="pre">Match[str]</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">Match[bytes]</span></code>로 써서 구체적으로 만들 수 있습니다.</p>
</dd></dl>

<dl class="class">
<dt id="typing.NamedTuple">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">NamedTuple</code><a class="headerlink" href="#typing.NamedTuple" title="정의 주소">¶</a></dt>
<dd><p>형 지정된(typed) <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a> 버전.</p>
<p>용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>이것은 다음과 동등합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>필드에 기본값을 부여하려면, 클래스 바디에서 그 값을 대입할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">employee</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">employee</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p>기본값이 있는 필드는 기본값이 없는 모든 필드 뒤에 와야 합니다.</p>
<p>결과 클래스에는 필드 이름을 필드형에 매핑하는 딕셔너리를 제공하는 추가 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code>가 있습니다. (필드 이름은 <code class="docutils literal notranslate"><span class="pre">_fields</span></code> 어트리뷰트에 있고 기본값은 <code class="docutils literal notranslate"><span class="pre">_field_defaults</span></code> 어트리뷰트에 있는데, 모두 namedtuple API의 일부입니다.)</p>
<p><code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> 서브 클래스는 독스트링과 메서드도 가질 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;종업원을 나타냅니다.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="s1">&#39;&lt;Employee </span><span class="si">{self.name}</span><span class="s1">, id=</span><span class="si">{self.id}</span><span class="s1">&gt;&#39;</span>
</pre></div>
</div>
<p>이전 버전과 호환되는 사용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><span class="target" id="index-68"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> 변수 어노테이션 문법 지원을 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6.1에서 변경: </span>기본값, 메서드 및 독스트링에 대한 지원을 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><code class="docutils literal notranslate"><span class="pre">_field_types</span></code>와 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 어트리뷰트는 이제 <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code> 인스턴스가 아닌 일반 딕셔너리입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span><code class="docutils literal notranslate"><span class="pre">_field_types</span></code> 어트리뷰트를 제거하고, 같은 정보를 가지는 더 표준적인 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 어트리뷰트로 대체했습니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.TypedDict">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">TypedDict</code><span class="sig-paren">(</span><em class="sig-param">dict</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypedDict" title="정의 주소">¶</a></dt>
<dd><p>간단한 형 지정된(typed) 이름 공간. 실행 시간에 일반 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>와 동등합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>는 모든 인스턴스가 각 키가 일관된 형의 값에 연관되는, 특정한 키 집합을 갖도록 기대되는 딕셔너리 형을 만듭니다. 이 기대는 실행 시간에는 검사되지 않고, 형 검사기에서만 강제됩니다. 사용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;good&#39;</span><span class="p">}</span>  <span class="c1"># OK</span>
<span class="n">b</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;bad&#39;</span><span class="p">}</span>           <span class="c1"># 형 검사에 실패합니다</span>

<span class="k">assert</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>인트로스펙션을 위한 형 정보는 <code class="docutils literal notranslate"><span class="pre">Point2D.__annotations__</span></code>와 <code class="docutils literal notranslate"><span class="pre">Point2D.__total__</span></code>을 통해 액세스할 수 있습니다. <span class="target" id="index-69"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>을 지원하지 않는 이전 버전의 파이썬에서 이 기능을 사용하도록 하기 위해, <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>는 두 개의 추가 문법 형식을 지원합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})</span>
</pre></div>
</div>
<p>기본적으로 모든 키는 TypedDict에 있어야 합니다. total을 지정하여 이를 재정의할 수 있습니다. 용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>이것은 point2D TypedDict는 모든 키를 생략 할 수 있다는 뜻입니다. 형 검사기는 total 인자의 값으로 리터럴 False나 True만 지원해야 합니다. 기본값은 True이며, 클래스 본문에 정의된 모든 항목이 필수가 되도록 합니다.</p>
<p>추가 예제와 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>를 사용하는 자세한 규칙은 <span class="target" id="index-70"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0589"><strong>PEP 589</strong></a>를 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.ForwardRef">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ForwardRef</code><a class="headerlink" href="#typing.ForwardRef" title="정의 주소">¶</a></dt>
<dd><p>문자열 전방 참조의 내부 typing 표현에 사용되는 클래스. 예를 들어, <code class="docutils literal notranslate"><span class="pre">List[&quot;SomeClass&quot;]</span></code>는 묵시적으로 <code class="docutils literal notranslate"><span class="pre">List[ForwardRef(&quot;SomeClass&quot;)]</span></code>로 변환됩니다. 이 클래스는 사용자가 인스턴스 화해서는 안 되지만, 인트로스펙션 도구에서 사용할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="typing.NewType">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">NewType</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">tp</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.NewType" title="정의 주소">¶</a></dt>
<dd><p>형 검사기에 구별되는 형을 가리키는 도우미 함수, <a class="reference internal" href="#distinct"><span class="std std-ref">NewType</span></a>을 참조하십시오. 실행 시간에 인자를 반환하는 함수를 반환합니다. 용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">first_user</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.cast">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">cast</code><span class="sig-paren">(</span><em class="sig-param">typ</em>, <em class="sig-param">val</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.cast" title="정의 주소">¶</a></dt>
<dd><p>값을 형으로 변환합니다.</p>
<p>값을 변경하지 않고 반환합니다. 형 검사기에서는 반환 값이 지정된 형임을 나타내지만, 실행 시간에는 의도적으로 아무것도 확인하지 않습니다 (우리는 이것이 가능한 한 빠르기를 원합니다).</p>
</dd></dl>

<dl class="function">
<dt id="typing.get_type_hints">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">get_type_hints</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">globalns=None</em>, <em class="sig-param">localns=None</em>, <em class="sig-param">include_extras=False</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_type_hints" title="정의 주소">¶</a></dt>
<dd><p>함수, 메서드, 모듈 또는 클래스 객체에 대한 형 힌트가 포함된 딕셔너리를 반환합니다.</p>
<p>이것은 종종 <code class="docutils literal notranslate"><span class="pre">obj.__annotations__</span></code>와 같습니다. 또한, 문자열 리터럴로 인코딩된 전방 참조는 <code class="docutils literal notranslate"><span class="pre">globals</span></code>와 <code class="docutils literal notranslate"><span class="pre">locals</span></code> 이름 공간에서 이를 평가하여 처리됩니다. 필요하면, 기본값이 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정되면 함수와 메서드 어노테이션에 <code class="docutils literal notranslate"><span class="pre">Optional[t]</span></code>가 추가됩니다. 클래스 <code class="docutils literal notranslate"><span class="pre">C</span></code>에 대해, <code class="docutils literal notranslate"><span class="pre">C.__mro__</span></code>의 역순으로 모든 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code>를 병합하여 만든 딕셔너리를 반환합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">include_extras</span></code>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정되어 있지 않은 한, 이 함수는 모든 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">...]</span></code>를 <code class="docutils literal notranslate"><span class="pre">T</span></code>로 재귀적으로 치환합니다 (자세한 내용은 <a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Annotated</span></code></a>를 참조하십시오). 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;some marker&#39;</span><span class="p">]</span>

<span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
<span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
<span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span>
    <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;some marker&#39;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span><span class="target" id="index-71"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0593"><strong>PEP 593</strong></a>의 일부로 <code class="docutils literal notranslate"><span class="pre">include_extras</span></code> 매개 변수를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.get_origin">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">get_origin</code><span class="sig-paren">(</span><em class="sig-param">tp</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_origin" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="typing.get_args">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">get_args</code><span class="sig-paren">(</span><em class="sig-param">tp</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_args" title="정의 주소">¶</a></dt>
<dd><p>제네릭 형과 특수 typing 형식에 대한 기본적인 인트로스펙션을 제공합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">X[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> 형식의 typing 객체의 경우, 이 함수는 <code class="docutils literal notranslate"><span class="pre">X</span></code>와 <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code>를 반환합니다. <code class="docutils literal notranslate"><span class="pre">X</span></code>가 내장이나 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 클래스의 제네릭 에일리어스인 경우, 원래 클래스로 정규화됩니다. 지원되지 않는 객체의 경우 각각 <code class="docutils literal notranslate"><span class="pre">None</span></code>과 <code class="docutils literal notranslate"><span class="pre">()</span></code>를 반환합니다. 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Union</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>정규화는 내장이나 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 클래스로만 제한되지는 않습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Union</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.overload">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">overload</code><a class="headerlink" href="#typing.overload" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 데코레이터는 여러 가지 다양한 인자형의 조합을 지원하는 함수와 메서드를 기술할 수 있도록 합니다. <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>로 데코레이트 된 일련의 정의에는 (같은 함수/메서드에 대해) 정확히 하나의 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>로 데코레이트 되지 않은 정의가 뒤따라야 합니다. <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>로 데코레이트 된 정의는 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>로 데코레이트 되지 않은 정의에 의해 덮어 쓰이기 때문에 형 검사기만을 위한 것입니다. 후자는 실행 시간에 사용되지만, 형 검사기에서는 무시되어야 합니다. 실행 시간에, <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>로 데코레이트 된 함수를 직접 호출하면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 가 발생합니다. 공용체(union)나 형 변수를 사용하여 표현할 수 있는 것보다 더 정밀한 형을 제공하는 오버로드의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">actual</span> <span class="n">implementation</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>자세한 내용과 다른 typing 의미와의 비교는 <span class="target" id="index-72"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>를 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="typing.final">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">final</code><a class="headerlink" href="#typing.final" title="정의 주소">¶</a></dt>
<dd><p>데코레이트 된 메서드가 재정의될 수 없고, 데코레이트 된 클래스가 서브 클래싱 될 수 없음을 형 검사기에 알리는 데코레이터. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>
<span class="k">class</span> <span class="nc">Sub</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># 형 검사기가 에러를 보고합니다</span>
          <span class="o">...</span>

<span class="nd">@final</span>
<span class="k">class</span> <span class="nc">Leaf</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">class</span> <span class="nc">Other</span><span class="p">(</span><span class="n">Leaf</span><span class="p">):</span>  <span class="c1"># 형 검사기가 에러를 보고합니다</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>이러한 속성에 대한 실행 시간 검사는 없습니다. 자세한 내용은 <span class="target" id="index-73"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0591"><strong>PEP 591</strong></a>을 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.no_type_check">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">no_type_check</code><a class="headerlink" href="#typing.no_type_check" title="정의 주소">¶</a></dt>
<dd><p>어노테이션이 형 힌트가 아님을 나타내는 데코레이터.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>이 데코레이터가 적용되면 <a class="reference internal" href="#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_type_hints()</span></code></a> 가 빈 딕셔너리를 반환합니다.
하지만 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code>를 변경하지는 않습니다.</p>
</div>
<p>이것은 클래스나 함수 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">데코레이터</span></a>로 작동합니다. 클래스일 때, 해당 클래스에 정의된 모든 메서드에 재귀적으로 적용됩니다 (하지만 슈퍼 클래스나 서브 클래스에 정의된 메서드에는 적용되지 않습니다).</p>
<p>함수가 제자리에서(in place) 변경됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="typing.no_type_check_decorator">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">no_type_check_decorator</code><a class="headerlink" href="#typing.no_type_check_decorator" title="정의 주소">¶</a></dt>
<dd><p>다른 데코레이터에 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a> 효과를 주는 데코레이터.</p>
<p>이것은 데코레이트 된 함수를 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a>로 감싸는 무언가로 데코레이터를 감쌉니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>이 데코레이터는 클래스나 함수에 사용하는 것이 아니라, 데코레이터에 사용하는 메타 데코레이터입니다.
다른 데코레이터에 이 데코레이터를 적용하면, 해당 데코레이터가 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a>의
효과를 포함하도록 수정합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.type_check_only">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">type_check_only</code><a class="headerlink" href="#typing.type_check_only" title="정의 주소">¶</a></dt>
<dd><p>실행 시간에 클래스나 함수를 사용할 수 없도록 표시하는 데코레이터.</p>
<p>이 데코레이터 자체는 실행 시간에 사용할 수 없습니다. 주로, 구현이 비공개 클래스의 인스턴스를 반환할 때, 형 스텁 파일에 정의된 클래스를 표시하기 위한 용도입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@type_check_only</span>
<span class="k">class</span> <span class="nc">Response</span><span class="p">:</span>  <span class="c1"># 비공개거나 실행 시간에 사용할 수 없습니다</span>
    <span class="n">code</span><span class="p">:</span> <span class="nb">int</span>
    <span class="k">def</span> <span class="nf">get_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">fetch_response</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>비공개 클래스의 인스턴스를 반환하는 것은 좋지 않음에 유의하십시오. 일반적으로 그러한 클래스를 공개로 만드는 것이 바람직합니다.</p>
</dd></dl>

<dl class="function">
<dt id="typing.runtime_checkable">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">runtime_checkable</code><a class="headerlink" href="#typing.runtime_checkable" title="정의 주소">¶</a></dt>
<dd><p>프로토콜 클래스를 실행 시간 프로토콜로 표시합니다.</p>
<p>이러한 프로토콜은 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>와 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>와 함께 사용할 수 있습니다. 이것은 비 프로토콜 클래스에 적용될 때 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다. 이것은 <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a>에 있는 <a class="reference internal" href="#typing.Iterable" title="typing.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>처럼 &quot;한 가지만 잘하는&quot; 것과 매우 유사한 단순한 구조적 검사를 허용합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">Closable</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/some/file&#39;</span><span class="p">),</span> <span class="n">Closable</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>경고:</strong> 이것은 필요한 메서드의 존재만 검사할 뿐, 그것들의 형 서명은 검사하지 않습니다!</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Any">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Any</code><a class="headerlink" href="#typing.Any" title="정의 주소">¶</a></dt>
<dd><p>제한되지 않는 형을 나타내는 특수형.</p>
<ul class="simple">
<li><p>모든 형은 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>와 호환됩니다.</p></li>
<li><p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>는 모든 형과 호환됩니다.</p></li>
</ul>
</dd></dl>

<dl class="data">
<dt id="typing.NoReturn">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">NoReturn</code><a class="headerlink" href="#typing.NoReturn" title="정의 주소">¶</a></dt>
<dd><p>함수가 절대 반환하지 않는 것을 나타내는 특수한 형. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NoReturn</span>

<span class="k">def</span> <span class="nf">stop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;no way&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Union">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Union</code><a class="headerlink" href="#typing.Union" title="정의 주소">¶</a></dt>
<dd><p>공용체 형; <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">Y]</span></code>는 X나 Y를 의미합니다.</p>
<p>공용체를 정의하려면, 예를 들어 <code class="docutils literal notranslate"><span class="pre">Union[int,</span> <span class="pre">str]</span></code>을 사용하십시오. 세부 사항:</p>
<ul>
<li><p>인자는 형이어야 하며 적어도 하나 있어야 합니다.</p></li>
<li><p>공용체의 공용체는 펼쳐집니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>단일 인자의 공용체는 사라집니다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span>  <span class="c1"># 생성자가 실제로는 int를 반환합니다</span>
</pre></div>
</div>
</li>
<li><p>중복 인자는 건너뜁니다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>공용체를 비교할 때, 인자 순서가 무시됩니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>공용체를 서브 클래스 화하거나 인스턴스 화할 수 없습니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Union[X][Y]</span></code>라고 쓸 수 없습니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Optional[X]</span></code>를 <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">None]</span></code>의 줄임 표현으로 사용할 수 있습니다.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>실행 시간에 공용체의 명시적 서브 클래스를 제거하지 않습니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Optional">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Optional</code><a class="headerlink" href="#typing.Optional" title="정의 주소">¶</a></dt>
<dd><p>선택적 형.</p>
<p><code class="docutils literal notranslate"><span class="pre">Optional[X]</span></code>는 <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">None]</span></code>과 동등합니다.</p>
<p>이는 기본값을 갖는 선택적 인자와 같은 개념이 아님에 유의하십시오. 단지 선택적이기 때문에 기본값을 갖는 선택적 인자가 형 어노테이션에 <code class="docutils literal notranslate"><span class="pre">Optional</span></code> 한정자가 필요하지는 않습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>한편, 명시적인 <code class="docutils literal notranslate"><span class="pre">None</span></code> 값이 허용되면, 인자가 선택적인지와 관계없이 <code class="docutils literal notranslate"><span class="pre">Optional</span></code>을 사용하는 것이 적합합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Tuple">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Tuple</code><a class="headerlink" href="#typing.Tuple" title="정의 주소">¶</a></dt>
<dd><p>튜플 형; <code class="docutils literal notranslate"><span class="pre">Tuple[X,</span> <span class="pre">Y]</span></code>는 첫 번째 항목의 형이 X이고 두 번째 항목의 형이 Y인 두 항목의 튜플 형입니다. 빈 튜플의 형은 <code class="docutils literal notranslate"><span class="pre">Tuple[()]</span></code>로 쓸 수 있습니다.</p>
<p>예: <code class="docutils literal notranslate"><span class="pre">Tuple[T1,</span> <span class="pre">T2]</span></code>는 각각 형 변수 T1과 T2에 해당하는 두 요소의 튜플입니다. <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">float,</span> <span class="pre">str]</span></code>은 int, float 및 문자열의 튜플입니다.</p>
<p>같은 형의 가변 길이 튜플을 지정하려면 리터럴 생략 부호(ellipsis)를 사용하십시오, 예를 들어 <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">...]</span></code>. 단순한 <a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code></a>은 <code class="docutils literal notranslate"><span class="pre">Tuple[Any,</span> <span class="pre">...]</span></code>와 동등하고, 이는 다시 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>과 동등합니다.</p>
</dd></dl>

<dl class="data">
<dt id="typing.Callable">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Callable</code><a class="headerlink" href="#typing.Callable" title="정의 주소">¶</a></dt>
<dd><p>콜러블 형; <code class="docutils literal notranslate"><span class="pre">Callable[[int],</span> <span class="pre">str]</span></code>은 (int) -&gt; str 인 함수입니다.</p>
<p>서브스크립션 문법은 항상 정확히 두 개의 값으로 사용되어야 합니다: 인자 리스트와 반환형. 인자 리스트는 형의 리스트거나 생략 부호(ellipsis)여야 합니다. 반환형은 단일한 형이어야 합니다.</p>
<p>선택적이나 키워드 인자를 나타내는 문법은 없습니다; 그런 함수 형은 거의 콜백 형으로 사용되지 않습니다. <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">ReturnType]</span></code>(리터럴 생략 부호)은 임의의 수의 인자를 취하고 <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code>을 반환하는 콜러블에 형 힌트를 주는 데 사용할 수 있습니다. 단순한 <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a>은 <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">Any]</span></code>와 동등하며, 이는 다시 <a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a>과 동등합니다.</p>
</dd></dl>

<dl class="data">
<dt id="typing.Literal">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Literal</code><a class="headerlink" href="#typing.Literal" title="정의 주소">¶</a></dt>
<dd><p>대응하는 변수나 함수 매개 변수가 제공된 리터럴(또는 여러 리터럴 중 하나)과 동등한 값을 가짐을 형 검사기에 알리는 데 사용할 수 있는 형. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">validate_simple</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]:</span>  <span class="c1"># 항상 True를 반환합니다</span>
    <span class="o">...</span>

<span class="n">MODE</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">open_helper</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">MODE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/some/path&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>  <span class="c1"># 형 검사기를 통과합니다</span>
<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/other/path&#39;</span><span class="p">,</span> <span class="s1">&#39;typo&#39;</span><span class="p">)</span>  <span class="c1"># 형 검사기에서 에러입니다</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code>은 서브 클래싱 될 수 없습니다. 실행 시간에는, 임의의 값이 <code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code>에 대한 형 인자로 허용되지만, 형 검사기는 제한을 부과할 수 있습니다. 리터럴 형에 대한 자세한 내용은 <span class="target" id="index-74"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0586"><strong>PEP 586</strong></a>을 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.ClassVar">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ClassVar</code><a class="headerlink" href="#typing.ClassVar" title="정의 주소">¶</a></dt>
<dd><p>클래스 변수를 표시하기 위한 특수 형 구조물.</p>
<p><span class="target" id="index-75"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>에서 소개된 것처럼, ClassVar로 감싼 변수 어노테이션은 주어진 어트리뷰트가 클래스 변수로 사용되도록 의도되었으며 해당 클래스의 인스턴스에 설정되어서는 안 됨을 나타냅니다. 용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Starship</span><span class="p">:</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># 클래스 변수</span>
    <span class="n">damage</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>                     <span class="c1"># 인스턴스 변수</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a>는 형만 받아들이며 더는 서브 스크립트 할 수 없습니다.</p>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a>는 클래스 자체가 아니므로, <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>나 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>와 함께 사용하면 안 됩니다. <a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a>는 파이썬 실행 시간 동작을 변경하지 않지만, 제삼자 형 검사기에서 사용할 수 있습니다. 예를 들어, 형 검사기는 다음 코드를 에러로 표시 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">enterprise_d</span> <span class="o">=</span> <span class="n">Starship</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>
<span class="n">enterprise_d</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># 에러, 클래스 변수를 인스턴스에 설정합니다</span>
<span class="n">Starship</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>     <span class="c1"># 이것은 OK</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Final">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Final</code><a class="headerlink" href="#typing.Final" title="정의 주소">¶</a></dt>
<dd><p>형 검사기에 이름이 다시 대입되거나 서브 클래스에서 재정의될 수 없다는 것을 나타내는 특수한 typing 구조물. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">MAX_SIZE</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="mi">9000</span>
<span class="n">MAX_SIZE</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># 형 검사기가 에러를 보고합니다</span>

<span class="k">class</span> <span class="nc">Connection</span><span class="p">:</span>
    <span class="n">TIMEOUT</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">class</span> <span class="nc">FastConnector</span><span class="p">(</span><span class="n">Connection</span><span class="p">):</span>
    <span class="n">TIMEOUT</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># 형 검사기가 에러를 보고합니다</span>
</pre></div>
</div>
<p>이러한 속성에 대한 실행 시간 검사는 없습니다. 자세한 내용은 <span class="target" id="index-76"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0591"><strong>PEP 591</strong></a>을 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.AnyStr">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AnyStr</code><a class="headerlink" href="#typing.AnyStr" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">AnyStr</span></code>은 <code class="docutils literal notranslate"><span class="pre">AnyStr</span> <span class="pre">=</span> <span class="pre">TypeVar('AnyStr',</span> <span class="pre">str,</span> <span class="pre">bytes)</span></code>로 정의된 형 변수입니다.</p>
<p>다른 종류의 문자열을 섞지 않고 모든 종류의 문자열을 받아들일 수 있는 함수에 사용하기 위한 것입니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">concat</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Ok, 출력은 형 &#39;unicode&#39; 입니다</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Ok, 출력은 형 &#39;bytes&#39; 입니다</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># 에러, unicode 와 bytes를 섞을 수 없습니다</span>
</pre></div>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.TYPE_CHECKING">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">TYPE_CHECKING</code><a class="headerlink" href="#typing.TYPE_CHECKING" title="정의 주소">¶</a></dt>
<dd><p>제삼자 정적 형 검사기에 의해 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정될 것으로 가정되는 특수 상수. 실행 시간에는 <code class="docutils literal notranslate"><span class="pre">False</span></code>입니다. 용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">expensive_mod</span>

<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="s1">&#39;expensive_mod.SomeType&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">local_var</span><span class="p">:</span> <span class="n">expensive_mod</span><span class="o">.</span><span class="n">AnotherType</span> <span class="o">=</span> <span class="n">other_fun</span><span class="p">()</span>
</pre></div>
</div>
<p>첫 번째 어노테이션이 따옴표로 묶였음에 유의하십시오, &quot;전방 참조&quot;로 만들어서 인터프리터 실행 시간에 <code class="docutils literal notranslate"><span class="pre">expensive_mod</span></code> 참조를 숨깁니다. 지역 변수에 대한 형 어노테이션은 평가되지 않기 때문에, 두 번째 어노테이션을 따옴표로 묶을 필요는 없습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Annotated">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Annotated</code><a class="headerlink" href="#typing.Annotated" title="정의 주소">¶</a></dt>
<dd><p><span class="target" id="index-77"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0593"><strong>PEP 593</strong></a>(<code class="docutils literal notranslate"><span class="pre">Flexible</span> <span class="pre">function</span> <span class="pre">and</span> <span class="pre">variable</span> <span class="pre">annotations</span></code>)에 도입된, 기존 형을 문맥 별 메타 데이터(<code class="docutils literal notranslate"><span class="pre">Annotated</span></code>가 가변적(variadic)이므로 여러 개가 가능합니다)로 데코레이트하는 형. 구체적으로, 형 <code class="docutils literal notranslate"><span class="pre">T</span></code>는 형 힌트 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code>를 통해 메타 데이터 <code class="docutils literal notranslate"><span class="pre">x</span></code>로 어노테이트될 수 있습니다. 이 메타 데이터는 정적 분석이나 실행 시간에 사용할 수 있습니다. 라이브러리(또는 도구)가 형 힌트 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code>를 만나고 메타 데이터 <code class="docutils literal notranslate"><span class="pre">x</span></code>에 대한 특별한 논리가 없으면, 이를 무시하고 단순히 형을 <code class="docutils literal notranslate"><span class="pre">T</span></code>로 처리해야 합니다. 현재 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 모듈에 존재하는, 함수나 클래스에서 형 검사 어노테이션을 완전히 비활성화하는 <code class="docutils literal notranslate"><span class="pre">no_type_check</span></code> 기능과 달리, <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 형은 <code class="docutils literal notranslate"><span class="pre">T</span></code>의 정적 형 검사(예를 들어, 안전하게 <code class="docutils literal notranslate"><span class="pre">x</span></code>를 무시할 수 있는, mypy나 Pyre를 통해)와 특정 응용프로그램에서 <code class="docutils literal notranslate"><span class="pre">x</span></code>에 실행 시간 액세스하는 것을 동시에 허용합니다.</p>
<p>궁극적으로, 어노테이션을 해석하는 방법에 대한 책임은 (있기는 하다면) <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 형을 만나는 도구나 라이브러리의 책임입니다. <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 형을 만나는 도구나 라이브러리는 어노테이션을 통해 스캔하여 관심이 있는 것인지 판별합니다 (예를 들어, <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code>를 사용하여).</p>
<p>도구나 라이브러리가 어노테이션을 지원하지 않거나 알 수 없는 어노테이션을 만나면, 이를 무시하고 어노테이트 된 형을 하부 형으로 처리해야 합니다.</p>
<p>클라이언트가 한 형에 여러 어노테이션을 갖도록 허용되는지와 해당 어노테이션들을 병합하는 방법을 결정하는 것은 어노테이션을 소비하는 도구에 달려 있습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 형을 사용하면 임의의 노드에 같은 (또는 다른) 형의 여러 어노테이션을 넣을 수 있도록 하므로, 이 어노테이션을 소비하는 도구나 라이브러리는 잠재적 중복을 처리해야 합니다. 예를 들어, 값 범위 분석을 수행하는 경우 다음처럼 허용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T1</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
<span class="n">T2</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">include_extras=True</span></code>를 <a class="reference internal" href="#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_type_hints()</span></code></a>로 전달하면 실행 시간에 추가 어노테이션에 액세스 할 수 있습니다.</p>
<p>문법의 세부 사항:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code>의 첫 번째 인자는 유효한 형이어야 합니다</p></li>
<li><p>여러 개의 형 주석이 지원됩니다 (<code class="docutils literal notranslate"><span class="pre">Annotated</span></code>는 가변 인자를 지원합니다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code>는 최소한 두 개의 인자로 호출해야 합니다 (<code class="docutils literal notranslate"><span class="pre">Annotated[int]</span></code>는 유효하지 않습니다)</p></li>
<li><p>어노테이션의 순서는 유지되며 동등(equality) 검사의 경우 중요합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>중첩된 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 형은 가장 안쪽 주석으로 시작하는 메타 데이터로 평탄화됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">==</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>중복된 어노테이션은 제거되지 않습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code>는 중첩되고 제네릭한 에일리어스와 함께 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">Vec</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]],</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">Vec</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

<span class="n">V</span> <span class="o">==</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</pre></div>
</div>
</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> --- 형 힌트 지원</a><ul>
<li><a class="reference internal" href="#type-aliases">형 에일리어스</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#callable">Callable</a></li>
<li><a class="reference internal" href="#generics">제네릭</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">사용자 정의 제네릭 형</a></li>
<li><a class="reference internal" href="#the-any-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code> 형</a></li>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping">명목적 대 구조적 서브 타이핑</a></li>
<li><a class="reference internal" href="#classes-functions-and-decorators">클래스, 함수 및 데코레이터</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="development.html"
                        title="이전 장">개발 도구</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="pydoc.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> --- 설명서 생성과 온라인 도움말 시스템</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc --- 설명서 생성과 온라인 도움말 시스템"
             >다음</a> |</li>
        <li class="right" >
          <a href="development.html" title="개발 도구"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >개발 도구</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>