
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>urllib.request --- URL을 열기 위한 확장 가능한 라이브러리 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="urllib.parse --- URL을 구성 요소로 구문 분석" href="urllib.parse.html" />
    <link rel="prev" title="urllib --- URL 처리 모듈" href="urllib.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/urllib.request.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="urllib.parse --- URL을 구성 요소로 구문 분석"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="urllib.html" title="urllib --- URL 처리 모듈"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-urllib.request">
<span id="urllib-request-extensible-library-for-opening-urls"></span><h1><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> --- URL을 열기 위한 확장 가능한 라이브러리<a class="headerlink" href="#module-urllib.request" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/urllib/request.py">Lib/urllib/request.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 모듈은 복잡한 세계에서 URL(대부분 HTTP)을 여는 데 도움이 되는 함수와 클래스를 정의합니다 --- 기본(basic)과 다이제스트 인증, 리디렉션, 쿠키 등.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>더 고수준 HTTP 클라이언트 인터페이스로 <a class="reference external" href="https://requests.readthedocs.io/en/master/">Requests 패키지</a>를 권장합니다.</p>
</div>
<p><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 모듈은 다음 함수를 정의합니다:</p>
<dl class="function">
<dt id="urllib.request.urlopen">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">urlopen</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">data=None</em>, <span class="optional">[</span><em class="sig-param">timeout</em>, <span class="optional">]</span><em class="sig-param">*</em>, <em class="sig-param">cafile=None</em>, <em class="sig-param">capath=None</em>, <em class="sig-param">cadefault=False</em>, <em class="sig-param">context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlopen" title="정의 주소">¶</a></dt>
<dd><p>문자열이나 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체일 수 있는, URL <em>url</em>을 엽니다.</p>
<p><em>data</em>는 서버로 전송할 추가 데이터를 지정하는 객체이거나, 그러한 데이터가 필요하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이어야 합니다. 자세한 내용은 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>를 참조하십시오.</p>
<p>urllib.request 모듈은 HTTP/1.1을 사용하고 HTTP 요청에 <code class="docutils literal notranslate"><span class="pre">Connection:close</span></code> 헤더를 포함합니다.</p>
<p>선택적 <em>timeout</em> 매개 변수는 연결 시도와 같은 연산을 블로킹하기 위한 시간제한을 초 단위로 지정합니다 (지정하지 않으면 전역 기본 시간제한 설정이 사용됩니다). 이것은 실제로는 HTTP, HTTPS 및 FTP 연결에서만 작동합니다.</p>
<p><em>context</em>가 지정되면, 다양한 SSL 옵션을 기술하는 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 인스턴스이어야 합니다. 자세한 내용은 <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSConnection</span></code></a>을 참조하십시오.</p>
<p>선택적 <em>cafile</em>과 <em>capath</em> 매개 변수는 HTTPS 요청을 위한 신뢰할 수 있는 CA 인증서 집합을 지정합니다. <em>cafile</em>은 CA 인증서 번들을 포함하는 단일 파일을 가리켜야 하지만, <em>capath</em>는 해시 된 인증서 파일의 디렉터리를 가리켜야 합니다. 자세한 정보는 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_verify_locations()</span></code></a>에서 찾을 수 있습니다.</p>
<p><em>cadefault</em> 매개 변수는 무시됩니다.</p>
<p>This function always returns an object which can work as a
<a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a> and has the properties <em>url</em>, <em>headers</em>, and <em>status</em>.
See <a class="reference internal" href="#urllib.response.addinfourl" title="urllib.response.addinfourl"><code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code></a> for more detail on these properties.</p>
<p>HTTP 및 HTTPS URL의 경우, 이 함수는 약간 수정된 <a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.client.HTTPResponse</span></code></a> 객체를 반환합니다. 위의 세 가지 새로운 메서드 외에도, msg 어트리뷰트에는 <a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPResponse</span></code></a> 설명서에 지정된 대로 응답 헤더 대신 <a class="reference internal" href="http.client.html#http.client.HTTPResponse.reason" title="http.client.HTTPResponse.reason"><code class="xref py py-attr docutils literal notranslate"><span class="pre">reason</span></code></a> 어트리뷰트와 --- 서버가 반환한 이유 문구 --- 같은 정보가 포함됩니다.</p>
<p>FTP, 파일 및 데이터 URL과 레거시 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a>와 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> 클래스에서 명시적으로 처리된 요청의 경우, 이 함수는 <a class="reference internal" href="#urllib.response.addinfourl" title="urllib.response.addinfourl"><code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code></a> 객체를 반환합니다.</p>
<p>프로토콜 에러 시 <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>를 발생시킵니다.</p>
<p>아무런 처리기도 요청을 처리하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환될 수 있습니다 (기본 설치된 전역 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>는 <a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnknownHandler</span></code></a>를 사용하여 이러한 상황이 발생하지 않도록 합니다).</p>
<p>또한, 프락시 설정이 감지되면 (예를 들어, <span class="target" id="index-25"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">http_proxy</span></code>와 같은 <code class="docutils literal notranslate"><span class="pre">*_proxy</span></code> 환경 변수가 설정될 때), <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a>가 기본적으로 설치되어 프락시를 통해 요청이 처리되도록 합니다.</p>
<p>파이썬 2.6 및 이전 버전의 레거시 <code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code> 함수는 중단되었습니다; <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.request.urlopen()</span></code></a>는 이전 <code class="docutils literal notranslate"><span class="pre">urllib2.urlopen</span></code>에 해당합니다. 딕셔너리 매개 변수를 <code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code>에 전달하여 수행되었던 프락시 처리는 <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> 객체를 사용하여 얻을 수 있습니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">fullurl</span></code>, <code class="docutils literal notranslate"><span class="pre">data</span></code>, <code class="docutils literal notranslate"><span class="pre">headers</span></code>, <code class="docutils literal notranslate"><span class="pre">method</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">urllib.Request</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>cafile</em>과 <em>capath</em>가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>가능하다면 (즉, <a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal notranslate"><span class="pre">ssl.HAS_SNI</span></code></a>가 참이라면) HTTPS 가상 호스트가 지원됩니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가: </span><em>data</em>는 이터러블 객체일 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><em>cadefault</em>가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4.3에서 변경: </span><em>context</em>가 추가되었습니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.6부터 폐지: </span><em>cafile</em>, <em>capath</em> 및 <em>cadefault</em>는 폐지되어 <em>context</em>로 대체되었습니다. 대신 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a>을 사용하거나, <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>가 시스템의 신뢰할 수 있는 CA 인증서를 선택하도록 하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.request.install_opener">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">install_opener</code><span class="sig-paren">(</span><em class="sig-param">opener</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.install_opener" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 인스턴스를 기본 전역 오프너로 설치합니다. 오프너 설치는 urlopen이 해당 오프너를 사용하도록 하려는 경우에만 필요합니다; 그렇지 않으면 단순히 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 대신 <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.open()</span></code></a>을 호출하십시오. 코드는 실제 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>를 확인하지 않으며, 적절한 인터페이스를 가진 클래스면 모두 작동합니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.build_opener">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">build_opener</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">handler</em>, <em class="sig-param">...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.build_opener" title="정의 주소">¶</a></dt>
<dd><p>주어진 순서대로 처리기를 연결하는 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 인스턴스를 반환합니다. <em>handler</em>는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>의 인스턴스이거나 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>의 서브 클래스(이 경우 매개 변수 없이 생성자를 호출할 수 있어야 합니다)일 수 있습니다. 다음과 같은 클래스들의 인스턴스는 <em>handler</em>에 그들, 그들의 인스턴스 또는 그들의 서브 클래스가 포함되지 않는 한 <em>handler</em> 앞에 있습니다: <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> (프락시 설정이 감지되는 경우), <a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnknownHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPHandler" title="urllib.request.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler" title="urllib.request.HTTPDefaultErrorHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPDefaultErrorHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPRedirectHandler" title="urllib.request.HTTPRedirectHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPRedirectHandler</span></code></a>, <a class="reference internal" href="#urllib.request.FTPHandler" title="urllib.request.FTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FTPHandler</span></code></a>, <a class="reference internal" href="#urllib.request.FileHandler" title="urllib.request.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPErrorProcessor" title="urllib.request.HTTPErrorProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPErrorProcessor</span></code></a>.</p>
<p>파이썬 설치에 SSL 지원이 있으면 (즉, <a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 모듈을 임포트 할 수 있으면) <a class="reference internal" href="#urllib.request.HTTPSHandler" title="urllib.request.HTTPSHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSHandler</span></code></a>도 추가됩니다.</p>
<p><a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 서브 클래스는 또한 <code class="xref py py-attr docutils literal notranslate"><span class="pre">handler_order</span></code> 어트리뷰트를 변경하여 처리기 리스트에서 자신의 위치를 수정할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.pathname2url">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">pathname2url</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.pathname2url" title="정의 주소">¶</a></dt>
<dd><p>경로명 <em>path</em>를 경로의 로컬 구문에서 URL의 경로 구성 요소에 사용된 형식으로 변환합니다. 완전한 URL을 생성하지는 않습니다. 반환 값은 <a class="reference internal" href="urllib.parse.html#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a> 함수를 사용하여 이미 인용되었습니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.url2pathname">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">url2pathname</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.url2pathname" title="정의 주소">¶</a></dt>
<dd><p>경로 구성 요소 <em>path</em>를 퍼센트 인코딩된 URL에서 경로의 로컬 구문으로 변환합니다. 완전한 URL을 받아들이지 않습니다. 이 함수는 <a class="reference internal" href="urllib.parse.html#urllib.parse.unquote" title="urllib.parse.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">unquote()</span></code></a>를 사용하여 <em>path</em>를 디코딩합니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.getproxies">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">getproxies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.getproxies" title="정의 주소">¶</a></dt>
<dd><p>이 도우미 함수는 스킴에서 프락시 서버 URL로 매핑하는 딕셔너리를 반환합니다. 먼저 모든 운영 체제에서 대소 문자를 구분하지 않는 방식으로 <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;_proxy</span></code>라는 변수를 환경에서 스캔하고, 찾을 수 없으면 맥 OS X의 맥 OSX 시스템 구성과 윈도우의 윈도우 시스템 레지스트리에서 프락시 정보를 찾습니다. 소문자와 대문자 환경 변수가 모두 존재하면 (그리고 다른 값을 가지면), 소문자가 선호됩니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>일반적으로 스크립트가 CGI 환경에서 실행 중임을 나타내는 환경 변수 <code class="docutils literal notranslate"><span class="pre">REQUEST_METHOD</span></code>가 설정되면, 환경 변수 <code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code>(대문자 <code class="docutils literal notranslate"><span class="pre">_PROXY</span></code>)는 무시됩니다. 이 변수는 &quot;Proxy:&quot; HTTP 헤더를 사용하여 클라이언트가 주입할 수 있기 때문입니다. CGI 환경에서 HTTP 프락시를 사용해야 하면, <code class="docutils literal notranslate"><span class="pre">ProxyHandler</span></code>를 명시적으로 사용하거나 변수 이름이 소문자(또는 적어도 <code class="docutils literal notranslate"><span class="pre">_proxy</span></code> 접미사)가 되도록 하십시오.</p>
</div>
</dd></dl>

<p>다음과 같은 클래스가 제공됩니다:</p>
<dl class="class">
<dt id="urllib.request.Request">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">Request</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">data=None</em>, <em class="sig-param">headers={}</em>, <em class="sig-param">origin_req_host=None</em>, <em class="sig-param">unverifiable=False</em>, <em class="sig-param">method=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 URL 요청의 추상화입니다.</p>
<p><em>url</em>은 유효한 URL을 포함하는 문자열이어야 합니다.</p>
<p><em>data</em>는 서버로 전송할 추가 데이터를 지정하는 객체이거나, 그러한 데이터가 필요하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이어야 합니다. 현재 HTTP 요청은 <em>data</em>를 사용하는 유일한 요청입니다. 지원되는 객체 형에는 바이트열, 파일류 객체 및 바이트열류 객체의 이터러블이 포함됩니다. <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code>와 <code class="docutils literal notranslate"><span class="pre">Transfer-Encoding</span></code> 헤더 필드가 모두 제공되지 않으면, <a class="reference internal" href="#urllib.request.HTTPHandler" title="urllib.request.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a>는 <em>data</em>의 형에 따라 이러한 헤더를 설정합니다. <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code>는 바이트열 객체를 보내는 데 사용되는 반면, <span class="target" id="index-26"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7230.html"><strong>RFC 7230</strong></a>, 섹션 3.3.1에 지정된 <code class="docutils literal notranslate"><span class="pre">Transfer-Encoding:</span> <span class="pre">chunked</span></code>는 파일과 다른 이터러블을 보내는 데 사용됩니다.</p>
<p>HTTP POST 요청 메서드의 경우, <em>data</em>는 표준 <em class="mimetype">application/x-www-form-urlencoded</em> 형식의 버퍼여야 합니다. <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 함수는 매핑이나 2-튜플의 시퀀스를 취하고 이 형식의 ASCII 문자열을 반환합니다. <em>data</em> 매개 변수로 사용되기 전에 바이트열로 인코딩되어야 합니다.</p>
<p><em>headers</em>는 딕셔너리이어야 하며, 각 키와 값을 인자로 사용하여 <a class="reference internal" href="#urllib.request.Request.add_header" title="urllib.request.Request.add_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_header()</span></code></a>가 호출된 것처럼 처리됩니다. 이것은 종종 브라우저가 자신을 식별하는 데 사용하는 <code class="docutils literal notranslate"><span class="pre">User-Agent</span></code> 헤더 값을 &quot;스푸핑&quot; 하는 데 사용됩니다 -- 일부 HTTP 서버는 스크립트가 아닌 일반 브라우저에서 오는 요청만 허용합니다. 예를 들어, Mozilla Firefox는 자신을 <code class="docutils literal notranslate"><span class="pre">&quot;Mozilla/5.0</span> <span class="pre">(X11;</span> <span class="pre">U;</span> <span class="pre">Linux</span> <span class="pre">i686)</span> <span class="pre">Gecko/20071127</span> <span class="pre">Firefox/2.0.0.11&quot;</span></code>로 식별하는 반면, <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a>의 기본 사용자 에이전트 문자열은 <code class="docutils literal notranslate"><span class="pre">&quot;Python-urllib/2.6&quot;</span></code> (파이썬 2.6에서) 입니다.</p>
<p><em>data</em> 인자가 있으면 적절한 <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> 헤더가 포함되어야 합니다. 이 헤더가 제공되지 않고 <em>data</em>가 None이 아니면, <code class="docutils literal notranslate"><span class="pre">Content-Type:</span> <span class="pre">application/x-www-form-urlencoded</span></code>가 기본값으로 추가됩니다.</p>
<p>다음 두 인자는 제삼자 HTTP 쿠키를 올바르게 처리하는 데에만 관심이 있습니다:</p>
<p><em>origin_req_host</em>는 <span class="target" id="index-27"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2965.html"><strong>RFC 2965</strong></a>에 의해 정의된 대로 오리진 트랜잭션의 요청 호스트여야 합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">http.cookiejar.request_host(self)</span></code>입니다. 이것은 사용자가 시작한 원래 요청의 호스트 이름이나 IP 주소입니다. 예를 들어, HTML 문서의 이미지에 대한 요청이면, 이미지가 포함된 페이지에 대한 요청의 요청 호스트여야 합니다.</p>
<p><em>unverifiable</em>은 <span class="target" id="index-28"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2965.html"><strong>RFC 2965</strong></a>에서 정의한 대로 요청을 확인할 수 없는지를 표시해야 합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code>입니다. 확인할 수 없는 요청은 사용자에게 URL에 대한 승인 옵션이 없는 요청입니다. 예를 들어, HTML 문서의 이미지에 대한 요청이고, 사용자에게 이미지의 자동 가져오기를 승인할 수 있는 옵션이 없으면, 이것은 참이어야 합니다.</p>
<p><em>method</em>는 사용될 HTTP 요청 메서드를 나타내는 문자열이어야 합니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">'HEAD'</span></code>). 제공되면, 해당 값은 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code></a> 어트리뷰트에 저장되고 <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a>에서 사용됩니다. 기본값은 <em>data</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면 <code class="docutils literal notranslate"><span class="pre">'GET'</span></code>이고, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">'POST'</span></code>입니다. 서브 클래스는 클래스 자체에서 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code></a> 어트리뷰트를 설정하여 다른 기본 메서드를 나타낼 수 있습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>data 객체가 콘텐츠를 두 번 이상 (예를 들어 콘텐츠를 한 번만 생성 할 수 있는 파일이나 이터러블) 전달할 수 없고 요청이 HTTP 리디렉션이나 인증을 위해 재시도되는 경우, 요청이 예상대로 작동하지 않습니다. <em>data</em>는 헤더 바로 다음에 HTTP 서버로 전송됩니다. 라이브러리에서 100-continue 예상(expectation)을 지원하지 않습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a> 인자가 Request 클래스에 추가됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>클래스 수준에서 기본 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a>를 지정할 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="docutils literal notranslate"><span class="pre">Content-Length</span></code>가 제공되지 않고 <em>data</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이나 바이트열 객체가 아닐 때 에러를 발생시키지 앖습니다. 대신 청크 전송 인코딩(chunked transfer encoding)으로 폴백 합니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.OpenerDirector">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">OpenerDirector</code><a class="headerlink" href="#urllib.request.OpenerDirector" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 클래스는 서로 연결된 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>들을 통해 URL을 엽니다. 처리기 연결과 에러 복구를 관리합니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.BaseHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">BaseHandler</code><a class="headerlink" href="#urllib.request.BaseHandler" title="정의 주소">¶</a></dt>
<dd><p>이것은 등록된 모든 처리기의 베이스 클래스이며 --- 간단한 등록 메커니즘만 처리합니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPDefaultErrorHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPDefaultErrorHandler</code><a class="headerlink" href="#urllib.request.HTTPDefaultErrorHandler" title="정의 주소">¶</a></dt>
<dd><p>HTTP 에러 응답에 대한 기본 처리기를 정의하는 클래스; 모든 응답은 <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> 예외로 바뀝니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPRedirectHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPRedirectHandler</code><a class="headerlink" href="#urllib.request.HTTPRedirectHandler" title="정의 주소">¶</a></dt>
<dd><p>리디렉션을 처리하는 클래스.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPCookieProcessor">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPCookieProcessor</code><span class="sig-paren">(</span><em class="sig-param">cookiejar=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPCookieProcessor" title="정의 주소">¶</a></dt>
<dd><p>HTTP 쿠키를 처리하는 클래스.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">ProxyHandler</code><span class="sig-paren">(</span><em class="sig-param">proxies=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyHandler" title="정의 주소">¶</a></dt>
<dd><p>요청이 프락시를 거치게 합니다. <em>proxies</em>가 제공되면, 프로토콜 이름을 프락시 URL로 매핑하는 딕셔너리여야 합니다. 기본값은 환경 변수 <code class="docutils literal notranslate"><span class="pre">&lt;protocol&gt;_proxy</span></code>에서 프락시 목록을 읽는 것입니다. 프락시 환경 변수가 설정되어 있지 않으면, 윈도우 환경에서는 레지스트리의 인터넷 설정 섹션에서 프락시 설정을 가져오고, 맥 OS X 환경에서는 프락시 정보를 OS X 시스템 구성 프레임워크에서 가져옵니다.</p>
<p>자동 감지 프락시를 비활성화하려면 빈 딕셔너리를 전달하십시오.</p>
<p><span class="target" id="index-29"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">no_proxy</span></code> 환경 변수를 사용하여 프락시를 통해 도달해서는 안 되는 호스트를 지정할 수 있습니다; 설정되면, 쉼표로 구분된 호스트 이름 접미사의 목록이어야 하며, 선택적으로 <code class="docutils literal notranslate"><span class="pre">:port</span></code>가 추가됩니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">cern.ch,ncsa.uiuc.edu,some.host:8080</span></code>.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">참고</p>
<p>변수 <code class="docutils literal notranslate"><span class="pre">REQUEST_METHOD</span></code>가 설정되면 <code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code>는 무시됩니다; <a class="reference internal" href="#urllib.request.getproxies" title="urllib.request.getproxies"><code class="xref py py-func docutils literal notranslate"><span class="pre">getproxies()</span></code></a>의 설명서를 참조하십시오.</p>
</div>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPPasswordMgr">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPPasswordMgr</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgr" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></code> 매핑 데이터베이스를 유지합니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPPasswordMgrWithDefaultRealm">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPPasswordMgrWithDefaultRealm</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></code> 매핑 데이터베이스를 유지합니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> realm은 포괄(catch-all) 영역으로 간주하며 다른 영역에 맞지 않으면 검색됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPPasswordMgrWithPriorAuth</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">uri</span> <span class="pre">-&gt;</span> <span class="pre">is_authenticated</span></code> 매핑 데이터베이스도 포함하는 <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a>의 변형. BasicAuth 처리기에서 <code class="docutils literal notranslate"><span class="pre">401</span></code> 응답을 먼저 기다리는 대신 인증 자격 증명을 언제 보낼 것인지 결정하는 데 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.AbstractBasicAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">AbstractBasicAuthHandler</code><span class="sig-paren">(</span><em class="sig-param">password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler" title="정의 주소">¶</a></dt>
<dd><p>원격 호스트와 프락시 모두에서 HTTP 인증을 돕는 믹스인 클래스입니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 객체</span></a>를 참조하십시오. <em>passwd_mgr</em>이 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code>와 <code class="docutils literal notranslate"><span class="pre">update_authenticated</span></code> 메서드도 제공하면 (<a class="reference internal" href="#http-password-mgr-with-prior-auth"><span class="std std-ref">HTTPPasswordMgrWithPriorAuth 객체</span></a>를 참조하십시오), 처리기는 지정된 URI에 대해 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 결과를 사용하여 요청과 함께 인증 자격 증명을 보낼지를 판별합니다. <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code>가 URI에 대해 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환하면, 자격 증명이 전송됩니다. <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, 자격 증명이 전송되지 않으며, 그런 다음 <code class="docutils literal notranslate"><span class="pre">401</span></code> 응답이 수신되면 요청이 인증 자격 증명과 함께 다시 전송됩니다. 인증이 성공하면, 이 URI에 대해 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code>를 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정하기 위해 <code class="docutils literal notranslate"><span class="pre">update_authenticated</span></code>가 호출되어서, 이 URI나 모든 슈퍼 URI에 대한 후속 요청에 인증 자격 증명이 자동으로 포함됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가: </span><code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPBasicAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPBasicAuthHandler</code><span class="sig-paren">(</span><em class="sig-param">password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler" title="정의 주소">¶</a></dt>
<dd><p>원격 호스트와의 인증을 처리합니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 객체</span></a>를 참조하십시오. 잘못된 인증 스킴(Authentication scheme)을 제시하면 HTTPBasicAuthHandler 가 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyBasicAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">ProxyBasicAuthHandler</code><span class="sig-paren">(</span><em class="sig-param">password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler" title="정의 주소">¶</a></dt>
<dd><p>프락시와의 인증을 처리합니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 객체</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.AbstractDigestAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">AbstractDigestAuthHandler</code><span class="sig-paren">(</span><em class="sig-param">password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler" title="정의 주소">¶</a></dt>
<dd><p>원격 호스트와 프락시 모두에서 HTTP 인증을 돕는 믹스인 클래스입니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 객체</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPDigestAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPDigestAuthHandler</code><span class="sig-paren">(</span><em class="sig-param">password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler" title="정의 주소">¶</a></dt>
<dd><p>원격 호스트와의 인증을 처리합니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 객체</span></a>를 참조하십시오. 다이제스트 인증 처리기와 기본 인증 처리기가 모두 추가되면, 다이제스트 인증이 항상 먼저 시도됩니다. 다이제스트 인증이 다시 40x 응답을 반환하면, 기본 인증 처리기로 보내 처리됩니다. 이 처리기 메서드는 Digest나 Basic 이외의 인증 스킴(authentication scheme)이 제공될 때 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>지원되지 않는 인증 스킴에 대해 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyDigestAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">ProxyDigestAuthHandler</code><span class="sig-paren">(</span><em class="sig-param">password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler" title="정의 주소">¶</a></dt>
<dd><p>프락시와의 인증을 처리합니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr 객체</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPHandler</code><a class="headerlink" href="#urllib.request.HTTPHandler" title="정의 주소">¶</a></dt>
<dd><p>HTTP URL 열기를 처리하는 클래스.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPSHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPSHandler</code><span class="sig-paren">(</span><em class="sig-param">debuglevel=0</em>, <em class="sig-param">context=None</em>, <em class="sig-param">check_hostname=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPSHandler" title="정의 주소">¶</a></dt>
<dd><p>HTTPS URL 열기를 처리하는 클래스. <em>context</em>와 <em>check_hostname</em>은 <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.client.HTTPSConnection</span></code></a>과 같은 의미입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>context</em>와 <em>check_hostname</em>이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.FileHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">FileHandler</code><a class="headerlink" href="#urllib.request.FileHandler" title="정의 주소">¶</a></dt>
<dd><p>로컬 파일을 엽니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.DataHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">DataHandler</code><a class="headerlink" href="#urllib.request.DataHandler" title="정의 주소">¶</a></dt>
<dd><p>데이터 URL을 엽니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.FTPHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">FTPHandler</code><a class="headerlink" href="#urllib.request.FTPHandler" title="정의 주소">¶</a></dt>
<dd><p>FTP URL을 엽니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.CacheFTPHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">CacheFTPHandler</code><a class="headerlink" href="#urllib.request.CacheFTPHandler" title="정의 주소">¶</a></dt>
<dd><p>지연 시간을 최소화하기 위해 열린 FTP 연결의 캐시를 유지하면서, FTP URL을 엽니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.UnknownHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">UnknownHandler</code><a class="headerlink" href="#urllib.request.UnknownHandler" title="정의 주소">¶</a></dt>
<dd><p>알 수 없는 URL을 처리하기 위한 포괄적인(catch-all) 클래스.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPErrorProcessor">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPErrorProcessor</code><a class="headerlink" href="#urllib.request.HTTPErrorProcessor" title="정의 주소">¶</a></dt>
<dd><p>HTTP 에러 응답을 처리합니다.</p>
</dd></dl>

<div class="section" id="request-objects">
<span id="id1"></span><h2>Request 객체<a class="headerlink" href="#request-objects" title="제목 주소">¶</a></h2>
<p>다음 메서드는 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>의 공용 인터페이스를 설명하므로, 서브 클래스에서 모두 재정의될 수 있습니다. 또한 클라이언트가 구문 분석된 요청을 검사하는 데 사용할 수 있는 몇 가지 공용 어트리뷰트를 정의합니다.</p>
<dl class="attribute">
<dt id="urllib.request.Request.full_url">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">full_url</code><a class="headerlink" href="#urllib.request.Request.full_url" title="정의 주소">¶</a></dt>
<dd><p>생성자에 전달된 원래 URL.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경.</span></p>
</div>
<p>Request.full_url은 setter, getter 및 deleter가 있는 프로퍼티입니다. <a class="reference internal" href="#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">full_url</span></code></a>을 읽으면 프래그먼트가 있는 원래 요청 URL을 반환합니다 (있다면).</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.type">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">type</code><a class="headerlink" href="#urllib.request.Request.type" title="정의 주소">¶</a></dt>
<dd><p>URI 스킴.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.host">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">host</code><a class="headerlink" href="#urllib.request.Request.host" title="정의 주소">¶</a></dt>
<dd><p>URI 주체(authority), 일반적으로 호스트이지만 콜론으로 구분된 포트를 포함할 수도 있습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.origin_req_host">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">origin_req_host</code><a class="headerlink" href="#urllib.request.Request.origin_req_host" title="정의 주소">¶</a></dt>
<dd><p>포트가 없는, 요청의 원래 호스트.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.selector">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">selector</code><a class="headerlink" href="#urllib.request.Request.selector" title="정의 주소">¶</a></dt>
<dd><p>URI 경로. <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>가 프락시를 사용하면, selector는 프락시로 전달되는 전체 URL이 됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.data">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">data</code><a class="headerlink" href="#urllib.request.Request.data" title="정의 주소">¶</a></dt>
<dd><p>요청의 엔티티 바디, 또는 지정되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.data</span></code></a>의 값을 변경하면 이제 &quot;Content-Length&quot; 헤더가 이전에 설정되거나 계산되었다면 삭제됩니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.unverifiable">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">unverifiable</code><a class="headerlink" href="#urllib.request.Request.unverifiable" title="정의 주소">¶</a></dt>
<dd><p>불리언, <span class="target" id="index-30"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2965.html"><strong>RFC 2965</strong></a>에서 정의한 대로 요청을 확인할 수 없는지를 나타냅니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.method">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">method</code><a class="headerlink" href="#urllib.request.Request.method" title="정의 주소">¶</a></dt>
<dd><p>사용할 HTTP 요청 메서드. 기본적으로 값은 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>입니다. 이는 <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a>가 사용될 메서드의 일반적인 계산을 수행함을 뜻합니다. <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 서브 클래스의 클래스 수준에서 값을 설정해서 기본값을 제공하거나, <em>method</em> 인자를 통해 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 생성자에 값을 전달하여 값을 설정할 수 있습니다 (그래서 <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a>의 기본 계산을 무시합니다).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>서브 클래스에서 이제 기본값을 설정할 수 있습니다; 이전에는 생성자 인자를 통해서만 설정할 수 있었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_method">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">get_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_method" title="정의 주소">¶</a></dt>
<dd><p>HTTP 요청 메서드를 나타내는 문자열을 반환합니다. <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면, 그 값을 반환하고, 그렇지 않으면 <a class="reference internal" href="#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.data</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면 <code class="docutils literal notranslate"><span class="pre">'GET'</span></code>을 반환하거나 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">'POST'</span></code>를 반환합니다. 이것은 HTTP 요청에만 의미가 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>get_method는 이제 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a>의 값을 조사합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.add_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">add_header</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">val</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.add_header" title="정의 주소">¶</a></dt>
<dd><p>요청에 다른 헤더를 추가합니다. 헤더는 현재 HTTP 처리기를 제외한 모든 처리기에서 무시되며, HTTP 처리기에서는 서버로 전송되는 헤더 리스트에 추가됩니다. 같은 이름을 가진 헤더를 두 개 이상 가질 수 없으며, <em>key</em>가 충돌하는 경우 후속 호출은 이전 호출을 덮어씁니다. 현재, 두 번 이상 사용될 때 의미가 있는 모든 헤더는 하나의 헤더만 사용하여 같은 기능을 얻는 (헤더 별) 방식을 가지므로 HTTP 기능의 손실은 없습니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.add_unredirected_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">add_unredirected_header</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">header</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.add_unredirected_header" title="정의 주소">¶</a></dt>
<dd><p>리디렉션 된 요청에 추가되지 않을 헤더를 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.has_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">has_header</code><span class="sig-paren">(</span><em class="sig-param">header</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.has_header" title="정의 주소">¶</a></dt>
<dd><p>인스턴스에 명명된 헤더가 있는지를 반환합니다 (일반과 리디렉션되지 않는 것을 모두 확인합니다).</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.remove_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">remove_header</code><span class="sig-paren">(</span><em class="sig-param">header</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.remove_header" title="정의 주소">¶</a></dt>
<dd><p>요청 인스턴스에서 명명된 헤더를 제거합니다 (일반과 리디렉션되지 않은 헤더 모두).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_full_url">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">get_full_url</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_full_url" title="정의 주소">¶</a></dt>
<dd><p>생성자에 제공된 URL을 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경.</span></p>
</div>
<p><a class="reference internal" href="#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.full_url</span></code></a>을 반환합니다</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.set_proxy">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">set_proxy</code><span class="sig-paren">(</span><em class="sig-param">host</em>, <em class="sig-param">type</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.set_proxy" title="정의 주소">¶</a></dt>
<dd><p>프락시 서버에 연결하여 요청을 준비합니다. <em>host</em>와 <em>type</em>은 인스턴스의 것을 대체하고, 인스턴스의 selector는 생성자에 제공된 원래 URL이 됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">get_header</code><span class="sig-paren">(</span><em class="sig-param">header_name</em>, <em class="sig-param">default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_header" title="정의 주소">¶</a></dt>
<dd><p>지정된 헤더의 값을 반환합니다. 헤더가 없으면, default 값을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.header_items">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">header_items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.header_items" title="정의 주소">¶</a></dt>
<dd><p>요청 헤더의 튜플 (header_name, header_value) 리스트를 반환합니다.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>3.3부터 폐지된 add_data, has_data, get_data, get_type, get_host, get_selector, get_origin_req_host 및 is_unverifiable 요청 메서드가 제거되었습니다.</p>
</div>
</div>
<div class="section" id="openerdirector-objects">
<span id="opener-director-objects"></span><h2>OpenerDirector 객체<a class="headerlink" href="#openerdirector-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 인스턴스에는 다음과 같은 메서드가 있습니다:</p>
<dl class="method">
<dt id="urllib.request.OpenerDirector.add_handler">
<code class="sig-prename descclassname">OpenerDirector.</code><code class="sig-name descname">add_handler</code><span class="sig-paren">(</span><em class="sig-param">handler</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.add_handler" title="정의 주소">¶</a></dt>
<dd><p><em>handler</em>는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>의 인스턴스여야 합니다. 다음 메서드가 검색되어, 가능한 체인에 추가됩니다 (HTTP 에러는 특별한 경우임에 유의하십시오). 다음에서 <em>protocol</em>은 처리할 실제 프로토콜로 바꿔야 합니다, 예를 들어 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_response()</span></code>는 HTTP 프로토콜 응답 처리기입니다. 또한 <em>type</em>은 실제 HTTP 코드로 대체해야 합니다, 예를 들어 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_404()</span></code>는 HTTP 404 에러를 처리합니다.</p>
<ul>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> --- 처리기가 <em>protocol</em> URL을 여는 방법을 알고 있음을 알립니다.</p>
<p>자세한 정보는 <a class="reference internal" href="#protocol-open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_open()</span></code></a>을 참조하십시오.</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> --- 처리기가 HTTP 에러 코드 <em>type</em>을 갖는 HTTP 에러를 처리하는 방법을 알고 있음을 알립니다.</p>
<p>자세한 정보는 <a class="reference internal" href="#http-error-nnn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.http_error_&lt;nnn&gt;()</span></code></a>을 참조하십시오.</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_error()</span></code> --- 처리기가 (<code class="docutils literal notranslate"><span class="pre">http</span></code>가 아닌) <em>protocol</em>의 에러를 처리하는 방법을 알고 있음을 알립니다.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code> --- 처리기가 <em>protocol</em> 요청을 전처리(pre-process)하는 방법을 알고 있음을 알립니다.</p>
<p>자세한 정보는 <a class="reference internal" href="#protocol-request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_request()</span></code></a>를 참조하십시오.</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> --- 처리기가 <em>protocol</em> 응답을 후처리(post-process)하는 방법을 알고 있음을 알립니다.</p>
<p>자세한 정보는 <a class="reference internal" href="#protocol-response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_response()</span></code></a>를 참조하십시오.</p>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="urllib.request.OpenerDirector.open">
<code class="sig-prename descclassname">OpenerDirector.</code><code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">data=None</em><span class="optional">[</span>, <em class="sig-param">timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.open" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>url</em>(요청 객체나 문자열일 수 있습니다)을 열고, 선택적으로 주어진 <em>data</em>를 전달합니다. 인자, 반환 값 및 발생하는 예외는 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>과 같습니다 (단순히 현재 설치된 전역 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>의 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> 메서드를 호출합니다). 선택적 <em>timeout</em> 매개 변수는 연결 시도와 같은 연산을 블로킹하기 위한 시간제한을 초 단위로 지정합니다 (지정하지 않으면 전역 기본 시간제한 설정이 사용됩니다). 시간제한 기능은 실제로는 HTTP, HTTPS 및 FTP 연결에서만 작동합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.OpenerDirector.error">
<code class="sig-prename descclassname">OpenerDirector.</code><code class="sig-name descname">error</code><span class="sig-paren">(</span><em class="sig-param">proto</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.error" title="정의 주소">¶</a></dt>
<dd><p>주어진 프로토콜의 에러를 처리합니다. 이것은 주어진 프로토콜에 대해 등록된 에러 처리기를 주어진 인자(프로토콜 특정입니다)로 호출합니다. HTTP 프로토콜은 HTTP 응답 코드를 사용하여 특정 에러 처리기를 결정하는 특수한 경우입니다; 처리기 클래스의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> 메서드를 참조하십시오.</p>
<p>반환 값과 발생하는 예외는 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>과 같습니다.</p>
</dd></dl>

<p>OpenerDirector 객체는 다음 3단계로 URL을 엽니다:</p>
<p>각 단계에서 이러한 메서드가 호출되는 순서는 처리기 인스턴스를 정렬하여 결정됩니다.</p>
<ol class="arabic">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code>와 같은 이름의 메서드를 가진 모든 처리기가 요청을 전처리하기 위해 해당 메서드가 호출됩니다.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code>과 같은 이름의 메서드를 가진 처리기가 요청을 처리하기 위해 호출됩니다. 이 단계는 처리기가 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>이 아닌 값(즉, 응답)을 반환하거나, 예외(보통 <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>)를 발생시킬 때 종료됩니다. 예외 전파가 허용됩니다.</p>
<p>사실, 위의 알고리즘은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code>이라는 메서드를 먼저 시도됩니다. 이러한 모든 메서드가 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환하면, 알고리즘은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code>과 같은 이름의 메서드에 대해 반복합니다. 이러한 모든 메서드가 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환하면, 알고리즘은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">unknown_open()</span></code>이라는 메서드에 대해 반복합니다.</p>
<p>이러한 메서드의 구현은 부모 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 인스턴스의 <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a>과 <a class="reference internal" href="#urllib.request.OpenerDirector.error" title="urllib.request.OpenerDirector.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a> 메서드의 호출을 수반할 수 있음에 유의하십시오.</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code>와 같은 이름의 메서드가 있는 모든 처리기는 응답을 후처리하기 위해 해당 메서드가 호출됩니다.</p></li>
</ol>
</div>
<div class="section" id="basehandler-objects">
<span id="base-handler-objects"></span><h2>BaseHandler 객체<a class="headerlink" href="#basehandler-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 객체는 직접적으로 유용한 몇 가지 메서드와 파생 클래스에서 사용하기 위한 다른 메서드를 제공합니다. 다음은 직접 사용하기 위한 것입니다:</p>
<dl class="method">
<dt id="urllib.request.BaseHandler.add_parent">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">add_parent</code><span class="sig-paren">(</span><em class="sig-param">director</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.add_parent" title="정의 주소">¶</a></dt>
<dd><p>director를 부모로 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.close">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.close" title="정의 주소">¶</a></dt>
<dd><p>모든 부모를 제거합니다.</p>
</dd></dl>

<p>다음 어트리뷰트와 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>에서 파생된 클래스에서만 사용해야 합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code>나 <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> 메서드를 정의하는 서브 클래스는 <code class="xref py py-class docutils literal notranslate"><span class="pre">*Processor</span></code>라고 이름 붙이는 규칙이 채택되었습니다; 다른 모든 것들의 이름은 <code class="xref py py-class docutils literal notranslate"><span class="pre">*Handler</span></code>입니다.</p>
</div>
<dl class="attribute">
<dt id="urllib.request.BaseHandler.parent">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">parent</code><a class="headerlink" href="#urllib.request.BaseHandler.parent" title="정의 주소">¶</a></dt>
<dd><p>다른 프로토콜을 사용하여 열거나 에러를 처리하는 데 사용할 수 있는 유효한 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.default_open">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">default_open</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.default_open" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>에 정의되지 <em>않았지만</em>, 서브 클래스가 모든 URL을 포착하려면 이를 정의해야 합니다.</p>
<p>구현되면 이 메서드는 부모 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다. <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>의 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a>의 반환 값에 설명된 대로 파일류 객체를 반환하거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환해야 합니다. 진짜 예외적인 상황이 발생하지 않는 한  (예를 들어, <a class="reference internal" href="exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a>는 <code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code>로 매핑하지 않아야 합니다), <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>를 발생해야 합니다.</p>
<p>이 메서드는 프로토콜별 open 메서드보다 먼저 호출됩니다.</p>
</dd></dl>

<span class="target" id="protocol-open"></span><dl class="method">
<dt>
<code class="sig-name descname">BaseHandler.&lt;protocol&gt;_open(req)</code></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스가 주어진 프로토콜로 URL을 처리하려면 이를 정의해야 합니다.</p>
<p>정의되면, 이 메서드는 부모 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다. 반환 값은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code>과 같아야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.unknown_open">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">unknown_open</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.unknown_open" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스는 등록된 특정 처리기가 없는 모든 URL을 잡아서 열려면 이를 정의해야 합니다.</p>
<p>구현되면, 이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler.parent" title="urllib.request.BaseHandler.parent"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parent</span></code></a> <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다. 반환 값은 <a class="reference internal" href="#urllib.request.BaseHandler.default_open" title="urllib.request.BaseHandler.default_open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code></a>과 같아야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.http_error_default">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">http_error_default</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.http_error_default" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스는 달리 처리되지 않은 HTTP 에러에 대해 포괄적인 처리를 제공하려면 이를 재정의해야 합니다. 에러가 발생하는 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 자동으로 호출되며, 다른 상황에서는 일반적으로 호출되지 않아야 합니다.</p>
<p><em>req</em>는 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체, <em>fp</em>는 HTTP 에러 바디가 있는 파일류 객체, <em>code</em>는 에러의 3자리 코드, <em>msg</em>는 사용자가 볼 수 있는 코드 설명, <em>hdrs</em>는 에러의 헤더가 있는 매핑 객체가 됩니다.</p>
<p>반환 값과 발생하는 예외는 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>의 것과 같아야 합니다.</p>
</dd></dl>

<span class="target" id="http-error-nnn"></span><dl class="method">
<dt>
<code class="sig-name descname">BaseHandler.http_error_&lt;nnn&gt;(req, fp, code, msg, hdrs)</code></dt>
<dd><p><em>nnn</em>은 3자리 HTTP 에러 코드여야 합니다. 이 메서드도 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되어 있지 않지만, 존재한다면 코드가 <em>nnn</em> 인 HTTP 에러가 발생할 때 서브 클래스의 인스턴스에 대해 호출됩니다.</p>
<p>특정 HTTP 에러를 처리하려면 서브 클래스가 이 메서드를 재정의해야 합니다.</p>
<p>인자, 반환 값 및 발생하는 예외는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_default()</span></code>와 같아야 합니다.</p>
</dd></dl>

<span class="target" id="protocol-request"></span><dl class="method">
<dt>
<code class="sig-name descname">BaseHandler.&lt;protocol&gt;_request(req)</code></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스는 주어진 프로토콜의 요청을 전처리하려면 이를 정의해야 합니다.</p>
<p>정의되면, 이 메서드는 부모 상위 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다. <em>req</em>는 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체가 됩니다. 반환 값은 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체여야 합니다.</p>
</dd></dl>

<span class="target" id="protocol-response"></span><dl class="method">
<dt>
<code class="sig-name descname">BaseHandler.&lt;protocol&gt;_response(req, response)</code></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스는 주어진 프로토콜의 응답을 후처리하려면 이를 정의해야 합니다.</p>
<p>정의되면, 이 메서드는 부모 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다. <em>req</em>는 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체가 됩니다. <em>response</em>는 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>의 반환 값과 같은 인터페이스를 구현하는 객체가 됩니다. 반환 값은 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>의 반환 값과 같은 인터페이스를 구현해야 합니다.</p>
</dd></dl>

</div>
<div class="section" id="httpredirecthandler-objects">
<span id="http-redirect-handler"></span><h2>HTTPRedirectHandler 객체<a class="headerlink" href="#httpredirecthandler-objects" title="제목 주소">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>일부 HTTP 리디렉션은 이 모듈의 클라이언트 코드로부터의 액션을 요구합니다. 이 경우, <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a>가 발생합니다. 다양한 리디렉션 코드의 정확한 의미에 대한 자세한 내용은 <span class="target" id="index-31"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a>을 참조하십시오.</p>
<p>HTTPRedirectHandler 에 HTTP, HTTPS 또는 FTP URL이 아닌 리디렉션 된 URL이 제공되면 보안을 고려하여 <code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPError</span></code> 예외가 발생했습니다.</p>
</div>
<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.redirect_request">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">redirect_request</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em>, <em class="sig-param">newurl</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.redirect_request" title="정의 주소">¶</a></dt>
<dd><p>리디렉션에 대한 응답으로 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>나 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 이것은 서버로부터 리디렉션이 수신될 때 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_30*()</span></code> 메서드의 기본 구현에 의해 호출됩니다. 리디렉션이 일어나야 하면, <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_30*()</span></code>이 <em>newurl</em>로 리디렉션을 수행할 수 있도록 새 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>를 반환합니다. 그렇지 않으면 다른 처리기가 이 URL을 처리하려고 시도하지 않아야 한다면 <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a>를 발생시키고, 자신은 할 수 없지만 다른 처리기가 처리할 수 있다면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 메서드의 기본 구현은 <span class="target" id="index-32"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a>을 엄격하게 따르지 않습니다. 즉, <code class="docutils literal notranslate"><span class="pre">POST</span></code> 요청에 대한 301과 302 응답은 사용자의 확인 없이 자동으로 리디렉션 되지 않아야 합니다. 실제로는, 브라우저들이 POST를 <code class="docutils literal notranslate"><span class="pre">GET</span></code>으로 변경하여 이러한 응답의 자동 리디렉션을 허용하며, 기본 구현은 이 동작을 재현합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_301">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">http_error_301</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Location:</span></code>이나 <code class="docutils literal notranslate"><span class="pre">URI:</span></code> URL로 리디렉션 합니다. 이 메서드는 HTTP 'moved permanently(영구적으로 이전했음)' 응답을 받을 때 부모 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_302">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">http_error_302</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_302" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>과 같지만, 'found(발견됨)' 응답에 대해 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_303">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">http_error_303</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_303" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>과 같지만, 'see other(다른 곳을 보세요)' 응답에 대해 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_307">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">http_error_307</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_307" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>과 같지만, 'temporary redirect(임시 리디렉션)' 응답에 대해 호출됩니다.</p>
</dd></dl>

</div>
<div class="section" id="httpcookieprocessor-objects">
<span id="http-cookie-processor"></span><h2>HTTPCookieProcessor 객체<a class="headerlink" href="#httpcookieprocessor-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.HTTPCookieProcessor" title="urllib.request.HTTPCookieProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPCookieProcessor</span></code></a> 인스턴스에는 하나의 어트리뷰트가 있습니다:</p>
<dl class="attribute">
<dt id="urllib.request.HTTPCookieProcessor.cookiejar">
<code class="sig-prename descclassname">HTTPCookieProcessor.</code><code class="sig-name descname">cookiejar</code><a class="headerlink" href="#urllib.request.HTTPCookieProcessor.cookiejar" title="정의 주소">¶</a></dt>
<dd><p>쿠키가 저장되는 <a class="reference internal" href="http.cookiejar.html#http.cookiejar.CookieJar" title="http.cookiejar.CookieJar"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.cookiejar.CookieJar</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="proxyhandler-objects">
<span id="proxy-handler"></span><h2>ProxyHandler 객체<a class="headerlink" href="#proxyhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt>
<code class="sig-name descname">ProxyHandler.&lt;protocol&gt;_open(request)</code></dt>
<dd><p><a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a>에는 생성자에 지정된 <em>proxies</em> 딕셔너리에 프락시가 있는 모든 <em>protocol</em>에 대해 <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> 메서드가 있습니다. 이 메서드는 <code class="docutils literal notranslate"><span class="pre">request.set_proxy()</span></code>를 호출하여 요청이 프락시를 통과하도록 수정하고, 체인에 있는 다음 처리기를 호출하여 실제로 프로토콜을 실행합니다.</p>
</dd></dl>

</div>
<div class="section" id="httppasswordmgr-objects">
<span id="http-password-mgr"></span><h2>HTTPPasswordMgr 객체<a class="headerlink" href="#httppasswordmgr-objects" title="제목 주소">¶</a></h2>
<p>이 메서드는 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> 객체에서 사용 가능합니다.</p>
<dl class="method">
<dt id="urllib.request.HTTPPasswordMgr.add_password">
<code class="sig-prename descclassname">HTTPPasswordMgr.</code><code class="sig-name descname">add_password</code><span class="sig-paren">(</span><em class="sig-param">realm</em>, <em class="sig-param">uri</em>, <em class="sig-param">user</em>, <em class="sig-param">passwd</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.add_password" title="정의 주소">¶</a></dt>
<dd><p><em>uri</em>는 단일 URI이거나 URI의 시퀀스일 수 있습니다. <em>realm</em>, <em>user</em> 및 <em>passwd</em>는 문자열이어야 합니다. 이는 <em>realm</em>과 지정된 URI 중 어느 하나의 슈퍼 URI에 대한 인증이 주어질 때 <code class="docutils literal notranslate"><span class="pre">(user,</span> <span class="pre">passwd)</span></code>가 인증 토큰으로 사용되도록 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPPasswordMgr.find_user_password">
<code class="sig-prename descclassname">HTTPPasswordMgr.</code><code class="sig-name descname">find_user_password</code><span class="sig-paren">(</span><em class="sig-param">realm</em>, <em class="sig-param">authuri</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.find_user_password" title="정의 주소">¶</a></dt>
<dd><p>주어진 realm과 URI에 대한 사용자/암호를 (있다면) 가져옵니다. 일치하는 사용자/암호가 없으면 이 메서드는 <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">None)</span></code>을 반환합니다.</p>
<p><a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> 객체의 경우, 주어진 <em>realm</em>에 일치하는 사용자/암호가 없으면 영역 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 검색됩니다.</p>
</dd></dl>

</div>
<div class="section" id="httppasswordmgrwithpriorauth-objects">
<span id="http-password-mgr-with-prior-auth"></span><h2>HTTPPasswordMgrWithPriorAuth 객체<a class="headerlink" href="#httppasswordmgrwithpriorauth-objects" title="제목 주소">¶</a></h2>
<p>이 암호 관리자는 <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a>를 확장하여 인증 자격 증명을 항상 보내야 하는 URI를 추적하는 것을 지원합니다.</p>
<dl class="method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.add_password">
<code class="sig-prename descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="sig-name descname">add_password</code><span class="sig-paren">(</span><em class="sig-param">realm</em>, <em class="sig-param">uri</em>, <em class="sig-param">user</em>, <em class="sig-param">passwd</em>, <em class="sig-param">is_authenticated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.add_password" title="정의 주소">¶</a></dt>
<dd><p><em>realm</em>, <em>uri</em>, <em>user</em>, <em>passwd</em>는 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr.add_password" title="urllib.request.HTTPPasswordMgr.add_password"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HTTPPasswordMgr.add_password()</span></code></a>와 같습니다. <em>is_authenticated</em>는 주어진 URI나 URI 리스트에 대한 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 플래그의 초깃값을 설정합니다. <em>is_authenticated</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 지정되면, <em>realm</em>는 무시됩니다.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-prename descclassname">HTTPPasswordMgr.</code><code class="sig-name descname">find_user_password</code><span class="sig-paren">(</span><em class="sig-param">realm</em>, <em class="sig-param">authuri</em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> 객체와 같습니다</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated">
<code class="sig-prename descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="sig-name descname">update_authenticated</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">uri</em>, <em class="sig-param">is_authenticated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>uri</em>나 URI 리스트에 대해 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 플래그를 갱신합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated">
<code class="sig-prename descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="sig-name descname">is_authenticated</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">authuri</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated" title="정의 주소">¶</a></dt>
<dd><p>주어진 URI에 대한 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 플래그의 현재 상태를 반환합니다.</p>
</dd></dl>

</div>
<div class="section" id="abstractbasicauthhandler-objects">
<span id="abstract-basic-auth-handler"></span><h2>AbstractBasicAuthHandler 객체<a class="headerlink" href="#abstractbasicauthhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed">
<code class="sig-prename descclassname">AbstractBasicAuthHandler.</code><code class="sig-name descname">http_error_auth_reqed</code><span class="sig-paren">(</span><em class="sig-param">authreq</em>, <em class="sig-param">host</em>, <em class="sig-param">req</em>, <em class="sig-param">headers</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed" title="정의 주소">¶</a></dt>
<dd><p>사용자/암호 쌍을 가져오고 요청을 다시 시도하여 인증 요청을 처리합니다. <em>authreq</em>는 영역(realm)에 대한 정보가 요청에 포함된 헤더의 이름이어야 하고, <em>host</em>는 인증할 URL과 경로를 지정하고, <em>req</em>는 (실패한) <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체여야 하며, <em>headers</em>는 에러 헤더여야 합니다.</p>
<p><em>host</em>는 주체(예를 들어 <code class="docutils literal notranslate"><span class="pre">&quot;python.org&quot;</span></code>)거나 주체 구성 요소를 포함하는 URL(예를 들어 <code class="docutils literal notranslate"><span class="pre">&quot;http://python.org/&quot;</span></code>)입니다. 어느 경우이든, 주체는 userinfo 구성 요소를 포함하지 않아야 합니다 (따라서, <code class="docutils literal notranslate"><span class="pre">&quot;python.org&quot;</span></code>와 <code class="docutils literal notranslate"><span class="pre">&quot;python.org:80&quot;</span></code>은 좋지만, <code class="docutils literal notranslate"><span class="pre">&quot;joe:password&#64;python.org&quot;</span></code>는 유효하지 않습니다).</p>
</dd></dl>

</div>
<div class="section" id="httpbasicauthhandler-objects">
<span id="http-basic-auth-handler"></span><h2>HTTPBasicAuthHandler 객체<a class="headerlink" href="#httpbasicauthhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPBasicAuthHandler.http_error_401">
<code class="sig-prename descclassname">HTTPBasicAuthHandler.</code><code class="sig-name descname">http_error_401</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler.http_error_401" title="정의 주소">¶</a></dt>
<dd><p>가능하다면 인증 정보로 요청을 재시도합니다.</p>
</dd></dl>

</div>
<div class="section" id="proxybasicauthhandler-objects">
<span id="proxy-basic-auth-handler"></span><h2>ProxyBasicAuthHandler 객체<a class="headerlink" href="#proxybasicauthhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.ProxyBasicAuthHandler.http_error_407">
<code class="sig-prename descclassname">ProxyBasicAuthHandler.</code><code class="sig-name descname">http_error_407</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler.http_error_407" title="정의 주소">¶</a></dt>
<dd><p>가능하다면 인증 정보로 요청을 재시도합니다.</p>
</dd></dl>

</div>
<div class="section" id="abstractdigestauthhandler-objects">
<span id="abstract-digest-auth-handler"></span><h2>AbstractDigestAuthHandler 객체<a class="headerlink" href="#abstractdigestauthhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed">
<code class="sig-prename descclassname">AbstractDigestAuthHandler.</code><code class="sig-name descname">http_error_auth_reqed</code><span class="sig-paren">(</span><em class="sig-param">authreq</em>, <em class="sig-param">host</em>, <em class="sig-param">req</em>, <em class="sig-param">headers</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed" title="정의 주소">¶</a></dt>
<dd><p><em>authreq</em>는 영역(realm)에 대한 정보가 요청에 포함된 헤더의 이름이어야 하고, <em>host</em>는 인증할 호스트여야 하고, <em>req</em>는 (실패한) <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체여야 하며, <em>headers</em>는 에러 헤더여야 합니다.</p>
</dd></dl>

</div>
<div class="section" id="httpdigestauthhandler-objects">
<span id="http-digest-auth-handler"></span><h2>HTTPDigestAuthHandler 객체<a class="headerlink" href="#httpdigestauthhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPDigestAuthHandler.http_error_401">
<code class="sig-prename descclassname">HTTPDigestAuthHandler.</code><code class="sig-name descname">http_error_401</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler.http_error_401" title="정의 주소">¶</a></dt>
<dd><p>가능하다면 인증 정보로 요청을 재시도합니다.</p>
</dd></dl>

</div>
<div class="section" id="proxydigestauthhandler-objects">
<span id="proxy-digest-auth-handler"></span><h2>ProxyDigestAuthHandler 객체<a class="headerlink" href="#proxydigestauthhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.ProxyDigestAuthHandler.http_error_407">
<code class="sig-prename descclassname">ProxyDigestAuthHandler.</code><code class="sig-name descname">http_error_407</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler.http_error_407" title="정의 주소">¶</a></dt>
<dd><p>가능하다면 인증 정보로 요청을 재시도합니다.</p>
</dd></dl>

</div>
<div class="section" id="httphandler-objects">
<span id="http-handler-objects"></span><h2>HTTPHandler 객체<a class="headerlink" href="#httphandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPHandler.http_open">
<code class="sig-prename descclassname">HTTPHandler.</code><code class="sig-name descname">http_open</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPHandler.http_open" title="정의 주소">¶</a></dt>
<dd><p>HTTP 요청을 보냅니다. <code class="docutils literal notranslate"><span class="pre">req.has_data()</span></code>에 따라, GET이나 POST일 수 있습니다.</p>
</dd></dl>

</div>
<div class="section" id="httpshandler-objects">
<span id="https-handler-objects"></span><h2>HTTPSHandler 객체<a class="headerlink" href="#httpshandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPSHandler.https_open">
<code class="sig-prename descclassname">HTTPSHandler.</code><code class="sig-name descname">https_open</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPSHandler.https_open" title="정의 주소">¶</a></dt>
<dd><p>HTTPS 요청을 보냅니다. <code class="docutils literal notranslate"><span class="pre">req.has_data()</span></code>에 따라, GET이나 POST일 수 있습니다.</p>
</dd></dl>

</div>
<div class="section" id="filehandler-objects">
<span id="file-handler-objects"></span><h2>FileHandler 객체<a class="headerlink" href="#filehandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.FileHandler.file_open">
<code class="sig-prename descclassname">FileHandler.</code><code class="sig-name descname">file_open</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FileHandler.file_open" title="정의 주소">¶</a></dt>
<dd><p>호스트 이름이 없거나, 호스트 이름이 <code class="docutils literal notranslate"><span class="pre">'localhost'</span></code>인 경우 파일을 로컬에서 엽니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>이 메서드는 로컬 호스트 명에만 적용할 수 있습니다. 원격 호스트 이름이 제공되면, <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>가 발생합니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="datahandler-objects">
<span id="data-handler-objects"></span><h2>DataHandler 객체<a class="headerlink" href="#datahandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.DataHandler.data_open">
<code class="sig-prename descclassname">DataHandler.</code><code class="sig-name descname">data_open</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.DataHandler.data_open" title="정의 주소">¶</a></dt>
<dd><p>데이터 URL을 읽습니다. 이러한 종류의 URL에는 URL 자체에 인코딩된 콘텐츠가 포함됩니다. 데이터 URL 문법은 <span class="target" id="index-33"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2397.html"><strong>RFC 2397</strong></a>에 지정되어 있습니다. 이 구현은 base64로 인코딩된 데이터 URL의 공백을 무시하기 때문에 URL은 소스 파일과 관계없이 줄 넘김 될 수 있습니다. 그러나 일부 브라우저가 base64로 인코딩된 데이터 URL 끝에 패딩이 누락된 것에 대해 신경 쓰지 않지만, 이 구현은 이 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

</div>
<div class="section" id="ftphandler-objects">
<span id="ftp-handler-objects"></span><h2>FTPHandler 객체<a class="headerlink" href="#ftphandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.FTPHandler.ftp_open">
<code class="sig-prename descclassname">FTPHandler.</code><code class="sig-name descname">ftp_open</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FTPHandler.ftp_open" title="정의 주소">¶</a></dt>
<dd><p><em>req</em>로 표시된 FTP 파일을 엽니다. 로그인은 항상 빈 사용자 이름과 암호로 수행됩니다.</p>
</dd></dl>

</div>
<div class="section" id="cacheftphandler-objects">
<span id="cacheftp-handler-objects"></span><h2>CacheFTPHandler 객체<a class="headerlink" href="#cacheftphandler-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.CacheFTPHandler" title="urllib.request.CacheFTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CacheFTPHandler</span></code></a> 객체는 다음과 같은 추가 메서드가 있는 <a class="reference internal" href="#urllib.request.FTPHandler" title="urllib.request.FTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FTPHandler</span></code></a> 객체입니다:</p>
<dl class="method">
<dt id="urllib.request.CacheFTPHandler.setTimeout">
<code class="sig-prename descclassname">CacheFTPHandler.</code><code class="sig-name descname">setTimeout</code><span class="sig-paren">(</span><em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.CacheFTPHandler.setTimeout" title="정의 주소">¶</a></dt>
<dd><p>연결 시간제한을 <em>t</em> 초로 설정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.CacheFTPHandler.setMaxConns">
<code class="sig-prename descclassname">CacheFTPHandler.</code><code class="sig-name descname">setMaxConns</code><span class="sig-paren">(</span><em class="sig-param">m</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.CacheFTPHandler.setMaxConns" title="정의 주소">¶</a></dt>
<dd><p>캐시 된 최대 연결 수를 <em>m</em>으로 설정합니다.</p>
</dd></dl>

</div>
<div class="section" id="unknownhandler-objects">
<span id="unknown-handler-objects"></span><h2>UnknownHandler 객체<a class="headerlink" href="#unknownhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.UnknownHandler.unknown_open">
<code class="sig-prename descclassname">UnknownHandler.</code><code class="sig-name descname">unknown_open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.UnknownHandler.unknown_open" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a> 예외를 발생시킵니다.</p>
</dd></dl>

</div>
<div class="section" id="httperrorprocessor-objects">
<span id="http-error-processor-objects"></span><h2>HTTPErrorProcessor 객체<a class="headerlink" href="#httperrorprocessor-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPErrorProcessor.http_response">
<code class="sig-prename descclassname">HTTPErrorProcessor.</code><code class="sig-name descname">http_response</code><span class="sig-paren">(</span><em class="sig-param">request</em>, <em class="sig-param">response</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.http_response" title="정의 주소">¶</a></dt>
<dd><p>HTTP 에러 응답을 처리합니다.</p>
<p>200 에러 코드의 경우, 응답 객체가 즉시 반환됩니다.</p>
<p>200이 아닌 에러 코드의 경우, <a class="reference internal" href="#urllib.request.OpenerDirector.error" title="urllib.request.OpenerDirector.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.error()</span></code></a>를 통해 단순히 작업을 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> 처리기 메서드로 전달합니다. 결국, 다른 처리기가 에러를 처리하지 않으면 <a class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler" title="urllib.request.HTTPDefaultErrorHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPDefaultErrorHandler</span></code></a>는 <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPErrorProcessor.https_response">
<code class="sig-prename descclassname">HTTPErrorProcessor.</code><code class="sig-name descname">https_response</code><span class="sig-paren">(</span><em class="sig-param">request</em>, <em class="sig-param">response</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.https_response" title="정의 주소">¶</a></dt>
<dd><p>HTTPS 에러 응답을 처리합니다.</p>
<p>동작은 <a class="reference internal" href="#urllib.request.HTTPErrorProcessor.http_response" title="urllib.request.HTTPErrorProcessor.http_response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_response()</span></code></a>와 같습니다.</p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="urllib-request-examples"></span><h2>예<a class="headerlink" href="#examples" title="제목 주소">¶</a></h2>
<p>아래 예 외에도 <a class="reference internal" href="../howto/urllib2.html#urllib-howto"><span class="std std-ref">urllib 패키지를 사용하여 인터넷 리소스를 가져오는 방법</span></a>에는 더 많은 예가 나와 있습니다.</p>
<p>이 예제는 python.org 메인 페이지를 가져와서 첫 300바이트를 표시합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">300</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">b&#39;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n\n\n&lt;html</span>
<span class="go">xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n</span>
<span class="go">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\n</span>
<span class="go">&lt;title&gt;Python Programming &#39;</span>
</pre></div>
</div>
<p>urlopen은 바이트열 객체를 반환함에 유의하십시오. 이는 urlopen이 HTTP 서버로부터 수신한 바이트 스트림의 인코딩을 자동으로 결정할 방법이 없기 때문입니다. 일반적으로, 프로그램은 일단 적절한 인코딩을 결정하거나 추측하면 반환된 바이트열 객체를 문자열로 디코딩합니다.</p>
<p>다음 W3C 문서 <a class="reference external" href="https://www.w3.org/International/O-charset">https://www.w3.org/International/O-charset</a>는 (X)HTML이나 XML 문서가 인코딩 정보를 지정할 수 있는 다양한 방법을 나열합니다.</p>
<p>python.org 웹 사이트는 메타 태그에 지정된 대로 <em>utf-8</em> 인코딩을 사용하므로, 바이트열 객체를 디코딩할 때도 이를 사용합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtm</span>
</pre></div>
</div>
<p><a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">컨텍스트 관리자</span></a> 방식을 사용하지 않고도 같은 결과를 얻을 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtm</span>
</pre></div>
</div>
<p>다음 예에서는, CGI의 표준 입력으로 데이터 스트림을 전송하고 반환되는 데이터를 읽습니다. 이 예제는 파이썬 설치가 SSL을 지원할 때만 작동함에 유의하십시오.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;https://localhost/cgi-bin/test.cgi&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">data</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;This data is passed to stdin of the CGI&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">Got Data: &quot;This data is passed to stdin of the CGI&quot;</span>
</pre></div>
</div>
<p>위 예제에서 사용한 샘플 CGI의 코드는 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Content-type: text/plain</span><span class="se">\n\n</span><span class="s1">Got Data: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>다음은 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>를 사용하여 <code class="docutils literal notranslate"><span class="pre">PUT</span></code> 요청을 수행하는 예입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">DATA</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;some data&#39;</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;http://localhost:8080&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">DATA</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;PUT&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
</pre></div>
</div>
<p>기본 HTTP 인증 사용:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="c1"># 기본 HTTP 인증을 지원하는 OpenerDirector를 만듭니다...</span>
<span class="n">auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">HTTPBasicAuthHandler</span><span class="p">()</span>
<span class="n">auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="n">realm</span><span class="o">=</span><span class="s1">&#39;PDQ Application&#39;</span><span class="p">,</span>
                          <span class="n">uri</span><span class="o">=</span><span class="s1">&#39;https://mahler:8092/site-updates.py&#39;</span><span class="p">,</span>
                          <span class="n">user</span><span class="o">=</span><span class="s1">&#39;klem&#39;</span><span class="p">,</span>
                          <span class="n">passwd</span><span class="o">=</span><span class="s1">&#39;kadidd!ehopper&#39;</span><span class="p">)</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">auth_handler</span><span class="p">)</span>
<span class="c1"># ...그리고 urlopen과 함께 사용할 수 있도록 전역으로 설치합니다.</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">install_opener</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#urllib.request.build_opener" title="urllib.request.build_opener"><code class="xref py py-func docutils literal notranslate"><span class="pre">build_opener()</span></code></a>는 기본적으로 <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a>를 포함하여 많은 처리기를 제공합니다. 기본적으로, <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;_proxy</span></code>라는 이름의 환경 변수를 사용합니다, 여기서 <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;</span></code>은 관련된 URL 스킴입니다. 예를 들어, HTTP 프락시의 URL을 얻기 위해 <span class="target" id="index-34"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">http_proxy</span></code> 환경 변수를 읽습니다.</p>
<p>이 예는 기본 <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a>를 프로그래밍 방식으로 제공되는 프락시 URL을 사용하는 것으로 대체하고, <a class="reference internal" href="#urllib.request.ProxyBasicAuthHandler" title="urllib.request.ProxyBasicAuthHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyBasicAuthHandler</span></code></a>로 프락시 인증 지원을 추가합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">proxy_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyHandler</span><span class="p">({</span><span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="s1">&#39;http://www.example.com:3128/&#39;</span><span class="p">})</span>
<span class="n">proxy_auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyBasicAuthHandler</span><span class="p">()</span>
<span class="n">proxy_auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="s1">&#39;realm&#39;</span><span class="p">,</span> <span class="s1">&#39;host&#39;</span><span class="p">,</span> <span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="s1">&#39;password&#39;</span><span class="p">)</span>

<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">proxy_handler</span><span class="p">,</span> <span class="n">proxy_auth_handler</span><span class="p">)</span>
<span class="c1"># 이번에는, OpenerDirector를 설치하지 않고 직접 사용합니다:</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>HTTP 헤더 추가하기:</p>
<p><a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 생성자에 <em>headers</em> 인자를 사용하십시오, 또는:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Referer&#39;</span><span class="p">,</span> <span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="c1"># 기본 User-Agent 헤더 값을 사용자 정의합니다:</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;User-Agent&#39;</span><span class="p">,</span> <span class="s1">&#39;urllib-example/0.1 (Contact: . . .)&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>는 모든 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>에 <em class="mailheader">User-Agent</em> 헤더를 자동으로 추가합니다. 이것을 바꾸려면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">()</span>
<span class="n">opener</span><span class="o">.</span><span class="n">addheaders</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;User-agent&#39;</span><span class="p">,</span> <span class="s1">&#39;Mozilla/5.0&#39;</span><span class="p">)]</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>또한, <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>가 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>(또는 <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.open()</span></code></a>)으로 전달될 때 몇 가지 표준 헤더(<em class="mailheader">Content-Length</em>, <em class="mailheader">Content-Type</em> 및 <em class="mailheader">Host</em>)가 추가됨을 기억하십시오.</p>
<p id="urllib-examples">다음은 <code class="docutils literal notranslate"><span class="pre">GET</span></code> 메서드를 사용하여 파라미터가 포함된 URL을 가져오는 예제 세션입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;http://www.musi-cal.com/cgi-bin/query?</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">params</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>다음 예제는 대신 <code class="docutils literal notranslate"><span class="pre">POST</span></code> 메서드를 사용합니다. urlencode의 파라미터 출력이 데이터로 urlopen에 보내기 전에 바이트열로 인코딩됨에 유의하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&quot;http://requestb.in/xrbl82xr&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>다음 예제는 명시적으로 지정된 HTTP 프락시를 사용하여 환경 설정을 대체합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proxies</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="s1">&#39;http://proxy.example.com:8080/&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">(</span><span class="n">proxies</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;http://www.python.org&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>다음 예제는 프락시를 전혀 사용하지 않도록 환경 설정을 대체합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">({})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;http://www.python.org/&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
</div>
<div class="section" id="legacy-interface">
<h2>레거시 인터페이스<a class="headerlink" href="#legacy-interface" title="제목 주소">¶</a></h2>
<p>다음 함수와 클래스는 파이썬 2 모듈 <code class="docutils literal notranslate"><span class="pre">urllib</span></code>(<code class="docutils literal notranslate"><span class="pre">urllib2</span></code>가 아니라)에서 이식됩니다. 나중에 언젠가 폐지될 수 있습니다.</p>
<dl class="function">
<dt id="urllib.request.urlretrieve">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">urlretrieve</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">reporthook=None</em>, <em class="sig-param">data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlretrieve" title="정의 주소">¶</a></dt>
<dd><p>URL로 표시된 네트워크 객체를 로컬 파일로 복사합니다. URL이 로컬 파일을 가리키면, 파일 이름을 제공하지 않는 한 객체가 복사되지 않습니다. 튜플 <code class="docutils literal notranslate"><span class="pre">(filename,</span> <span class="pre">headers)</span></code>를 반환합니다. 여기서 <em>filename</em>은 객체를 찾을 수 있는 로컬 파일 이름이며, <em>headers</em>는 (원격 객체에 대해) <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>이 반환한 객체의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code> 메서드가 반환한 것입니다. 예외는 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>과 같습니다.</p>
<p>있다면, 두 번째 인자는 복사할 파일 위치를 지정합니다 (없으면, 위치는 생성된 이름을 가진 임시 파일이 됩니다). 있다면, 세 번째 인자는 네트워크 연결이 이루어질 때 한 번 호출되고 그 이후에 각 블록을 읽을 때마다 한 번씩 호출되는 콜러블입니다. 콜러블에는 세 개의 인자가 전달됩니다; 지금까지 전송된 블록 수, 바이트 단위의 블록 크기 및 파일의 전체 크기. 세 번째 인자는 가져오기 요청에 대한 응답으로 파일 크기를 반환하지 않는 구형 FTP 서버에서 <code class="docutils literal notranslate"><span class="pre">-1</span></code>일 수 있습니다.</p>
<p>다음 예는 가장 일반적인 사용 시나리오를 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_filename</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlretrieve</span><span class="p">(</span><span class="s1">&#39;http://python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">local_filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p><em>url</em>이 <code class="file docutils literal notranslate"><span class="pre">http:</span></code> 스킴 식별자를 사용하면, <code class="docutils literal notranslate"><span class="pre">POST</span></code> 요청을 지정하기 위해 선택적 <em>data</em> 인자가 제공될 수 있습니다 (일반적으로 요청형은 <code class="docutils literal notranslate"><span class="pre">GET</span></code>입니다). <em>data</em> 인자는 표준 <em class="mimetype">application/x-www-form-urlencoded</em> 형식의 바이트열 객체여야 합니다; <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 함수를 참조하십시오.</p>
<p><a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a>는 사용 가능한 데이터양이 예상 양(<em>Content-Length</em> 헤더에 의해 보고된 크기)보다 작은 것을 감지하면 <code class="xref py py-exc docutils literal notranslate"><span class="pre">ContentTooShortError</span></code>를 발생시킵니다. 예를 들어, 다운로드가 중단된 경우에 발생할 수 있습니다.</p>
<p><em>Content-Length</em>는 하한값으로 취급됩니다: 읽을 데이터가 더 있으면, urlretrieve는 더 많은 데이터를 읽지만, 사용 가능한 데이터가 부족하면 예외가 발생합니다.</p>
<p>이 경우에도 다운로드된 데이터를 여전히 가져올 수 있으며, 예외 인스턴스의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">content</span></code> 어트리뷰트에 저장됩니다.</p>
<p><em>Content-Length</em> 헤더가 제공되지 않으면, urlretrieve는 다운로드 한 데이터의 크기를 확인할 수 없고, 그냥 반환합니다. 이 경우 다운로드가 성공했다고 가정해야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.urlcleanup">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">urlcleanup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlcleanup" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a>에 대한 이전 호출로 남겨졌을 수 있는 임시 파일을 정리합니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.URLopener">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">URLopener</code><span class="sig-paren">(</span><em class="sig-param">proxies=None</em>, <em class="sig-param">**x509</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener" title="정의 주소">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지.</span></p>
</div>
<p>URL을 열고 읽는 베이스 클래스. <code class="file docutils literal notranslate"><span class="pre">http:</span></code>, <code class="file docutils literal notranslate"><span class="pre">ftp:</span></code> 또는 <code class="file docutils literal notranslate"><span class="pre">file:</span></code> 이외의 스킴을 사용하여 객체 열기를 지원할 필요가 있지 않은 한, 아마도 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a>를 사용하고 싶을 것입니다.</p>
<p>기본적으로, <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> 클래스는 <em class="mailheader">User-Agent</em> 헤더로 <code class="docutils literal notranslate"><span class="pre">urllib/VVV</span></code>를 전송합니다. 여기서 <em>VVV</em>는 <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> 버전 번호입니다. 응용 프로그램은 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a>나 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a>를 서브 클래싱하고 클래스 어트리뷰트 <a class="reference internal" href="#urllib.request.URLopener.version" title="urllib.request.URLopener.version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">version</span></code></a>을 서브 클래스 정의에서 적절한 문자열 값으로 설정하여 자체 <em class="mailheader">User-Agent</em> 헤더를 정의할 수 있습니다.</p>
<p>선택적 <em>proxies</em> 매개 변수는 스킴 이름을 프락시 URL로 매핑하는 딕셔너리여야 합니다. 여기서 빈 딕셔너리는 프락시를 완전히 끕니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>이며, 이 경우 위의 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 정의에서 설명한 대로 환경 프락시 설정이 있으면 사용됩니다.</p>
<p><em>x509</em>로 수집된 추가 키워드 매개 변수는 <code class="file docutils literal notranslate"><span class="pre">https:</span></code> 스킴을 사용할 때 클라이언트의 인증에 사용될 수 있습니다. 키워드 <em>key_file</em>과 <em>cert_file</em>은 SSL 키와 인증서를 제공하기 위해 지원됩니다; 클라이언트 인증을 지원하려면 둘 다 필요합니다.</p>
<p>서버가 에러 코드를 반환하면 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> 객체는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 예외를 발생시킵니다.</p>
<dl class="method">
<dt id="urllib.request.URLopener.open">
<code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param">fullurl</em>, <em class="sig-param">data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.open" title="정의 주소">¶</a></dt>
<dd><p>적절한 프로토콜을 사용하여 <em>fullurl</em>을 엽니다. 이 메서드는 캐시와 프락시 정보를 설정한 다음, 입력 인자로 적절한 open 메서드를 호출합니다. 스킴이 인식되지 않으면, <a class="reference internal" href="#urllib.request.URLopener.open_unknown" title="urllib.request.URLopener.open_unknown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open_unknown()</span></code></a>이 호출됩니다. <em>data</em> 인자는 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>의 <em>data</em> 인자와 같은 의미입니다.</p>
<p>이 메서드는 항상 <a class="reference internal" href="urllib.parse.html#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>를 사용하여 <em>fullurl</em>을 인용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.URLopener.open_unknown">
<code class="sig-name descname">open_unknown</code><span class="sig-paren">(</span><em class="sig-param">fullurl</em>, <em class="sig-param">data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.open_unknown" title="정의 주소">¶</a></dt>
<dd><p>알 수 없는 URL 유형을 여는 재정의 가능한 인터페이스.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.URLopener.retrieve">
<code class="sig-name descname">retrieve</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">reporthook=None</em>, <em class="sig-param">data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.retrieve" title="정의 주소">¶</a></dt>
<dd><p><em>url</em>의 내용을 가져와서 <em>filename</em>에 배치합니다. 반환 값은 로컬 파일명과 응답 헤더를 포함하는 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.message.Message</span></code></a> 객체 (원격 URL의 경우) 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>(로컬 URL의 경우)으로 구성된 튜플입니다. 그러면 호출자는 <em>filename</em>의 내용을 열고 읽어야 합니다. <em>filename</em>이 제공되지 않고 URL이 로컬 파일을 참조하면, 입력 파일명이 반환됩니다. URL이 로컬이 아니고 <em>filename</em>이 제공되지 않으면, 파일 이름은 입력 URL의 마지막 경로 구성 요소의 접미사와 일치하는 접미사로 <a class="reference internal" href="tempfile.html#tempfile.mktemp" title="tempfile.mktemp"><code class="xref py py-func docutils literal notranslate"><span class="pre">tempfile.mktemp()</span></code></a> 한 출력입니다. <em>reporthook</em>이 제공되면, 세 개의 숫자 매개 변수를 받아들이는 함수여야 합니다: 청크 번호, 청크를 읽을 최대 크기 및 다운로드의 전체 크기 (알 수 없으면 -1). 처음에 한 번 호출되고 네트워크에서 각 데이터 청크를 읽은 후에 한 번씩 호출됩니다. 로컬 URL의 경우 <em>reporthook</em>은 무시됩니다.</p>
<p><em>url</em>이 <code class="file docutils literal notranslate"><span class="pre">http:</span></code> 스킴 식별자를 사용하면, <code class="docutils literal notranslate"><span class="pre">POST</span></code> 요청을 지정하기 위해 선택적 <em>data</em> 인자가 제공될 수 있습니다 (일반적으로 요청형은 <code class="docutils literal notranslate"><span class="pre">GET</span></code>입니다). <em>data</em> 인자는 표준 <em class="mimetype">application/x-www-form-urlencoded</em> 형식이어야 합니다; <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 함수를 참조하십시오.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.URLopener.version">
<code class="sig-name descname">version</code><a class="headerlink" href="#urllib.request.URLopener.version" title="정의 주소">¶</a></dt>
<dd><p>오프너 객체의 사용자 에이전트를 지정하는 변수. <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a>가 서버에 특정 사용자 에이전트임을 알리려면, 서브 클래스에서 클래스 변수로 설정하거나 생성자에서 베이스 생성자를 호출하기 전에 이를 설정하십시오.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="urllib.request.FancyURLopener">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">FancyURLopener</code><span class="sig-paren">(</span><em class="sig-param">...</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FancyURLopener" title="정의 주소">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지.</span></p>
</div>
<p><a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a>는 다음 HTTP 응답 코드에 대한 기본 처리를 제공하는 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> 서브 클래스입니다: 301, 302, 303, 307 및 401. 위에 나열된 30x 응답 코드의 경우, 실제 URL을 가져오는 데 <em class="mailheader">Location</em> 헤더가 사용됩니다. 401 응답 코드(authentication required - 인증 필요)의 경우, 기본 HTTP 인증이 수행됩니다. 30x 응답 코드의 경우, 재귀는 <em>maxtries</em> 어트리뷰트 값에 의해 제한되며, 기본값은 10입니다.</p>
<p>다른 모든 응답 코드의 경우, 에러를 적절하게 처리하기 위해 서브 클래스에서 재정의할 수 있는 메서드 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_default()</span></code>가 호출됩니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><span class="target" id="index-35"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a>의 편지(letter)에 따르면, POST 요청에 대한 301과 302 응답은 사용자의 확인 없이 자동으로 리디렉션 되지 않아야 합니다. 실제로는, 브라우저들이 POST를 GET으로 변경하여 이러한 응답의 자동 리디렉션을 허용하고, <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a>는 이 동작을 재현합니다.</p>
</div>
<p>생성자의 매개 변수는 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a>의 매개 변수와 같습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>기본 인증을 수행할 때, <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> 인스턴스는 <a class="reference internal" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="urllib.request.FancyURLopener.prompt_user_passwd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prompt_user_passwd()</span></code></a> 메서드를 호출합니다. 기본 구현은 사용자에게 제어 터미널에서 필요한 정보를 요청합니다. 필요하면 서브 클래스가 이 메서드를 재정의하여 더 적절한 동작을 지원할 수 있습니다.</p>
</div>
<p><a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> 클래스는 적절한 동작을 제공하기 위해 재정의되어야 하는 하나의 추가 메서드를 제공합니다:</p>
<dl class="method">
<dt id="urllib.request.FancyURLopener.prompt_user_passwd">
<code class="sig-name descname">prompt_user_passwd</code><span class="sig-paren">(</span><em class="sig-param">host</em>, <em class="sig-param">realm</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="정의 주소">¶</a></dt>
<dd><p>지정된 보안 영역(realm)의 지정된 호스트에서 사용자를 인증하는 데 필요한 정보를 반환합니다. 반환 값은 기본 인증에 사용될 수 있는 튜플 <code class="docutils literal notranslate"><span class="pre">(user,</span> <span class="pre">password)</span></code>여야 합니다.</p>
<p>구현은 터미널에서 이 정보를 요구합니다; 로컬 환경에서 적절한 상호 작용 모델을 사용하려면 응용 프로그램이 이 메서드를 재정의해야 합니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="urllib-request-restrictions">
<h2><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 제약 사항<a class="headerlink" href="#urllib-request-restrictions" title="제목 주소">¶</a></h2>
<blockquote>
<div></div></blockquote>
<ul id="index-11">
<li><p>현재, 다음과 같은 프로토콜만 지원됩니다: HTTP (버전 0.9와 1.0), FTP, 로컬 파일 및 데이터 URL.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>데이터 URL에 대한 지원이 추가되었습니다.</p>
</div>
</li>
<li><p><a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a>의 캐싱 기능은 누군가가 만료 시간 헤더의 적절한 처리를 해킹할 시간을 찾을 때까지 비활성화되었습니다.</p></li>
<li><p>특정 URL이 캐시에 있는지를 조회하는 함수가 있어야 합니다.</p></li>
<li><p>이전 버전과의 호환성을 위해, URL이 로컬 파일을 가리키는 것으로 보이지만 파일을 열 수 없으면, FTP 프로토콜을 사용하여 URL을 다시 해석합니다. 이로 인해 때때로 혼란스러운 에러 메시지가 발생할 수 있습니다.</p></li>
<li><p><a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>과 <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> 함수는 네트워크 연결이 이루어지기를 기다리는 동안 임의의 긴 지연을 유발할 수 있습니다. 이는 스레드를 사용하지 않고 이러한 함수를 사용하여 대화식 웹 클라이언트를 구축하기 어렵다는 것을 뜻합니다.</p>
</li>
<li id="index-12"><p><a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>이나 <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a>가 반환한 데이터는 서버가 반환한 원시 데이터입니다. 바이너리 데이터 (가령 이미지), 평문 텍스트 또는 (예를 들어) HTML일 수 있습니다. HTTP 프로토콜은 응답 헤더에 유형 정보를 제공하는데, <em class="mailheader">Content-Type</em> 헤더를 통해 검사할 수 있습니다. 반환된 데이터가 HTML이면, <a class="reference internal" href="html.parser.html#module-html.parser" title="html.parser: A simple parser that can handle HTML and XHTML."><code class="xref py py-mod docutils literal notranslate"><span class="pre">html.parser</span></code></a> 모듈을 사용하여 구문 분석할 수 있습니다.</p>
</li>
<li id="index-13"><p>FTP 프로토콜을 처리하는 코드는 파일과 디렉터리를 구별할 수 없습니다. 이는 액세스 할 수 없는 파일을 가리키는 URL을 읽으려고 할 때 예기치 않은 동작을 일으킬 수 있습니다. URL이 <code class="docutils literal notranslate"><span class="pre">/</span></code>로 끝나면, 디렉터리를 참조하는 것으로 간주하고 그에 따라 처리됩니다. 그러나 파일을 읽으려는 시도가 550 에러를 일으키면 (URL을 찾을 수 없거나 액세스할 수 없다는 뜻인데, 종종 권한 문제입니다), URL이 디렉터리를 지정하지만, 후행 <code class="docutils literal notranslate"><span class="pre">/</span></code>를 붙이지 않은 경우를 처리하기 위해 경로가 디렉터리로 처리됩니다. 이는 읽기 권한이 액세스할 수 없도록 지정된 파일을 가져오려고 시도할 때 잘못된 결과를 만들 수 있도록 합니다; FTP 코드가 이를 읽으려고 시도하고, 550 에러로 실패한 다음, 읽을 수 없는 파일에 대해 디렉터리 리스팅을 수행합니다. 세밀한 제어가 필요하면, <a class="reference internal" href="ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a> 모듈 사용, <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> 서브 클래싱 또는 필요에 맞게 <em>_urlopener</em>를 변경하는 것을 고려하십시오.</p></li>
</ul>
</div>
</div>
<div class="section" id="module-urllib.response">
<span id="urllib-response-response-classes-used-by-urllib"></span><h1><a class="reference internal" href="#module-urllib.response" title="urllib.response: Response classes used by urllib."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code></a> --- urllib가 사용하는 응답 클래스<a class="headerlink" href="#module-urllib.response" title="제목 주소">¶</a></h1>
<p>The <a class="reference internal" href="#module-urllib.response" title="urllib.response: Response classes used by urllib."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code></a> module defines functions and classes which define a
minimal file-like interface, including <code class="docutils literal notranslate"><span class="pre">read()</span></code> and <code class="docutils literal notranslate"><span class="pre">readline()</span></code>.
Functions defined by this module are used internally by the <a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> module.
The typical response object is a <a class="reference internal" href="#urllib.response.addinfourl" title="urllib.response.addinfourl"><code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code></a> instance:</p>
<dl class="class">
<dt id="urllib.response.addinfourl">
<em class="property">class </em><code class="sig-prename descclassname">urllib.response.</code><code class="sig-name descname">addinfourl</code><a class="headerlink" href="#urllib.response.addinfourl" title="정의 주소">¶</a></dt>
<dd><dl class="attribute">
<dt id="urllib.response.addinfourl.url">
<code class="sig-name descname">url</code><a class="headerlink" href="#urllib.response.addinfourl.url" title="정의 주소">¶</a></dt>
<dd><p>가져온 자원의 URL, 일반적으로 리디렉션을 따라갔는지 판별하는 데 사용됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.response.addinfourl.headers">
<code class="sig-name descname">headers</code><a class="headerlink" href="#urllib.response.addinfourl.headers" title="정의 주소">¶</a></dt>
<dd><p>Returns the headers of the response in the form of an <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.response.addinfourl.status">
<code class="sig-name descname">status</code><a class="headerlink" href="#urllib.response.addinfourl.status" title="정의 주소">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
<p>Status code returned by server.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.response.addinfourl.geturl">
<code class="sig-name descname">geturl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.response.addinfourl.geturl" title="정의 주소">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span>Deprecated in favor of <a class="reference internal" href="#urllib.response.addinfourl.url" title="urllib.response.addinfourl.url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">url</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.response.addinfourl.info">
<code class="sig-name descname">info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.response.addinfourl.info" title="정의 주소">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span>Deprecated in favor of <a class="reference internal" href="#urllib.response.addinfourl.headers" title="urllib.response.addinfourl.headers"><code class="xref py py-attr docutils literal notranslate"><span class="pre">headers</span></code></a>.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="urllib.response.addinfourl.code">
<code class="sig-name descname">code</code><a class="headerlink" href="#urllib.response.addinfourl.code" title="정의 주소">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span>Deprecated in favor of <a class="reference internal" href="#urllib.response.addinfourl.status" title="urllib.response.addinfourl.status"><code class="xref py py-attr docutils literal notranslate"><span class="pre">status</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.response.addinfourl.getstatus">
<code class="sig-name descname">getstatus</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.response.addinfourl.getstatus" title="정의 주소">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span>Deprecated in favor of <a class="reference internal" href="#urllib.response.addinfourl.status" title="urllib.response.addinfourl.status"><code class="xref py py-attr docutils literal notranslate"><span class="pre">status</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> --- URL을 열기 위한 확장 가능한 라이브러리</a><ul>
<li><a class="reference internal" href="#request-objects">Request 객체</a></li>
<li><a class="reference internal" href="#openerdirector-objects">OpenerDirector 객체</a></li>
<li><a class="reference internal" href="#basehandler-objects">BaseHandler 객체</a></li>
<li><a class="reference internal" href="#httpredirecthandler-objects">HTTPRedirectHandler 객체</a></li>
<li><a class="reference internal" href="#httpcookieprocessor-objects">HTTPCookieProcessor 객체</a></li>
<li><a class="reference internal" href="#proxyhandler-objects">ProxyHandler 객체</a></li>
<li><a class="reference internal" href="#httppasswordmgr-objects">HTTPPasswordMgr 객체</a></li>
<li><a class="reference internal" href="#httppasswordmgrwithpriorauth-objects">HTTPPasswordMgrWithPriorAuth 객체</a></li>
<li><a class="reference internal" href="#abstractbasicauthhandler-objects">AbstractBasicAuthHandler 객체</a></li>
<li><a class="reference internal" href="#httpbasicauthhandler-objects">HTTPBasicAuthHandler 객체</a></li>
<li><a class="reference internal" href="#proxybasicauthhandler-objects">ProxyBasicAuthHandler 객체</a></li>
<li><a class="reference internal" href="#abstractdigestauthhandler-objects">AbstractDigestAuthHandler 객체</a></li>
<li><a class="reference internal" href="#httpdigestauthhandler-objects">HTTPDigestAuthHandler 객체</a></li>
<li><a class="reference internal" href="#proxydigestauthhandler-objects">ProxyDigestAuthHandler 객체</a></li>
<li><a class="reference internal" href="#httphandler-objects">HTTPHandler 객체</a></li>
<li><a class="reference internal" href="#httpshandler-objects">HTTPSHandler 객체</a></li>
<li><a class="reference internal" href="#filehandler-objects">FileHandler 객체</a></li>
<li><a class="reference internal" href="#datahandler-objects">DataHandler 객체</a></li>
<li><a class="reference internal" href="#ftphandler-objects">FTPHandler 객체</a></li>
<li><a class="reference internal" href="#cacheftphandler-objects">CacheFTPHandler 객체</a></li>
<li><a class="reference internal" href="#unknownhandler-objects">UnknownHandler 객체</a></li>
<li><a class="reference internal" href="#httperrorprocessor-objects">HTTPErrorProcessor 객체</a></li>
<li><a class="reference internal" href="#examples">예</a></li>
<li><a class="reference internal" href="#legacy-interface">레거시 인터페이스</a></li>
<li><a class="reference internal" href="#urllib-request-restrictions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> 제약 사항</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-urllib.response"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code> --- urllib가 사용하는 응답 클래스</a></li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="urllib.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code> --- URL 처리 모듈</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="urllib.parse.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code> --- URL을 구성 요소로 구문 분석</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="urllib.parse --- URL을 구성 요소로 구문 분석"
             >다음</a> |</li>
        <li class="right" >
          <a href="urllib.html" title="urllib --- URL 처리 모듈"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>