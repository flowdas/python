
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>urllib.request --- URL을 열기 위한 확장 가능한 라이브러리 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="urllib.parse --- URL을 구성 요소로 구문 분석" href="urllib.parse.html" />
    <link rel="prev" title="urllib --- URL 처리 모듈" href="urllib.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/urllib.request.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="urllib.parse --- URL을 구성 요소로 구문 분석"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="urllib.html" title="urllib --- URL 처리 모듈"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-urllib.request">
<span id="urllib-request-extensible-library-for-opening-urls"></span><h1><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> --- URL을 열기 위한 확장 가능한 라이브러리<a class="headerlink" href="#module-urllib.request" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/urllib/request.py">Lib/urllib/request.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 모듈은 복잡한 세계에서 URL(대부분 HTTP)을 여는 데 도움이 되는 함수와 클래스를 정의합니다 --- 기본(basic)과 다이제스트 인증, 리디렉션, 쿠키 등.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>더 고수준 HTTP 클라이언트 인터페이스로 <a class="reference external" href="https://requests.readthedocs.io/en/master/">Requests 패키지</a>를 권장합니다.</p>
</div>
<p><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 모듈은 다음 함수를 정의합니다:</p>
<dl class="function">
<dt id="urllib.request.urlopen">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">urlopen</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">data=None</em>, <span class="optional">[</span><em class="sig-param">timeout</em>, <span class="optional">]</span><em class="sig-param">*</em>, <em class="sig-param">cafile=None</em>, <em class="sig-param">capath=None</em>, <em class="sig-param">cadefault=False</em>, <em class="sig-param">context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlopen" title="정의 주소">¶</a></dt>
<dd><p>문자열이나 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체일 수 있는, URL <em>url</em>을 엽니다.</p>
<p><em>data</em>는 서버로 전송할 추가 데이터를 지정하는 객체이거나, 그러한 데이터가 필요하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이어야 합니다. 자세한 내용은 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>를 참조하십시오.</p>
<p>urllib.request 모듈은 HTTP/1.1을 사용하고 HTTP 요청에 <code class="docutils literal notranslate"><span class="pre">Connection:close</span></code> 헤더를 포함합니다.</p>
<p>선택적 <em>timeout</em> 매개 변수는 연결 시도와 같은 연산을 블로킹하기 위한 시간제한을 초 단위로 지정합니다 (지정하지 않으면 전역 기본 시간제한 설정이 사용됩니다). 이것은 실제로는 HTTP, HTTPS 및 FTP 연결에서만 작동합니다.</p>
<p><em>context</em>가 지정되면, 다양한 SSL 옵션을 기술하는 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 인스턴스이어야 합니다. 자세한 내용은 <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSConnection</span></code></a>을 참조하십시오.</p>
<p>선택적 <em>cafile</em>과 <em>capath</em> 매개 변수는 HTTPS 요청을 위한 신뢰할 수 있는 CA 인증서 집합을 지정합니다. <em>cafile</em>은 CA 인증서 번들을 포함하는 단일 파일을 가리켜야 하지만, <em>capath</em>는 해시 된 인증서 파일의 디렉터리를 가리켜야 합니다. 자세한 정보는 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_verify_locations()</span></code></a>에서 찾을 수 있습니다.</p>
<p><em>cadefault</em> 매개 변수는 무시됩니다.</p>
<p>이 함수는 항상 <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">컨텍스트 관리자</span></a>로 작동할 수 있는 객체를 반환하며 다음과 같은 메서드가 있습니다</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">geturl()</span></code> --- 가져온 자원의 URL을 반환하며, 일반적으로 리디렉션을 따라갔는지 판별하는 데 사용됩니다</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code> --- 헤더와 같은 페이지의 메타 정보를 <a class="reference internal" href="email.parser.html#email.message_from_string" title="email.message_from_string"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.message_from_string()</span></code></a> 인스턴스 형태로 반환합니다 (<a class="reference external" href="http://jkorpela.fi/http.html">Quick Reference to HTTP Headers</a>를 참조하십시오)</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">getcode()</span></code> -- 응답의 HTTP 상태 코드를 반환합니다.</p></li>
</ul>
<p>HTTP 및 HTTPS URL의 경우, 이 함수는 약간 수정된 <a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.client.HTTPResponse</span></code></a> 객체를 반환합니다. 위의 세 가지 새로운 메서드 외에도, msg 어트리뷰트에는 <a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPResponse</span></code></a> 설명서에 지정된 대로 응답 헤더 대신 <a class="reference internal" href="http.client.html#http.client.HTTPResponse.reason" title="http.client.HTTPResponse.reason"><code class="xref py py-attr docutils literal notranslate"><span class="pre">reason</span></code></a> 어트리뷰트와 --- 서버가 반환한 이유 문구 --- 같은 정보가 포함됩니다.</p>
<p>FTP, 파일 및 데이터 URL과 레거시 <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a>와 <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> 클래스에서 명시적으로 처리된 요청의 경우, 이 함수는 <code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code> 객체를 반환합니다.</p>
<p>프로토콜 에러 시 <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>를 발생시킵니다.</p>
<p>아무런 처리기도 요청을 처리하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환될 수 있습니다 (기본 설치된 전역 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>는 <a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnknownHandler</span></code></a>를 사용하여 이러한 상황이 발생하지 않도록 합니다).</p>
<p>또한, 프락시 설정이 감지되면 (예를 들어, <span class="target" id="index-22"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">http_proxy</span></code>와 같은 <code class="docutils literal notranslate"><span class="pre">*_proxy</span></code> 환경 변수가 설정될 때), <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a>가 기본적으로 설치되어 프락시를 통해 요청이 처리되도록 합니다.</p>
<p>파이썬 2.6 및 이전 버전의 레거시 <code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code> 함수는 중단되었습니다; <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.request.urlopen()</span></code></a>는 이전 <code class="docutils literal notranslate"><span class="pre">urllib2.urlopen</span></code>에 해당합니다. 딕셔너리 매개 변수를 <code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code>에 전달하여 수행되었던 프락시 처리는 <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> 객체를 사용하여 얻을 수 있습니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">fullurl</span></code>, <code class="docutils literal notranslate"><span class="pre">data</span></code>, <code class="docutils literal notranslate"><span class="pre">headers</span></code>, <code class="docutils literal notranslate"><span class="pre">method</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">urllib.Request</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>cafile</em>과 <em>capath</em>가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>가능하다면 (즉, <a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal notranslate"><span class="pre">ssl.HAS_SNI</span></code></a>가 참이라면) HTTPS 가상 호스트가 지원됩니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가: </span><em>data</em>는 이터러블 객체일 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><em>cadefault</em>가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4.3에서 변경: </span><em>context</em>가 추가되었습니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.6부터 폐지: </span><em>cafile</em>, <em>capath</em> 및 <em>cadefault</em>는 폐지되어 <em>context</em>로 대체되었습니다. 대신 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a>을 사용하거나, <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>가 시스템의 신뢰할 수 있는 CA 인증서를 선택하도록 하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.request.install_opener">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">install_opener</code><span class="sig-paren">(</span><em class="sig-param">opener</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.install_opener" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 인스턴스를 기본 전역 오프너로 설치합니다. 오프너 설치는 urlopen이 해당 오프너를 사용하도록 하려는 경우에만 필요합니다; 그렇지 않으면 단순히 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 대신 <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.open()</span></code></a>을 호출하십시오. 코드는 실제 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>를 확인하지 않으며, 적절한 인터페이스를 가진 클래스면 모두 작동합니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.build_opener">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">build_opener</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">handler</em>, <em class="sig-param">...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.build_opener" title="정의 주소">¶</a></dt>
<dd><p>주어진 순서대로 처리기를 연결하는 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 인스턴스를 반환합니다. <em>handler</em>는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>의 인스턴스이거나 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>의 서브 클래스(이 경우 매개 변수 없이 생성자를 호출할 수 있어야 합니다)일 수 있습니다. 다음과 같은 클래스들의 인스턴스는 <em>handler</em>에 그들, 그들의 인스턴스 또는 그들의 서브 클래스가 포함되지 않는 한 <em>handler</em> 앞에 있습니다: <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> (프락시 설정이 감지되는 경우), <a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnknownHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPHandler" title="urllib.request.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler" title="urllib.request.HTTPDefaultErrorHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPDefaultErrorHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPRedirectHandler" title="urllib.request.HTTPRedirectHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPRedirectHandler</span></code></a>, <a class="reference internal" href="#urllib.request.FTPHandler" title="urllib.request.FTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FTPHandler</span></code></a>, <a class="reference internal" href="#urllib.request.FileHandler" title="urllib.request.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPErrorProcessor" title="urllib.request.HTTPErrorProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPErrorProcessor</span></code></a>.</p>
<p>파이썬 설치에 SSL 지원이 있으면 (즉, <a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 모듈을 임포트 할 수 있으면) <a class="reference internal" href="#urllib.request.HTTPSHandler" title="urllib.request.HTTPSHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSHandler</span></code></a>도 추가됩니다.</p>
<p><a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 서브 클래스는 또한 <code class="xref py py-attr docutils literal notranslate"><span class="pre">handler_order</span></code> 어트리뷰트를 변경하여 처리기 리스트에서 자신의 위치를 수정할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.pathname2url">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">pathname2url</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.pathname2url" title="정의 주소">¶</a></dt>
<dd><p>경로명 <em>path</em>를 경로의 로컬 구문에서 URL의 경로 구성 요소에 사용된 형식으로 변환합니다. 완전한 URL을 생성하지는 않습니다. 반환 값은 <a class="reference internal" href="urllib.parse.html#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a> 함수를 사용하여 이미 인용되었습니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.url2pathname">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">url2pathname</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.url2pathname" title="정의 주소">¶</a></dt>
<dd><p>경로 구성 요소 <em>path</em>를 퍼센트 인코딩된 URL에서 경로의 로컬 구문으로 변환합니다. 완전한 URL을 받아들이지 않습니다. 이 함수는 <a class="reference internal" href="urllib.parse.html#urllib.parse.unquote" title="urllib.parse.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">unquote()</span></code></a>를 사용하여 <em>path</em>를 디코딩합니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.getproxies">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">getproxies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.getproxies" title="정의 주소">¶</a></dt>
<dd><p>이 도우미 함수는 스킴에서 프락시 서버 URL로 매핑하는 딕셔너리를 반환합니다. 먼저 모든 운영 체제에서 대소 문자를 구분하지 않는 방식으로 <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;_proxy</span></code>라는 변수를 환경에서 스캔하고, 찾을 수 없으면 맥 OS X의 맥 OSX 시스템 구성과 윈도우의 윈도우 시스템 레지스트리에서 프락시 정보를 찾습니다. 소문자와 대문자 환경 변수가 모두 존재하면 (그리고 다른 값을 가지면), 소문자가 선호됩니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>일반적으로 스크립트가 CGI 환경에서 실행 중임을 나타내는 환경 변수 <code class="docutils literal notranslate"><span class="pre">REQUEST_METHOD</span></code>가 설정되면, 환경 변수 <code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code>(대문자 <code class="docutils literal notranslate"><span class="pre">_PROXY</span></code>)는 무시됩니다. 이 변수는 &quot;Proxy:&quot; HTTP 헤더를 사용하여 클라이언트가 주입할 수 있기 때문입니다. CGI 환경에서 HTTP 프락시를 사용해야 하면, <code class="docutils literal notranslate"><span class="pre">ProxyHandler</span></code>를 명시적으로 사용하거나 변수 이름이 소문자(또는 적어도 <code class="docutils literal notranslate"><span class="pre">_proxy</span></code> 접미사)가 되도록 하십시오.</p>
</div>
</dd></dl>

<p>다음과 같은 클래스가 제공됩니다:</p>
<dl class="class">
<dt id="urllib.request.Request">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">Request</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">data=None</em>, <em class="sig-param">headers={}</em>, <em class="sig-param">origin_req_host=None</em>, <em class="sig-param">unverifiable=False</em>, <em class="sig-param">method=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 URL 요청의 추상화입니다.</p>
<p><em>url</em>은 유효한 URL을 포함하는 문자열이어야 합니다.</p>
<p><em>data</em>는 서버로 전송할 추가 데이터를 지정하는 객체이거나, 그러한 데이터가 필요하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이어야 합니다. 현재 HTTP 요청은 <em>data</em>를 사용하는 유일한 요청입니다. 지원되는 객체 형에는 바이트열, 파일류 객체 및 바이트열류 객체의 이터러블이 포함됩니다. <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code>와 <code class="docutils literal notranslate"><span class="pre">Transfer-Encoding</span></code> 헤더 필드가 모두 제공되지 않으면, <a class="reference internal" href="#urllib.request.HTTPHandler" title="urllib.request.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a>는 <em>data</em>의 형에 따라 이러한 헤더를 설정합니다. <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code>는 바이트열 객체를 보내는 데 사용되는 반면, <span class="target" id="index-23"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7230.html"><strong>RFC 7230</strong></a>, 섹션 3.3.1에 지정된 <code class="docutils literal notranslate"><span class="pre">Transfer-Encoding:</span> <span class="pre">chunked</span></code>는 파일과 다른 이터러블을 보내는 데 사용됩니다.</p>
<p>HTTP POST 요청 메서드의 경우, <em>data</em>는 표준 <em class="mimetype">application/x-www-form-urlencoded</em> 형식의 버퍼여야 합니다. <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 함수는 매핑이나 2-튜플의 시퀀스를 취하고 이 형식의 ASCII 문자열을 반환합니다. <em>data</em> 매개 변수로 사용되기 전에 바이트열로 인코딩되어야 합니다.</p>
<p><em>headers</em>는 딕셔너리이어야 하며, 각 키와 값을 인자로 사용하여 <a class="reference internal" href="#urllib.request.Request.add_header" title="urllib.request.Request.add_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_header()</span></code></a>가 호출된 것처럼 처리됩니다. 이것은 종종 브라우저가 자신을 식별하는 데 사용하는 <code class="docutils literal notranslate"><span class="pre">User-Agent</span></code> 헤더 값을 &quot;스푸핑&quot; 하는 데 사용됩니다 -- 일부 HTTP 서버는 스크립트가 아닌 일반 브라우저에서 오는 요청만 허용합니다. 예를 들어, Mozilla Firefox는 자신을 <code class="docutils literal notranslate"><span class="pre">&quot;Mozilla/5.0</span> <span class="pre">(X11;</span> <span class="pre">U;</span> <span class="pre">Linux</span> <span class="pre">i686)</span> <span class="pre">Gecko/20071127</span> <span class="pre">Firefox/2.0.0.11&quot;</span></code>로 식별하는 반면, <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a>의 기본 사용자 에이전트 문자열은 <code class="docutils literal notranslate"><span class="pre">&quot;Python-urllib/2.6&quot;</span></code> (파이썬 2.6에서) 입니다.</p>
<p><em>data</em> 인자가 있으면 적절한 <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> 헤더가 포함되어야 합니다. 이 헤더가 제공되지 않고 <em>data</em>가 None이 아니면, <code class="docutils literal notranslate"><span class="pre">Content-Type:</span> <span class="pre">application/x-www-form-urlencoded</span></code>가 기본값으로 추가됩니다.</p>
<p>다음 두 인자는 제삼자 HTTP 쿠키를 올바르게 처리하는 데에만 관심이 있습니다:</p>
<p><em>origin_req_host</em>는 <span class="target" id="index-24"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2965.html"><strong>RFC 2965</strong></a>에 의해 정의된 대로 오리진 트랜잭션의 요청 호스트여야 합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">http.cookiejar.request_host(self)</span></code>입니다. 이것은 사용자가 시작한 원래 요청의 호스트 이름이나 IP 주소입니다. 예를 들어, HTML 문서의 이미지에 대한 요청이면, 이미지가 포함된 페이지에 대한 요청의 요청 호스트여야 합니다.</p>
<p><em>unverifiable</em>은 <span class="target" id="index-25"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2965.html"><strong>RFC 2965</strong></a>에서 정의한 대로 요청을 확인할 수 없는지를 표시해야 합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code>입니다. 확인할 수 없는 요청은 사용자에게 URL에 대한 승인 옵션이 없는 요청입니다. 예를 들어, HTML 문서의 이미지에 대한 요청이고, 사용자에게 이미지의 자동 가져오기를 승인할 수 있는 옵션이 없으면, 이것은 참이어야 합니다.</p>
<p><em>method</em>는 사용될 HTTP 요청 메서드를 나타내는 문자열이어야 합니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">'HEAD'</span></code>). 제공되면, 해당 값은 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code></a> 어트리뷰트에 저장되고 <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a>에서 사용됩니다. 기본값은 <em>data</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면 <code class="docutils literal notranslate"><span class="pre">'GET'</span></code>이고, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">'POST'</span></code>입니다. 서브 클래스는 클래스 자체에서 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code></a> 어트리뷰트를 설정하여 다른 기본 메서드를 나타낼 수 있습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>data 객체가 콘텐츠를 두 번 이상 (예를 들어 콘텐츠를 한 번만 생성 할 수 있는 파일이나 이터러블) 전달할 수 없고 요청이 HTTP 리디렉션이나 인증을 위해 재시도되는 경우, 요청이 예상대로 작동하지 않습니다. <em>data</em>는 헤더 바로 다음에 HTTP 서버로 전송됩니다. 라이브러리에서 100-continue 예상(expectation)을 지원하지 않습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a> 인자가 Request 클래스에 추가됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>클래스 수준에서 기본 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a>를 지정할 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="docutils literal notranslate"><span class="pre">Content-Length</span></code>가 제공되지 않고 <em>data</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이나 바이트열 객체가 아닐 때 에러를 발생시키지 앖습니다. 대신 청크 전송 인코딩(chunked transfer encoding)으로 폴백 합니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.OpenerDirector">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">OpenerDirector</code><a class="headerlink" href="#urllib.request.OpenerDirector" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 클래스는 서로 연결된 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>들을 통해 URL을 엽니다. 처리기 연결과 에러 복구를 관리합니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.BaseHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">BaseHandler</code><a class="headerlink" href="#urllib.request.BaseHandler" title="정의 주소">¶</a></dt>
<dd><p>이것은 등록된 모든 처리기의 베이스 클래스이며 --- 간단한 등록 메커니즘만 처리합니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPDefaultErrorHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPDefaultErrorHandler</code><a class="headerlink" href="#urllib.request.HTTPDefaultErrorHandler" title="정의 주소">¶</a></dt>
<dd><p>HTTP 에러 응답에 대한 기본 처리기를 정의하는 클래스; 모든 응답은 <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> 예외로 바뀝니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPRedirectHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPRedirectHandler</code><a class="headerlink" href="#urllib.request.HTTPRedirectHandler" title="정의 주소">¶</a></dt>
<dd><p>리디렉션을 처리하는 클래스.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPCookieProcessor">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPCookieProcessor</code><span class="sig-paren">(</span><em class="sig-param">cookiejar=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPCookieProcessor" title="정의 주소">¶</a></dt>
<dd><p>HTTP 쿠키를 처리하는 클래스.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">ProxyHandler</code><span class="sig-paren">(</span><em class="sig-param">proxies=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyHandler" title="정의 주소">¶</a></dt>
<dd><p>요청이 프락시를 거치게 합니다. <em>proxies</em>가 제공되면, 프로토콜 이름을 프락시 URL로 매핑하는 딕셔너리여야 합니다. 기본값은 환경 변수 <code class="docutils literal notranslate"><span class="pre">&lt;protocol&gt;_proxy</span></code>에서 프락시 목록을 읽는 것입니다. 프락시 환경 변수가 설정되어 있지 않으면, 윈도우 환경에서는 레지스트리의 인터넷 설정 섹션에서 프락시 설정을 가져오고, 맥 OS X 환경에서는 프락시 정보를 OS X 시스템 구성 프레임워크에서 가져옵니다.</p>
<p>자동 감지 프락시를 비활성화하려면 빈 딕셔너리를 전달하십시오.</p>
<p><span class="target" id="index-26"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">no_proxy</span></code> 환경 변수를 사용하여 프락시를 통해 도달해서는 안 되는 호스트를 지정할 수 있습니다; 설정되면, 쉼표로 구분된 호스트 이름 접미사의 목록이어야 하며, 선택적으로 <code class="docutils literal notranslate"><span class="pre">:port</span></code>가 추가됩니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">cern.ch,ncsa.uiuc.edu,some.host:8080</span></code>.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">참고</p>
<p>변수 <code class="docutils literal notranslate"><span class="pre">REQUEST_METHOD</span></code>가 설정되면 <code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code>는 무시됩니다; <a class="reference internal" href="#urllib.request.getproxies" title="urllib.request.getproxies"><code class="xref py py-func docutils literal notranslate"><span class="pre">getproxies()</span></code></a>의 설명서를 참조하십시오.</p>
</div>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPPasswordMgr">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPPasswordMgr</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgr" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></code> 매핑 데이터베이스를 유지합니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPPasswordMgrWithDefaultRealm">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPPasswordMgrWithDefaultRealm</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></code> 매핑 데이터베이스를 유지합니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> realm은 포괄(catch-all) 영역으로 간주하며 다른 영역에 맞지 않으면 검색됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPPasswordMgrWithPriorAuth</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">uri</span> <span class="pre">-&gt;</span> <span class="pre">is_authenticated</span></code> 매핑 데이터베이스도 포함하는 <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a>의 변형. BasicAuth 처리기에서 <code class="docutils literal notranslate"><span class="pre">401</span></code> 응답을 먼저 기다리는 대신 인증 자격 증명을 언제 보낼 것인지 결정하는 데 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.AbstractBasicAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">AbstractBasicAuthHandler</code><span class="sig-paren">(</span><em class="sig-param">password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler" title="정의 주소">¶</a></dt>
<dd><p>원격 호스트와 프락시 모두에서 HTTP 인증을 돕는 믹스인 클래스입니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr Objects</span></a>를 참조하십시오. <em>passwd_mgr</em>이 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code>와 <code class="docutils literal notranslate"><span class="pre">update_authenticated</span></code> 메서드도 제공하면 (<a class="reference internal" href="#http-password-mgr-with-prior-auth"><span class="std std-ref">HTTPPasswordMgrWithPriorAuth Objects</span></a>를 참조하십시오), 처리기는 지정된 URI에 대해 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 결과를 사용하여 요청과 함께 인증 자격 증명을 보낼지를 판별합니다. <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code>가 URI에 대해 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환하면, 자격 증명이 전송됩니다. <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, 자격 증명이 전송되지 않으며, 그런 다음 <code class="docutils literal notranslate"><span class="pre">401</span></code> 응답이 수신되면 요청이 인증 자격 증명과 함께 다시 전송됩니다. 인증이 성공하면, 이 URI에 대해 <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code>를 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정하기 위해 <code class="docutils literal notranslate"><span class="pre">update_authenticated</span></code>가 호출되어서, 이 URI나 모든 슈퍼 URI에 대한 후속 요청에 인증 자격 증명이 자동으로 포함됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가: </span><code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPBasicAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPBasicAuthHandler</code><span class="sig-paren">(</span><em class="sig-param">password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler" title="정의 주소">¶</a></dt>
<dd><p>원격 호스트와의 인증을 처리합니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr Objects</span></a>를 참조하십시오. 잘못된 인증 스킴(Authentication scheme)을 제시하면 HTTPBasicAuthHandler 가 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyBasicAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">ProxyBasicAuthHandler</code><span class="sig-paren">(</span><em class="sig-param">password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler" title="정의 주소">¶</a></dt>
<dd><p>프락시와의 인증을 처리합니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr Objects</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.AbstractDigestAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">AbstractDigestAuthHandler</code><span class="sig-paren">(</span><em class="sig-param">password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler" title="정의 주소">¶</a></dt>
<dd><p>원격 호스트와 프락시 모두에서 HTTP 인증을 돕는 믹스인 클래스입니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr Objects</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPDigestAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPDigestAuthHandler</code><span class="sig-paren">(</span><em class="sig-param">password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler" title="정의 주소">¶</a></dt>
<dd><p>원격 호스트와의 인증을 처리합니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr Objects</span></a>를 참조하십시오. 다이제스트 인증 처리기와 기본 인증 처리기가 모두 추가되면, 다이제스트 인증이 항상 먼저 시도됩니다. 다이제스트 인증이 다시 40x 응답을 반환하면, 기본 인증 처리기로 보내 처리됩니다. 이 처리기 메서드는 Digest나 Basic 이외의 인증 스킴(authentication scheme)이 제공될 때 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>지원되지 않는 인증 스킴에 대해 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyDigestAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">ProxyDigestAuthHandler</code><span class="sig-paren">(</span><em class="sig-param">password_mgr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler" title="정의 주소">¶</a></dt>
<dd><p>프락시와의 인증을 처리합니다. <em>password_mgr</em>이 주어지면 <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> 과 호환되는 것이어야 합니다; 지원해야 하는 인터페이스에 대한 정보는 섹션 <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr Objects</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPHandler</code><a class="headerlink" href="#urllib.request.HTTPHandler" title="정의 주소">¶</a></dt>
<dd><p>HTTP URL 열기를 처리하는 클래스.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPSHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPSHandler</code><span class="sig-paren">(</span><em class="sig-param">debuglevel=0</em>, <em class="sig-param">context=None</em>, <em class="sig-param">check_hostname=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPSHandler" title="정의 주소">¶</a></dt>
<dd><p>HTTPS URL 열기를 처리하는 클래스. <em>context</em>와 <em>check_hostname</em>은 <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.client.HTTPSConnection</span></code></a>과 같은 의미입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>context</em>와 <em>check_hostname</em>이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.FileHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">FileHandler</code><a class="headerlink" href="#urllib.request.FileHandler" title="정의 주소">¶</a></dt>
<dd><p>로컬 파일을 엽니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.DataHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">DataHandler</code><a class="headerlink" href="#urllib.request.DataHandler" title="정의 주소">¶</a></dt>
<dd><p>데이터 URL을 엽니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.FTPHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">FTPHandler</code><a class="headerlink" href="#urllib.request.FTPHandler" title="정의 주소">¶</a></dt>
<dd><p>FTP URL을 엽니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.CacheFTPHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">CacheFTPHandler</code><a class="headerlink" href="#urllib.request.CacheFTPHandler" title="정의 주소">¶</a></dt>
<dd><p>지연 시간을 최소화하기 위해 열린 FTP 연결의 캐시를 유지하면서, FTP URL을 엽니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.UnknownHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">UnknownHandler</code><a class="headerlink" href="#urllib.request.UnknownHandler" title="정의 주소">¶</a></dt>
<dd><p>알 수 없는 URL을 처리하기 위한 포괄적인(catch-all) 클래스.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPErrorProcessor">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPErrorProcessor</code><a class="headerlink" href="#urllib.request.HTTPErrorProcessor" title="정의 주소">¶</a></dt>
<dd><p>HTTP 에러 응답을 처리합니다.</p>
</dd></dl>

<div class="section" id="request-objects">
<span id="id1"></span><h2>Request 객체<a class="headerlink" href="#request-objects" title="제목 주소">¶</a></h2>
<p>다음 메서드는 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>의 공용 인터페이스를 설명하므로, 서브 클래스에서 모두 재정의될 수 있습니다. 또한 클라이언트가 구문 분석된 요청을 검사하는 데 사용할 수 있는 몇 가지 공용 어트리뷰트를 정의합니다.</p>
<dl class="attribute">
<dt id="urllib.request.Request.full_url">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">full_url</code><a class="headerlink" href="#urllib.request.Request.full_url" title="정의 주소">¶</a></dt>
<dd><p>생성자에 전달된 원래 URL.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경.</span></p>
</div>
<p>Request.full_url은 setter, getter 및 deleter가 있는 프로퍼티입니다. <a class="reference internal" href="#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">full_url</span></code></a>을 읽으면 프래그먼트가 있는 원래 요청 URL을 반환합니다 (있다면).</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.type">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">type</code><a class="headerlink" href="#urllib.request.Request.type" title="정의 주소">¶</a></dt>
<dd><p>URI 스킴.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.host">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">host</code><a class="headerlink" href="#urllib.request.Request.host" title="정의 주소">¶</a></dt>
<dd><p>URI 주체(authority), 일반적으로 호스트이지만 콜론으로 구분된 포트를 포함할 수도 있습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.origin_req_host">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">origin_req_host</code><a class="headerlink" href="#urllib.request.Request.origin_req_host" title="정의 주소">¶</a></dt>
<dd><p>포트가 없는, 요청의 원래 호스트.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.selector">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">selector</code><a class="headerlink" href="#urllib.request.Request.selector" title="정의 주소">¶</a></dt>
<dd><p>URI 경로. <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>가 프락시를 사용하면, selector는 프락시로 전달되는 전체 URL이 됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.data">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">data</code><a class="headerlink" href="#urllib.request.Request.data" title="정의 주소">¶</a></dt>
<dd><p>요청의 엔터티 바디, 또는 지정되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.data</span></code></a>의 값을 변경하면 이제 &quot;Content-Length&quot; 헤더가 이전에 설정되거나 계산되었다면 삭제됩니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.unverifiable">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">unverifiable</code><a class="headerlink" href="#urllib.request.Request.unverifiable" title="정의 주소">¶</a></dt>
<dd><p>불리언, <span class="target" id="index-27"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2965.html"><strong>RFC 2965</strong></a>에서 정의한 대로 요청을 확인할 수 없는지를 나타냅니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.Request.method">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">method</code><a class="headerlink" href="#urllib.request.Request.method" title="정의 주소">¶</a></dt>
<dd><p>사용할 HTTP 요청 메서드. 기본적으로 값은 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>입니다. 이는 <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a>가 사용될 메서드의 일반적인 계산을 수행함을 뜻합니다. <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 서브 클래스의 클래스 수준에서 값을 설정해서 기본값을 제공하거나, <em>method</em> 인자를 통해 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 생성자에 값을 전달하여 값을 설정할 수 있습니다 (그래서 <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a>의 기본 계산을 무시합니다).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>서브 클래스에서 이제 기본값을 설정할 수 있습니다; 이전에는 생성자 인자를 통해서만 설정할 수 있었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_method">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">get_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_method" title="정의 주소">¶</a></dt>
<dd><p>HTTP 요청 메서드를 나타내는 문자열을 반환합니다. <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면, 그 값을 반환하고, 그렇지 않으면 <a class="reference internal" href="#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.data</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면 <code class="docutils literal notranslate"><span class="pre">'GET'</span></code>을 반환하거나 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">'POST'</span></code>를 반환합니다. 이것은 HTTP 요청에만 의미가 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>get_method는 이제 <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a>의 값을 조사합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.add_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">add_header</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">val</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.add_header" title="정의 주소">¶</a></dt>
<dd><p>요청에 다른 헤더를 추가합니다. 헤더는 현재 HTTP 처리기를 제외한 모든 처리기에서 무시되며, HTTP 처리기에서는 서버로 전송되는 헤더 리스트에 추가됩니다. 같은 이름을 가진 헤더를 두 개 이상 가질 수 없으며, <em>key</em>가 충돌하는 경우 후속 호출은 이전 호출을 덮어씁니다. 현재, 두 번 이상 사용될 때 의미가 있는 모든 헤더는 하나의 헤더만 사용하여 같은 기능을 얻는 (헤더 별) 방식을 가지므로 HTTP 기능의 손실은 없습니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.add_unredirected_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">add_unredirected_header</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">header</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.add_unredirected_header" title="정의 주소">¶</a></dt>
<dd><p>리디렉션 된 요청에 추가되지 않을 헤더를 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.has_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">has_header</code><span class="sig-paren">(</span><em class="sig-param">header</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.has_header" title="정의 주소">¶</a></dt>
<dd><p>인스턴스에 명명된 헤더가 있는지를 반환합니다 (일반과 리디렉션되지 않는 것을 모두 확인합니다).</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.remove_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">remove_header</code><span class="sig-paren">(</span><em class="sig-param">header</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.remove_header" title="정의 주소">¶</a></dt>
<dd><p>요청 인스턴스에서 명명된 헤더를 제거합니다 (일반과 리디렉션되지 않은 헤더 모두).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_full_url">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">get_full_url</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_full_url" title="정의 주소">¶</a></dt>
<dd><p>생성자에 제공된 URL을 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경.</span></p>
</div>
<p><a class="reference internal" href="#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.full_url</span></code></a>을 반환합니다</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.set_proxy">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">set_proxy</code><span class="sig-paren">(</span><em class="sig-param">host</em>, <em class="sig-param">type</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.set_proxy" title="정의 주소">¶</a></dt>
<dd><p>프락시 서버에 연결하여 요청을 준비합니다. <em>host</em>와 <em>type</em>은 인스턴스의 것을 대체하고, 인스턴스의 selector는 생성자에 제공된 원래 URL이 됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">get_header</code><span class="sig-paren">(</span><em class="sig-param">header_name</em>, <em class="sig-param">default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_header" title="정의 주소">¶</a></dt>
<dd><p>지정된 헤더의 값을 반환합니다. 헤더가 없으면, default 값을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.header_items">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">header_items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.header_items" title="정의 주소">¶</a></dt>
<dd><p>요청 헤더의 튜플 (header_name, header_value) 리스트를 반환합니다.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>3.3부터 폐지된 add_data, has_data, get_data, get_type, get_host, get_selector, get_origin_req_host 및 is_unverifiable 요청 메서드가 제거되었습니다.</p>
</div>
</div>
<div class="section" id="openerdirector-objects">
<span id="opener-director-objects"></span><h2>OpenerDirector 객체<a class="headerlink" href="#openerdirector-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 인스턴스에는 다음과 같은 메서드가 있습니다:</p>
<dl class="method">
<dt id="urllib.request.OpenerDirector.add_handler">
<code class="sig-prename descclassname">OpenerDirector.</code><code class="sig-name descname">add_handler</code><span class="sig-paren">(</span><em class="sig-param">handler</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.add_handler" title="정의 주소">¶</a></dt>
<dd><p><em>handler</em>는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>의 인스턴스여야 합니다. 다음 메서드가 검색되어, 가능한 체인에 추가됩니다 (HTTP 에러는 특별한 경우임에 유의하십시오). 다음에서 <em>protocol</em>은 처리할 실제 프로토콜로 바꿔야 합니다, 예를 들어 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_response()</span></code>는 HTTP 프로토콜 응답 처리기입니다. 또한 <em>type</em>은 실제 HTTP 코드로 대체해야 합니다, 예를 들어 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_404()</span></code>는 HTTP 404 에러를 처리합니다.</p>
<ul>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> --- 처리기가 <em>protocol</em> URL을 여는 방법을 알고 있음을 알립니다.</p>
<p>자세한 정보는 <a class="reference internal" href="#protocol-open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_open()</span></code></a>을 참조하십시오.</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> --- 처리기가 HTTP 에러 코드 <em>type</em>을 갖는 HTTP 에러를 처리하는 방법을 알고 있음을 알립니다.</p>
<p>자세한 정보는 <a class="reference internal" href="#http-error-nnn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.http_error_&lt;nnn&gt;()</span></code></a>을 참조하십시오.</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_error()</span></code> --- 처리기가 (<code class="docutils literal notranslate"><span class="pre">http</span></code>가 아닌) <em>protocol</em>의 에러를 처리하는 방법을 알고 있음을 알립니다.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code> --- 처리기가 <em>protocol</em> 요청을 전처리(pre-process)하는 방법을 알고 있음을 알립니다.</p>
<p>자세한 정보는 <a class="reference internal" href="#protocol-request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_request()</span></code></a>를 참조하십시오.</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> --- 처리기가 <em>protocol</em> 응답을 후처리(post-process)하는 방법을 알고 있음을 알립니다.</p>
<p>자세한 정보는 <a class="reference internal" href="#protocol-response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_response()</span></code></a>를 참조하십시오.</p>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="urllib.request.OpenerDirector.open">
<code class="sig-prename descclassname">OpenerDirector.</code><code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">data=None</em><span class="optional">[</span>, <em class="sig-param">timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.open" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>url</em>(요청 객체나 문자열일 수 있습니다)을 열고, 선택적으로 주어진 <em>data</em>를 전달합니다. 인자, 반환 값 및 발생하는 예외는 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>과 같습니다 (단순히 현재 설치된 전역 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>의 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> 메서드를 호출합니다). 선택적 <em>timeout</em> 매개 변수는 연결 시도와 같은 연산을 블로킹하기 위한 시간제한을 초 단위로 지정합니다 (지정하지 않으면 전역 기본 시간제한 설정이 사용됩니다). 시간제한 기능은 실제로는 HTTP, HTTPS 및 FTP 연결에서만 작동합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.OpenerDirector.error">
<code class="sig-prename descclassname">OpenerDirector.</code><code class="sig-name descname">error</code><span class="sig-paren">(</span><em class="sig-param">proto</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.error" title="정의 주소">¶</a></dt>
<dd><p>주어진 프로토콜의 에러를 처리합니다. 이것은 주어진 프로토콜에 대해 등록된 에러 처리기를 주어진 인자(프로토콜 특정입니다)로 호출합니다. HTTP 프로토콜은 HTTP 응답 코드를 사용하여 특정 에러 처리기를 결정하는 특수한 경우입니다; 처리기 클래스의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> 메서드를 참조하십시오.</p>
<p>반환 값과 발생하는 예외는 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>과 같습니다.</p>
</dd></dl>

<p>OpenerDirector 객체는 다음 3단계로 URL을 엽니다:</p>
<p>각 단계에서 이러한 메서드가 호출되는 순서는 처리기 인스턴스를 정렬하여 결정됩니다.</p>
<ol class="arabic">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code>와 같은 이름의 메서드를 가진 모든 처리기가 요청을 전처리하기 위해 해당 메서드가 호출됩니다.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code>과 같은 이름의 메서드를 가진 처리기가 요청을 처리하기 위해 호출됩니다. 이 단계는 처리기가 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>이 아닌 값(즉, 응답)을 반환하거나, 예외(보통 <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>)를 발생시킬 때 종료됩니다. 예외 전파가 허용됩니다.</p>
<p>사실, 위의 알고리즘은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code>이라는 메서드를 먼저 시도됩니다. 이러한 모든 메서드가 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환하면, 알고리즘은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code>과 같은 이름의 메서드에 대해 반복합니다. 이러한 모든 메서드가 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환하면, 알고리즘은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">unknown_open()</span></code>이라는 메서드에 대해 반복합니다.</p>
<p>이러한 메서드의 구현은 부모 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> 인스턴스의 <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a>과 <a class="reference internal" href="#urllib.request.OpenerDirector.error" title="urllib.request.OpenerDirector.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a> 메서드의 호출을 수반할 수 있음에 유의하십시오.</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code>와 같은 이름의 메서드가 있는 모든 처리기는 응답을 후처리하기 위해 해당 메서드가 호출됩니다.</p></li>
</ol>
</div>
<div class="section" id="basehandler-objects">
<span id="base-handler-objects"></span><h2>BaseHandler 객체<a class="headerlink" href="#basehandler-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 객체는 직접적으로 유용한 몇 가지 메서드와 파생 클래스에서 사용하기 위한 다른 메서드를 제공합니다. 다음은 직접 사용하기 위한 것입니다:</p>
<dl class="method">
<dt id="urllib.request.BaseHandler.add_parent">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">add_parent</code><span class="sig-paren">(</span><em class="sig-param">director</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.add_parent" title="정의 주소">¶</a></dt>
<dd><p>director를 부모로 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.close">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.close" title="정의 주소">¶</a></dt>
<dd><p>모든 부모를 제거합니다.</p>
</dd></dl>

<p>다음 어트리뷰트와 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>에서 파생된 클래스에서만 사용해야 합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code>나 <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> 메서드를 정의하는 서브 클래스는 <code class="xref py py-class docutils literal notranslate"><span class="pre">*Processor</span></code>라고 이름 붙이는 규칙이 채택되었습니다; 다른 모든 것들의 이름은 <code class="xref py py-class docutils literal notranslate"><span class="pre">*Handler</span></code>입니다.</p>
</div>
<dl class="attribute">
<dt id="urllib.request.BaseHandler.parent">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">parent</code><a class="headerlink" href="#urllib.request.BaseHandler.parent" title="정의 주소">¶</a></dt>
<dd><p>다른 프로토콜을 사용하여 열거나 에러를 처리하는 데 사용할 수 있는 유효한 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.default_open">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">default_open</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.default_open" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>에 정의되지 <em>않았지만</em>, 서브 클래스가 모든 URL을 포착하려면 이를 정의해야 합니다.</p>
<p>구현되면 이 메서드는 부모 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다. <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>의 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a>의 반환 값에 설명된 대로 파일류 객체를 반환하거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환해야 합니다. 진짜 예외적인 상황이 발생하지 않는 한  (예를 들어, <a class="reference internal" href="exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a>는 <code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code>로 매핑하지 않아야 합니다), <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>를 발생해야 합니다.</p>
<p>이 메서드는 프로토콜별 open 메서드보다 먼저 호출됩니다.</p>
</dd></dl>

<span class="target" id="protocol-open"></span><dl class="method">
<dt>
<code class="sig-name descname">BaseHandler.&lt;protocol&gt;_open(req)</code></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스가 주어진 프로토콜로 URL을 처리하려면 이를 정의해야 합니다.</p>
<p>정의되면, 이 메서드는 부모 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다. 반환 값은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code>과 같아야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.unknown_open">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">unknown_open</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.unknown_open" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스는 등록된 특정 처리기가 없는 모든 URL을 잡아서 열려면 이를 정의해야 합니다.</p>
<p>구현되면, 이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler.parent" title="urllib.request.BaseHandler.parent"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parent</span></code></a> <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다. 반환 값은 <a class="reference internal" href="#urllib.request.BaseHandler.default_open" title="urllib.request.BaseHandler.default_open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code></a>과 같아야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.http_error_default">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">http_error_default</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.http_error_default" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스는 달리 처리되지 않은 HTTP 에러에 대해 포괄적인 처리를 제공하려면 이를 재정의해야 합니다. 에러가 발생하는 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 자동으로 호출되며, 다른 상황에서는 일반적으로 호출되지 않아야 합니다.</p>
<p><em>req</em>는 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체, <em>fp</em>는 HTTP 에러 바디가 있는 파일류 객체, <em>code</em>는 에러의 3자리 코드, <em>msg</em>는 사용자가 볼 수 있는 코드 설명, <em>hdrs</em>는 에러의 헤더가 있는 매핑 객체가 됩니다.</p>
<p>반환 값과 발생하는 예외는 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>의 것과 같아야 합니다.</p>
</dd></dl>

<span class="target" id="http-error-nnn"></span><dl class="method">
<dt>
<code class="sig-name descname">BaseHandler.http_error_&lt;nnn&gt;(req, fp, code, msg, hdrs)</code></dt>
<dd><p><em>nnn</em>은 3자리 HTTP 에러 코드여야 합니다. 이 메서드도 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되어 있지 않지만, 존재한다면 코드가 <em>nnn</em> 인 HTTP 에러가 발생할 때 서브 클래스의 인스턴스에 대해 호출됩니다.</p>
<p>특정 HTTP 에러를 처리하려면 서브 클래스가 이 메서드를 재정의해야 합니다.</p>
<p>인자, 반환 값 및 발생하는 예외는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_default()</span></code>와 같아야 합니다.</p>
</dd></dl>

<span class="target" id="protocol-request"></span><dl class="method">
<dt>
<code class="sig-name descname">BaseHandler.&lt;protocol&gt;_request(req)</code></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스는 주어진 프로토콜의 요청을 전처리하려면 이를 정의해야 합니다.</p>
<p>정의되면, 이 메서드는 부모 상위 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다. <em>req</em>는 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체가 됩니다. 반환 값은 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체여야 합니다.</p>
</dd></dl>

<span class="target" id="protocol-response"></span><dl class="method">
<dt>
<code class="sig-name descname">BaseHandler.&lt;protocol&gt;_response(req, response)</code></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> 에 정의되지 <em>않았지만</em>, 서브 클래스는 주어진 프로토콜의 응답을 후처리하려면 이를 정의해야 합니다.</p>
<p>정의되면, 이 메서드는 부모 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다. <em>req</em>는 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 객체가 됩니다. <em>response</em>는 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>의 반환 값과 같은 인터페이스를 구현하는 객체가 됩니다. 반환 값은 <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>의 반환 값과 같은 인터페이스를 구현해야 합니다.</p>
</dd></dl>

</div>
<div class="section" id="httpredirecthandler-objects">
<span id="http-redirect-handler"></span><h2>HTTPRedirectHandler 객체<a class="headerlink" href="#httpredirecthandler-objects" title="제목 주소">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>일부 HTTP 리디렉션은 이 모듈의 클라이언트 코드로부터의 액션을 요구합니다. 이 경우, <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a>가 발생합니다. 다양한 리디렉션 코드의 정확한 의미에 대한 자세한 내용은 <span class="target" id="index-28"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a>을 참조하십시오.</p>
<p>HTTPRedirectHandler 에 HTTP, HTTPS 또는 FTP URL이 아닌 리디렉션 된 URL이 제공되면 보안을 고려하여 <code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPError</span></code> 예외가 발생했습니다.</p>
</div>
<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.redirect_request">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">redirect_request</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em>, <em class="sig-param">newurl</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.redirect_request" title="정의 주소">¶</a></dt>
<dd><p>리디렉션에 대한 응답으로 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>나 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 이것은 서버로부터 리디렉션이 수신될 때 <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_30*()</span></code> 메서드의 기본 구현에 의해 호출됩니다. 리디렉션이 일어나야 하면, <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_30*()</span></code>이 <em>newurl</em>로 리디렉션을 수행할 수 있도록 새 <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>를 반환합니다. 그렇지 않으면 다른 처리기가 이 URL을 처리하려고 시도하지 않아야 한다면 <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a>를 발생시키고, 자신은 할 수 없지만 다른 처리기가 처리할 수 있다면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 메서드의 기본 구현은 <span class="target" id="index-29"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a>을 엄격하게 따르지 않습니다. 즉, <code class="docutils literal notranslate"><span class="pre">POST</span></code> 요청에 대한 301과 302 응답은 사용자의 확인 없이 자동으로 리디렉션 되지 않아야 합니다. 실제로는, 브라우저들이 POST를 <code class="docutils literal notranslate"><span class="pre">GET</span></code>으로 변경하여 이러한 응답의 자동 리디렉션을 허용하며, 기본 구현은 이 동작을 재현합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_301">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">http_error_301</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Location:</span></code>이나 <code class="docutils literal notranslate"><span class="pre">URI:</span></code> URL로 리디렉션 합니다. 이 메서드는 HTTP 'moved permanently(영구적으로 이전했음)' 응답을 받을 때 부모 <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>에 의해 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_302">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">http_error_302</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_302" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>과 같지만, 'found(발견됨)' 응답에 대해 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_303">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">http_error_303</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_303" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>과 같지만, 'see other(다른 곳을 보세요)' 응답에 대해 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_307">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">http_error_307</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_307" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>과 같지만, 'temporary redirect(임시 리디렉션)' 응답에 대해 호출됩니다.</p>
</dd></dl>

</div>
<div class="section" id="httpcookieprocessor-objects">
<span id="http-cookie-processor"></span><h2>HTTPCookieProcessor 객체<a class="headerlink" href="#httpcookieprocessor-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.HTTPCookieProcessor" title="urllib.request.HTTPCookieProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPCookieProcessor</span></code></a> 인스턴스에는 하나의 어트리뷰트가 있습니다:</p>
<dl class="attribute">
<dt id="urllib.request.HTTPCookieProcessor.cookiejar">
<code class="sig-prename descclassname">HTTPCookieProcessor.</code><code class="sig-name descname">cookiejar</code><a class="headerlink" href="#urllib.request.HTTPCookieProcessor.cookiejar" title="정의 주소">¶</a></dt>
<dd><p>쿠키가 저장되는 <a class="reference internal" href="http.cookiejar.html#http.cookiejar.CookieJar" title="http.cookiejar.CookieJar"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.cookiejar.CookieJar</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="proxyhandler-objects">
<span id="proxy-handler"></span><h2>ProxyHandler 객체<a class="headerlink" href="#proxyhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt>
<code class="sig-name descname">ProxyHandler.&lt;protocol&gt;_open(request)</code></dt>
<dd><p>The <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> will have a method <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> for every
<em>protocol</em> which has a proxy in the <em>proxies</em> dictionary given in the
constructor.  The method will modify requests to go through the proxy, by
calling <code class="docutils literal notranslate"><span class="pre">request.set_proxy()</span></code>, and call the next handler in the chain to
actually execute the protocol.</p>
</dd></dl>

</div>
<div class="section" id="httppasswordmgr-objects">
<span id="http-password-mgr"></span><h2>HTTPPasswordMgr Objects<a class="headerlink" href="#httppasswordmgr-objects" title="제목 주소">¶</a></h2>
<p>These methods are available on <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> and
<a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> objects.</p>
<dl class="method">
<dt id="urllib.request.HTTPPasswordMgr.add_password">
<code class="sig-prename descclassname">HTTPPasswordMgr.</code><code class="sig-name descname">add_password</code><span class="sig-paren">(</span><em class="sig-param">realm</em>, <em class="sig-param">uri</em>, <em class="sig-param">user</em>, <em class="sig-param">passwd</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.add_password" title="정의 주소">¶</a></dt>
<dd><p><em>uri</em> can be either a single URI, or a sequence of URIs. <em>realm</em>, <em>user</em> and
<em>passwd</em> must be strings. This causes <code class="docutils literal notranslate"><span class="pre">(user,</span> <span class="pre">passwd)</span></code> to be used as
authentication tokens when authentication for <em>realm</em> and a super-URI of any of
the given URIs is given.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPPasswordMgr.find_user_password">
<code class="sig-prename descclassname">HTTPPasswordMgr.</code><code class="sig-name descname">find_user_password</code><span class="sig-paren">(</span><em class="sig-param">realm</em>, <em class="sig-param">authuri</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.find_user_password" title="정의 주소">¶</a></dt>
<dd><p>Get user/password for given realm and URI, if any.  This method will return
<code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">None)</span></code> if there is no matching user/password.</p>
<p>For <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> objects, the realm <code class="docutils literal notranslate"><span class="pre">None</span></code> will be
searched if the given <em>realm</em> has no matching user/password.</p>
</dd></dl>

</div>
<div class="section" id="httppasswordmgrwithpriorauth-objects">
<span id="http-password-mgr-with-prior-auth"></span><h2>HTTPPasswordMgrWithPriorAuth Objects<a class="headerlink" href="#httppasswordmgrwithpriorauth-objects" title="제목 주소">¶</a></h2>
<p>This password manager extends <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> to support
tracking URIs for which authentication credentials should always be sent.</p>
<dl class="method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.add_password">
<code class="sig-prename descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="sig-name descname">add_password</code><span class="sig-paren">(</span><em class="sig-param">realm</em>, <em class="sig-param">uri</em>, <em class="sig-param">user</em>, <em class="sig-param">passwd</em>, <em class="sig-param">is_authenticated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.add_password" title="정의 주소">¶</a></dt>
<dd><p><em>realm</em>, <em>uri</em>, <em>user</em>, <em>passwd</em> are as for
<a class="reference internal" href="#urllib.request.HTTPPasswordMgr.add_password" title="urllib.request.HTTPPasswordMgr.add_password"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HTTPPasswordMgr.add_password()</span></code></a>.  <em>is_authenticated</em> sets the initial
value of the <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> flag for the given URI or list of URIs.
If <em>is_authenticated</em> is specified as <code class="docutils literal notranslate"><span class="pre">True</span></code>, <em>realm</em> is ignored.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-prename descclassname">HTTPPasswordMgr.</code><code class="sig-name descname">find_user_password</code><span class="sig-paren">(</span><em class="sig-param">realm</em>, <em class="sig-param">authuri</em><span class="sig-paren">)</span></dt>
<dd><p>Same as for <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> objects</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated">
<code class="sig-prename descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="sig-name descname">update_authenticated</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">uri</em>, <em class="sig-param">is_authenticated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated" title="정의 주소">¶</a></dt>
<dd><p>Update the <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> flag for the given <em>uri</em> or list
of URIs.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated">
<code class="sig-prename descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="sig-name descname">is_authenticated</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">authuri</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated" title="정의 주소">¶</a></dt>
<dd><p>Returns the current state of the <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> flag for
the given URI.</p>
</dd></dl>

</div>
<div class="section" id="abstractbasicauthhandler-objects">
<span id="abstract-basic-auth-handler"></span><h2>AbstractBasicAuthHandler Objects<a class="headerlink" href="#abstractbasicauthhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed">
<code class="sig-prename descclassname">AbstractBasicAuthHandler.</code><code class="sig-name descname">http_error_auth_reqed</code><span class="sig-paren">(</span><em class="sig-param">authreq</em>, <em class="sig-param">host</em>, <em class="sig-param">req</em>, <em class="sig-param">headers</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed" title="정의 주소">¶</a></dt>
<dd><p>Handle an authentication request by getting a user/password pair, and re-trying
the request.  <em>authreq</em> should be the name of the header where the information
about the realm is included in the request, <em>host</em> specifies the URL and path to
authenticate for, <em>req</em> should be the (failed) <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> object, and
<em>headers</em> should be the error headers.</p>
<p><em>host</em> is either an authority (e.g. <code class="docutils literal notranslate"><span class="pre">&quot;python.org&quot;</span></code>) or a URL containing an
authority component (e.g. <code class="docutils literal notranslate"><span class="pre">&quot;http://python.org/&quot;</span></code>). In either case, the
authority must not contain a userinfo component (so, <code class="docutils literal notranslate"><span class="pre">&quot;python.org&quot;</span></code> and
<code class="docutils literal notranslate"><span class="pre">&quot;python.org:80&quot;</span></code> are fine, <code class="docutils literal notranslate"><span class="pre">&quot;joe:password&#64;python.org&quot;</span></code> is not).</p>
</dd></dl>

</div>
<div class="section" id="httpbasicauthhandler-objects">
<span id="http-basic-auth-handler"></span><h2>HTTPBasicAuthHandler Objects<a class="headerlink" href="#httpbasicauthhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPBasicAuthHandler.http_error_401">
<code class="sig-prename descclassname">HTTPBasicAuthHandler.</code><code class="sig-name descname">http_error_401</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler.http_error_401" title="정의 주소">¶</a></dt>
<dd><p>Retry the request with authentication information, if available.</p>
</dd></dl>

</div>
<div class="section" id="proxybasicauthhandler-objects">
<span id="proxy-basic-auth-handler"></span><h2>ProxyBasicAuthHandler Objects<a class="headerlink" href="#proxybasicauthhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.ProxyBasicAuthHandler.http_error_407">
<code class="sig-prename descclassname">ProxyBasicAuthHandler.</code><code class="sig-name descname">http_error_407</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler.http_error_407" title="정의 주소">¶</a></dt>
<dd><p>Retry the request with authentication information, if available.</p>
</dd></dl>

</div>
<div class="section" id="abstractdigestauthhandler-objects">
<span id="abstract-digest-auth-handler"></span><h2>AbstractDigestAuthHandler Objects<a class="headerlink" href="#abstractdigestauthhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed">
<code class="sig-prename descclassname">AbstractDigestAuthHandler.</code><code class="sig-name descname">http_error_auth_reqed</code><span class="sig-paren">(</span><em class="sig-param">authreq</em>, <em class="sig-param">host</em>, <em class="sig-param">req</em>, <em class="sig-param">headers</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed" title="정의 주소">¶</a></dt>
<dd><p><em>authreq</em> should be the name of the header where the information about the realm
is included in the request, <em>host</em> should be the host to authenticate to, <em>req</em>
should be the (failed) <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> object, and <em>headers</em> should be the
error headers.</p>
</dd></dl>

</div>
<div class="section" id="httpdigestauthhandler-objects">
<span id="http-digest-auth-handler"></span><h2>HTTPDigestAuthHandler Objects<a class="headerlink" href="#httpdigestauthhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPDigestAuthHandler.http_error_401">
<code class="sig-prename descclassname">HTTPDigestAuthHandler.</code><code class="sig-name descname">http_error_401</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler.http_error_401" title="정의 주소">¶</a></dt>
<dd><p>Retry the request with authentication information, if available.</p>
</dd></dl>

</div>
<div class="section" id="proxydigestauthhandler-objects">
<span id="proxy-digest-auth-handler"></span><h2>ProxyDigestAuthHandler Objects<a class="headerlink" href="#proxydigestauthhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.ProxyDigestAuthHandler.http_error_407">
<code class="sig-prename descclassname">ProxyDigestAuthHandler.</code><code class="sig-name descname">http_error_407</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">fp</em>, <em class="sig-param">code</em>, <em class="sig-param">msg</em>, <em class="sig-param">hdrs</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler.http_error_407" title="정의 주소">¶</a></dt>
<dd><p>Retry the request with authentication information, if available.</p>
</dd></dl>

</div>
<div class="section" id="httphandler-objects">
<span id="http-handler-objects"></span><h2>HTTPHandler Objects<a class="headerlink" href="#httphandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPHandler.http_open">
<code class="sig-prename descclassname">HTTPHandler.</code><code class="sig-name descname">http_open</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPHandler.http_open" title="정의 주소">¶</a></dt>
<dd><p>Send an HTTP request, which can be either GET or POST, depending on
<code class="docutils literal notranslate"><span class="pre">req.has_data()</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="httpshandler-objects">
<span id="https-handler-objects"></span><h2>HTTPSHandler Objects<a class="headerlink" href="#httpshandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPSHandler.https_open">
<code class="sig-prename descclassname">HTTPSHandler.</code><code class="sig-name descname">https_open</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPSHandler.https_open" title="정의 주소">¶</a></dt>
<dd><p>Send an HTTPS request, which can be either GET or POST, depending on
<code class="docutils literal notranslate"><span class="pre">req.has_data()</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="filehandler-objects">
<span id="file-handler-objects"></span><h2>FileHandler Objects<a class="headerlink" href="#filehandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.FileHandler.file_open">
<code class="sig-prename descclassname">FileHandler.</code><code class="sig-name descname">file_open</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FileHandler.file_open" title="정의 주소">¶</a></dt>
<dd><p>Open the file locally, if there is no host name, or the host name is
<code class="docutils literal notranslate"><span class="pre">'localhost'</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>This method is applicable only for local hostnames.  When a remote
hostname is given, an <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a> is raised.</p>
</div>
</dd></dl>

</div>
<div class="section" id="datahandler-objects">
<span id="data-handler-objects"></span><h2>DataHandler Objects<a class="headerlink" href="#datahandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.DataHandler.data_open">
<code class="sig-prename descclassname">DataHandler.</code><code class="sig-name descname">data_open</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.DataHandler.data_open" title="정의 주소">¶</a></dt>
<dd><p>Read a data URL. This kind of URL contains the content encoded in the URL
itself. The data URL syntax is specified in <span class="target" id="index-8"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2397.html"><strong>RFC 2397</strong></a>. This implementation
ignores white spaces in base64 encoded data URLs so the URL may be wrapped
in whatever source file it comes from. But even though some browsers don't
mind about a missing padding at the end of a base64 encoded data URL, this
implementation will raise an <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> in that case.</p>
</dd></dl>

</div>
<div class="section" id="ftphandler-objects">
<span id="ftp-handler-objects"></span><h2>FTPHandler Objects<a class="headerlink" href="#ftphandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.FTPHandler.ftp_open">
<code class="sig-prename descclassname">FTPHandler.</code><code class="sig-name descname">ftp_open</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FTPHandler.ftp_open" title="정의 주소">¶</a></dt>
<dd><p>Open the FTP file indicated by <em>req</em>. The login is always done with empty
username and password.</p>
</dd></dl>

</div>
<div class="section" id="cacheftphandler-objects">
<span id="cacheftp-handler-objects"></span><h2>CacheFTPHandler Objects<a class="headerlink" href="#cacheftphandler-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#urllib.request.CacheFTPHandler" title="urllib.request.CacheFTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CacheFTPHandler</span></code></a> objects are <a class="reference internal" href="#urllib.request.FTPHandler" title="urllib.request.FTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FTPHandler</span></code></a> objects with the
following additional methods:</p>
<dl class="method">
<dt id="urllib.request.CacheFTPHandler.setTimeout">
<code class="sig-prename descclassname">CacheFTPHandler.</code><code class="sig-name descname">setTimeout</code><span class="sig-paren">(</span><em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.CacheFTPHandler.setTimeout" title="정의 주소">¶</a></dt>
<dd><p>Set timeout of connections to <em>t</em> seconds.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.CacheFTPHandler.setMaxConns">
<code class="sig-prename descclassname">CacheFTPHandler.</code><code class="sig-name descname">setMaxConns</code><span class="sig-paren">(</span><em class="sig-param">m</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.CacheFTPHandler.setMaxConns" title="정의 주소">¶</a></dt>
<dd><p>Set maximum number of cached connections to <em>m</em>.</p>
</dd></dl>

</div>
<div class="section" id="unknownhandler-objects">
<span id="unknown-handler-objects"></span><h2>UnknownHandler Objects<a class="headerlink" href="#unknownhandler-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.UnknownHandler.unknown_open">
<code class="sig-prename descclassname">UnknownHandler.</code><code class="sig-name descname">unknown_open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.UnknownHandler.unknown_open" title="정의 주소">¶</a></dt>
<dd><p>Raise a <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a> exception.</p>
</dd></dl>

</div>
<div class="section" id="httperrorprocessor-objects">
<span id="http-error-processor-objects"></span><h2>HTTPErrorProcessor Objects<a class="headerlink" href="#httperrorprocessor-objects" title="제목 주소">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPErrorProcessor.http_response">
<code class="sig-prename descclassname">HTTPErrorProcessor.</code><code class="sig-name descname">http_response</code><span class="sig-paren">(</span><em class="sig-param">request</em>, <em class="sig-param">response</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.http_response" title="정의 주소">¶</a></dt>
<dd><p>HTTP 에러 응답을 처리합니다.</p>
<p>For 200 error codes, the response object is returned immediately.</p>
<p>For non-200 error codes, this simply passes the job on to the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> handler methods, via <a class="reference internal" href="#urllib.request.OpenerDirector.error" title="urllib.request.OpenerDirector.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.error()</span></code></a>.
Eventually, <a class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler" title="urllib.request.HTTPDefaultErrorHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPDefaultErrorHandler</span></code></a> will raise an
<a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> if no other handler handles the error.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPErrorProcessor.https_response">
<code class="sig-prename descclassname">HTTPErrorProcessor.</code><code class="sig-name descname">https_response</code><span class="sig-paren">(</span><em class="sig-param">request</em>, <em class="sig-param">response</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.https_response" title="정의 주소">¶</a></dt>
<dd><p>Process HTTPS error responses.</p>
<p>The behavior is same as <a class="reference internal" href="#urllib.request.HTTPErrorProcessor.http_response" title="urllib.request.HTTPErrorProcessor.http_response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_response()</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="urllib-request-examples"></span><h2>Examples<a class="headerlink" href="#examples" title="제목 주소">¶</a></h2>
<p>In addition to the examples below, more examples are given in
<a class="reference internal" href="../howto/urllib2.html#urllib-howto"><span class="std std-ref">urllib 패키지를 사용하여 인터넷 리소스를 가져오는 방법</span></a>.</p>
<p>This example gets the python.org main page and displays the first 300 bytes of
it.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">300</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">b&#39;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n\n\n&lt;html</span>
<span class="go">xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n</span>
<span class="go">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\n</span>
<span class="go">&lt;title&gt;Python Programming &#39;</span>
</pre></div>
</div>
<p>Note that urlopen returns a bytes object.  This is because there is no way
for urlopen to automatically determine the encoding of the byte stream
it receives from the HTTP server. In general, a program will decode
the returned bytes object to string once it determines or guesses
the appropriate encoding.</p>
<p>The following W3C document, <a class="reference external" href="https://www.w3.org/International/O-charset">https://www.w3.org/International/O-charset</a>, lists
the various ways in which an (X)HTML or an XML document could have specified its
encoding information.</p>
<p>As the python.org website uses <em>utf-8</em> encoding as specified in its meta tag, we
will use the same for decoding the bytes object.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtm</span>
</pre></div>
</div>
<p>It is also possible to achieve the same result without using the
<a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a> approach.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtm</span>
</pre></div>
</div>
<p>In the following example, we are sending a data-stream to the stdin of a CGI
and reading the data it returns to us. Note that this example will only work
when the Python installation supports SSL.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;https://localhost/cgi-bin/test.cgi&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">data</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;This data is passed to stdin of the CGI&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">Got Data: &quot;This data is passed to stdin of the CGI&quot;</span>
</pre></div>
</div>
<p>The code for the sample CGI used in the above example is:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Content-type: text/plain</span><span class="se">\n\n</span><span class="s1">Got Data: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is an example of doing a <code class="docutils literal notranslate"><span class="pre">PUT</span></code> request using <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">DATA</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;some data&#39;</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;http://localhost:8080&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">DATA</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;PUT&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
</pre></div>
</div>
<p>Use of Basic HTTP Authentication:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="c1"># Create an OpenerDirector with support for Basic HTTP Authentication...</span>
<span class="n">auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">HTTPBasicAuthHandler</span><span class="p">()</span>
<span class="n">auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="n">realm</span><span class="o">=</span><span class="s1">&#39;PDQ Application&#39;</span><span class="p">,</span>
                          <span class="n">uri</span><span class="o">=</span><span class="s1">&#39;https://mahler:8092/site-updates.py&#39;</span><span class="p">,</span>
                          <span class="n">user</span><span class="o">=</span><span class="s1">&#39;klem&#39;</span><span class="p">,</span>
                          <span class="n">passwd</span><span class="o">=</span><span class="s1">&#39;kadidd!ehopper&#39;</span><span class="p">)</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">auth_handler</span><span class="p">)</span>
<span class="c1"># ...and install it globally so it can be used with urlopen.</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">install_opener</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#urllib.request.build_opener" title="urllib.request.build_opener"><code class="xref py py-func docutils literal notranslate"><span class="pre">build_opener()</span></code></a> provides many handlers by default, including a
<a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a>.  By default, <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> uses the environment
variables named <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;_proxy</span></code>, where <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;</span></code> is the URL scheme
involved.  For example, the <span class="target" id="index-9"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">http_proxy</span></code> environment variable is read to
obtain the HTTP proxy's URL.</p>
<p>This example replaces the default <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> with one that uses
programmatically-supplied proxy URLs, and adds proxy authorization support with
<a class="reference internal" href="#urllib.request.ProxyBasicAuthHandler" title="urllib.request.ProxyBasicAuthHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyBasicAuthHandler</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">proxy_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyHandler</span><span class="p">({</span><span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="s1">&#39;http://www.example.com:3128/&#39;</span><span class="p">})</span>
<span class="n">proxy_auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyBasicAuthHandler</span><span class="p">()</span>
<span class="n">proxy_auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="s1">&#39;realm&#39;</span><span class="p">,</span> <span class="s1">&#39;host&#39;</span><span class="p">,</span> <span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="s1">&#39;password&#39;</span><span class="p">)</span>

<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">proxy_handler</span><span class="p">,</span> <span class="n">proxy_auth_handler</span><span class="p">)</span>
<span class="c1"># This time, rather than install the OpenerDirector, we use it directly:</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Adding HTTP headers:</p>
<p>Use the <em>headers</em> argument to the <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> constructor, or:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Referer&#39;</span><span class="p">,</span> <span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="c1"># Customize the default User-Agent header value:</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;User-Agent&#39;</span><span class="p">,</span> <span class="s1">&#39;urllib-example/0.1 (Contact: . . .)&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> automatically adds a <em class="mailheader">User-Agent</em> header to
every <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>.  To change this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">()</span>
<span class="n">opener</span><span class="o">.</span><span class="n">addheaders</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;User-agent&#39;</span><span class="p">,</span> <span class="s1">&#39;Mozilla/5.0&#39;</span><span class="p">)]</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Also, remember that a few standard headers (<em class="mailheader">Content-Length</em>,
<em class="mailheader">Content-Type</em> and <em class="mailheader">Host</em>)
are added when the <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> is passed to <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> (or
<a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.open()</span></code></a>).</p>
<p id="urllib-examples">Here is an example session that uses the <code class="docutils literal notranslate"><span class="pre">GET</span></code> method to retrieve a URL
containing parameters:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;http://www.musi-cal.com/cgi-bin/query?</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">params</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>The following example uses the <code class="docutils literal notranslate"><span class="pre">POST</span></code> method instead. Note that params output
from urlencode is encoded to bytes before it is sent to urlopen as data:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&quot;http://requestb.in/xrbl82xr&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>The following example uses an explicitly specified HTTP proxy, overriding
environment settings:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proxies</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="s1">&#39;http://proxy.example.com:8080/&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">(</span><span class="n">proxies</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;http://www.python.org&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>The following example uses no proxies at all, overriding environment settings:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">({})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;http://www.python.org/&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
</div>
<div class="section" id="legacy-interface">
<h2>Legacy interface<a class="headerlink" href="#legacy-interface" title="제목 주소">¶</a></h2>
<p>The following functions and classes are ported from the Python 2 module
<code class="docutils literal notranslate"><span class="pre">urllib</span></code> (as opposed to <code class="docutils literal notranslate"><span class="pre">urllib2</span></code>).  They might become deprecated at
some point in the future.</p>
<dl class="function">
<dt id="urllib.request.urlretrieve">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">urlretrieve</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">reporthook=None</em>, <em class="sig-param">data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlretrieve" title="정의 주소">¶</a></dt>
<dd><p>Copy a network object denoted by a URL to a local file. If the URL
points to a local file, the object will not be copied unless filename is supplied.
Return a tuple <code class="docutils literal notranslate"><span class="pre">(filename,</span> <span class="pre">headers)</span></code> where <em>filename</em> is the
local file name under which the object can be found, and <em>headers</em> is whatever
the <code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code> method of the object returned by <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> returned (for
a remote object). Exceptions are the same as for <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>.</p>
<p>The second argument, if present, specifies the file location to copy to (if
absent, the location will be a tempfile with a generated name). The third
argument, if present, is a callable that will be called once on
establishment of the network connection and once after each block read
thereafter.  The callable will be passed three arguments; a count of blocks
transferred so far, a block size in bytes, and the total size of the file.  The
third argument may be <code class="docutils literal notranslate"><span class="pre">-1</span></code> on older FTP servers which do not return a file
size in response to a retrieval request.</p>
<p>The following example illustrates the most common usage scenario:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_filename</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlretrieve</span><span class="p">(</span><span class="s1">&#39;http://python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">local_filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>If the <em>url</em> uses the <code class="file docutils literal notranslate"><span class="pre">http:</span></code> scheme identifier, the optional <em>data</em>
argument may be given to specify a <code class="docutils literal notranslate"><span class="pre">POST</span></code> request (normally the request
type is <code class="docutils literal notranslate"><span class="pre">GET</span></code>).  The <em>data</em> argument must be a bytes object in standard
<em class="mimetype">application/x-www-form-urlencoded</em> format; see the
<a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> function.</p>
<p><a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> will raise <code class="xref py py-exc docutils literal notranslate"><span class="pre">ContentTooShortError</span></code> when it detects that
the amount of data available  was less than the expected amount (which is the
size reported by a  <em>Content-Length</em> header). This can occur, for example, when
the  download is interrupted.</p>
<p>The <em>Content-Length</em> is treated as a lower bound: if there's more data  to read,
urlretrieve reads more data, but if less data is available,  it raises the
exception.</p>
<p>You can still retrieve the downloaded data in this case, it is stored  in the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">content</span></code> attribute of the exception instance.</p>
<p>If no <em>Content-Length</em> header was supplied, urlretrieve can not check the size
of the data it has downloaded, and just returns it.  In this case you just have
to assume that the download was successful.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.urlcleanup">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">urlcleanup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlcleanup" title="정의 주소">¶</a></dt>
<dd><p>Cleans up temporary files that may have been left behind by previous
calls to <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.URLopener">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">URLopener</code><span class="sig-paren">(</span><em class="sig-param">proxies=None</em>, <em class="sig-param">**x509</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener" title="정의 주소">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지.</span></p>
</div>
<p>Base class for opening and reading URLs.  Unless you need to support opening
objects using schemes other than <code class="file docutils literal notranslate"><span class="pre">http:</span></code>, <code class="file docutils literal notranslate"><span class="pre">ftp:</span></code>, or <code class="file docutils literal notranslate"><span class="pre">file:</span></code>,
you probably want to use <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a>.</p>
<p>By default, the <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> class sends a <em class="mailheader">User-Agent</em> header
of <code class="docutils literal notranslate"><span class="pre">urllib/VVV</span></code>, where <em>VVV</em> is the <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> version number.
Applications can define their own <em class="mailheader">User-Agent</em> header by subclassing
<a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> or <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> and setting the class attribute
<a class="reference internal" href="#urllib.request.URLopener.version" title="urllib.request.URLopener.version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">version</span></code></a> to an appropriate string value in the subclass definition.</p>
<p>The optional <em>proxies</em> parameter should be a dictionary mapping scheme names to
proxy URLs, where an empty dictionary turns proxies off completely.  Its default
value is <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case environmental proxy settings will be used if
present, as discussed in the definition of <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>, above.</p>
<p>Additional keyword parameters, collected in <em>x509</em>, may be used for
authentication of the client when using the <code class="file docutils literal notranslate"><span class="pre">https:</span></code> scheme.  The keywords
<em>key_file</em> and <em>cert_file</em> are supported to provide an  SSL key and certificate;
both are needed to support client authentication.</p>
<p><a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> objects will raise an <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> exception if the server
returns an error code.</p>
<dl class="method">
<dt id="urllib.request.URLopener.open">
<code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param">fullurl</em>, <em class="sig-param">data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.open" title="정의 주소">¶</a></dt>
<dd><p>Open <em>fullurl</em> using the appropriate protocol.  This method sets up cache and
proxy information, then calls the appropriate open method with its input
arguments.  If the scheme is not recognized, <a class="reference internal" href="#urllib.request.URLopener.open_unknown" title="urllib.request.URLopener.open_unknown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open_unknown()</span></code></a> is called.
The <em>data</em> argument has the same meaning as the <em>data</em> argument of
<a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>.</p>
<p>This method always quotes <em>fullurl</em> using <a class="reference internal" href="urllib.parse.html#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.URLopener.open_unknown">
<code class="sig-name descname">open_unknown</code><span class="sig-paren">(</span><em class="sig-param">fullurl</em>, <em class="sig-param">data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.open_unknown" title="정의 주소">¶</a></dt>
<dd><p>Overridable interface to open unknown URL types.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.URLopener.retrieve">
<code class="sig-name descname">retrieve</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">reporthook=None</em>, <em class="sig-param">data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.retrieve" title="정의 주소">¶</a></dt>
<dd><p>Retrieves the contents of <em>url</em> and places it in <em>filename</em>.  The return value
is a tuple consisting of a local filename and either an
<a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.message.Message</span></code></a> object containing the response headers (for remote
URLs) or <code class="docutils literal notranslate"><span class="pre">None</span></code> (for local URLs).  The caller must then open and read the
contents of <em>filename</em>.  If <em>filename</em> is not given and the URL refers to a
local file, the input filename is returned.  If the URL is non-local and
<em>filename</em> is not given, the filename is the output of <a class="reference internal" href="tempfile.html#tempfile.mktemp" title="tempfile.mktemp"><code class="xref py py-func docutils literal notranslate"><span class="pre">tempfile.mktemp()</span></code></a>
with a suffix that matches the suffix of the last path component of the input
URL.  If <em>reporthook</em> is given, it must be a function accepting three numeric
parameters: A chunk number, the maximum size chunks are read in and the total size of the download
(-1 if unknown).  It will be called once at the start and after each chunk of data is read from the
network.  <em>reporthook</em> is ignored for local URLs.</p>
<p>If the <em>url</em> uses the <code class="file docutils literal notranslate"><span class="pre">http:</span></code> scheme identifier, the optional <em>data</em>
argument may be given to specify a <code class="docutils literal notranslate"><span class="pre">POST</span></code> request (normally the request type
is <code class="docutils literal notranslate"><span class="pre">GET</span></code>).  The <em>data</em> argument must in standard
<em class="mimetype">application/x-www-form-urlencoded</em> format; see the
<a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> function.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.URLopener.version">
<code class="sig-name descname">version</code><a class="headerlink" href="#urllib.request.URLopener.version" title="정의 주소">¶</a></dt>
<dd><p>Variable that specifies the user agent of the opener object.  To get
<a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> to tell servers that it is a particular user agent, set this in a
subclass as a class variable or in the constructor before calling the base
constructor.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="urllib.request.FancyURLopener">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">FancyURLopener</code><span class="sig-paren">(</span><em class="sig-param">...</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FancyURLopener" title="정의 주소">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지.</span></p>
</div>
<p><a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> subclasses <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> providing default handling
for the following HTTP response codes: 301, 302, 303, 307 and 401.  For the 30x
response codes listed above, the <em class="mailheader">Location</em> header is used to fetch
the actual URL.  For 401 response codes (authentication required), basic HTTP
authentication is performed.  For the 30x response codes, recursion is bounded
by the value of the <em>maxtries</em> attribute, which defaults to 10.</p>
<p>For all other response codes, the method <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_default()</span></code> is called
which you can override in subclasses to handle the error appropriately.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>According to the letter of <span class="target" id="index-10"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html"><strong>RFC 2616</strong></a>, 301 and 302 responses to POST requests
must not be automatically redirected without confirmation by the user.  In
reality, browsers do allow automatic redirection of these responses, changing
the POST to a GET, and <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> reproduces this behaviour.</p>
</div>
<p>The parameters to the constructor are the same as those for <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>When performing basic authentication, a <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> instance calls
its <a class="reference internal" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="urllib.request.FancyURLopener.prompt_user_passwd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prompt_user_passwd()</span></code></a> method.  The default implementation asks the
users for the required information on the controlling terminal.  A subclass may
override this method to support more appropriate behavior if needed.</p>
</div>
<p>The <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> class offers one additional method that should be
overloaded to provide the appropriate behavior:</p>
<dl class="method">
<dt id="urllib.request.FancyURLopener.prompt_user_passwd">
<code class="sig-name descname">prompt_user_passwd</code><span class="sig-paren">(</span><em class="sig-param">host</em>, <em class="sig-param">realm</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="정의 주소">¶</a></dt>
<dd><p>Return information needed to authenticate the user at the given host in the
specified security realm.  The return value should be a tuple, <code class="docutils literal notranslate"><span class="pre">(user,</span>
<span class="pre">password)</span></code>, which can be used for basic authentication.</p>
<p>The implementation prompts for this information on the terminal; an application
should override this method to use an appropriate interaction model in the local
environment.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="urllib-request-restrictions">
<h2><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> Restrictions<a class="headerlink" href="#urllib-request-restrictions" title="제목 주소">¶</a></h2>
<blockquote>
<div></div></blockquote>
<ul id="index-11">
<li><p>Currently, only the following protocols are supported: HTTP (versions 0.9 and
1.0), FTP, local files, and data URLs.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>Added support for data URLs.</p>
</div>
</li>
<li><p>The caching feature of <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> has been disabled until someone
finds the time to hack proper processing of Expiration time headers.</p></li>
<li><p>There should be a function to query whether a particular URL is in the cache.</p></li>
<li><p>For backward compatibility, if a URL appears to point to a local file but the
file can't be opened, the URL is re-interpreted using the FTP protocol.  This
can sometimes cause confusing error messages.</p></li>
<li><p>The <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> and <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> functions can cause arbitrarily
long delays while waiting for a network connection to be set up.  This means
that it is difficult to build an interactive Web client using these functions
without using threads.</p>
</li>
<li id="index-12"><p>The data returned by <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> or <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> is the raw data
returned by the server.  This may be binary data (such as an image), plain text
or (for example) HTML.  The HTTP protocol provides type information in the reply
header, which can be inspected by looking at the <em class="mailheader">Content-Type</em>
header.  If the returned data is HTML, you can use the module
<a class="reference internal" href="html.parser.html#module-html.parser" title="html.parser: A simple parser that can handle HTML and XHTML."><code class="xref py py-mod docutils literal notranslate"><span class="pre">html.parser</span></code></a> to parse it.</p>
</li>
<li id="index-13"><p>The code handling the FTP protocol cannot differentiate between a file and a
directory.  This can lead to unexpected behavior when attempting to read a URL
that points to a file that is not accessible.  If the URL ends in a <code class="docutils literal notranslate"><span class="pre">/</span></code>, it is
assumed to refer to a directory and will be handled accordingly.  But if an
attempt to read a file leads to a 550 error (meaning the URL cannot be found or
is not accessible, often for permission reasons), then the path is treated as a
directory in order to handle the case when a directory is specified by a URL but
the trailing <code class="docutils literal notranslate"><span class="pre">/</span></code> has been left off.  This can cause misleading results when
you try to fetch a file whose read permissions make it inaccessible; the FTP
code will try to read it, fail with a 550 error, and then perform a directory
listing for the unreadable file. If fine-grained control is needed, consider
using the <a class="reference internal" href="ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a> module, subclassing <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a>, or changing
<em>_urlopener</em> to meet your needs.</p></li>
</ul>
</div>
</div>
<div class="section" id="module-urllib.response">
<span id="urllib-response-response-classes-used-by-urllib"></span><h1><a class="reference internal" href="#module-urllib.response" title="urllib.response: Response classes used by urllib."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code></a> --- Response classes used by urllib<a class="headerlink" href="#module-urllib.response" title="제목 주소">¶</a></h1>
<p>The <a class="reference internal" href="#module-urllib.response" title="urllib.response: Response classes used by urllib."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code></a> module defines functions and classes which define a
minimal file like interface, including <code class="docutils literal notranslate"><span class="pre">read()</span></code> and <code class="docutils literal notranslate"><span class="pre">readline()</span></code>. The
typical response object is an addinfourl instance, which defines an <code class="docutils literal notranslate"><span class="pre">info()</span></code>
method and that returns headers and a <code class="docutils literal notranslate"><span class="pre">geturl()</span></code> method that returns the url.
Functions defined by this module are used internally by the
<a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> module.</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> --- URL을 열기 위한 확장 가능한 라이브러리</a><ul>
<li><a class="reference internal" href="#request-objects">Request 객체</a></li>
<li><a class="reference internal" href="#openerdirector-objects">OpenerDirector 객체</a></li>
<li><a class="reference internal" href="#basehandler-objects">BaseHandler 객체</a></li>
<li><a class="reference internal" href="#httpredirecthandler-objects">HTTPRedirectHandler 객체</a></li>
<li><a class="reference internal" href="#httpcookieprocessor-objects">HTTPCookieProcessor 객체</a></li>
<li><a class="reference internal" href="#proxyhandler-objects">ProxyHandler 객체</a></li>
<li><a class="reference internal" href="#httppasswordmgr-objects">HTTPPasswordMgr Objects</a></li>
<li><a class="reference internal" href="#httppasswordmgrwithpriorauth-objects">HTTPPasswordMgrWithPriorAuth Objects</a></li>
<li><a class="reference internal" href="#abstractbasicauthhandler-objects">AbstractBasicAuthHandler Objects</a></li>
<li><a class="reference internal" href="#httpbasicauthhandler-objects">HTTPBasicAuthHandler Objects</a></li>
<li><a class="reference internal" href="#proxybasicauthhandler-objects">ProxyBasicAuthHandler Objects</a></li>
<li><a class="reference internal" href="#abstractdigestauthhandler-objects">AbstractDigestAuthHandler Objects</a></li>
<li><a class="reference internal" href="#httpdigestauthhandler-objects">HTTPDigestAuthHandler Objects</a></li>
<li><a class="reference internal" href="#proxydigestauthhandler-objects">ProxyDigestAuthHandler Objects</a></li>
<li><a class="reference internal" href="#httphandler-objects">HTTPHandler Objects</a></li>
<li><a class="reference internal" href="#httpshandler-objects">HTTPSHandler Objects</a></li>
<li><a class="reference internal" href="#filehandler-objects">FileHandler Objects</a></li>
<li><a class="reference internal" href="#datahandler-objects">DataHandler Objects</a></li>
<li><a class="reference internal" href="#ftphandler-objects">FTPHandler Objects</a></li>
<li><a class="reference internal" href="#cacheftphandler-objects">CacheFTPHandler Objects</a></li>
<li><a class="reference internal" href="#unknownhandler-objects">UnknownHandler Objects</a></li>
<li><a class="reference internal" href="#httperrorprocessor-objects">HTTPErrorProcessor Objects</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#legacy-interface">Legacy interface</a></li>
<li><a class="reference internal" href="#urllib-request-restrictions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> Restrictions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-urllib.response"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code> --- Response classes used by urllib</a></li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="urllib.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code> --- URL 처리 모듈</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="urllib.parse.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code> --- URL을 구성 요소로 구문 분석</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="urllib.parse --- URL을 구성 요소로 구문 분석"
             >다음</a> |</li>
        <li class="right" >
          <a href="urllib.html" title="urllib --- URL 처리 모듈"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>