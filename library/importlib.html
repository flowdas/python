
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>importlib --- import의 구현 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="importlib.metadata 사용하기" href="importlib.metadata.html" />
    <link rel="prev" title="runpy --- 파이썬 모듈 찾기와 실행" href="runpy.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/importlib.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="importlib.metadata.html" title="importlib.metadata 사용하기"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy --- 파이썬 모듈 찾기와 실행"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" accesskey="U">모듈 임포트 하기</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-importlib">
<span id="importlib-the-implementation-of-import"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> --- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>의 구현<a class="headerlink" href="#module-importlib" title="제목 주소">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/importlib/__init__.py">Lib/importlib/__init__.py</a></p>
<hr class="docutils" />
<div class="section" id="introduction">
<h2>소개<a class="headerlink" href="#introduction" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 패키지의 목적은 두 가지입니다. 하나는 파이썬 소스 코드에서 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문(그리고, 확장하면 <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수)의 구현을 제공하는 것입니다. 이것은 모든 파이썬 인터프리터에 이식할 수 있는 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>의 구현을 제공합니다. 또한 파이썬 이외의 프로그래밍 언어로 구현 된 것보다 이해하기 쉬운 구현을 제공합니다.</p>
<p>둘째, <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>를 구현하는 구성 요소가 이 패키지에서 노출되어, 사용자가 임포트 프로세스에 참여하기 위해 자신의 사용자 지정 객체(일반적으로 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">임포터</span></a>라고 합니다)를 쉽게 만들 수 있도록 합니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><a class="reference internal" href="../reference/simple_stmts.html#import"><span class="std std-ref">임포트(import) 문</span></a></dt><dd><p><a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문의 언어 레퍼런스.</p>
</dd>
<dt><a class="reference external" href="https://www.python.org/doc/essays/packages/">패키지 명세</a></dt><dd><p>패키지의 원래 명세. 이 문서를 작성한 이후로 일부 의미가 변경되었습니다 (예를 들어 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 기반으로 하는 리디렉션).</p>
</dd>
<dt><a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수</dt><dd><p><a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문은 이 함수의 편의 문법입니다.</p>
</dd>
<dt><span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0235"><strong>PEP 235</strong></a></dt><dd><p>대소 문자를 구분하지 않는 플랫폼에서의 임포트</p>
</dd>
<dt><span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0263"><strong>PEP 263</strong></a></dt><dd><p>파이썬 소스 코드 인코딩 정의</p>
</dd>
<dt><span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a></dt><dd><p>새로운 임포트 훅</p>
</dd>
<dt><span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a></dt><dd><p>임포트: 다중 줄과 절대/상대</p>
</dd>
<dt><span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a></dt><dd><p>메인 모듈 명시적 상대 임포트</p>
</dd>
<dt><span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a></dt><dd><p>묵시적 이름 공간 패키지</p>
</dd>
<dt><span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451"><strong>PEP 451</strong></a></dt><dd><p>임포트 시스템을 위한 ModuleSpec 형</p>
</dd>
<dt><span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a></dt><dd><p>PYO 파일 제거</p>
</dd>
<dt><span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a></dt><dd><p>다단계 확장 모듈 초기화</p>
</dd>
<dt><span class="target" id="index-9"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0552"><strong>PEP 552</strong></a></dt><dd><p>결정론적 pyc</p>
</dd>
<dt><span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3120"><strong>PEP 3120</strong></a></dt><dd><p>UTF-8을 기본 소스 인코딩으로 사용하기</p>
</dd>
<dt><span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a></dt><dd><p>PYC 저장소 디렉터리</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="functions">
<h2>함수<a class="headerlink" href="#functions" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="importlib.__import__">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">__import__</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">globals=None</em>, <em class="sig-param">locals=None</em>, <em class="sig-param">fromlist=()</em>, <em class="sig-param">level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.__import__" title="정의 주소">¶</a></dt>
<dd><p>내장 <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수의 구현.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>프로그래밍 방식으로 모듈을 임포트하려면 이 함수 대신 <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a>을 사용해야합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.import_module">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">import_module</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.import_module" title="정의 주소">¶</a></dt>
<dd><p>모듈을 임포트합니다. <em>name</em> 인자는 절대나 상대적인 항으로 임포트할 모듈을 지정합니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>나 <code class="docutils literal notranslate"><span class="pre">..mod</span></code>). 이름이 상대적인 항으로 지정되면, <em>package</em> 인자는 패키지 이름을 결정하기 위한 앵커 역할을 하는 패키지 이름으로 설정해야합니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">import_module('..mod',</span> <span class="pre">'pkg.subpkg')</span></code>는 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>를 임포트합니다).</p>
<p><a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> 함수는 <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a> 주위를 감싸는 단순화 래퍼 역할을 합니다. 이는 함수의 모든 의미가 <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a>에서 파생됨을 뜻합니다. 이 두 함수의 가장 중요한 차이점은 <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a>이 지정된 패키지나 모듈(예를 들어 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>)을 반환하는 반면, <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>는 최상위 패키지나 모듈(예를 들어 <code class="docutils literal notranslate"><span class="pre">pkg</span></code>)을 반환한다는 것입니다.</p>
<p>인터프리터가 실행을 시작한 이후 만들어진 모듈(예를 들어, 파이썬 소스 파일을 만들면)을 동적으로 임포트하는 경우, 임포트 시스템에서 새 모듈을 알 수 있도록 <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">invalidate_caches()</span></code></a>를 호출해야 할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>부모 패키지는 자동으로 임포트됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.find_loader">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">find_loader</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.find_loader" title="정의 주소">¶</a></dt>
<dd><p>선택적으로 지정된 <em>path</em> 내에서, 모듈의 로더를 찾습니다. 모듈이 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 있으면, <code class="docutils literal notranslate"><span class="pre">sys.modules[name].__loader__</span></code>가 반환됩니다 (로더가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 되거나 설정되지 않지 않은 한, 그런 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다). 그렇지 않으면 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>를 사용한 검색이 수행됩니다. 로더가 발견되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다.</p>
<p>점으로 구분된 이름은 부모를 묵시적으로 임포트되게 하지 않습니다, 그렇게 하려면 로드가 필요하고 이것이 바람직하지 않을 수 있기 때문입니다. 서브 모듈을 올바르게 임포트 하려면 서브 모듈의 모든 부모 패키지를 임포트하고 <em>path</em>에 올바른 인자를 사용해야합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">__loader__</span></code>가 설정되지 않으면, 어트리뷰트가 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정되었을 때와 마찬가지로 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.invalidate_caches">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.invalidate_caches" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>에 저장된 파인더의 내부 캐시를 무효화합니다. 파인더가 <code class="docutils literal notranslate"><span class="pre">invalidate_caches()</span></code>를 구현하면 무효화를 수행하기 위해 호출됩니다. 모든 파인더가 새로운 모듈의 존재를 알 수 있도록 프로그램이 실행되는 동안 모듈이 만들어진/설치된 경우 이 함수를 호출해야합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.reload">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">reload</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.reload" title="정의 주소">¶</a></dt>
<dd><p>이전에 임포트한 <em>module</em>를 다시 로드합니다. 인자는 모듈 객체여야 해서, 이전에 성공적으로 임포트되었어야 합니다. 외부 편집기를 사용하여 모듈 소스 파일을 편집했고 파이썬 인터프리터를 떠나지 않고 새 버전을 시험해보고 싶을 때 유용합니다. 반환 값은 모듈 객체입니다 (재 임포트로 인해 다른 객체가 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 배치되면 다를 수 있습니다).</p>
<p><a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a>가 실행될 때:</p>
<ul class="simple">
<li><p>파이썬 모듈의 코드가 다시 컴파일되고 모듈 수준 코드가 다시 실행되어, 원래 모듈을 로드한 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>를 재사용하여 모듈 딕셔너리에 있는 이름에 연결되는 새로운 객체 집합을 정의합니다. 확장 모듈의 <code class="docutils literal notranslate"><span class="pre">init</span></code> 함수는 두 번째에는 호출되지 않습니다.</p></li>
<li><p>파이썬의 다른 모든 객체와 마찬가지로 이전 객체는 참조 횟수가 0으로 떨어진 후에 만 자원이 회수됩니다.</p></li>
<li><p>모듈 이름 공간의 이름은 새로운 객체나 변경된 객체를 가리키도록 갱신됩니다.</p></li>
<li><p>이전 객체에 대한 다른 참조(가령 모듈 외부의 이름)는 새 객체를 참조하기 위해 다시 연결되지 않으며 필요하다면 그들이 등장하는 각 이름 공간에서 갱신되어야 합니다.</p></li>
</ul>
<p>다른 여러 가지 경고가 있습니다:</p>
<p>모듈을 다시 로드할 때, 그것의 (모듈의 전역 변수를 포함하는) 딕셔너리가 유지됩니다. 이름을 재정의하면 이전 정의를 대체해서, 일반적으로 문제가 되지 않습니다. 새 버전의 모듈이 이전 버전이 정의한 이름을 정의하지 않으면, 이전 정의가 그대로 남습니다. 이 기능은 객체의 전역 테이블이나 캐시를 유지한다면 모듈의 이점으로 사용될 수 있습니다 --- <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문으로 테이블의 존재를 검사하고 필요하다면 초기화를 건너뛸 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">cache</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p>일반적으로 내장이나 동적으로 로드된 모듈을 다시 로드하는 것은 그리 유용하지 않습니다. <a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>, <a class="reference internal" href="__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a>, <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 및 기타 주요 모듈을 다시 로드하지 않는 것이 좋습니다. 많은 경우 확장 모듈은 두 번 이상 초기화되도록 설계되지 않았으며, 다시로드 할 때 임의의 방식으로 실패할 수 있습니다.</p>
<p>모듈이 <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> ... <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> ...를 사용하여 다른 모듈에서 객체를 임포트하면, 다른 모듈에 대해 <a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a>를 호출해도 그것에서 임포트한 객체를 재정의하지 않습니다 --- 이것을 피하는 한가지 방법은 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code> 문을 다시 실행하는 것입니다, 다른 방법은 대신 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>와 정규화된 이름(<em>module.name</em>)을 사용하는 것입니다.</p>
<p>모듈이 클래스의 인스턴스를 인스턴스화하면, 클래스를 정의하는 모듈을 다시 로드해도 인스턴스의 메서드 정의에는 영향을 미치지 않습니다 --- 이전 클래스 정의를 계속 사용합니다. 파생 클래스의 경우도 마찬가지입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>다시 로드되는 모듈에 <code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code>이 없으면 <a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a>가 발생합니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-importlib.abc">
<span id="importlib-abc-abstract-base-classes-related-to-import"></span><h2><a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> -- import와 관련된 추상 베이스 클래스<a class="headerlink" href="#module-importlib.abc" title="제목 주소">¶</a></h2>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/importlib/abc.py">Lib/importlib/abc.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> 모듈에는 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>에서 사용하는 모든 핵심 추상 베이스 클래스가 포함되어 있습니다. 핵심 ABC 구현에 도움이 되도록 핵심 추상 베이스 클래스의 일부 서브 클래스도 제공됩니다.</p>
<p>ABC 계층:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">object</span>
 <span class="o">+--</span> <span class="n">Finder</span> <span class="p">(</span><span class="n">deprecated</span><span class="p">)</span>
 <span class="o">|</span>    <span class="o">+--</span> <span class="n">MetaPathFinder</span>
 <span class="o">|</span>    <span class="o">+--</span> <span class="n">PathEntryFinder</span>
 <span class="o">+--</span> <span class="n">Loader</span>
      <span class="o">+--</span> <span class="n">ResourceLoader</span> <span class="o">--------+</span>
      <span class="o">+--</span> <span class="n">InspectLoader</span>          <span class="o">|</span>
           <span class="o">+--</span> <span class="n">ExecutionLoader</span> <span class="o">--+</span>
                                 <span class="o">+--</span> <span class="n">FileLoader</span>
                                 <span class="o">+--</span> <span class="n">SourceLoader</span>
</pre></div>
</div>
<dl class="class">
<dt id="importlib.abc.Finder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">Finder</code><a class="headerlink" href="#importlib.abc.Finder" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">파인더</span></a>를 나타내는 추상 베이스 클래스.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaPathFinder</span></code></a>나 <a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathEntryFinder</span></code></a>를 사용하십시오.</p>
</div>
<dl class="method">
<dt id="importlib.abc.Finder.find_module">
<em class="property">abstractmethod </em><code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Finder.find_module" title="정의 주소">¶</a></dt>
<dd><p>지정된 모듈의 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>를 찾는 추상 메서드. 원래 <span class="target" id="index-31"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>에 지정된, 이 메서드는 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>와 경로 기반 임포트 서브 시스템에서 사용하기위한 것입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>호출하면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시키는 대신 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.MetaPathFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">MetaPathFinder</code><a class="headerlink" href="#importlib.abc.MetaPathFinder" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">메타 경로 파인더</span></a>를 나타내는 추상 베이스 클래스. 호환성을 위해, <a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code></a>의 서브 클래스입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<dl class="method">
<dt id="importlib.abc.MetaPathFinder.find_spec">
<code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path</em>, <em class="sig-param">target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_spec" title="정의 주소">¶</a></dt>
<dd><p>지정된 모듈의 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">스펙</span></a>을 찾는 추상 메서드. 최상위 임포트 인 경우, <em>path</em>는 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. 그렇지 않으면, 이것은 서브 패키지나 모듈의 검색이 되고, <em>path</em>는 부모 패키지의 <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> 값입니다. 스펙을 찾을 수 없으면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다. 전달될 때, <code class="docutils literal notranslate"><span class="pre">target</span></code>은 파인더가 반환할 스펙에 대해 더 정교하게 추측하기 위해 사용할 수 있는 모듈 객체입니다. <a class="reference internal" href="#importlib.util.spec_from_loader" title="importlib.util.spec_from_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.spec_from_loader()</span></code></a>는 구상 <code class="docutils literal notranslate"><span class="pre">MetaPathFinders</span></code>를 구현하는 데 유용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.MetaPathFinder.find_module">
<code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_module" title="정의 주소">¶</a></dt>
<dd><p>지정된 모듈에 대한 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>를 찾기위한 레거시 메서드. 최상위 임포트 인 경우, <em>path</em>는 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. 그렇지 않으면, 이것은 서브 패키지나 모듈의 검색이 되고, <em>path</em>는 부모 패키지의 <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> 값입니다. 로더를 찾을 수 없으면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다.</p>
<p><a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>이 정의되면, 이전 버전과 호환되는 기능이 제공됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>호출하면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시키는 대신 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>을 사용하여 기능을 제공할 수 있습니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.MetaPathFinder.invalidate_caches">
<code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.invalidate_caches" title="정의 주소">¶</a></dt>
<dd><p>호출될 때, 파인더가 사용하는 내부 캐시를 무효화해야하는 선택적 메서드. <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>에서 모든 파인더의 캐시를 무효화할 때 <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a>에서 사용합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>호출될 때 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 대신 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.PathEntryFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">PathEntryFinder</code><a class="headerlink" href="#importlib.abc.PathEntryFinder" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a>를 나타내는 추상 베이스 클래스. <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaPathFinder</span></code></a>와 일부 유사하지만, <code class="docutils literal notranslate"><span class="pre">PathEntryFinder</span></code>는 <code class="xref py py-class docutils literal notranslate"><span class="pre">PathFinder</span></code>가 제공하는 경로 기반 임포트 서브 시스템 내에서만 사용하려는 것입니다. 이 ABC는 호환성을 위해서만 <a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code></a>의 서브 클래스입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<dl class="method">
<dt id="importlib.abc.PathEntryFinder.find_spec">
<code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_spec" title="정의 주소">¶</a></dt>
<dd><p>지정된 모듈의 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">스펙</span></a>을 찾는 추상 메서드. 파인더는 할당된 <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">경로 엔트리</span></a> 내에서만 모듈을 검색합니다. 스펙을 찾을 수 없으면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다. 전달될 때, <code class="docutils literal notranslate"><span class="pre">target</span></code>은 파인더가 반환할 스펙에 대해 더 정교하게 추측하기 위해 사용할 수 있는 모듈 객체입니다. <a class="reference internal" href="#importlib.util.spec_from_loader" title="importlib.util.spec_from_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.spec_from_loader()</span></code></a>는 구상 <code class="docutils literal notranslate"><span class="pre">PathEntryFinders</span></code>를 구현하는 데 유용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PathEntryFinder.find_loader">
<code class="sig-name descname">find_loader</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_loader" title="정의 주소">¶</a></dt>
<dd><p>지정된 모듈에 대한 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>를 찾기 위한 레거시 메서드. <code class="docutils literal notranslate"><span class="pre">(loader,</span> <span class="pre">portion)</span></code>의 2-튜플을 반환하는데, <code class="docutils literal notranslate"><span class="pre">portion</span></code>은 이름 공간 패키지의 일부에 기여하는 파일 시스템 위치의 시퀀스입니다. 파일 시스템 위치가 이름 공간 패키지에 기여 함을 나타내도록 <code class="docutils literal notranslate"><span class="pre">portion</span></code>을 지정하는 동안 로더는 <code class="docutils literal notranslate"><span class="pre">None</span></code>일 수 있습니다. 로더가 이름 공간 패키지의 일부가 아님을 표시하기 위해 <code class="docutils literal notranslate"><span class="pre">portion</span></code>에 빈 리스트를 사용할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">loader</span></code>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이고 <code class="docutils literal notranslate"><span class="pre">portion</span></code>이 빈 리스트이면 이름 공간 패키지의 로더나 위치가 발견되지 않은 것입니다 (즉 모듈에 대해 아무것도 찾지 못했습니다).</p>
<p><a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>이 정의되면 이전 버전과 호환되는 기능이 제공됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시키는 대신 <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">[])</span></code>를 반환합니다. 가능하다면 기능을 제공하기 위해 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>을 사용하십시오.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PathEntryFinder.find_module">
<code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_module" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self.find_loader(fullname)[0]</span></code>와 동등한 <a class="reference internal" href="#importlib.abc.Finder.find_module" title="importlib.abc.Finder.find_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Finder.find_module()</span></code></a>의 구상 구현.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PathEntryFinder.invalidate_caches">
<code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="정의 주소">¶</a></dt>
<dd><p>호출될 때, 파인더가 사용하는 내부 캐시를 무효화해야하는 선택적 메서드. 모든 캐시 된 파인더의 캐시를 무효화 할 때 <code class="xref py py-meth docutils literal notranslate"><span class="pre">PathFinder.invalidate_caches()</span></code>에서 사용합니다.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.Loader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">Loader</code><a class="headerlink" href="#importlib.abc.Loader" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>의 추상 베이스 클래스. 로더에 대한 정확한 정의는 <span class="target" id="index-32"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>를 참조하십시오.</p>
<p>리소스 읽기를 지원하려는 로더는 <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a>에 지정된대로 <code class="docutils literal notranslate"><span class="pre">get_resource_reader(fullname)</span></code> 메서드를 구현해야합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>선택적 <code class="docutils literal notranslate"><span class="pre">get_resource_reader()</span></code> 메서드를 도입했습니다.</p>
</div>
<dl class="method">
<dt id="importlib.abc.Loader.create_module">
<code class="sig-name descname">create_module</code><span class="sig-paren">(</span><em class="sig-param">spec</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.create_module" title="정의 주소">¶</a></dt>
<dd><p>모듈을 임포트할 때 사용할 모듈 객체를 반환하는 메서드. 이 메서드는 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환해서 기본 모듈 생성 시맨틱이 적용되어야 함을 나타낼 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>파이썬 3.6부터는, <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>이 정의 될 때 이 메서드는 선택 사항이 아닙니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.Loader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.exec_module" title="정의 주소">¶</a></dt>
<dd><p>모듈을 임포트하거나 다시 로드 할 때 자체 이름 공간에서 모듈을 실행하는 추상 메서드. <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code>이 호출될 때 모듈이 이미 초기화되어 있어야합니다. 이 메서드가 존재하면, <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>을 정의해야합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>도 정의해야합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.Loader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.load_module" title="정의 주소">¶</a></dt>
<dd><p>모듈을 로드하는 레거시 메서드. 모듈을로드 할 수 없으면, <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>가 발생하고, 그렇지 않으면 로드 된 모듈이 반환됩니다.</p>
<p>요청된 모듈이 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 이미 존재하면, 해당 모듈이 사용되고 다시 로드되어야 합니다. 그렇지 않으면 로더는 임포트에서 재귀를 방지하기 위해로드를 시작하기 전에 새 모듈을 만들어 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 삽입해야합니다. 로더가 모듈을 삽입했는데 로드에 실패하면, 로더가 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에서 모듈을 제거해야합니다; 로더가 실행을 시작하기 전에 이미 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 있었던 모듈은 그대로 두어야합니다 (<a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a>를 참조하십시오).</p>
<p>로더는 모듈에서 여러 어트리뷰트를 설정해야합니다. (이러한 어트리뷰트 중 일부는 모듈을 다시 로드 할 때 변경될 수 있습니다):</p>
<ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>모듈의 이름</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a></dt><dd><p>모듈 데이터가 저장되는 경로입니다 (내장 모듈에는 설정되지 않습니다).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__cached__" title="__cached__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code></a></dt><dd><p>모듈의 컴파일 된 버전이 저장되는/저장되어야 하는 경로 (어트리뷰트가 부적절하면 설정되지 않습니다).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a></dt><dd><p>패키지 내에서 검색 경로를 지정하는 문자열 리스트. 이 어트리뷰트는 모듈에는 설정되지 않습니다.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a></dt><dd><p>모듈/패키지의 부모 패키지. 모듈이 최상위 수준이면 빈 문자열 값을 갖습니다. <a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a> 데코레이터는 <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>의 세부 사항을 처리할 수 있습니다.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a></dt><dd><p>모듈을 로드하는 데 사용되는 로더. <a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a> 데코레이터는 <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>의 세부 사항을 처리 할 수 있습니다.</p>
</dd>
</dl>
</li>
</ul>
<p><a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>을 사용할 수 있으면 이전 버전과 호환되는 기능이 제공됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>호출될 때 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다. <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>을 사용할 수 있을 때 제공되는 기능.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>모듈 로드에 권장되는 API는 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>(및 <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>)입니다. 로더는 load_module() 대신 이것을 구현해야합니다. 임포트 절차는 exec_module()이 구현 될 때 load_module()의 다른 모든 책임을 처리합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.Loader.module_repr">
<code class="sig-name descname">module_repr</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.module_repr" title="정의 주소">¶</a></dt>
<dd><p>구현될 때 지정된 모듈의 repr을 문자열로 계산하고 반환하는 레거시 메서드. 모듈 형의 기본 repr()은 이 메서드의 결과를 적절하게 사용합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>abstractmethod 대신에 선택 사항으로 만들어졌습니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>임포트 절차는 이제 이것을 자동으로 처리합니다.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.ResourceReader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">ResourceReader</code><a class="headerlink" href="#importlib.abc.ResourceReader" title="정의 주소">¶</a></dt>
<dd><p><em>리소스(resources)</em>를 읽을 수 있는 기능을 제공하는 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">추상 베이스 클래스</span></a>.</p>
<p>이 ABC의 관점에서, <em>리소스(resource)</em>는 패키지 내에 제공되는 바이너리 아티팩트(artifact)입니다. 일반적으로 이것은 패키지의 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일 옆에 있는 데이터 파일같은 것입니다. 이 클래스의 목적은 이러한 데이터 파일에 대한 액세스를 추상화하여 패키지와 해당 데이터 파일이 예를 들어 zip 파일에 있는지 파일 시스템에 저장되어 있는지가 중요하지 않도록 만드는 것입니다.</p>
<p>이 클래스의 모든 메서드에서, <em>resource</em> 인자는 개념적으로 단지 파일 이름을 나타내는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>가 될 것으로 기대됩니다. 이는 <em>resource</em> 인자에 서브 디렉터리 경로가 포함되지 않아야 함을 의미합니다. 판독기(reader)가 읽으려는 패키지의 위치가 &quot;디렉터리&quot;의 역할을 하기 때문입니다. 따라서 디렉터리와 파일 이름에 대한 은유는 각각 패키지와 리소스입니다. 이것은 또한 이 클래스의 인스턴스가 (잠재적으로 여러 패키지나 모듈을 나타내는 대신) 특정 패키지와 직접적으로 연관될 것으로 기대되는 이유입니다.</p>
<p>리소스 읽기를 지원하려는 로더는 이 ABC의 인터페이스를 구현하는 객체를 반환하는 <code class="docutils literal notranslate"><span class="pre">get_resource_reader(fullname)</span></code>이라는 메서드를 제공해야 합니다. fullname으로 지정된 모듈이 패키지가 아니면, 이 메서드는 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환해야합니다. 이 ABC와 호환되는 객체는 지정된 모듈이 패키지일 때만 반환해야합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
<dl class="method">
<dt id="importlib.abc.ResourceReader.open_resource">
<em class="property">abstractmethod </em><code class="sig-name descname">open_resource</code><span class="sig-paren">(</span><em class="sig-param">resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.open_resource" title="정의 주소">¶</a></dt>
<dd><p><em>resource</em>의 바이너리 읽기를 위해 열린 <a class="reference internal" href="../glossary.html#term-file-like-object"><span class="xref std std-term">파일류 객체</span></a>를 반환합니다.</p>
<p>리소스를 찾을 수 없으면, <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a>가 발생합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.ResourceReader.resource_path">
<em class="property">abstractmethod </em><code class="sig-name descname">resource_path</code><span class="sig-paren">(</span><em class="sig-param">resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.resource_path" title="정의 주소">¶</a></dt>
<dd><p><em>resource</em>에 대한 파일 시스템 경로를 반환합니다.</p>
<p>리소스가 파일 시스템에 구체적으로 존재하지 않으면, <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a>가 발생합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.ResourceReader.is_resource">
<em class="property">abstractmethod </em><code class="sig-name descname">is_resource</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.is_resource" title="정의 주소">¶</a></dt>
<dd><p>명명된 <em>name</em>이 리소스로 간주되면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다. <em>name</em>이 없으면, <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a>가 발생합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.ResourceReader.contents">
<em class="property">abstractmethod </em><code class="sig-name descname">contents</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.contents" title="정의 주소">¶</a></dt>
<dd><p>패키지 내용에 대한 문자열의 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">이터러블</span></a>을 반환합니다. 이터레이터가 반환한 모든 이름이 실제 리소스일 필요는 없음에 유의하십시오, 예를 들어 <a class="reference internal" href="#importlib.abc.ResourceReader.is_resource" title="importlib.abc.ResourceReader.is_resource"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_resource()</span></code></a>가 거짓인 이름을 반환하는 것이 허용됩니다.</p>
<p>리소스가 아닌 이름이 반환되도록 하는 것은 패키지와 그것의 리소스가 저장되는 방법이 사전에 알려져있고 우선적으로 알고 리소스가 아닌 이름이 유용한 상황을 허용하기 위함입니다. 예를 들어, 패키지와 리소스가 파일 시스템에 저장되어있는 것으로 알려졌을 때 해당 서브 디렉터리 이름을 직접 사용할 수 있도록 서브 디렉터리 이름 반환이 허용됩니다.</p>
<p>추상 메서드는 항목이 없는 이터러블을 반환합니다.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.ResourceLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">ResourceLoader</code><a class="headerlink" href="#importlib.abc.ResourceLoader" title="정의 주소">¶</a></dt>
<dd><p>스토리지 백엔드에서 임의의 리소스를 로드하기위한 선택적 <span class="target" id="index-33"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 프로토콜을 구현하는 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>의 추상 베이스 클래스.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.7부터 폐지: </span>이 ABC는 폐지되었고 <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a>를 통한 리소스 로드 지원으로 대체되었습니다.</p>
</div>
<dl class="method">
<dt id="importlib.abc.ResourceLoader.get_data">
<em class="property">abstractmethod </em><code class="sig-name descname">get_data</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceLoader.get_data" title="정의 주소">¶</a></dt>
<dd><p><em>path</em>에 있는 데이터를 바이트열로 반환하는 추상 메서드. 임의의 데이터를 저장할 수 있는 파일류 스토리지 백엔드가 있는 로더는 이 추상 메서드를 구현하여 저장된 데이터에 직접 액세스 하도록 할 수 있습니다. <em>path</em>를 찾을 수 없으면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다. <em>path</em>는 모듈의 <a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 어트리뷰트나 패키지의 <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a>에서 온 항목을 사용하여 구성될 것으로 기대됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.InspectLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">InspectLoader</code><a class="headerlink" href="#importlib.abc.InspectLoader" title="정의 주소">¶</a></dt>
<dd><p>모듈을 검사(inspect)하는 로더을 위한 선택적 <span class="target" id="index-34"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 프로토콜을 구현하는 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>의 추상 베이스 클래스.</p>
<dl class="method">
<dt id="importlib.abc.InspectLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_code" title="정의 주소">¶</a></dt>
<dd><p>모듈에 대한 코드 객체나, 모듈에 코드 객체가 없으면 (예를 들어 내장 모듈이 이런 경우입니다) <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 로더가 요청한 모듈을 찾을 수 없으면 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>가 발생합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 메서드에는 기본 구현이 있지만, 가능하다면 성능을 위해 재정의하는 것이 좋습니다.</p>
</div>
<div class="versionchanged" id="index-16">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>더는 추상적이지 않고 구상 구현이 제공됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.get_source">
<em class="property">abstractmethod </em><code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_source" title="정의 주소">¶</a></dt>
<dd><p>모듈의 소스를 반환하는 추상 메서드. 인식된 모든 줄 구분자를 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 문자로 변환하는 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">유니버설 줄 넘김</span></a>을 사용하여 텍스트 문자열로 반환됩니다. 사용 가능한 소스가 없으면 (예를 들어 내장 모듈) <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 로더가 지정된 모듈을 찾을 수 없으면 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.is_package" title="정의 주소">¶</a></dt>
<dd><p>모듈이 패키지이면 참값을 반환하고, 그렇지 않으면 거짓값을 반환하는 추상 메서드. <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>가 모듈을 찾을 수 없으면 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>가 발생합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.source_to_code">
<em class="property">static </em><code class="sig-name descname">source_to_code</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">path='&lt;string&gt;'</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.source_to_code" title="정의 주소">¶</a></dt>
<dd><p>파이썬 소스에서 코드 객체를 만듭니다.</p>
<p><em>data</em> 인자는 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 함수가 지원하는 것은 무엇이든 될 수 있습니다 (즉 문자열이나 바이트열). <em>path</em> 인자는 소스 코드가 온 곳의 &quot;경로&quot;여야하며, 추상 개념(예를 들어 zip 파일에서의 위치)일 수 있습니다.</p>
<p>후속 코드 객체를 사용하면 <code class="docutils literal notranslate"><span class="pre">exec(code,</span> <span class="pre">module.__dict__)</span></code>를 실행하여 그 코드를 모듈에서 실행할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>메서드를 정적(static)으로 만들었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.exec_module" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>의 구현.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.load_module" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>의 구현.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.InspectLoader.exec_module" title="importlib.abc.InspectLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.ExecutionLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">ExecutionLoader</code><a class="headerlink" href="#importlib.abc.ExecutionLoader" title="정의 주소">¶</a></dt>
<dd><p>구현될 때, 모듈이 스크립트로 실행되도록 돕는 <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">InspectLoader</span></code></a>에서 상속되는 추상 베이스 클래스. ABC는 선택적 <span class="target" id="index-35"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 프로토콜을 표현합니다.</p>
<dl class="method">
<dt id="importlib.abc.ExecutionLoader.get_filename">
<em class="property">abstractmethod </em><code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ExecutionLoader.get_filename" title="정의 주소">¶</a></dt>
<dd><p>지정된 모듈의 <a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 값을 반환하는 추상 메서드. 사용 가능한 경로가 없으면 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>가 발생합니다.</p>
<p>소스 코드가 사용 가능하면, 메서드는 모듈을 로드하는데 바이트 코드를 사용했는지에 관계없이 소스 파일의 경로를 반환해야합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.FileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">FileLoader</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a>와 <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>를 상속하고 <a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a>와 <a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a>의 구상 구현을 제공하는 추상 베이스 클래스.</p>
<p><em>fullname</em> 인자는 로더가 처리해야하는 모듈의 완전히 결정된(resolved) 이름입니다. <em>path</em> 인자는 모듈의 파일 경로입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.abc.FileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.abc.FileLoader.name" title="정의 주소">¶</a></dt>
<dd><p>로더가 처리할 수 있는 모듈의 이름.</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.abc.FileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.abc.FileLoader.path" title="정의 주소">¶</a></dt>
<dd><p>모듈 파일의 경로.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.FileLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.load_module" title="정의 주소">¶</a></dt>
<dd><p>super의 <code class="docutils literal notranslate"><span class="pre">load_module()</span></code>을 호출합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.FileLoader.get_filename">
<em class="property">abstractmethod </em><code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_filename" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.FileLoader.path" title="importlib.abc.FileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.FileLoader.get_data">
<em class="property">abstractmethod </em><code class="sig-name descname">get_data</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_data" title="정의 주소">¶</a></dt>
<dd><p><em>path</em>를 바이너리 파일로 읽고 그것의 바이트열을 반환합니다.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.SourceLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">SourceLoader</code><a class="headerlink" href="#importlib.abc.SourceLoader" title="정의 주소">¶</a></dt>
<dd><p>소스 (및 선택적으로 바이트 코드) 파일 로드를 구현하기위한 추상 베이스 클래스. 이 클래스는 <a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a>와 <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>를 모두 상속하며, 다음을 구현해야합니다:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a></p></li>
<li><dl class="simple">
<dt><a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a></dt><dd><p>소스 파일의 경로만 반환해야합니다; 소스 없는 로딩은 지원되지 않습니다.</p>
</dd>
</dl>
</li>
</ul>
<p>이 클래스에 의해 정의된 추상 메서드는 선택적 바이트 코드 파일 지원을 추가하는 것입니다. 이러한 선택적 메서드를 구현하지 않으면 (또는 그들이 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시키도록 하면) 로더가 소스 코드에 대해서만 작동하도록 만듭니다. 메서드를 구현하면 로더가 소스*와* 바이트 코드 파일 모두에 대해 작동하게 할 수 있습니다; 바이트 코드만 제공되는 <em>소스 없는</em> 로드는 허용하지 않습니다. 바이트 코드 파일은 파이썬 컴파일러의 구문 분석 단계를 제거하여 로딩 속도를 높이기위한 최적화라서, 바이트 코드 전용 API는 노출되지 않습니다.</p>
<dl class="method">
<dt id="importlib.abc.SourceLoader.path_stats">
<code class="sig-name descname">path_stats</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_stats" title="정의 주소">¶</a></dt>
<dd><p>지정된 경로에 대한 메타 데이터를 포함하는 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>를 반환하는 선택적 추상 메서드. 지원되는 딕셔너리 키는 다음과 같습니다:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'mtime'</span></code> (필수): 소스 코드의 수정 시간을 나타내는 정수나 부동 소수점 숫자;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'size'</span></code> (선택): 바이트 단위의 소스 코드의 크기.</p></li>
</ul>
<p>향후 확장을 위해, 딕셔너리의 다른 키는 무시됩니다. 경로를 처리할 수 없으면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.path_mtime">
<code class="sig-name descname">path_mtime</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_mtime" title="정의 주소">¶</a></dt>
<dd><p>지정된 경로의 수정 시간을 반환하는 선택적 추상 메서드.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지: </span>이 메서드는 폐지되었고 <a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">path_stats()</span></code></a>로 대체되었습니다. 구현할 필요는 없지만, 호환성을 위해 여전히 제공됩니다. 경로를 처리할 수 없으면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.set_data">
<code class="sig-name descname">set_data</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.set_data" title="정의 주소">¶</a></dt>
<dd><p>지정된 바이트열을 파일 경로에 쓰는 선택적 추상 메서드. 존재하지 않는 중간 디렉터리는 자동으로 만들어집니다.</p>
<p>경로가 읽기 전용(<a class="reference internal" href="errno.html#errno.EACCES" title="errno.EACCES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errno.EACCES</span></code></a>/<a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PermissionError</span></code></a>)이라서 경로에 쓰지 못할 때 예외를 전파하지 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>호출할 때 더는 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시키지 않습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_code" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.InspectLoader.get_code" title="importlib.abc.InspectLoader.get_code"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_code()</span></code></a>의 구상 구현.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.exec_module" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>의 구상 구현.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.load_module" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>의 구상 구현.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.SourceLoader.exec_module" title="importlib.abc.SourceLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.get_source">
<code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_source" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_source()</span></code></a>의 구상 구현.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.is_package" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code></a>의 구상 구현. (<a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a>에서 제공되는) 파일 경로가 파일 확장자를 제거했을 때 <code class="docutils literal notranslate"><span class="pre">__init__</span></code>라는 이름의 파일이고 <em>동시에</em> 모듈 이름 자체가 <code class="docutils literal notranslate"><span class="pre">__init__</span></code>로 끝나지 않으면 모듈은 패키지로 결정됩니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-importlib.resources">
<span id="importlib-resources-resources"></span><h2><a class="reference internal" href="#module-importlib.resources" title="importlib.resources: Package resource reading, opening, and access"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code></a> -- 리소스<a class="headerlink" href="#module-importlib.resources" title="제목 주소">¶</a></h2>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/importlib/resources.py">Lib/importlib/resources.py</a></p>
<hr class="docutils" />
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
<p>이 모듈은 파이썬의 임포트 시스템을 활용하여 <em>패키지(packages)</em> 안에 있는 <em>리소스(resources)</em>에 대한 액세스를 제공합니다. 패키지를 임포트할 수 있으면, 해당 패키지 내의 리소스에 액세스 할 수 있습니다. 바이너리나 텍스트 모드로 리소스를 열거나 읽을 수 있습니다.</p>
<p>리소스는 디렉터리 내의 파일과 거의 비슷하지만, 이것은 단지 은유라는 점을 명심해야합니다. 리소스와 패키지가 파일 시스템에 실제 파일과 디렉터리로 존재할 필요는 <strong>없습니다</strong>.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 모듈은 <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html">pkg_resources</a> <a class="reference external" href="http://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-resource-access">Basic Resource Access</a>와 유사한 기능을 제공합니다만, 이 패키지의 성능 오버 헤드가 없습니다. 이는 더 안정적이고 일관된 의미론으로, 패키지에 포함된 리소스를 더 쉽게 읽을 수 있도록 합니다.</p>
<p>이 모듈의 독립형 역이식은 <a class="reference external" href="http://importlib-resources.readthedocs.io/en/latest/using.html">using importlib.resources</a>와 <a class="reference external" href="http://importlib-resources.readthedocs.io/en/latest/migration.html">migrating from pkg_resources to importlib.resources</a>에서 자세한 정보를 제공합니다.</p>
</div>
<p>리소스 읽기를 지원하려는 로더는 <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a>에 지정된대로 <code class="docutils literal notranslate"><span class="pre">get_resource_reader(fullname)</span></code> 메서드를 구현해야합니다.</p>
<p>다음과 같은 형이 정의됩니다.</p>
<dl class="data">
<dt id="importlib.resources.Package">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">Package</code><a class="headerlink" href="#importlib.resources.Package" title="정의 주소">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">Package</span></code> type is defined as <code class="docutils literal notranslate"><span class="pre">Union[str,</span> <span class="pre">ModuleType]</span></code>.  This means
that where the function describes accepting a <code class="docutils literal notranslate"><span class="pre">Package</span></code>, you can pass in
either a string or a module.  Module objects must have a resolvable
<code class="docutils literal notranslate"><span class="pre">__spec__.submodule_search_locations</span></code> that is not <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="data">
<dt id="importlib.resources.Resource">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">Resource</code><a class="headerlink" href="#importlib.resources.Resource" title="정의 주소">¶</a></dt>
<dd><p>This type describes the resource names passed into the various functions
in this package.  This is defined as <code class="docutils literal notranslate"><span class="pre">Union[str,</span> <span class="pre">os.PathLike]</span></code>.</p>
</dd></dl>

<p>The following functions are available.</p>
<dl class="function">
<dt id="importlib.resources.open_binary">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">open_binary</code><span class="sig-paren">(</span><em class="sig-param">package</em>, <em class="sig-param">resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.open_binary" title="정의 주소">¶</a></dt>
<dd><p>Open for binary reading the <em>resource</em> within <em>package</em>.</p>
<p><em>package</em> is either a name or a module object which conforms to the
<code class="docutils literal notranslate"><span class="pre">Package</span></code> requirements.  <em>resource</em> is the name of the resource to open
within <em>package</em>; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).  This function returns a
<code class="docutils literal notranslate"><span class="pre">typing.BinaryIO</span></code> instance, a binary I/O stream open for reading.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.open_text">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">open_text</code><span class="sig-paren">(</span><em class="sig-param">package</em>, <em class="sig-param">resource</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.open_text" title="정의 주소">¶</a></dt>
<dd><p>Open for text reading the <em>resource</em> within <em>package</em>.  By default, the
resource is opened for reading as UTF-8.</p>
<p><em>package</em> is either a name or a module object which conforms to the
<code class="docutils literal notranslate"><span class="pre">Package</span></code> requirements.  <em>resource</em> is the name of the resource to open
within <em>package</em>; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).  <em>encoding</em> and <em>errors</em>
have the same meaning as with built-in <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p>
<p>This function returns a <code class="docutils literal notranslate"><span class="pre">typing.TextIO</span></code> instance, a text I/O stream open
for reading.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.read_binary">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">read_binary</code><span class="sig-paren">(</span><em class="sig-param">package</em>, <em class="sig-param">resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.read_binary" title="정의 주소">¶</a></dt>
<dd><p>Read and return the contents of the <em>resource</em> within <em>package</em> as
<code class="docutils literal notranslate"><span class="pre">bytes</span></code>.</p>
<p><em>package</em> is either a name or a module object which conforms to the
<code class="docutils literal notranslate"><span class="pre">Package</span></code> requirements.  <em>resource</em> is the name of the resource to open
within <em>package</em>; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).  This function returns the
contents of the resource as <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.read_text">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">read_text</code><span class="sig-paren">(</span><em class="sig-param">package</em>, <em class="sig-param">resource</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.read_text" title="정의 주소">¶</a></dt>
<dd><p>Read and return the contents of <em>resource</em> within <em>package</em> as a <code class="docutils literal notranslate"><span class="pre">str</span></code>.
By default, the contents are read as strict UTF-8.</p>
<p><em>package</em> is either a name or a module object which conforms to the
<code class="docutils literal notranslate"><span class="pre">Package</span></code> requirements.  <em>resource</em> is the name of the resource to open
within <em>package</em>; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).  <em>encoding</em> and <em>errors</em>
have the same meaning as with built-in <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.  This function
returns the contents of the resource as <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.path">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">path</code><span class="sig-paren">(</span><em class="sig-param">package</em>, <em class="sig-param">resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.path" title="정의 주소">¶</a></dt>
<dd><p>Return the path to the <em>resource</em> as an actual file system path.  This
function returns a context manager for use in a <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement.
The context manager provides a <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> object.</p>
<p>Exiting the context manager cleans up any temporary file created when the
resource needs to be extracted from e.g. a zip file.</p>
<p><em>package</em> is either a name or a module object which conforms to the
<code class="docutils literal notranslate"><span class="pre">Package</span></code> requirements.  <em>resource</em> is the name of the resource to open
within <em>package</em>; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.is_resource">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">is_resource</code><span class="sig-paren">(</span><em class="sig-param">package</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.is_resource" title="정의 주소">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if there is a resource named <em>name</em> in the package,
otherwise <code class="docutils literal notranslate"><span class="pre">False</span></code>.  Remember that directories are <em>not</em> resources!
<em>package</em> is either a name or a module object which conforms to the
<code class="docutils literal notranslate"><span class="pre">Package</span></code> requirements.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.contents">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">contents</code><span class="sig-paren">(</span><em class="sig-param">package</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.contents" title="정의 주소">¶</a></dt>
<dd><p>Return an iterable over the named items within the package.  The iterable
returns <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> resources (e.g. files) and non-resources
(e.g. directories).  The iterable does not recurse into subdirectories.</p>
<p><em>package</em> is either a name or a module object which conforms to the
<code class="docutils literal notranslate"><span class="pre">Package</span></code> requirements.</p>
</dd></dl>

</div>
<div class="section" id="module-importlib.machinery">
<span id="importlib-machinery-importers-and-path-hooks"></span><h2><a class="reference internal" href="#module-importlib.machinery" title="importlib.machinery: Importers and path hooks"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code></a> -- Importers and path hooks<a class="headerlink" href="#module-importlib.machinery" title="제목 주소">¶</a></h2>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/importlib/machinery.py">Lib/importlib/machinery.py</a></p>
<hr class="docutils" />
<p>This module contains the various objects that help <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>
find and load modules.</p>
<dl class="attribute">
<dt id="importlib.machinery.SOURCE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">SOURCE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.SOURCE_SUFFIXES" title="정의 주소">¶</a></dt>
<dd><p>A list of strings representing the recognized file suffixes for source
modules.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.DEBUG_BYTECODE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">DEBUG_BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.DEBUG_BYTECODE_SUFFIXES" title="정의 주소">¶</a></dt>
<dd><p>A list of strings representing the file suffixes for non-optimized bytecode
modules.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.5부터 폐지: </span>Use <a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">OPTIMIZED_BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES" title="정의 주소">¶</a></dt>
<dd><p>A list of strings representing the file suffixes for optimized bytecode
modules.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.5부터 폐지: </span>Use <a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.BYTECODE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.BYTECODE_SUFFIXES" title="정의 주소">¶</a></dt>
<dd><p>A list of strings representing the recognized file suffixes for bytecode
modules (including the leading dot).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>The value is no longer dependent on <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.EXTENSION_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">EXTENSION_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.EXTENSION_SUFFIXES" title="정의 주소">¶</a></dt>
<dd><p>A list of strings representing the recognized file suffixes for
extension modules.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.machinery.all_suffixes">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">all_suffixes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.all_suffixes" title="정의 주소">¶</a></dt>
<dd><p>Returns a combined list of strings representing all file suffixes for
modules recognized by the standard import machinery. This is a
helper for code which simply needs to know if a filesystem path
potentially refers to a module without needing any details on the kind
of module (for example, <a class="reference internal" href="inspect.html#inspect.getmodulename" title="inspect.getmodulename"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getmodulename()</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.BuiltinImporter">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">BuiltinImporter</code><a class="headerlink" href="#importlib.machinery.BuiltinImporter" title="정의 주소">¶</a></dt>
<dd><p>An <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> for built-in modules. All known built-in modules are
listed in <a class="reference internal" href="sys.html#sys.builtin_module_names" title="sys.builtin_module_names"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.builtin_module_names</span></code></a>. This class implements the
<a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> and
<a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a> ABCs.</p>
<p>Only class methods are defined by this class to alleviate the need for
instantiation.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>As part of <span class="target" id="index-18"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>, the builtin importer now implements
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.create_module()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.FrozenImporter">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">FrozenImporter</code><a class="headerlink" href="#importlib.machinery.FrozenImporter" title="정의 주소">¶</a></dt>
<dd><p>An <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> for frozen modules. This class implements the
<a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> and
<a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a> ABCs.</p>
<p>Only class methods are defined by this class to alleviate the need for
instantiation.</p>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.WindowsRegistryFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">WindowsRegistryFinder</code><a class="headerlink" href="#importlib.machinery.WindowsRegistryFinder" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> for modules declared in the Windows registry.  This class
implements the <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC.</p>
<p>Only class methods are defined by this class to alleviate the need for
instantiation.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.6부터 폐지: </span>Use <a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> configuration instead. Future versions of Python may
not enable this finder by default.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.PathFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">PathFinder</code><a class="headerlink" href="#importlib.machinery.PathFinder" title="정의 주소">¶</a></dt>
<dd><p>A <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> for <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> and package <code class="docutils literal notranslate"><span class="pre">__path__</span></code> attributes.
This class implements the <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC.</p>
<p>Only class methods are defined by this class to alleviate the need for
instantiation.</p>
<dl class="method">
<dt id="importlib.machinery.PathFinder.find_spec">
<em class="property">classmethod </em><code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path=None</em>, <em class="sig-param">target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_spec" title="정의 주소">¶</a></dt>
<dd><p>Class method that attempts to find a <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a>
for the module specified by <em>fullname</em> on <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> or, if
defined, on <em>path</em>. For each path entry that is searched,
<a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> is checked. If a non-false object
is found then it is used as the <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> to look
for the module being searched for. If no entry is found in
<a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>, then <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> is
searched for a finder for the path entry and, if found, is stored
in <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> along with being queried about
the module. If no finder is ever found then <code class="docutils literal notranslate"><span class="pre">None</span></code> is both
stored in the cache and returned.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>If the current working directory -- represented by an empty string --
is no longer valid then <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned but no value is cached
in <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.PathFinder.find_module">
<em class="property">classmethod </em><code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_module" title="정의 주소">¶</a></dt>
<dd><p>A legacy wrapper around <a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.PathFinder.invalidate_caches">
<em class="property">classmethod </em><code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.invalidate_caches" title="정의 주소">¶</a></dt>
<dd><p>Calls <a class="reference internal" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="importlib.abc.PathEntryFinder.invalidate_caches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder.invalidate_caches()</span></code></a> on all
finders stored in <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> that define the method.
Otherwise entries in <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> set to <code class="docutils literal notranslate"><span class="pre">None</span></code> are
deleted.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Entries of <code class="docutils literal notranslate"><span class="pre">None</span></code> in <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> are deleted.</p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>Calls objects in <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> with the current working
directory for <code class="docutils literal notranslate"><span class="pre">''</span></code> (i.e. the empty string).</p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.FileFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">FileFinder</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">*loader_details</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder" title="정의 주소">¶</a></dt>
<dd><p>A concrete implementation of <a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> which
caches results from the file system.</p>
<p>The <em>path</em> argument is the directory for which the finder is in charge of
searching.</p>
<p>The <em>loader_details</em> argument is a variable number of 2-item tuples each
containing a loader and a sequence of file suffixes the loader recognizes.
The loaders are expected to be callables which accept two arguments of
the module's name and the path to the file found.</p>
<p>The finder will cache the directory contents as necessary, making stat calls
for each module search to verify the cache is not outdated. Because cache
staleness relies upon the granularity of the operating system's state
information of the file system, there is a potential race condition of
searching for a module, creating a new file, and then searching for the
module the new file represents. If the operations happen fast enough to fit
within the granularity of stat calls, then the module search will fail. To
prevent this from happening, when you create a module dynamically, make sure
to call <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.FileFinder.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.FileFinder.path" title="정의 주소">¶</a></dt>
<dd><p>The path the finder will search in.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.FileFinder.find_spec">
<code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_spec" title="정의 주소">¶</a></dt>
<dd><p>Attempt to find the spec to handle <em>fullname</em> within <a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.FileFinder.find_loader">
<code class="sig-name descname">find_loader</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_loader" title="정의 주소">¶</a></dt>
<dd><p>Attempt to find the loader to handle <em>fullname</em> within <a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.FileFinder.invalidate_caches">
<code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.invalidate_caches" title="정의 주소">¶</a></dt>
<dd><p>Clear out the internal cache.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.FileFinder.path_hook">
<em class="property">classmethod </em><code class="sig-name descname">path_hook</code><span class="sig-paren">(</span><em class="sig-param">*loader_details</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.path_hook" title="정의 주소">¶</a></dt>
<dd><p>A class method which returns a closure for use on <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>.
An instance of <a class="reference internal" href="#importlib.machinery.FileFinder" title="importlib.machinery.FileFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileFinder</span></code></a> is returned by the closure using the
path argument given to the closure directly and <em>loader_details</em>
indirectly.</p>
<p>If the argument to the closure is not an existing directory,
<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> is raised.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.machinery.SourceFileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">SourceFileLoader</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader" title="정의 주소">¶</a></dt>
<dd><p>A concrete implementation of <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a> by
subclassing <a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a> and providing some concrete
implementations of other methods.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.SourceFileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.SourceFileLoader.name" title="정의 주소">¶</a></dt>
<dd><p>The name of the module that this loader will handle.</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.SourceFileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path" title="정의 주소">¶</a></dt>
<dd><p>The path to the source file.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.is_package" title="정의 주소">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <a class="reference internal" href="#importlib.machinery.SourceFileLoader.path" title="importlib.machinery.SourceFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> appears to be for a package.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.path_stats">
<code class="sig-name descname">path_stats</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path_stats" title="정의 주소">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.path_stats()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.set_data">
<code class="sig-name descname">set_data</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.set_data" title="정의 주소">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.SourceLoader.set_data" title="importlib.abc.SourceLoader.set_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.set_data()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.load_module" title="정의 주소">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> where
specifying the name of the module to load is optional.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.6부터 폐지: </span>Use <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> instead.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.machinery.SourcelessFileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">SourcelessFileLoader</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader" title="정의 주소">¶</a></dt>
<dd><p>A concrete implementation of <a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a> which can
import bytecode files (i.e. no source code files exist).</p>
<p>Please note that direct use of bytecode files (and thus not source code
files) inhibits your modules from being usable by all Python
implementations or new versions of Python which change the bytecode
format.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.SourcelessFileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.name" title="정의 주소">¶</a></dt>
<dd><p>The name of the module the loader will handle.</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.SourcelessFileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.path" title="정의 주소">¶</a></dt>
<dd><p>The path to the bytecode file.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.is_package" title="정의 주소">¶</a></dt>
<dd><p>Determines if the module is a package based on <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_code" title="정의 주소">¶</a></dt>
<dd><p>Returns the code object for <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.name" title="importlib.machinery.SourcelessFileLoader.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> created from <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.get_source">
<code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_source" title="정의 주소">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> as bytecode files have no source when this loader is
used.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.load_module" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>Concrete implementation of <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> where
specifying the name of the module to load is optional.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.6부터 폐지: </span>Use <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.ExtensionFileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">ExtensionFileLoader</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader" title="정의 주소">¶</a></dt>
<dd><p>A concrete implementation of <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ExecutionLoader</span></code></a> for
extension modules.</p>
<p>The <em>fullname</em> argument specifies the name of the module the loader is to
support. The <em>path</em> argument is the path to the extension module's file.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.ExtensionFileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.name" title="정의 주소">¶</a></dt>
<dd><p>Name of the module the loader supports.</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.ExtensionFileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.path" title="정의 주소">¶</a></dt>
<dd><p>Path to the extension module.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.create_module">
<code class="sig-name descname">create_module</code><span class="sig-paren">(</span><em class="sig-param">spec</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.create_module" title="정의 주소">¶</a></dt>
<dd><p>Creates the module object from the given specification in accordance
with <span class="target" id="index-19"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.exec_module" title="정의 주소">¶</a></dt>
<dd><p>Initializes the given module object in accordance with <span class="target" id="index-20"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.is_package" title="정의 주소">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the file path points to a package's <code class="docutils literal notranslate"><span class="pre">__init__</span></code>
module based on <a class="reference internal" href="#importlib.machinery.EXTENSION_SUFFIXES" title="importlib.machinery.EXTENSION_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">EXTENSION_SUFFIXES</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_code" title="정의 주소">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> as extension modules lack a code object.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.get_source">
<code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_source" title="정의 주소">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> as extension modules do not have source code.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.get_filename">
<code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_filename" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.ExtensionFileLoader.path" title="importlib.machinery.ExtensionFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.machinery.ModuleSpec">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">ModuleSpec</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">loader</em>, <em class="sig-param">*</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">loader_state=None</em>, <em class="sig-param">is_package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ModuleSpec" title="정의 주소">¶</a></dt>
<dd><p>A specification for a module's import-system-related state.  This is
typically exposed as the module's <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> attribute.  In the
descriptions below, the names in parentheses give the corresponding
attribute available directly on the module object.
E.g. <code class="docutils literal notranslate"><span class="pre">module.__spec__.origin</span> <span class="pre">==</span> <span class="pre">module.__file__</span></code>.  Note however that
while the <em>values</em> are usually equivalent, they can differ since there is
no synchronization between the two objects.  Thus it is possible to update
the module's <code class="docutils literal notranslate"><span class="pre">__path__</span></code> at runtime, and this will not be automatically
reflected in <code class="docutils literal notranslate"><span class="pre">__spec__.submodule_search_locations</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.name" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__name__</span></code>)</p>
<p>A string for the fully-qualified name of the module.</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.loader">
<code class="sig-name descname">loader</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__loader__</span></code>)</p>
<p>The loader to use for loading.  For namespace packages this should be
set to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.origin">
<code class="sig-name descname">origin</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.origin" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__file__</span></code>)</p>
<p>Name of the place from which the module is loaded, e.g. &quot;builtin&quot; for
built-in modules and the filename for modules loaded from source.
Normally &quot;origin&quot; should be set, but it may be <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default)
which indicates it is unspecified (e.g. for namespace packages).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.submodule_search_locations">
<code class="sig-name descname">submodule_search_locations</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.submodule_search_locations" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__path__</span></code>)</p>
<p>List of strings for where to find submodules, if a package (<code class="docutils literal notranslate"><span class="pre">None</span></code>
otherwise).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.loader_state">
<code class="sig-name descname">loader_state</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader_state" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>Container of extra module-specific data for use during loading (or
<code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.cached">
<code class="sig-name descname">cached</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.cached" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__cached__</span></code>)</p>
<p>String for where the compiled module should be stored (or <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.parent">
<code class="sig-name descname">parent</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.parent" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__package__</span></code>)</p>
<p>(Read-only) Fully-qualified name of the package to which the module
belongs as a submodule (or <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.has_location">
<code class="sig-name descname">has_location</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.has_location" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>Boolean indicating whether or not the module's &quot;origin&quot;
attribute refers to a loadable location.</p>
</dd></dl>

</div>
<div class="section" id="module-importlib.util">
<span id="importlib-util-utility-code-for-importers"></span><h2><a class="reference internal" href="#module-importlib.util" title="importlib.util: Utility code for importers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code></a> -- Utility code for importers<a class="headerlink" href="#module-importlib.util" title="제목 주소">¶</a></h2>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/importlib/util.py">Lib/importlib/util.py</a></p>
<hr class="docutils" />
<p>This module contains the various objects that help in the construction of
an <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>.</p>
<dl class="attribute">
<dt id="importlib.util.MAGIC_NUMBER">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">MAGIC_NUMBER</code><a class="headerlink" href="#importlib.util.MAGIC_NUMBER" title="정의 주소">¶</a></dt>
<dd><p>The bytes which represent the bytecode version number. If you need help with
loading/writing bytecode then consider <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.cache_from_source">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">cache_from_source</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">debug_override=None</em>, <em class="sig-param">*</em>, <em class="sig-param">optimization=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.cache_from_source" title="정의 주소">¶</a></dt>
<dd><p>Return the <span class="target" id="index-21"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>/<span class="target" id="index-22"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a> path to the byte-compiled file associated
with the source <em>path</em>.  For example, if <em>path</em> is <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code> the return
value would be <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code> for Python 3.2.
The <code class="docutils literal notranslate"><span class="pre">cpython-32</span></code> string comes from the current magic tag (see
<code class="xref py py-func docutils literal notranslate"><span class="pre">get_tag()</span></code>; if <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code> is not defined then
<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> will be raised).</p>
<p>The <em>optimization</em> parameter is used to specify the optimization level of the
bytecode file. An empty string represents no optimization, so
<code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code> with an <em>optimization</em> of <code class="docutils literal notranslate"><span class="pre">''</span></code> will result in a
bytecode path of <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>. <code class="docutils literal notranslate"><span class="pre">None</span></code> causes
the interpreter's optimization level to be used. Any other value's string
representation is used, so <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code> with an <em>optimization</em> of
<code class="docutils literal notranslate"><span class="pre">2</span></code> will lead to the bytecode path of
<code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc</span></code>. The string representation
of <em>optimization</em> can only be alphanumeric, else <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised.</p>
<p>The <em>debug_override</em> parameter is deprecated and can be used to override
the system's value for <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>. A <code class="docutils literal notranslate"><span class="pre">True</span></code> value is the equivalent of
setting <em>optimization</em> to the empty string. A <code class="docutils literal notranslate"><span class="pre">False</span></code> value is the same as
setting <em>optimization</em> to <code class="docutils literal notranslate"><span class="pre">1</span></code>. If both <em>debug_override</em> an <em>optimization</em>
are not <code class="docutils literal notranslate"><span class="pre">None</span></code> then <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>The <em>optimization</em> parameter was added and the <em>debug_override</em> parameter
was deprecated.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.source_from_cache">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">source_from_cache</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_from_cache" title="정의 주소">¶</a></dt>
<dd><p>Given the <em>path</em> to a <span class="target" id="index-23"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> file name, return the associated source code
file path.  For example, if <em>path</em> is
<code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code> the returned path would be
<code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>.  <em>path</em> need not exist, however if it does not conform
to <span class="target" id="index-24"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> or <span class="target" id="index-25"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a> format, a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised. If
<code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code> is not defined,
<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.decode_source">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">decode_source</code><span class="sig-paren">(</span><em class="sig-param">source_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.decode_source" title="정의 주소">¶</a></dt>
<dd><p>Decode the given bytes representing source code and return it as a string
with universal newlines (as required by
<a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.get_source()</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.resolve_name">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">resolve_name</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">package</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.resolve_name" title="정의 주소">¶</a></dt>
<dd><p>Resolve a relative module name to an absolute one.</p>
<p>If  <strong>name</strong> has no leading dots, then <strong>name</strong> is simply returned. This
allows for usage such as
<code class="docutils literal notranslate"><span class="pre">importlib.util.resolve_name('sys',</span> <span class="pre">__package__)</span></code> without doing a
check to see if the <strong>package</strong> argument is needed.</p>
<p><a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised if <strong>name</strong> is a relative module name but
package is a false value (e.g. <code class="docutils literal notranslate"><span class="pre">None</span></code> or the empty string).
<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is also raised a relative name would escape its containing
package (e.g. requesting <code class="docutils literal notranslate"><span class="pre">..bacon</span></code> from within the <code class="docutils literal notranslate"><span class="pre">spam</span></code> package).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.find_spec">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.find_spec" title="정의 주소">¶</a></dt>
<dd><p>Find the <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> for a module, optionally relative to
the specified <strong>package</strong> name. If the module is in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>,
then <code class="docutils literal notranslate"><span class="pre">sys.modules[name].__spec__</span></code> is returned (unless the spec would be
<code class="docutils literal notranslate"><span class="pre">None</span></code> or is not set, in which case <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised).
Otherwise a search using <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> is done. <code class="docutils literal notranslate"><span class="pre">None</span></code> is
returned if no spec is found.</p>
<p>If <strong>name</strong> is for a submodule (contains a dot), the parent module is
automatically imported.</p>
<p><strong>name</strong> and <strong>package</strong> work the same as for <code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Raises <a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> instead of <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> if
<strong>package</strong> is in fact not a package (i.e. lacks a <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a>
attribute).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.module_from_spec">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">module_from_spec</code><span class="sig-paren">(</span><em class="sig-param">spec</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.module_from_spec" title="정의 주소">¶</a></dt>
<dd><p>Create a new module based on <strong>spec</strong> and
<a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a>.</p>
<p>If <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a>
does not return <code class="docutils literal notranslate"><span class="pre">None</span></code>, then any pre-existing attributes will not be reset.
Also, no <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> will be raised if triggered while accessing
<strong>spec</strong> or setting an attribute on the module.</p>
<p>This function is preferred over using <a class="reference internal" href="types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> to create a
new module as <strong>spec</strong> is used to set as many import-controlled attributes on
the module as possible.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.module_for_loader">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">module_for_loader</code><a class="headerlink" href="#importlib.util.module_for_loader" title="정의 주소">¶</a></dt>
<dd><p>A <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> for <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>
to handle selecting the proper
module object to load with. The decorated method is expected to have a call
signature taking two positional arguments
(e.g. <code class="docutils literal notranslate"><span class="pre">load_module(self,</span> <span class="pre">module)</span></code>) for which the second argument
will be the module <strong>object</strong> to be used by the loader.
Note that the decorator will not work on static methods because of the
assumption of two arguments.</p>
<p>The decorated method will take in the <strong>name</strong> of the module to be loaded
as expected for a <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>. If the module is not found in
<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> then a new one is constructed. Regardless of where the
module came from, <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> set to <strong>self</strong> and <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>
is set based on what <a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.is_package()</span></code></a> returns
(if available). These attributes are set unconditionally to support
reloading.</p>
<p>If an exception is raised by the decorated method and a module was added to
<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, then the module will be removed to prevent a partially
initialized module from being in left in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>. If the module
was already in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> then it is left alone.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> and <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> are automatically set
(when possible).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>Set <a class="reference internal" href="../reference/import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>, <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>
unconditionally to support reloading.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>The import machinery now directly performs all the functionality
provided by this function.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.set_loader">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">set_loader</code><a class="headerlink" href="#importlib.util.set_loader" title="정의 주소">¶</a></dt>
<dd><p>A <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> for <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>
to set the <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a>
attribute on the returned module. If the attribute is already set the
decorator does nothing. It is assumed that the first positional argument to
the wrapped method (i.e. <code class="docutils literal notranslate"><span class="pre">self</span></code>) is what <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> should be set
to.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>Set <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> if set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, as if the attribute does not
exist.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>The import machinery takes care of this automatically.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.set_package">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">set_package</code><a class="headerlink" href="#importlib.util.set_package" title="정의 주소">¶</a></dt>
<dd><p>A <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> for <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> to set the
<a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> attribute on the returned module. If <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>
is set and has a value other than <code class="docutils literal notranslate"><span class="pre">None</span></code> it will not be changed.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>The import machinery takes care of this automatically.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.spec_from_loader">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">spec_from_loader</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">loader</em>, <em class="sig-param">*</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">is_package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_loader" title="정의 주소">¶</a></dt>
<dd><p>A factory function for creating a <code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code> instance based
on a loader.  The parameters have the same meaning as they do for
ModuleSpec.  The function uses available <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> APIs, such as
<code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code>, to fill in any missing
information on the spec.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.spec_from_file_location">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">spec_from_file_location</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">location</em>, <em class="sig-param">*</em>, <em class="sig-param">loader=None</em>, <em class="sig-param">submodule_search_locations=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_file_location" title="정의 주소">¶</a></dt>
<dd><p>A factory function for creating a <code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code> instance based
on the path to a file.  Missing information will be filled in on the
spec by making use of loader APIs and by the implication that the
module will be file-based.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>Accepts a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.source_hash">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">source_hash</code><span class="sig-paren">(</span><em class="sig-param">source_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_hash" title="정의 주소">¶</a></dt>
<dd><p>Return the hash of <em>source_bytes</em> as bytes. A hash-based <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> file embeds
the <a class="reference internal" href="#importlib.util.source_hash" title="importlib.util.source_hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">source_hash()</span></code></a> of the corresponding source file's contents in its
header.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.util.LazyLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">LazyLoader</code><span class="sig-paren">(</span><em class="sig-param">loader</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.LazyLoader" title="정의 주소">¶</a></dt>
<dd><p>A class which postpones the execution of the loader of a module until the
module has an attribute accessed.</p>
<p>This class <strong>only</strong> works with loaders that define
<a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> as control over what module type
is used for the module is required. For those same reasons, the loader's
<a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> method must return <code class="docutils literal notranslate"><span class="pre">None</span></code> or a
type for which its <code class="docutils literal notranslate"><span class="pre">__class__</span></code> attribute can be mutated along with not
using <a class="reference internal" href="../glossary.html#term-slots"><span class="xref std std-term">slots</span></a>. Finally, modules which substitute the object
placed into <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a> will not work as there is no way to properly
replace the module references throughout the interpreter safely;
<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised if such a substitution is detected.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>For projects where startup time is critical, this class allows for
potentially minimizing the cost of loading a module if it is never used.
For projects where startup time is not essential then use of this class is
<strong>heavily</strong> discouraged due to error messages created during loading being
postponed and thus occurring out of context.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>Began calling <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>, removing the
compatibility warning for <a class="reference internal" href="#importlib.machinery.BuiltinImporter" title="importlib.machinery.BuiltinImporter"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.BuiltinImporter</span></code></a> and
<a class="reference internal" href="#importlib.machinery.ExtensionFileLoader" title="importlib.machinery.ExtensionFileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ExtensionFileLoader</span></code></a>.</p>
</div>
<dl class="method">
<dt id="importlib.util.LazyLoader.factory">
<em class="property">classmethod </em><code class="sig-name descname">factory</code><span class="sig-paren">(</span><em class="sig-param">loader</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.LazyLoader.factory" title="정의 주소">¶</a></dt>
<dd><p>A static method which returns a callable that creates a lazy loader. This
is meant to be used in situations where the loader is passed by class
instead of by instance.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">suffixes</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span>
<span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span>
<span class="n">lazy_loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">LazyLoader</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="n">lazy_loader</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="examples">
<span id="importlib-examples"></span><h2>Examples<a class="headerlink" href="#examples" title="제목 주소">¶</a></h2>
<div class="section" id="importing-programmatically">
<h3>Importing programmatically<a class="headerlink" href="#importing-programmatically" title="제목 주소">¶</a></h3>
<p>To programmatically import a module, use <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib</span>

<span class="n">itertools</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;itertools&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="checking-if-a-module-can-be-imported">
<h3>Checking if a module can be imported<a class="headerlink" href="#checking-if-a-module-can-be-imported" title="제목 주소">¶</a></h3>
<p>If you need to find out if a module can be imported without actually doing the
import, then you should use <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes.</span>
<span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;itertools&#39;</span>

<span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{name!r}</span><span class="s2"> already in sys.modules&quot;</span><span class="p">)</span>
<span class="k">elif</span> <span class="p">(</span><span class="n">spec</span> <span class="p">:</span><span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># If you chose to perform the actual import ...</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{name!r}</span><span class="s2"> has been imported&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;can&#39;t find the </span><span class="si">{name!r}</span><span class="s2"> module&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="importing-a-source-file-directly">
<h3>Importing a source file directly<a class="headerlink" href="#importing-a-source-file-directly" title="제목 주소">¶</a></h3>
<p>To import a Python source file directly, use the following recipe
(Python 3.5 and newer only):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes.</span>
<span class="kn">import</span> <span class="nn">tokenize</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="vm">__file__</span>
<span class="n">module_name</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="vm">__name__</span>

<span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">spec_from_file_location</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
<span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="setting-up-an-importer">
<h3>Setting up an importer<a class="headerlink" href="#setting-up-an-importer" title="제목 주소">¶</a></h3>
<p>For deep customizations of import, you typically want to implement an
<a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>. This means managing both the <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> and <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>
side of things. For finders there are two flavours to choose from depending on
your needs: a <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a> or a <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>. The
former is what you would put on <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> while the latter is what
you create using a <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">path entry hook</span></a> on <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> which works
with <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path</span></code></a> entries to potentially create a finder. This example will
show you how to register your own importers so that import will use them (for
creating an importer for yourself, read the documentation for the appropriate
classes defined within this package):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.machinery</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes only.</span>
<span class="n">SpamMetaPathFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">PathFinder</span>
<span class="n">SpamPathEntryFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span>
<span class="n">loader_details</span> <span class="o">=</span> <span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span><span class="p">,</span>
                  <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span><span class="p">)</span>

<span class="c1"># Setting up a meta path finder.</span>
<span class="c1"># Make sure to put the finder in the proper location in the list in terms of</span>
<span class="c1"># priority.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamMetaPathFinder</span><span class="p">)</span>

<span class="c1"># Setting up a path entry finder.</span>
<span class="c1"># Make sure to put the path hook in the proper location in the list in terms</span>
<span class="c1"># of priority.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamPathEntryFinder</span><span class="o">.</span><span class="n">path_hook</span><span class="p">(</span><span class="n">loader_details</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="approximating-importlib-import-module">
<h3>Approximating <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a><a class="headerlink" href="#approximating-importlib-import-module" title="제목 주소">¶</a></h3>
<p>Import itself is implemented in Python code, making it possible to
expose most of the import machinery through importlib. The following
helps illustrate the various APIs that importlib exposes by providing an
approximate implementation of
<a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> (Python 3.4 and newer for the importlib usage,
Python 3.6 and newer for other parts of the code).</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">import_module</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An approximate implementation of import.&quot;&quot;&quot;</span>
    <span class="n">absolute_name</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">resolve_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">absolute_name</span><span class="p">:</span>
        <span class="n">parent_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">child_name</span> <span class="o">=</span> <span class="n">absolute_name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">parent_module</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="n">parent_name</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">parent_module</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">submodule_search_locations</span>
    <span class="k">for</span> <span class="n">finder</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">absolute_name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;No module named </span><span class="si">{absolute_name!r}</span><span class="s1">&#39;</span>
        <span class="k">raise</span> <span class="n">ModuleNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">absolute_name</span><span class="p">)</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">parent_module</span><span class="p">,</span> <span class="n">child_name</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">module</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> --- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>의 구현</a><ul>
<li><a class="reference internal" href="#introduction">소개</a></li>
<li><a class="reference internal" href="#functions">함수</a></li>
<li><a class="reference internal" href="#module-importlib.abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code> -- import와 관련된 추상 베이스 클래스</a></li>
<li><a class="reference internal" href="#module-importlib.resources"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code> -- 리소스</a></li>
<li><a class="reference internal" href="#module-importlib.machinery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code> -- Importers and path hooks</a></li>
<li><a class="reference internal" href="#module-importlib.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code> -- Utility code for importers</a></li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#importing-programmatically">Importing programmatically</a></li>
<li><a class="reference internal" href="#checking-if-a-module-can-be-imported">Checking if a module can be imported</a></li>
<li><a class="reference internal" href="#importing-a-source-file-directly">Importing a source file directly</a></li>
<li><a class="reference internal" href="#setting-up-an-importer">Setting up an importer</a></li>
<li><a class="reference internal" href="#approximating-importlib-import-module">Approximating <code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="runpy.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code> --- 파이썬 모듈 찾기와 실행</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="importlib.metadata.html"
                        title="다음 장">importlib.metadata 사용하기</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="importlib.metadata.html" title="importlib.metadata 사용하기"
             >다음</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy --- 파이썬 모듈 찾기와 실행"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" >모듈 임포트 하기</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>