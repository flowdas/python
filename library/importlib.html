
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>importlib --- import의 구현 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="importlib.metadata 사용하기" href="importlib.metadata.html" />
    <link rel="prev" title="runpy --- 파이썬 모듈 찾기와 실행" href="runpy.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/importlib.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="importlib.metadata.html" title="importlib.metadata 사용하기"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy --- 파이썬 모듈 찾기와 실행"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" accesskey="U">모듈 임포트 하기</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-importlib">
<span id="importlib-the-implementation-of-import"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> --- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>의 구현<a class="headerlink" href="#module-importlib" title="제목 주소">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/importlib/__init__.py">Lib/importlib/__init__.py</a></p>
<hr class="docutils" />
<div class="section" id="introduction">
<h2>소개<a class="headerlink" href="#introduction" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 패키지의 목적은 두 가지입니다. 하나는 파이썬 소스 코드에서 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문(그리고, 확장하면 <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수)의 구현을 제공하는 것입니다. 이것은 모든 파이썬 인터프리터에 이식할 수 있는 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>의 구현을 제공합니다. 또한 파이썬 이외의 프로그래밍 언어로 구현된 것보다 이해하기 쉬운 구현을 제공합니다.</p>
<p>둘째, <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>를 구현하는 구성 요소가 이 패키지에서 노출되어, 사용자가 임포트 프로세스에 참여하기 위해 자신의 사용자 지정 객체(일반적으로 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">임포터</span></a>라고 합니다)를 쉽게 만들 수 있도록 합니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><a class="reference internal" href="../reference/simple_stmts.html#import"><span class="std std-ref">임포트(import) 문</span></a></dt><dd><p><a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문의 언어 레퍼런스.</p>
</dd>
<dt><a class="reference external" href="https://www.python.org/doc/essays/packages/">패키지 명세</a></dt><dd><p>패키지의 원래 명세. 이 문서를 작성한 이후로 일부 의미가 변경되었습니다 (예를 들어 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 기반으로 하는 리디렉션).</p>
</dd>
<dt><a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수</dt><dd><p><a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문은 이 함수의 편의 문법입니다.</p>
</dd>
<dt><span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0235"><strong>PEP 235</strong></a></dt><dd><p>대소 문자를 구분하지 않는 플랫폼에서의 임포트</p>
</dd>
<dt><span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0263"><strong>PEP 263</strong></a></dt><dd><p>파이썬 소스 코드 인코딩 정의</p>
</dd>
<dt><span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a></dt><dd><p>새로운 임포트 훅</p>
</dd>
<dt><span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a></dt><dd><p>임포트: 다중 줄과 절대/상대</p>
</dd>
<dt><span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a></dt><dd><p>메인 모듈 명시적 상대 임포트</p>
</dd>
<dt><span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a></dt><dd><p>묵시적 이름 공간 패키지</p>
</dd>
<dt><span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451"><strong>PEP 451</strong></a></dt><dd><p>임포트 시스템을 위한 ModuleSpec 형</p>
</dd>
<dt><span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a></dt><dd><p>PYO 파일 제거</p>
</dd>
<dt><span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a></dt><dd><p>다단계 확장 모듈 초기화</p>
</dd>
<dt><span class="target" id="index-9"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0552"><strong>PEP 552</strong></a></dt><dd><p>결정론적 pyc</p>
</dd>
<dt><span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3120"><strong>PEP 3120</strong></a></dt><dd><p>UTF-8을 기본 소스 인코딩으로 사용하기</p>
</dd>
<dt><span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a></dt><dd><p>PYC 저장소 디렉터리</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="functions">
<h2>함수<a class="headerlink" href="#functions" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="importlib.__import__">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">__import__</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">globals=None</em>, <em class="sig-param">locals=None</em>, <em class="sig-param">fromlist=()</em>, <em class="sig-param">level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.__import__" title="정의 주소">¶</a></dt>
<dd><p>내장 <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수의 구현.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>프로그래밍 방식으로 모듈을 임포트 하려면 이 함수 대신 <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a>을 사용해야 합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.import_module">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">import_module</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.import_module" title="정의 주소">¶</a></dt>
<dd><p>모듈을 임포트 합니다. <em>name</em> 인자는 절대나 상대적인 항으로 임포트 할 모듈을 지정합니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>나 <code class="docutils literal notranslate"><span class="pre">..mod</span></code>). 이름이 상대적인 항으로 지정되면, <em>package</em> 인자는 패키지 이름을 결정하기 위한 앵커 역할을 하는 패키지 이름으로 설정해야 합니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">import_module('..mod',</span> <span class="pre">'pkg.subpkg')</span></code>는 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>를 임포트 합니다).</p>
<p><a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> 함수는 <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a> 주위를 감싸는 단순화 래퍼 역할을 합니다. 이는 함수의 모든 의미가 <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a>에서 파생됨을 뜻합니다. 이 두 함수의 가장 중요한 차이점은 <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a>이 지정된 패키지나 모듈(예를 들어 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>)을 반환하는 반면, <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>는 최상위 패키지나 모듈(예를 들어 <code class="docutils literal notranslate"><span class="pre">pkg</span></code>)을 반환한다는 것입니다.</p>
<p>인터프리터가 실행을 시작한 이후 만들어진 모듈(예를 들어, 파이썬 소스 파일을 만들면)을 동적으로 임포트 하는 경우, 임포트 시스템에서 새 모듈을 알 수 있도록 <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">invalidate_caches()</span></code></a>를 호출해야 할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>부모 패키지는 자동으로 임포트 됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.find_loader">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">find_loader</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.find_loader" title="정의 주소">¶</a></dt>
<dd><p>선택적으로 지정된 <em>path</em> 내에서, 모듈의 로더를 찾습니다. 모듈이 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 있으면, <code class="docutils literal notranslate"><span class="pre">sys.modules[name].__loader__</span></code>가 반환됩니다 (로더가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 되거나 설정되지 않지 않은 한, 그런 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다). 그렇지 않으면 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>를 사용한 검색이 수행됩니다. 로더가 발견되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다.</p>
<p>점으로 구분된 이름은 부모를 묵시적으로 임포트 되게 하지 않습니다, 그렇게 하려면 로드가 필요하고 이것이 바람직하지 않을 수 있기 때문입니다. 서브 모듈을 올바르게 임포트 하려면 서브 모듈의 모든 부모 패키지를 임포트 하고 <em>path</em>에 올바른 인자를 사용해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">__loader__</span></code>가 설정되지 않으면, 어트리뷰트가 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정되었을 때와 마찬가지로 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.invalidate_caches">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.invalidate_caches" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>에 저장된 파인더의 내부 캐시를 무효로 합니다. 파인더가 <code class="docutils literal notranslate"><span class="pre">invalidate_caches()</span></code>를 구현하면 무효화를 수행하기 위해 호출됩니다. 모든 파인더가 새로운 모듈의 존재를 알 수 있도록 프로그램이 실행되는 동안 모듈이 만들어진/설치된 경우 이 함수를 호출해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.reload">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">reload</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.reload" title="정의 주소">¶</a></dt>
<dd><p>이전에 임포트 한 <em>module</em>을 다시 로드합니다. 인자는 모듈 객체여야 해서, 이전에 성공적으로 임포트 됐어야 합니다. 외부 편집기를 사용하여 모듈 소스 파일을 편집했고 파이썬 인터프리터를 떠나지 않고 새 버전을 시험해보고 싶을 때 유용합니다. 반환 값은 모듈 객체입니다 (재 임포트로 인해 다른 객체가 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 배치되면 다를 수 있습니다).</p>
<p><a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a>가 실행될 때:</p>
<ul class="simple">
<li><p>파이썬 모듈의 코드가 다시 컴파일되고 모듈 수준 코드가 다시 실행되어, 원래 모듈을 로드한 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>를 재사용하여 모듈 딕셔너리에 있는 이름에 연결되는 새로운 객체 집합을 정의합니다. 확장 모듈의 <code class="docutils literal notranslate"><span class="pre">init</span></code> 함수는 두 번째에는 호출되지 않습니다.</p></li>
<li><p>파이썬의 다른 모든 객체와 마찬가지로 이전 객체는 참조 횟수가 0으로 떨어진 후에만 자원이 회수됩니다.</p></li>
<li><p>모듈 이름 공간의 이름은 새로운 객체나 변경된 객체를 가리키도록 갱신됩니다.</p></li>
<li><p>이전 객체에 대한 다른 참조(가령 모듈 외부의 이름)는 새 객체를 참조하기 위해 다시 연결되지 않으며 필요하다면 그들이 등장하는 각 이름 공간에서 갱신되어야 합니다.</p></li>
</ul>
<p>다른 여러 가지 경고가 있습니다:</p>
<p>모듈을 다시 로드할 때, 그것의 (모듈의 전역 변수를 포함하는) 딕셔너리가 유지됩니다. 이름을 재정의하면 이전 정의를 대체해서, 일반적으로 문제가 되지 않습니다. 새 버전의 모듈이 이전 버전이 정의한 이름을 정의하지 않으면, 이전 정의가 그대로 남습니다. 이 기능은 객체의 전역 테이블이나 캐시를 유지한다면 모듈의 이점으로 사용될 수 있습니다 --- <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문으로 테이블의 존재를 검사하고 필요하다면 초기화를 건너뛸 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">cache</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p>일반적으로 내장이나 동적으로 로드된 모듈을 다시 로드하는 것은 그리 유용하지 않습니다. <a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>, <a class="reference internal" href="__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a>, <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 및 기타 주요 모듈을 다시 로드하지 않는 것이 좋습니다. 많은 경우 확장 모듈은 두 번 이상 초기화되도록 설계되지 않았으며, 다시 로드할 때 임의의 방식으로 실패할 수 있습니다.</p>
<p>모듈이 <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> ... <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> ...를 사용하여 다른 모듈에서 객체를 임포트 하면, 다른 모듈에 대해 <a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a>를 호출해도 그것에서 임포트 한 객체를 재정의하지 않습니다 --- 이것을 피하는 한 가지 방법은 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code> 문을 다시 실행하는 것입니다, 다른 방법은 대신 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>와 정규화된 이름(<em>module.name</em>)을 사용하는 것입니다.</p>
<p>모듈이 클래스의 인스턴스를 인스턴스 화하면, 클래스를 정의하는 모듈을 다시 로드해도 인스턴스의 메서드 정의에는 영향을 미치지 않습니다 --- 이전 클래스 정의를 계속 사용합니다. 파생 클래스의 경우도 마찬가지입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>다시 로드되는 모듈에 <code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code>이 없으면 <a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 가 발생합니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-importlib.abc">
<span id="importlib-abc-abstract-base-classes-related-to-import"></span><h2><a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> -- import와 관련된 추상 베이스 클래스<a class="headerlink" href="#module-importlib.abc" title="제목 주소">¶</a></h2>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/importlib/abc.py">Lib/importlib/abc.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> 모듈에는 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>에서 사용하는 모든 핵심 추상 베이스 클래스가 포함되어 있습니다. 핵심 ABC 구현에 도움이 되도록 핵심 추상 베이스 클래스의 일부 서브 클래스도 제공됩니다.</p>
<p>ABC 계층:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">object</span>
 <span class="o">+--</span> <span class="n">Finder</span> <span class="p">(</span><span class="n">deprecated</span><span class="p">)</span>
 <span class="o">|</span>    <span class="o">+--</span> <span class="n">MetaPathFinder</span>
 <span class="o">|</span>    <span class="o">+--</span> <span class="n">PathEntryFinder</span>
 <span class="o">+--</span> <span class="n">Loader</span>
      <span class="o">+--</span> <span class="n">ResourceLoader</span> <span class="o">--------+</span>
      <span class="o">+--</span> <span class="n">InspectLoader</span>          <span class="o">|</span>
           <span class="o">+--</span> <span class="n">ExecutionLoader</span> <span class="o">--+</span>
                                 <span class="o">+--</span> <span class="n">FileLoader</span>
                                 <span class="o">+--</span> <span class="n">SourceLoader</span>
</pre></div>
</div>
<dl class="class">
<dt id="importlib.abc.Finder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">Finder</code><a class="headerlink" href="#importlib.abc.Finder" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">파인더</span></a>를 나타내는 추상 베이스 클래스.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaPathFinder</span></code></a>나 <a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathEntryFinder</span></code></a>를 사용하십시오.</p>
</div>
<dl class="method">
<dt id="importlib.abc.Finder.find_module">
<em class="property">abstractmethod </em><code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Finder.find_module" title="정의 주소">¶</a></dt>
<dd><p>지정된 모듈의 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>를 찾는 추상 메서드. 원래 <span class="target" id="index-39"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>에 지정된, 이 메서드는 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>와 경로 기반 임포트 서브 시스템에서 사용하기 위한 것입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>호출하면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시키는 대신 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.MetaPathFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">MetaPathFinder</code><a class="headerlink" href="#importlib.abc.MetaPathFinder" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">메타 경로 파인더</span></a>를 나타내는 추상 베이스 클래스. 호환성을 위해, <a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code></a>의 서브 클래스입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<dl class="method">
<dt id="importlib.abc.MetaPathFinder.find_spec">
<code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path</em>, <em class="sig-param">target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_spec" title="정의 주소">¶</a></dt>
<dd><p>지정된 모듈의 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">스펙</span></a>을 찾는 추상 메서드. 최상위 임포트 인 경우, <em>path</em>는 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. 그렇지 않으면, 이것은 서브 패키지나 모듈의 검색이 되고, <em>path</em>는 부모 패키지의 <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> 값입니다. 스펙을 찾을 수 없으면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다. 전달될 때, <code class="docutils literal notranslate"><span class="pre">target</span></code>은 파인더가 반환할 스펙에 대해 더 정교하게 추측하기 위해 사용할 수 있는 모듈 객체입니다. <a class="reference internal" href="#importlib.util.spec_from_loader" title="importlib.util.spec_from_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.spec_from_loader()</span></code></a>는 구상 <code class="docutils literal notranslate"><span class="pre">MetaPathFinders</span></code>를 구현하는 데 유용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.MetaPathFinder.find_module">
<code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_module" title="정의 주소">¶</a></dt>
<dd><p>지정된 모듈에 대한 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>를 찾기 위한 레거시 메서드. 최상위 임포트 인 경우, <em>path</em>는 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. 그렇지 않으면, 이것은 서브 패키지나 모듈의 검색이 되고, <em>path</em>는 부모 패키지의 <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> 값입니다. 로더를 찾을 수 없으면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다.</p>
<p><a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>이 정의되면, 이전 버전과 호환되는 기능이 제공됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>호출하면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시키는 대신 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>을 사용하여 기능을 제공할 수 있습니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.MetaPathFinder.invalidate_caches">
<code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.invalidate_caches" title="정의 주소">¶</a></dt>
<dd><p>호출될 때, 파인더가 사용하는 내부 캐시를 무효로 해야 하는 선택적 메서드. <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>에서 모든 파인더의 캐시를 무효로 할 때 <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a>에서 사용합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>호출될 때 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 대신 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.PathEntryFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">PathEntryFinder</code><a class="headerlink" href="#importlib.abc.PathEntryFinder" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a>를 나타내는 추상 베이스 클래스. <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaPathFinder</span></code></a>와 일부 유사하지만, <code class="docutils literal notranslate"><span class="pre">PathEntryFinder</span></code>는 <code class="xref py py-class docutils literal notranslate"><span class="pre">PathFinder</span></code>가 제공하는 경로 기반 임포트 서브 시스템 내에서만 사용하려는 것입니다. 이 ABC는 호환성을 위해서만 <a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code></a>의 서브 클래스입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<dl class="method">
<dt id="importlib.abc.PathEntryFinder.find_spec">
<code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_spec" title="정의 주소">¶</a></dt>
<dd><p>지정된 모듈의 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">스펙</span></a>을 찾는 추상 메서드. 파인더는 할당된 <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">경로 엔트리</span></a> 내에서만 모듈을 검색합니다. 스펙을 찾을 수 없으면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다. 전달될 때, <code class="docutils literal notranslate"><span class="pre">target</span></code>은 파인더가 반환할 스펙에 대해 더 정교하게 추측하기 위해 사용할 수 있는 모듈 객체입니다. <a class="reference internal" href="#importlib.util.spec_from_loader" title="importlib.util.spec_from_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.spec_from_loader()</span></code></a>는 구상 <code class="docutils literal notranslate"><span class="pre">PathEntryFinders</span></code>를 구현하는 데 유용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PathEntryFinder.find_loader">
<code class="sig-name descname">find_loader</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_loader" title="정의 주소">¶</a></dt>
<dd><p>지정된 모듈에 대한 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>를 찾기 위한 레거시 메서드. <code class="docutils literal notranslate"><span class="pre">(loader,</span> <span class="pre">portion)</span></code>의 2-튜플을 반환하는데, <code class="docutils literal notranslate"><span class="pre">portion</span></code>은 이름 공간 패키지의 일부에 기여하는 파일 시스템 위치의 시퀀스입니다. 파일 시스템 위치가 이름 공간 패키지에 기여함을 나타내도록 <code class="docutils literal notranslate"><span class="pre">portion</span></code>을 지정하는 동안 로더는 <code class="docutils literal notranslate"><span class="pre">None</span></code>일 수 있습니다. 로더가 이름 공간 패키지의 일부가 아님을 표시하기 위해 <code class="docutils literal notranslate"><span class="pre">portion</span></code>에 빈 리스트를 사용할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">loader</span></code>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이고 <code class="docutils literal notranslate"><span class="pre">portion</span></code>이 빈 리스트이면 이름 공간 패키지의 로더나 위치가 발견되지 않은 것입니다 (즉 모듈에 대해 아무것도 찾지 못했습니다).</p>
<p><a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>이 정의되면 이전 버전과 호환되는 기능이 제공됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시키는 대신 <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">[])</span></code>를 반환합니다. 가능하다면 기능을 제공하기 위해 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>을 사용하십시오.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PathEntryFinder.find_module">
<code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_module" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self.find_loader(fullname)[0]</span></code>과 동등한 <a class="reference internal" href="#importlib.abc.Finder.find_module" title="importlib.abc.Finder.find_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Finder.find_module()</span></code></a>의 구상 구현.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PathEntryFinder.invalidate_caches">
<code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="정의 주소">¶</a></dt>
<dd><p>호출될 때, 파인더가 사용하는 내부 캐시를 무효로 해야 하는 선택적 메서드. 모든 캐시 된 파인더의 캐시를 무효화 할 때 <code class="xref py py-meth docutils literal notranslate"><span class="pre">PathFinder.invalidate_caches()</span></code>에서 사용합니다.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.Loader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">Loader</code><a class="headerlink" href="#importlib.abc.Loader" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>의 추상 베이스 클래스. 로더에 대한 정확한 정의는 <span class="target" id="index-40"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>를 참조하십시오.</p>
<p>리소스 읽기를 지원하려는 로더는 <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a>에 지정된 대로 <code class="docutils literal notranslate"><span class="pre">get_resource_reader(fullname)</span></code> 메서드를 구현해야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>선택적 <code class="docutils literal notranslate"><span class="pre">get_resource_reader()</span></code> 메서드를 도입했습니다.</p>
</div>
<dl class="method">
<dt id="importlib.abc.Loader.create_module">
<code class="sig-name descname">create_module</code><span class="sig-paren">(</span><em class="sig-param">spec</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.create_module" title="정의 주소">¶</a></dt>
<dd><p>모듈을 임포트 할 때 사용할 모듈 객체를 반환하는 메서드. 이 메서드는 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환해서 기본 모듈 생성 시맨틱이 적용되어야 함을 나타낼 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>파이썬 3.6부터는, <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>이 정의될 때 이 메서드는 선택 사항이 아닙니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.Loader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.exec_module" title="정의 주소">¶</a></dt>
<dd><p>모듈을 임포트 하거나 다시 로드할 때 자체 이름 공간에서 모듈을 실행하는 추상 메서드. <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code>이 호출될 때 모듈이 이미 초기화되어 있어야 합니다. 이 메서드가 존재하면, <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>을 정의해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>도 정의해야 합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.Loader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.load_module" title="정의 주소">¶</a></dt>
<dd><p>모듈을 로드하는 레거시 메서드. 모듈을 로드할 수 없으면, <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>가 발생하고, 그렇지 않으면 로드된 모듈이 반환됩니다.</p>
<p>요청된 모듈이 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 이미 존재하면, 해당 모듈이 사용되고 다시 로드되어야 합니다. 그렇지 않으면 로더는 임포트에서 재귀를 방지하기 위해 로드를 시작하기 전에 새 모듈을 만들어 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 삽입해야 합니다. 로더가 모듈을 삽입했는데 로드에 실패하면, 로더가 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에서 모듈을 제거해야 합니다; 로더가 실행을 시작하기 전에 이미 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 있었던 모듈은 그대로 두어야 합니다 (<a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a>를 참조하십시오).</p>
<p>로더는 모듈에서 여러 어트리뷰트를 설정해야 합니다. (이러한 어트리뷰트 중 일부는 모듈을 다시 로드할 때 변경될 수 있습니다):</p>
<ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>모듈의 이름</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a></dt><dd><p>모듈 데이터가 저장되는 경로입니다 (내장 모듈에는 설정되지 않습니다).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__cached__" title="__cached__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code></a></dt><dd><p>모듈의 컴파일 된 버전이 저장되는/저장되어야 하는 경로 (어트리뷰트가 부적절하면 설정되지 않습니다).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a></dt><dd><p>패키지 내에서 검색 경로를 지정하는 문자열 리스트. 이 어트리뷰트는 모듈에는 설정되지 않습니다.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a></dt><dd><p>모듈/패키지의 부모 패키지. 모듈이 최상위 수준이면 빈 문자열 값을 갖습니다. <a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a> 데코레이터는 <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>의 세부 사항을 처리할 수 있습니다.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a></dt><dd><p>모듈을 로드하는 데 사용되는 로더. <a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a> 데코레이터는 <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>의 세부 사항을 처리 할 수 있습니다.</p>
</dd>
</dl>
</li>
</ul>
<p><a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>을 사용할 수 있으면 이전 버전과 호환되는 기능이 제공됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>호출될 때 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다. <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>을 사용할 수 있을 때 제공되는 기능.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>모듈 로드에 권장되는 API는 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>(및 <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>)입니다. 로더는 load_module() 대신 이것을 구현해야 합니다. 임포트 절차는 exec_module()이 구현될 때 load_module()의 다른 모든 책임을 처리합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.Loader.module_repr">
<code class="sig-name descname">module_repr</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.module_repr" title="정의 주소">¶</a></dt>
<dd><p>구현될 때 지정된 모듈의 repr을 문자열로 계산하고 반환하는 레거시 메서드. 모듈 형의 기본 repr()은 이 메서드의 결과를 적절하게 사용합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>abstractmethod 대신에 선택 사항으로 만들어졌습니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>임포트 절차는 이제 이것을 자동으로 처리합니다.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.ResourceReader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">ResourceReader</code><a class="headerlink" href="#importlib.abc.ResourceReader" title="정의 주소">¶</a></dt>
<dd><p><em>리소스(resources)</em>를 읽을 수 있는 기능을 제공하는 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">추상 베이스 클래스</span></a>.</p>
<p>이 ABC의 관점에서, <em>리소스(resource)</em>는 패키지 내에 제공되는 바이너리 아티팩트(artifact)입니다. 일반적으로 이것은 패키지의 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 파일 옆에 있는 데이터 파일 같은 것입니다. 이 클래스의 목적은 이러한 데이터 파일에 대한 액세스를 추상화하여 패키지와 해당 데이터 파일이 예를 들어 zip 파일에 있는지 파일 시스템에 저장되어 있는지가 중요하지 않도록 만드는 것입니다.</p>
<p>이 클래스의 모든 메서드에서, <em>resource</em> 인자는 개념적으로 단지 파일 이름을 나타내는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>가 될 것으로 기대됩니다. 이는 <em>resource</em> 인자에 서브 디렉터리 경로가 포함되지 않아야 함을 의미합니다. 판독기(reader)가 읽으려는 패키지의 위치가 &quot;디렉터리&quot;의 역할을 하기 때문입니다. 따라서 디렉터리와 파일 이름에 대한 은유는 각각 패키지와 리소스입니다. 이것은 또한 이 클래스의 인스턴스가 (잠재적으로 여러 패키지나 모듈을 나타내는 대신) 특정 패키지와 직접적으로 연관될 것으로 기대되는 이유입니다.</p>
<p>리소스 읽기를 지원하려는 로더는 이 ABC의 인터페이스를 구현하는 객체를 반환하는 <code class="docutils literal notranslate"><span class="pre">get_resource_reader(fullname)</span></code>이라는 메서드를 제공해야 합니다. fullname으로 지정된 모듈이 패키지가 아니면, 이 메서드는 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환해야 합니다. 이 ABC와 호환되는 객체는 지정된 모듈이 패키지일 때만 반환해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
<dl class="method">
<dt id="importlib.abc.ResourceReader.open_resource">
<em class="property">abstractmethod </em><code class="sig-name descname">open_resource</code><span class="sig-paren">(</span><em class="sig-param">resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.open_resource" title="정의 주소">¶</a></dt>
<dd><p><em>resource</em>의 바이너리 읽기를 위해 열린 <a class="reference internal" href="../glossary.html#term-file-like-object"><span class="xref std std-term">파일류 객체</span></a>를 반환합니다.</p>
<p>리소스를 찾을 수 없으면, <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a> 가 발생합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.ResourceReader.resource_path">
<em class="property">abstractmethod </em><code class="sig-name descname">resource_path</code><span class="sig-paren">(</span><em class="sig-param">resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.resource_path" title="정의 주소">¶</a></dt>
<dd><p><em>resource</em>에 대한 파일 시스템 경로를 반환합니다.</p>
<p>리소스가 파일 시스템에 구체적으로 존재하지 않으면, <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a> 가 발생합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.ResourceReader.is_resource">
<em class="property">abstractmethod </em><code class="sig-name descname">is_resource</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.is_resource" title="정의 주소">¶</a></dt>
<dd><p>명명된 <em>name</em>을 리소스로 간주하면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다. <em>name</em>이 없으면, <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a> 가 발생합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.ResourceReader.contents">
<em class="property">abstractmethod </em><code class="sig-name descname">contents</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.contents" title="정의 주소">¶</a></dt>
<dd><p>패키지 내용에 대한 문자열의 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">이터러블</span></a>을 반환합니다. 이터레이터가 반환한 모든 이름이 실제 리소스일 필요는 없음에 유의하십시오, 예를 들어 <a class="reference internal" href="#importlib.abc.ResourceReader.is_resource" title="importlib.abc.ResourceReader.is_resource"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_resource()</span></code></a>가 거짓인 이름을 반환하는 것이 허용됩니다.</p>
<p>리소스가 아닌 이름이 반환되도록 하는 것은 패키지와 그것의 리소스가 저장되는 방법이 사전에 알려졌고 리소스가 아닌 이름이 유용한 상황을 허용하기 위함입니다. 예를 들어, 패키지와 리소스가 파일 시스템에 저장되어있는 것으로 알려졌을 때 해당 서브 디렉터리 이름을 직접 사용할 수 있도록 서브 디렉터리 이름 반환이 허용됩니다.</p>
<p>추상 메서드는 항목이 없는 이터러블을 반환합니다.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.ResourceLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">ResourceLoader</code><a class="headerlink" href="#importlib.abc.ResourceLoader" title="정의 주소">¶</a></dt>
<dd><p>스토리지 백 엔드에서 임의의 리소스를 로드하기 위한 선택적 <span class="target" id="index-41"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 프로토콜을 구현하는 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>의 추상 베이스 클래스.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.7부터 폐지: </span>이 ABC는 폐지되었고 <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a>를 통한 리소스 로드 지원으로 대체되었습니다.</p>
</div>
<dl class="method">
<dt id="importlib.abc.ResourceLoader.get_data">
<em class="property">abstractmethod </em><code class="sig-name descname">get_data</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceLoader.get_data" title="정의 주소">¶</a></dt>
<dd><p><em>path</em>에 있는 데이터를 바이트열로 반환하는 추상 메서드. 임의의 데이터를 저장할 수 있는 파일류 스토리지 백 엔드가 있는 로더는 이 추상 메서드를 구현하여 저장된 데이터에 직접 액세스하도록 할 수 있습니다. <em>path</em>를 찾을 수 없으면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다. <em>path</em>는 모듈의 <a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 어트리뷰트나 패키지의 <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a>에서 온 항목을 사용하여 구성될 것으로 기대됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.InspectLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">InspectLoader</code><a class="headerlink" href="#importlib.abc.InspectLoader" title="정의 주소">¶</a></dt>
<dd><p>모듈을 검사(inspect)하는 로더를 위한 선택적 <span class="target" id="index-42"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 프로토콜을 구현하는 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>의 추상 베이스 클래스.</p>
<dl class="method">
<dt id="importlib.abc.InspectLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_code" title="정의 주소">¶</a></dt>
<dd><p>모듈에 대한 코드 객체나, 모듈에 코드 객체가 없으면 (예를 들어, 내장 모듈이 이런 경우입니다) <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 로더가 요청한 모듈을 찾을 수 없으면 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>가 발생합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 메서드에는 기본 구현이 있지만, 가능하다면 성능을 위해 재정의하는 것이 좋습니다.</p>
</div>
<div class="versionchanged" id="index-16">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>더는 추상적이지 않고 구상 구현이 제공됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.get_source">
<em class="property">abstractmethod </em><code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_source" title="정의 주소">¶</a></dt>
<dd><p>모듈의 소스를 반환하는 추상 메서드. 인식된 모든 줄 구분자를 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 문자로 변환하는 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">유니버설 줄 넘김</span></a>을 사용하여 텍스트 문자열로 반환됩니다. 사용 가능한 소스가 없으면 (예를 들어, 내장 모듈) <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 로더가 지정된 모듈을 찾을 수 없으면 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.is_package" title="정의 주소">¶</a></dt>
<dd><p>모듈이 패키지이면 참값을 반환하고, 그렇지 않으면 거짓 값을 반환하는 추상 메서드. <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>가 모듈을 찾을 수 없으면 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>가 발생합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.source_to_code">
<em class="property">static </em><code class="sig-name descname">source_to_code</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">path='&lt;string&gt;'</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.source_to_code" title="정의 주소">¶</a></dt>
<dd><p>파이썬 소스에서 코드 객체를 만듭니다.</p>
<p><em>data</em> 인자는 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 함수가 지원하는 것은 무엇이든 될 수 있습니다 (즉 문자열이나 바이트열). <em>path</em> 인자는 소스 코드가 온 곳의 &quot;경로&quot;여야 하며, 추상 개념(예를 들어 zip 파일에서의 위치)일 수 있습니다.</p>
<p>후속 코드 객체를 사용하면 <code class="docutils literal notranslate"><span class="pre">exec(code,</span> <span class="pre">module.__dict__)</span></code>를 실행하여 그 코드를 모듈에서 실행할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>메서드를 정적(static)으로 만들었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.exec_module" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>의 구현.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.load_module" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>의 구현.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.InspectLoader.exec_module" title="importlib.abc.InspectLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.ExecutionLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">ExecutionLoader</code><a class="headerlink" href="#importlib.abc.ExecutionLoader" title="정의 주소">¶</a></dt>
<dd><p>구현될 때, 모듈이 스크립트로 실행되도록 돕는 <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">InspectLoader</span></code></a>에서 상속되는 추상 베이스 클래스. ABC는 선택적 <span class="target" id="index-43"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 프로토콜을 표현합니다.</p>
<dl class="method">
<dt id="importlib.abc.ExecutionLoader.get_filename">
<em class="property">abstractmethod </em><code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ExecutionLoader.get_filename" title="정의 주소">¶</a></dt>
<dd><p>지정된 모듈의 <a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 값을 반환하는 추상 메서드. 사용 가능한 경로가 없으면 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>가 발생합니다.</p>
<p>소스 코드를 사용할 수 있으면, 메서드는 모듈을 로드하는 데 바이트 코드를 사용했는지와 관계없이 소스 파일의 경로를 반환해야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.FileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">FileLoader</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a>와 <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>를 상속하고 <a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a>와 <a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a>의 구상 구현을 제공하는 추상 베이스 클래스.</p>
<p><em>fullname</em> 인자는 로더가 처리해야 하는 모듈의 완전히 결정된(resolved) 이름입니다. <em>path</em> 인자는 모듈의 파일 경로입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.abc.FileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.abc.FileLoader.name" title="정의 주소">¶</a></dt>
<dd><p>로더가 처리할 수 있는 모듈의 이름.</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.abc.FileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.abc.FileLoader.path" title="정의 주소">¶</a></dt>
<dd><p>모듈 파일의 경로.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.FileLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.load_module" title="정의 주소">¶</a></dt>
<dd><p>super의 <code class="docutils literal notranslate"><span class="pre">load_module()</span></code>을 호출합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.FileLoader.get_filename">
<em class="property">abstractmethod </em><code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_filename" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.FileLoader.path" title="importlib.abc.FileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.FileLoader.get_data">
<em class="property">abstractmethod </em><code class="sig-name descname">get_data</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_data" title="정의 주소">¶</a></dt>
<dd><p><em>path</em>를 바이너리 파일로 읽고 그것의 바이트열을 반환합니다.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.SourceLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">SourceLoader</code><a class="headerlink" href="#importlib.abc.SourceLoader" title="정의 주소">¶</a></dt>
<dd><p>소스 (및 선택적으로 바이트 코드) 파일 로드를 구현하기 위한 추상 베이스 클래스. 이 클래스는 <a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a>와 <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>를 모두 상속하며, 다음을 구현해야 합니다:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a></p></li>
<li><dl class="simple">
<dt><a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a></dt><dd><p>소스 파일의 경로만 반환해야 합니다; 소스 없는 로딩은 지원되지 않습니다.</p>
</dd>
</dl>
</li>
</ul>
<p>이 클래스에 의해 정의된 추상 메서드는 선택적 바이트 코드 파일 지원을 추가하는 것입니다. 이러한 선택적 메서드를 구현하지 않으면 (또는 그들이 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시키도록 하면) 로더가 소스 코드에 대해서만 작동하도록 만듭니다. 메서드를 구현하면 로더가 소스*와* 바이트 코드 파일 모두에 대해 작동하게 할 수 있습니다; 바이트 코드만 제공되는 <em>소스 없는</em> 로드는 허용하지 않습니다. 바이트 코드 파일은 파이썬 컴파일러의 구문 분석 단계를 제거하여 로딩 속도를 높이기 위한 최적화라서, 바이트 코드 전용 API는 노출되지 않습니다.</p>
<dl class="method">
<dt id="importlib.abc.SourceLoader.path_stats">
<code class="sig-name descname">path_stats</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_stats" title="정의 주소">¶</a></dt>
<dd><p>지정된 경로에 대한 메타 데이터를 포함하는 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>를 반환하는 선택적 추상 메서드. 지원되는 딕셔너리 키는 다음과 같습니다:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'mtime'</span></code> (필수): 소스 코드의 수정 시간을 나타내는 정수나 부동 소수점 숫자;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'size'</span></code> (선택): 바이트 단위의 소스 코드의 크기.</p></li>
</ul>
<p>향후 확장을 위해, 딕셔너리의 다른 키는 무시됩니다. 경로를 처리할 수 없으면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.path_mtime">
<code class="sig-name descname">path_mtime</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_mtime" title="정의 주소">¶</a></dt>
<dd><p>지정된 경로의 수정 시간을 반환하는 선택적 추상 메서드.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지: </span>이 메서드는 폐지되었고 <a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">path_stats()</span></code></a>로 대체되었습니다. 구현할 필요는 없지만, 호환성을 위해 여전히 제공됩니다. 경로를 처리할 수 없으면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.set_data">
<code class="sig-name descname">set_data</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.set_data" title="정의 주소">¶</a></dt>
<dd><p>지정된 바이트열을 파일 경로에 쓰는 선택적 추상 메서드. 존재하지 않는 중간 디렉터리는 자동으로 만들어집니다.</p>
<p>경로가 읽기 전용(<a class="reference internal" href="errno.html#errno.EACCES" title="errno.EACCES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errno.EACCES</span></code></a>/<a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PermissionError</span></code></a>)이라서 경로에 쓰지 못할 때 예외를 전파하지 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>호출할 때 더는 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시키지 않습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_code" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.InspectLoader.get_code" title="importlib.abc.InspectLoader.get_code"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_code()</span></code></a>의 구상 구현.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.exec_module" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>의 구상 구현.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.load_module" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>의 구상 구현.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.SourceLoader.exec_module" title="importlib.abc.SourceLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.get_source">
<code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_source" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_source()</span></code></a>의 구상 구현.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.is_package" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code></a>의 구상 구현. (<a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a>에서 제공되는) 파일 경로가 파일 확장자를 제거했을 때 <code class="docutils literal notranslate"><span class="pre">__init__</span></code>라는 이름의 파일이고 <em>동시에</em> 모듈 이름 자체가 <code class="docutils literal notranslate"><span class="pre">__init__</span></code>로 끝나지 않으면 모듈은 패키지로 결정됩니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-importlib.resources">
<span id="importlib-resources-resources"></span><h2><a class="reference internal" href="#module-importlib.resources" title="importlib.resources: Package resource reading, opening, and access"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code></a> -- 리소스<a class="headerlink" href="#module-importlib.resources" title="제목 주소">¶</a></h2>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/importlib/resources.py">Lib/importlib/resources.py</a></p>
<hr class="docutils" />
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
<p>이 모듈은 파이썬의 임포트 시스템을 활용하여 <em>패키지(packages)</em> 안에 있는 <em>리소스(resources)</em>에 대한 액세스를 제공합니다. 패키지를 임포트 할 수 있으면, 해당 패키지 내의 리소스에 액세스 할 수 있습니다. 바이너리나 텍스트 모드로 리소스를 열거나 읽을 수 있습니다.</p>
<p>리소스는 디렉터리 내의 파일과 거의 비슷하지만, 이것은 단지 은유라는 점을 명심해야 합니다. 리소스와 패키지가 파일 시스템에 실제 파일과 디렉터리로 존재할 필요는 <strong>없습니다</strong>.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 모듈은 <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html">pkg_resources</a> <a class="reference external" href="http://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-resource-access">Basic Resource Access</a>와 유사한 기능을 제공합니다만, 이 패키지의 성능 오버헤드가 없습니다. 이는 더 안정적이고 일관된 의미론으로, 패키지에 포함된 리소스를 더 쉽게 읽을 수 있도록 합니다.</p>
<p>이 모듈의 독립형 역 이식은 <a class="reference external" href="http://importlib-resources.readthedocs.io/en/latest/using.html">using importlib.resources</a>와 <a class="reference external" href="http://importlib-resources.readthedocs.io/en/latest/migration.html">migrating from pkg_resources to importlib.resources</a>에서 자세한 정보를 제공합니다.</p>
</div>
<p>리소스 읽기를 지원하려는 로더는 <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a>에 지정된 대로 <code class="docutils literal notranslate"><span class="pre">get_resource_reader(fullname)</span></code> 메서드를 구현해야 합니다.</p>
<p>다음과 같은 형이 정의됩니다.</p>
<dl class="data">
<dt id="importlib.resources.Package">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">Package</code><a class="headerlink" href="#importlib.resources.Package" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Package</span></code> 형은 <code class="docutils literal notranslate"><span class="pre">Union[str,</span> <span class="pre">ModuleType]</span></code>으로 정의됩니다. 이는 함수가 <code class="docutils literal notranslate"><span class="pre">Package</span></code>를 받아들인다고 설명하는 위치에 문자열이나 모듈을 전달할 수 있음을 의미합니다. 모듈 객체는 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아닌 해석할 수 있는 <code class="docutils literal notranslate"><span class="pre">__spec__.submodule_search_locations</span></code>를 가져야 합니다.</p>
</dd></dl>

<dl class="data">
<dt id="importlib.resources.Resource">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">Resource</code><a class="headerlink" href="#importlib.resources.Resource" title="정의 주소">¶</a></dt>
<dd><p>이 형은 이 패키지의 다양한 함수에 전달된 리소스 이름을 기술합니다. 이것은 <code class="docutils literal notranslate"><span class="pre">Union[str,</span> <span class="pre">os.PathLike]</span></code>으로 정의됩니다.</p>
</dd></dl>

<p>다음과 같은 함수를 사용할 수 있습니다.</p>
<dl class="function">
<dt id="importlib.resources.open_binary">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">open_binary</code><span class="sig-paren">(</span><em class="sig-param">package</em>, <em class="sig-param">resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.open_binary" title="정의 주소">¶</a></dt>
<dd><p><em>package</em> 내에서 <em>resource</em>를 바이너리 읽기로 엽니다.</p>
<p><em>package</em>는 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 요구 사항을 준수하는 이름이나 모듈 객체입니다. <em>resource</em>는 <em>package</em> 내에서 열 리소스의 이름입니다; 경로 구분 기호를 포함하지 않아야 하고 서브 리소스를 가질 수도 없습니다 (즉, 디렉터리가 될 수 없습니다). 이 함수는 읽기 위해 열린 바이너리 I/O 스트림인 <code class="docutils literal notranslate"><span class="pre">typing.BinaryIO</span></code> 인스턴스를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.open_text">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">open_text</code><span class="sig-paren">(</span><em class="sig-param">package</em>, <em class="sig-param">resource</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.open_text" title="정의 주소">¶</a></dt>
<dd><p><em>package</em> 내에서 <em>resource</em>를 텍스트 읽기로 엽니다. 기본적으로, 리소스는 UTF-8로 읽도록 열립니다.</p>
<p><em>package</em>는 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 요구 사항을 준수하는 이름이나 모듈 객체입니다. <em>resource</em>는 <em>package</em> 내에서 열 리소스의 이름입니다; 경로 구분 기호를 포함하지 않아야 하고 서브 리소스를 가질 수도 없습니다 (즉, 디렉터리가 될 수 없습니다). <em>encoding</em>과 <em>errors</em>는 내장 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>과 같은 의미입니다.</p>
<p>이 함수는 읽기 위해 열린 텍스트 I/O 스트림인 <code class="docutils literal notranslate"><span class="pre">typing.TextIO</span></code> 인스턴스를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.read_binary">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">read_binary</code><span class="sig-paren">(</span><em class="sig-param">package</em>, <em class="sig-param">resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.read_binary" title="정의 주소">¶</a></dt>
<dd><p><em>package</em> 내에서 <em>resource</em>의 내용을 읽고 <code class="docutils literal notranslate"><span class="pre">bytes</span></code>로 반환합니다.</p>
<p><em>package</em>는 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 요구 사항을 준수하는 이름이나 모듈 객체입니다. <em>resource</em>는 <em>package</em> 내에서 열 리소스의 이름입니다; 경로 구분 기호를 포함하지 않아야 하고 서브 리소스를 가질 수도 없습니다 (즉, 디렉터리가 될 수 없습니다). 이 함수는 리소스의 내용을 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>로 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.read_text">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">read_text</code><span class="sig-paren">(</span><em class="sig-param">package</em>, <em class="sig-param">resource</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.read_text" title="정의 주소">¶</a></dt>
<dd><p><em>package</em> 내에서 <em>resource</em>의 내용을 읽고 <code class="docutils literal notranslate"><span class="pre">str</span></code>로 반환합니다. 기본적으로, 내용은 엄격한(strict) UTF-8로 읽습니다.</p>
<p><em>package</em>는 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 요구 사항을 준수하는 이름이나 모듈 객체입니다. <em>resource</em>는 <em>package</em> 내에서 열 리소스의 이름입니다; 경로 구분 기호를 포함하지 않아야 하고 서브 리소스를 가질 수도 없습니다 (즉, 디렉터리가 될 수 없습니다). <em>encoding</em>과 <em>errors</em>는 내장 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>과 같은 의미입니다. 이 함수는 리소스의 내용을 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.path">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">path</code><span class="sig-paren">(</span><em class="sig-param">package</em>, <em class="sig-param">resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.path" title="정의 주소">¶</a></dt>
<dd><p><em>resource</em>에 대한 경로를 실제 파일 시스템 경로로 반환합니다. 이 함수는 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문에서 사용할 컨텍스트 관리자를 반환합니다. 컨텍스트 관리자는 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> 객체를 제공합니다.</p>
<p>컨텍스트 관리자를 종료하면 리소스를 예를 들어 zip 파일에서 추출해야 할 때 만들어진 임시 파일이 정리됩니다.</p>
<p><em>package</em>는 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 요구 사항을 준수하는 이름이나 모듈 객체입니다. <em>resource</em>는 <em>package</em> 내에서 열 리소스의 이름입니다; 경로 구분 기호를 포함하지 않아야 하고 서브 리소스를 가질 수도 없습니다 (즉, 디렉터리가 될 수 없습니다).</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.is_resource">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">is_resource</code><span class="sig-paren">(</span><em class="sig-param">package</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.is_resource" title="정의 주소">¶</a></dt>
<dd><p>패키지에 <em>name</em>이라는 리소스가 있으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다. 디렉터리는 리소스가 <em>아니라는</em> 것을 기억하십시오! <em>package</em>는 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 요구 사항을 준수하는 이름이나 모듈 객체입니다.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.contents">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">contents</code><span class="sig-paren">(</span><em class="sig-param">package</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.contents" title="정의 주소">¶</a></dt>
<dd><p>패키지 내에서 이름이 있는 항목에 대한 이터러블을 반환합니다. 이터러블은 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 리소스(예를 들어 파일)와 리소스가 아닌 것(예를 들어 디렉터리)을 반환합니다. 이터러블은 서브 디렉터리로 재귀하지 않습니다.</p>
<p><em>package</em>는 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 요구 사항을 준수하는 이름이나 모듈 객체입니다.</p>
</dd></dl>

</div>
<div class="section" id="module-importlib.machinery">
<span id="importlib-machinery-importers-and-path-hooks"></span><h2><a class="reference internal" href="#module-importlib.machinery" title="importlib.machinery: Importers and path hooks"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code></a> -- 임포터와 경로 훅<a class="headerlink" href="#module-importlib.machinery" title="제목 주소">¶</a></h2>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/importlib/machinery.py">Lib/importlib/machinery.py</a></p>
<hr class="docutils" />
<p>이 모듈에는 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>가 모듈을 찾고 로드하는 데 도움이 되는 다양한 객체가 포함되어 있습니다.</p>
<dl class="attribute">
<dt id="importlib.machinery.SOURCE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">SOURCE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.SOURCE_SUFFIXES" title="정의 주소">¶</a></dt>
<dd><p>소스 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.DEBUG_BYTECODE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">DEBUG_BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.DEBUG_BYTECODE_SUFFIXES" title="정의 주소">¶</a></dt>
<dd><p>최적화되지 않은 바이트 코드 모듈의 파일 접미사를 나타내는 문자열 리스트.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.5부터 폐지: </span>대신 <a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a>를 사용하십시오.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">OPTIMIZED_BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES" title="정의 주소">¶</a></dt>
<dd><p>최적화된 바이트 코드 모듈의 파일 접미사를 나타내는 문자열 리스트.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.5부터 폐지: </span>대신 <a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a>를 사용하십시오.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.BYTECODE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.BYTECODE_SUFFIXES" title="정의 주소">¶</a></dt>
<dd><p>바이트 코드 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트 (앞의 점을 포함합니다).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이 값은 더는 <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>에 의존하지 않습니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.EXTENSION_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">EXTENSION_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.EXTENSION_SUFFIXES" title="정의 주소">¶</a></dt>
<dd><p>확장 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.machinery.all_suffixes">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">all_suffixes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.all_suffixes" title="정의 주소">¶</a></dt>
<dd><p>표준 임포트 절차가 인식하는 모듈의 모든 파일 접미사를 나타내는 문자열의 결합한 리스트를 반환합니다. 이것은 모듈 종류에 대한 세부 정보 없이 파일 시스템 경로가 잠재적으로 모듈을 참조하는지를 알아야 하는 코드(예를 들어, <a class="reference internal" href="inspect.html#inspect.getmodulename" title="inspect.getmodulename"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getmodulename()</span></code></a>)를 위한 도우미입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.BuiltinImporter">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">BuiltinImporter</code><a class="headerlink" href="#importlib.machinery.BuiltinImporter" title="정의 주소">¶</a></dt>
<dd><p>내장 모듈용 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">임포터</span></a>. 알려진 모든 내장 모듈은 <a class="reference internal" href="sys.html#sys.builtin_module_names" title="sys.builtin_module_names"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.builtin_module_names</span></code></a>에 나열되어 있습니다. 이 클래스는 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a>와 <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a> ABC를 구현합니다.</p>
<p>이 클래스는 인스턴스 화의 필요성을 완화하기 위해 클래스 메서드만 정의합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><span class="target" id="index-44"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>의 일부로, 내장 임포터는 이제 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.create_module()</span></code>과 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code>을 구현합니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.FrozenImporter">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">FrozenImporter</code><a class="headerlink" href="#importlib.machinery.FrozenImporter" title="정의 주소">¶</a></dt>
<dd><p>프로즌(frozen) 모듈용 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">임포터</span></a>. 이 클래스는 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a>와 <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a> ABC를 구현합니다.</p>
<p>이 클래스는 인스턴스 화의 필요성을 완화하기 위해 클래스 메서드만 정의합니다.</p>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.WindowsRegistryFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">WindowsRegistryFinder</code><a class="headerlink" href="#importlib.machinery.WindowsRegistryFinder" title="정의 주소">¶</a></dt>
<dd><p>윈도우 레지스트리에 선언된 모듈용 <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">파인더</span></a>. 이 클래스는 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC를 구현합니다.</p>
<p>이 클래스는 인스턴스 화의 필요성을 완화하기 위해 클래스 메서드만 정의합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.6부터 폐지: </span>대신 <a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 구성을 사용하십시오. 이후 버전의 파이썬은 기본적으로 이 파인더를 활성화하지 않을 수 있습니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.PathFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">PathFinder</code><a class="headerlink" href="#importlib.machinery.PathFinder" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>와 패키지 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 어트리뷰트용 <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">파인더</span></a>. 이 클래스는 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC를 구현합니다.</p>
<p>이 클래스는 인스턴스 화의 필요성을 완화하기 위해 클래스 메서드만 정의합니다.</p>
<dl class="method">
<dt id="importlib.machinery.PathFinder.find_spec">
<em class="property">classmethod </em><code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path=None</em>, <em class="sig-param">target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_spec" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 또는, 정의되었다면, <em>path</em>에서 <em>fullname</em>에 의해 지정된 모듈에 대한 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">스펙</span></a>을 찾으려고 시도하는 클래스 메서드. 검색된 각 경로 엔트리에 대해, <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>가 확인됩니다. 거짓이 아닌 객체를 찾으면 검색 중인 모듈을 찾기 위한 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a>로 사용됩니다. <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>에 엔트리가 없으면, <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>에서 경로 엔트리를 위한 파인더를 검색하고, 발견되면, 모듈에 대해 조회되는 것과 동시에 <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>에 저장됩니다. 파인더가 아예 발견되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 캐시에 저장되고 반환됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>현재 작업 디렉터리 -- 빈 문자열로 표현됩니다 -- 가 더는 유효하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환되지만 <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>에 값이 캐시 되지는 않습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.PathFinder.find_module">
<em class="property">classmethod </em><code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_module" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>을 감싸는 레거시 래퍼.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>대신 <a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.PathFinder.invalidate_caches">
<em class="property">classmethod </em><code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.invalidate_caches" title="정의 주소">¶</a></dt>
<dd><p>메서드를 정의하는 <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>에 저장된 모든 파인더에 대해 <a class="reference internal" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="importlib.abc.PathEntryFinder.invalidate_caches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder.invalidate_caches()</span></code></a>를 호출합니다. <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>에 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정된 엔트리가 삭제됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>에서 <code class="docutils literal notranslate"><span class="pre">None</span></code>의 엔트리가 삭제됩니다.</p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">''</span></code>(즉 빈 문자열)에 대해서는 현재 작업 디렉터리로 <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>의 객체를 호출합니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.FileFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">FileFinder</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">*loader_details</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder" title="정의 주소">¶</a></dt>
<dd><p>파일 시스템에서의 결과를 캐시 하는 <a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> 의 구상 구현.</p>
<p><em>path</em> 인자는 파인더가 검색을 담당하는 디렉터리입니다.</p>
<p><em>loader_details</em> 인자는 각각 로더와 로더가 인식하는 파일 접미사의 시퀀스를 포함하는 가변 개수의 2개 항목 튜플입니다. 로더는 모듈 이름과 찾은 파일의 경로로 구성되는 두 인자를 받아들이는 콜러블일 것으로 기대됩니다.</p>
<p>파인더는 필요에 따라 디렉터리 내용을 캐시 하여, 각 모듈 검색에서 stat 호출을 수행하여 캐시가 시효가 지나지 않았는지 확인합니다. 캐시 만료는 파일 시스템의 운영 체제 상태 정보의 세분성에 의존하기 때문에, 모듈 검색, 새 파일 생성 및 새 파일이 나타내는 모듈 검색의 잠재적 경쟁 조건이 있습니다. stat 호출의 세분성 이하로 연산이 아주 빠르게 수행되면, 모듈 검색이 실패합니다. 이를 방지하려면, 모듈을 동적으로 만들 때, <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a>를 호출해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.FileFinder.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.FileFinder.path" title="정의 주소">¶</a></dt>
<dd><p>파인더가 검색할 경로.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.FileFinder.find_spec">
<code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_spec" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> 내에서 <em>fullname</em>을 처리할 스펙을 찾으려고 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.FileFinder.find_loader">
<code class="sig-name descname">find_loader</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_loader" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> 내에서 <em>fullname</em>을 처리할 로더를 찾으려고 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.FileFinder.invalidate_caches">
<code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.invalidate_caches" title="정의 주소">¶</a></dt>
<dd><p>내부 캐시를 지웁니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.FileFinder.path_hook">
<em class="property">classmethod </em><code class="sig-name descname">path_hook</code><span class="sig-paren">(</span><em class="sig-param">*loader_details</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.path_hook" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>에 사용할 클로저를 반환하는 클래스 메서드. <a class="reference internal" href="#importlib.machinery.FileFinder" title="importlib.machinery.FileFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileFinder</span></code></a>의 인스턴스는 클로저에 직접 제공된 경로 인자와 <em>loader_details</em>를 간접적으로 사용하여 클로저에 의해 반환됩니다.</p>
<p>클로저에 대한 인자가 기존 디렉터리가 아니면, <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>가 발생합니다.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.machinery.SourceFileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">SourceFileLoader</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a>를 서브 클래싱하고 다른 메서드의 구상 구현을 제공하는 <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a>의 구상 구현.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.SourceFileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.SourceFileLoader.name" title="정의 주소">¶</a></dt>
<dd><p>이 로더가 처리할 모듈의 이름.</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.SourceFileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path" title="정의 주소">¶</a></dt>
<dd><p>소스 파일의 경로.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.is_package" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.SourceFileLoader.path" title="importlib.machinery.SourceFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>가 패키지에 대한 것으로 드러나면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.path_stats">
<code class="sig-name descname">path_stats</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path_stats" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.path_stats()</span></code></a>의 구상 구현.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.set_data">
<code class="sig-name descname">set_data</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.set_data" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.SourceLoader.set_data" title="importlib.abc.SourceLoader.set_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.set_data()</span></code></a>의 구상 구현.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.load_module" title="정의 주소">¶</a></dt>
<dd><p>로드할 모듈 이름을 지정하는 것이 선택적인 <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>의 구상 구현.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.6부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.machinery.SourcelessFileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">SourcelessFileLoader</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader" title="정의 주소">¶</a></dt>
<dd><p>바이트 코드 파일을 (즉, 소스 코드 파일 없이) 임포트 할 수 있는 <a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a>의 구상 구현.</p>
<p>바이트 코드 파일(그래서 소스 코드 파일이 아닌)을 직접 사용하면 모든 파이썬 구현이나 바이트 코드 형식을 변경하는 새 버전의 파이썬에서 모듈을 사용할 수 없게 됨에 유의하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.SourcelessFileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.name" title="정의 주소">¶</a></dt>
<dd><p>로더가 처리할 모듈의 이름.</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.SourcelessFileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.path" title="정의 주소">¶</a></dt>
<dd><p>바이트 코드 파일의 경로.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.is_package" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>를 기반으로 모듈이 패키지인지 판단합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_code" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>에서 만들어진 <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.name" title="importlib.machinery.SourcelessFileLoader.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a>의 코드 객체를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.get_source">
<code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_source" title="정의 주소">¶</a></dt>
<dd><p>이 로더가 사용될 때는 바이트 코드 파일에 소스가 없어서 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.load_module" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>로드할 모듈 이름을 지정하는 것이 선택적인 <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>의 구상 구현.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.6부터 폐지: </span>대신 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.ExtensionFileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">ExtensionFileLoader</code><span class="sig-paren">(</span><em class="sig-param">fullname</em>, <em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader" title="정의 주소">¶</a></dt>
<dd><p>확장 모듈을 위한 <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ExecutionLoader</span></code></a>의 구상 구현.</p>
<p><em>fullname</em> 인자는 로더가 지원할 모듈의 이름을 지정합니다. <em>path</em> 인자는 확장 모듈 파일의 경로입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.ExtensionFileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.name" title="정의 주소">¶</a></dt>
<dd><p>로더가 지원하는 모듈의 이름.</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.ExtensionFileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.path" title="정의 주소">¶</a></dt>
<dd><p>확장 모듈의 경로.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.create_module">
<code class="sig-name descname">create_module</code><span class="sig-paren">(</span><em class="sig-param">spec</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.create_module" title="정의 주소">¶</a></dt>
<dd><p><span class="target" id="index-45"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>에 따라 지정된 명세에서 모듈 객체를 만듭니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.exec_module" title="정의 주소">¶</a></dt>
<dd><p><span class="target" id="index-46"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>에 따라 주어진 모듈 객체를 초기화합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.is_package" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.EXTENSION_SUFFIXES" title="importlib.machinery.EXTENSION_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">EXTENSION_SUFFIXES</span></code></a>에 기반해서 파일 경로가 패키지의 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 모듈을 가리키면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_code" title="정의 주소">¶</a></dt>
<dd><p>확장 모듈에는 코드 객체가 없어서 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.get_source">
<code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_source" title="정의 주소">¶</a></dt>
<dd><p>확장 모듈에는 소스 코드가 없어서 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.get_filename">
<code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param">fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_filename" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.ExtensionFileLoader.path" title="importlib.machinery.ExtensionFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.machinery.ModuleSpec">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">ModuleSpec</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">loader</em>, <em class="sig-param">*</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">loader_state=None</em>, <em class="sig-param">is_package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ModuleSpec" title="정의 주소">¶</a></dt>
<dd><p>모듈의 임포트 시스템 관련 상태에 대한 명세. 이것은 일반적으로 모듈의 <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 어트리뷰트로 노출됩니다. 아래 설명에서, 괄호 안의 이름은 모듈 객체에서 직접 사용 가능한 해당 어트리뷰트를 제공합니다. 예를 들어: <code class="docutils literal notranslate"><span class="pre">module.__spec__.origin</span> <span class="pre">==</span> <span class="pre">module.__file__</span></code>. 그러나 <em>values</em>는 일반적으로 동등하지만, 두 객체 간에 동기화가 없기 때문에 다를 수 있음에 유의하십시오. 따라서 실행 시간에 모듈의 <code class="docutils literal notranslate"><span class="pre">__path__</span></code>를 갱신할 수 있으며, 이는 <code class="docutils literal notranslate"><span class="pre">__spec__.submodule_search_locations</span></code>에 자동으로 반영되지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.name" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__name__</span></code>)</p>
<p>정규화된 모듈 이름의 문자열.</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.loader">
<code class="sig-name descname">loader</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__loader__</span></code>)</p>
<p>로딩에 사용할 로더. 이름 공간 패키지의 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정해야 합니다.</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.origin">
<code class="sig-name descname">origin</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.origin" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__file__</span></code>)</p>
<p>모듈이 로드된 장소의 이름, 예를 들어, 내장 모듈의 경우 &quot;builtin&quot;이고 소스에서 로드한 모듈의 경우 파일명. 일반적으로 &quot;origin&quot;을 설정해야 하지만, 지정되지 않았음을 나타내는 <code class="docutils literal notranslate"><span class="pre">None</span></code>(기본값)일 수 있습니다 (예를 들어 이름 공간 패키지).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.submodule_search_locations">
<code class="sig-name descname">submodule_search_locations</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.submodule_search_locations" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__path__</span></code>)</p>
<p>패키지이면, 서브 모듈을 찾을 수 있는 문자열 리스트 (그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.loader_state">
<code class="sig-name descname">loader_state</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader_state" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>로드 중 사용하기 위한 추가 모듈 특정 데이터의 컨테이너 (또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.cached">
<code class="sig-name descname">cached</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.cached" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__cached__</span></code>)</p>
<p>컴파일된 모듈을 저장해야 하는 장소의 문자열 (또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.parent">
<code class="sig-name descname">parent</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.parent" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__package__</span></code>)</p>
<p>(읽기 전용) 모듈이 서브 모듈로 속하는 패키지의 정규화된 이름 (또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.has_location">
<code class="sig-name descname">has_location</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.has_location" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>모듈의 &quot;origin&quot; 어트리뷰트가 로드 가능한 위치를 나타내는지를 나타내는 불리언.</p>
</dd></dl>

</div>
<div class="section" id="module-importlib.util">
<span id="importlib-util-utility-code-for-importers"></span><h2><a class="reference internal" href="#module-importlib.util" title="importlib.util: Utility code for importers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code></a> -- 임포터를 위한 유틸리티 코드<a class="headerlink" href="#module-importlib.util" title="제목 주소">¶</a></h2>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/importlib/util.py">Lib/importlib/util.py</a></p>
<hr class="docutils" />
<p>이 모듈에는 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">임포터</span></a> 구성에 도움이 되는 다양한 객체가 포함되어 있습니다.</p>
<dl class="attribute">
<dt id="importlib.util.MAGIC_NUMBER">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">MAGIC_NUMBER</code><a class="headerlink" href="#importlib.util.MAGIC_NUMBER" title="정의 주소">¶</a></dt>
<dd><p>바이트 코드 버전 번호를 나타내는 바이트열. 바이트 코드의 로드/쓰기에 도움이 필요하면 <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a>를 고려하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.cache_from_source">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">cache_from_source</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">debug_override=None</em>, <em class="sig-param">*</em>, <em class="sig-param">optimization=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.cache_from_source" title="정의 주소">¶</a></dt>
<dd><p>소스 <em>path</em>와 연관된 바이트 컴파일된 파일의 <span class="target" id="index-47"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>/<span class="target" id="index-48"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a> 경로를 반환합니다. 예를 들어, <em>path</em>가 <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>이면 반환값은 파이썬 3.2의 경우 <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>입니다. <code class="docutils literal notranslate"><span class="pre">cpython-32</span></code> 문자열은 현재 매직 태그에서 온 것입니다 (<code class="xref py py-func docutils literal notranslate"><span class="pre">get_tag()</span></code>를 참조하십시오; <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code>가 정의되지 않으면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 가 발생합니다).</p>
<p><em>optimization</em> 매개 변수는 바이트 코드 파일의 최적화 수준을 지정하는 데 사용됩니다. 빈 문자열은 최적화하지 않음을 나타내므로, <em>optimization</em>이 <code class="docutils literal notranslate"><span class="pre">''</span></code> 인 <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>는 바이트 코드 경로가 <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>가 됩니다. <code class="docutils literal notranslate"><span class="pre">None</span></code>은 인터프리터의 최적화 수준이 사용되도록 합니다. 다른 값의 문자열 표현은 사용되므로, <em>optimization</em>이 <code class="docutils literal notranslate"><span class="pre">2</span></code>인 <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>는 바이트 코드 경로가 <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc</span></code>가 됩니다. <em>optimization</em>의 문자열 표현은 영숫자만 가능하며, 그렇지 않으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p><em>debug_override</em> 매개 변수는 폐지되었고 <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>의 시스템값을 대체하는 데 사용할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">True</span></code> 값은 <em>optimization</em>을 빈 문자열로 설정하는 것과 등등합니다. <code class="docutils literal notranslate"><span class="pre">False</span></code> 값은 <em>optimization</em>을 <code class="docutils literal notranslate"><span class="pre">1</span></code>로 설정하는 것과 같습니다. <em>debug_override</em>와 <em>optimization</em>이 모두 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><em>optimization</em> 매개 변수가 추가되었고 <em>debug_override</em> 매개 변수는 폐지되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.source_from_cache">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">source_from_cache</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_from_cache" title="정의 주소">¶</a></dt>
<dd><p><em>path</em>에 <span class="target" id="index-49"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> 파일 이름이 주어지면, 연관된 소스 코드 파일 경로를 반환합니다. 예를 들어, <em>path</em>가 <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>이면 반환된 경로는 <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>입니다. <em>path</em>는 존재할 필요는 없지만, <span class="target" id="index-50"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>이나 <span class="target" id="index-51"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a> 형식을 준수하지 않으면, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code>가 정의되지 않으면, <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.decode_source">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">decode_source</code><span class="sig-paren">(</span><em class="sig-param">source_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.decode_source" title="정의 주소">¶</a></dt>
<dd><p>소스 코드를 나타내는 주어진 바이트열을 디코딩하고 유니버설 줄 넘김이 적용된 문자열로 반환합니다 (<a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.get_source()</span></code></a>에 필요한 대로).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.resolve_name">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">resolve_name</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">package</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.resolve_name" title="정의 주소">¶</a></dt>
<dd><p>상대 모듈 이름을 절대 이름으로 결정합니다.</p>
<p><strong>name</strong> 선두에 점이 없으면, <strong>name</strong>이 단순히 반환됩니다. 이를 통해 <strong>package</strong> 인자가 필요한지 확인하지 않고 <code class="docutils literal notranslate"><span class="pre">importlib.util.resolve_name('sys',</span> <span class="pre">__package__)</span></code>와 같은 사용이 가능합니다.</p>
<p><strong>name</strong>이 상대 모듈 이름이지만 package가 거짓 값(예를 들어 <code class="docutils literal notranslate"><span class="pre">None</span></code>이나 빈 문자열)이면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>는 또한 상대 이름이 그것을 포함하는 패키지를 벗어날 것 같으면 발생합니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">spam</span></code> 패키지 내에서 <code class="docutils literal notranslate"><span class="pre">..bacon</span></code>을 요청하는 것).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.find_spec">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.find_spec" title="정의 주소">¶</a></dt>
<dd><p>선택적으로 지정된 <strong>package</strong> 이름에 상대적으로, 모듈의 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">스펙</span></a>을 찾습니다. 모듈이 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 있으면, <code class="docutils literal notranslate"><span class="pre">sys.modules[name].__spec__</span></code>이 반환됩니다 (스펙이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 되거나 설정되지 않지 않은 한, 그럴 경우는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다). 그렇지 않으면 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>를 사용한 검색이 수행됩니다. 스펙을 찾지 못하면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다.</p>
<p><strong>name</strong>이 서브 모듈에 관한 것이면 (점을 포함하면), 부모 모듈은 자동으로 임포트 됩니다.</p>
<p><strong>name</strong>과 <strong>package</strong>는 <code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code>과 같게 작동합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><strong>package</strong>가 실제로 패키지가 아니면 (즉 <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> 어트리뷰트가 없으면) <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.module_from_spec">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">module_from_spec</code><span class="sig-paren">(</span><em class="sig-param">spec</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.module_from_spec" title="정의 주소">¶</a></dt>
<dd><p><strong>spec</strong>과 <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a>을 기반으로 새 모듈을 만듭니다.</p>
<p><a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환하지 않으면, 어떤 기존 어트리뷰트도 재설정되지 않습니다. 또한 <strong>spec</strong>에 액세스하거나 모듈에서 어트리뷰트를 설정하는 동안 트리거 되면 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>가 발생하지 않습니다.</p>
<p><strong>spec</strong>은 모듈에서 가능한 많은 임포트 제어 어트리뷰트를 설정하는 데 사용되므로 새 모듈을 작성하는 데 <a class="reference internal" href="types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a>을 사용하는 것보다 이 함수가 선호됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.module_for_loader">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">module_for_loader</code><a class="headerlink" href="#importlib.util.module_for_loader" title="정의 주소">¶</a></dt>
<dd><p>로드할 적절한 모듈 객체 선택을 처리하기 위한 <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> 용 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">데코레이터</span></a>. 데코레이팅 된 메서드에는 두 개의 위치 인자를 취하는 호출 서명을 가질 것으로 기대됩니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">load_module(self,</span> <span class="pre">module)</span></code>), 두 번째 인자는 로더가 사용할 모듈 <strong>객체</strong>입니다. 데코레이터는 두 개의 인자를 가정하기 때문에 정적 메서드에서 작동하지 않음에 유의하십시오.</p>
<p>데코레이팅 된 메서드는 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a>에 대해 로드될 모듈 <strong>이름</strong>을 취합니다. <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 모듈이 없으면 새로운 모듈이 구성됩니다. 모듈의 출처와 관계없이, <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a>는 <strong>self</strong>로 설정되고 <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>는 <a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.is_package()</span></code></a>가 반환하는 것에 따라 설정됩니다 (사용 가능하다면). 이러한 어트리뷰트는 재로드를 지원하도록 무조건 설정됩니다.</p>
<p>데코레이트 된 메서드가 예외를 발생시키고 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 모듈이 추가되었으면, 부분적으로 초기화된 모듈이 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 남아 있지 않도록 모듈이 제거됩니다. 모듈이 이미 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 있었다면 모듈은 그대로 유지됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a>와 <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>는 자동으로 설정됩니다 (가능하면).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>재로드를 지원하기 위해 <a class="reference internal" href="../reference/import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>, <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>를 무조건 설정합니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>임포트 절차는 이제 이 함수가 제공하는 모든 기능을 직접 수행합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.set_loader">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">set_loader</code><a class="headerlink" href="#importlib.util.set_loader" title="정의 주소">¶</a></dt>
<dd><p>반환된 모듈에서 <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> 어트리뷰트를 설정하기 위한 <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> 용 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">데코레이터</span></a>. 어트리뷰트가 이미 설정되어 있으면 데코레이터는 아무것도 하지 않습니다. 래핑 된 메서드에 대한 첫 번째 위치 인자(즉, <code class="docutils literal notranslate"><span class="pre">self</span></code>)가 <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a>가 설정되어야 하는 것으로 가정합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>어트리뷰트가 존재하지 않는 것처럼, <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정되었으면 <code class="docutils literal notranslate"><span class="pre">__loader__</span></code>를 설정합니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>임포트 절차는 이것을 자동으로 처리합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.set_package">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">set_package</code><a class="headerlink" href="#importlib.util.set_package" title="정의 주소">¶</a></dt>
<dd><p>반환된 모듈에서 <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> 어트리뷰트를 설정하기 위한 <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> 용 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">데코레이터</span></a>. <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>가 설정되었고 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이외의 값을 가지면 변경되지 않습니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span>임포트 절차는 이것을 자동으로 처리합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.spec_from_loader">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">spec_from_loader</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">loader</em>, <em class="sig-param">*</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">is_package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_loader" title="정의 주소">¶</a></dt>
<dd><p>로더(loader)를 기반으로 <code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code> 인스턴스를 만들기 위한 팩토리 함수. 매개 변수는 ModuleSpec에서와 같은 의미입니다. 이 함수는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code>와 같은 사용 가능한 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a> API를 사용하여 스펙에 빠진 정보를 채웁니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.spec_from_file_location">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">spec_from_file_location</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">location</em>, <em class="sig-param">*</em>, <em class="sig-param">loader=None</em>, <em class="sig-param">submodule_search_locations=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_file_location" title="정의 주소">¶</a></dt>
<dd><p>파일 경로를 기반으로 <code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code> 인스턴스를 만드는 팩토리 함수. 로더 API를 사용하고 모듈이 파일 기반일 것이라는 것이 뜻하는 것으로 누락된 정보가 스펙에 채워집니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.source_hash">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">source_hash</code><span class="sig-paren">(</span><em class="sig-param">source_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_hash" title="정의 주소">¶</a></dt>
<dd><p><em>source_bytes</em>의 해시를 바이트열로 반환합니다. 해시 기반 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일은 해당 소스 파일 내용의 <a class="reference internal" href="#importlib.util.source_hash" title="importlib.util.source_hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">source_hash()</span></code></a>를 헤더에 포함합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.util.LazyLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">LazyLoader</code><span class="sig-paren">(</span><em class="sig-param">loader</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.LazyLoader" title="정의 주소">¶</a></dt>
<dd><p>모듈이 어트리뷰트에 액세스할 때까지 모듈 로더의 실행을 연기하는 클래스.</p>
<p>이 클래스는 필요한 모듈 형에 대한 제어로 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>을 정의하는 로더**에서만** 작동합니다. 같은 이유로, 로더의 <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> 메서드는 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환하거나, <a class="reference internal" href="../glossary.html#term-slots"><span class="xref std std-term">슬롯</span></a>을 사용하지 않고 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 어트리뷰트가 변경될 수 있는 형을 반환해야 합니다. 마지막으로, <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>에 배치된 객체를 치환하는 모듈은 인터프리터 전체에서 모듈 참조를 안전하게 대체할 방법이 없어서 작동하지 않습니다; 이러한 치환이 감지되면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>시작 시간이 중요한 프로젝트의 경우, 이 클래스를 사용하면 사용하지 않을 모듈을 로드하는 데 드는 비용을 최소화할 수 있습니다. 시작 시간이 핵심이 아닌 프로젝트의 경우 로딩이 지연되는 동안 만들어진, 따라서 문맥을 벗어난 에러 메시지 때문에, 이 클래스를 사용하지 말 것을 <strong>강하게</strong> 권고합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="#importlib.machinery.BuiltinImporter" title="importlib.machinery.BuiltinImporter"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.BuiltinImporter</span></code></a>와 <a class="reference internal" href="#importlib.machinery.ExtensionFileLoader" title="importlib.machinery.ExtensionFileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ExtensionFileLoader</span></code></a> 에 대한 호환성 경고를 제거하고, <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>을 호출하기 시작했습니다.</p>
</div>
<dl class="method">
<dt id="importlib.util.LazyLoader.factory">
<em class="property">classmethod </em><code class="sig-name descname">factory</code><span class="sig-paren">(</span><em class="sig-param">loader</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.LazyLoader.factory" title="정의 주소">¶</a></dt>
<dd><p>지연된 로더(lazy loader)를 만드는 콜러블을 반환하는 정적 메서드. 이것은 로더가 인스턴스가 아닌 클래스로 전달되는 상황에서 사용하려는 것입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">suffixes</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span>
<span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span>
<span class="n">lazy_loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">LazyLoader</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="n">lazy_loader</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="examples">
<span id="importlib-examples"></span><h2>예<a class="headerlink" href="#examples" title="제목 주소">¶</a></h2>
<div class="section" id="importing-programmatically">
<h3>프로그래밍 방식으로 임포트 하기<a class="headerlink" href="#importing-programmatically" title="제목 주소">¶</a></h3>
<p>프로그래밍 방식으로 모듈을 임포트 하려면, <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>을 사용하십시오.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib</span>

<span class="n">itertools</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;itertools&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="checking-if-a-module-can-be-imported">
<h3>모듈을 임포트 할 수 있는지 확인하기<a class="headerlink" href="#checking-if-a-module-can-be-imported" title="제목 주소">¶</a></h3>
<p>실제로 임포트를 수행하지 않고 모듈을 임포트 할 수 있는지 확인해야 하면, <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a>을 사용해야 합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># 설명을 위해.</span>
<span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;itertools&#39;</span>

<span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{name!r}</span><span class="s2"> already in sys.modules&quot;</span><span class="p">)</span>
<span class="k">elif</span> <span class="p">(</span><span class="n">spec</span> <span class="p">:</span><span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># 실제 임포트를 수행하기로 선택하면 ...</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{name!r}</span><span class="s2"> has been imported&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;can&#39;t find the </span><span class="si">{name!r}</span><span class="s2"> module&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="importing-a-source-file-directly">
<h3>소스 파일을 직접 임포트 하기<a class="headerlink" href="#importing-a-source-file-directly" title="제목 주소">¶</a></h3>
<p>파이썬 소스 파일을 직접 임포트 하려면, 다음 조리법을 사용하십시오 (파이썬 3.5 이상):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># 설명을 위해.</span>
<span class="kn">import</span> <span class="nn">tokenize</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="vm">__file__</span>
<span class="n">module_name</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="vm">__name__</span>

<span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">spec_from_file_location</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
<span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="setting-up-an-importer">
<h3>임포터 설정하기<a class="headerlink" href="#setting-up-an-importer" title="제목 주소">¶</a></h3>
<p>임포트의 심층 사용자 정의를 위해서는, 일반적으로 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">임포터</span></a>를 구현하려고 합니다. 이는 <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">파인더</span></a>와 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">로더</span></a> 측면을 모두 관리한다는 의미입니다. 파인더에는 필요에 따라 두 가지 종류가 있습니다: <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">메타 경로 파인더</span></a>나 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">경로 엔트리 파인더</span></a>. 전자는 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>에 배치하는 것이고 후자는 <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>에서 <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">경로 엔트리 훅</span></a>을 사용하여 만드는 것으로 <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path</span></code></a> 항목과 함께 작동하여 파인더를 만듭니다. 이 예제는 임포트가 임포터를 사용할 수 있도록 임포터를 등록하는 방법을 보여줍니다 (임포터를 직접 만들려면, 이 패키지에 정의된 적절한 클래스의 설명서를 읽으십시오):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.machinery</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># 오직 설명을 위해.</span>
<span class="n">SpamMetaPathFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">PathFinder</span>
<span class="n">SpamPathEntryFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span>
<span class="n">loader_details</span> <span class="o">=</span> <span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span><span class="p">,</span>
                  <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span><span class="p">)</span>

<span class="c1"># 메타 경로 파인더 설정하기.</span>
<span class="c1"># 파인더를 우선순위 측면에서 리스트의 올바른 위치에 넣으십시오.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamMetaPathFinder</span><span class="p">)</span>

<span class="c1"># 경로 엔트리 파인더 설정하기.</span>
<span class="c1"># 경로 훅을 우선순위 측면에서 리스트의 올바른 위치에 넣으십시오.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamPathEntryFinder</span><span class="o">.</span><span class="n">path_hook</span><span class="p">(</span><span class="n">loader_details</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="approximating-importlib-import-module">
<h3><a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 근사하기<a class="headerlink" href="#approximating-importlib-import-module" title="제목 주소">¶</a></h3>
<p>임포트 자체는 파이썬 코드로 구현되므로, importlib를 통해 대부분의 임포트 절차를 노출할 수 있습니다. 다음은 <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>의 근사적인(approximate) 구현을 제공하여 importlib가 노출하는 다양한 API를 설명하는 데 도움을 줍니다 (importlib 사용법에 대해서는 파이썬 3.4 이상, 코드의 다른 부분에 대해서는 파이썬 3.6 이상).</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">import_module</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;import의 대략적인 구현.&quot;&quot;&quot;</span>
    <span class="n">absolute_name</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">resolve_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">absolute_name</span><span class="p">:</span>
        <span class="n">parent_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">child_name</span> <span class="o">=</span> <span class="n">absolute_name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">parent_module</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="n">parent_name</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">parent_module</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">submodule_search_locations</span>
    <span class="k">for</span> <span class="n">finder</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">absolute_name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;No module named </span><span class="si">{absolute_name!r}</span><span class="s1">&#39;</span>
        <span class="k">raise</span> <span class="n">ModuleNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">absolute_name</span><span class="p">)</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">parent_module</span><span class="p">,</span> <span class="n">child_name</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">module</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> --- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>의 구현</a><ul>
<li><a class="reference internal" href="#introduction">소개</a></li>
<li><a class="reference internal" href="#functions">함수</a></li>
<li><a class="reference internal" href="#module-importlib.abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code> -- import와 관련된 추상 베이스 클래스</a></li>
<li><a class="reference internal" href="#module-importlib.resources"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code> -- 리소스</a></li>
<li><a class="reference internal" href="#module-importlib.machinery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code> -- 임포터와 경로 훅</a></li>
<li><a class="reference internal" href="#module-importlib.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code> -- 임포터를 위한 유틸리티 코드</a></li>
<li><a class="reference internal" href="#examples">예</a><ul>
<li><a class="reference internal" href="#importing-programmatically">프로그래밍 방식으로 임포트 하기</a></li>
<li><a class="reference internal" href="#checking-if-a-module-can-be-imported">모듈을 임포트 할 수 있는지 확인하기</a></li>
<li><a class="reference internal" href="#importing-a-source-file-directly">소스 파일을 직접 임포트 하기</a></li>
<li><a class="reference internal" href="#setting-up-an-importer">임포터 설정하기</a></li>
<li><a class="reference internal" href="#approximating-importlib-import-module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code> 근사하기</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="runpy.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code> --- 파이썬 모듈 찾기와 실행</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="importlib.metadata.html"
                        title="다음 장">importlib.metadata 사용하기</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="importlib.metadata.html" title="importlib.metadata 사용하기"
             >다음</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy --- 파이썬 모듈 찾기와 실행"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" >모듈 임포트 하기</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>