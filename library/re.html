
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>re --- 정규식 연산 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="difflib --- 델타 계산을 위한 도우미" href="difflib.html" />
    <link rel="prev" title="string --- 일반적인 문자열 연산" href="string.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/re.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="difflib.html" title="difflib --- 델타 계산을 위한 도우미"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="string.html" title="string --- 일반적인 문자열 연산"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="text.html" accesskey="U">텍스트 처리 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-re">
<span id="re-regular-expression-operations"></span><h1><a class="reference internal" href="#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> --- 정규식 연산<a class="headerlink" href="#module-re" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/re.py">Lib/re.py</a></p>
<hr class="docutils" />
<p>이 모듈은 Perl에 있는 것과 유사한 정규식 일치 연산을 제공합니다.</p>
<p>패턴과 검색 할 문자열은 모두 유니코드 문자열(<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>)과 8비트 문자열(<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>)이 될 수 있습니다. 그러나, 유니코드 문자열과 8비트 문자열은 혼합될 수 없습니다: 즉, 유니코드 문자열을 바이트열 패턴과 일치시킬 수 없으며 그 반대도 마찬가지입니다; 마찬가지로, 치환을 요청할 때, 치환 문자열은 패턴과 검색 문자열과 같은 형이어야 합니다.</p>
<p>정규식은 역 슬래시 문자(<code class="docutils literal notranslate"><span class="pre">'\'</span></code>)를 사용하여 특수 형식을 나타내거나 특별한 의미를 갖지 않고 특수 문자를 사용할 수 있게 합니다. 이것은 문자열 리터럴에서 같은 목적을 위해 같은 문자를 사용하는 파이썬과 충돌합니다; 예를 들어, 리터럴 역 슬래시와 일치시키려면 <code class="docutils literal notranslate"><span class="pre">'\\\\'</span></code>를 패턴 문자열로 작성해야 하는데, 정규식은 <code class="docutils literal notranslate"><span class="pre">\\</span></code> 여야하고, 각 역 슬래시는 일반 파이썬 문자열 리터럴 내에서 <code class="docutils literal notranslate"><span class="pre">\\</span></code>로 표현되어야 하기 때문입니다. 또한, 파이썬의 문자열 리터럴에서 역 슬래시가 사용될 때 유효하지 않은 이스케이프 시퀀스는 이제 <a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>을 생성하고 앞으로는 <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>가 될 것이라는 점에 유의하십시오. 이 동작은 정규식에서 유효한 이스케이프 시퀀스인 경우에도 발생합니다.</p>
<p>해결책은 정규식 패턴에 파이썬의 날 문자열(raw string) 표기법을 사용하는 것입니다; 역 슬래시는 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> 접두어가 붙은 문자열 리터럴에서 특별한 방법으로 처리되지 않습니다. 따라서 <code class="docutils literal notranslate"><span class="pre">r&quot;\n&quot;</span></code>은 <code class="docutils literal notranslate"><span class="pre">'\'</span></code>와 <code class="docutils literal notranslate"><span class="pre">'n'</span></code>을 포함하는 두 글자 문자열이고, <code class="docutils literal notranslate"><span class="pre">&quot;\n&quot;</span></code>은 개행을 포함하는 한 글자 문자열입니다. 일반적으로 패턴은, 이 날 문자열 표기법을 사용하여 파이썬 코드로 표현됩니다.</p>
<p>대부분 정규식 연산은 모듈 수준 함수와 <a class="reference internal" href="#re-objects"><span class="std std-ref">컴파일된 정규식</span></a>의 메서드로 사용할 수 있다는 점에 유의해야 합니다. 함수는 정규식 객체를 먼저 컴파일할 필요가 없도록 하는 바로 가기이지만, 일부 미세 조정 매개 변수가 빠져있습니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>제삼자 <a class="reference external" href="https://pypi.org/project/regex/">regex</a> 모듈은 표준 라이브러리 <a class="reference internal" href="#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 모듈과 호환되는 API를 가지고 있지만, 추가 기능과 더 철저한 유니코드 지원을 제공합니다.</p>
</div>
<div class="section" id="regular-expression-syntax">
<span id="re-syntax"></span><h2>정규식 문법<a class="headerlink" href="#regular-expression-syntax" title="제목 주소">¶</a></h2>
<p>정규식(또는 RE)은 일치하는 문자열 집합을 지정합니다; 이 모듈의 함수는 특정 문자열이 주어진 정규식과 일치하는지 확인할 수 있도록 합니다 (또는 주어진 정규식이 특정 문자열과 일치하는지, 결국 같은 결과를 줍니다).</p>
<p>정규식을 이어붙여서 새로운 정규식을 만들 수 있습니다; <em>A</em>와 <em>B</em>가 모두 정규식이면 <em>AB</em>도 정규식입니다. 일반적으로 문자열 <em>p</em>가 <em>A</em>와 일치하고 다른 문자열 <em>q</em>가 <em>B</em>와 일치하면 문자열 <em>pq</em>가 AB와 일치합니다. 이것은 <em>A</em>나 <em>B</em>가 우선순위가 낮은 연산, <em>A</em>와 <em>B</em> 사이의 경계 조건 또는 숫자 그룹 참조를 포함하지 않는 한 성립합니다. 따라서, 복잡한 정규식은 여기에 설명된 것과 같은 더 단순한 기본 정규식으로 쉽게 구성할 수 있습니다. 정규식의 이론과 구현에 관한 자세한 내용은 Friedl 책 <a class="reference internal" href="#frie09" id="id1"><span>[Frie09]</span></a>, 또는 컴파일러 작성에 관한 거의 모든 교과서를 참조하십시오.</p>
<p>정규식의 형식에 대한 간단한 설명이 이어집니다. 더 자세한 정보와 더 친절한 소개는 <a class="reference internal" href="../howto/regex.html#regex-howto"><span class="std std-ref">정규식 HOWTO</span></a>를 참조하십시오.</p>
<p>정규식은 특수 문자와 일반 문자를 모두 포함 할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">'A'</span></code>, <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'0'</span></code>과 같은 대부분의 일반 문자는 가장 단순한 정규식입니다; 그들은 단순히 자신과 일치합니다. 일반 문자를 이어 붙일 수 있어서, <code class="docutils literal notranslate"><span class="pre">last</span></code>는 <code class="docutils literal notranslate"><span class="pre">'last'</span></code> 문자열과 일치합니다. (이 절의 나머지 부분에서는, RE를 (보통 따옴표 없이) <code class="docutils literal notranslate"><span class="pre">이런</span> <span class="pre">특별한</span> <span class="pre">스타일</span></code>로, 일치할 문자열은 <code class="docutils literal notranslate"><span class="pre">'작은따옴표</span> <span class="pre">안에'</span></code> 씁니다.)</p>
<p><code class="docutils literal notranslate"><span class="pre">'|'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'('</span></code>와 같은 일부 문자는 특수합니다. 특수 문자는 일반 문자의 클래스를 나타내거나, 그 주변의 정규식이 해석되는 방식에 영향을 줍니다.</p>
<p>반복 한정자(<code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code> 등)는 직접 중첩될 수 없습니다. 이렇게 하면 비 탐욕적인 수정자 접미사인 <code class="docutils literal notranslate"><span class="pre">?</span></code>와 다른 구현의 다른 수정자와의 모호함을 피할 수 있습니다. 내부 반복에 두 번째 반복을 적용하려면 괄호를 사용할 수 있습니다. 예를 들어, 정규식 <code class="docutils literal notranslate"><span class="pre">(?:a{6})*</span></code>는 여섯 개의 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 문자가 임의로 반복되는 것과 일치합니다.</p>
<p>특수 문자는 다음과 같습니다:</p>
<dl class="simple" id="index-0">
<dt><code class="docutils literal notranslate"><span class="pre">.</span></code></dt><dd><p>(점.) 기본 모드에서, 이것은 개행 문자를 제외한 모든 문자와 일치합니다. <a class="reference internal" href="#re.DOTALL" title="re.DOTALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">DOTALL</span></code></a> 플래그가 지정되면, 개행 문자를 포함한 모든 문자와 일치합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-1">
<dt><code class="docutils literal notranslate"><span class="pre">^</span></code></dt><dd><p>(캐럿.) 문자열의 시작과 일치하고, <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 모드에서는 각 개행 직후에도 일치합니다.</p>
</dd>
</dl>
<dl id="index-2">
<dt><code class="docutils literal notranslate"><span class="pre">$</span></code></dt><dd><p>문자열의 끝이나 문자열 끝의 개행 문자 바로 직전과 일치하고, <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 모드에서는 개행 문자 앞에서도 일치합니다. <code class="docutils literal notranslate"><span class="pre">foo</span></code>는 'foo'와 'foobar'를 모두 일치시키는 반면, 정규식 <code class="docutils literal notranslate"><span class="pre">foo$</span></code>는 'foo' 만 일치합니다. 흥미롭게도, <code class="docutils literal notranslate"><span class="pre">'foo1\nfoo2\n'</span></code>에서 <code class="docutils literal notranslate"><span class="pre">foo.$</span></code>를 검색하면 'foo2' 는 정상적으로 일치되지만, 'foo1'은 <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 모드에서 검색됩니다; <code class="docutils literal notranslate"><span class="pre">'foo\n'</span></code>에서 단일 <code class="docutils literal notranslate"><span class="pre">$</span></code>를 검색하면 두 개의 (빈) 일치가 발견됩니다: 하나는 개행 직전에, 다른 하나는 문자열 끝에.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>문자열 끝에 있는 개행 문자가 특별하게 취급된다는 것에 유의하십시오. 다음 예가 도움이 될지도 모르겠습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="s1">&#39;$&#39;</span><span class="p">,</span> <span class="s1">&#39;foo</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="go">[&lt;re.Match object; span=(4, 4), match=&#39;&#39;&gt;, &lt;re.Match object; span=(5, 5), match=&#39;&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="s1">&#39;$&#39;</span><span class="p">,</span> <span class="s1">&#39;foo</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">))</span>
<span class="go">[&lt;re.Match object; span=(3, 3), match=&#39;&#39;&gt;, &lt;re.Match object; span=(4, 4), match=&#39;&#39;&gt;, &lt;re.Match object; span=(5, 5), match=&#39;&#39;&gt;]</span>
</pre></div>
</div>
</div>
</dd>
</dl>
<dl class="simple" id="index-3">
<dt><code class="docutils literal notranslate"><span class="pre">*</span></code></dt><dd><p>결과 RE가 선행 RE의 가능한 한 많은 0회 이상의 반복과 일치하도록 합니다. <code class="docutils literal notranslate"><span class="pre">ab*</span></code>는 'a', 'ab' 또는 'a' 다음에 임의의 수의 'b'가 오는 것과 일치합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-4">
<dt><code class="docutils literal notranslate"><span class="pre">+</span></code></dt><dd><p>결과 RE가 선행 RE의 1회 이상의 반복과 일치하도록 합니다. <code class="docutils literal notranslate"><span class="pre">ab+</span></code>는 'a' 다음에 하나 이상의 'b'가 오는 것과 일치합니다; 단지 'a'와는 일치하지 않습니다.</p>
</dd>
</dl>
<dl class="simple" id="index-5">
<dt><code class="docutils literal notranslate"><span class="pre">?</span></code></dt><dd><p>결과 RE가 선행 RE의 0 또는 1 반복과 일치하도록 합니다. <code class="docutils literal notranslate"><span class="pre">ab?</span></code>는 'a'나 'ab'와 일치합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-6">
<dt><code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">+?</span></code>, <code class="docutils literal notranslate"><span class="pre">??</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'?'</span></code> 한정자는 모두 <em class="dfn">탐욕적 (greedy)</em>입니다; 가능한 한 많은 텍스트와 일치합니다. 때로는 이 동작이 바람직하지 않습니다; RE <code class="docutils literal notranslate"><span class="pre">&lt;.*&gt;</span></code>를 <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;</span> <span class="pre">b</span> <span class="pre">&lt;c&gt;'</span></code>와 일치시키면, <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>가 아닌 전체 문자열과 일치합니다. 한정자 뒤에 <code class="docutils literal notranslate"><span class="pre">?</span></code>를 추가하면 <em class="dfn">비 탐욕적 (non-greedy)</em> 또는 <em class="dfn">최소 (minimal)</em> 방식으로 일치를 수행합니다; 가능하면 <em>적은</em> 문자가 일치합니다. RE <code class="docutils literal notranslate"><span class="pre">&lt;.*?&gt;</span></code>를 사용하면 <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code> 만 일치합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-7">
<dt><code class="docutils literal notranslate"><span class="pre">{m}</span></code></dt><dd><p>선행 RE의 정확히 <em>m</em> 복사가 일치하도록 지정합니다; 적은 횟수의 일치는 전체 RE가 일치하지 않게 됩니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">a{6}</span></code>는 정확히 6개의 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 문자와 일치하지만, 5개의 문자와는 일치하지 않습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}</span></code></dt><dd><p>결과 RE를 선행 RE의 <em>m</em>에서 <em>n</em> 사이의 최대한 많은 반복과 일치하도록 합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code>는 3에서 5개의 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 문자와 일치합니다. <em>m</em>을 생략하면 하한값 0이 지정되고, <em>n</em>을 생략하면 무한한 상한이 지정됩니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">a{4,}b</span></code>는 <code class="docutils literal notranslate"><span class="pre">'aaaab'</span></code> 나 1000개의 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 문자와 <code class="docutils literal notranslate"><span class="pre">'b'</span></code>가 일치하지만, <code class="docutils literal notranslate"><span class="pre">'aaab'</span></code>는 일치하지 않습니다. 콤마는 생략할 수 없습니다, 그렇지 않으면 한정자가 앞에서 설명한 형식과 혼동될 수 있습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}?</span></code></dt><dd><p>결과 RE를 선행 RE의 <em>m</em>에서 <em>n</em> 사이의 가능한 한 <em>적은</em> 반복과 일치하도록 합니다. 이것은 이전 한정자의 비 탐욕적 버전입니다. 예를 들어, 6문자 문자열 <code class="docutils literal notranslate"><span class="pre">'aaaaaa'</span></code>에서, <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code>는 5개의 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 문자와 일치하고, <code class="docutils literal notranslate"><span class="pre">a{3,5}?</span></code>는 3개의 문자만 일치합니다.</p>
</dd>
</dl>
<dl id="index-8">
<dt><code class="docutils literal notranslate"><span class="pre">\</span></code></dt><dd><p>특수 문자를 이스케이프 하거나 (<code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'?'</span></code> 등의 문자를 일치시킬 수 있도록 합니다), 특수 시퀀스를 알립니다; 특수 시퀀스는 아래에서 설명합니다.</p>
<p>날 문자열을 사용하여 패턴을 표현하지 않는다면, 파이썬이 문자열 리터럴에서 이스케이프 시퀀스로 역 슬래시를 사용한다는 것을 기억하십시오; 이스케이프 시퀀스가 파이썬의 구문 분석기에 의해 인식되지 않으면, 역 슬래시와 후속 문자가 결과 문자열에 포함됩니다. 그러나 파이썬이 결과 시퀀스를 인식한다면 역 슬래시는 두 번 반복되어야 합니다. 이것은 복잡하고 이해하기 어렵기 때문에, 가장 단순한 표현 이외에는 날 문자열을 사용하는 것이 좋습니다.</p>
</dd>
</dl>
<dl id="index-9">
<dt><code class="docutils literal notranslate"><span class="pre">[]</span></code></dt><dd><p>문자 집합을 나타내는 데 사용됩니다. 집합 안에서:</p>
<ul class="simple">
<li><p>문자는 개별적으로 나열 할 수 있습니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">[amk]</span></code>는 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'k'</span></code>와 일치합니다.</p></li>
</ul>
<ul class="simple" id="index-10">
<li><p>문자의 범위는 <code class="docutils literal notranslate"><span class="pre">'-'</span></code>로 구분된 두 문자를 주고는 것으로 나타낼 수 있습니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code>는 모든 소문자 ASCII 문자와 일치하고, <code class="docutils literal notranslate"><span class="pre">[0-5][0-9]</span></code>는 <code class="docutils literal notranslate"><span class="pre">00</span></code>에서 <code class="docutils literal notranslate"><span class="pre">59</span></code>까지의 모든 두 자리 숫자와 일치하며, <code class="docutils literal notranslate"><span class="pre">[0-9A-Fa-f]</span></code>는 모든 16진수와 일치합니다. <code class="docutils literal notranslate"><span class="pre">-</span></code>가 이스케이프 처리되거나 (예를 들어 <code class="docutils literal notranslate"><span class="pre">[a\-z]</span></code>) 첫 번째나 마지막 문자로 배치되면 (예를 들어 <code class="docutils literal notranslate"><span class="pre">[-a]</span></code>나 <code class="docutils literal notranslate"><span class="pre">[a-]</span></code>) 리터럴 <code class="docutils literal notranslate"><span class="pre">'-'</span></code>와 일치합니다.</p></li>
<li><p>특수 문자는 집합 내에서 특별한 의미를 상실합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[(+*)]</span></code>는 리터럴 문자 <code class="docutils literal notranslate"><span class="pre">'('</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code>, <code class="docutils literal notranslate"><span class="pre">'*'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">')'</span></code>와 일치합니다.</p></li>
</ul>
<ul class="simple" id="index-11">
<li><p><code class="docutils literal notranslate"><span class="pre">\w</span></code> 나 <code class="docutils literal notranslate"><span class="pre">\S</span></code>(아래에서 정의됩니다)와 같은 문자 클래스도 집합 내에서 허용되지만, 일치하는 문자는 <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a>나 <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> 모드가 유효한지에 따라 다릅니다.</p></li>
</ul>
<ul class="simple" id="index-12">
<li><p>범위 내에 있지 않은 문자는 <em class="dfn">여집합(complementing)</em>을 만들어 일치할 수 있습니다. 집합의 첫 번째 문자가 <code class="docutils literal notranslate"><span class="pre">'^'</span></code>이면, 집합에 속하지 <em>않은</em> 모든 문자가 일치합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[^5]</span></code>는 <code class="docutils literal notranslate"><span class="pre">'5'</span></code>를 제외한 모든 문자와 일치하며, <code class="docutils literal notranslate"><span class="pre">[^^]</span></code>는 <code class="docutils literal notranslate"><span class="pre">'^'</span></code>를 제외한 모든 문자와 일치합니다. <code class="docutils literal notranslate"><span class="pre">^</span></code>는 집합의 첫 번째 문자가 아닐 때 특별한 의미가 없습니다.</p></li>
<li><p>집합 내에서 리터럴 <code class="docutils literal notranslate"><span class="pre">']'</span></code>를 일치시키려면, 앞에 역 슬래시를 붙이거나, 집합의 시작 부분에 배치하십시오. 예를 들어, <code class="docutils literal notranslate"><span class="pre">[()[\]{}]</span></code>와 <code class="docutils literal notranslate"><span class="pre">[]()[{}]</span></code>는 둘 다 괄호와 일치합니다.</p></li>
</ul>
<ul class="simple">
<li><p><a class="reference external" href="https://unicode.org/reports/tr18/">유니코드 기술 표준 #18</a> 에서 정의하는 중첩 집합과 집합 연산의 지원이 다음에 추가될 수 있습니다. 이것은 문법을 변경하므로, 이 변경을 용이하게 하기 위해 당분간 <a class="reference internal" href="exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a>이 모호한 경우에 발생합니다. 여기에는 리터럴 <code class="docutils literal notranslate"><span class="pre">'['</span></code>로 시작하거나 리터럴 문자 시퀀스 <code class="docutils literal notranslate"><span class="pre">'--'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&amp;&amp;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'~~'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'||'</span></code>가 포함된 집합이 포함됩니다. 경고를 피하려면 역 슬래시로 이스케이프 처리하십시오.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>문자 집합이 미래에 의미가 변할 구조를 포함하고 있다면 <a class="reference internal" href="exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a>이 발생합니다.</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-13">
<dt><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">A|B</span></code>(여기서 <em>A</em>와 <em>B</em>는 임의의 RE일 수 있습니다)는 <em>A</em>나 <em>B</em>와 일치하는 정규식을 만듭니다. 이러한 방식으로 임의의 수의 RE를 <code class="docutils literal notranslate"><span class="pre">'|'</span></code>로 분리 할 수 있습니다. 이것은 그룹(아래를 참조하세요)에서도 사용할 수 있습니다. 대상 문자열이 스캔 될 때 <code class="docutils literal notranslate"><span class="pre">'|'</span></code>로 구분된 RE는 왼쪽에서 오른쪽으로 시도됩니다. 한 패턴이 완전히 일치하면, 해당 분기가 받아들여집니다. 이는 일단 <em>A</em>가 일치하면, <em>B</em>는 전체적으로 더 긴 일치를 생성하더라도 더 검사되지 않는다는 것을 뜻합니다. 즉, <code class="docutils literal notranslate"><span class="pre">'|'</span></code> 연산자는 절대로 탐욕적이지 않습니다. 리터럴 <code class="docutils literal notranslate"><span class="pre">'|'</span></code>와 일치시키려면, <code class="docutils literal notranslate"><span class="pre">\|</span></code>를 사용하거나, <code class="docutils literal notranslate"><span class="pre">[|]</span></code>처럼 문자 클래스 안에 넣으십시오.</p>
</dd>
</dl>
<dl class="simple" id="index-14">
<dt><code class="docutils literal notranslate"><span class="pre">(...)</span></code></dt><dd><p>괄호 안에 있는 정규식과 일치하며, 그룹의 시작과 끝을 나타냅니다; 그룹의 내용은 일치가 수행된 후 조회할 수 있으며, 나중에 문자열에서 <code class="docutils literal notranslate"><span class="pre">\number</span></code> 특수 시퀀스로 일치시킬 수 있습니다 (아래에서 설명됩니다). 리터럴 <code class="docutils literal notranslate"><span class="pre">'('</span></code>나 <code class="docutils literal notranslate"><span class="pre">')'</span></code>를 일치시키려면, <code class="docutils literal notranslate"><span class="pre">\(</span></code>나 <code class="docutils literal notranslate"><span class="pre">\)</span></code>를 사용하거나, 문자 클래스 안에 넣으십시오: <code class="docutils literal notranslate"><span class="pre">[(]</span></code>, <code class="docutils literal notranslate"><span class="pre">[)]</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-15">
<dt><code class="docutils literal notranslate"><span class="pre">(?...)</span></code></dt><dd><p>이것은 확장 표기법입니다 (그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">'('</span></code> 다음에 오는 <code class="docutils literal notranslate"><span class="pre">'?'``는</span> <span class="pre">의미가</span> <span class="pre">없습니다).</span> <span class="pre">``'?'</span></code> 다음의 첫 번째 문자는 확장의 의미와 이후의 문법을 결정합니다. 확장은 대개 새 그룹을 만들지 않습니다; 이 규칙에 대한 유일한 예외는 <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code>입니다. 다음은 현재 지원되는 확장입니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?aiLmsux)</span></code></dt><dd><p>(집합 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>의 문자 중 하나 이상.) 그룹은 빈 문자열과 일치합니다; 문자는 해당 플래그를 전체 정규식에 대해 설정합니다: <a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (ASCII만 일치), <a class="reference internal" href="#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (케이스 무시), <a class="reference internal" href="#re.L" title="re.L"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.L</span></code></a> (로케일 종속), <a class="reference internal" href="#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (여러 줄), <a class="reference internal" href="#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (점이 모든 문자와 일치), <code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code> (유니코드 일치) 및 <a class="reference internal" href="#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (상세 모드). (플래그는 <a class="reference internal" href="#contents-of-module-re"><span class="std std-ref">모듈 내용</span></a>에 설명되어 있습니다.) <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> 함수에 <em>flag</em> 인자를 전달하는 대신, 정규식의 일부로 플래그를 포함하려는 경우에 유용합니다. 플래그는 정규식 문자열에서 처음에 사용해야 합니다.</p>
</dd>
</dl>
<dl id="index-16">
<dt><code class="docutils literal notranslate"><span class="pre">(?:...)</span></code></dt><dd><p>일반 괄호의 비 포착 버전. 괄호 안의 정규식과 일치하지만, 그룹과 일치하는 부분 문자열은 일치를 수행한 후 조회하거나 나중에 패턴에서 참조할 수 <em>없습니다</em>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?aiLmsux-imsx:...)</span></code></dt><dd><p>(집합 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>의 문자 중 0개 이상, 선택적으로 <code class="docutils literal notranslate"><span class="pre">'-'</span></code>와 그 뒤에 <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 중 하나 이상의 문자가 따라옵니다.) 문자는 해당 플래그를 정규식의 일부에 대해 설정하거나 제거합니다: <a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (ASCII만 일치), <a class="reference internal" href="#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (케이스 무시), <a class="reference internal" href="#re.L" title="re.L"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.L</span></code></a> (로케일 종속), <a class="reference internal" href="#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (여러 줄), <a class="reference internal" href="#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (점이 모든 문자와 일치), <code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code> (유니코드 일치) 및 <a class="reference internal" href="#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (상세 모드). (플래그는 <a class="reference internal" href="#contents-of-module-re"><span class="std std-ref">모듈 내용</span></a>에 설명되어 있습니다.)</p>
<p>문자 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'u'</span></code>는 인라인 플래그로 사용될 때 상호 배타적이므로, <code class="docutils literal notranslate"><span class="pre">'-'</span></code>와 결합하거나 그 뒤에 올 수 없습니다. 대신, 이 중 하나가 인라인 그룹에 나타나면, 그것은 둘러싸는 그룹의 일치 모드를 재정의합니다. 유니코드 패턴에서 <code class="docutils literal notranslate"><span class="pre">(?a:...)</span></code>는 ASCII 전용 일치로 전환하고, <code class="docutils literal notranslate"><span class="pre">(?u:...)</span></code>는 유니코드 일치(기본값)로 전환합니다. 바이트열 패턴에서 <code class="docutils literal notranslate"><span class="pre">(?L:...)</span></code>는 로케일 종속 일치로 전환하고, <code class="docutils literal notranslate"><span class="pre">(?a:...)</span></code>는 ASCII 전용 일치(기본값)로 전환합니다. 이 재정의는 좁은 인라인 그룹에 대해서만 적용되며, 원래의 일치 모드는 그룹 밖에서 복원됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>문자 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'u'</span></code>도 그룹에서 사용할 수 있습니다.</p>
</div>
</dd>
</dl>
<dl id="index-17">
<dt><code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code></dt><dd><p>일반 괄호와 유사하지만, 그룹과 일치하는 부분 문자열은 기호 그룹 이름 <em>name</em>을 통해 액세스 할 수 있습니다. 그룹 이름은 유효한 파이썬 식별자여야 하며, 각 그룹 이름은 정규식 내에서 한 번만 정의해야 합니다. 기호 그룹은 번호 그룹이기도 합니다, 마치 그룹이 이름 붙지 않은 것처럼.</p>
<p>이름 있는 그룹은 세 가지 문맥에서 참조될 수 있습니다. 패턴이 <code class="docutils literal notranslate"><span class="pre">(?P&lt;quote&gt;['&quot;]).*?(?P=quote)</span></code>면 (즉, 작은따옴표나 큰따옴표로 인용된 문자열과 일치):</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 53%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>그룹 &quot;quote&quot;에 대한 참조 문맥</p></th>
<th class="head"><p>참조하는 방법</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>같은 패턴 자체에서</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(?P=quote)</span></code> (보이는 대로)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>일치 객체 <em>m</em>을 처리할 때</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m.group('quote')</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m.end('quote')</span></code> (등)</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">re.sub()</span></code>의 <em>repl</em> 인자로 전달되는 문자열에서</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\g&lt;quote&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl class="simple" id="index-18">
<dt><code class="docutils literal notranslate"><span class="pre">(?P=name)</span></code></dt><dd><p>이름있는 그룹에 대한 역참조; <em>name</em>이라는 이름의 앞선 그룹과 일치하는 텍스트와 일치합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-19">
<dt><code class="docutils literal notranslate"><span class="pre">(?#...)</span></code></dt><dd><p>주석; 괄호의 내용은 단순히 무시됩니다.</p>
</dd>
</dl>
<dl class="simple" id="index-20">
<dt><code class="docutils literal notranslate"><span class="pre">(?=...)</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">...</span></code>가 다음과 일치하면 일치하지만, 문자열을 소비하지는 않습니다. 이를 <em class="dfn">미리 보기 어서션 (lookahead assertion)</em>이라고 합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?=Asimov)</span></code>는 <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>가 뒤따를 때만 <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code>과 일치합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-21">
<dt><code class="docutils literal notranslate"><span class="pre">(?!...)</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">...</span></code>가 다음과 일치하지 않으면 일치합니다. 이것은 <em class="dfn">부정적인 미리 보기 어서션 (negative lookahead assertion)</em>입니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?!Asimov)</span></code>는 <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>가 뒤따르지 <em>않을</em> 때 만 <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code>과 일치합니다.</p>
</dd>
</dl>
<dl id="index-22">
<dt><code class="docutils literal notranslate"><span class="pre">(?&lt;=...)</span></code></dt><dd><p>문자열의 현재 위치 앞에 현재 위치에서 끝나는 <code class="docutils literal notranslate"><span class="pre">...</span></code>와의 일치가 있으면 일치합니다. 이를 <em class="dfn">긍정적인 되돌아보기 어서션 (positive lookbehind assertion)</em>이라고 합니다. 되돌아보기가 3문자를 백업하고 포함된 패턴이 일치하는지 확인하기 때문에 <code class="docutils literal notranslate"><span class="pre">(?&lt;=abc)def</span></code>는 <code class="docutils literal notranslate"><span class="pre">'abcdef'</span></code>에서 일치를 찾습니다. 포함된 패턴은 고정 길이의 문자열과 일치해야 합니다, 즉, <code class="docutils literal notranslate"><span class="pre">abc</span></code>나 <code class="docutils literal notranslate"><span class="pre">a|b</span></code>는 허용되지만, <code class="docutils literal notranslate"><span class="pre">a*</span></code>와 <code class="docutils literal notranslate"><span class="pre">a{3,4}</span></code>는 허용되지 않습니다. 긍정적인 되돌아보기 어서션으로 시작하는 패턴은 검색되는 문자열의 시작 부분에서 일치하지 않음에 유의하십시오; <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> 함수보다는 <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> 함수를 사용하기를 원할 것입니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;(?&lt;=abc)def&#39;</span><span class="p">,</span> <span class="s1">&#39;abcdef&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
</pre></div>
</div>
<p>이 예에서는 하이픈 다음의 단어를 찾습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?&lt;=-)\w+&#39;</span><span class="p">,</span> <span class="s1">&#39;spam-egg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;egg&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>고정 길이의 그룹 참조에 대한 지원이 추가되었습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><code class="docutils literal notranslate"><span class="pre">r'(?&lt;=\1)'</span></code> 과 같은 패턴이 유효하다는 뜻입니다. 다만 역참조가 고정 길이의 그룹을 가리킬 때만 허용됩니다.</p>
</div>
</div>
</dd>
</dl>
<dl id="index-23">
<dt><code class="docutils literal notranslate"><span class="pre">(?&lt;!...)</span></code></dt><dd><p>문자열의 현재 위치 앞에 <code class="docutils literal notranslate"><span class="pre">...</span></code>와의 일치가 없으면 일치합니다. 이를 <em class="dfn">부정적인 뒤돌아보기 어서션 (negative lookbehind assertion)</em>이라고 합니다. 긍정적인 뒤돌아보기 어서션과 마찬가지로, 포함된 패턴은 고정 길이의 문자열과 일치해야 합니다. 부정적인 뒤돌아보기 어서션으로 시작하는 패턴은 검색되는 문자열의 시작 부분에서 일치 할 수 있습니다.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?(id/name)yes-pattern|no-pattern)</span></code></dt><dd><p>주어진 <em>id</em>나 <em>name</em>의 그룹이 있으면 <code class="docutils literal notranslate"><span class="pre">yes-pattern</span></code>과, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">no-pattern</span></code>과 일치하려고 시도합니다. <code class="docutils literal notranslate"><span class="pre">no-pattern</span></code>은 선택적이며 생략될 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">(&lt;)?(\w+&#64;\w+(?:\.\w+)+)(?(1)&gt;|$)</span></code>는 정교하지 않은 전자 메일 일치 패턴인데, <code class="docutils literal notranslate"><span class="pre">'&lt;user&#64;host.com&gt;'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'user&#64;host.com'</span></code>과 일치하지만, <code class="docutils literal notranslate"><span class="pre">'&lt;user&#64;host.com'</span></code>이나 <code class="docutils literal notranslate"><span class="pre">'user&#64;host.com&gt;'</span></code>과는 일치하지 않습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><em>id</em> 는 그룹 번호, <em>name</em> 은 그룹 이름입니다. 즉, <code class="docutils literal notranslate"><span class="pre">(?(1)...)</span></code> 이나 <code class="docutils literal notranslate"><span class="pre">(?(name)...)</span></code> 과 같은 표현이
가능합니다. 예에서는 번호를 사용했는데, <code class="docutils literal notranslate"><span class="pre">?(1)</span></code>은 패턴의 처음에 나오는 그룹 <code class="docutils literal notranslate"><span class="pre">(&lt;)</span></code>를 가리킵니다.</p>
</div>
</dd>
</dl>
<p>특수 시퀀스는 <code class="docutils literal notranslate"><span class="pre">'\'</span></code>와 아래 목록의 문자로 구성됩니다. 일반 문자가 ASCII 숫자나 ASCII 글자가 아니면, 결과 RE는 두 번째 문자와 일치합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">\$</span></code>는 문자 <code class="docutils literal notranslate"><span class="pre">'$'</span></code>와 일치합니다.</p>
<dl class="simple" id="index-24">
<dt><code class="docutils literal notranslate"><span class="pre">\number</span></code></dt><dd><p>같은 번호의 그룹 내용과 일치합니다. 그룹은 1부터 번호가 매겨집니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">(.+)</span> <span class="pre">\1</span></code>은 <code class="docutils literal notranslate"><span class="pre">'the</span> <span class="pre">the'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'55</span> <span class="pre">55'</span></code>와 일치하지만, <code class="docutils literal notranslate"><span class="pre">'thethe'</span></code>와는 일치하지 않습니다 (그룹 뒤의 공백에 유의하십시오). 이 특수 시퀀스는 첫 99개 그룹 중 하나와 일치하는 데에만 사용될 수 있습니다. <em>number</em>의 첫 자릿수가 0이거나, <em>number</em>가 3 자릿수면, 그룹 일치로 해석되지 않고, 8진수 값 <em>number</em>를 갖는 문자로 해석됩니다. 문자 클래스의 <code class="docutils literal notranslate"><span class="pre">'['</span></code>와 <code class="docutils literal notranslate"><span class="pre">']'</span></code> 안에서는, 모든 숫자 이스케이프가 문자로 처리됩니다.</p>
</dd>
</dl>
<dl class="simple" id="index-25">
<dt><code class="docutils literal notranslate"><span class="pre">\A</span></code></dt><dd><p>문자열의 시작 부분에서만 일치합니다.</p>
</dd>
</dl>
<dl id="index-26">
<dt><code class="docutils literal notranslate"><span class="pre">\b</span></code></dt><dd><p>빈 문자열과 일치하지만, 단어의 처음이나 끝에만 일치합니다. 단어는 단어 문자의 시퀀스로 정의됩니다. 형식적으로, <code class="docutils literal notranslate"><span class="pre">\b</span></code>는 <code class="docutils literal notranslate"><span class="pre">\w</span></code>와 <code class="docutils literal notranslate"><span class="pre">\W</span></code> 문자 사이의 (또는 그 반대), 또는 <code class="docutils literal notranslate"><span class="pre">\w</span></code>와 문자열 시작/끝 사이의 경계로 정의됩니다. 즉, <code class="docutils literal notranslate"><span class="pre">r'\bfoo\b'</span></code>는 <code class="docutils literal notranslate"><span class="pre">'foo'</span></code>, <code class="docutils literal notranslate"><span class="pre">'foo.'</span></code>, <code class="docutils literal notranslate"><span class="pre">'(foo)'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bar</span> <span class="pre">foo</span> <span class="pre">baz'</span></code>와는 일치하지만, <code class="docutils literal notranslate"><span class="pre">'foobar'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'foo3'</span></code>와는 일치하지 않습니다.</p>
<p>기본적으로 유니코드 영숫자가 유니코드 패턴에서 사용되는 것이지만, <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 플래그를 사용하여 변경할 수 있습니다. <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> 플래그가 사용되면, 단어 경계는 현재 로케일에 의해 결정됩니다. 문자 범위 내에서, 파이썬의 문자열 리터럴과의 호환성을 위해, <code class="docutils literal notranslate"><span class="pre">\b</span></code>는 백스페이스 문자를 나타냅니다.</p>
</dd>
</dl>
<dl class="simple" id="index-27">
<dt><code class="docutils literal notranslate"><span class="pre">\B</span></code></dt><dd><p>단어의 시작이나 끝에 있지 <em>않을</em> 때만 빈 문자열과 일치합니다. 즉, <code class="docutils literal notranslate"><span class="pre">r'py\B'</span></code>는 <code class="docutils literal notranslate"><span class="pre">'python'</span></code>, <code class="docutils literal notranslate"><span class="pre">'py3'</span></code>, <code class="docutils literal notranslate"><span class="pre">'py2'</span></code>와 일치하지만, <code class="docutils literal notranslate"><span class="pre">'py'</span></code>, <code class="docutils literal notranslate"><span class="pre">'py.'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'py!'</span></code>와는 일치하지 않습니다. <code class="docutils literal notranslate"><span class="pre">\B</span></code>는 단지 <code class="docutils literal notranslate"><span class="pre">\b</span></code>의 반대이므로, 유니코드 패턴의 단어 문자는 유니코드 영숫자나 밑줄입니다. <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 플래그를 사용하여 변경할 수 있습니다. <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> 플래그가 사용되면 단어 경계는 현재 로케일에 의해 결정됩니다.</p>
</dd>
</dl>
<dl class="simple" id="index-28">
<dt><code class="docutils literal notranslate"><span class="pre">\d</span></code></dt><dd><dl class="simple">
<dt>유니코드 (str) 패턴일 때:</dt><dd><p>모든 유니코드 십진 숫자(즉, 유니코드 문자 범주 [Nd]의 모든 문자)와 일치합니다. 여기에는 <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code> 및 다른 많은 숫자가 포함됩니다. <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 플래그가 사용되면 <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>만 일치합니다.</p>
</dd>
<dt>8비트 (bytes) 패턴일 때:</dt><dd><p>모든 십진 숫자와 일치합니다; 이것은 <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>와 동등합니다.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="index-29">
<dt><code class="docutils literal notranslate"><span class="pre">\D</span></code></dt><dd><p>십진 숫자가 아닌 모든 문자와 일치합니다. 이것은 <code class="docutils literal notranslate"><span class="pre">\d</span></code>의 반대입니다. <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 플래그를 사용하면 <code class="docutils literal notranslate"><span class="pre">[^0-9]</span></code>와 동등합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-30">
<dt><code class="docutils literal notranslate"><span class="pre">\s</span></code></dt><dd><dl class="simple">
<dt>유니코드 (str) 패턴일 때:</dt><dd><p>유니코드 공백 문자(<code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>와 많은 다른 문자들, 예를 들어 많은 언어에서 타이포그래피 규칙에 의해 강제된 분리할 수 없는 스페이스(non-breaking spaces))와 일치합니다. <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 플래그가 사용되면, <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>만 일치합니다.</p>
</dd>
<dt>8비트 (bytes) 패턴일 때:</dt><dd><p>ASCII 문자 집합에서 공백으로 간주하는 문자와 일치합니다; 이것은 <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>와 동등합니다.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="index-31">
<dt><code class="docutils literal notranslate"><span class="pre">\S</span></code></dt><dd><p>공백 문자가 아닌 모든 문자와 일치합니다. 이것은 <code class="docutils literal notranslate"><span class="pre">\s</span></code>의 반대입니다. <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 플래그를 사용하면 <code class="docutils literal notranslate"><span class="pre">[^</span> <span class="pre">\t\n\r\f\v]</span></code>와 동등합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-32">
<dt><code class="docutils literal notranslate"><span class="pre">\w</span></code></dt><dd><dl class="simple">
<dt>유니코드 (str) 패턴일 때:</dt><dd><p>유니코드 단어 문자와 일치합니다; 여기에는 숫자와 밑줄뿐만 아니라, 모든 언어에서 단어의 일부가 될 수 있는 대부분의 문자가 포함됩니다. <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 플래그가 사용되면 <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code>만 일치합니다.</p>
</dd>
<dt>8비트 (bytes) 패턴일 때:</dt><dd><p>ASCII 문자 집합에서 영숫자로 간주하는 문자와 일치합니다; 이것은 <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code>와 동등합니다. <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> 플래그를 사용하면, 현재 로케일에서 영숫자로 간주하는 문자와 밑줄에 일치합니다.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="index-33">
<dt><code class="docutils literal notranslate"><span class="pre">\W</span></code></dt><dd><p>단어 문자가 아닌 모든 문자와 일치합니다. 이것은 <code class="docutils literal notranslate"><span class="pre">\w</span></code>의 반대입니다. <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 플래그가 사용되면 <code class="docutils literal notranslate"><span class="pre">[^a-zA-Z0-9_]</span></code>와 동등하게 됩니다. <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> 플래그를 사용하면, 현재 로케일에서 영숫자로 간주하는 문자와 밑줄을 제외한 것과 일치합니다.</p>
</dd>
</dl>
<dl class="simple" id="index-34">
<dt><code class="docutils literal notranslate"><span class="pre">\Z</span></code></dt><dd><p>문자열 끝에만 일치합니다.</p>
</dd>
</dl>
<p id="index-35">파이썬 문자열 리터럴이 지원하는 대부분의 표준 이스케이프는 정규식 구문 분석기도 받아들입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>\<span class="n">a</span>      \<span class="n">b</span>      \<span class="n">f</span>      \<span class="n">n</span>
\<span class="n">N</span>      \<span class="n">r</span>      \<span class="n">t</span>      \<span class="n">u</span>
\<span class="n">U</span>      \<span class="n">v</span>      \<span class="n">x</span>      \\
</pre></div>
</div>
<p>(<code class="docutils literal notranslate"><span class="pre">\b</span></code>는 단어 경계를 나타내는 데 사용되며, 문자 클래스 내에서만 &quot;백스페이스&quot;를 의미함에 유의하십시오.)</p>
<p><code class="docutils literal notranslate"><span class="pre">'\u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'\U'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'\N'</span></code> 이스케이프 시퀀스는 유니코드 패턴에서만 인식됩니다. 바이트열 패턴에서는 에러입니다. 알 수 없는 ASCII 문자 이스케이프는 나중에 사용하기 위해 예약되어 있으며 에러로 처리됩니다.</p>
<p>8진수 이스케이프는 제한된 형식으로 포함됩니다. 첫 번째 숫자가 0이거나, 3개의 8진수가 있으면, 8진수 이스케이프로 간주합니다. 그렇지 않으면, 그룹 참조입니다. 문자열 리터럴과 마찬가지로, 8진수 이스케이프 길이는 항상 최대 3자리입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'\u'</span></code>와 <code class="docutils literal notranslate"><span class="pre">'\U'</span></code> 이스케이프 시퀀스가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'\'</span></code>와 ASCII 글자로 구성된 알 수 없는 이스케이프는 이제 에러입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'\N{name}'</span></code> 이스케이프 시퀀스가 추가되었습니다. 문자열 리터럴과 마찬가지로, 이름 있는 유니코드 문자(예를 들어 <code class="docutils literal notranslate"><span class="pre">'\N{EM</span> <span class="pre">DASH}'</span></code>)로 확장됩니다.</p>
</div>
</div>
<div class="section" id="module-contents">
<span id="contents-of-module-re"></span><h2>모듈 내용<a class="headerlink" href="#module-contents" title="제목 주소">¶</a></h2>
<p>모듈은 몇 가지 함수, 상수 및 예외를 정의합니다. 함수 중 일부는 컴파일된 정규식의 모든 기능을 갖춘 메서드의 단순화된 버전입니다. 대부분의 사소하지 않은 응용 프로그램은 항상 컴파일된 형식을 사용합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>플래그 상수는 이제 <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a>의 서브 클래스인 <code class="xref py py-class docutils literal notranslate"><span class="pre">RegexFlag</span></code>의 인스턴스입니다.</p>
</div>
<dl class="function">
<dt id="re.compile">
<code class="descclassname">re.</code><code class="descname">compile</code><span class="sig-paren">(</span><em>pattern</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#re.compile" title="정의 주소">¶</a></dt>
<dd><p>정규식 패턴을 <a class="reference internal" href="#re-objects"><span class="std std-ref">정규식 객체</span></a>로 컴파일합니다. 정규식 객체는 아래에 설명되는 <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a>, <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> 및 기타 메서드를 일치시키는 데 사용할 수 있습니다.</p>
<p>정규식의 동작은 <em>flags</em> 값을 지정하여 수정할 수 있습니다. 값은 비트별 OR(<code class="docutils literal notranslate"><span class="pre">|</span></code> 연산자)를 사용하여 다음 변수들을 결합할 수 있습니다.</p>
<p>시퀀스</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>는 다음과 동등합니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>하지만 정규식이 단일 프로그램에서 여러 번 사용될 때, <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>을 사용하고 결과 정규식 객체를 저장하여 재사용하는 것이 더 효율적입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>과 모듈 수준 일치 함수에 전달된 가장 최근 패턴의 컴파일된 버전이 캐시 되므로, 한 번에 몇 가지 정규식만 사용하는 프로그램은 정규식 컴파일에 대해 신경 쓸 필요가 없습니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="re.A">
<code class="descclassname">re.</code><code class="descname">A</code><a class="headerlink" href="#re.A" title="정의 주소">¶</a></dt>
<dt id="re.ASCII">
<code class="descclassname">re.</code><code class="descname">ASCII</code><a class="headerlink" href="#re.ASCII" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code>, <code class="docutils literal notranslate"><span class="pre">\d</span></code>, <code class="docutils literal notranslate"><span class="pre">\D</span></code>, <code class="docutils literal notranslate"><span class="pre">\s</span></code> 및 <code class="docutils literal notranslate"><span class="pre">\S</span></code>가 전체 유니코드 일치 대신 ASCII 전용 일치를 수행하도록 합니다. 유니코드 패턴에만 의미가 있으며 바이트열 패턴에서는 무시됩니다. 인라인 플래그 <code class="docutils literal notranslate"><span class="pre">(?a)</span></code>에 해당합니다.</p>
<p>이전 버전과의 호환성을 위해, <code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code> 플래그는 (동의어 <code class="xref py py-const docutils literal notranslate"><span class="pre">re.UNICODE</span></code>와 내장 대응 버전 <code class="docutils literal notranslate"><span class="pre">(?u)</span></code>도) 여전히 존재하지만, 파이썬 3에서는 문자열에 대한 일치가 기본적으로 유니코드이므로 (그리고 유니코드 일치는 바이트열에는 허용되지 않습니다) 필요 없습니다.</p>
</dd></dl>

<dl class="data">
<dt id="re.DEBUG">
<code class="descclassname">re.</code><code class="descname">DEBUG</code><a class="headerlink" href="#re.DEBUG" title="정의 주소">¶</a></dt>
<dd><p>컴파일된 정규식에 대한 디버그 정보를 표시합니다. 해당하는 인라인 플래그가 없습니다.</p>
</dd></dl>

<dl class="data">
<dt id="re.I">
<code class="descclassname">re.</code><code class="descname">I</code><a class="headerlink" href="#re.I" title="정의 주소">¶</a></dt>
<dt id="re.IGNORECASE">
<code class="descclassname">re.</code><code class="descname">IGNORECASE</code><a class="headerlink" href="#re.IGNORECASE" title="정의 주소">¶</a></dt>
<dd><p>대/소문자를 구분하지 않는 일치를 수행합니다; <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code>와 같은 정규식은 소문자와도 일치합니다. <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.ASCII</span></code></a> 플래그가 비 ASCII 일치를 비활성화하지 않는 한 전체 유니코드 일치(가령 <code class="docutils literal notranslate"><span class="pre">Ü</span></code>가 <code class="docutils literal notranslate"><span class="pre">ü</span></code>와 일치)가 작동합니다. <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.LOCALE</span></code></a> 플래그도 사용되지 않는 한, 현재 로케일은 이 플래그의 효과를 변경하지 않습니다. 인라인 플래그 <code class="docutils literal notranslate"><span class="pre">(?i)</span></code> 에 해당합니다.</p>
<p>유니코드 패턴 <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code>나 <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code>가 <a class="reference internal" href="#re.IGNORECASE" title="re.IGNORECASE"><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code></a> 플래그와 함께 사용되면, 52개의 ASCII 글자와 4개의 추가 비 ASCII 문자와 일치합니다: 'İ' (U+0130, Latin capital letter I with dot above), 'ı' (U+0131, Latin small letter dotless i), 'ſ' (U+017F, Latin small letter long s) 및 'K' (U+212A, Kelvin sign). <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> 플래그가 사용되면, 문자 'a' 에서 'z'와 'A' 에서 'Z' 만 일치합니다.</p>
</dd></dl>

<dl class="data">
<dt id="re.L">
<code class="descclassname">re.</code><code class="descname">L</code><a class="headerlink" href="#re.L" title="정의 주소">¶</a></dt>
<dt id="re.LOCALE">
<code class="descclassname">re.</code><code class="descname">LOCALE</code><a class="headerlink" href="#re.LOCALE" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code> 및 대소 문자를 구분하지 않는 일치를 현재 로케일에 의존하도록 만듭니다. 이 플래그는 바이트열 패턴에서만 사용할 수 있습니다. 로케일 메커니즘은 신뢰성이 부족하고, 한 번에 하나의 &quot;컬처(culture)&quot; 만 처리하며, 8비트 로케일에서만 동작하므로, 이 플래그의 사용은 권장하지 않습니다. 파이썬 3에서, 유니코드 (str) 패턴에 대해서 유니코드 일치가 기본적으로 이미 활성화되어 있으며 다른 로케일/언어를 처리할 수 있습니다. 인라인 플래그 <code class="docutils literal notranslate"><span class="pre">(?L)</span></code> 에 해당합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.LOCALE</span></code></a>은 바이트열 패턴에만 사용할 수 있으며 <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.ASCII</span></code></a>와 호환되지 않습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.LOCALE</span></code></a> 플래그로 컴파일된 정규식 객체는 더는 컴파일 타임의 로케일에 의존하지 않습니다. 일치하는 시점의 로케일 만 일치 결과에 영향을 줍니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="re.M">
<code class="descclassname">re.</code><code class="descname">M</code><a class="headerlink" href="#re.M" title="정의 주소">¶</a></dt>
<dt id="re.MULTILINE">
<code class="descclassname">re.</code><code class="descname">MULTILINE</code><a class="headerlink" href="#re.MULTILINE" title="정의 주소">¶</a></dt>
<dd><p>지정될 때, 패턴 문자 <code class="docutils literal notranslate"><span class="pre">'^'</span></code>는 문자열 시작과 각 줄의 시작(각 줄 바꿈 바로 다음)에서 일치합니다; 패턴 문자 <code class="docutils literal notranslate"><span class="pre">'$'</span></code>는 문자열의 끝과 각 줄의 끝(각 줄 바꿈 직전)에서 일치합니다. 기본적으로, <code class="docutils literal notranslate"><span class="pre">'^'</span></code>는 문자열의 시작 부분에서만 일치하고, <code class="docutils literal notranslate"><span class="pre">'$'</span></code>는 문자열 끝과 문자열 끝에 있는 (있다면) 줄 바꿈 바로 앞에서 일치합니다. 인라인 플래그 <code class="docutils literal notranslate"><span class="pre">(?m)</span></code> 에 해당합니다.</p>
</dd></dl>

<dl class="data">
<dt id="re.S">
<code class="descclassname">re.</code><code class="descname">S</code><a class="headerlink" href="#re.S" title="정의 주소">¶</a></dt>
<dt id="re.DOTALL">
<code class="descclassname">re.</code><code class="descname">DOTALL</code><a class="headerlink" href="#re.DOTALL" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'.'</span></code> 특수 문자가 줄 넘김을 포함하여 모든 문자와 일치하도록 합니다; 이 플래그가 없으면, <code class="docutils literal notranslate"><span class="pre">'.'</span></code>는 줄 넘김을 <em>제외한</em> 모든 문자와 일치합니다. 인라인 플래그 <code class="docutils literal notranslate"><span class="pre">(?s)</span></code>에 해당합니다.</p>
</dd></dl>

<dl class="data">
<dt id="re.X">
<code class="descclassname">re.</code><code class="descname">X</code><a class="headerlink" href="#re.X" title="정의 주소">¶</a></dt>
<dt id="re.VERBOSE">
<code class="descclassname">re.</code><code class="descname">VERBOSE</code><a class="headerlink" href="#re.VERBOSE" title="정의 주소">¶</a></dt>
<dd><p id="index-36">이 플래그를 사용하면 패턴의 논리 섹션을 시각적으로 분리하고 주석을 추가해서 더 멋지게 보이고 읽기 쉬운 정규식을 작성할 수 있습니다. 패턴 내의 공백은 무시되는데, 캐릭터 클래스에 있을 때나 이스케이프 되지 않은 역 슬래시가 앞에 있거나, <code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">(?:</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">(?P&lt;...&gt;</span></code>와 같은 토큰 내에 있을 때는 예외입니다. 문자 클래스에 들어 있지 않고 이스케이프 처리되지 않은 역 슬래시가 없는 <code class="docutils literal notranslate"><span class="pre">#</span></code>가 줄에 포함되어 있으면, 가장 왼쪽의 그런 <code class="docutils literal notranslate"><span class="pre">#</span></code>에서 줄 끝까지의 모든 문자가 무시됩니다.</p>
<p>이것은 십진수와 일치하는 다음 두 정규식 객체는 기능적으로 같음을 뜻합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;\d +  # 정수부</span>
<span class="s2">                   \.    # 소수점</span>
<span class="s2">                   \d *  # 소수부&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+\.\d*&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>인라인 플래그 <code class="docutils literal notranslate"><span class="pre">(?x)</span></code> 에 해당합니다.</p>
</dd></dl>

<dl class="function">
<dt id="re.search">
<code class="descclassname">re.</code><code class="descname">search</code><span class="sig-paren">(</span><em>pattern</em>, <em>string</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#re.search" title="정의 주소">¶</a></dt>
<dd><p><em>string</em>을 통해 스캔하여 정규식 <em>pattern</em>이 일치하는 첫 번째 위치를 찾고, 대응하는 <a class="reference internal" href="#match-objects"><span class="std std-ref">일치 객체</span></a>를 반환합니다. 문자열의 어느 위치도 패턴과 일치하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다; 이것은 문자열의 어떤 지점에서 길이가 0인 일치를 찾는 것과는 다르다는 것에 유의하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="re.match">
<code class="descclassname">re.</code><code class="descname">match</code><span class="sig-paren">(</span><em>pattern</em>, <em>string</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#re.match" title="정의 주소">¶</a></dt>
<dd><p><em>string</em> 시작 부분에서 0개 이상의 문자가 정규식 <em>pattern</em>과 일치하면, 해당 <a class="reference internal" href="#match-objects"><span class="std std-ref">일치 객체</span></a>를 반환합니다. 문자열이 패턴과 일치하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다; 이것은 길이가 0인 일치와는 다르다는 것에 유의하십시오.</p>
<p><a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 모드에서도, <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a>는 각 줄의 시작 부분이 아니라 문자열의 시작 부분에서만 일치함에 유의하십시오.</p>
<p><em>string</em>의 모든 위치에서 일치를 찾으려면, 대신 <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>를 사용하십시오 (<a class="reference internal" href="#search-vs-match"><span class="std std-ref">search() 대 match()</span></a>도 참조하십시오).</p>
</dd></dl>

<dl class="function">
<dt id="re.fullmatch">
<code class="descclassname">re.</code><code class="descname">fullmatch</code><span class="sig-paren">(</span><em>pattern</em>, <em>string</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#re.fullmatch" title="정의 주소">¶</a></dt>
<dd><p>전체 <em>string</em>이 정규식 <em>pattern</em>과 일치하면, 해당하는 <a class="reference internal" href="#match-objects"><span class="std std-ref">일치 객체</span></a>를 반환합니다. 문자열이 패턴과 일치하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다; 이것은 길이가 0인 일치와는 다르다는 것에 유의하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="re.split">
<code class="descclassname">re.</code><code class="descname">split</code><span class="sig-paren">(</span><em>pattern</em>, <em>string</em>, <em>maxsplit=0</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#re.split" title="정의 주소">¶</a></dt>
<dd><p><em>string</em>을 <em>pattern</em>으로 나눕니다. <em>pattern</em>에서 포착하는 괄호가 사용되면 패턴의 모든 그룹 텍스트도 결과 리스트의 일부로 반환됩니다. <em>maxsplit</em>이 0이 아니면, 최대 <em>maxsplit</em> 분할이 발생하고, 나머지 문자열이 리스트의 마지막 요소로 반환됩니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words&#39;, &#39;words&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words, words.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[a-f]+&#39;</span><span class="p">,</span> <span class="s1">&#39;0a3B9&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">[&#39;0&#39;, &#39;3&#39;, &#39;9&#39;]</span>
</pre></div>
</div>
<p>구분자에 포착하는 그룹이 있고 문자열 시작 부분에서 일치하면, 결과는 빈 문자열로 시작됩니다. 문자열의 끝에 대해서도 마찬가지입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">,</span> <span class="s1">&#39;...words, words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;...&#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;...&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p>그런 식으로, 구분자 구성 요소는 항상 결과 리스트 내의 같은 상대 인덱스에서 발견됩니다.</p>
<p>패턴에 대한 빈(empty) 일치는 이전의 빈 일치와 인접하지 않을 때만 문자열을 분할합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W*&#39;</span><span class="p">,</span> <span class="s1">&#39;...words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;&#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;d&#39;, &#39;s&#39;, &#39;&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W*)&#39;</span><span class="p">,</span> <span class="s1">&#39;...words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;...&#39;, &#39;&#39;, &#39;&#39;, &#39;w&#39;, &#39;&#39;, &#39;o&#39;, &#39;&#39;, &#39;r&#39;, &#39;&#39;, &#39;d&#39;, &#39;&#39;, &#39;s&#39;, &#39;...&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span>선택적 flags 인자를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>빈 문자열과 일치 할 수 있는 패턴으로 분할하는 지원을 추가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="re.findall">
<code class="descclassname">re.</code><code class="descname">findall</code><span class="sig-paren">(</span><em>pattern</em>, <em>string</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#re.findall" title="정의 주소">¶</a></dt>
<dd><p><em>string</em>에서 겹치지 않는 <em>pattern</em>의 모든 일치를 문자열 리스트로 반환합니다. <em>string</em>은 왼쪽에서 오른쪽으로 스캔 되고, 일치는 찾은 순서대로 반환됩니다. 하나 이상의 그룹이 패턴에 있으면, 그룹 리스트를 반환합니다; 패턴에 두 개 이상의 그룹이 있으면 튜플의 리스트가 됩니다. 빈 일치가 결과에 포함됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>비어 있지 않은 일치는 이제 이전의 비어 있는 일치 직후에 시작할 수 있습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="re.finditer">
<code class="descclassname">re.</code><code class="descname">finditer</code><span class="sig-paren">(</span><em>pattern</em>, <em>string</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#re.finditer" title="정의 주소">¶</a></dt>
<dd><p><em>string</em>에서 겹치지 않는 RE <em>pattern</em>의 모든 일치를 <a class="reference internal" href="#match-objects"><span class="std std-ref">일치 객체</span></a>를 산출하는 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a>로 반환합니다. <em>string</em>은 왼쪽에서 오른쪽으로 스캔 되고, 일치는 찾은 순서대로 반환됩니다. 빈 일치가 결과에 포함됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>비어 있지 않은 일치는 이제 이전의 비어 있는 일치 직후에 시작할 수 있습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="re.sub">
<code class="descclassname">re.</code><code class="descname">sub</code><span class="sig-paren">(</span><em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count=0</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#re.sub" title="정의 주소">¶</a></dt>
<dd><p><em>string</em>에서 겹치지 않는 <em>pattern</em>의 가장 왼쪽 일치를 <em>repl</em>로 치환하여 얻은 문자열을 반환합니다. 패턴을 찾지 못하면, <em>string</em>이 변경되지 않고 반환됩니다. <em>repl</em>은 문자열이나 함수가 될 수 있습니다; 문자열이면 모든 역 슬래시 이스케이프가 처리됩니다. 즉, <code class="docutils literal notranslate"><span class="pre">\n</span></code>은 단일 개행 문자로 변환되고, <code class="docutils literal notranslate"><span class="pre">\r</span></code>는 캐리지 리턴으로 변환되고, 등등. 알 수 없는 ASCII 글자 이스케이프는 나중에 사용하기 위해 예약되어 있으며 에러로 처리됩니다. <code class="docutils literal notranslate"><span class="pre">\&amp;</span></code>와 같은 다른 알려지지 않은 이스케이프는 그대로 있습니다. <code class="docutils literal notranslate"><span class="pre">\6</span></code>과 같은 역참조는 패턴에서 그룹 6과 일치하는 부분 문자열로 치환됩니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="sa">r</span><span class="s1">&#39;static PyObject*\npy_\1(void)\n{&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s1">&#39;def myfunc():&#39;</span><span class="p">)</span>
<span class="go">&#39;static PyObject*\npy_myfunc(void)\n{&#39;</span>
</pre></div>
</div>
<p><em>repl</em>이 함수면, <em>pattern</em>의 겹치지 않는 모든 일치마다 호출됩니다. 이 함수는 단일 <a class="reference internal" href="#match-objects"><span class="std std-ref">일치 객체</span></a> 인자를 취하고, 치환 문자열을 반환합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">dashrepl</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39; &#39;</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;-&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;-{1,2}&#39;</span><span class="p">,</span> <span class="n">dashrepl</span><span class="p">,</span> <span class="s1">&#39;pro----gram-files&#39;</span><span class="p">)</span>
<span class="go">&#39;pro--gram files&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\sAND\s&#39;</span><span class="p">,</span> <span class="s1">&#39; &amp; &#39;</span><span class="p">,</span> <span class="s1">&#39;Baked Beans And Spam&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">&#39;Baked Beans &amp; Spam&#39;</span>
</pre></div>
</div>
<p>패턴은 문자열 또는 <a class="reference internal" href="#re-objects"><span class="std std-ref">패턴 객체</span></a>일 수 있습니다.</p>
<p>선택적 인자 <em>count</em>는 치환될 패턴 발생의 최대 수입니다; <em>count</em>는 음수가 아닌 정수여야 합니다. 생략되거나 0이면, 모든 발생이 치환됩니다. 패턴에 대한 빈 일치는 이전의 빈 일치와 인접하지 않을 때만 치환되므로, <code class="docutils literal notranslate"><span class="pre">sub('x*',</span> <span class="pre">'-',</span> <span class="pre">'abxd')</span></code>는 <code class="docutils literal notranslate"><span class="pre">'-a-b--d-'</span></code>를 반환합니다.</p>
<p id="index-37">문자열형 <em>repl</em> 인자에서, 위에 설명된 문자 이스케이프와 역참조 외에, <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code>는 <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code> 문법으로 정의한 <code class="docutils literal notranslate"><span class="pre">name</span></code>이라는 그룹에 일치하는 부분 문자열을 사용합니다. <code class="docutils literal notranslate"><span class="pre">\g&lt;number&gt;</span></code>는 해당 그룹 번호를 사용합니다; 따라서 <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;</span></code>는 <code class="docutils literal notranslate"><span class="pre">\2</span></code>와 동등하지만, <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;0</span></code>와 같은 치환에서 모호하지 않습니다. <code class="docutils literal notranslate"><span class="pre">\20</span></code>은 그룹 2에 대한 참조에 리터럴 문자 <code class="docutils literal notranslate"><span class="pre">'0'</span></code>이 뒤에 오는 것이 아니라, 그룹 20에 대한 참조로 해석됩니다. 역참조 <code class="docutils literal notranslate"><span class="pre">\g&lt;0&gt;</span></code>은 RE와 일치하는 전체 부분 문자열을 치환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span>선택적 flags 인자를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>일치하지 않는 그룹은 빈 문자열로 치환됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><em>pattern</em>의 <code class="docutils literal notranslate"><span class="pre">'\'</span></code>와 ASCII 글자(letter)로 구성된 알 수 없는 이스케이프는 이제 에러입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>repl</em>의 <code class="docutils literal notranslate"><span class="pre">'\'</span></code>와 ASCII 글자(letter)로 구성된 알 수 없는 이스케이프는 이제 에러입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>패턴에 대한 빈 일치는 이전의 비어 있지 않은 일치와 인접 할 때 치환됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="re.subn">
<code class="descclassname">re.</code><code class="descname">subn</code><span class="sig-paren">(</span><em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count=0</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#re.subn" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>와 같은 연산을 수행하지만, 튜플 <code class="docutils literal notranslate"><span class="pre">(new_string,</span> <span class="pre">number_of_subs_made)</span></code>를 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span>선택적 flags 인자를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>일치하지 않는 그룹은 빈 문자열로 치환됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="re.escape">
<code class="descclassname">re.</code><code class="descname">escape</code><span class="sig-paren">(</span><em>pattern</em><span class="sig-paren">)</span><a class="headerlink" href="#re.escape" title="정의 주소">¶</a></dt>
<dd><p><em>pattern</em>에서 특수 문자를 이스케이프 처리합니다. 이것은 정규식 메타 문자가 포함되어있을 수 있는 임의의 리터럴 문자열을 일치시키려는 경우에 유용합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;http://www.python.org&#39;</span><span class="p">))</span>
<span class="go">http://www\.python\.org</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">legal_chars</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span> <span class="o">+</span> <span class="s2">&quot;!#$%&amp;&#39;*+-.^_`|~:&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]+&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">legal_chars</span><span class="p">))</span>
<span class="go">[abcdefghijklmnopqrstuvwxyz0123456789!\#\$%\&amp;&#39;\*\+\-\.\^_`\|\~:]+</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">operators</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;**&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))))</span>
<span class="go">/|\-|\+|\*\*|\*</span>
</pre></div>
</div>
<p>이 함수는 <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>와 <a class="reference internal" href="#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a>의 치환 문자열에 사용하면 안 되며, 역 슬래시만 이스케이프 해야 합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">digits_re</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\d+&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span> <span class="o">=</span> <span class="s1">&#39;/usr/sbin/sendmail - 0 errors, 12 warnings&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">digits_re</span><span class="p">,</span> <span class="n">digits_re</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">sample</span><span class="p">))</span>
<span class="go">/usr/sbin/sendmail - \d+ errors, \d+ warnings</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'_'</span></code> 문자는 더는 이스케이프 되지 않습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>정규식에서 특별한 의미를 가질 수 있는 문자만 이스케이프 됩니다. 결과적으로, <code class="docutils literal notranslate"><span class="pre">'!'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&quot;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'%'</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;'&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">','</span></code>, <code class="docutils literal notranslate"><span class="pre">'/'</span></code>, <code class="docutils literal notranslate"><span class="pre">':'</span></code>, <code class="docutils literal notranslate"><span class="pre">';'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'='</span></code>, <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> 및 '<cite>&quot;</cite>'는 더는 이스케이프 되지 않습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="re.purge">
<code class="descclassname">re.</code><code class="descname">purge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#re.purge" title="정의 주소">¶</a></dt>
<dd><p>정규식 캐시를 지웁니다.</p>
</dd></dl>

<dl class="exception">
<dt id="re.error">
<em class="property">exception </em><code class="descclassname">re.</code><code class="descname">error</code><span class="sig-paren">(</span><em>msg</em>, <em>pattern=None</em>, <em>pos=None</em><span class="sig-paren">)</span><a class="headerlink" href="#re.error" title="정의 주소">¶</a></dt>
<dd><p>여기에 있는 함수 중 하나에 전달된 문자열이 유효한 정규식이 아니거나 (예를 들어, 쌍을 이루지 않는 괄호가 들어있을 수 있습니다) 컴파일이나 일치 중에 다른 에러가 발생할 때 발생하는 예외. 문자열에 패턴과의 일치가 포함되지 않을 때 에러가 발생하지는 않습니다. 에러 인스턴스에는 다음과 같은 추가 어트리뷰트가 있습니다:</p>
<dl class="attribute">
<dt id="re.error.msg">
<code class="descname">msg</code><a class="headerlink" href="#re.error.msg" title="정의 주소">¶</a></dt>
<dd><p>포맷되지 않은 에러 메시지.</p>
</dd></dl>

<dl class="attribute">
<dt id="re.error.pattern">
<code class="descname">pattern</code><a class="headerlink" href="#re.error.pattern" title="정의 주소">¶</a></dt>
<dd><p>정규식 패턴.</p>
</dd></dl>

<dl class="attribute">
<dt id="re.error.pos">
<code class="descname">pos</code><a class="headerlink" href="#re.error.pos" title="정의 주소">¶</a></dt>
<dd><p>컴파일이 실패한 위치를 가리키는 <em>pattern</em>의 인덱스 (<code class="docutils literal notranslate"><span class="pre">None</span></code>일 수 있습니다).</p>
</dd></dl>

<dl class="attribute">
<dt id="re.error.lineno">
<code class="descname">lineno</code><a class="headerlink" href="#re.error.lineno" title="정의 주소">¶</a></dt>
<dd><p><em>pos</em>에 해당하는 줄 (<code class="docutils literal notranslate"><span class="pre">None</span></code>일 수 있습니다).</p>
</dd></dl>

<dl class="attribute">
<dt id="re.error.colno">
<code class="descname">colno</code><a class="headerlink" href="#re.error.colno" title="정의 주소">¶</a></dt>
<dd><p><em>pos</em>에 해당하는 열 (<code class="docutils literal notranslate"><span class="pre">None</span></code>일 수 있습니다).</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>추가 어트리뷰트가 추가되었습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="regular-expression-objects">
<span id="re-objects"></span><h2>정규식 객체<a class="headerlink" href="#regular-expression-objects" title="제목 주소">¶</a></h2>
<p>컴파일된 정규식 객체는 다음 메서드와 어트리뷰트를 지원합니다:</p>
<dl class="method">
<dt id="re.Pattern.search">
<code class="descclassname">Pattern.</code><code class="descname">search</code><span class="sig-paren">(</span><em>string</em><span class="optional">[</span>, <em>pos</em><span class="optional">[</span>, <em>endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.search" title="정의 주소">¶</a></dt>
<dd><p><em>string</em>을 통해 스캔하여 이 정규식이 일치하는 첫 번째 위치를 찾고, 대응하는 <a class="reference internal" href="#match-objects"><span class="std std-ref">일치 객체</span></a>를 반환합니다. 문자열의 어느 위치도 패턴과 일치하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다; 이것은 문자열의 어떤 지점에서 길이가 0인 일치를 찾는 것과는 다르다는 것에 유의하십시오.</p>
<p>선택적 두 번째 매개 변수 <em>pos</em>는 검색을 시작할 문자열의 인덱스를 제공합니다; 기본값은 <code class="docutils literal notranslate"><span class="pre">0</span></code>입니다. 이것은 문자열을 슬라이싱하는 것과 완전히 동등하지는 않습니다; <code class="docutils literal notranslate"><span class="pre">'^'</span></code> 패턴 문자는 문자열의 실제 시작 부분과 개행 직후의 위치에서 일치하지만, 검색을 시작할 색인에서 반드시 일치하지는 않습니다.</p>
<p>선택적 매개 변수 <em>endpos</em>는 문자열을 어디까지 검색할지를 제한합니다; 문자열이 <em>endpos</em> 문자 길이인 것처럼 취급되어, 일치를 찾기 위해 <em>pos</em>에서 <code class="docutils literal notranslate"><span class="pre">endpos</span> <span class="pre">-</span> <span class="pre">1</span></code>까지의 문자만 검색됩니다. <em>endpos</em>가 <em>pos</em>보다 작으면 일치는 없습니다; 그렇지 않으면, <em>rx</em>가 컴파일된 정규식 객체일 때, <code class="docutils literal notranslate"><span class="pre">rx.search(string,</span> <span class="pre">0,</span> <span class="pre">50)</span></code>는 <code class="docutils literal notranslate"><span class="pre">rx.search(string[:50],</span> <span class="pre">0)</span></code>와 동등합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>     <span class="c1"># 인덱스 0에서 일치</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;d&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 일치 없음; 검색에 &quot;d&quot;가 포함되지 않습니다</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="re.Pattern.match">
<code class="descclassname">Pattern.</code><code class="descname">match</code><span class="sig-paren">(</span><em>string</em><span class="optional">[</span>, <em>pos</em><span class="optional">[</span>, <em>endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.match" title="정의 주소">¶</a></dt>
<dd><p><em>string</em>의 <em>처음</em>에서 0개 이상의 문자가 이 정규식과 일치하면, 해당하는 <a class="reference internal" href="#match-objects"><span class="std std-ref">일치 객체</span></a>를 반환합니다. 문자열이 패턴과 일치하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다; 이것은 길이가 0인 일치와는 다릅니다.</p>
<p>선택적 <em>pos</em>와 <em>endpos</em> 매개 변수는 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 메서드에서와 같은 의미입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;o&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>      <span class="c1"># &quot;o&quot;가 &quot;dog&quot;의 시작에 있지 않기 때문에 일치하지 않습니다.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># &quot;o&quot;가 &quot;dog&quot;의 두 번째 문자이므로 일치합니다.</span>
<span class="go">&lt;re.Match object; span=(1, 2), match=&#39;o&#39;&gt;</span>
</pre></div>
</div>
<p><em>string</em>의 임의 위치에서 일치를 찾으려면, 대신 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>를 사용하십시오 (<a class="reference internal" href="#search-vs-match"><span class="std std-ref">search() 대 match()</span></a>도 참조하십시오).</p>
</dd></dl>

<dl class="method">
<dt id="re.Pattern.fullmatch">
<code class="descclassname">Pattern.</code><code class="descname">fullmatch</code><span class="sig-paren">(</span><em>string</em><span class="optional">[</span>, <em>pos</em><span class="optional">[</span>, <em>endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.fullmatch" title="정의 주소">¶</a></dt>
<dd><p>전체 <em>string</em>이 이 정규식과 일치하면, 해당하는 <a class="reference internal" href="#match-objects"><span class="std std-ref">일치 객체</span></a>를 반환합니다. 문자열이 패턴과 일치하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다; 이것은 길이가 0인 일치와는 다릅니다.</p>
<p>선택적 <em>pos</em>와 <em>endpos</em> 매개 변수는 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 메서드에서와 같은 의미입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;o[gh]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>      <span class="c1"># &quot;o&quot;가 &quot;dog&quot;의 시작에 있지 않기 때문에 일치하지 않습니다.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;ogre&quot;</span><span class="p">)</span>     <span class="c1"># 전체 문자열이 일치하지 않기 때문에 일치하지 않습니다.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;doggie&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1"># 주어진 범위에서 일치합니다.</span>
<span class="go">&lt;re.Match object; span=(1, 3), match=&#39;og&#39;&gt;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="re.Pattern.split">
<code class="descclassname">Pattern.</code><code class="descname">split</code><span class="sig-paren">(</span><em>string</em>, <em>maxsplit=0</em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.split" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> 함수와 같은데, 컴파일된 패턴을 사용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="re.Pattern.findall">
<code class="descclassname">Pattern.</code><code class="descname">findall</code><span class="sig-paren">(</span><em>string</em><span class="optional">[</span>, <em>pos</em><span class="optional">[</span>, <em>endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.findall" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a> 함수와 유사한데, 컴파일된 패턴을 사용합니다. 하지만, <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>처럼 검색 영역을 제한하는 선택적 <em>pos</em>와 <em>endpos</em> 매개 변수도 받아들입니다.</p>
</dd></dl>

<dl class="method">
<dt id="re.Pattern.finditer">
<code class="descclassname">Pattern.</code><code class="descname">finditer</code><span class="sig-paren">(</span><em>string</em><span class="optional">[</span>, <em>pos</em><span class="optional">[</span>, <em>endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.finditer" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a> 함수와 유사한데, 컴파일된 패턴을 사용합니다. 하지만, <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>처럼 검색 영역을 제한하는 선택적 <em>pos</em>와 <em>endpos</em> 매개 변수도 받아들입니다.</p>
</dd></dl>

<dl class="method">
<dt id="re.Pattern.sub">
<code class="descclassname">Pattern.</code><code class="descname">sub</code><span class="sig-paren">(</span><em>repl</em>, <em>string</em>, <em>count=0</em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.sub" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> 함수와 같은데, 컴파일된 패턴을 사용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="re.Pattern.subn">
<code class="descclassname">Pattern.</code><code class="descname">subn</code><span class="sig-paren">(</span><em>repl</em>, <em>string</em>, <em>count=0</em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.subn" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a> 함수와 같은데, 컴파일된 패턴을 사용합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="re.Pattern.flags">
<code class="descclassname">Pattern.</code><code class="descname">flags</code><a class="headerlink" href="#re.Pattern.flags" title="정의 주소">¶</a></dt>
<dd><p>정규식 일치 플래그. 이것은 <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>에 주어진 플래그, 패턴의 모든 <code class="docutils literal notranslate"><span class="pre">(?...)</span></code> 인라인 플래그 및 패턴이 유니코드 문자열일 때 <code class="xref py py-data docutils literal notranslate"><span class="pre">UNICODE</span></code>와 같은 묵시적 플래그의 조합입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="re.Pattern.groups">
<code class="descclassname">Pattern.</code><code class="descname">groups</code><a class="headerlink" href="#re.Pattern.groups" title="정의 주소">¶</a></dt>
<dd><p>패턴에 있는 포착 그룹 수.</p>
</dd></dl>

<dl class="attribute">
<dt id="re.Pattern.groupindex">
<code class="descclassname">Pattern.</code><code class="descname">groupindex</code><a class="headerlink" href="#re.Pattern.groupindex" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">(?P&lt;id&gt;)</span></code>로 정의된 기호 그룹 이름을 그룹 번호에 매핑하는 딕셔너리. 패턴에 기호 그룹이 사용되지 않으면 딕셔너리는 비어 있습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="re.Pattern.pattern">
<code class="descclassname">Pattern.</code><code class="descname">pattern</code><a class="headerlink" href="#re.Pattern.pattern" title="정의 주소">¶</a></dt>
<dd><p>패턴 객체가 컴파일된 패턴 문자열.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a>와 <a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a> 지원이 추가되었습니다. 컴파일된 정규식 객체는 원자적이라고 간주합니다.</p>
</div>
</div>
<div class="section" id="match-objects">
<span id="id2"></span><h2>일치 객체<a class="headerlink" href="#match-objects" title="제목 주소">¶</a></h2>
<p>일치 객체는 항상 불리언 값 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 가집니다. <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a>와 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>는 일치가 없을 때 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환하기 때문에, 간단한 <code class="docutils literal notranslate"><span class="pre">if</span></code> 문으로 일치가 있는지 검사할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
<span class="k">if</span> <span class="n">match</span><span class="p">:</span>
    <span class="n">process</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
</pre></div>
</div>
<p>일치 객체는 다음 메서드와 어트리뷰트를 지원합니다:</p>
<dl class="method">
<dt id="re.Match.expand">
<code class="descclassname">Match.</code><code class="descname">expand</code><span class="sig-paren">(</span><em>template</em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.expand" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#re.Pattern.sub" title="re.Pattern.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a> 메서드에서 수행되는 것처럼, 템플릿 문자열 <em>template</em>에 역 슬래시 치환을 수행하여 얻은 문자열을 반환합니다. <code class="docutils literal notranslate"><span class="pre">\n</span></code>과 같은 이스케이프는 적절한 문자로 변환되고, 숫자 역참조(<code class="docutils literal notranslate"><span class="pre">\1</span></code>, <code class="docutils literal notranslate"><span class="pre">\2</span></code>)와 이름 있는 역참조(<code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code>)는 해당 그룹의 내용으로 치환됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>일치하지 않는 그룹은 빈 문자열로 치환됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="re.Match.group">
<code class="descclassname">Match.</code><code class="descname">group</code><span class="sig-paren">(</span><span class="optional">[</span><em>group1</em>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.group" title="정의 주소">¶</a></dt>
<dd><p>일치의 하나 이상의 서브 그룹을 반환합니다. 단일 인자가 있으면, 결과는 단일 문자열입니다; 인자가 여러 개면, 결과는 인자당 하나의 항목이 있는 튜플입니다. 인자가 없으면, <em>group1</em>의 기본값은 0입니다 (전체 일치가 반환됩니다). <em>groupN</em> 인자가 0이면, 해당 반환 값은 전체 일치 문자열입니다; 경계를 포함하는 범위 [1..99]에 있으면, 해당 괄호로 묶은 그룹과 일치하는 문자열입니다. 그룹 번호가 음수이거나 패턴에 정의된 그룹 수보다 크면, <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 예외가 발생합니다. 패턴이 일치하지 않는 부분에 그룹이 포함되어 있으면, 해당 결과는 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. 그룹이 여러 번 일치하는 패턴의 일부에 포함되어 있으면, 마지막 일치가 반환됩니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+) (\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton, physicist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>       <span class="c1"># 전체 일치</span>
<span class="go">&#39;Isaac Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># 첫 번째 괄호 서브 그룹.</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>       <span class="c1"># 두 번째 괄호 서브 그룹.</span>
<span class="go">&#39;Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1"># 다중 인자는 튜플을 줍니다.</span>
<span class="go">(&#39;Isaac&#39;, &#39;Newton&#39;)</span>
</pre></div>
</div>
<p>정규식이 <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code> 문법을 사용하면, <em>groupN</em> 인자는 그룹 이름으로 그룹을 식별하는 문자열일 수도 있습니다. 문자열 인자가 패턴의 그룹 이름으로 사용되지 않으면, <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 예외가 발생합니다.</p>
<p>적당히 복잡한 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Malcolm Reynolds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;first_name&#39;</span><span class="p">)</span>
<span class="go">&#39;Malcolm&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;last_name&#39;</span><span class="p">)</span>
<span class="go">&#39;Reynolds&#39;</span>
</pre></div>
</div>
<p>이름있는 그룹은 인덱스로 참조할 수도 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;Malcolm&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;Reynolds&#39;</span>
</pre></div>
</div>
<p>그룹이 여러 번 일치하면, 마지막 일치만 액세스 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(..)+&quot;</span><span class="p">,</span> <span class="s2">&quot;a1b2c3&quot;</span><span class="p">)</span>  <span class="c1"># 세 번 일치합니다.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                        <span class="c1"># 마지막 일치만 반환합니다.</span>
<span class="go">&#39;c3&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="re.Match.__getitem__">
<code class="descclassname">Match.</code><code class="descname">__getitem__</code><span class="sig-paren">(</span><em>g</em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.__getitem__" title="정의 주소">¶</a></dt>
<dd><p>이것은 <code class="docutils literal notranslate"><span class="pre">m.group(g)</span></code>와 같습니다. 일치에서 개별 그룹에 더 쉽게 액세스 할 수 있게 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+) (\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton, physicist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>       <span class="c1"># 전체 일치</span>
<span class="go">&#39;Isaac Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>       <span class="c1"># 첫 번째 괄호 서브 그룹.</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>       <span class="c1"># 두 번째 괄호 서브 그룹.</span>
<span class="go">&#39;Newton&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="re.Match.groups">
<code class="descclassname">Match.</code><code class="descname">groups</code><span class="sig-paren">(</span><em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.groups" title="정의 주소">¶</a></dt>
<dd><p>1에서 패턴에 있는 그룹의 수까지, 일치의 모든 서브 그룹을 포함하는 튜플을 반환합니다. <em>default</em> 인자는 일치에 참여하지 않은 그룹에 사용됩니다; 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d+)\.(\d+)&quot;</span><span class="p">,</span> <span class="s2">&quot;24.1632&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">(&#39;24&#39;, &#39;1632&#39;)</span>
</pre></div>
</div>
<p>우리가 소수점과 그 이후의 모든 것을 선택적으로 만들면, 모든 그룹이 일치에 참여하지 않을 수 있습니다. 이 그룹은 <em>default</em> 인자가 주어지지 않는 한 기본값 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d+)\.?(\d+)?&quot;</span><span class="p">,</span> <span class="s2">&quot;24&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>      <span class="c1"># 두 번째 그룹의 기본값은 None입니다.</span>
<span class="go">(&#39;24&#39;, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>   <span class="c1"># 이제, 두 번째 그룹의 기본값은 &#39;0&#39;입니다.</span>
<span class="go">(&#39;24&#39;, &#39;0&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="re.Match.groupdict">
<code class="descclassname">Match.</code><code class="descname">groupdict</code><span class="sig-paren">(</span><em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.groupdict" title="정의 주소">¶</a></dt>
<dd><p>일치의 모든 <em>이름 있는</em> 서브 그룹을 포함하고, 서브 그룹의 이름을 키로 사용하는 딕셔너리를 반환합니다. <em>default</em> 인자는 일치에 참여하지 않은 그룹에 사용됩니다; 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Malcolm Reynolds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
<span class="go">{&#39;first_name&#39;: &#39;Malcolm&#39;, &#39;last_name&#39;: &#39;Reynolds&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="re.Match.start">
<code class="descclassname">Match.</code><code class="descname">start</code><span class="sig-paren">(</span><span class="optional">[</span><em>group</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.start" title="정의 주소">¶</a></dt>
<dt id="re.Match.end">
<code class="descclassname">Match.</code><code class="descname">end</code><span class="sig-paren">(</span><span class="optional">[</span><em>group</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.end" title="정의 주소">¶</a></dt>
<dd><p><em>group</em>과 일치하는 부분 문자열의 시작과 끝 인덱스를 반환합니다; <em>group</em>의 기본값은 0입니다 (전체 일치 문자열을 뜻합니다). <em>group</em>이 있지만, 일치에 기여하지 않으면, <code class="docutils literal notranslate"><span class="pre">-1</span></code>을 반환합니다. 일치 객체 <em>m</em>과 일치에 기여한 그룹 <em>g</em>에서, 그룹 <em>g</em>와 일치하는 부분 문자열(<code class="docutils literal notranslate"><span class="pre">m.group(g)</span></code>와 동등합니다)은 다음과 같습니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">.</span><span class="n">string</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">g</span><span class="p">):</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">g</span><span class="p">)]</span>
</pre></div>
</div>
<p><em>group</em>이 널 문자열과 일치하면 <code class="docutils literal notranslate"><span class="pre">m.start(group)</span></code>은 <code class="docutils literal notranslate"><span class="pre">m.end(group)</span></code>와 같음에 유의하십시오. 예를 들어, <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">re.search('b(c?)',</span> <span class="pre">'cba')</span></code> 이후에, <code class="docutils literal notranslate"><span class="pre">m.start(0)</span></code>은 1이고, <code class="docutils literal notranslate"><span class="pre">m.end(0)</span></code>은 2이며, <code class="docutils literal notranslate"><span class="pre">m.start(1)</span></code>과 <code class="docutils literal notranslate"><span class="pre">m.end(1)</span></code>은 모두 2이고, <code class="docutils literal notranslate"><span class="pre">m.start(2)</span></code>는 <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 예외를 발생시킵니다.</p>
<p>전자 메일 주소에서 <em>remove_this</em>를 제거하는 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">email</span> <span class="o">=</span> <span class="s2">&quot;tony@tiremove_thisger.net&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;remove_this&quot;</span><span class="p">,</span> <span class="n">email</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="p">[:</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span> <span class="o">+</span> <span class="n">email</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">():]</span>
<span class="go">&#39;tony@tiger.net&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="re.Match.span">
<code class="descclassname">Match.</code><code class="descname">span</code><span class="sig-paren">(</span><span class="optional">[</span><em>group</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.span" title="정의 주소">¶</a></dt>
<dd><p>일치가 <em>m</em>일 때, 2-튜플 <code class="docutils literal notranslate"><span class="pre">(m.start(group),</span> <span class="pre">m.end(group))</span></code>를 반환합니다. <em>group</em>이 일치에 기여하지 않으면, 이것은 <code class="docutils literal notranslate"><span class="pre">(-1,</span> <span class="pre">-1)</span></code>임에 유의하십시오. <em>group</em>의 기본값은 0으로, 전체 일치입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="re.Match.pos">
<code class="descclassname">Match.</code><code class="descname">pos</code><a class="headerlink" href="#re.Match.pos" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#re-objects"><span class="std std-ref">정규식 객체</span></a>의 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>나 <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> 메서드에 전달된 <em>pos</em> 값. 이것은 RE 엔진이 일치를 찾기 시작한 string에 대한 인덱스입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="re.Match.endpos">
<code class="descclassname">Match.</code><code class="descname">endpos</code><a class="headerlink" href="#re.Match.endpos" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#re-objects"><span class="std std-ref">정규식 객체</span></a>의 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>나 <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> 메서드에 전달된 <em>endpos</em> 값. 이것은 RE 엔진이 넘어가지 않을 string에 대한 인덱스입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="re.Match.lastindex">
<code class="descclassname">Match.</code><code class="descname">lastindex</code><a class="headerlink" href="#re.Match.lastindex" title="정의 주소">¶</a></dt>
<dd><p>마지막으로 일치하는 포착 그룹의 정수 인덱스, 또는 그룹이 전혀 일치하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>. 예를 들어, 정규식 <code class="docutils literal notranslate"><span class="pre">(a)b</span></code>, <code class="docutils literal notranslate"><span class="pre">((a)(b))</span></code> 및 <code class="docutils literal notranslate"><span class="pre">((ab))</span></code>는 문자열 <code class="docutils literal notranslate"><span class="pre">'ab'</span></code>에 적용될 경우 <code class="docutils literal notranslate"><span class="pre">lastindex</span> <span class="pre">==</span> <span class="pre">1</span></code>이 되지만, <code class="docutils literal notranslate"><span class="pre">(a)(b)</span></code> 정규식은 같은 문자열에 적용될 때 <code class="docutils literal notranslate"><span class="pre">lastindex</span> <span class="pre">==</span> <span class="pre">2</span></code>가 됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="re.Match.lastgroup">
<code class="descclassname">Match.</code><code class="descname">lastgroup</code><a class="headerlink" href="#re.Match.lastgroup" title="정의 주소">¶</a></dt>
<dd><p>마지막으로 일치하는 포착 그룹의 이름, 또는 그룹에 이름이 없거나, 그룹이 전혀 일치하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="re.Match.re">
<code class="descclassname">Match.</code><code class="descname">re</code><a class="headerlink" href="#re.Match.re" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a>나 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> 메서드가 이 일치 인스턴스를 생성한 <a class="reference internal" href="#re-objects"><span class="std std-ref">정규식 객체</span></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="re.Match.string">
<code class="descclassname">Match.</code><code class="descname">string</code><a class="headerlink" href="#re.Match.string" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a>나 <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>에 전달된 문자열.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a>와 <a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a> 지원이 추가되었습니다. 일치 객체는 원자적이라고 간주합니다.</p>
</div>
</div>
<div class="section" id="regular-expression-examples">
<span id="re-examples"></span><h2>정규식 예제<a class="headerlink" href="#regular-expression-examples" title="제목 주소">¶</a></h2>
<div class="section" id="checking-for-a-pair">
<h3>쌍 검사하기<a class="headerlink" href="#checking-for-a-pair" title="제목 주소">¶</a></h3>
<p>이 예제에서는, 다음과 같은 도우미 함수를 사용하여 좀 더 세련되게 일치 객체를 표시합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">displaymatch</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="s1">&#39;&lt;Match: </span><span class="si">%r</span><span class="s1">, groups=</span><span class="si">%r</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(),</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
</pre></div>
</div>
<p>플레이어의 패를 5문자 문자열로 나타내는 포커 프로그램을 작성하고 있다고 가정해봅시다. &quot;a&quot;는 에이스, &quot;k&quot;는 킹, &quot;q&quot;는 퀸, &quot;j&quot;는 잭, &quot;t&quot;는 10, &quot;2&quot;에서 &quot;9&quot;는 그 값의 카드를 나타냅니다.</p>
<p>주어진 문자열이 유효한 패인지 보려면, 다음과 같이 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">valid</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[a2-9tjqk]</span><span class="si">{5}</span><span class="s2">$&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt5q&quot;</span><span class="p">))</span>  <span class="c1"># 유효합니다.</span>
<span class="go">&quot;&lt;Match: &#39;akt5q&#39;, groups=()&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt5e&quot;</span><span class="p">))</span>  <span class="c1"># 유효하지 않습니다.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt&quot;</span><span class="p">))</span>    <span class="c1"># 유효하지 않습니다.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;727ak&quot;</span><span class="p">))</span>  <span class="c1"># 유효합니다.</span>
<span class="go">&quot;&lt;Match: &#39;727ak&#39;, groups=()&gt;&quot;</span>
</pre></div>
</div>
<p>마지막 패 <code class="docutils literal notranslate"><span class="pre">&quot;727ak&quot;</span></code>는 페어, 즉 같은 값의 카드 두 장을 포함합니다. 이것을 정규식과 일치시키려면, 역참조를 다음과 같이 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;717ak&quot;</span><span class="p">))</span>     <span class="c1"># 7의 페어.</span>
<span class="go">&quot;&lt;Match: &#39;717&#39;, groups=(&#39;7&#39;,)&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;718ak&quot;</span><span class="p">))</span>     <span class="c1"># 페어 없음.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;354aa&quot;</span><span class="p">))</span>     <span class="c1"># 에이스의 페어.</span>
<span class="go">&quot;&lt;Match: &#39;354aa&#39;, groups=(&#39;a&#39;,)&gt;&quot;</span>
</pre></div>
</div>
<p>페어가 어떤 카드로 구성되어 있는지 알아내려면, 다음과 같이 일치 객체의 <a class="reference internal" href="#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a> 메서드를 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;717ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;7&#39;</span>

<span class="go"># re.match()가 group() 메서드가 없는 None을 반환하기 때문에 에러입니다:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;718ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#23&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
    <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">,</span> <span class="s2">&quot;718ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;NoneType&#39; object has no attribute &#39;group&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;354aa&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="simulating-scanf">
<h3>scanf() 시뮬레이션<a class="headerlink" href="#simulating-scanf" title="제목 주소">¶</a></h3>
<p id="index-38">파이썬에는 현재 <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code>에 해당하는 것이 없습니다. 정규식은 일반적으로 <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> 포맷 문자열보다 강력하지만, 더 장황하기도 합니다. 아래 표는 <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> 포맷 토큰과 정규식 간의 다소 비슷한 매핑을 제공합니다.</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 42%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> 토큰</p></th>
<th class="head"><p>정규식</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%5c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.{5}</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%d</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?\d+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%e</span></code>, <code class="docutils literal notranslate"><span class="pre">%E</span></code>, <code class="docutils literal notranslate"><span class="pre">%f</span></code>, <code class="docutils literal notranslate"><span class="pre">%g</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%i</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(0[xX][\dA-Fa-f]+|0[0-7]*|\d+)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%o</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?[0-7]+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%s</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\S+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%u</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\d+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%x</span></code>, <code class="docutils literal notranslate"><span class="pre">%X</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(0[xX])?[\dA-Fa-f]+</span></code></p></td>
</tr>
</tbody>
</table>
<p>다음과 같은 문자열에서 파일명과 숫자를 추출하려면</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">sendmail</span> <span class="o">-</span> <span class="mi">0</span> <span class="n">errors</span><span class="p">,</span> <span class="mi">4</span> <span class="n">warnings</span>
</pre></div>
</div>
<p>여러분은 다음과 같은 <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> 포맷을 사용할 것입니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">s</span> <span class="o">-</span> <span class="o">%</span><span class="n">d</span> <span class="n">errors</span><span class="p">,</span> <span class="o">%</span><span class="n">d</span> <span class="n">warnings</span>
</pre></div>
</div>
<p>동등한 정규식은 다음과 같습니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span>\<span class="n">S</span><span class="o">+</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span>\<span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="n">errors</span><span class="p">,</span> <span class="p">(</span>\<span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="n">warnings</span>
</pre></div>
</div>
</div>
<div class="section" id="search-vs-match">
<span id="id3"></span><h3>search() 대 match()<a class="headerlink" href="#search-vs-match" title="제목 주소">¶</a></h3>
<p>파이썬은 정규식에 기반한 두 가지 기본 연산을 제공합니다: <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a>는 문자열의 시작 부분에서만 일치를 검사하는 반면, <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>는 문자열의 아무 곳에서나 일치하는지 확인합니다 (이것이 Perl이 기본적으로 수행하는 것입니다).</p>
<p>예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>    <span class="c1"># 일치 없음</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>   <span class="c1"># 일치</span>
<span class="go">&lt;re.Match object; span=(2, 3), match=&#39;c&#39;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">'^'</span></code>로 시작하는 정규식은 <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>와 함께 사용하여 문자열 시작 부분의 일치로 제한 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>    <span class="c1"># 일치 없음</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>  <span class="c1"># 일치 없음</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^a&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>  <span class="c1"># 일치</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;a&#39;&gt;</span>
</pre></div>
</div>
<p>그러나 <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> 모드에서 <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a>는 문자열 시작 부분에서만 일치하지만, <code class="docutils literal notranslate"><span class="pre">'^'</span></code>로 시작하는 정규식을 <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>에 사용하면 각 줄의 시작 부분에서 일치합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;A</span><span class="se">\n</span><span class="s1">B</span><span class="se">\n</span><span class="s1">X&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>  <span class="c1"># 일치 없음</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;^X&#39;</span><span class="p">,</span> <span class="s1">&#39;A</span><span class="se">\n</span><span class="s1">B</span><span class="se">\n</span><span class="s1">X&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>  <span class="c1"># 일치</span>
<span class="go">&lt;re.Match object; span=(4, 5), match=&#39;X&#39;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="making-a-phonebook">
<h3>전화번호부 만들기<a class="headerlink" href="#making-a-phonebook" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>는 문자열을, 전달된 패턴으로 구분된 리스트로 분할합니다. 이 메서드는 전화번호부를 만드는 다음 예제에서 보이듯이 텍스트 데이터를 파이썬에서 쉽게 읽고 수정할 수 있는 데이터 구조로 변환하는 데 매우 중요합니다.</p>
<p>먼저, 여기 입력이 있습니다. 보통 파일에서 올 수 있습니다만, 여기서는 삼중 따옴표로 묶인 문자열 문법을 사용합니다.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Ross McFluff: 834.345.1254 155 Elm Street</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">Ronald Heathmore: 892.345.3428 436 Finley Avenue</span>
<span class="gp">... </span><span class="s2">Frank Burger: 925.541.7625 662 South Dogwood Way</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">Heather Albrecht: 548.326.4584 919 Park Place&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>항목은 하나 이상의 개행으로 구분됩니다. 이제 비어있지 않은 각 줄이 항목이 되도록 문자열을 리스트로 변환합니다:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">entries</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">+&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entries</span>
<span class="go">[&#39;Ross McFluff: 834.345.1254 155 Elm Street&#39;,</span>
<span class="go">&#39;Ronald Heathmore: 892.345.3428 436 Finley Avenue&#39;,</span>
<span class="go">&#39;Frank Burger: 925.541.7625 662 South Dogwood Way&#39;,</span>
<span class="go">&#39;Heather Albrecht: 548.326.4584 919 Park Place&#39;]</span>
</pre></div>
</div>
<p>마지막으로, 각 항목을 이름, 성, 전화번호 및 주소로 구성된 리스트로 분할합니다. 주소에 우리의 분할 패턴인 스페이스가 들어있기 때문에, <a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> 매개 변수를 사용합니다:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:? &quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
<span class="go">[[&#39;Ross&#39;, &#39;McFluff&#39;, &#39;834.345.1254&#39;, &#39;155 Elm Street&#39;],</span>
<span class="go">[&#39;Ronald&#39;, &#39;Heathmore&#39;, &#39;892.345.3428&#39;, &#39;436 Finley Avenue&#39;],</span>
<span class="go">[&#39;Frank&#39;, &#39;Burger&#39;, &#39;925.541.7625&#39;, &#39;662 South Dogwood Way&#39;],</span>
<span class="go">[&#39;Heather&#39;, &#39;Albrecht&#39;, &#39;548.326.4584&#39;, &#39;919 Park Place&#39;]]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">:?</span></code> 패턴은 결과 리스트에 나타나지 않도록, 성 뒤의 콜론과 일치합니다. <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code>로 <code class="docutils literal notranslate"><span class="pre">4</span></code>를 사용하면, 번지수를 거리 이름과 분리 할 수 있습니다:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:? &quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
<span class="go">[[&#39;Ross&#39;, &#39;McFluff&#39;, &#39;834.345.1254&#39;, &#39;155&#39;, &#39;Elm Street&#39;],</span>
<span class="go">[&#39;Ronald&#39;, &#39;Heathmore&#39;, &#39;892.345.3428&#39;, &#39;436&#39;, &#39;Finley Avenue&#39;],</span>
<span class="go">[&#39;Frank&#39;, &#39;Burger&#39;, &#39;925.541.7625&#39;, &#39;662&#39;, &#39;South Dogwood Way&#39;],</span>
<span class="go">[&#39;Heather&#39;, &#39;Albrecht&#39;, &#39;548.326.4584&#39;, &#39;919&#39;, &#39;Park Place&#39;]]</span>
</pre></div>
</div>
</div>
<div class="section" id="text-munging">
<h3>텍스트 뒤섞기<a class="headerlink" href="#text-munging" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>는 패턴의 모든 일치를 문자열이나 함수의 결과로 치환합니다. 이 예제는 <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>에 텍스트를 &quot;뒤섞는&quot;, 즉 문장의 각 단어에서 첫 번째 문자와 마지막 문자를 제외한 모든 문자의 순서를 무작위로 바꾸는 함수를 사용하는 방법을 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">inner_word</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">inner_word</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inner_word</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Professor Abdolmalek, please report your absences promptly.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\w+)(\w)&quot;</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\w+)(\w)&quot;</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="finding-all-adverbs">
<h3>모든 부사 찾기<a class="headerlink" href="#finding-all-adverbs" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a>은 <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>처럼 첫 번째 등장뿐만 아니라, 패턴의 <em>모든</em> 등장과 일치합니다. 예를 들어, 작가가 어떤 텍스트에서 부사를 모두 찾고 싶으면, 다음과 같은 방식으로 <a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a>을 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;He was carefully disguised but captured quickly by police.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w+ly&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">[&#39;carefully&#39;, &#39;quickly&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="finding-all-adverbs-and-their-positions">
<h3>모든 부사와 그 위치 찾기<a class="headerlink" href="#finding-all-adverbs-and-their-positions" title="제목 주소">¶</a></h3>
<p>일치하는 텍스트보다 패턴의 모든 일치에 대한 자세한 정보가 필요하면, <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a>는 문자열 대신 <a class="reference internal" href="#match-objects"><span class="std std-ref">일치 객체</span></a>를 제공하므로 유용합니다. 이전 예에서 계속해서, 작가가 어떤 텍스트에서 부사<em>와 그 위치</em>를 모두 찾고 싶으면, 다음과 같은 방식으로 <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a>를 사용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;He was carefully disguised but captured quickly by police.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w+ly&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
<span class="go">07-16: carefully</span>
<span class="go">40-47: quickly</span>
</pre></div>
</div>
</div>
<div class="section" id="raw-string-notation">
<h3>날 문자열 표기법<a class="headerlink" href="#raw-string-notation" title="제목 주소">¶</a></h3>
<p>날 문자열 표기법(<code class="docutils literal notranslate"><span class="pre">r&quot;text&quot;</span></code>)은 정규식을 합리적인 상태로 유지합니다. 이것 없이는, 정규식의 모든 역 슬래시(<code class="docutils literal notranslate"><span class="pre">'\'</span></code>)를 이스케이프 하기 위해 그 앞에 또 하나의 역 슬래시를 붙여야 합니다. 예를 들어, 다음 두 코드 줄은 기능상으로 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\W(.)\1\W&quot;</span><span class="p">,</span> <span class="s2">&quot; ff &quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39; ff &#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">W(.)</span><span class="se">\\</span><span class="s2">1</span><span class="se">\\</span><span class="s2">W&quot;</span><span class="p">,</span> <span class="s2">&quot; ff &quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39; ff &#39;&gt;</span>
</pre></div>
</div>
<p>리터럴 역 슬래시와 일치시키려면, 정규식에서 이스케이프 되어야 합니다. 날 문자열 표기법을 사용하면, <code class="docutils literal notranslate"><span class="pre">r&quot;\\&quot;</span></code>이 됩니다. 날 문자열 표기법을 사용하지 않으면, <code class="docutils literal notranslate"><span class="pre">&quot;\\\\&quot;</span></code>를 사용해야 하는데, 다음 코드 줄들은 기능적으로 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;\\&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;\\&#39;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="writing-a-tokenizer">
<h3>토크나이저 작성하기<a class="headerlink" href="#writing-a-tokenizer" title="제목 주소">¶</a></h3>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Lexical_analysis">토크나이저나 스캐너</a>는 문자열을 분석하여 문자 그룹을 분류합니다. 이것은 컴파일러나 인터프리터를 작성하는 데 유용한 첫 번째 단계입니다.</p>
<p>텍스트 범주는 정규식으로 지정됩니다. 이 기법은 이들을 하나의 마스터 정규식으로 결합하고 연속적인 일치를 반복하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="n">Token</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Token&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
    <span class="n">keywords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="s1">&#39;FOR&#39;</span><span class="p">,</span> <span class="s1">&#39;NEXT&#39;</span><span class="p">,</span> <span class="s1">&#39;GOSUB&#39;</span><span class="p">,</span> <span class="s1">&#39;RETURN&#39;</span><span class="p">}</span>
    <span class="n">token_specification</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;NUMBER&#39;</span><span class="p">,</span>   <span class="sa">r</span><span class="s1">&#39;\d+(\.\d*)?&#39;</span><span class="p">),</span>  <span class="c1"># 정수나 십진수</span>
        <span class="p">(</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span>   <span class="sa">r</span><span class="s1">&#39;:=&#39;</span><span class="p">),</span>           <span class="c1"># 대입 연산자</span>
        <span class="p">(</span><span class="s1">&#39;END&#39;</span><span class="p">,</span>      <span class="sa">r</span><span class="s1">&#39;;&#39;</span><span class="p">),</span>            <span class="c1"># 문장 종료자</span>
        <span class="p">(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span>       <span class="sa">r</span><span class="s1">&#39;[A-Za-z]+&#39;</span><span class="p">),</span>    <span class="c1"># 식별자</span>
        <span class="p">(</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span>       <span class="sa">r</span><span class="s1">&#39;[+\-*/]&#39;</span><span class="p">),</span>      <span class="c1"># 산술 연산자</span>
        <span class="p">(</span><span class="s1">&#39;NEWLINE&#39;</span><span class="p">,</span>  <span class="sa">r</span><span class="s1">&#39;\n&#39;</span><span class="p">),</span>           <span class="c1"># 줄 종료</span>
        <span class="p">(</span><span class="s1">&#39;SKIP&#39;</span><span class="p">,</span>     <span class="sa">r</span><span class="s1">&#39;[ \t]+&#39;</span><span class="p">),</span>       <span class="c1"># 스페이스와 탭을 건너뜁니다</span>
        <span class="p">(</span><span class="s1">&#39;MISMATCH&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;.&#39;</span><span class="p">),</span>            <span class="c1"># 나머지 문자들</span>
    <span class="p">]</span>
    <span class="n">tok_regex</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;(?P&lt;</span><span class="si">%s</span><span class="s1">&gt;</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">token_specification</span><span class="p">)</span>
    <span class="n">line_num</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">line_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">mo</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">tok_regex</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">lastgroup</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">-</span> <span class="n">line_start</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;NUMBER&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">value</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;ID&#39;</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span><span class="p">:</span>
            <span class="n">line_start</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">line_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;SKIP&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;MISMATCH&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{value!r}</span><span class="s1"> unexpected on line </span><span class="si">{line_num}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">line_num</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>

<span class="n">statements</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    IF quantity THEN</span>
<span class="s1">        total := total + price * quantity;</span>
<span class="s1">        tax := price * 0.05;</span>
<span class="s1">    ENDIF;</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">statements</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
</pre></div>
</div>
<p>토크나이저는 다음과 같은 출력을 생성합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;:=&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">17</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">33</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">41</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;tax&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;:=&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;NUMBER&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">27</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<dl class="citation">
<dt class="label" id="frie09"><span class="brackets"><a class="fn-backref" href="#id1">Frie09</a></span></dt>
<dd><p>Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, 2009. 이 책의 세 번째 판은 더는 파이썬을 다루지 않지만, 초판은 훌륭한 정규식 패턴 작성을 아주 자세하게 다루었습니다.</p>
</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> --- 정규식 연산</a><ul>
<li><a class="reference internal" href="#regular-expression-syntax">정규식 문법</a></li>
<li><a class="reference internal" href="#module-contents">모듈 내용</a></li>
<li><a class="reference internal" href="#regular-expression-objects">정규식 객체</a></li>
<li><a class="reference internal" href="#match-objects">일치 객체</a></li>
<li><a class="reference internal" href="#regular-expression-examples">정규식 예제</a><ul>
<li><a class="reference internal" href="#checking-for-a-pair">쌍 검사하기</a></li>
<li><a class="reference internal" href="#simulating-scanf">scanf() 시뮬레이션</a></li>
<li><a class="reference internal" href="#search-vs-match">search() 대 match()</a></li>
<li><a class="reference internal" href="#making-a-phonebook">전화번호부 만들기</a></li>
<li><a class="reference internal" href="#text-munging">텍스트 뒤섞기</a></li>
<li><a class="reference internal" href="#finding-all-adverbs">모든 부사 찾기</a></li>
<li><a class="reference internal" href="#finding-all-adverbs-and-their-positions">모든 부사와 그 위치 찾기</a></li>
<li><a class="reference internal" href="#raw-string-notation">날 문자열 표기법</a></li>
<li><a class="reference internal" href="#writing-a-tokenizer">토크나이저 작성하기</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="string.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code> --- 일반적인 문자열 연산</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="difflib.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code> --- 델타 계산을 위한 도우미</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="difflib.html" title="difflib --- 델타 계산을 위한 도우미"
             >다음</a> |</li>
        <li class="right" >
          <a href="string.html" title="string --- 일반적인 문자열 연산"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="text.html" >텍스트 처리 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>