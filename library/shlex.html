
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>shlex --- 간단한 어휘 분석 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="Tk를 사용한 그래픽 사용자 인터페이스" href="tk.html" />
    <link rel="prev" title="cmd --- 줄 지향 명령 인터프리터 지원" href="cmd.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/shlex.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="tk.html" title="Tk를 사용한 그래픽 사용자 인터페이스"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="cmd.html" title="cmd --- 줄 지향 명령 인터프리터 지원"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="frameworks.html" accesskey="U">프로그램 프레임워크</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-shlex">
<span id="shlex-simple-lexical-analysis"></span><h1><a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shlex</span></code></a> --- 간단한 어휘 분석<a class="headerlink" href="#module-shlex" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/shlex.py">Lib/shlex.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 클래스를 사용하면 유닉스 셸과 유사한 간단한 구문에 대한 어휘 분석기를 쉽게 작성할 수 있습니다. 이것은 미니 언어를 작성하거나 (예를 들어 파이썬 응용 프로그램을 위한 실행 제어 파일에서), 인용된 문자열을 구문 분석할 때 유용합니다.</p>
<p><a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shlex</span></code></a> 모듈은 다음 함수를 정의합니다:</p>
<dl class="function">
<dt id="shlex.split">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param">s</em>, <em class="sig-param">comments=False</em>, <em class="sig-param">posix=True</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.split" title="정의 주소">¶</a></dt>
<dd><p>셸과 비슷한 문법을 사용하여 문자열 <em>s</em>를 분할합니다. <em>comments</em>가 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>(기본값)이면, 지정된 문자열의 주석 구문 분석이 비활성화됩니다 (<a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 인스턴스의 <a class="reference internal" href="#shlex.shlex.commenters" title="shlex.shlex.commenters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">commenters</span></code></a> 어트리뷰트를 빈 문자열로 설정합니다). 이 함수는 기본적으로 POSIX 모드로 작동하지만, <em>posix</em> 인자가 거짓이면 비 POSIX 모드를 사용합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#shlex.split" title="shlex.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> 함수는 <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 인스턴스를 인스턴스화 하므로, <em>s</em>에 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 전달하면 표준 입력에서 분할할 문자열을 읽습니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><em>s</em>에 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 전달하면 향후 파이썬 버전에서 예외가 발생할 것입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="shlex.join">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">join</code><span class="sig-paren">(</span><em class="sig-param">split_command</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.join" title="정의 주소">¶</a></dt>
<dd><p>리스트 <em>split_command</em>의 토큰을 이어붙이고 문자열을 반환합니다. 이 함수는 <a class="reference internal" href="#shlex.split" title="shlex.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>의 역함수입니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shlex</span> <span class="k">import</span> <span class="n">join</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;echo&#39;</span><span class="p">,</span> <span class="s1">&#39;-n&#39;</span><span class="p">,</span> <span class="s1">&#39;Multiple words&#39;</span><span class="p">]))</span>
<span class="go">echo -n &#39;Multiple words&#39;</span>
</pre></div>
</div>
<p>반환된 값은 주입 취약점(injection vulnerabilities)으로부터 보호하기 위해 셸 이스케이프 처리됩니다 (<a class="reference internal" href="#shlex.quote" title="shlex.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>를 참조하십시오).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="shlex.quote">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">quote</code><span class="sig-paren">(</span><em class="sig-param">s</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.quote" title="정의 주소">¶</a></dt>
<dd><p>셸 이스케이프 된 문자열 <em>s</em>를 반환합니다. 반환된 값은 (리스트를 사용할 수 없는 경우) 셸 명령 줄에서 하나의 토큰으로 안전하게 사용할 수 있는 문자열입니다.</p>
<p>이 관용구는 안전하지 않습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;somefile; rm -rf ~&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">command</span> <span class="o">=</span> <span class="s1">&#39;ls -l </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>  <span class="c1"># 셀로 실행하면 큰일 납니다!</span>
<span class="go">ls -l somefile; rm -rf ~</span>
</pre></div>
</div>
<p><a class="reference internal" href="#shlex.quote" title="shlex.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>를 사용하면 보안 허점을 메꿀 수 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shlex</span> <span class="k">import</span> <span class="n">quote</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">command</span> <span class="o">=</span> <span class="s1">&#39;ls -l </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">quote</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
<span class="go">ls -l &#39;somefile; rm -rf ~&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">remote_command</span> <span class="o">=</span> <span class="s1">&#39;ssh home </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">quote</span><span class="p">(</span><span class="n">command</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">remote_command</span><span class="p">)</span>
<span class="go">ssh home &#39;ls -l &#39;&quot;&#39;&quot;&#39;somefile; rm -rf ~&#39;&quot;&#39;&quot;&#39;&#39;</span>
</pre></div>
</div>
<p>인용(quoting)은 유닉스 셸과 <a class="reference internal" href="#shlex.split" title="shlex.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>과 호환됩니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shlex</span> <span class="k">import</span> <span class="n">split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">remote_command</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">remote_command</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">remote_command</span>
<span class="go">[&#39;ssh&#39;, &#39;home&#39;, &quot;ls -l &#39;somefile; rm -rf ~&#39;&quot;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">command</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">remote_command</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">command</span>
<span class="go">[&#39;ls&#39;, &#39;-l&#39;, &#39;somefile; rm -rf ~&#39;]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<p><a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shlex</span></code></a> 모듈은 다음 클래스를 정의합니다:</p>
<dl class="class">
<dt id="shlex.shlex">
<em class="property">class </em><code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">shlex</code><span class="sig-paren">(</span><em class="sig-param">instream=None</em>, <em class="sig-param">infile=None</em>, <em class="sig-param">posix=False</em>, <em class="sig-param">punctuation_chars=False</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 인스턴스나 서브 클래스 인스턴스는 어휘 분석기 객체입니다. 존재할 때 초기화 인자는 문자를 어디에서 읽을지를 지정합니다. <a class="reference internal" href="io.html#io.TextIOBase.read" title="io.TextIOBase.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>와 <a class="reference internal" href="io.html#io.TextIOBase.readline" title="io.TextIOBase.readline"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> 메서드가 있는 파일/스트림류 객체이거나 문자열이어야 합니다. 인자가 없으면 <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>에서 입력을 받습니다. 두 번째 선택적 인자는 파일명 문자열이며, <a class="reference internal" href="#shlex.shlex.infile" title="shlex.shlex.infile"><code class="xref py py-attr docutils literal notranslate"><span class="pre">infile</span></code></a> 어트리뷰트의 초깃값을 설정합니다. <em>instream</em> 인자가 생략되거나 <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>과 같으면, 이 두 번째 인자의 기본값은 &quot;stdin&quot;입니다. <em>posix</em> 인자는 작동 모드를 정의합니다: <em>posix</em>가 참이 아닐 때 (기본값), <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 인스턴스는 호환 모드에서 작동합니다. POSIX 모드에서 작동할 때, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a>는 가능한 한 POSIX 셸 구문 분석 규칙에 가깝도록 시도합니다. <em>punctuation_chars</em> 인자는 동작을 실제 셸이 구문 분석하는 방식에 더 가깝게 만드는 방법을 제공합니다. 이것은 여러 종류의 값을 취할 수 있습니다: 기본값 <code class="docutils literal notranslate"><span class="pre">False</span></code>는 파이썬 3.5와 이전 버전에서의 동작을 유지합니다. <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정되면, 문자 <code class="docutils literal notranslate"><span class="pre">();&lt;&gt;|&amp;</span></code>의 구문 분석이 변경됩니다: 이러한 문자(구두(punctuation) 문자로 간주합니다)의 모든 연속은 단일 토큰으로 반환됩니다. 비어 있지 않은 문자열로 설정하면, 해당 문자는 구두(punctuation) 문자로 사용됩니다. <em>punctuation_chars</em>에 나타나는 <a class="reference internal" href="#shlex.shlex.wordchars" title="shlex.shlex.wordchars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">wordchars</span></code></a> 어트리뷰트의 문자는 <a class="reference internal" href="#shlex.shlex.wordchars" title="shlex.shlex.wordchars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">wordchars</span></code></a>에서 제거됩니다. 자세한 정보는 <a class="reference internal" href="#improved-shell-compatibility"><span class="std std-ref">셸과의 호환성 향상</span></a>을 참조하십시오. <em>punctuation_chars</em>는 <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 인스턴스 생성 시에만 설정할 수 있으며 나중에 수정할 수 없습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><em>punctuation_chars</em> 매개 변수가 추가되었습니다.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt>모듈 <a class="reference internal" href="configparser.html#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a></dt><dd><p>윈도우 <code class="file docutils literal notranslate"><span class="pre">.ini</span></code> 파일과 유사한 구성 파일 구문 분석기.</p>
</dd>
</dl>
</div>
<div class="section" id="shlex-objects">
<span id="id1"></span><h2>shlex 객체<a class="headerlink" href="#shlex-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 인스턴스에는 다음과 같은 메서드가 있습니다:</p>
<dl class="method">
<dt id="shlex.shlex.get_token">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">get_token</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex.get_token" title="정의 주소">¶</a></dt>
<dd><p>토큰을 반환합니다. <a class="reference internal" href="#shlex.shlex.push_token" title="shlex.shlex.push_token"><code class="xref py py-meth docutils literal notranslate"><span class="pre">push_token()</span></code></a>을 사용하여 토큰이 스택(stack) 되었으면, 스택에서 토큰을 팝(pop) 합니다. 그렇지 않으면, 입력 스트림에서 하나를 읽습니다. 읽기가 즉시 파일 끝을 만나면, <a class="reference internal" href="#shlex.shlex.eof" title="shlex.shlex.eof"><code class="xref py py-attr docutils literal notranslate"><span class="pre">eof</span></code></a>가 반환됩니다 (POSIX 모드가 아니면 빈 문자열 (<code class="docutils literal notranslate"><span class="pre">''</span></code>), POSIX 모드이면 <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="method">
<dt id="shlex.shlex.push_token">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">push_token</code><span class="sig-paren">(</span><em class="sig-param">str</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex.push_token" title="정의 주소">¶</a></dt>
<dd><p>인자를 토큰 스택으로 푸시(push)합니다.</p>
</dd></dl>

<dl class="method">
<dt id="shlex.shlex.read_token">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">read_token</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex.read_token" title="정의 주소">¶</a></dt>
<dd><p>원시 토큰을 읽습니다. 푸시백 스택을 무시하고, 소스 요청(source requests)을 해석하지 않습니다. (이것은 일반적으로 유용한 진입점이 아니며, 단지 완전성을 위해 여기에서 설명합니다.)</p>
</dd></dl>

<dl class="method">
<dt id="shlex.shlex.sourcehook">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">sourcehook</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex.sourcehook" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a>가 소스 요청(아래 <a class="reference internal" href="#shlex.shlex.source" title="shlex.shlex.source"><code class="xref py py-attr docutils literal notranslate"><span class="pre">source</span></code></a>를 참조하십시오)을 감지할 때 이 메서드에는 다음 토큰이 인자로 제공되고 파일명과 열린 파일류 객체로 구성된 튜플을 반환해야 합니다.</p>
<p>일반적으로, 이 메서드는 먼저 인자에서 인용(quotes)을 제거합니다. 결과가 절대 경로명이거나 유효한 이전 소스 요청이 없거나 이전 소스가 스트림(가령 <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>)이면 결과는 그대로 유지됩니다. 그렇지 않으면, 결과가 상대 경로명이면 소스 포함 스택에서 파일 바로 앞에 있는 파일의 이름의 디렉터리 부분을 앞에 붙입니다 (이 동작은 C 전처리기가 <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;file.h&quot;</span></code>를 처리하는 방식과 유사합니다).</p>
<p>조작 결과는 파일명으로 취급되고, 튜플의 첫 번째 구성 요소로 반환되며, 이것에 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>이 호출되어 두 번째 구성 요소를 산출합니다. (참고: 이것은 인스턴스 초기화의 인자 순서와 반대입니다!)</p>
<p>이 훅은 디렉터리 검색 경로, 파일 확장자 추가 및 기타 네임 스페이스 해킹을 구현하는 데 사용할 수 있도록 노출됩니다. 해당 '닫기' 훅은 없지만, shlex 인스턴스는 소스 입력 스트림이 EOF를 반환할 때 그것의 <a class="reference internal" href="io.html#io.IOBase.close" title="io.IOBase.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 메서드를 호출합니다.</p>
<p>소스 스태킹을 더 명시적으로 제어하려면, <a class="reference internal" href="#shlex.shlex.push_source" title="shlex.shlex.push_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">push_source()</span></code></a>와 <a class="reference internal" href="#shlex.shlex.pop_source" title="shlex.shlex.pop_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pop_source()</span></code></a> 메서드를 사용하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="shlex.shlex.push_source">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">push_source</code><span class="sig-paren">(</span><em class="sig-param">newstream</em>, <em class="sig-param">newfile=None</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex.push_source" title="정의 주소">¶</a></dt>
<dd><p>입력 소스 스트림을 입력 스택으로 푸시합니다. filename 인자가 지정되면 나중에 에러 메시지에 사용할 수 있습니다. 이것은 <a class="reference internal" href="#shlex.shlex.sourcehook" title="shlex.shlex.sourcehook"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sourcehook()</span></code></a> 메서드에 의해 내부적으로 사용되는 것과 같은 메서드입니다.</p>
</dd></dl>

<dl class="method">
<dt id="shlex.shlex.pop_source">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">pop_source</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex.pop_source" title="정의 주소">¶</a></dt>
<dd><p>마지막으로 푸시 된 입력 소스를 입력 스택에서 팝 합니다. 이는 어휘 분석기가 스택 된 입력 스트림에서 EOF에 도달할 때 내부적으로 사용되는 것과 같은 메서드입니다.</p>
</dd></dl>

<dl class="method">
<dt id="shlex.shlex.error_leader">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">error_leader</code><span class="sig-paren">(</span><em class="sig-param">infile=None</em>, <em class="sig-param">lineno=None</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex.error_leader" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 유닉스 C 컴파일러 에러 레이블 형식으로 에러 메시지 리더를 생성합니다; 형식은 <code class="docutils literal notranslate"><span class="pre">'&quot;%s&quot;,</span> <span class="pre">line</span> <span class="pre">%d:</span> <span class="pre">'</span></code>이며, 여기서 <code class="docutils literal notranslate"><span class="pre">%s</span></code>는 현재 소스 파일의 이름으로 치환되고 <code class="docutils literal notranslate"><span class="pre">%d</span></code>는 현재 입력 줄 번호로 치환됩니다 (선택적 인자를 사용하여 이를 재정의할 수 있습니다).</p>
<p>이 편리 메서드는 <a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shlex</span></code></a> 사용자가 Emacs와 기타 유닉스 도구가 이해할 수 있는 표준의 구문 분석 가능한 형식으로 에러 메시지를 생성하도록 권장하기 위해 제공됩니다.</p>
</dd></dl>

<p><a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 서브 클래스의 인스턴스에는 어휘 분석을 제어하거나 디버깅에 사용할 수 있는 일부 공용 인스턴스 변수가 있습니다:</p>
<dl class="attribute">
<dt id="shlex.shlex.commenters">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">commenters</code><a class="headerlink" href="#shlex.shlex.commenters" title="정의 주소">¶</a></dt>
<dd><p>주석을 시작하는 것으로 인식되는 문자열. 주석 시작부터 줄 끝까지의 모든 문자는 무시됩니다. 기본적으로 <code class="docutils literal notranslate"><span class="pre">'#'</span></code> 만 포함합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.wordchars">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">wordchars</code><a class="headerlink" href="#shlex.shlex.wordchars" title="정의 주소">¶</a></dt>
<dd><p>다중 문자 토큰에 누적될 문자들의 문자열. 기본적으로, 모든 ASCII 영숫자와 밑줄이 포함됩니다. POSIX 모드에서는, 라틴-1 집합의 악센트 부호 문자도 포함됩니다. <a class="reference internal" href="#shlex.shlex.punctuation_chars" title="shlex.shlex.punctuation_chars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">punctuation_chars</span></code></a>가 비어 있지 않으면, 파일명 명세와 명령 줄 매개 변수에 나타날 수 있는 문자 <code class="docutils literal notranslate"><span class="pre">~-./*?=</span></code>도 이 어트리뷰트에 포함되며, <code class="docutils literal notranslate"><span class="pre">punctuation_chars</span></code>에 있는 문자는 <code class="docutils literal notranslate"><span class="pre">wordchars</span></code>에 있으면 제거됩니다. <a class="reference internal" href="#shlex.shlex.whitespace_split" title="shlex.shlex.whitespace_split"><code class="xref py py-attr docutils literal notranslate"><span class="pre">whitespace_split</span></code></a>이 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정되면, 이것은 효과가 없습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.whitespace">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">whitespace</code><a class="headerlink" href="#shlex.shlex.whitespace" title="정의 주소">¶</a></dt>
<dd><p>공백으로 간주하여 건너뛸 문자들. 공백은 토큰의 경계를 만듭니다. 기본적으로, 스페이스, 탭, 줄 바꿈 및 캐리지 리턴이 포함됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.escape">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">escape</code><a class="headerlink" href="#shlex.shlex.escape" title="정의 주소">¶</a></dt>
<dd><p>이스케이프로 간주하는 문자들. POSIX 모드에서만 사용되며, 기본적으로 <code class="docutils literal notranslate"><span class="pre">'\'</span></code> 만 포함합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.quotes">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">quotes</code><a class="headerlink" href="#shlex.shlex.quotes" title="정의 주소">¶</a></dt>
<dd><p>문자열 인용으로 간주하는 문자들. 같은 인용을 다시 만날 때까지 토큰이 누적됩니다 (따라서, 다른 인용 유형은 셸에서와같이 서로를 보호합니다). 기본적으로, ASCII 작은따옴표와 큰따옴표가 포함됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.escapedquotes">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">escapedquotes</code><a class="headerlink" href="#shlex.shlex.escapedquotes" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#shlex.shlex.escape" title="shlex.shlex.escape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">escape</span></code></a>에 정의된 이스케이프 문자를 해석하는 <a class="reference internal" href="#shlex.shlex.quotes" title="shlex.shlex.quotes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">quotes</span></code></a>의 문자들. 이것은 POSIX 모드에서만 사용되며, 기본적으로 <code class="docutils literal notranslate"><span class="pre">'&quot;'</span></code> 만 포함합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.whitespace_split">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">whitespace_split</code><a class="headerlink" href="#shlex.shlex.whitespace_split" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">True</span></code>이면, 토큰은 공백으로만 분할됩니다. 예를 들어, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a>로 명령 줄을 구문 분석하고 셸 인자와 유사한 방식으로 토큰을 가져오는 데 유용합니다. <a class="reference internal" href="#shlex.shlex.punctuation_chars" title="shlex.shlex.punctuation_chars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">punctuation_chars</span></code></a>와 함께 사용하면, 토큰은 그 문자들 외에도 공백으로 분할됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><a class="reference internal" href="#shlex.shlex.punctuation_chars" title="shlex.shlex.punctuation_chars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">punctuation_chars</span></code></a> 어트리뷰트가 <a class="reference internal" href="#shlex.shlex.whitespace_split" title="shlex.shlex.whitespace_split"><code class="xref py py-attr docutils literal notranslate"><span class="pre">whitespace_split</span></code></a> 어트리뷰트와 호환되었습니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.infile">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">infile</code><a class="headerlink" href="#shlex.shlex.infile" title="정의 주소">¶</a></dt>
<dd><p>클래스 인스턴스화 시점에 처음 설정되거나 이후 소스 요청으로 스택 된 현재 입력 파일의 이름. 에러 메시지를 구성할 때 이를 조사하는 것이 유용할 수 있습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.instream">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">instream</code><a class="headerlink" href="#shlex.shlex.instream" title="정의 주소">¶</a></dt>
<dd><p>이 <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 인스턴스가 문자를 읽고 있는 입력 스트림.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.source">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">source</code><a class="headerlink" href="#shlex.shlex.source" title="정의 주소">¶</a></dt>
<dd><p>이 어트리뷰트는 기본적으로 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. 문자열을 대입하면, 해당 문자열은 여러 셸의 <code class="docutils literal notranslate"><span class="pre">source</span></code> 키워드와 유사한 어휘 수준 포함 요청으로 인식됩니다. 즉, 바로 다음 토큰이 파일명으로 열리고 그 스트림에서 입력을 EOF까지 취합니다, 이 시점에서 해당 스트림의 <a class="reference internal" href="io.html#io.IOBase.close" title="io.IOBase.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 메서드가 호출되고 입력 소스는 다시 원래 입력 스트림이 됩니다. 소스 요청은 임의의 수준 깊이로 스택 될 수 있습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.debug">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">debug</code><a class="headerlink" href="#shlex.shlex.debug" title="정의 주소">¶</a></dt>
<dd><p>이 어트리뷰트가 숫자이고 <code class="docutils literal notranslate"><span class="pre">1</span></code> 이상이면, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 인스턴스는 자신의 동작에 대한 자세한 진행 출력을 인쇄합니다. 이것을 사용해야 하면, 세부 사항을 배우기 위해 모듈 소스 코드를 읽을 수 있습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.lineno">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">lineno</code><a class="headerlink" href="#shlex.shlex.lineno" title="정의 주소">¶</a></dt>
<dd><p>소스 줄 번호 (지금까지 본 줄 넘김 개수에 1을 더한 것).</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.token">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">token</code><a class="headerlink" href="#shlex.shlex.token" title="정의 주소">¶</a></dt>
<dd><p>토큰 버퍼. 예외를 잡을 때 이를 조사하는 것이 유용 할 수 있습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.eof">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">eof</code><a class="headerlink" href="#shlex.shlex.eof" title="정의 주소">¶</a></dt>
<dd><p>파일 끝을 판단하는 데 사용되는 토큰. POSIX 모드가 아닐 때 빈 문자열 (<code class="docutils literal notranslate"><span class="pre">''</span></code>), POSIX 모드일 때 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.punctuation_chars">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">punctuation_chars</code><a class="headerlink" href="#shlex.shlex.punctuation_chars" title="정의 주소">¶</a></dt>
<dd><p>읽기 전용 프로퍼티. 구두 부호로 간주할 문자들. 구두 부호 문자들은 단일 토큰으로 반환됩니다. 그러나, 아무런 의미 유효성 검사도 수행되지 않음에 유의하십시오: 예를 들어 '&gt;&gt;&gt;'는 셸에서 인식되지 않더라도 토큰으로 반환될 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="parsing-rules">
<span id="shlex-parsing-rules"></span><h2>구문 분석 규칙<a class="headerlink" href="#parsing-rules" title="제목 주소">¶</a></h2>
<p>비 POSIX 모드에서 작동할 때, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a>는 다음 규칙을 따르려고 합니다.</p>
<ul class="simple">
<li><p>인용 문자는 단어 내에서 인식되지 않습니다 (<code class="docutils literal notranslate"><span class="pre">Do&quot;Not&quot;Separate</span></code>는 단일 단어 <code class="docutils literal notranslate"><span class="pre">Do&quot;Not&quot;Separate</span></code>로 구문 분석됩니다);</p></li>
<li><p>이스케이프 문자는 인식되지 않습니다;</p></li>
<li><p>인용으로 묶인 문자들은 인용 안에 있는 모든 문자의 리터럴 값을 유지합니다;</p></li>
<li><p>인용을 닫는 것은 단어를 분리합니다 (<code class="docutils literal notranslate"><span class="pre">&quot;Do&quot;Separate</span></code>는 <code class="docutils literal notranslate"><span class="pre">&quot;Do&quot;</span></code>와 <code class="docutils literal notranslate"><span class="pre">Separate</span></code>로 구문 분석됩니다);</p></li>
<li><p><a class="reference internal" href="#shlex.shlex.whitespace_split" title="shlex.shlex.whitespace_split"><code class="xref py py-attr docutils literal notranslate"><span class="pre">whitespace_split</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, 단어 문자, 공백 또는 인용으로 선언되지 않은 모든 문자는 단일 문자 토큰으로 반환됩니다. <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a>는 공백으로 만 단어를 분리합니다;</p></li>
<li><p>EOF는 빈 문자열(<code class="docutils literal notranslate"><span class="pre">''</span></code>)로 알립니다;</p></li>
<li><p>인용된 경우에도 빈 문자열을 구문 분석할 수 없습니다.</p></li>
</ul>
<p>POSIX 모드에서 작동할 때, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a>는 다음 구문 분석 규칙을 따르려고 합니다.</p>
<ul class="simple">
<li><p>인용은 제거되고, 단어를 분리하지 않습니다 (<code class="docutils literal notranslate"><span class="pre">&quot;Do&quot;Not&quot;Separate&quot;</span></code>는 단일 단어 <code class="docutils literal notranslate"><span class="pre">DoNotSeparate</span></code>로 구문 분석됩니다);</p></li>
<li><p>인용되지 않은 이스케이프 문자(예를 들어 <code class="docutils literal notranslate"><span class="pre">'\'</span></code>)는 다음에 오는 문자의 리터럴 값을 유지합니다;</p></li>
<li><p><a class="reference internal" href="#shlex.shlex.escapedquotes" title="shlex.shlex.escapedquotes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">escapedquotes</span></code></a>의 일부가 아닌 인용으로 묶인 문자(예를 들어 <code class="docutils literal notranslate"><span class="pre">&quot;'&quot;</span></code>)는 인용 안에 있는 모든 문자의 리터럴 값을 유지합니다;</p></li>
<li><p><a class="reference internal" href="#shlex.shlex.escapedquotes" title="shlex.shlex.escapedquotes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">escapedquotes</span></code></a>의 일부인 인용으로 묶인 문자(예를 들어 <code class="docutils literal notranslate"><span class="pre">'&quot;'</span></code>)는 <a class="reference internal" href="#shlex.shlex.escape" title="shlex.shlex.escape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">escape</span></code></a>에서 언급된 문자를 제외하고 인용 안에 있는 모든 문자의 리터럴 값을 유지합니다. 이스케이프 문자는 사용 중인 인용이나 이스케이프 문자 자체가 뒤에 오는 경우에만 특별한 의미를 유지합니다. 그렇지 않으면 이스케이프 문자는 일반 문자로 간주합니다.</p></li>
<li><p>EOF는 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 값으로 알립니다;</p></li>
<li><p>인용된 빈 문자열(<code class="docutils literal notranslate"><span class="pre">''</span></code>)이 허용됩니다.</p></li>
</ul>
</div>
<div class="section" id="improved-compatibility-with-shells">
<span id="improved-shell-compatibility"></span><h2>셸과의 호환성 향상<a class="headerlink" href="#improved-compatibility-with-shells" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
<p><a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 클래스는 <code class="docutils literal notranslate"><span class="pre">bash</span></code>, <code class="docutils literal notranslate"><span class="pre">dash</span></code> 및 <code class="docutils literal notranslate"><span class="pre">sh</span></code>와 같은 일반적인 유닉스 셸에서 수행하는 구문 분석과 호환됩니다. 이 호환성을 이용하려면, 생성자에서 <code class="docutils literal notranslate"><span class="pre">punctuation_chars</span></code> 인자를 지정하십시오. 기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code>이며, 3.6 이전 동작을 유지합니다. 그러나, <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정되면, 문자 <code class="docutils literal notranslate"><span class="pre">();&lt;&gt;|&amp;</span></code>의 구문 분석이 변경됩니다: 이러한 문자의 연속은 단일 토큰으로 반환됩니다. 이것은 셸에 대한 전체 파서로는 부족하지만 (여러 종류의 셀이 있음을 고려할 때, 표준 라이브러리의 범위를 벗어납니다), 이것이 없을 때보다 명령 줄 처리를 더 쉽게 수행할 수 있도록 합니다. 예시하기 위해, 다음 코드 조각에서 차이점을 볼 수 있습니다:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="go"> &gt;&gt;&gt; import shlex</span>
<span class="go"> &gt;&gt;&gt; text = &quot;a &amp;&amp; b; c &amp;&amp; d || e; f &gt;&#39;abc&#39;; (def \&quot;ghi\&quot;)&quot;</span>
<span class="go"> &gt;&gt;&gt; s = shlex.shlex(text, posix=True)</span>
<span class="go"> &gt;&gt;&gt; s.whitespace_split = True</span>
<span class="go"> &gt;&gt;&gt; list(s)</span>
<span class="go"> [&#39;a&#39;, &#39;&amp;&amp;&#39;, &#39;b;&#39;, &#39;c&#39;, &#39;&amp;&amp;&#39;, &#39;d&#39;, &#39;||&#39;, &#39;e;&#39;, &#39;f&#39;, &#39;&gt;abc;&#39;, &#39;(def&#39;, &#39;ghi)&#39;]</span>
<span class="go"> &gt;&gt;&gt; s = shlex.shlex(text, posix=True, punctuation_chars=True)</span>
<span class="go"> &gt;&gt;&gt; s.whitespace_split = True</span>
<span class="go"> &gt;&gt;&gt; list(s)</span>
<span class="go"> [&#39;a&#39;, &#39;&amp;&amp;&#39;, &#39;b&#39;, &#39;;&#39;, &#39;c&#39;, &#39;&amp;&amp;&#39;, &#39;d&#39;, &#39;||&#39;, &#39;e&#39;, &#39;;&#39;, &#39;f&#39;, &#39;&gt;&#39;, &#39;abc&#39;, &#39;;&#39;,</span>
<span class="go"> &#39;(&#39;, &#39;def&#39;, &#39;ghi&#39;, &#39;)&#39;]</span>
</pre></div>
</div>
<p>물론, 셸에 유효하지 않은 토큰이 반환되며, 반환된 토큰에 대해 여러분 자신의 에러 검사를 구현해야 합니다.</p>
<p>punctuation_chars 매개 변수의 값으로 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 전달하는 대신, 특정 문자가 포함된 문자열을 전달하면 구두 부호를 구성하는 문자를 판별하는 데 사용됩니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">shlex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">shlex</span><span class="o">.</span><span class="n">shlex</span><span class="p">(</span><span class="s2">&quot;a &amp;&amp; b || c&quot;</span><span class="p">,</span> <span class="n">punctuation_chars</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;&amp;&#39;, &#39;&amp;&#39;, &#39;b&#39;, &#39;||&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><code class="docutils literal notranslate"><span class="pre">punctuation_chars</span></code>가 지정되면, <a class="reference internal" href="#shlex.shlex.wordchars" title="shlex.shlex.wordchars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">wordchars</span></code></a> 어트리뷰트는 문자 <code class="docutils literal notranslate"><span class="pre">~-./*?=</span></code>로 보강됩니다. 이러한 문자는 파일 이름(와일드카드를 포함해서)과 명령 줄 인자(예를 들어 <code class="docutils literal notranslate"><span class="pre">--color=auto</span></code>)에 나타날 수 있기 때문입니다. 그래서:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">shlex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">shlex</span><span class="o">.</span><span class="n">shlex</span><span class="p">(</span><span class="s1">&#39;~/a &amp;&amp; b-c --color=auto || d *.py?&#39;</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">punctuation_chars</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;~/a&#39;, &#39;&amp;&amp;&#39;, &#39;b-c&#39;, &#39;--color=auto&#39;, &#39;||&#39;, &#39;d&#39;, &#39;*.py?&#39;]</span>
</pre></div>
</div>
<p>그러나, 가능한 한 가깝게 셸과 일치하려면, <a class="reference internal" href="#shlex.shlex.punctuation_chars" title="shlex.shlex.punctuation_chars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">punctuation_chars</span></code></a>를 사용할 때 항상 <code class="docutils literal notranslate"><span class="pre">posix</span></code>와 <a class="reference internal" href="#shlex.shlex.whitespace_split" title="shlex.shlex.whitespace_split"><code class="xref py py-attr docutils literal notranslate"><span class="pre">whitespace_split</span></code></a>를 사용하는 것이 좋습니다, 이는 <a class="reference internal" href="#shlex.shlex.wordchars" title="shlex.shlex.wordchars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">wordchars</span></code></a>를 완전히 무효로 합니다.</p>
</div>
<p>최상의 효과를 얻으려면, <code class="docutils literal notranslate"><span class="pre">punctuation_chars</span></code>를 <code class="docutils literal notranslate"><span class="pre">posix=True</span></code>와 함께 설정해야 합니다. (<code class="docutils literal notranslate"><span class="pre">posix=False</span></code>가 <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a>의 기본값임에 유의하십시오.)</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">shlex</span></code> --- 간단한 어휘 분석</a><ul>
<li><a class="reference internal" href="#shlex-objects">shlex 객체</a></li>
<li><a class="reference internal" href="#parsing-rules">구문 분석 규칙</a></li>
<li><a class="reference internal" href="#improved-compatibility-with-shells">셸과의 호환성 향상</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="cmd.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmd</span></code> --- 줄 지향 명령 인터프리터 지원</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="tk.html"
                        title="다음 장">Tk를 사용한 그래픽 사용자 인터페이스</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="tk.html" title="Tk를 사용한 그래픽 사용자 인터페이스"
             >다음</a> |</li>
        <li class="right" >
          <a href="cmd.html" title="cmd --- 줄 지향 명령 인터프리터 지원"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="frameworks.html" >프로그램 프레임워크</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>