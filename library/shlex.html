
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>shlex --- 간단한 어휘 분석 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="Tk를 사용한 그래픽 사용자 인터페이스" href="tk.html" />
    <link rel="prev" title="cmd --- 줄 지향 명령 인터프리터 지원" href="cmd.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/shlex.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="tk.html" title="Tk를 사용한 그래픽 사용자 인터페이스"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="cmd.html" title="cmd --- 줄 지향 명령 인터프리터 지원"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="frameworks.html" accesskey="U">프로그램 프레임워크</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-shlex">
<span id="shlex-simple-lexical-analysis"></span><h1><a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shlex</span></code></a> --- 간단한 어휘 분석<a class="headerlink" href="#module-shlex" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/shlex.py">Lib/shlex.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 클래스를 사용하면 유닉스 셸과 유사한 간단한 구문에 대한 어휘 분석기를 쉽게 작성할 수 있습니다. 이것은 미니 언어를 작성하거나 (예를 들어 파이썬 응용 프로그램을 위한 실행 제어 파일에서), 인용된 문자열을 구문 분석할 때 유용합니다.</p>
<p><a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shlex</span></code></a> 모듈은 다음 함수를 정의합니다:</p>
<dl class="function">
<dt id="shlex.split">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param">s</em>, <em class="sig-param">comments=False</em>, <em class="sig-param">posix=True</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.split" title="정의 주소">¶</a></dt>
<dd><p>셸과 비슷한 문법을 사용하여 문자열 <em>s</em>를 분할합니다. <em>comments</em>가 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>(기본값)이면, 지정된 문자열의 주석 구문 분석이 비활성화됩니다 (<a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 인스턴스의 <a class="reference internal" href="#shlex.shlex.commenters" title="shlex.shlex.commenters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">commenters</span></code></a> 어트리뷰트를 빈 문자열로 설정합니다). 이 함수는 기본적으로 POSIX 모드로 작동하지만, <em>posix</em> 인자가 거짓이면 비 POSIX 모드를 사용합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#shlex.split" title="shlex.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> 함수는 <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 인스턴스를 인스턴스화하므로, <em>s</em>에 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 전달하면 표준 입력에서 분할할 문자열을 읽습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="shlex.join">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">join</code><span class="sig-paren">(</span><em class="sig-param">split_command</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.join" title="정의 주소">¶</a></dt>
<dd><p>리스트 <em>split_command</em>의 토큰을 이어붙이고 문자열을 반환합니다. 이 함수는 <a class="reference internal" href="#shlex.split" title="shlex.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>의 역함수입니다.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shlex</span> <span class="k">import</span> <span class="n">join</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;echo&#39;</span><span class="p">,</span> <span class="s1">&#39;-n&#39;</span><span class="p">,</span> <span class="s1">&#39;Multiple words&#39;</span><span class="p">]))</span>
<span class="go">echo -n &#39;Multiple words&#39;</span>
</pre></div>
</div>
<p>반환된 값은 주입 취약점(injection vulnerabilities)으로부터 보호하기 위해 셸 이스케이프 처리됩니다 (<a class="reference internal" href="#shlex.quote" title="shlex.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>를 참조하십시오).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="shlex.quote">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">quote</code><span class="sig-paren">(</span><em class="sig-param">s</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.quote" title="정의 주소">¶</a></dt>
<dd><p>셸 이스케이프 된 문자열 <em>s</em>를 반환합니다. 반환된 값은 (리스트를 사용할 수 없는 경우) 셸 명령 줄에서 하나의 토큰으로 안전하게 사용할 수 있는 문자열입니다.</p>
<p>이 관용구는 안전하지 않습니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;somefile; rm -rf ~&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">command</span> <span class="o">=</span> <span class="s1">&#39;ls -l </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>  <span class="c1"># 셀로 실행하면 큰일 납니다!</span>
<span class="go">ls -l somefile; rm -rf ~</span>
</pre></div>
</div>
<p><a class="reference internal" href="#shlex.quote" title="shlex.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>를 사용하면 보안 허점을 매꿀 수 있습니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shlex</span> <span class="k">import</span> <span class="n">quote</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">command</span> <span class="o">=</span> <span class="s1">&#39;ls -l </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">quote</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
<span class="go">ls -l &#39;somefile; rm -rf ~&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">remote_command</span> <span class="o">=</span> <span class="s1">&#39;ssh home </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">quote</span><span class="p">(</span><span class="n">command</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">remote_command</span><span class="p">)</span>
<span class="go">ssh home &#39;ls -l &#39;&quot;&#39;&quot;&#39;somefile; rm -rf ~&#39;&quot;&#39;&quot;&#39;&#39;</span>
</pre></div>
</div>
<p>인용(quoting)은 유닉스 셸과 <a class="reference internal" href="#shlex.split" title="shlex.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>와 호환됩니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shlex</span> <span class="k">import</span> <span class="n">split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">remote_command</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">remote_command</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">remote_command</span>
<span class="go">[&#39;ssh&#39;, &#39;home&#39;, &quot;ls -l &#39;somefile; rm -rf ~&#39;&quot;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">command</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">remote_command</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">command</span>
<span class="go">[&#39;ls&#39;, &#39;-l&#39;, &#39;somefile; rm -rf ~&#39;]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<p><a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shlex</span></code></a> 모듈은 다음 클래스를 정의합니다:</p>
<dl class="class">
<dt id="shlex.shlex">
<em class="property">class </em><code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">shlex</code><span class="sig-paren">(</span><em class="sig-param">instream=None</em>, <em class="sig-param">infile=None</em>, <em class="sig-param">posix=False</em>, <em class="sig-param">punctuation_chars=False</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 인스턴스나 서브 클래스 인스턴스는 어휘 분석기 객체입니다. 존재할 때 초기화 인자는 문자를 어디에서 읽을지를 지정합니다. <a class="reference internal" href="io.html#io.TextIOBase.read" title="io.TextIOBase.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>와 <a class="reference internal" href="io.html#io.TextIOBase.readline" title="io.TextIOBase.readline"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> 메서드가 있는 파일/스트림류 객체이거나 문자열이어야 합니다. 인자가 없으면 <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>에서 입력을 받습니다. 두 번째 선택적 인자는 파일명 문자열이며, <a class="reference internal" href="#shlex.shlex.infile" title="shlex.shlex.infile"><code class="xref py py-attr docutils literal notranslate"><span class="pre">infile</span></code></a> 어트리뷰트의 초기 값을 설정합니다. <em>instream</em> 인자가 생략되거나 <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>과 같으면, 이 두 번째 인자의 기본값은 &quot;stdin&quot;입니다. <em>posix</em> 인자는 작동 모드를 정의합니다: <em>posix</em>가 참이 아닐 때 (기본값), <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 인스턴스는 호환 모드에서 작동합니다. POSIX 모드에서 작동할 때, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a>는 가능한 한 POSIX 셸 구문 분석 규칙에 가깝도록 시도합니다. <em>punctuation_chars</em> 인자는 동작을 실제 셸이 구문 분석하는 방식에 더 가깝게 만드는 방법을 제공합니다. 이것은 여러 종류의 값을 취할 수 있습니다: 기본값 <code class="docutils literal notranslate"><span class="pre">False</span></code>는 파이썬 3.5와 이전 버전에서의 동작을 유지합니다. <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정되면, 문자 <code class="docutils literal notranslate"><span class="pre">();&lt;&gt;|&amp;</span></code>의 구문 분석이 변경됩니다: 이러한 문자(구두(punctuation) 문자로 간주합니다)의 모든 연속은 단일 토큰으로 반환됩니다. 비어 있지 않은 문자열로 설정하면, 해당 문자는 구두(punctuation) 문자로 사용됩니다. <em>punctuation_chars</em>에 나타나는 <a class="reference internal" href="#shlex.shlex.wordchars" title="shlex.shlex.wordchars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">wordchars</span></code></a> 어트리뷰트의 문자는 <a class="reference internal" href="#shlex.shlex.wordchars" title="shlex.shlex.wordchars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">wordchars</span></code></a>에서 제거됩니다. 자세한 정보는 <a class="reference internal" href="#improved-shell-compatibility"><span class="std std-ref">셸과의 호환성 향상</span></a>을 참조하십시오. <em>punctuation_chars</em>는 <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 인스턴스 생성시에만 설정할 수 있으며 나중에 수정할 수 없습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><em>punctuation_chars</em> 매개 변수가 추가되었습니다.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt>모듈 <a class="reference internal" href="configparser.html#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a></dt><dd><p>윈도우 <code class="file docutils literal notranslate"><span class="pre">.ini</span></code> 파일과 유사한 구성 파일 구문 분석기.</p>
</dd>
</dl>
</div>
<div class="section" id="shlex-objects">
<span id="id1"></span><h2>shlex 객체<a class="headerlink" href="#shlex-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> 인스턴스에는 다음과 같은 메서드가 있습니다:</p>
<dl class="method">
<dt id="shlex.shlex.get_token">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">get_token</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex.get_token" title="정의 주소">¶</a></dt>
<dd><p>토큰을 반환합니다. <a class="reference internal" href="#shlex.shlex.push_token" title="shlex.shlex.push_token"><code class="xref py py-meth docutils literal notranslate"><span class="pre">push_token()</span></code></a>를 사용하여 토큰이 스택(stack)되었으면, 스택에서 토큰을 팝(pop)합니다. 그렇지 않으면, 입력 스트림에서 하나를 읽습니다. 읽기가 즉시 파일 끝을 만나면, <a class="reference internal" href="#shlex.shlex.eof" title="shlex.shlex.eof"><code class="xref py py-attr docutils literal notranslate"><span class="pre">eof</span></code></a>가 반환됩니다 (POSIX 모드가 아니면 빈 문자열 (<code class="docutils literal notranslate"><span class="pre">''</span></code>), POSIX 모드면 <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="method">
<dt id="shlex.shlex.push_token">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">push_token</code><span class="sig-paren">(</span><em class="sig-param">str</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex.push_token" title="정의 주소">¶</a></dt>
<dd><p>인자를 토큰 스택으로 푸시(push)합니다.</p>
</dd></dl>

<dl class="method">
<dt id="shlex.shlex.read_token">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">read_token</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex.read_token" title="정의 주소">¶</a></dt>
<dd><p>원시 토큰을 읽습니다. 푸시 백 스택을 무시하고, 소스 요청(source requests)을 해석하지 않습니다. (이것은 일반적으로 유용한 진입점이 아니며, 단지 완전성을 위해 여기에서 설명합니다.)</p>
</dd></dl>

<dl class="method">
<dt id="shlex.shlex.sourcehook">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">sourcehook</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex.sourcehook" title="정의 주소">¶</a></dt>
<dd><p>When <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> detects a source request (see <a class="reference internal" href="#shlex.shlex.source" title="shlex.shlex.source"><code class="xref py py-attr docutils literal notranslate"><span class="pre">source</span></code></a>
below) this method is given the following token as argument, and expected
to return a tuple consisting of a filename and an open file-like object.</p>
<p>Normally, this method first strips any quotes off the argument.  If the result
is an absolute pathname, or there was no previous source request in effect, or
the previous source was a stream (such as <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>), the result is left
alone.  Otherwise, if the result is a relative pathname, the directory part of
the name of the file immediately before it on the source inclusion stack is
prepended (this behavior is like the way the C preprocessor handles <code class="docutils literal notranslate"><span class="pre">#include</span>
<span class="pre">&quot;file.h&quot;</span></code>).</p>
<p>The result of the manipulations is treated as a filename, and returned as the
first component of the tuple, with <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> called on it to yield the second
component. (Note: this is the reverse of the order of arguments in instance
initialization!)</p>
<p>This hook is exposed so that you can use it to implement directory search paths,
addition of file extensions, and other namespace hacks. There is no
corresponding 'close' hook, but a shlex instance will call the
<a class="reference internal" href="io.html#io.IOBase.close" title="io.IOBase.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> method of the sourced input stream when it returns
EOF.</p>
<p>For more explicit control of source stacking, use the <a class="reference internal" href="#shlex.shlex.push_source" title="shlex.shlex.push_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">push_source()</span></code></a> and
<a class="reference internal" href="#shlex.shlex.pop_source" title="shlex.shlex.pop_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pop_source()</span></code></a> methods.</p>
</dd></dl>

<dl class="method">
<dt id="shlex.shlex.push_source">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">push_source</code><span class="sig-paren">(</span><em class="sig-param">newstream</em>, <em class="sig-param">newfile=None</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex.push_source" title="정의 주소">¶</a></dt>
<dd><p>Push an input source stream onto the input stack.  If the filename argument is
specified it will later be available for use in error messages.  This is the
same method used internally by the <a class="reference internal" href="#shlex.shlex.sourcehook" title="shlex.shlex.sourcehook"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sourcehook()</span></code></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="shlex.shlex.pop_source">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">pop_source</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex.pop_source" title="정의 주소">¶</a></dt>
<dd><p>Pop the last-pushed input source from the input stack. This is the same method
used internally when the lexer reaches EOF on a stacked input stream.</p>
</dd></dl>

<dl class="method">
<dt id="shlex.shlex.error_leader">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">error_leader</code><span class="sig-paren">(</span><em class="sig-param">infile=None</em>, <em class="sig-param">lineno=None</em><span class="sig-paren">)</span><a class="headerlink" href="#shlex.shlex.error_leader" title="정의 주소">¶</a></dt>
<dd><p>This method generates an error message leader in the format of a Unix C compiler
error label; the format is <code class="docutils literal notranslate"><span class="pre">'&quot;%s&quot;,</span> <span class="pre">line</span> <span class="pre">%d:</span> <span class="pre">'</span></code>, where the <code class="docutils literal notranslate"><span class="pre">%s</span></code> is replaced
with the name of the current source file and the <code class="docutils literal notranslate"><span class="pre">%d</span></code> with the current input
line number (the optional arguments can be used to override these).</p>
<p>This convenience is provided to encourage <a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shlex</span></code></a> users to generate error
messages in the standard, parseable format understood by Emacs and other Unix
tools.</p>
</dd></dl>

<p>Instances of <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> subclasses have some public instance
variables which either control lexical analysis or can be used for debugging:</p>
<dl class="attribute">
<dt id="shlex.shlex.commenters">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">commenters</code><a class="headerlink" href="#shlex.shlex.commenters" title="정의 주소">¶</a></dt>
<dd><p>The string of characters that are recognized as comment beginners. All
characters from the comment beginner to end of line are ignored. Includes just
<code class="docutils literal notranslate"><span class="pre">'#'</span></code> by default.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.wordchars">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">wordchars</code><a class="headerlink" href="#shlex.shlex.wordchars" title="정의 주소">¶</a></dt>
<dd><p>The string of characters that will accumulate into multi-character tokens.  By
default, includes all ASCII alphanumerics and underscore.  In POSIX mode, the
accented characters in the Latin-1 set are also included.  If
<a class="reference internal" href="#shlex.shlex.punctuation_chars" title="shlex.shlex.punctuation_chars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">punctuation_chars</span></code></a> is not empty, the characters <code class="docutils literal notranslate"><span class="pre">~-./*?=</span></code>, which can
appear in filename specifications and command line parameters, will also be
included in this attribute, and any characters which appear in
<code class="docutils literal notranslate"><span class="pre">punctuation_chars</span></code> will be removed from <code class="docutils literal notranslate"><span class="pre">wordchars</span></code> if they are present
there. If <a class="reference internal" href="#shlex.shlex.whitespace_split" title="shlex.shlex.whitespace_split"><code class="xref py py-attr docutils literal notranslate"><span class="pre">whitespace_split</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, this will have no
effect.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.whitespace">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">whitespace</code><a class="headerlink" href="#shlex.shlex.whitespace" title="정의 주소">¶</a></dt>
<dd><p>Characters that will be considered whitespace and skipped.  Whitespace bounds
tokens.  By default, includes space, tab, linefeed and carriage-return.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.escape">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">escape</code><a class="headerlink" href="#shlex.shlex.escape" title="정의 주소">¶</a></dt>
<dd><p>Characters that will be considered as escape. This will be only used in POSIX
mode, and includes just <code class="docutils literal notranslate"><span class="pre">'\'</span></code> by default.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.quotes">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">quotes</code><a class="headerlink" href="#shlex.shlex.quotes" title="정의 주소">¶</a></dt>
<dd><p>Characters that will be considered string quotes.  The token accumulates until
the same quote is encountered again (thus, different quote types protect each
other as in the shell.)  By default, includes ASCII single and double quotes.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.escapedquotes">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">escapedquotes</code><a class="headerlink" href="#shlex.shlex.escapedquotes" title="정의 주소">¶</a></dt>
<dd><p>Characters in <a class="reference internal" href="#shlex.shlex.quotes" title="shlex.shlex.quotes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">quotes</span></code></a> that will interpret escape characters defined in
<a class="reference internal" href="#shlex.shlex.escape" title="shlex.shlex.escape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">escape</span></code></a>.  This is only used in POSIX mode, and includes just <code class="docutils literal notranslate"><span class="pre">'&quot;'</span></code> by
default.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.whitespace_split">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">whitespace_split</code><a class="headerlink" href="#shlex.shlex.whitespace_split" title="정의 주소">¶</a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, tokens will only be split in whitespaces.  This is useful, for
example, for parsing command lines with <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a>, getting
tokens in a similar way to shell arguments.  When used in combination with
<a class="reference internal" href="#shlex.shlex.punctuation_chars" title="shlex.shlex.punctuation_chars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">punctuation_chars</span></code></a>, tokens will be split on whitespace in addition to
those characters.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>The <a class="reference internal" href="#shlex.shlex.punctuation_chars" title="shlex.shlex.punctuation_chars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">punctuation_chars</span></code></a> attribute was made compatible with the
<a class="reference internal" href="#shlex.shlex.whitespace_split" title="shlex.shlex.whitespace_split"><code class="xref py py-attr docutils literal notranslate"><span class="pre">whitespace_split</span></code></a> attribute.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.infile">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">infile</code><a class="headerlink" href="#shlex.shlex.infile" title="정의 주소">¶</a></dt>
<dd><p>The name of the current input file, as initially set at class instantiation time
or stacked by later source requests.  It may be useful to examine this when
constructing error messages.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.instream">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">instream</code><a class="headerlink" href="#shlex.shlex.instream" title="정의 주소">¶</a></dt>
<dd><p>The input stream from which this <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> instance is reading
characters.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.source">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">source</code><a class="headerlink" href="#shlex.shlex.source" title="정의 주소">¶</a></dt>
<dd><p>This attribute is <code class="docutils literal notranslate"><span class="pre">None</span></code> by default.  If you assign a string to it, that
string will be recognized as a lexical-level inclusion request similar to the
<code class="docutils literal notranslate"><span class="pre">source</span></code> keyword in various shells.  That is, the immediately following token
will be opened as a filename and input will be taken from that stream until
EOF, at which point the <a class="reference internal" href="io.html#io.IOBase.close" title="io.IOBase.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> method of that stream will be
called and the input source will again become the original input stream.  Source
requests may be stacked any number of levels deep.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.debug">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">debug</code><a class="headerlink" href="#shlex.shlex.debug" title="정의 주소">¶</a></dt>
<dd><p>If this attribute is numeric and <code class="docutils literal notranslate"><span class="pre">1</span></code> or more, a <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a>
instance will print verbose progress output on its behavior.  If you need
to use this, you can read the module source code to learn the details.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.lineno">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">lineno</code><a class="headerlink" href="#shlex.shlex.lineno" title="정의 주소">¶</a></dt>
<dd><p>Source line number (count of newlines seen so far plus one).</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.token">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">token</code><a class="headerlink" href="#shlex.shlex.token" title="정의 주소">¶</a></dt>
<dd><p>The token buffer.  It may be useful to examine this when catching exceptions.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.eof">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">eof</code><a class="headerlink" href="#shlex.shlex.eof" title="정의 주소">¶</a></dt>
<dd><p>Token used to determine end of file. This will be set to the empty string
(<code class="docutils literal notranslate"><span class="pre">''</span></code>), in non-POSIX mode, and to <code class="docutils literal notranslate"><span class="pre">None</span></code> in POSIX mode.</p>
</dd></dl>

<dl class="attribute">
<dt id="shlex.shlex.punctuation_chars">
<code class="sig-prename descclassname">shlex.</code><code class="sig-name descname">punctuation_chars</code><a class="headerlink" href="#shlex.shlex.punctuation_chars" title="정의 주소">¶</a></dt>
<dd><p>A read-only property. Characters that will be considered punctuation. Runs of
punctuation characters will be returned as a single token. However, note that no
semantic validity checking will be performed: for example, '&gt;&gt;&gt;' could be
returned as a token, even though it may not be recognised as such by shells.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="parsing-rules">
<span id="shlex-parsing-rules"></span><h2>Parsing Rules<a class="headerlink" href="#parsing-rules" title="제목 주소">¶</a></h2>
<p>When operating in non-POSIX mode, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> will try to obey to the
following rules.</p>
<ul class="simple">
<li><p>Quote characters are not recognized within words (<code class="docutils literal notranslate"><span class="pre">Do&quot;Not&quot;Separate</span></code> is
parsed as the single word <code class="docutils literal notranslate"><span class="pre">Do&quot;Not&quot;Separate</span></code>);</p></li>
<li><p>Escape characters are not recognized;</p></li>
<li><p>Enclosing characters in quotes preserve the literal value of all characters
within the quotes;</p></li>
<li><p>Closing quotes separate words (<code class="docutils literal notranslate"><span class="pre">&quot;Do&quot;Separate</span></code> is parsed as <code class="docutils literal notranslate"><span class="pre">&quot;Do&quot;</span></code> and
<code class="docutils literal notranslate"><span class="pre">Separate</span></code>);</p></li>
<li><p>If <a class="reference internal" href="#shlex.shlex.whitespace_split" title="shlex.shlex.whitespace_split"><code class="xref py py-attr docutils literal notranslate"><span class="pre">whitespace_split</span></code></a> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, any character not
declared to be a word character, whitespace, or a quote will be returned as
a single-character token. If it is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> will only
split words in whitespaces;</p></li>
<li><p>EOF is signaled with an empty string (<code class="docutils literal notranslate"><span class="pre">''</span></code>);</p></li>
<li><p>It's not possible to parse empty strings, even if quoted.</p></li>
</ul>
<p>When operating in POSIX mode, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> will try to obey to the
following parsing rules.</p>
<ul class="simple">
<li><p>Quotes are stripped out, and do not separate words (<code class="docutils literal notranslate"><span class="pre">&quot;Do&quot;Not&quot;Separate&quot;</span></code> is
parsed as the single word <code class="docutils literal notranslate"><span class="pre">DoNotSeparate</span></code>);</p></li>
<li><p>Non-quoted escape characters (e.g. <code class="docutils literal notranslate"><span class="pre">'\'</span></code>) preserve the literal value of the
next character that follows;</p></li>
<li><p>Enclosing characters in quotes which are not part of
<a class="reference internal" href="#shlex.shlex.escapedquotes" title="shlex.shlex.escapedquotes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">escapedquotes</span></code></a> (e.g. <code class="docutils literal notranslate"><span class="pre">&quot;'&quot;</span></code>) preserve the literal value
of all characters within the quotes;</p></li>
<li><p>Enclosing characters in quotes which are part of
<a class="reference internal" href="#shlex.shlex.escapedquotes" title="shlex.shlex.escapedquotes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">escapedquotes</span></code></a> (e.g. <code class="docutils literal notranslate"><span class="pre">'&quot;'</span></code>) preserves the literal value
of all characters within the quotes, with the exception of the characters
mentioned in <a class="reference internal" href="#shlex.shlex.escape" title="shlex.shlex.escape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">escape</span></code></a>.  The escape characters retain its
special meaning only when followed by the quote in use, or the escape
character itself. Otherwise the escape character will be considered a
normal character.</p></li>
<li><p>EOF is signaled with a <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> value;</p></li>
<li><p>Quoted empty strings (<code class="docutils literal notranslate"><span class="pre">''</span></code>) are allowed.</p></li>
</ul>
</div>
<div class="section" id="improved-compatibility-with-shells">
<span id="improved-shell-compatibility"></span><h2>셸과의 호환성 향상<a class="headerlink" href="#improved-compatibility-with-shells" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
<p>The <a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a> class provides compatibility with the parsing performed by
common Unix shells like <code class="docutils literal notranslate"><span class="pre">bash</span></code>, <code class="docutils literal notranslate"><span class="pre">dash</span></code>, and <code class="docutils literal notranslate"><span class="pre">sh</span></code>.  To take advantage of
this compatibility, specify the <code class="docutils literal notranslate"><span class="pre">punctuation_chars</span></code> argument in the
constructor.  This defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>, which preserves pre-3.6 behaviour.
However, if it is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, then parsing of the characters <code class="docutils literal notranslate"><span class="pre">();&lt;&gt;|&amp;</span></code>
is changed: any run of these characters is returned as a single token.  While
this is short of a full parser for shells (which would be out of scope for the
standard library, given the multiplicity of shells out there), it does allow
you to perform processing of command lines more easily than you could
otherwise.  To illustrate, you can see the difference in the following snippet:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="go"> &gt;&gt;&gt; import shlex</span>
<span class="go"> &gt;&gt;&gt; text = &quot;a &amp;&amp; b; c &amp;&amp; d || e; f &gt;&#39;abc&#39;; (def \&quot;ghi\&quot;)&quot;</span>
<span class="go"> &gt;&gt;&gt; s = shlex.shlex(text, posix=True)</span>
<span class="go"> &gt;&gt;&gt; s.whitespace_split = True</span>
<span class="go"> &gt;&gt;&gt; list(s)</span>
<span class="go"> [&#39;a&#39;, &#39;&amp;&amp;&#39;, &#39;b;&#39;, &#39;c&#39;, &#39;&amp;&amp;&#39;, &#39;d&#39;, &#39;||&#39;, &#39;e;&#39;, &#39;f&#39;, &#39;&gt;abc;&#39;, &#39;(def&#39;, &#39;ghi)&#39;]</span>
<span class="go"> &gt;&gt;&gt; s = shlex.shlex(text, posix=True, punctuation_chars=True)</span>
<span class="go"> &gt;&gt;&gt; s.whitespace_split = True</span>
<span class="go"> &gt;&gt;&gt; list(s)</span>
<span class="go"> [&#39;a&#39;, &#39;&amp;&amp;&#39;, &#39;b&#39;, &#39;;&#39;, &#39;c&#39;, &#39;&amp;&amp;&#39;, &#39;d&#39;, &#39;||&#39;, &#39;e&#39;, &#39;;&#39;, &#39;f&#39;, &#39;&gt;&#39;, &#39;abc&#39;, &#39;;&#39;,</span>
<span class="go"> &#39;(&#39;, &#39;def&#39;, &#39;ghi&#39;, &#39;)&#39;]</span>
</pre></div>
</div>
<p>Of course, tokens will be returned which are not valid for shells, and you'll
need to implement your own error checks on the returned tokens.</p>
<p>Instead of passing <code class="docutils literal notranslate"><span class="pre">True</span></code> as the value for the punctuation_chars parameter,
you can pass a string with specific characters, which will be used to determine
which characters constitute punctuation. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">shlex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">shlex</span><span class="o">.</span><span class="n">shlex</span><span class="p">(</span><span class="s2">&quot;a &amp;&amp; b || c&quot;</span><span class="p">,</span> <span class="n">punctuation_chars</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;&amp;&#39;, &#39;&amp;&#39;, &#39;b&#39;, &#39;||&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>When <code class="docutils literal notranslate"><span class="pre">punctuation_chars</span></code> is specified, the <a class="reference internal" href="#shlex.shlex.wordchars" title="shlex.shlex.wordchars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">wordchars</span></code></a>
attribute is augmented with the characters <code class="docutils literal notranslate"><span class="pre">~-./*?=</span></code>.  That is because these
characters can appear in file names (including wildcards) and command-line
arguments (e.g. <code class="docutils literal notranslate"><span class="pre">--color=auto</span></code>). Hence:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">shlex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">shlex</span><span class="o">.</span><span class="n">shlex</span><span class="p">(</span><span class="s1">&#39;~/a &amp;&amp; b-c --color=auto || d *.py?&#39;</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">punctuation_chars</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;~/a&#39;, &#39;&amp;&amp;&#39;, &#39;b-c&#39;, &#39;--color=auto&#39;, &#39;||&#39;, &#39;d&#39;, &#39;*.py?&#39;]</span>
</pre></div>
</div>
<p>However, to match the shell as closely as possible, it is recommended to
always use <code class="docutils literal notranslate"><span class="pre">posix</span></code> and <a class="reference internal" href="#shlex.shlex.whitespace_split" title="shlex.shlex.whitespace_split"><code class="xref py py-attr docutils literal notranslate"><span class="pre">whitespace_split</span></code></a> when using
<a class="reference internal" href="#shlex.shlex.punctuation_chars" title="shlex.shlex.punctuation_chars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">punctuation_chars</span></code></a>, which will negate
<a class="reference internal" href="#shlex.shlex.wordchars" title="shlex.shlex.wordchars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">wordchars</span></code></a> entirely.</p>
</div>
<p>For best effect, <code class="docutils literal notranslate"><span class="pre">punctuation_chars</span></code> should be set in conjunction with
<code class="docutils literal notranslate"><span class="pre">posix=True</span></code>. (Note that <code class="docutils literal notranslate"><span class="pre">posix=False</span></code> is the default for
<a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code class="xref py py-class docutils literal notranslate"><span class="pre">shlex</span></code></a>.)</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">shlex</span></code> --- 간단한 어휘 분석</a><ul>
<li><a class="reference internal" href="#shlex-objects">shlex 객체</a></li>
<li><a class="reference internal" href="#parsing-rules">Parsing Rules</a></li>
<li><a class="reference internal" href="#improved-compatibility-with-shells">셸과의 호환성 향상</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="cmd.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmd</span></code> --- 줄 지향 명령 인터프리터 지원</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="tk.html"
                        title="다음 장">Tk를 사용한 그래픽 사용자 인터페이스</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="tk.html" title="Tk를 사용한 그래픽 사용자 인터페이스"
             >다음</a> |</li>
        <li class="right" >
          <a href="cmd.html" title="cmd --- 줄 지향 명령 인터프리터 지원"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="frameworks.html" >프로그램 프레임워크</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>