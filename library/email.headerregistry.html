
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>email.headerregistry: 사용자 정의 헤더 객체 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="email.contentmanager: MIME 콘텐츠 관리" href="email.contentmanager.html" />
    <link rel="prev" title="email.errors: 예외와 결함 클래스" href="email.errors.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/email.headerregistry.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="email.contentmanager.html" title="email.contentmanager: MIME 콘텐츠 관리"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="email.errors.html" title="email.errors: 예외와 결함 클래스"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >인터넷 데이터 처리</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 전자 메일과 MIME 처리 패키지</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-email.headerregistry">
<span id="email-headerregistry-custom-header-objects"></span><h1><a class="reference internal" href="#module-email.headerregistry" title="email.headerregistry: Automatic Parsing of headers based on the field name"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.headerregistry</span></code></a>: 사용자 정의 헤더 객체<a class="headerlink" href="#module-email.headerregistry" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/email/headerregistry.py">Lib/email/headerregistry.py</a></p>
<hr class="docutils" />
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가: </span><a class="footnote-reference brackets" href="#id2" id="id1">1</a></p>
</div>
<p>헤더는 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>의 사용자 정의된 서브 클래스로 표현됩니다. 주어진 헤더를 표현하는 데 사용되는 특정 클래스는 헤더가 만들어질 때 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a>의 <a class="reference internal" href="email.policy.html#email.policy.EmailPolicy.header_factory" title="email.policy.EmailPolicy.header_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">header_factory</span></code></a>에 의해 결정됩니다. 이 섹션에서는 <span class="target" id="index-30"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a> 호환 전자 우편 메시지를 처리하기 위해 email 패키지가 구현한 특정 <code class="docutils literal notranslate"><span class="pre">header_factory</span></code>에 관해 설명합니다. 다양한 헤더 유형에 대해 사용자 정의된 헤더 객체를 제공할 뿐만 아니라, 응용 프로그램에서 고유한 사용자 정의 헤더 유형을 추가할 수 있는 확장 메커니즘을 제공합니다.</p>
<p><a class="reference internal" href="email.policy.html#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-data docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a>에서 파생된 정책 객체를 사용할 때, 모든 헤더는 <a class="reference internal" href="#email.headerregistry.HeaderRegistry" title="email.headerregistry.HeaderRegistry"><code class="xref py py-class docutils literal notranslate"><span class="pre">HeaderRegistry</span></code></a>가 생성하며 마지막 베이스 클래스로 <a class="reference internal" href="#email.headerregistry.BaseHeader" title="email.headerregistry.BaseHeader"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHeader</span></code></a>를 갖습니다. 각 헤더 클래스에는 헤더 유형에 따라 결정되는 추가 베이스 클래스가 있습니다. 예를 들어, 많은 헤더에는 다른 베이스 클래스로 <a class="reference internal" href="#email.headerregistry.UnstructuredHeader" title="email.headerregistry.UnstructuredHeader"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnstructuredHeader</span></code></a> 클래스를 갖습니다. 헤더의 특수화된 두 번째 클래스는 <a class="reference internal" href="#email.headerregistry.HeaderRegistry" title="email.headerregistry.HeaderRegistry"><code class="xref py py-class docutils literal notranslate"><span class="pre">HeaderRegistry</span></code></a>에 저장된 검색 테이블을 사용하여 헤더의 이름으로 결정됩니다. 이 모든 것은 일반적인 응용 프로그램에 대해 투명하게 관리되지만, 더욱 복잡한 응용 프로그램에서 사용할 수 있도록 기본 동작을 수정하기 위한 인터페이스가 제공됩니다.</p>
<p>아래 섹션은 먼저 헤더 베이스 클래스와 그들의 어트리뷰트를, 그다음으로 <a class="reference internal" href="#email.headerregistry.HeaderRegistry" title="email.headerregistry.HeaderRegistry"><code class="xref py py-class docutils literal notranslate"><span class="pre">HeaderRegistry</span></code></a>의 동작을 수정하기 위한 API를, 그리고 마지막으로 구조화된 헤더에서 구문 분석된 데이터를 나타내는 데 사용되는 지원 클래스에를 설명합니다.</p>
<dl class="class">
<dt id="email.headerregistry.BaseHeader">
<em class="property">class </em><code class="sig-prename descclassname">email.headerregistry.</code><code class="sig-name descname">BaseHeader</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.headerregistry.BaseHeader" title="정의 주소">¶</a></dt>
<dd><p><em>name</em>과 <em>value</em>는 <a class="reference internal" href="email.policy.html#email.policy.EmailPolicy.header_factory" title="email.policy.EmailPolicy.header_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">header_factory</span></code></a> 호출에서 <code class="docutils literal notranslate"><span class="pre">BaseHeader</span></code>로 전달됩니다. 헤더 객체의 문자열 값은 유니코드로 완전히 디코딩된 <em>value</em>입니다.</p>
<p>이 베이스 클래스는 다음과 같은 읽기 전용 프로퍼티를 정의합니다:</p>
<dl class="attribute">
<dt id="email.headerregistry.BaseHeader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#email.headerregistry.BaseHeader.name" title="정의 주소">¶</a></dt>
<dd><p>헤더 이름(':' 앞의 필드 부분). 이것은 정확히 <a class="reference internal" href="email.policy.html#email.policy.EmailPolicy.header_factory" title="email.policy.EmailPolicy.header_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">header_factory</span></code></a> 호출에 전달된 <em>name</em>에 대한 값입니다; 즉, 대소 문자가 유지됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.headerregistry.BaseHeader.defects">
<code class="sig-name descname">defects</code><a class="headerlink" href="#email.headerregistry.BaseHeader.defects" title="정의 주소">¶</a></dt>
<dd><p>구문 분석 중 발견된 RFC 준수 문제를 보고하는 <code class="xref py py-exc docutils literal notranslate"><span class="pre">HeaderDefect</span></code> 인스턴스 튜플. email 패키지는 규정 준수 문제 감지에 대해 완전해지려고 합니다. 보고될 수 있는 결함 유형에 대한 설명은 <a class="reference internal" href="email.errors.html#module-email.errors" title="email.errors: The exception classes used by the email package."><code class="xref py py-mod docutils literal notranslate"><span class="pre">errors</span></code></a> 모듈을 참조하십시오.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.headerregistry.BaseHeader.max_count">
<code class="sig-name descname">max_count</code><a class="headerlink" href="#email.headerregistry.BaseHeader.max_count" title="정의 주소">¶</a></dt>
<dd><p>같은 <code class="docutils literal notranslate"><span class="pre">name</span></code>을 가질 수 있는 이 유형의 최대 헤더 수. <code class="docutils literal notranslate"><span class="pre">None</span></code> 값은 무제한을 의미합니다. 이 어트리뷰트의 <code class="docutils literal notranslate"><span class="pre">BaseHeader</span></code> 값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다; 특수화된 헤더 클래스가 필요할 때 이 값을 재정의할 것으로 기대됩니다.</p>
</dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">BaseHeader</span></code>는 또한 email 라이브러리 코드에 의해 호출되고 일반적으로 응용 프로그램이 호출해서는 안 되는 다음 메서드를 제공합니다:</p>
<dl class="method">
<dt id="email.headerregistry.BaseHeader.fold">
<code class="sig-name descname">fold</code><span class="sig-paren">(</span><em class="sig-param">*</em>, <em class="sig-param">policy</em><span class="sig-paren">)</span><a class="headerlink" href="#email.headerregistry.BaseHeader.fold" title="정의 주소">¶</a></dt>
<dd><p><em>policy</em>에 따라 헤더를 올바르게 접는 데 필요한 <a class="reference internal" href="email.policy.html#email.policy.Policy.linesep" title="email.policy.Policy.linesep"><code class="xref py py-attr docutils literal notranslate"><span class="pre">linesep</span></code></a> 문자를 포함하는 문자열을 반환합니다. 헤더는 임의의 바이너리 데이터를 포함할 수 없어서, <code class="docutils literal notranslate"><span class="pre">8bit</span></code>의 <a class="reference internal" href="email.policy.html#email.policy.Policy.cte_type" title="email.policy.Policy.cte_type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cte_type</span></code></a>은 마치 <code class="docutils literal notranslate"><span class="pre">7bit</span></code>인 것처럼 처리됩니다. <a class="reference internal" href="email.policy.html#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a>이 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, 비 ASCII 데이터는 <span class="target" id="index-31"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html"><strong>RFC 2047</strong></a>로 인코딩됩니다.</p>
</dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">BaseHeader</span></code> 자체는 헤더 객체를 만드는 데 사용할 수 없습니다. 헤더 객체를 생성하기 위해 각 특수화된 헤더가 협력하는 프로토콜을 정의합니다. 특히 <code class="docutils literal notranslate"><span class="pre">BaseHeader</span></code>는 특수화된 클래스가 <code class="docutils literal notranslate"><span class="pre">parse</span></code>라는 <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a>를 제공할 것을 요구합니다. 이 메서드는 다음과 같이 호출됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">parse</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">kwds</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">kwds</span></code>는 하나의 미리 초기화된 키 <code class="docutils literal notranslate"><span class="pre">defects</span></code>를 포함하는 딕셔너리입니다. <code class="docutils literal notranslate"><span class="pre">defects</span></code>는 빈 리스트입니다. parse 메서드는 감지된 결함을 이 리스트에 추가해야 합니다. 반환될 때, <code class="docutils literal notranslate"><span class="pre">kwds</span></code> 딕셔너리는 <em>반드시</em> 적어도 키 <code class="docutils literal notranslate"><span class="pre">decoded</span></code>와 <code class="docutils literal notranslate"><span class="pre">defects</span></code>에 대한 값을 포함해야 합니다. <code class="docutils literal notranslate"><span class="pre">decoded</span></code>는 헤더의 문자열 값이어야 합니다 (즉, 유니코드로 완전히 디코딩된 헤더 값). parse 메서드는 <em>string</em>이 콘텐츠 전송 인코딩된 파트를 포함할 수 있다고 가정해야 하지만, 인코딩되지 않은 헤더 값을 구문 분석할 수 있도록 모든 유효한 유니코드 문자도 올바르게 처리해야 합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">BaseHeader</span></code>의 <code class="docutils literal notranslate"><span class="pre">__new__</span></code>는 헤더 인스턴스를 만들고, <code class="docutils literal notranslate"><span class="pre">init</span></code> 메서드를 호출합니다. 특수화된 클래스가 <code class="docutils literal notranslate"><span class="pre">BaseHeader</span></code> 자체에서 제공하는 것 이상의 추가 어트리뷰트를 설정하려면 <code class="docutils literal notranslate"><span class="pre">init</span></code> 메서드 만 제공하면 됩니다. 이러한 <code class="docutils literal notranslate"><span class="pre">init</span></code> 메서드는 다음과 같아야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_myattr</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;myattr&#39;</span><span class="p">)</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</pre></div>
</div>
<p>즉, 특수화된 클래스가 <code class="docutils literal notranslate"><span class="pre">kwds</span></code> 딕셔너리에 추가하는 것은 제거해야 하고 처리해야 하며, <code class="docutils literal notranslate"><span class="pre">kw</span></code>(및 <code class="docutils literal notranslate"><span class="pre">args</span></code>)의 나머지 내용은 <code class="docutils literal notranslate"><span class="pre">BaseHeader</span></code> <code class="docutils literal notranslate"><span class="pre">init</span></code> 메서드로 전달됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="email.headerregistry.UnstructuredHeader">
<em class="property">class </em><code class="sig-prename descclassname">email.headerregistry.</code><code class="sig-name descname">UnstructuredHeader</code><a class="headerlink" href="#email.headerregistry.UnstructuredHeader" title="정의 주소">¶</a></dt>
<dd><p>&quot;구조화되지 않은&quot; 헤더는 <span class="target" id="index-32"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>의 기본 헤더 유형입니다. 지정된 문법이 없는 헤더는 구조화되지 않은 것으로 취급됩니다. 구조화되지 않은 헤더의 전형적인 예는 <em class="mailheader">Subject</em> 헤더입니다.</p>
<p><span class="target" id="index-33"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>에서, 구조화되지 않은 헤더는 ASCII 문자 집합에서 임의의 텍스트를 나열합니다. 그러나 <span class="target" id="index-34"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html"><strong>RFC 2047</strong></a>은 비 ASCII 텍스트를 헤더 값 내에서 ASCII 문자로 인코딩하기 위한 <span class="target" id="index-35"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a> 호환 메커니즘을 가지고 있습니다. 인코딩된 단어를 포함하는 <em>value</em>가 생성자에 전달되면, <code class="docutils literal notranslate"><span class="pre">UnstructuredHeader</span></code> 구문 분석기는 구조화되지 않은 텍스트의 <span class="target" id="index-36"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html"><strong>RFC 2047</strong></a> 규칙에 따라 인코딩된 단어를 유니코드로 변환합니다. 구문 분석기는 휴리스틱을 사용하여 특정 비 호환 인코딩된 단어를 디코딩하려고 시도합니다. 인코딩된 단어나 인코딩되지 않는 텍스트 내의 유효하지 않은 문자와 같은 문제에 대한 결함뿐만 아니라 이럴 때 결함을 등록합니다.</p>
<p>이 헤더 유형은 추가 어트리뷰트를 제공하지 않습니다.</p>
</dd></dl>

<dl class="class">
<dt id="email.headerregistry.DateHeader">
<em class="property">class </em><code class="sig-prename descclassname">email.headerregistry.</code><code class="sig-name descname">DateHeader</code><a class="headerlink" href="#email.headerregistry.DateHeader" title="정의 주소">¶</a></dt>
<dd><p><span class="target" id="index-37"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>는 전자 우편 헤더 내의 날짜에 대해 매우 구체적인 형식을 지정합니다. <code class="docutils literal notranslate"><span class="pre">DateHeader</span></code> 구문 분석기는 이 날짜 형식을 인식할 뿐만 아니라, &quot;야생&quot;에서 발견되는 다양한 변종 형식을 인식합니다.</p>
<p>이 헤더 유형은 다음과 같은 추가 어트리뷰트를 제공합니다:</p>
<dl class="attribute">
<dt id="email.headerregistry.DateHeader.datetime">
<code class="sig-name descname">datetime</code><a class="headerlink" href="#email.headerregistry.DateHeader.datetime" title="정의 주소">¶</a></dt>
<dd><p>헤더 값이 한 양식이나 다른 양식의 유효한 날짜로 인식될 수 있으면, 이 어트리뷰트는 해당 날짜를 나타내는 <a class="reference internal" href="datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a> 인스턴스가 포함됩니다. 입력 날짜의 시간대가 <code class="docutils literal notranslate"><span class="pre">-0000</span></code>으로 지정되면 (UTC이지만 소스 시간대에 대한 정보는 포함하지 않음을 나타냅니다), <a class="reference internal" href="#email.headerregistry.DateHeader.datetime" title="email.headerregistry.DateHeader.datetime"><code class="xref py py-attr docutils literal notranslate"><span class="pre">datetime</span></code></a>은 나이브 <a class="reference internal" href="datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a>이 됩니다. 특정 시간대 오프셋이 발견되면 (<cite>+0000</cite>을 포함합니다), <a class="reference internal" href="#email.headerregistry.DateHeader.datetime" title="email.headerregistry.DateHeader.datetime"><code class="xref py py-attr docutils literal notranslate"><span class="pre">datetime</span></code></a>에는 <a class="reference internal" href="datetime.html#datetime.timezone" title="datetime.timezone"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.timezone</span></code></a>을 사용하여 시간대 오프셋을 기록하는 어웨어 <code class="docutils literal notranslate"><span class="pre">datetime</span></code>이 포함됩니다.</p>
</dd></dl>

<p>헤더의 <code class="docutils literal notranslate"><span class="pre">decoded</span></code> 값은 <span class="target" id="index-38"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a> 규칙에 따라 <code class="docutils literal notranslate"><span class="pre">datetime</span></code>을 포매팅해서 결정됩니다; 즉, 다음과 같이 설정됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">email</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">format_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">DateHeader</span></code>를 만들 때, <em>value</em>는 <a class="reference internal" href="datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a> 인스턴스일 수 있습니다. 이것은, 예를 들어, 다음 코드가 유효하고 기대하는 것을 수행함을 뜻합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2011</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>
</pre></div>
</div>
<p>이것은 나이브 <code class="docutils literal notranslate"><span class="pre">datetime</span></code>이므로 UTC 타임스탬프로 해석되며 결괏값의 시간대는 <code class="docutils literal notranslate"><span class="pre">-0000</span></code>입니다. <a class="reference internal" href="email.utils.html#module-email.utils" title="email.utils: Miscellaneous email package utilities."><code class="xref py py-mod docutils literal notranslate"><span class="pre">utils</span></code></a> 모듈의 <a class="reference internal" href="email.utils.html#email.utils.localtime" title="email.utils.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">localtime()</span></code></a> 함수를 사용하는 것이 훨씬 더 유용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">localtime</span><span class="p">()</span>
</pre></div>
</div>
<p>이 예에서는 현재 시간대 오프셋을 사용하여 날짜 헤더를 현재 시간과 날짜로 설정합니다.</p>
</dd></dl>

<dl class="class">
<dt id="email.headerregistry.AddressHeader">
<em class="property">class </em><code class="sig-prename descclassname">email.headerregistry.</code><code class="sig-name descname">AddressHeader</code><a class="headerlink" href="#email.headerregistry.AddressHeader" title="정의 주소">¶</a></dt>
<dd><p>주소 헤더는 가장 복잡한 구조화된 헤더 유형 중 하나입니다. <code class="docutils literal notranslate"><span class="pre">AddressHeader</span></code> 클래스는 모든 주소 헤더에 대한 범용 인터페이스를 제공합니다.</p>
<p>이 헤더 유형은 다음과 같은 추가 어트리뷰트를 제공합니다:</p>
<dl class="attribute">
<dt id="email.headerregistry.AddressHeader.groups">
<code class="sig-name descname">groups</code><a class="headerlink" href="#email.headerregistry.AddressHeader.groups" title="정의 주소">¶</a></dt>
<dd><p>헤더 값에서 찾은 주소와 그룹을 인코딩하는 <a class="reference internal" href="#email.headerregistry.Group" title="email.headerregistry.Group"><code class="xref py py-class docutils literal notranslate"><span class="pre">Group</span></code></a> 객체의 튜플. 그룹 일부가 아닌 주소는 이 목록에서 <a class="reference internal" href="#email.headerregistry.Group.display_name" title="email.headerregistry.Group.display_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">display_name</span></code></a>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>인 단일 주소 <code class="docutils literal notranslate"><span class="pre">Groups</span></code>로 표현됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.headerregistry.AddressHeader.addresses">
<code class="sig-name descname">addresses</code><a class="headerlink" href="#email.headerregistry.AddressHeader.addresses" title="정의 주소">¶</a></dt>
<dd><p>헤더 값의 모든 개별 주소를 인코딩하는 <a class="reference internal" href="#email.headerregistry.Address" title="email.headerregistry.Address"><code class="xref py py-class docutils literal notranslate"><span class="pre">Address</span></code></a> 객체의 튜플. 헤더 값이 그룹을 포함하면, 그룹의 개별 주소가 값에서 그룹이 발생하는 지점에서 목록에 포함됩니다 (즉, 주소 목록은 1차원 목록으로 &quot;평평하게&quot; 만들어집니다).</p>
</dd></dl>

<p>헤더의 <code class="docutils literal notranslate"><span class="pre">decoded</span></code> 값에서는 모든 인코딩된 단어가 유니코드로 디코딩됩니다. <a class="reference internal" href="codecs.html#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-class docutils literal notranslate"><span class="pre">idna</span></code></a>로 인코딩된 도메인 이름도 유니코드로 디코딩됩니다. <code class="docutils literal notranslate"><span class="pre">decoded</span></code> 값은 <code class="docutils literal notranslate"><span class="pre">groups</span></code> 어트리뷰트 요소의 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 값을 <code class="docutils literal notranslate"><span class="pre">',</span> <span class="pre">'</span></code>로 <a class="reference internal" href="stdtypes.html#str.join" title="str.join"><code class="xref py py-attr docutils literal notranslate"><span class="pre">join</span></code></a>하여 설정됩니다.</p>
<p><a class="reference internal" href="#email.headerregistry.Address" title="email.headerregistry.Address"><code class="xref py py-class docutils literal notranslate"><span class="pre">Address</span></code></a>와 <a class="reference internal" href="#email.headerregistry.Group" title="email.headerregistry.Group"><code class="xref py py-class docutils literal notranslate"><span class="pre">Group</span></code></a> 객체의 목록을 임의 조합한 목록을 주소 헤더의 값을 설정하는 데 사용할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">display_name</span></code>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>인 <code class="docutils literal notranslate"><span class="pre">Group</span></code> 객체는 단일 주소로 해석되므로, 소스 헤더의 <code class="docutils literal notranslate"><span class="pre">groups</span></code> 어트리뷰트에서 얻은 목록을 사용하여 주소 목록을 그룹과 함께 그대로 복사할 수 있습니다.</p>
</dd></dl>

<dl class="class">
<dt id="email.headerregistry.SingleAddressHeader">
<em class="property">class </em><code class="sig-prename descclassname">email.headerregistry.</code><code class="sig-name descname">SingleAddressHeader</code><a class="headerlink" href="#email.headerregistry.SingleAddressHeader" title="정의 주소">¶</a></dt>
<dd><p>하나의 추가 어트리뷰트를 추가하는 <a class="reference internal" href="#email.headerregistry.AddressHeader" title="email.headerregistry.AddressHeader"><code class="xref py py-class docutils literal notranslate"><span class="pre">AddressHeader</span></code></a>의 서브 클래스:</p>
<dl class="attribute">
<dt id="email.headerregistry.SingleAddressHeader.address">
<code class="sig-name descname">address</code><a class="headerlink" href="#email.headerregistry.SingleAddressHeader.address" title="정의 주소">¶</a></dt>
<dd><p>헤더 값으로 인코딩된 단일 주소. 헤더 값에 실제로 둘 이상의 주소가 포함될 때 (기본 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a>에서 RFC 위반입니다), 이 어트리뷰트에 액세스하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
</dd></dl>

</dd></dl>

<p>위의 많은 클래스에는 <code class="docutils literal notranslate"><span class="pre">Unique</span></code> 변형도 있습니다 (예를 들어, <code class="docutils literal notranslate"><span class="pre">UniqueUnstructuredHeader</span></code>). 유일한 차이점은 <code class="docutils literal notranslate"><span class="pre">Unique</span></code> 변형에서 <a class="reference internal" href="#email.headerregistry.BaseHeader.max_count" title="email.headerregistry.BaseHeader.max_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_count</span></code></a>가 1로 설정되어 있다는 것입니다.</p>
<dl class="class">
<dt id="email.headerregistry.MIMEVersionHeader">
<em class="property">class </em><code class="sig-prename descclassname">email.headerregistry.</code><code class="sig-name descname">MIMEVersionHeader</code><a class="headerlink" href="#email.headerregistry.MIMEVersionHeader" title="정의 주소">¶</a></dt>
<dd><p><em class="mailheader">MIME-Version</em> 헤더에는 실제로 하나의 유효한 값만 있으며, 이는 <code class="docutils literal notranslate"><span class="pre">1.0</span></code>입니다. 미래에 안전하기 위해, 이 헤더 클래스는 다른 유효한 버전 번호를 지원합니다. 버전 번호가 <span class="target" id="index-39"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a>에 따라 유효한 값을 가지면, 헤더 객체는 다음 어트리뷰트에 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아닌 값을 갖습니다:</p>
<dl class="attribute">
<dt id="email.headerregistry.MIMEVersionHeader.version">
<code class="sig-name descname">version</code><a class="headerlink" href="#email.headerregistry.MIMEVersionHeader.version" title="정의 주소">¶</a></dt>
<dd><p>공백 및/또는 주석이 제거된 문자열 버전 번호.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.headerregistry.MIMEVersionHeader.major">
<code class="sig-name descname">major</code><a class="headerlink" href="#email.headerregistry.MIMEVersionHeader.major" title="정의 주소">¶</a></dt>
<dd><p>정수 주 버전 번호</p>
</dd></dl>

<dl class="attribute">
<dt id="email.headerregistry.MIMEVersionHeader.minor">
<code class="sig-name descname">minor</code><a class="headerlink" href="#email.headerregistry.MIMEVersionHeader.minor" title="정의 주소">¶</a></dt>
<dd><p>정수 부 버전 번호</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="email.headerregistry.ParameterizedMIMEHeader">
<em class="property">class </em><code class="sig-prename descclassname">email.headerregistry.</code><code class="sig-name descname">ParameterizedMIMEHeader</code><a class="headerlink" href="#email.headerregistry.ParameterizedMIMEHeader" title="정의 주소">¶</a></dt>
<dd><p>MIME 헤더는 모두 접두사 'Content-'로 시작합니다. 각 특정 헤더에는 해당 헤더의 클래스에 설명된 특정 값이 있습니다. 일부는 공통 형식을 가진 보조 파라미터 목록을 취할 수도 있습니다. 이 클래스는 파라미터를 취하는 모든 MIME 헤더의 베이스로 사용됩니다.</p>
<dl class="attribute">
<dt id="email.headerregistry.ParameterizedMIMEHeader.params">
<code class="sig-name descname">params</code><a class="headerlink" href="#email.headerregistry.ParameterizedMIMEHeader.params" title="정의 주소">¶</a></dt>
<dd><p>파라미터 이름을 파라미터값으로 매핑하는 딕셔너리.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="email.headerregistry.ContentTypeHeader">
<em class="property">class </em><code class="sig-prename descclassname">email.headerregistry.</code><code class="sig-name descname">ContentTypeHeader</code><a class="headerlink" href="#email.headerregistry.ContentTypeHeader" title="정의 주소">¶</a></dt>
<dd><p><em class="mailheader">Content-Type</em> 헤더를 처리하는 <a class="reference internal" href="#email.headerregistry.ParameterizedMIMEHeader" title="email.headerregistry.ParameterizedMIMEHeader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParameterizedMIMEHeader</span></code></a> 클래스.</p>
<dl class="attribute">
<dt id="email.headerregistry.ContentTypeHeader.content_type">
<code class="sig-name descname">content_type</code><a class="headerlink" href="#email.headerregistry.ContentTypeHeader.content_type" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">maintype/subtype</span></code> 형식의 콘텐츠 유형 문자열.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.headerregistry.ContentTypeHeader.maintype">
<code class="sig-name descname">maintype</code><a class="headerlink" href="#email.headerregistry.ContentTypeHeader.maintype" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="email.headerregistry.ContentTypeHeader.subtype">
<code class="sig-name descname">subtype</code><a class="headerlink" href="#email.headerregistry.ContentTypeHeader.subtype" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="email.headerregistry.ContentDispositionHeader">
<em class="property">class </em><code class="sig-prename descclassname">email.headerregistry.</code><code class="sig-name descname">ContentDispositionHeader</code><a class="headerlink" href="#email.headerregistry.ContentDispositionHeader" title="정의 주소">¶</a></dt>
<dd><p><em class="mailheader">Content-Disposition</em> 헤더를 처리하는 <a class="reference internal" href="#email.headerregistry.ParameterizedMIMEHeader" title="email.headerregistry.ParameterizedMIMEHeader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParameterizedMIMEHeader</span></code></a> 클래스.</p>
<dl class="attribute">
<dt id="email.headerregistry.ContentDispositionHeader.content_disposition">
<code class="sig-name descname">content_disposition</code><a class="headerlink" href="#email.headerregistry.ContentDispositionHeader.content_disposition" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">inline</span></code>과 <code class="docutils literal notranslate"><span class="pre">attachment</span></code>가 일반적으로 사용되는 유일하게 유효한 값입니다.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="email.headerregistry.ContentTransferEncoding">
<em class="property">class </em><code class="sig-prename descclassname">email.headerregistry.</code><code class="sig-name descname">ContentTransferEncoding</code><a class="headerlink" href="#email.headerregistry.ContentTransferEncoding" title="정의 주소">¶</a></dt>
<dd><p><em class="mailheader">Content-Transfer-Encoding</em> 헤더를 처리합니다.</p>
<dl class="attribute">
<dt id="email.headerregistry.ContentTransferEncoding.cte">
<code class="sig-name descname">cte</code><a class="headerlink" href="#email.headerregistry.ContentTransferEncoding.cte" title="정의 주소">¶</a></dt>
<dd><p>유효한 값은 <code class="docutils literal notranslate"><span class="pre">7bit</span></code>, <code class="docutils literal notranslate"><span class="pre">8bit</span></code>, <code class="docutils literal notranslate"><span class="pre">base64</span></code> 및 <code class="docutils literal notranslate"><span class="pre">quoted-printable</span></code>입니다. 자세한 정보는 <span class="target" id="index-40"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a>를 참조하십시오.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="email.headerregistry.HeaderRegistry">
<em class="property">class </em><code class="sig-prename descclassname">email.headerregistry.</code><code class="sig-name descname">HeaderRegistry</code><span class="sig-paren">(</span><em class="sig-param">base_class=BaseHeader</em>, <em class="sig-param">default_class=UnstructuredHeader</em>, <em class="sig-param">use_default_map=True</em><span class="sig-paren">)</span><a class="headerlink" href="#email.headerregistry.HeaderRegistry" title="정의 주소">¶</a></dt>
<dd><p>기본적으로 <a class="reference internal" href="email.policy.html#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a>에서 사용되는 팩토리입니다. <code class="docutils literal notranslate"><span class="pre">HeaderRegistry</span></code>는 <em>base_class</em>와 보유한 등록소에서 꺼낸 특수화된 클래스를 사용하여 헤더 인스턴스를 동적으로 만드는 데 사용되는 클래스를 구축합니다. 지정된 헤더 이름이 등록소에 나타나지 않으면, <em>default_class</em>에 의해 지정된 클래스가 특수화된 클래스로 사용됩니다. <em>use_default_map</em>이 <code class="docutils literal notranslate"><span class="pre">True</span></code>(기본값)이면, 헤더 이름에서 클래스로의 표준 매핑이 초기화 중에 등록소에 복사됩니다. <em>base_class</em>는 항상 생성된 클래스의 <code class="docutils literal notranslate"><span class="pre">__bases__</span></code> 목록에서 마지막 클래스입니다.</p>
<p>기본 매핑은 다음과 같습니다:</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">subject</dt>
<dd class="field-odd"><p>UniqueUnstructuredHeader</p>
</dd>
<dt class="field-even">date</dt>
<dd class="field-even"><p>UniqueDateHeader</p>
</dd>
<dt class="field-odd">resent-date</dt>
<dd class="field-odd"><p>DateHeader</p>
</dd>
<dt class="field-even">orig-date</dt>
<dd class="field-even"><p>UniqueDateHeader</p>
</dd>
<dt class="field-odd">sender</dt>
<dd class="field-odd"><p>UniqueSingleAddressHeader</p>
</dd>
<dt class="field-even">resent-sender</dt>
<dd class="field-even"><p>SingleAddressHeader</p>
</dd>
<dt class="field-odd">to</dt>
<dd class="field-odd"><p>UniqueAddressHeader</p>
</dd>
<dt class="field-even">resent-to</dt>
<dd class="field-even"><p>AddressHeader</p>
</dd>
<dt class="field-odd">cc</dt>
<dd class="field-odd"><p>UniqueAddressHeader</p>
</dd>
<dt class="field-even">resent-cc</dt>
<dd class="field-even"><p>AddressHeader</p>
</dd>
<dt class="field-odd">bcc</dt>
<dd class="field-odd"><p>UniqueAddressHeader</p>
</dd>
<dt class="field-even">resent-bcc</dt>
<dd class="field-even"><p>AddressHeader</p>
</dd>
<dt class="field-odd">from</dt>
<dd class="field-odd"><p>UniqueAddressHeader</p>
</dd>
<dt class="field-even">resent-from</dt>
<dd class="field-even"><p>AddressHeader</p>
</dd>
<dt class="field-odd">reply-to</dt>
<dd class="field-odd"><p>UniqueAddressHeader</p>
</dd>
<dt class="field-even">mime-version</dt>
<dd class="field-even"><p>MIMEVersionHeader</p>
</dd>
<dt class="field-odd">content-type</dt>
<dd class="field-odd"><p>ContentTypeHeader</p>
</dd>
<dt class="field-even">content-disposition</dt>
<dd class="field-even"><p>ContentDispositionHeader</p>
</dd>
<dt class="field-odd">content-transfer-encoding</dt>
<dd class="field-odd"><p>ContentTransferEncodingHeader</p>
</dd>
<dt class="field-even">message-id</dt>
<dd class="field-even"><p>MessageIDHeader</p>
</dd>
</dl>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">HeaderRegistry</span></code>에는 다음과 같은 메서드가 있습니다:</p>
<dl class="method">
<dt id="email.headerregistry.HeaderRegistry.map_to_type">
<code class="sig-name descname">map_to_type</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">cls</em><span class="sig-paren">)</span><a class="headerlink" href="#email.headerregistry.HeaderRegistry.map_to_type" title="정의 주소">¶</a></dt>
<dd><p><em>name</em>은 매핑할 헤더의 이름입니다. 등록소에서 소문자로 변환됩니다. <em>cls</em>는 <em>name</em>과 일치하는 헤더를 인스턴스 화하는 데 사용되는 클래스를 만들기 위해 <em>base_class</em>와 함께 사용되는 특수 클래스입니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.headerregistry.HeaderRegistry.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.headerregistry.HeaderRegistry.__getitem__" title="정의 주소">¶</a></dt>
<dd><p><em>name</em> 헤더 생성을 처리할 클래스를 구성하고 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.headerregistry.HeaderRegistry.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.headerregistry.HeaderRegistry.__call__" title="정의 주소">¶</a></dt>
<dd><p>등록소에서 <em>name</em>과 연관된 특수화된 헤더를 꺼내고 (등록소에 <em>name</em>이 없으면 <em>default_class</em>를 사용해서), <em>base_class</em>와 결합하여 클래스를 생성하고, 생성된 클래스의 생성자를 같은 인자 목록을 전달해서 호출한 후, 마지막으로 이렇게 만들어진 클래스 인스턴스를 반환합니다.</p>
</dd></dl>

</dd></dl>

<p>다음 클래스는 구조화된 헤더에서 구문 분석된 데이터를 나타내는 데 사용되는 클래스이며 일반적으로 응용 프로그램에서 특정 헤더에 지정할 구조화된 값을 대입하는 데 사용할 수 있습니다.</p>
<dl class="class">
<dt id="email.headerregistry.Address">
<em class="property">class </em><code class="sig-prename descclassname">email.headerregistry.</code><code class="sig-name descname">Address</code><span class="sig-paren">(</span><em class="sig-param">display_name=''</em>, <em class="sig-param">username=''</em>, <em class="sig-param">domain=''</em>, <em class="sig-param">addr_spec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.headerregistry.Address" title="정의 주소">¶</a></dt>
<dd><p>전자 우편 주소를 나타내는 데 사용되는 클래스. 주소의 일반적인 형식은 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">display_name</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">username</span><span class="nd">@domain</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>또는:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">username</span><span class="nd">@domain</span>
</pre></div>
</div>
<p>여기서 각 부분은 <span class="target" id="index-41"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>에 명시된 특정 문법 규칙을 준수해야 합니다.</p>
<p>편의상 <em>username</em>과 <em>domain</em> 대신 <em>addr_spec</em>을 지정할 수 있으며, 이 경우 <em>addr_spec</em>에서 <em>username</em>과 <em>domain</em>이 구문 분석됩니다. <em>addr_spec</em>은 올바르게 RFC 인용된 문자열(quoted string)이어야 합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">Address</span></code>는 에러를 발생시킵니다. 유니코드 문자는 허용되며 직렬화될 때 적절하게 인코딩됩니다. 그러나, RFC에 따라, 주소의 사용자 이름 부분에는 유니코드가 허용되지 <em>않습니다</em>.</p>
<dl class="attribute">
<dt id="email.headerregistry.Address.display_name">
<code class="sig-name descname">display_name</code><a class="headerlink" href="#email.headerregistry.Address.display_name" title="정의 주소">¶</a></dt>
<dd><p>모든 인용(quoting)이 제거된 주소의 표시 이름 부분 (있다면). 주소에 표시 이름이 없으면, 이 어트리뷰트는 빈 문자열입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.headerregistry.Address.username">
<code class="sig-name descname">username</code><a class="headerlink" href="#email.headerregistry.Address.username" title="정의 주소">¶</a></dt>
<dd><p>모든 인용(quoting)이 제거된 주소의 <code class="docutils literal notranslate"><span class="pre">username</span></code> 부분.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.headerregistry.Address.domain">
<code class="sig-name descname">domain</code><a class="headerlink" href="#email.headerregistry.Address.domain" title="정의 주소">¶</a></dt>
<dd><p>주소의 <code class="docutils literal notranslate"><span class="pre">domain</span></code> 부분.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.headerregistry.Address.addr_spec">
<code class="sig-name descname">addr_spec</code><a class="headerlink" href="#email.headerregistry.Address.addr_spec" title="정의 주소">¶</a></dt>
<dd><p>주소의 <code class="docutils literal notranslate"><span class="pre">username&#64;domain</span></code> 부분, 단순 주소(위의 두 번째 형식)로 사용하기 위해 올바르게 인용(quoted)됩니다. 이 어트리뷰트는 불변입니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.headerregistry.Address.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.headerregistry.Address.__str__" title="정의 주소">¶</a></dt>
<dd><p>객체의 <code class="docutils literal notranslate"><span class="pre">str</span></code> 값은 <span class="target" id="index-42"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a> 규칙에 따라 인용된(quoted) 주소이지만, ASCII가 아닌 문자의 콘텐츠 전송 인코딩(Content Transfer Encoding)은 없습니다.</p>
</dd></dl>

<p>SMTP(<span class="target" id="index-43"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5321.html"><strong>RFC 5321</strong></a>)를 지원하기 위해, <code class="docutils literal notranslate"><span class="pre">Address</span></code>는 한가지 특별한 경우를 처리합니다: <code class="docutils literal notranslate"><span class="pre">username</span></code>과 <code class="docutils literal notranslate"><span class="pre">domain</span></code>이 모두 빈 문자열(또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>)이면, <code class="docutils literal notranslate"><span class="pre">Address</span></code>의 문자열 값은 <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code>입니다.</p>
</dd></dl>

<dl class="class">
<dt id="email.headerregistry.Group">
<em class="property">class </em><code class="sig-prename descclassname">email.headerregistry.</code><code class="sig-name descname">Group</code><span class="sig-paren">(</span><em class="sig-param">display_name=None</em>, <em class="sig-param">addresses=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.headerregistry.Group" title="정의 주소">¶</a></dt>
<dd><p>주소 그룹을 표현하는 데 사용되는 클래스. 주소 그룹의 일반적인 형식은 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">display_name</span><span class="p">:</span> <span class="p">[</span><span class="n">address</span><span class="o">-</span><span class="nb">list</span><span class="p">];</span>
</pre></div>
</div>
<p>그룹과 단일 주소의 혼합으로 구성된 주소 목록 처리의 편의를 위해, <em>display_name</em>을 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정하고 단일 주소 목록을 <em>addresses</em>로 제공하여, <code class="docutils literal notranslate"><span class="pre">Group</span></code>을 그룹의 일부가 아닌 단일 주소를 나타내는 데 사용할 수도 있습니다.</p>
<dl class="attribute">
<dt id="email.headerregistry.Group.display_name">
<code class="sig-name descname">display_name</code><a class="headerlink" href="#email.headerregistry.Group.display_name" title="정의 주소">¶</a></dt>
<dd><p>그룹의 <code class="docutils literal notranslate"><span class="pre">display_name</span></code>. <code class="docutils literal notranslate"><span class="pre">None</span></code>이고 <code class="docutils literal notranslate"><span class="pre">addresses</span></code>에 정확히 하나의 <code class="docutils literal notranslate"><span class="pre">Address</span></code>가 있으면, <code class="docutils literal notranslate"><span class="pre">Group</span></code>은 그룹에 속하지 않은 단일 주소를 나타냅니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.headerregistry.Group.addresses">
<code class="sig-name descname">addresses</code><a class="headerlink" href="#email.headerregistry.Group.addresses" title="정의 주소">¶</a></dt>
<dd><p>그룹에 있는 주소를 나타내는 <a class="reference internal" href="#email.headerregistry.Address" title="email.headerregistry.Address"><code class="xref py py-class docutils literal notranslate"><span class="pre">Address</span></code></a> 객체의 비어있을 수 있는 튜플.</p>
</dd></dl>

<dl class="method">
<dt id="email.headerregistry.Group.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.headerregistry.Group.__str__" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Group</span></code>의 <code class="docutils literal notranslate"><span class="pre">str</span></code> 값은 <span class="target" id="index-44"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>에 따라 포맷되지만, ASCII가 아닌 문자의 콘텐츠 전송 인코딩(Content Transfer Encoding)은 없습니다. <code class="docutils literal notranslate"><span class="pre">display_name</span></code>이 None이고 <code class="docutils literal notranslate"><span class="pre">addresses</span></code> 목록에 단일 <code class="docutils literal notranslate"><span class="pre">Address</span></code>가 있으면 <code class="docutils literal notranslate"><span class="pre">str</span></code> 값은 해당 단일 <code class="docutils literal notranslate"><span class="pre">Address</span></code>의 <code class="docutils literal notranslate"><span class="pre">str</span></code>과 같습니다.</p>
</dd></dl>

</dd></dl>

<p class="rubric">각주</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>원래 3.3에서 <a class="reference internal" href="../glossary.html#term-provisional-package"><span class="xref std std-term">잠정적 모듈</span></a>로 추가되었습니다.</p>
</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>이전 항목</h4>
  <p class="topless"><a href="email.errors.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.errors</span></code>: 예외와 결함 클래스</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="email.contentmanager.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.contentmanager</span></code>: MIME 콘텐츠 관리</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="email.contentmanager.html" title="email.contentmanager: MIME 콘텐츠 관리"
             >다음</a> |</li>
        <li class="right" >
          <a href="email.errors.html" title="email.errors: 예외와 결함 클래스"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >인터넷 데이터 처리</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 전자 메일과 MIME 처리 패키지</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2021, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2021, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>