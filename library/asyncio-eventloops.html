
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>19.5.2. 이벤트 루프 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="19.5.3. Tasks and coroutines" href="asyncio-task.html" />
    <link rel="prev" title="19.5.1. 베이스 이벤트 루프" href="asyncio-eventloop.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/library/asyncio-eventloops.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-task.html" title="19.5.3. Tasks and coroutines"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="asyncio-eventloop.html" title="19.5.1. 베이스 이벤트 루프"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >19. 프로세스 간 통신과 네트워킹</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U">19.5. <code class="docutils literal"><span class="pre">asyncio</span></code> --- 비동기 I/O, 이벤트 루프, 코루틴과 태스크</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="event-loops">
<h1>19.5.2. 이벤트 루프<a class="headerlink" href="#event-loops" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/asyncio/events.py">Lib/asyncio/events.py</a></p>
<div class="section" id="event-loop-functions">
<h2>19.5.2.1. 이벤트 루프 함수<a class="headerlink" href="#event-loop-functions" title="제목 주소">¶</a></h2>
<p>다음 함수는 전역 정책의 메서드에 액세스하는 손쉬운 방법입니다. 프로세스의 실행 초기에 <a class="reference internal" href="#asyncio.set_event_loop_policy" title="asyncio.set_event_loop_policy"><code class="xref py py-func docutils literal"><span class="pre">set_event_loop_policy()</span></code></a>를 호출함으로써 대체 정책이 설정되지 않는 한, 이것은 기본 정책에 대한 액세스를 제공합니다.</p>
<dl class="function">
<dt id="asyncio.get_event_loop">
<code class="descclassname">asyncio.</code><code class="descname">get_event_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_event_loop" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">get_event_loop_policy().get_event_loop()</span></code> 를 호출하는 것과 동등합니다.</p>
</dd></dl>

<dl class="function">
<dt id="asyncio.set_event_loop">
<code class="descclassname">asyncio.</code><code class="descname">set_event_loop</code><span class="sig-paren">(</span><em>loop</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.set_event_loop" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">get_event_loop_policy().set_event_loop(loop)</span></code> 를 호출하는 것과 동등합니다.</p>
</dd></dl>

<dl class="function">
<dt id="asyncio.new_event_loop">
<code class="descclassname">asyncio.</code><code class="descname">new_event_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.new_event_loop" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">get_event_loop_policy().new_event_loop()</span></code> 를 호출하는 것과 동등합니다.</p>
</dd></dl>

<dl class="function">
<dt id="asyncio.get_running_loop">
<code class="descclassname">asyncio.</code><code class="descname">get_running_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_running_loop" title="정의 주소">¶</a></dt>
<dd><p>현재 OS 스레드에서 실행 중인 이벤트 루프를 반환합니다. 실행 중인 이벤트 루프가 없으면 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> 가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="available-event-loops">
<span id="asyncio-event-loops"></span><h2>19.5.2.2. 사용 가능한 이벤트 루프<a class="headerlink" href="#available-event-loops" title="제목 주소">¶</a></h2>
<p>asyncio는 현재 이벤트 루프의 두 가지 구현을 제공합니다: <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a>와 <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a></p>
<dl class="class">
<dt id="asyncio.SelectorEventLoop">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">SelectorEventLoop</code><a class="headerlink" href="#asyncio.SelectorEventLoop" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal"><span class="pre">selectors</span></code></a> 모듈을 기반으로 하는 이벤트 루프. <a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code class="xref py py-class docutils literal"><span class="pre">AbstractEventLoop</span></code></a> 의 서브 클래스입니다.</p>
<p>플랫폼에서 사용할 수 있는 가장 효율적인 셀렉터를 사용합니다.</p>
<p>윈도우에서는, 소켓만 지원됩니다 (예: 파이프는 지원되지 않습니다): <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms740141%28v=vs.85%29.aspx">select의 MSDN 설명서</a> 를 참조하세요.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.ProactorEventLoop">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">ProactorEventLoop</code><a class="headerlink" href="#asyncio.ProactorEventLoop" title="정의 주소">¶</a></dt>
<dd><p>IOCP라고 하는 &quot;I/O 완료 포트&quot;를 사용하는 윈도우용 프로액터 이벤트 루프. <a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code class="xref py py-class docutils literal"><span class="pre">AbstractEventLoop</span></code></a> 의 서브 클래스입니다.</p>
<p>가용성: 윈도우.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365198%28v=vs.85%29.aspx">I/O 완료 포트에 관한 MSDN 설명서</a>.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">프로액터(proactor) 는 리액터(reactor)와 대비되는 용어입니다. <a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal"><span class="pre">selectors</span></code></a> 모듈이 제공하는
셀렉터들은 모두 비 블로킹(non-blocking) I/O를 사용합니다. 이들은 동기(synchronous) I/O와 사실상
같은 구조를 갖지만 요청한 I/O가 블로킹에 들어갈 것 같으면 <code class="docutils literal"><span class="pre">EWOULDBLOCK</span></code> 에러를 일으키도록 하고, 셀렉터는
이 에러를 일으키지 않고 I/O가 수행될 수 있을 때까지 <strong>한꺼번에</strong> 대기할 수 있도록 합니다. 이런 방식을
reactive 하다고 합니다. 이에 반해 I/O를 즉시 완료할 수 없어도 요청 자체를 거부하는 것이 아니라, 요청을
큐에 넣어두고, I/O가 완료되면 완료 신호를 주는 방식이 있습니다. 이때도 셀렉터와 비슷한 종류의 대기 메커니즘이
제공됩니다. 윈도우의 IOCP 가 이 대기 메커니즘의 하나입니다. 비 블로킹 방식과의 결정적인 차이는, 요청하는
순간부터 요청이 완료될 때까지 I/O에 수반되는 버퍼가 I/O 하부 시스템에 붙잡혀있게 된다는 것과, 큐에 들어간
요청을 취소하는 메커니즘이 필요하다는 것입니다. 이 때문에 I/O 루프가 좀 다른 방식으로 구성되어야 합니다.
구별하기 위해 이런 방식을 proactive 하다고 합니다. 버퍼가 직접 제공되기 때문에 reactive 한 방식보다 메모리
복사를 줄여 성능을 개선할 수 있는 여지가 있습니다.</p>
</div>
</dd></dl>

<p>윈도우에서 <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a>를 사용하는 예:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span><span class="o">,</span> <span class="nn">sys</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;win32&#39;</span><span class="p">:</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">ProactorEventLoop</span><span class="p">()</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="platform-support">
<span id="asyncio-platform-support"></span><h2>19.5.2.3. 플랫폼 지원<a class="headerlink" href="#platform-support" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 모듈은 이식성을 갖도록 설계되었지만, 각 플랫폼은 여전히 ​​미묘한 차이가 있으며 모든 <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 기능을 지원하지 않을 수도 있습니다.</p>
<div class="section" id="windows">
<h3>19.5.2.3.1. 윈도우<a class="headerlink" href="#windows" title="제목 주소">¶</a></h3>
<p>윈도우 이벤트 루프의 일반적인 한계:</p>
<ul class="simple">
<li><a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop.create_unix_connection" title="asyncio.AbstractEventLoop.create_unix_connection"><code class="xref py py-meth docutils literal"><span class="pre">create_unix_connection()</span></code></a>과 <a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop.create_unix_server" title="asyncio.AbstractEventLoop.create_unix_server"><code class="xref py py-meth docutils literal"><span class="pre">create_unix_server()</span></code></a> 는 지원되지 않습니다: 소켓 패밀리 <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal"><span class="pre">socket.AF_UNIX</span></code></a> 는 유닉스에서만 사용됩니다</li>
<li><a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop.add_signal_handler" title="asyncio.AbstractEventLoop.add_signal_handler"><code class="xref py py-meth docutils literal"><span class="pre">add_signal_handler()</span></code></a>와 <a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop.remove_signal_handler" title="asyncio.AbstractEventLoop.remove_signal_handler"><code class="xref py py-meth docutils literal"><span class="pre">remove_signal_handler()</span></code></a> 는 지원되지 않습니다.</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">EventLoopPolicy.set_child_watcher()</span></code> 는 지원되지 않습니다. <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a> 은 자식 프로세스를 지원합니다. 자식 프로세스를 감시하는 구현은 하나뿐이고, 구성할 필요가 없습니다.</li>
</ul>
<p><a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a> 특정 제한:</p>
<ul class="simple">
<li><a class="reference internal" href="selectors.html#selectors.SelectSelector" title="selectors.SelectSelector"><code class="xref py py-class docutils literal"><span class="pre">SelectSelector</span></code></a> 는 소켓만을 지원하며 512개의 소켓으로 제한됩니다.</li>
<li><a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop.add_reader" title="asyncio.AbstractEventLoop.add_reader"><code class="xref py py-meth docutils literal"><span class="pre">add_reader()</span></code></a>와 <a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop.add_writer" title="asyncio.AbstractEventLoop.add_writer"><code class="xref py py-meth docutils literal"><span class="pre">add_writer()</span></code></a> 는 소켓의 파일 디스크립터만을 받아들입니다.</li>
<li>파이프는 지원되지 않습니다 (예: <a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop.connect_read_pipe" title="asyncio.AbstractEventLoop.connect_read_pipe"><code class="xref py py-meth docutils literal"><span class="pre">connect_read_pipe()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop.connect_write_pipe" title="asyncio.AbstractEventLoop.connect_write_pipe"><code class="xref py py-meth docutils literal"><span class="pre">connect_write_pipe()</span></code></a>).</li>
<li><a class="reference internal" href="asyncio-subprocess.html#asyncio-subprocess"><span class="std std-ref">자식 프로세스</span></a> 는 지원되지 않습니다 (예: <a class="reference internal" href="asyncio-subprocess.html#asyncio.AbstractEventLoop.subprocess_exec" title="asyncio.AbstractEventLoop.subprocess_exec"><code class="xref py py-meth docutils literal"><span class="pre">subprocess_exec()</span></code></a>, <a class="reference internal" href="asyncio-subprocess.html#asyncio.AbstractEventLoop.subprocess_shell" title="asyncio.AbstractEventLoop.subprocess_shell"><code class="xref py py-meth docutils literal"><span class="pre">subprocess_shell()</span></code></a>).</li>
</ul>
<p><a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a> 특정 제한:</p>
<ul class="simple">
<li><a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop.create_datagram_endpoint" title="asyncio.AbstractEventLoop.create_datagram_endpoint"><code class="xref py py-meth docutils literal"><span class="pre">create_datagram_endpoint()</span></code></a> (UDP) 는 지원되지 않습니다.</li>
<li><a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop.add_reader" title="asyncio.AbstractEventLoop.add_reader"><code class="xref py py-meth docutils literal"><span class="pre">add_reader()</span></code></a>와 <a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop.add_writer" title="asyncio.AbstractEventLoop.add_writer"><code class="xref py py-meth docutils literal"><span class="pre">add_writer()</span></code></a> 는 지원되지 않습니다.</li>
</ul>
<p>윈도우에서 단조 시계의 해상도는 대개 15.6 msec 입니다. 최상의 해상도는 0.5 msec 입니다. 해상도는 하드웨어(<a class="reference external" href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">HPET</a> 이 제공되는지)와 윈도우 구성에 따라 다릅니다. <a class="reference internal" href="asyncio-eventloop.html#asyncio-delayed-calls"><span class="std std-ref">asyncio 지연된 호출</span></a> 을 참조하세요.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span><a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></code></a>는 이제 SSL을 지원합니다.</p>
</div>
</div>
<div class="section" id="mac-os-x">
<h3>19.5.2.3.2. 맥 OS X<a class="headerlink" href="#mac-os-x" title="제목 주소">¶</a></h3>
<p>PTY와 같은 문자 장치는 Mavericks (맥 OS 10.9) 이후로만 잘 지원됩니다. 맥 OS 10.5 이하에서는 지원되지 않습니다.</p>
<p>맥 OS 10.6, 10.7 및 10.8에서, 기본 이벤트 루프는 <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a> 이며 <a class="reference internal" href="selectors.html#selectors.KqueueSelector" title="selectors.KqueueSelector"><code class="xref py py-class docutils literal"><span class="pre">selectors.KqueueSelector</span></code></a> 를 사용합니다. <a class="reference internal" href="selectors.html#selectors.KqueueSelector" title="selectors.KqueueSelector"><code class="xref py py-class docutils literal"><span class="pre">selectors.KqueueSelector</span></code></a> 는 이 버전에서 문자 장치를 지원하지 않습니다. <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></code></a>는 <a class="reference internal" href="selectors.html#selectors.SelectSelector" title="selectors.SelectSelector"><code class="xref py py-class docutils literal"><span class="pre">SelectSelector</span></code></a> 나 <a class="reference internal" href="selectors.html#selectors.PollSelector" title="selectors.PollSelector"><code class="xref py py-class docutils literal"><span class="pre">PollSelector</span></code></a> 와 함께 사용되어 이 버전의 맥 OS X에서 문자 장치를 지원할 수 있습니다. 예를 들어:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">selectors</span>

<span class="n">selector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">SelectSelector</span><span class="p">()</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">SelectorEventLoop</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="event-loop-policies-and-the-default-policy">
<h2>19.5.2.4. 이벤트 루프 정책과 기본 정책<a class="headerlink" href="#event-loop-policies-and-the-default-policy" title="제목 주소">¶</a></h2>
<p>이벤트 루프 관리는 <em>정책(policy)</em> 패턴으로 추상화되어, 사용자 정의 플랫폼 및 프레임워크에 최대한의 유연성을 제공합니다. 프로세스 실행되는 동안, 단일 전역 정책 객체는 호출하는 컨텍스트에 기반하여 프로세스에서 사용할 수 있는 이벤트 루프를 관리합니다. 정책은 <a class="reference internal" href="#asyncio.AbstractEventLoopPolicy" title="asyncio.AbstractEventLoopPolicy"><code class="xref py py-class docutils literal"><span class="pre">AbstractEventLoopPolicy</span></code></a> 인터페이스를 구현하는 객체입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">정책 패턴(policy pattern)은 디자인 패턴의 한 종류 입니다.</p>
</div>
<p><a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a> 의 대부분 사용자는, 기본 전역 정책으로 충분하므로, 정책을 명시적으로 처리할 필요가 없습니다 (아래를 참조하세요).</p>
<p>모듈 수준 함수 <a class="reference internal" href="#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal"><span class="pre">get_event_loop()</span></code></a>와 <a class="reference internal" href="#asyncio.set_event_loop" title="asyncio.set_event_loop"><code class="xref py py-func docutils literal"><span class="pre">set_event_loop()</span></code></a>는 기본 정책에 의해 관리되는 이벤트 루프에 편리한 접근을 제공합니다.</p>
</div>
<div class="section" id="event-loop-policy-interface">
<h2>19.5.2.5. 이벤트 루프 정책 인터페이스<a class="headerlink" href="#event-loop-policy-interface" title="제목 주소">¶</a></h2>
<p>이벤트 루프 정책은 다음 인터페이스를 구현해야 합니다:</p>
<dl class="class">
<dt id="asyncio.AbstractEventLoopPolicy">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">AbstractEventLoopPolicy</code><a class="headerlink" href="#asyncio.AbstractEventLoopPolicy" title="정의 주소">¶</a></dt>
<dd><p>이벤트 루프 정책.</p>
<dl class="method">
<dt id="asyncio.AbstractEventLoopPolicy.get_event_loop">
<code class="descname">get_event_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoopPolicy.get_event_loop" title="정의 주소">¶</a></dt>
<dd><p>현재 컨텍스트의 이벤트 루프를 가져옵니다.</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code class="xref py py-class docutils literal"><span class="pre">AbstractEventLoop</span></code></a> 인터페이스를 구현하는 이벤트 루프 객체를 반환합니다. 코루틴에서 호출되면, 현재 실행 중인 이벤트 루프를 반환합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">코루틴에서 호출될 때 그 코루틴을 실행하고 있는 이벤트 루프와 현재 컨텍스트의 이벤트 루프가
다를 수도 있음을 시사하고 있습니다.</p>
</div>
<p>현재의 컨텍스트에 이벤트 루프가 설정되어 있지 않고 현재의 정책이 이벤트 루프를 만들도록 지정하지 않으면 예외를 발생시킵니다. 절대 <code class="docutils literal"><span class="pre">None</span></code> 을 반환해서는 안 됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이벤트 루프를 새로 만들지를 지정하는 인터페이스 같은 것은 없습니다. 이런 정책은 정책 객체의
코드에서 정의됩니다. 기본 정책의 경우는 메인 스레드에서 호출하는 경우만 루프를 새로 만들도록
허락합니다. 컨텍스트라는 개념도 추상적인 것으로, 컨텍스트가 무엇을 의미하는지 역시 정책 객체의
코드에서 결정합니다. 기본 정책의 경우는 컨텍스트가 스레드입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoopPolicy.set_event_loop">
<code class="descname">set_event_loop</code><span class="sig-paren">(</span><em>loop</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoopPolicy.set_event_loop" title="정의 주소">¶</a></dt>
<dd><p>현재 컨텍스트의 이벤트 루프를 <em>loop</em> 로 설정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.AbstractEventLoopPolicy.new_event_loop">
<code class="descname">new_event_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.AbstractEventLoopPolicy.new_event_loop" title="정의 주소">¶</a></dt>
<dd><p>이 정책의 규칙에 따라 새 이벤트 루프 객체를 만들어 반환합니다.</p>
<p>이 루프를 현재 컨텍스트의 이벤트 루프로 설정해야 하면 <a class="reference internal" href="#asyncio.set_event_loop" title="asyncio.set_event_loop"><code class="xref py py-meth docutils literal"><span class="pre">set_event_loop()</span></code></a>를 명시적으로 호출해야 합니다.</p>
</dd></dl>

</dd></dl>

<p>기본 정책은 컨텍스트를 현재 스레드로 정의하고, <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code class="xref py py-mod docutils literal"><span class="pre">asyncio</span></code></a>와 상호 작용하는 스레드 당 하나의 이벤트 루프를 관리합니다. 이 규칙에 대한 예외는 <a class="reference internal" href="#asyncio.AbstractEventLoopPolicy.get_event_loop" title="asyncio.AbstractEventLoopPolicy.get_event_loop"><code class="xref py py-meth docutils literal"><span class="pre">get_event_loop()</span></code></a> 가 실행 중인 퓨처/코루틴에서 호출될 때 발생합니다. 이때 그 퓨처/코루틴을 실행하고 있는 현재 루프를 반환합니다.</p>
<p>만약 현재 스레드가 이미 연결된 이벤트 루프를 가지고 있지 않다면, 기본 정책의 <a class="reference internal" href="#asyncio.AbstractEventLoopPolicy.get_event_loop" title="asyncio.AbstractEventLoopPolicy.get_event_loop"><code class="xref py py-meth docutils literal"><span class="pre">get_event_loop()</span></code></a> 메서드는 메인 스레드에서 호출될 때 하나를 만들지만, 그렇지 않으면 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> 를 발생시킵니다.</p>
</div>
<div class="section" id="access-to-the-global-loop-policy">
<h2>19.5.2.6. 전역 루프 정책 액세스<a class="headerlink" href="#access-to-the-global-loop-policy" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="asyncio.get_event_loop_policy">
<code class="descclassname">asyncio.</code><code class="descname">get_event_loop_policy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_event_loop_policy" title="정의 주소">¶</a></dt>
<dd><p>현재 이벤트 루프 정책을 가져옵니다.</p>
</dd></dl>

<dl class="function">
<dt id="asyncio.set_event_loop_policy">
<code class="descclassname">asyncio.</code><code class="descname">set_event_loop_policy</code><span class="sig-paren">(</span><em>policy</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.set_event_loop_policy" title="정의 주소">¶</a></dt>
<dd><p>현재 이벤트 루프 정책을 설정합니다. <em>policy</em> 가 <code class="docutils literal"><span class="pre">None</span></code> 이면, 기본 정책이 복원됩니다.</p>
</dd></dl>

</div>
<div class="section" id="customizing-the-event-loop-policy">
<h2>19.5.2.7. 이벤트 루프 정책 사용자 정의<a class="headerlink" href="#customizing-the-event-loop-policy" title="제목 주소">¶</a></h2>
<p>새로운 이벤트 루프 정책을 구현하려면, 구상 기본 이벤트 루프 정책 <code class="xref py py-class docutils literal"><span class="pre">DefaultEventLoopPolicy</span></code>를 서브 클래스하고, 동작을 변경할 메서드를 재정의하는 것이 좋습니다, 예를 들어:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyEventLoopPolicy</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">DefaultEventLoopPolicy</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">get_event_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;이벤트 루프를 가져옵니다.</span>

<span class="sd">        None 이거나 EventLoop 의 인스턴스일 수 있습니다.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
        <span class="c1"># loop 로 뭔가 합니다 ...</span>
        <span class="k">return</span> <span class="n">loop</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop_policy</span><span class="p">(</span><span class="n">MyEventLoopPolicy</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">따로 설명하고 있지는 않지만 <code class="xref py py-class docutils literal"><span class="pre">DefaultEventLoopPolicy</span></code> 라는 클래스가 정의되는 것으로
보아야 합니다.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">19.5.2. 이벤트 루프</a><ul>
<li><a class="reference internal" href="#event-loop-functions">19.5.2.1. 이벤트 루프 함수</a></li>
<li><a class="reference internal" href="#available-event-loops">19.5.2.2. 사용 가능한 이벤트 루프</a></li>
<li><a class="reference internal" href="#platform-support">19.5.2.3. 플랫폼 지원</a><ul>
<li><a class="reference internal" href="#windows">19.5.2.3.1. 윈도우</a></li>
<li><a class="reference internal" href="#mac-os-x">19.5.2.3.2. 맥 OS X</a></li>
</ul>
</li>
<li><a class="reference internal" href="#event-loop-policies-and-the-default-policy">19.5.2.4. 이벤트 루프 정책과 기본 정책</a></li>
<li><a class="reference internal" href="#event-loop-policy-interface">19.5.2.5. 이벤트 루프 정책 인터페이스</a></li>
<li><a class="reference internal" href="#access-to-the-global-loop-policy">19.5.2.6. 전역 루프 정책 액세스</a></li>
<li><a class="reference internal" href="#customizing-the-event-loop-policy">19.5.2.7. 이벤트 루프 정책 사용자 정의</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="asyncio-eventloop.html"
                        title="이전 장">19.5.1. 베이스 이벤트 루프</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="asyncio-task.html"
                        title="다음 장">19.5.3. Tasks and coroutines</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-task.html" title="19.5.3. Tasks and coroutines"
             >다음</a> |</li>
        <li class="right" >
          <a href="asyncio-eventloop.html" title="19.5.1. 베이스 이벤트 루프"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >19. 프로세스 간 통신과 네트워킹</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" >19.5. <code class="docutils literal"><span class="pre">asyncio</span></code> --- 비동기 I/O, 이벤트 루프, 코루틴과 태스크</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2018, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 를 사용해서 만들었습니다.
    </div>

  </body>
</html>