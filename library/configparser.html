
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>configparser --- 구성 파일 구문 분석기 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="netrc --- netrc 파일 처리" href="netrc.html" />
    <link rel="prev" title="csv --- CSV 파일 읽기와 쓰기" href="csv.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/configparser.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="netrc.html" title="netrc --- netrc 파일 처리"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="csv.html" title="csv --- CSV 파일 읽기와 쓰기"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="fileformats.html" accesskey="U">파일 형식</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-configparser">
<span id="configparser-configuration-file-parser"></span><h1><a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a> --- 구성 파일 구문 분석기<a class="headerlink" href="#module-configparser" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/configparser.py">Lib/configparser.py</a></p>
<hr class="docutils" id="index-0" />
<p>이 모듈은 마이크로소프트 윈도우 INI 파일과 유사한 구조를 제공하는 기본 구성 언어를 구현하는 <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConfigParser</span></code></a> 클래스를 제공합니다. 이를 사용하여 최종 사용자가 쉽게 사용자 정의 할 수 있는 파이썬 프로그램을 작성할 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 라이브러리는 윈도우 레지스트리 확장 버전의 INI 문법에 사용된 값-형 접두사를 해석하거나 기록하지 <em>않습니다</em>.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<dl class="last docutils">
<dt>모듈 <a class="reference internal" href="shlex.html#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shlex</span></code></a></dt>
<dd>응용 프로그램 구성 파일의 대체 형식으로 사용할 수 있는 유닉스 셸과 유사한 미니 언어를 만드는 것에 관한 지원.</dd>
<dt>모듈 <a class="reference internal" href="json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a></dt>
<dd>json 모듈은 이러한 목적으로도 사용될 수 있는 자바스크립트 문법의 부분 집합을 구현합니다.</dd>
</dl>
</div>
<div class="section" id="quick-start">
<h2>빠른 시작<a class="headerlink" href="#quick-start" title="제목 주소">¶</a></h2>
<p>다음과 같은 매우 기본적인 구성 파일을 봅시다:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[DEFAULT]</span>
<span class="na">ServerAliveInterval</span> <span class="o">=</span> <span class="s">45</span>
<span class="na">Compression</span> <span class="o">=</span> <span class="s">yes</span>
<span class="na">CompressionLevel</span> <span class="o">=</span> <span class="s">9</span>
<span class="na">ForwardX11</span> <span class="o">=</span> <span class="s">yes</span>

<span class="k">[bitbucket.org]</span>
<span class="na">User</span> <span class="o">=</span> <span class="s">hg</span>

<span class="k">[topsecret.server.com]</span>
<span class="na">Port</span> <span class="o">=</span> <span class="s">50022</span>
<span class="na">ForwardX11</span> <span class="o">=</span> <span class="s">no</span>
</pre></div>
</div>
<p>INI 파일의 구조는 <a class="reference external" href="#supported-ini-file-structure">다음 섹션에서</a> 설명됩니다. 기본적으로, 파일은 섹션으로 구성되며, 각 섹션에는 값이 있는 키가 포함됩니다. <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a> 클래스는 이러한 파일을 읽고 쓸 수 있습니다. 프로그래밍 방식으로 위의 구성 파일을 만드는 것으로 시작하겠습니다.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">configparser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;DEFAULT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ServerAliveInterval&#39;</span><span class="p">:</span> <span class="s1">&#39;45&#39;</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="s1">&#39;Compression&#39;</span><span class="p">:</span> <span class="s1">&#39;yes&#39;</span><span class="p">,</span>
<span class="gp">... </span>                     <span class="s1">&#39;CompressionLevel&#39;</span><span class="p">:</span> <span class="s1">&#39;9&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bitbucket.org&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bitbucket.org&#39;</span><span class="p">][</span><span class="s1">&#39;User&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;hg&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;topsecret.server.com&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;topsecret.server.com&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="p">[</span><span class="s1">&#39;Port&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;50022&#39;</span>     <span class="c1"># 구문 분석기를 변경합니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="p">[</span><span class="s1">&#39;ForwardX11&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;no&#39;</span>  <span class="c1"># 여기도 마찬가지입니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;DEFAULT&#39;</span><span class="p">][</span><span class="s1">&#39;ForwardX11&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;yes&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;example.ini&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">configfile</span><span class="p">:</span>
<span class="gp">... </span>  <span class="n">config</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">configfile</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>보시다시피, 구성 구문 분석기는 딕셔너리처럼 취급할 수 있습니다. <a class="reference external" href="#mapping-protocol-access">나중에 설명되는</a> 차이점이 있지만, 동작은 딕셔너리에서 기대하는 것과 매우 비슷합니다.</p>
<p>이제 구성 파일을 만들고 저장 했으니, 파일을 다시 읽고 담긴 데이터를 탐색합시다.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;example.ini&#39;</span><span class="p">)</span>
<span class="go">[&#39;example.ini&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
<span class="go">[&#39;bitbucket.org&#39;, &#39;topsecret.server.com&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;bitbucket.org&#39;</span> <span class="ow">in</span> <span class="n">config</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;bytebong.com&#39;</span> <span class="ow">in</span> <span class="n">config</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bitbucket.org&#39;</span><span class="p">][</span><span class="s1">&#39;User&#39;</span><span class="p">]</span>
<span class="go">&#39;hg&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;DEFAULT&#39;</span><span class="p">][</span><span class="s1">&#39;Compression&#39;</span><span class="p">]</span>
<span class="go">&#39;yes&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;topsecret.server.com&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="p">[</span><span class="s1">&#39;ForwardX11&#39;</span><span class="p">]</span>
<span class="go">&#39;no&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="p">[</span><span class="s1">&#39;Port&#39;</span><span class="p">]</span>
<span class="go">&#39;50022&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;bitbucket.org&#39;</span><span class="p">]:</span>  
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="go">user</span>
<span class="go">compressionlevel</span>
<span class="go">serveraliveinterval</span>
<span class="go">compression</span>
<span class="go">forwardx11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bitbucket.org&#39;</span><span class="p">][</span><span class="s1">&#39;ForwardX11&#39;</span><span class="p">]</span>
<span class="go">&#39;yes&#39;</span>
</pre></div>
</div>
<p>위에서 볼 수 있듯이, API는 매우 간단합니다. 유일한 마법은 <code class="docutils literal notranslate"><span class="pre">DEFAULT</span></code> 섹션인데, 다른 모든 섹션에 대한 기본값을 제공합니다 <a class="footnote-reference" href="#id14" id="id1">[1]</a>. 섹션의 키는 대소 문자를 구분하지 않으며 소문자로 저장됨에 유의하십시오 <a class="footnote-reference" href="#id14" id="id2">[1]</a>.</p>
</div>
<div class="section" id="supported-datatypes">
<h2>지원되는 데이터 형<a class="headerlink" href="#supported-datatypes" title="제목 주소">¶</a></h2>
<p>구성 구문 분석기는 구성 파일에 있는 값의 데이터 형을 추측하지 않고, 항상 내부적으로 문자열로 저장합니다. 이것은 다른 데이터 형이 필요하면, 직접 변환해야함을 뜻합니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">topsecret</span><span class="p">[</span><span class="s1">&#39;Port&#39;</span><span class="p">])</span>
<span class="go">50022</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">topsecret</span><span class="p">[</span><span class="s1">&#39;CompressionLevel&#39;</span><span class="p">])</span>
<span class="go">9.0</span>
</pre></div>
</div>
<p>이 작업이 매우 흔하기 때문에, 구성 구문 분석기는 정수, 부동 소수점및 불리언을 처리하는 편리한 게터(getter) 메서드를 제공합니다. 마지막 것이 가장 흥미로운데, <code class="docutils literal notranslate"><span class="pre">bool('False')</span></code>가 여전히 <code class="docutils literal notranslate"><span class="pre">True</span></code>이기 때문에 <code class="docutils literal notranslate"><span class="pre">bool()</span></code>에 값을 전달하는 것만으로는 충분치 않기 때문입니다. 이것이 구성 구문 분석기가 <a class="reference internal" href="#configparser.ConfigParser.getboolean" title="configparser.ConfigParser.getboolean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getboolean()</span></code></a>도 제공하는 이유입니다. 이 메서드는 대소 문자를 구분하지 않으며 <code class="docutils literal notranslate"><span class="pre">'yes'</span></code>/<code class="docutils literal notranslate"><span class="pre">'no'</span></code>, <code class="docutils literal notranslate"><span class="pre">'on'</span></code>/<code class="docutils literal notranslate"><span class="pre">'off'</span></code>, <code class="docutils literal notranslate"><span class="pre">'true'</span></code>/<code class="docutils literal notranslate"><span class="pre">'false'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'1'</span></code>/<code class="docutils literal notranslate"><span class="pre">'0'</span></code>에서 불리언 값을 인식합니다 <a class="footnote-reference" href="#id14" id="id3">[1]</a>. 예를 들면:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">&#39;ForwardX11&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;bitbucket.org&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">&#39;ForwardX11&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">&#39;bitbucket.org&#39;</span><span class="p">,</span> <span class="s1">&#39;Compression&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p><a class="reference internal" href="#configparser.ConfigParser.getboolean" title="configparser.ConfigParser.getboolean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getboolean()</span></code></a> 외에도, 구성 구문 분석기는 동등한 <a class="reference internal" href="#configparser.ConfigParser.getint" title="configparser.ConfigParser.getint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getint()</span></code></a>와 <a class="reference internal" href="#configparser.ConfigParser.getfloat" title="configparser.ConfigParser.getfloat"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getfloat()</span></code></a> 메서드를 제공합니다. 여러분 자신의 변환기를 등록하고 제공된 변환기를 사용자 정의 할 수 있습니다. <a class="footnote-reference" href="#id14" id="id4">[1]</a></p>
</div>
<div class="section" id="fallback-values">
<h2>대체 값<a class="headerlink" href="#fallback-values" title="제목 주소">¶</a></h2>
<p>딕셔너리와 마찬가지로, 섹션의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code> 메서드를 사용하여 대체(fallback) 값을 제공할 수 있습니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Port&#39;</span><span class="p">)</span>
<span class="go">&#39;50022&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;CompressionLevel&#39;</span><span class="p">)</span>
<span class="go">&#39;9&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Cipher&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Cipher&#39;</span><span class="p">,</span> <span class="s1">&#39;3des-cbc&#39;</span><span class="p">)</span>
<span class="go">&#39;3des-cbc&#39;</span>
</pre></div>
</div>
<p>기본값이 대체 값보다 우선함에 유의하십시오. 예를 들어, 이 예에서 <code class="docutils literal notranslate"><span class="pre">'CompressionLevel'</span></code> 키는 <code class="docutils literal notranslate"><span class="pre">'DEFAULT'</span></code> 섹션에서만 지정되었습니다. 이것을 <code class="docutils literal notranslate"><span class="pre">'topsecret.server.com'</span></code> 섹션에서 가져 오려고하면 대체 값을 지정하더라도 항상 기본값을 얻습니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;CompressionLevel&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">)</span>
<span class="go">&#39;9&#39;</span>
</pre></div>
</div>
<p>알아 두어야 할 또 다른 사항은 구문 분석기 수준의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code> 메서드가 이전 버전과의 호환성을 위해 유지되는 더 복잡한 사용자 정의 인터페이스를 제공한다는 것입니다. 이 메서드를 사용할 때, <code class="docutils literal notranslate"><span class="pre">fallback</span></code> 키워드 전용 인자를 통해 대체 값을 제공할 수 있습니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bitbucket.org&#39;</span><span class="p">,</span> <span class="s1">&#39;monster&#39;</span><span class="p">,</span>
<span class="gp">... </span>           <span class="n">fallback</span><span class="o">=</span><span class="s1">&#39;No such things as monsters&#39;</span><span class="p">)</span>
<span class="go">&#39;No such things as monsters&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#configparser.ConfigParser.getint" title="configparser.ConfigParser.getint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getint()</span></code></a>, <a class="reference internal" href="#configparser.ConfigParser.getfloat" title="configparser.ConfigParser.getfloat"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getfloat()</span></code></a> 및 <a class="reference internal" href="#configparser.ConfigParser.getboolean" title="configparser.ConfigParser.getboolean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getboolean()</span></code></a> 메서드에 같은 <code class="docutils literal notranslate"><span class="pre">fallback</span></code> 인자를 사용할 수 있습니다. 예를 들면:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;BatchMode&#39;</span> <span class="ow">in</span> <span class="n">topsecret</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">&#39;BatchMode&#39;</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;DEFAULT&#39;</span><span class="p">][</span><span class="s1">&#39;BatchMode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;no&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">topsecret</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">&#39;BatchMode&#39;</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
<div class="section" id="supported-ini-file-structure">
<h2>지원되는 INI 파일 구조<a class="headerlink" href="#supported-ini-file-structure" title="제목 주소">¶</a></h2>
<p>구성 파일은 섹션으로 구성되며, 각 섹션은 <code class="docutils literal notranslate"><span class="pre">[section]</span></code> 헤더로 시작하고, 특정 문자열(기본적으로 <code class="docutils literal notranslate"><span class="pre">=</span></code>이나 <code class="docutils literal notranslate"><span class="pre">:</span></code> <a class="footnote-reference" href="#id14" id="id5">[1]</a>)로 구분된 키/값 항목들이 뒤따릅니다. 기본적으로, 섹션 이름은 대소 문자를 구분하지만 키는 구분하지 않습니다 <a class="footnote-reference" href="#id14" id="id6">[1]</a>. 선행과 후행 공백은 키와 값에서 제거됩니다. 값을 생략할 수 있으며, 이 경우 키/값 구분자도 생략될 수 있습니다. 값의 첫 줄보다 깊게 들여쓰기 만하면 값이 여러 줄에 걸쳐있을 수 있습니다. 구문 분석기의 모드에 따라, 빈 줄은 여러 줄 값의 일부로 취급되거나 무시될 수 있습니다.</p>
<p>구성 파일에는 특정 문자(기본적으로 <code class="docutils literal notranslate"><span class="pre">#</span></code>과 <code class="docutils literal notranslate"><span class="pre">;</span></code> <a class="footnote-reference" href="#id14" id="id7">[1]</a>)를 접두사로 붙인 주석이 포함될 수 있습니다. 주석은 주석이 없다면 빈 줄일 곳에 있을 수 있으며, 들여쓰기될 수 있습니다. <a class="footnote-reference" href="#id14" id="id8">[1]</a></p>
<p>예를 들면:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Simple Values]</span>
<span class="na">key</span><span class="o">=</span><span class="s">value</span>
<span class="na">spaces in keys</span><span class="o">=</span><span class="s">allowed</span>
<span class="na">spaces in values</span><span class="o">=</span><span class="s">allowed as well</span>
<span class="na">spaces around the delimiter</span> <span class="o">=</span> <span class="s">obviously</span>
<span class="na">you can also use : to delimit keys from values</span>

<span class="k">[All Values Are Strings]</span>
<span class="na">values like this: 1000000</span>
<span class="na">or this: 3.14159265359</span>
<span class="na">are they treated as numbers? : no</span>
<span class="na">integers, floats and booleans are held as: strings</span>
<span class="na">can use the API to get converted values directly: true</span>

<span class="k">[Multiline Values]</span>
<span class="na">chorus: I&#39;m a lumberjack, and I&#39;m okay</span>
    <span class="na">I sleep all night and I work all day</span>

<span class="k">[No Values]</span>
<span class="na">key_without_value</span>
<span class="na">empty string value here</span> <span class="o">=</span>

<span class="k">[You can use comments]</span>
<span class="c1"># 이것처럼</span>
<span class="c1">; 또는 이것처럼</span>

<span class="c1"># 기본적으로 빈 줄에만 허용됩니다.</span>
<span class="c1"># 인라인 주석은 사용자가 구분 문자를 값의 일부로 사용하지 못하게 하므로 해로울 수 있습니다.</span>
<span class="c1"># 그러해도, 이것을 사용자 정의할 수 있습니다.</span>

    <span class="k">[Sections Can Be Indented]</span>
        <span class="na">can_values_be_as_well</span> <span class="o">=</span> <span class="s">True</span>
<span class="s">        does_that_mean_anything_special = False</span>
<span class="s">        purpose = formatting for readability</span>
<span class="s">        multiline_values = are</span>
<span class="s">            handled just fine as</span>
<span class="s">            long as they are indented</span>
<span class="s">            deeper than the first line</span>
<span class="s">            of a value</span>
<span class="s">        # 댓글도 들여 쓸 수 있다고 언급했나요?</span>
</pre></div>
</div>
</div>
<div class="section" id="interpolation-of-values">
<h2>값의 보간<a class="headerlink" href="#interpolation-of-values" title="제목 주소">¶</a></h2>
<p>핵심 기능 위에, <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConfigParser</span></code></a>는 보간(interpolation)을 지원합니다. 이는 <code class="docutils literal notranslate"><span class="pre">get()</span></code> 호출에서 값을 반환하기 전에 값을 전처리할 수 있음을 의미합니다.</p>
<span class="target" id="index-1"></span><dl class="class">
<dt id="configparser.BasicInterpolation">
<em class="property">class </em><code class="descclassname">configparser.</code><code class="descname">BasicInterpolation</code><a class="headerlink" href="#configparser.BasicInterpolation" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConfigParser</span></code></a>에서 사용되는 기본 구현. 같은 섹션의 다른 값이나 특수한 기본 섹션의 값을 참조하는 포맷 문자열을 포함하는 값을 사용할 수 있도록 합니다 <a class="footnote-reference" href="#id14" id="id9">[1]</a>. 초기화시 추가 기본값을 제공할 수 있습니다.</p>
<p>예를 들면:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Paths]</span>
<span class="na">home_dir: /Users</span>
<span class="na">my_dir: %(home_dir)s/lumberjack</span>
<span class="na">my_pictures: %(my_dir)s/Pictures</span>

<span class="k">[Escape]</span>
<span class="na">gain: 80%%  # %% 를 사용하여 % 기호를 이스케이프 합니다 (% 는 이스케이프 해야 하는 유일한 문자입니다)</span>
</pre></div>
</div>
<p>위의 예에서, <em>interpolation</em>이 <code class="docutils literal notranslate"><span class="pre">BasicInterpolation()</span></code>로 설정된 <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConfigParser</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">%(home_dir)s</span></code>를 <code class="docutils literal notranslate"><span class="pre">home_dir</span></code>의 값(이 경우 <code class="docutils literal notranslate"><span class="pre">/Users</span></code>)으로 해석합니다. 결과적으로 <code class="docutils literal notranslate"><span class="pre">%(my_dir)s</span></code>는 <code class="docutils literal notranslate"><span class="pre">/Users/lumberjack</span></code>로 해석됩니다. 모든 보간은 요청시 수행되므로 참조 체인에 사용된 키를 구성 파일에서 특정 순서로 지정할 필요는 없습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">interpolation</span></code>을 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정하면, 구문 분석기는 <code class="docutils literal notranslate"><span class="pre">my_pictures</span></code>의 값을 <code class="docutils literal notranslate"><span class="pre">%(my_dir)s/Pictures</span></code>로 , <code class="docutils literal notranslate"><span class="pre">my_dir</span></code>의 값을 <code class="docutils literal notranslate"><span class="pre">%(home_dir)s/lumberjack</span></code>으로 반환합니다.</p>
</dd></dl>

<span class="target" id="index-2"></span><dl class="class">
<dt id="configparser.ExtendedInterpolation">
<em class="property">class </em><code class="descclassname">configparser.</code><code class="descname">ExtendedInterpolation</code><a class="headerlink" href="#configparser.ExtendedInterpolation" title="정의 주소">¶</a></dt>
<dd><p>예를 들어 <code class="docutils literal notranslate"><span class="pre">zc.buildout</span></code>에서 사용되는 고급 문법을 구현하는 보간 대체 처리기. 확장 보간은 <code class="docutils literal notranslate"><span class="pre">${section:option}</span></code>을 사용하여 외부 섹션의 값을 나타냅니다. 보간은 여러 수준으로 확장 될 수 있습니다. 편의상, <code class="docutils literal notranslate"><span class="pre">section:</span></code> 부분을 생략하면, 보간은 현재 섹션(그리고 가능하면 특수 섹션의 기본값)으로 기본 설정됩니다.</p>
<p>예를 들어, 기본 보간으로 위에서 지정한 구성은, 확장 보간으로는 다음과 같습니다:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Paths]</span>
<span class="na">home_dir: /Users</span>
<span class="na">my_dir: ${home_dir}/lumberjack</span>
<span class="na">my_pictures: ${my_dir}/Pictures</span>

<span class="k">[Escape]</span>
<span class="na">cost: $$80  # $$ 를 사용하여 $ 기호를 이스케이프 합니다 ($ 는 이스케이프 해야 하는 유일한 문자입니다)</span>
</pre></div>
</div>
<p>다른 섹션의 값도 가져올 수 있습니다:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Common]</span>
<span class="na">home_dir: /Users</span>
<span class="na">library_dir: /Library</span>
<span class="na">system_dir: /System</span>
<span class="na">macports_dir: /opt/local</span>

<span class="k">[Frameworks]</span>
<span class="na">Python: 3.2</span>
<span class="na">path: ${Common:system_dir}/Library/Frameworks/</span>

<span class="k">[Arthur]</span>
<span class="na">nickname: Two Sheds</span>
<span class="na">last_name: Jackson</span>
<span class="na">my_dir: ${Common:home_dir}/twosheds</span>
<span class="na">my_pictures: ${my_dir}/Pictures</span>
<span class="na">python_dir: ${Frameworks:path}/Python/Versions/${Frameworks:Python}</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="mapping-protocol-access">
<h2>매핑 프로토콜 액세스<a class="headerlink" href="#mapping-protocol-access" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
<p>매핑 프로토콜 액세스는 사용자 정의 객체를 딕셔너리처럼 사용하는 기능의 일반적인 이름입니다. <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a>의 경우, 매핑 인터페이스 구현은 <code class="docutils literal notranslate"><span class="pre">parser['section']['option']</span></code> 표기법을 사용합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">parser['section']</span></code>은 특히 구문 분석기의 섹션 데이터에 대한 프락시를 반환합니다. 이는 값은 복사되지 않지만 필요할 때 원래 구문 분석기에서 가져옴을 뜻합니다. 더욱 중요한 것은 섹션 프락시에서 값이 변경되면, 실제로 원래 구문 분석기에서 변경된다는 것입니다.</p>
<p><a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a> 객체는 가능한 한 실제 딕셔너리에 가깝게 동작합니다. 매핑 인터페이스가 완전하며 <a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a> ABC를 준수합니다. 그러나, 고려해야 하는 몇 가지 차이점이 있습니다:</p>
<ul>
<li><p class="first">기본적으로, 섹션의 모든 키는 대소 문자를 구분하지 않고 액세스 할 수 있습니다 <a class="footnote-reference" href="#id14" id="id10">[1]</a>. 예를 들어 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">option</span> <span class="pre">in</span> <span class="pre">parser[&quot;section&quot;]</span></code>는 <code class="docutils literal notranslate"><span class="pre">optionxform</span></code> 변환된 옵션 키 이름만 산출합니다. 이것은 기본적으로 소문자 키를 의미합니다. 동시에, 키 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>를 보유하는 섹션의 경우, 두 표현식 모두 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="n">parser</span><span class="p">[</span><span class="s2">&quot;section&quot;</span><span class="p">]</span>
<span class="s2">&quot;A&quot;</span> <span class="ow">in</span> <span class="n">parser</span><span class="p">[</span><span class="s2">&quot;section&quot;</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first">모든 섹션에는 <code class="docutils literal notranslate"><span class="pre">DEFAULTSECT</span></code> 값도 포함되어 있는데, 섹션에 대한 <code class="docutils literal notranslate"><span class="pre">.clear()</span></code>가 섹션을 비어보이게 만들 수 없다는 뜻입니다. 이것은 섹션에서 기본값을 삭제할 수 없기 때문입니다 (기술적으로는 기본값이 거기 없기 때문입니다). 섹션에서 재정의되었으면, 삭제하면 기본값이 다시 보입니다. 기본값을 삭제하려고 하면 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>가 발생합니다.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">DEFAULTSECT</span></code>는 구문 분석기에서 제거할 수 없습니다:</p>
<ul class="simple">
<li>삭제하려고 하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다,</li>
<li><code class="docutils literal notranslate"><span class="pre">parser.clear()</span></code>는 이것을 그대로 남겨둡니다,</li>
<li><code class="docutils literal notranslate"><span class="pre">parser.popitem()</span></code>은 이것을 절대 반환하지 않습니다.</li>
</ul>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">parser.get(section,</span> <span class="pre">option,</span> <span class="pre">**kwargs)</span></code> - 두 번째 인자는 대체 값이 <strong>아닙니다</strong>. 그러나 섹션 수준 <code class="docutils literal notranslate"><span class="pre">get()</span></code> 메서드는 매핑 프로토콜과 클래식 configparser API와 모두 호환됨에 유의하십시오.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">parser.items()</span></code>는 매핑 프로토콜과 호환됩니다 (DEFAULTSECT를 포함하여 <em>section_name</em>, <em>section_proxy</em> 쌍의 리스트를 반환합니다). 그러나, 이 메서드는 인자와 함께 호출 할 수도 있습니다: <code class="docutils literal notranslate"><span class="pre">parser.items(section,</span> <span class="pre">raw,</span> <span class="pre">vars)</span></code>. 후자의 호출은 지정된 <code class="docutils literal notranslate"><span class="pre">section</span></code>에 대한 <em>option</em>, <em>value</em> 쌍의 리스트를 반환하며, 모든 보간이 확장됩니다 (<code class="docutils literal notranslate"><span class="pre">raw=True</span></code>가 제공되지 않는 한).</p>
</li>
</ul>
<p>매핑 프로토콜은 기존 레거시 API 위에 구현되므로 원래 인터페이스를 대정의하는 서브 클래스에서도 여전히 매핑이 작동해야합니다.</p>
</div>
<div class="section" id="customizing-parser-behaviour">
<h2>구문 분석기 동작 사용자 정의<a class="headerlink" href="#customizing-parser-behaviour" title="제목 주소">¶</a></h2>
<p>INI 형식을 사용하는 응용 프로그램만큼이나 많은 INI 형식 변형이 있습니다. <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a>는 사용 가능한 가장 큰 INI 스타일 집합을 지원하기 위해 먼 길을 갔습니다. 기본 기능은 주로 역사적 배경에 의해 결정되며 일부 기능을 사용자 정의하고싶을 가능성이 큽니다.</p>
<p>특정 구성 구문 분석기의 작동 방식을 변경하는 가장 흔한 방법은 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 옵션을 사용하는 것입니다:</p>
<ul>
<li><p class="first"><em>defaults</em>, 기본값: <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
<p>이 옵션은 처음에 <code class="docutils literal notranslate"><span class="pre">DEFAULT</span></code> 섹션에 배치될 키-값 쌍의 딕셔너리를 받아들입니다. 이것은 지정하지 않으면 설명된 기본값과 같은 값이 되는 간결한 구성 파일을 지원하는 우아한 방법입니다.</p>
<p>힌트: 특정 섹션에 대한 기본값을 지정하려면, 실제 파일을 읽기 전에 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read_dict()</span></code>를 사용하십시오.</p>
</li>
<li><p class="first"><em>dict_type</em>, 기본값: <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p>
<p>이 옵션은 매핑 프로토콜의 작동 방식과 기록된 구성 파일의 꼴에 큰 영향을 미칩니다. 표준 딕셔너리를 사용하면, 모든 섹션이 구문 분석기에 추가된 순서대로 저장됩니다. 섹션 내의 옵션도 마찬가지입니다.</p>
<p>대체 딕셔너리 형을 사용하여 예를 들어 다시 쓸 때 섹션과 옵션을 정렬할 수 있습니다.</p>
<p>참고: 단일 연산에서 키-값 쌍의 집합을 추가하는 방법이 있습니다. 이러한 연산에서 일반 딕셔너리를 사용하면 키 순서가 유지됩니다. 예를 들면:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">read_dict</span><span class="p">({</span><span class="s1">&#39;section1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;key1&#39;</span><span class="p">:</span> <span class="s1">&#39;value1&#39;</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="s1">&#39;key2&#39;</span><span class="p">:</span> <span class="s1">&#39;value2&#39;</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="s1">&#39;key3&#39;</span><span class="p">:</span> <span class="s1">&#39;value3&#39;</span><span class="p">},</span>
<span class="gp">... </span>                  <span class="s1">&#39;section2&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;keyA&#39;</span><span class="p">:</span> <span class="s1">&#39;valueA&#39;</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="s1">&#39;keyB&#39;</span><span class="p">:</span> <span class="s1">&#39;valueB&#39;</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="s1">&#39;keyC&#39;</span><span class="p">:</span> <span class="s1">&#39;valueC&#39;</span><span class="p">},</span>
<span class="gp">... </span>                  <span class="s1">&#39;section3&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span>
<span class="gp">... </span>                               <span class="s1">&#39;baz&#39;</span><span class="p">:</span> <span class="s1">&#39;z&#39;</span><span class="p">}</span>
<span class="gp">... </span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
<span class="go">[&#39;section1&#39;, &#39;section2&#39;, &#39;section3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">option</span> <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">parser</span><span class="p">[</span><span class="s1">&#39;section3&#39;</span><span class="p">]]</span>
<span class="go">[&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]</span>
</pre></div>
</div>
</li>
<li><p class="first"><em>allow_no_value</em>, 기본값: <code class="docutils literal notranslate"><span class="pre">False</span></code></p>
<p>일부 구성 파일에는 값이 없는 설정이 포함되어 있지만, 그 외에는 <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a>에서 지원하는 구문을 준수하는 것으로 알려져 있습니다. 생성자에 대한 <em>allow_no_value</em> 매개 변수를 사용하여 이러한 값을 받아들여야 함을 표시할 수 있습니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">configparser</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sample_config</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="gp">... </span><span class="s2">[mysqld]</span>
<span class="gp">... </span><span class="s2">  user = mysql</span>
<span class="gp">... </span><span class="s2">  pid-file = /var/run/mysqld/mysqld.pid</span>
<span class="gp">... </span><span class="s2">  skip-external-locking</span>
<span class="gp">... </span><span class="s2">  old_passwords = 1</span>
<span class="gp">... </span><span class="s2">  skip-bdb</span>
<span class="gp">... </span><span class="s2">  # we don&#39;t need ACID today</span>
<span class="gp">... </span><span class="s2">  skip-innodb</span>
<span class="gp">... </span><span class="s2">&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">(</span><span class="n">allow_no_value</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">read_string</span><span class="p">(</span><span class="n">sample_config</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 값이 있는 설정은 이전처럼 처리됩니다:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;mysqld&quot;</span><span class="p">][</span><span class="s2">&quot;user&quot;</span><span class="p">]</span>
<span class="go">&#39;mysql&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 값이 없는 설정은 None을 제공합니다:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;mysqld&quot;</span><span class="p">][</span><span class="s2">&quot;skip-bdb&quot;</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 지정되지 않은 설정은 여전히 에러를 발생시킵니다:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;mysqld&quot;</span><span class="p">][</span><span class="s2">&quot;does-not-exist&quot;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">KeyError</span>: <span class="n">&#39;does-not-exist&#39;</span>
</pre></div>
</div>
</li>
<li><p class="first"><em>delimiters</em>, 기본값: <code class="docutils literal notranslate"><span class="pre">('=',</span> <span class="pre">':')</span></code></p>
<p>구분자(delimiters)는 섹션 내의 값에서 키를 구분하는 부분 문자열입니다. 줄에서 처음 나타나는 구분하는 부분 문자열을 구분자로 간주합니다. 이는 값에 (하지만 키는 아닙니다) 구분자가 포함될 수 있음을 의미합니다.</p>
<p><a class="reference internal" href="#configparser.ConfigParser.write" title="configparser.ConfigParser.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ConfigParser.write()</span></code></a>에 대한 <em>space_around_delimiters</em> 인자도 참조하십시오.</p>
</li>
<li><p class="first"><em>comment_prefixes</em>, 기본값: <code class="docutils literal notranslate"><span class="pre">('#',</span> <span class="pre">';')</span></code></p>
</li>
<li><p class="first"><em>inline_comment_prefixes</em>, 기본값 : <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
<p>주석 접두사는 구성 파일 내에서 유효한 주석의 시작을 나타내는 문자열입니다. <em>comment_prefixes</em>는 주석이 없으면 빈 줄일 때만 (선택적으로 들여쓰기됩니다) 사용되는 반면  <em>inline_comment_prefixes</em>는 모든 유효한 값 (예를 들어 섹션 이름, 옵션 및 빈 줄 역시) 뒤에 사용될 수 있습니다. 기본적으로 인라인 주석은 비활성화되어 있으며 <code class="docutils literal notranslate"><span class="pre">'#'</span></code>과 <code class="docutils literal notranslate"><span class="pre">';'</span></code>이 전체 줄 주석의 접두사로 사용됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a>의 이전 버전에서는 동작이 <code class="docutils literal notranslate"><span class="pre">comment_prefixes=('#',';')</span></code>와 <code class="docutils literal notranslate"><span class="pre">inline_comment_prefixes=(';',)</span></code>와 일치했습니다.</p>
</div>
<p>구성 구문 분석기는 주석 접두사 이스케이프를 지원하지 않으므로 <em>inline_comment_prefixes</em>를 사용하면 사용자가 주석 접두사로 사용되는 문자로 옵션 값을 지정하지 못할 수 있습니다. 확실하지 않으면, <em>inline_comment_prefixes</em>를 설정하지 마십시오. 어떤 상황에서든, 여러 줄 값에서 줄의 시작 부분에 주석 접두사 문자를 저장하는 유일한 방법은 접두사를 보간하는 것입니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">configparser</span> <span class="k">import</span> <span class="n">ConfigParser</span><span class="p">,</span> <span class="n">ExtendedInterpolation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="p">(</span><span class="n">interpolation</span><span class="o">=</span><span class="n">ExtendedInterpolation</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 기본 BasicInterpolation 도 사용될 수 있습니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">read_string</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="gp">... </span><span class="s2">[DEFAULT]</span>
<span class="gp">... </span><span class="s2">hash = #</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">[hashes]</span>
<span class="gp">... </span><span class="s2">shebang =</span>
<span class="gp">... </span><span class="s2">  $</span><span class="si">{hash}</span><span class="s2">!/usr/bin/env python</span>
<span class="gp">... </span><span class="s2">  $</span><span class="si">{hash}</span><span class="s2"> -*- coding: utf-8 -*-</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">extensions =</span>
<span class="gp">... </span><span class="s2">  enabled_extension</span>
<span class="gp">... </span><span class="s2">  another_extension</span>
<span class="gp">... </span><span class="s2">  #disabled_by_comment</span>
<span class="gp">... </span><span class="s2">  yet_another_extension</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">interpolation not necessary = if # is not at line start</span>
<span class="gp">... </span><span class="s2">even in multiline values = line #1</span>
<span class="gp">... </span><span class="s2">  line #2</span>
<span class="gp">... </span><span class="s2">  line #3</span>
<span class="gp">... </span><span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">parser</span><span class="p">[</span><span class="s1">&#39;hashes&#39;</span><span class="p">][</span><span class="s1">&#39;shebang&#39;</span><span class="p">])</span>

<span class="go">#!/usr/bin/env python</span>
<span class="go"># -*- coding: utf-8 -*-</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">parser</span><span class="p">[</span><span class="s1">&#39;hashes&#39;</span><span class="p">][</span><span class="s1">&#39;extensions&#39;</span><span class="p">])</span>

<span class="go">enabled_extension</span>
<span class="go">another_extension</span>
<span class="go">yet_another_extension</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">parser</span><span class="p">[</span><span class="s1">&#39;hashes&#39;</span><span class="p">][</span><span class="s1">&#39;interpolation not necessary&#39;</span><span class="p">])</span>
<span class="go">if # is not at line start</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">parser</span><span class="p">[</span><span class="s1">&#39;hashes&#39;</span><span class="p">][</span><span class="s1">&#39;even in multiline values&#39;</span><span class="p">])</span>
<span class="go">line #1</span>
<span class="go">line #2</span>
<span class="go">line #3</span>
</pre></div>
</div>
</li>
<li><p class="first"><em>strict</em>, 기본값: <code class="docutils literal notranslate"><span class="pre">True</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정하면, 구문 분석기는 단일 소스에서 읽는 (<code class="xref py py-meth docutils literal notranslate"><span class="pre">read_file()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">read_string()</span></code> 또는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read_dict()</span></code>를 사용해서) 동안 섹션이나 옵션 중복을 허용하지 않습니다. 새로운 응용 프로그램에서는 엄격한(strict) 구문 분석기를 사용하는 것이 좋습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a>의 이전 버전에서는 동작이 <code class="docutils literal notranslate"><span class="pre">strict=False</span></code>와 일치했습니다.</p>
</div>
</li>
<li><p class="first"><em>empty_lines_in_values</em>, 기본값: <code class="docutils literal notranslate"><span class="pre">True</span></code></p>
<p>구성 구문 분석기에서는, 값을 담는 키보다 많이 들여쓰기 만하면 값이 여러 줄에 걸쳐있을 수 있습니다. 기본적으로 구문 분석기는 빈 줄도 값의 일부가 되도록 합니다. 동시에, 가독성을 높이기 위해 키를 임의로 들여 쓸 수 있습니다. 결과적으로, 구성 파일이 커지고 복잡해지면, 사용자가 파일 구조를 쉽게 놓칠 수 있습니다. 예를 들어 봅시다:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Section]</span>
<span class="na">key</span> <span class="o">=</span> <span class="s">multiline</span>
<span class="s">  value with a gotcha</span>

 <span class="na">this</span> <span class="o">=</span> <span class="s">is still a part of the multiline value of &#39;key&#39;</span>
</pre></div>
</div>
<p>이것은 사용자가 가변폭 글꼴을 사용하여 파일을 편집하고 있다면 보는데 특히 문제가 될 수 있습니다. 따라서 응용 프로그램에 빈 줄이 있는 값이 필요하지 않으면, 허용하지 않는 것이 좋습니다. 이렇게하면 빈 줄이 매번 키를 분리합니다. 위의 예에서는, <code class="docutils literal notranslate"><span class="pre">key</span></code>와 <code class="docutils literal notranslate"><span class="pre">this</span></code>의 두 키를 생성합니다.</p>
</li>
<li><p class="first"><em>default_section</em>, 기본값: <code class="docutils literal notranslate"><span class="pre">configparser.DEFAULTSECT</span></code> (즉: <code class="docutils literal notranslate"><span class="pre">&quot;DEFAULT&quot;</span></code>)</p>
<p>다른 섹션이나 보간 목적으로 기본값의 특수한 섹션을 허용하는 규칙은 이 라이브러리의 강력한 개념으로, 사용자로 하여금 복잡한 선언적 구성을 만들 수 있도록 합니다. 이 섹션은 일반적으로 <code class="docutils literal notranslate"><span class="pre">&quot;DEFAULT&quot;</span></code>라고하지만 다른 유효한 섹션 이름을 가리키도록 사용자 정의할 수 있습니다. 몇가지 흔한 값은 이렇습니다: <code class="docutils literal notranslate"><span class="pre">&quot;general&quot;</span></code>이나 <code class="docutils literal notranslate"><span class="pre">&quot;common&quot;</span></code>. 제공된 이름은 모든 소스에서 읽을 때 기본값 섹션을 인식하는 데 사용되며 구성을 파일에 다시 쓸 때 사용됩니다. 현재 값은 <code class="docutils literal notranslate"><span class="pre">parser_instance.default_section</span></code> 어트리뷰트를 사용하여 꺼낼 수 있으며 실행 시간에 수정될 수 있습니다 (즉 파일을 한 형식에서 다른 형식으로 변환하기위해).</p>
</li>
<li><p class="first"><em>interpolation</em>, 기본값: <code class="docutils literal notranslate"><span class="pre">configparser.BasicInterpolation</span></code></p>
<p><em>interpolation</em> 인자를 통해 사용자 정의 처리기를 제공하여 보간 동작을 사용자 정의할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">None</span></code>은 보간을 완전히 끄는 데 사용할 수 있으며, <code class="docutils literal notranslate"><span class="pre">ExtendedInterpolation()</span></code>은 <code class="docutils literal notranslate"><span class="pre">zc.buildout</span></code>에서 영감을 얻은 고급 변형을 제공합니다. 이 주제에 관한 자세한 내용은 <a class="reference external" href="#interpolation-of-values">전용 설명서 섹션</a>에 있습니다. <a class="reference internal" href="#configparser.RawConfigParser" title="configparser.RawConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">RawConfigParser</span></code></a>의 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다.</p>
</li>
<li><p class="first"><em>converters</em>, 기본값: 설정되지 않음</p>
<p>구성 구문 분석기는 형 변환을 수행하는 옵션 값 게터를 제공합니다. 기본적으로 <a class="reference internal" href="#configparser.ConfigParser.getint" title="configparser.ConfigParser.getint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getint()</span></code></a>, <a class="reference internal" href="#configparser.ConfigParser.getfloat" title="configparser.ConfigParser.getfloat"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getfloat()</span></code></a> 및 <a class="reference internal" href="#configparser.ConfigParser.getboolean" title="configparser.ConfigParser.getboolean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getboolean()</span></code></a>가 구현됩니다. 다른 게터가 바람직하다면, 사용자는 그것들을 서브 클래스에 정의하거나 각 키가 변환기의 이름이고 각 값이 이 변환을 구현하는 콜러블인 딕셔너리를 전달할 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">{'decimal':</span> <span class="pre">decimal.Decimal}</span></code>을 전달하면 구문 분석기 객체와 모든 섹션 프락시 모두에 <code class="xref py py-meth docutils literal notranslate"><span class="pre">getdecimal()</span></code>이 추가됩니다. 즉, <code class="docutils literal notranslate"><span class="pre">parser_instance.getdecimal('section',</span> <span class="pre">'key',</span> <span class="pre">fallback=0)</span></code>과 <code class="docutils literal notranslate"><span class="pre">parser_instance['section'].getdecimal('key',</span> <span class="pre">0)</span></code>을 모두 쓸 수 있습니다.</p>
<p>변환기가 구문 분석기의 상태에 액세스해야하면, 구성 구문 분석기 서브 클래스에서 메서드로 구현될 수 있습니다. 이 메서드의 이름이 <code class="docutils literal notranslate"><span class="pre">get</span></code>으로 시작하면, 모든 섹션 프락시에서 dict 호환 형식으로 사용할 수 있습니다 (위의 <code class="docutils literal notranslate"><span class="pre">getdecimal()</span></code> 예를 참조하십시오).</p>
</li>
</ul>
<p>이러한 구문 분석기 어트리뷰트의 기본값을 재정의하여 더 고급 사용자 정의를 수행할 수 있습니다. 기본값은 클래스에서 정의되므로, 서브 클래스나 어트리뷰트 대입으로 재정의할 수 있습니다.</p>
<dl class="attribute">
<dt id="configparser.ConfigParser.BOOLEAN_STATES">
<code class="descclassname">ConfigParser.</code><code class="descname">BOOLEAN_STATES</code><a class="headerlink" href="#configparser.ConfigParser.BOOLEAN_STATES" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#configparser.ConfigParser.getboolean" title="configparser.ConfigParser.getboolean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getboolean()</span></code></a>을 사용할 때 기본적으로, 구성 구문 분석기는 다음 값들을 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 간주하고: <code class="docutils literal notranslate"><span class="pre">'1'</span></code>, <code class="docutils literal notranslate"><span class="pre">'yes'</span></code>, <code class="docutils literal notranslate"><span class="pre">'true'</span></code>, <code class="docutils literal notranslate"><span class="pre">'on'</span></code> 다음 값들을 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 간주합니다: <code class="docutils literal notranslate"><span class="pre">'0'</span></code>, <code class="docutils literal notranslate"><span class="pre">'no'</span></code>, <code class="docutils literal notranslate"><span class="pre">'false'</span></code>, <code class="docutils literal notranslate"><span class="pre">'off'</span></code>. 문자열과 불리언 결과를 사용자 정의 딕셔너리로 지정하여 이를 재정의할 수 있습니다. 예를 들면:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="p">[</span><span class="s1">&#39;section1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;funky&#39;</span><span class="p">:</span> <span class="s1">&#39;nope&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="p">[</span><span class="s1">&#39;section1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">&#39;funky&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Not a boolean: nope</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="o">.</span><span class="n">BOOLEAN_STATES</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sure&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="s1">&#39;nope&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="p">[</span><span class="s1">&#39;section1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">&#39;funky&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>다른 일반적인 불리언 쌍에는 <code class="docutils literal notranslate"><span class="pre">accept</span></code>/<code class="docutils literal notranslate"><span class="pre">reject</span></code>나 <code class="docutils literal notranslate"><span class="pre">enabled</span></code>/<code class="docutils literal notranslate"><span class="pre">disabled</span></code>가 포함됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.optionxform">
<code class="descclassname">ConfigParser.</code><code class="descname">optionxform</code><span class="sig-paren">(</span><em>option</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.optionxform" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 모든 읽기, get 또는 set 연산에서 옵션 이름을 변환합니다. 기본값은 이름을 소문자로 변환합니다. 이는 또한 구성 파일을 기록할 때 모든 키가 소문자가 됨을 의미합니다. 이것이 부적절하다면 이 메서드를 재정의하십시오. 예를 들면:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">config</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="gp">... </span><span class="s2">[Section1]</span>
<span class="gp">... </span><span class="s2">Key = Value</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">[Section2]</span>
<span class="gp">... </span><span class="s2">AnotherKey = Value</span>
<span class="gp">... </span><span class="s2">&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typical</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typical</span><span class="o">.</span><span class="n">read_string</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">typical</span><span class="p">[</span><span class="s1">&#39;Section1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;key&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">typical</span><span class="p">[</span><span class="s1">&#39;Section2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;anotherkey&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">RawConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="o">.</span><span class="n">optionxform</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">option</span><span class="p">:</span> <span class="n">option</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="o">.</span><span class="n">read_string</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">custom</span><span class="p">[</span><span class="s1">&#39;Section1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;Key&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">custom</span><span class="p">[</span><span class="s1">&#39;Section2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;AnotherKey&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">optionxform 함수는 옵션 이름을 규범적 형식으로 변환합니다. 이 함수는 멱등(idempotent) 함수여야 합니다: 이름이 이미 규범적 형식이면, 변경되지 않은 상태로 반환해야합니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="configparser.ConfigParser.SECTCRE">
<code class="descclassname">ConfigParser.</code><code class="descname">SECTCRE</code><a class="headerlink" href="#configparser.ConfigParser.SECTCRE" title="정의 주소">¶</a></dt>
<dd><p>섹션 헤더를 구문 분석하는 데 사용되는 컴파일된 정규식. 기본값은 <code class="docutils literal notranslate"><span class="pre">[section]</span></code>을 이름 <code class="docutils literal notranslate"><span class="pre">&quot;section&quot;</span></code>과 일치시킵니다. 공백은 섹션 이름의 일부로 간주되어서, <code class="docutils literal notranslate"><span class="pre">[</span>&#160; <span class="pre">larch</span>&#160; <span class="pre">]</span></code>는 이름이 <code class="docutils literal notranslate"><span class="pre">&quot;</span>&#160; <span class="pre">larch</span>&#160; <span class="pre">&quot;</span></code>인 섹션으로 읽힙니다. 이것이 부적절하다면 이 어트리뷰트를 재정의하십시오. 예를 들면:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="gp">... </span><span class="s2">[Section 1]</span>
<span class="gp">... </span><span class="s2">option = value</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">[  Section 2  ]</span>
<span class="gp">... </span><span class="s2">another = val</span>
<span class="gp">... </span><span class="s2">&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typical</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typical</span><span class="o">.</span><span class="n">read_string</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typical</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
<span class="go">[&#39;Section 1&#39;, &#39;  Section 2  &#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="o">.</span><span class="n">SECTCRE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\[ *(?P&lt;header&gt;[^]]+?) *\]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="o">.</span><span class="n">read_string</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">custom</span><span class="o">.</span><span class="n">sections</span><span class="p">()</span>
<span class="go">[&#39;Section 1&#39;, &#39;Section 2&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">ConfigParser 객체는 옵션 줄을 인식하기 위해 <code class="docutils literal notranslate"><span class="pre">OPTCRE</span></code> 어트리뷰트도 사용하지만, 생성자 옵션 <em>allow_no_value</em>와 <em>delimiters</em>를 방해하기 때문에 재정의하지 않는 것이 좋습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="legacy-api-examples">
<h2>레거시 API 예제<a class="headerlink" href="#legacy-api-examples" title="제목 주소">¶</a></h2>
<p>주로 이전 버전과의 호환성 문제로 인해, <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a>는 명시적인 <code class="docutils literal notranslate"><span class="pre">get</span></code>/<code class="docutils literal notranslate"><span class="pre">set</span></code> 메서드로 레거시 API도 제공합니다. 아래에 설명된 메서드에 대한 유효한 사용 사례가 있지만, 새 프로젝트에는 매핑 프로토콜 액세스가 선호됩니다. 레거시 API는 때때로 더 고급이고, 저수준이며 완전히 반 직관적입니다.</p>
<p>구성 파일에 쓰는 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">configparser</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">RawConfigParser</span><span class="p">()</span>

<span class="c1"># RawConfigParser 의 set 함수를 사용하면, 문자열이 아닌 값을 키에 내부적으로 대입할 수 있지만,</span>
<span class="c1"># 파일에 쓰려고 할 때나 비 원시 모드로 가져올 때 에러가 발생함에 유의하십시오. 매핑 프로토콜이나</span>
<span class="c1"># ConfigParser의 set()을 사용하여 값을 설정하면 이러한 대입이 허용되지 않습니다.</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;an_int&#39;</span><span class="p">,</span> <span class="s1">&#39;15&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;a_bool&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;a_float&#39;</span><span class="p">,</span> <span class="s1">&#39;3.1415&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;Python&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%(bar)s</span><span class="s1"> is </span><span class="si">%(baz)s</span><span class="s1">!&#39;</span><span class="p">)</span>

<span class="c1"># 구성 파일을 &#39;example.cfg&#39;에 기록하기</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;example.cfg&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">configfile</span><span class="p">:</span>
    <span class="n">config</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">configfile</span><span class="p">)</span>
</pre></div>
</div>
<p>구성 파일을 다시 읽는 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">configparser</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">RawConfigParser</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;example.cfg&#39;</span><span class="p">)</span>

<span class="c1"># 값이 float가 아니면 getfloat()는 예외를 발생시킵니다</span>
<span class="c1"># getint()와 getboolean() 또한 해당 유형에 대해 이렇게 합니다</span>
<span class="n">a_float</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;a_float&#39;</span><span class="p">)</span>
<span class="n">an_int</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getint</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;an_int&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a_float</span> <span class="o">+</span> <span class="n">an_int</span><span class="p">)</span>

<span class="c1"># 다음 출력은 &#39;%(bar)s&#39; 나 &#39;%(baz)s&#39; 를 보간하지 않음에 유의하십시오.</span>
<span class="c1"># RawConfigParser() 를 사용하고 있기 때문입니다.</span>
<span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;a_bool&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>보간을 얻으려면, <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConfigParser</span></code></a>를 사용하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">configparser</span>

<span class="n">cfg</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="n">cfg</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;example.cfg&#39;</span><span class="p">)</span>

<span class="c1"># 단일 get 연산에서 보간을 사용하지 않으려면 get()의 선택적 *raw* 인자를 True로 설정하십시오.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>  <span class="c1"># -&gt; &quot;Python is fun!&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>   <span class="c1"># -&gt; &quot;%(bar)s is %(baz)s!&quot;</span>

<span class="c1"># 선택적 *vars* 인자는 보간에서 우선하는 멤버가 포함된 dict입니다.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="nb">vars</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="s1">&#39;Documentation&#39;</span><span class="p">,</span>
                                       <span class="s1">&#39;baz&#39;</span><span class="p">:</span> <span class="s1">&#39;evil&#39;</span><span class="p">}))</span>

<span class="c1"># 선택적 *fallback* 인자를 사용하여 대체 값을 제공할 수 있습니다.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">))</span>
      <span class="c1"># -&gt; &quot;Python is fun!&quot;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="s1">&#39;Monty is not.&#39;</span><span class="p">))</span>
      <span class="c1"># -&gt; &quot;Python is fun!&quot;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;monster&#39;</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="s1">&#39;No such things as monsters.&#39;</span><span class="p">))</span>
      <span class="c1"># -&gt; &quot;No such things as monsters.&quot;</span>

<span class="c1"># print(cfg.get(&#39;Section1&#39;, &#39;monster&#39;)) 만은 NoOptionError 를 발생시킵니다</span>
<span class="c1"># 하지만 이렇게 사용할 수도 있습니다:</span>

<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;monster&#39;</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
      <span class="c1"># -&gt; None</span>
</pre></div>
</div>
<p>기본값은 두 가지 유형의 ConfigParser 모두에서 사용할 수 있습니다. 사용된 옵션이 다른 곳에 정의되어 있지 않으면 보간에 사용됩니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">configparser</span>

<span class="c1"># &#39;bar&#39;와 &#39;baz&#39;의 기본값이 각각 &#39;Life&#39;와 &#39;hard&#39;인 새 인스턴스</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">({</span><span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="s1">&#39;Life&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">:</span> <span class="s1">&#39;hard&#39;</span><span class="p">})</span>
<span class="n">config</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;example.cfg&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">))</span>     <span class="c1"># -&gt; &quot;Python is fun!&quot;</span>
<span class="n">config</span><span class="o">.</span><span class="n">remove_option</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">remove_option</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Section1&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">))</span>     <span class="c1"># -&gt; &quot;Life is hard!&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="configparser-objects">
<span id="id11"></span><h2>ConfigParser 객체<a class="headerlink" href="#configparser-objects" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="configparser.ConfigParser">
<em class="property">class </em><code class="descclassname">configparser.</code><code class="descname">ConfigParser</code><span class="sig-paren">(</span><em>defaults=None</em>, <em>dict_type=dict</em>, <em>allow_no_value=False</em>, <em>delimiters=('='</em>, <em>':')</em>, <em>comment_prefixes=('#'</em>, <em>';')</em>, <em>inline_comment_prefixes=None</em>, <em>strict=True</em>, <em>empty_lines_in_values=True</em>, <em>default_section=configparser.DEFAULTSECT</em>, <em>interpolation=BasicInterpolation()</em>, <em>converters={}</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser" title="정의 주소">¶</a></dt>
<dd><p>메인 구성 구문 분석기. <em>defaults</em>가 주어지면, 내장 기본값의 딕셔너리로 초기화됩니다. <em>dict_type</em>이 제공되면, 섹션 리스트, 섹션 내의 옵션 및 기본값에 대한 딕셔너리 객체를 만드는 데 사용됩니다.</p>
<p><em>delimiters</em>가 주어지면, 키를 값과 나누는 부분 문자열 집합으로 사용됩니다. <em>comment_prefixes</em>가 주어지면, 주석이 없다면 빈 줄일 곳에서 주석을 시작하는 접두사의 부분 문자열 집합으로 사용됩니다. 주석은 들여 쓸 수 있습니다. <em>inline_comment_prefixes</em>가 주어지면, 비어 있지 않은 줄에서 주석을 시작하는 접두사의 부분 문자열 집합으로 사용됩니다.</p>
<p><em>strict</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>(기본값)이면, 구문 분석기는 단일 소스(파일, 문자열 또는 딕셔너리)에서 읽는 동안 섹션이나 옵션의 중복을 허용하지 않고, <a class="reference internal" href="#configparser.DuplicateSectionError" title="configparser.DuplicateSectionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DuplicateSectionError</span></code></a>나 <a class="reference internal" href="#configparser.DuplicateOptionError" title="configparser.DuplicateOptionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DuplicateOptionError</span></code></a>를 발생시킵니다. <em>empty_lines_in_values</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면 (기본값: <code class="docutils literal notranslate"><span class="pre">True</span></code>), 각 빈 줄은 옵션의 끝을 나타냅니다. 그렇지 않으면, 여러 줄 옵션의 내부 빈 줄이 값의 일부로 유지됩니다. <em>allow_no_value</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면 (기본값: <code class="docutils literal notranslate"><span class="pre">False</span></code>), 값이 없는 옵션이 허용됩니다; 이들에 대해 저장되는 값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>이며 후행 구분자 없이 직렬화됩니다.</p>
<p><em>default_section</em>이 주어지면, 다른 섹션과 보간 목적의 기본값을 담는 특수한 섹션의 이름을 지정합니다 (보통 <code class="docutils literal notranslate"><span class="pre">&quot;DEFAULT&quot;</span></code>라는 이름). 이 값은 <code class="docutils literal notranslate"><span class="pre">default_section</span></code> 인스턴스 어트리뷰트를 사용하여 실행시간에 꺼내고 변경할 수 있습니다.</p>
<p><em>interpolation</em> 인자를 통해 사용자 정의 처리기를 제공하여 보간 동작을 사용자 정의할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">None</span></code>은 보간을 완전히 끄는 데 사용할 수 있으며, <code class="docutils literal notranslate"><span class="pre">ExtendedInterpolation()</span></code>은 <code class="docutils literal notranslate"><span class="pre">zc.buildout</span></code>에서 영감을 얻은 고급 변형을 제공합니다. 이 주제에 관한 자세한 내용은 <a class="reference external" href="#interpolation-of-values">전용 설명서 섹션</a>에 있습니다.</p>
<p>보간에 사용된 모든 옵션 이름은 다른 옵션 이름 참조와 마찬가지로 <a class="reference internal" href="#configparser.ConfigParser.optionxform" title="configparser.ConfigParser.optionxform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">optionxform()</span></code></a> 메서드를 통해 전달됩니다. 예를 들어, (옵션 이름을 소문자로 변환하는) <a class="reference internal" href="#configparser.ConfigParser.optionxform" title="configparser.ConfigParser.optionxform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">optionxform()</span></code></a>의 기본 구현을 사용하면, 값 <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">%(bar)s</span></code>와 <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">%(BAR)s</span></code>가 동등합니다.</p>
<p><em>converters</em>가 주어지면, 각 키는 형 변환기의 이름을 나타내고 각 값은 문자열에서 원하는 데이터 형으로의 변환을 구현하는 콜러블인 딕셔너리이어야합니다. 모든 변환기는 구문 분석기 객체와 섹션 프락시에서 자신만의 해당 <code class="xref py py-meth docutils literal notranslate"><span class="pre">get*()</span></code> 메서드를 갖습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.1으로 변경: </span>기본 <em>dict_type</em>은 <a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a>입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><em>allow_no_value</em>, <em>delimiters</em>, <em>comment_prefixes</em>, <em>strict</em>, <em>empty_lines_in_values</em>, <em>default_section</em> 및 <em>interpolation</em>이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span><em>converters</em> 인자가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>defaults</em> 인자는 <a class="reference internal" href="#configparser.ConfigParser.read_dict" title="configparser.ConfigParser.read_dict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_dict()</span></code></a>로 읽혀, 구문 분석기 전체에 일관된 동작을 제공합니다: 문자열이 아닌 키와 값은 묵시적으로 문자열로 변환됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.8으로 변경: </span>이제 삽입 순서를 유지하므로, 기본 <em>dict_type</em>은 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>입니다.</p>
</div>
<dl class="method">
<dt id="configparser.ConfigParser.defaults">
<code class="descname">defaults</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.defaults" title="정의 주소">¶</a></dt>
<dd><p>인스턴스 전체 기본값을 포함하는 딕셔너리를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.sections">
<code class="descname">sections</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.sections" title="정의 주소">¶</a></dt>
<dd><p>사용 가능한 섹션 리스트를 반환합니다; <em>기본값 섹션</em>은 리스트에 포함되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.add_section">
<code class="descname">add_section</code><span class="sig-paren">(</span><em>section</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.add_section" title="정의 주소">¶</a></dt>
<dd><p><em>section</em>이라는 섹션을 인스턴스에 추가합니다. 주어진 이름의 섹션이 이미 존재하면, <a class="reference internal" href="#configparser.DuplicateSectionError" title="configparser.DuplicateSectionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DuplicateSectionError</span></code></a>가 발생합니다. <em>기본값 섹션</em> 이름이 전달되면, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 섹션의 이름은 문자열이어야 합니다; 그렇지 않으면, <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>문자열이 아닌 섹션 이름은 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.has_section">
<code class="descname">has_section</code><span class="sig-paren">(</span><em>section</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.has_section" title="정의 주소">¶</a></dt>
<dd><p>이름 지정된 <em>section</em>이 구성에 있는지를 나타냅니다. <em>기본값 섹션</em>은 인정되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.options">
<code class="descname">options</code><span class="sig-paren">(</span><em>section</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.options" title="정의 주소">¶</a></dt>
<dd><p>지정된 <em>section</em>에서 사용 가능한 옵션 리스트를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.has_option">
<code class="descname">has_option</code><span class="sig-paren">(</span><em>section</em>, <em>option</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.has_option" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>section</em>이 존재하고, 주어진 <em>option</em>을 포함하면, <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다; 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다. 지정된 <em>section</em>이 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>이거나 빈 문자열이면, DEFAULT로 가정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>filenames</em>, <em>encoding=None</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.read" title="정의 주소">¶</a></dt>
<dd><p>파일명들의 이터러블을 읽고 구문 분석하여, 성공적으로 구문 분석된 파일명의 리스트를 반환합니다.</p>
<p><em>filenames</em>가 문자열, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체 또는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>이면 단일 파일명으로 처리됩니다. <em>filenames</em>에서 이름 지정된 파일을 열 수 없으면, 해당 파일은 무시됩니다. 이는 잠재적인 구성 파일 위치(예를 들어, 현재 디렉터리, 사용자의 홈 디렉터리 및 일부 시스템 전체 디렉터리)의 이터러블을 지정할 수 있도록 설계되었으며, 이터러블에 있는 존재하는 모든 구성 파일을 읽습니다.</p>
<p>제공된 이름의 파일이 아무것도 없으면, <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConfigParser</span></code></a> 인스턴스는 빈 데이터 집합을 포함합니다. 파일에서 초기 값을 로드해야하는 응용 프로그램은 선택적 파일에 대해 <a class="reference internal" href="#configparser.ConfigParser.read" title="configparser.ConfigParser.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>를 호출하기 전에 <a class="reference internal" href="#configparser.ConfigParser.read_file" title="configparser.ConfigParser.read_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_file()</span></code></a>을 사용하여 필수 파일을 로드해야합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">configparser</span><span class="o">,</span> <span class="nn">os</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">configparser</span><span class="o">.</span><span class="n">ConfigParser</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;defaults.cfg&#39;</span><span class="p">))</span>
<span class="n">config</span><span class="o">.</span><span class="n">read</span><span class="p">([</span><span class="s1">&#39;site.cfg&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~/.myapp.cfg&#39;</span><span class="p">)],</span>
            <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;cp1250&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span><em>encoding</em> 매개 변수. 이전에는, <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>의 기본 인코딩을 사용하여 모든 파일을 읽었습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6.1에 추가: </span><em>filenames</em> 매개 변수는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><em>filenames</em> 매개 변수는 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.read_file">
<code class="descname">read_file</code><span class="sig-paren">(</span><em>f</em>, <em>source=None</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.read_file" title="정의 주소">¶</a></dt>
<dd><p><em>f</em>에서 구성 데이터를 읽고 구문 분석합니다. <em>f</em>는 유니 코드 문자열을 산출하는 이터러블이어야 합니다 (예를 들어 텍스트 모드로 열린 파일).</p>
<p>선택적 인자 <em>source</em>는 읽을 파일의 이름을 지정합니다. 지정하지 않고 <em>f</em>에 <code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code> 어트리뷰트가 있으면, 이것이 <em>source</em>로 사용됩니다; 기본값은 <code class="docutils literal notranslate"><span class="pre">'&lt;???&gt;'</span></code>입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span><a class="reference internal" href="#configparser.ConfigParser.readfp" title="configparser.ConfigParser.readfp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readfp()</span></code></a>를 대체합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.read_string">
<code class="descname">read_string</code><span class="sig-paren">(</span><em>string</em>, <em>source='&lt;string&gt;'</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.read_string" title="정의 주소">¶</a></dt>
<dd><p>문자열에서 구성 데이터를 구문 분석합니다.</p>
<p>선택적 인자 <em>source</em>는 전달된 string의 문맥 특정 이름을 지정합니다. 지정하지 않으면, <code class="docutils literal notranslate"><span class="pre">'&lt;string&gt;'</span></code>이 사용됩니다. 일반적으로 파일 시스템 경로나 URL이어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.read_dict">
<code class="descname">read_dict</code><span class="sig-paren">(</span><em>dictionary</em>, <em>source='&lt;dict&gt;'</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.read_dict" title="정의 주소">¶</a></dt>
<dd><p>딕셔너리와 같은 <code class="docutils literal notranslate"><span class="pre">items()</span></code> 메서드를 제공하는 임의의 객체에서 구성을 로드합니다. 키는 섹션 이름이며, 값은 섹션에 있어야하는 키와 값이 들어있는 딕셔너리입니다. 사용된 딕셔너리 형이 순서를 유지하면, 섹션과 해당 키가 순서대로 추가됩니다. 값은 자동으로 문자열로 변환됩니다.</p>
<p>선택적 인자 <em>source</em>는 전달된 dictionary의 문맥 특정 이름을 지정합니다. 지정하지 않으면, <code class="docutils literal notranslate"><span class="pre">&lt;dict&gt;</span></code>가 사용됩니다.</p>
<p>이 메서드를 사용하면 구문 분석기간에 상태를 복사할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>section</em>, <em>option</em>, <em>*</em>, <em>raw=False</em>, <em>vars=None</em><span class="optional">[</span>, <em>fallback</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.get" title="정의 주소">¶</a></dt>
<dd><p>명명된 <em>section</em>에서 <em>option</em> 값을 가져옵니다. <em>vars</em>가 제공되면, 딕셔너리이어야 합니다. <em>option</em>은 <em>vars</em> (제공되면), <em>section</em> 및 <em>DEFAULTSECT</em>에서 순서대로 조회됩니다. 키를 찾을 수 없고 <em>fallback</em>이 제공되면, 대체 값으로 사용됩니다. <code class="docutils literal notranslate"><span class="pre">None</span></code>은 <em>fallback</em> 값으로 제공될 수 있습니다.</p>
<p><em>raw</em> 인자가 참이 아닌한, 모든 <code class="docutils literal notranslate"><span class="pre">'%'</span></code> 보간이 반환 값에서 확장됩니다. 보간 키의 값은 옵션과 같은 방식으로 조회됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>인자 <em>raw</em>, <em>vars</em> 및 <em>fallback</em>은 사용자가 세 번째 인자를 <em>fallback</em> 폴 백으로 사용하지 못하도록 하기위해 키워드 전용입니다 (특히 매핑 프로토콜을 사용할 때).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.getint">
<code class="descname">getint</code><span class="sig-paren">(</span><em>section</em>, <em>option</em>, <em>*</em>, <em>raw=False</em>, <em>vars=None</em><span class="optional">[</span>, <em>fallback</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.getint" title="정의 주소">¶</a></dt>
<dd><p>지정된 <em>section</em>의 <em>option</em>을 정수로 강제 변환하는 편의 메서드. <em>raw</em>, <em>vars</em> 및 <em>fallback</em>에 대한 설명은 <a class="reference internal" href="#configparser.ConfigParser.get" title="configparser.ConfigParser.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>을 참조하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.getfloat">
<code class="descname">getfloat</code><span class="sig-paren">(</span><em>section</em>, <em>option</em>, <em>*</em>, <em>raw=False</em>, <em>vars=None</em><span class="optional">[</span>, <em>fallback</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.getfloat" title="정의 주소">¶</a></dt>
<dd><p>지정된 <em>section</em>의 <em>option</em>을 부동 소수점 수로 강제 변환하는 편의 메서드. <em>raw</em>, <em>vars</em> 및 <em>fallback</em>에 대한 설명은 <a class="reference internal" href="#configparser.ConfigParser.get" title="configparser.ConfigParser.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>을 참조하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.getboolean">
<code class="descname">getboolean</code><span class="sig-paren">(</span><em>section</em>, <em>option</em>, <em>*</em>, <em>raw=False</em>, <em>vars=None</em><span class="optional">[</span>, <em>fallback</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.getboolean" title="정의 주소">¶</a></dt>
<dd><p>지정된 <em>section</em>의 <em>option</em>을 불리언 값으로 강제 변환하는 편의 메서드. 옵션에 허용되는 값은 이 메서드가 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환하게하는 <code class="docutils literal notranslate"><span class="pre">'1'</span></code>, <code class="docutils literal notranslate"><span class="pre">'yes'</span></code>, <code class="docutils literal notranslate"><span class="pre">'true'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'on'</span></code>과 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환하게하는 <code class="docutils literal notranslate"><span class="pre">'0'</span></code>, <code class="docutils literal notranslate"><span class="pre">'no'</span></code>, <code class="docutils literal notranslate"><span class="pre">'false'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'off'</span></code>입니다. 이 문자열 값은 대소 문자를 구분하지 않고 확인됩니다. 다른 모든 값은 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다. <em>raw</em>, <em>vars</em> 및 <em>fallback</em>에 대한 설명은 <a class="reference internal" href="#configparser.ConfigParser.get" title="configparser.ConfigParser.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>을 참조하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.items">
<code class="descname">items</code><span class="sig-paren">(</span><em>raw=False</em>, <em>vars=None</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.items" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">items</code><span class="sig-paren">(</span><em>section</em>, <em>raw=False</em>, <em>vars=None</em><span class="sig-paren">)</span></dt>
<dd><p><em>section</em>이 제공되지 않으면, DEFAULTSECT를 포함하여, <em>section_name</em>, <em>section_proxy</em> 쌍의 리스트를 반환합니다.</p>
<p>그렇지 않으면, 주어진 <em>section</em>의 옵션에 대해 <em>name</em>, <em>value</em> 쌍의 리스트를 반환합니다. 선택적 인자는 <a class="reference internal" href="#configparser.ConfigParser.get" title="configparser.ConfigParser.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> 메서드에서와 같은 의미를 갖습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.8으로 변경: </span><em>vars</em>에 있는 항목은 더는 결과에 나타나지 않습니다. 이전 동작은 실제 구문 분석기 옵션과 보간을 위해 제공된 변수를 혼합했습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>section</em>, <em>option</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.set" title="정의 주소">¶</a></dt>
<dd><p>주어진 섹션이 존재하면, 주어진 옵션을 지정된 값으로 설정합니다; 그렇지 않으면 <a class="reference internal" href="#configparser.NoSectionError" title="configparser.NoSectionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NoSectionError</span></code></a>를 발생시킵니다. <em>option</em>과 <em>value</em>는 문자열이어야 합니다; 그렇지 않으면, <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생합니다.</p>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>fileobject</em>, <em>space_around_delimiters=True</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.write" title="정의 주소">¶</a></dt>
<dd><p>텍스트 모드로 열렸어야 하는 (문자열을 받아들이는), 지정된 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a>에 구성의 표현을 기록합니다. 이 표현은 향후 <a class="reference internal" href="#configparser.ConfigParser.read" title="configparser.ConfigParser.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> 호출로 구문 분석할 수 있습니다. <em>space_around_delimiters</em>가 참이면, 키와 값 사이의 구분자는 공백으로 둘러싸입니다.</p>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.remove_option">
<code class="descname">remove_option</code><span class="sig-paren">(</span><em>section</em>, <em>option</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.remove_option" title="정의 주소">¶</a></dt>
<dd><p>지정된 <em>section</em>에서 지정된 <em>option</em>을 제거합니다. 섹션이 존재하지 않으면, <a class="reference internal" href="#configparser.NoSectionError" title="configparser.NoSectionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NoSectionError</span></code></a>를 발생시킵니다. 제거되는 옵션이 존재했으면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다; 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.remove_section">
<code class="descname">remove_section</code><span class="sig-paren">(</span><em>section</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.remove_section" title="정의 주소">¶</a></dt>
<dd><p>지정된 <em>section</em>을 구성에서 제거합니다. 실제로 섹션이 존재하면, <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다. 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">optionxform</code><span class="sig-paren">(</span><em>option</em><span class="sig-paren">)</span></dt>
<dd><p>입력 파일에서 발견되거나 클라이언트 코드에서 전달된 옵션 이름 <em>option</em>을 내부 구조에서 사용되어야 하는 형식으로 변환합니다. 기본 구현은 <em>option</em>의 소문자 버전을 반환합니다; 이 동작에 영향을 주기 위해 서브 클래스가 이 것을 재정의하거나 클라이언트 코드가 인스턴스에 이 이름의 어트리뷰트를 설정할 수 있습니다.</p>
<p>이 메서드를 사용하기 위해 구문 분석기를 서브 클래싱할 필요는 없으며, 문자열 인자를 취해서 문자열을 반환하는 함수로 인스턴스에 설정할 수도 있습니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">str</span></code>로 설정하면 옵션 이름이 대소 문자를 구분하게됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">cfgparser</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="p">()</span>
<span class="n">cfgparser</span><span class="o">.</span><span class="n">optionxform</span> <span class="o">=</span> <span class="nb">str</span>
</pre></div>
</div>
<p>구성 파일을 읽을 때, <a class="reference internal" href="#configparser.ConfigParser.optionxform" title="configparser.ConfigParser.optionxform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">optionxform()</span></code></a>가 호출되기 전에 옵션 이름 주위의 공백이 제거됨에 유의하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="configparser.ConfigParser.readfp">
<code class="descname">readfp</code><span class="sig-paren">(</span><em>fp</em>, <em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.ConfigParser.readfp" title="정의 주소">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">버전 3.2 폐지: </span>대신 <a class="reference internal" href="#configparser.ConfigParser.read_file" title="configparser.ConfigParser.read_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_file()</span></code></a>을 사용하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><a class="reference internal" href="#configparser.ConfigParser.readfp" title="configparser.ConfigParser.readfp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readfp()</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">fp.readline()</span></code>을 호출하는 대신 <em>fp</em>를 이터레이트합니다.</p>
</div>
<p>이터레이션을 지원하지 않는 인자로 <a class="reference internal" href="#configparser.ConfigParser.readfp" title="configparser.ConfigParser.readfp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readfp()</span></code></a>를 호출하는 기존 코드의 경우, 다음과 같은 제너레이터를 파일류 객체를 감싸는 래퍼로 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">readline_generator</span><span class="p">(</span><span class="n">fp</span><span class="p">):</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">line</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">parser.readfp(fp)</span></code> 대신 <code class="docutils literal notranslate"><span class="pre">parser.read_file(readline_generator(fp))</span></code>를 사용하십시오.</p>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="configparser.MAX_INTERPOLATION_DEPTH">
<code class="descclassname">configparser.</code><code class="descname">MAX_INTERPOLATION_DEPTH</code><a class="headerlink" href="#configparser.MAX_INTERPOLATION_DEPTH" title="정의 주소">¶</a></dt>
<dd><p><em>raw</em> 매개 변수가 거짓일 때 <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code>의 재귀 보간의 최대 깊이. 기본 <em>interpolation</em>을 사용할 때만 의미있습니다.</p>
</dd></dl>

</div>
<div class="section" id="rawconfigparser-objects">
<span id="id13"></span><h2>RawConfigParser 객체<a class="headerlink" href="#rawconfigparser-objects" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="configparser.RawConfigParser">
<em class="property">class </em><code class="descclassname">configparser.</code><code class="descname">RawConfigParser</code><span class="sig-paren">(</span><em>defaults=None</em>, <em>dict_type=dict</em>, <em>allow_no_value=False</em>, <em>*</em>, <em>delimiters=('='</em>, <em>':')</em>, <em>comment_prefixes=('#'</em>, <em>';')</em>, <em>inline_comment_prefixes=None</em>, <em>strict=True</em>, <em>empty_lines_in_values=True</em>, <em>default_section=configparser.DEFAULTSECT</em><span class="optional">[</span>, <em>interpolation</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#configparser.RawConfigParser" title="정의 주소">¶</a></dt>
<dd><p>Legacy variant of the <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConfigParser</span></code></a>.  It has interpolation
disabled by default and allows for non-string section names, option
names, and values via its unsafe <code class="docutils literal notranslate"><span class="pre">add_section</span></code> and <code class="docutils literal notranslate"><span class="pre">set</span></code> methods,
as well as the legacy <code class="docutils literal notranslate"><span class="pre">defaults=</span></code> keyword argument handling.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.8으로 변경: </span>이제 삽입 순서를 유지하므로, 기본 <em>dict_type</em>은 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>입니다.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">Consider using <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConfigParser</span></code></a> instead which checks types of
the values to be stored internally.  If you don't want interpolation, you
can use <code class="docutils literal notranslate"><span class="pre">ConfigParser(interpolation=None)</span></code>.</p>
</div>
<dl class="method">
<dt id="configparser.RawConfigParser.add_section">
<code class="descname">add_section</code><span class="sig-paren">(</span><em>section</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.RawConfigParser.add_section" title="정의 주소">¶</a></dt>
<dd><p>Add a section named <em>section</em> to the instance.  If a section by the given
name already exists, <a class="reference internal" href="#configparser.DuplicateSectionError" title="configparser.DuplicateSectionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DuplicateSectionError</span></code></a> is raised.  If the
<em>default section</em> name is passed, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised.</p>
<p>Type of <em>section</em> is not checked which lets users create non-string named
sections.  This behaviour is unsupported and may cause internal errors.</p>
</dd></dl>

<dl class="method">
<dt id="configparser.RawConfigParser.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>section</em>, <em>option</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#configparser.RawConfigParser.set" title="정의 주소">¶</a></dt>
<dd><p>If the given section exists, set the given option to the specified value;
otherwise raise <a class="reference internal" href="#configparser.NoSectionError" title="configparser.NoSectionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NoSectionError</span></code></a>.  While it is possible to use
<a class="reference internal" href="#configparser.RawConfigParser" title="configparser.RawConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">RawConfigParser</span></code></a> (or <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConfigParser</span></code></a> with <em>raw</em> parameters
set to true) for <em>internal</em> storage of non-string values, full
functionality (including interpolation and output to files) can only be
achieved using string values.</p>
<p>This method lets users assign non-string values to keys internally.  This
behaviour is unsupported and will cause errors when attempting to write
to a file or get it in non-raw mode.  <strong>Use the mapping protocol API</strong>
which does not allow such assignments to take place.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="exceptions">
<h2>Exceptions<a class="headerlink" href="#exceptions" title="제목 주소">¶</a></h2>
<dl class="exception">
<dt id="configparser.Error">
<em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">Error</code><a class="headerlink" href="#configparser.Error" title="정의 주소">¶</a></dt>
<dd><p>Base class for all other <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a> exceptions.</p>
</dd></dl>

<dl class="exception">
<dt id="configparser.NoSectionError">
<em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">NoSectionError</code><a class="headerlink" href="#configparser.NoSectionError" title="정의 주소">¶</a></dt>
<dd><p>Exception raised when a specified section is not found.</p>
</dd></dl>

<dl class="exception">
<dt id="configparser.DuplicateSectionError">
<em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">DuplicateSectionError</code><a class="headerlink" href="#configparser.DuplicateSectionError" title="정의 주소">¶</a></dt>
<dd><p>Exception raised if <code class="xref py py-meth docutils literal notranslate"><span class="pre">add_section()</span></code> is called with the name of a section
that is already present or in strict parsers when a section if found more
than once in a single input file, string or dictionary.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span>Optional <code class="docutils literal notranslate"><span class="pre">source</span></code> and <code class="docutils literal notranslate"><span class="pre">lineno</span></code> attributes and arguments to
<a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> were added.</p>
</div>
</dd></dl>

<dl class="exception">
<dt id="configparser.DuplicateOptionError">
<em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">DuplicateOptionError</code><a class="headerlink" href="#configparser.DuplicateOptionError" title="정의 주소">¶</a></dt>
<dd><p>Exception raised by strict parsers if a single option appears twice during
reading from a single file, string or dictionary. This catches misspellings
and case sensitivity-related errors, e.g. a dictionary may have two keys
representing the same case-insensitive configuration key.</p>
</dd></dl>

<dl class="exception">
<dt id="configparser.NoOptionError">
<em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">NoOptionError</code><a class="headerlink" href="#configparser.NoOptionError" title="정의 주소">¶</a></dt>
<dd><p>Exception raised when a specified option is not found in the specified
section.</p>
</dd></dl>

<dl class="exception">
<dt id="configparser.InterpolationError">
<em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">InterpolationError</code><a class="headerlink" href="#configparser.InterpolationError" title="정의 주소">¶</a></dt>
<dd><p>Base class for exceptions raised when problems occur performing string
interpolation.</p>
</dd></dl>

<dl class="exception">
<dt id="configparser.InterpolationDepthError">
<em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">InterpolationDepthError</code><a class="headerlink" href="#configparser.InterpolationDepthError" title="정의 주소">¶</a></dt>
<dd><p>Exception raised when string interpolation cannot be completed because the
number of iterations exceeds <a class="reference internal" href="#configparser.MAX_INTERPOLATION_DEPTH" title="configparser.MAX_INTERPOLATION_DEPTH"><code class="xref py py-const docutils literal notranslate"><span class="pre">MAX_INTERPOLATION_DEPTH</span></code></a>.  Subclass of
<a class="reference internal" href="#configparser.InterpolationError" title="configparser.InterpolationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterpolationError</span></code></a>.</p>
</dd></dl>

<dl class="exception">
<dt id="configparser.InterpolationMissingOptionError">
<em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">InterpolationMissingOptionError</code><a class="headerlink" href="#configparser.InterpolationMissingOptionError" title="정의 주소">¶</a></dt>
<dd><p>Exception raised when an option referenced from a value does not exist.
Subclass of <a class="reference internal" href="#configparser.InterpolationError" title="configparser.InterpolationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterpolationError</span></code></a>.</p>
</dd></dl>

<dl class="exception">
<dt id="configparser.InterpolationSyntaxError">
<em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">InterpolationSyntaxError</code><a class="headerlink" href="#configparser.InterpolationSyntaxError" title="정의 주소">¶</a></dt>
<dd><p>Exception raised when the source text into which substitutions are made does
not conform to the required syntax.  Subclass of <a class="reference internal" href="#configparser.InterpolationError" title="configparser.InterpolationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterpolationError</span></code></a>.</p>
</dd></dl>

<dl class="exception">
<dt id="configparser.MissingSectionHeaderError">
<em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">MissingSectionHeaderError</code><a class="headerlink" href="#configparser.MissingSectionHeaderError" title="정의 주소">¶</a></dt>
<dd><p>Exception raised when attempting to parse a file which has no section
headers.</p>
</dd></dl>

<dl class="exception">
<dt id="configparser.ParsingError">
<em class="property">exception </em><code class="descclassname">configparser.</code><code class="descname">ParsingError</code><a class="headerlink" href="#configparser.ParsingError" title="정의 주소">¶</a></dt>
<dd><p>Exception raised when errors occur attempting to parse a file.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>The <code class="docutils literal notranslate"><span class="pre">filename</span></code> attribute and <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> argument were renamed to
<code class="docutils literal notranslate"><span class="pre">source</span></code> for consistency.</p>
</div>
</dd></dl>

<p class="rubric">각주</p>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>, <a class="fn-backref" href="#id3">3</a>, <a class="fn-backref" href="#id4">4</a>, <a class="fn-backref" href="#id5">5</a>, <a class="fn-backref" href="#id6">6</a>, <a class="fn-backref" href="#id7">7</a>, <a class="fn-backref" href="#id8">8</a>, <a class="fn-backref" href="#id9">9</a>, <a class="fn-backref" href="#id10">10</a>)</em> 구성 구문 분석기는 심도 있는 사용자 정의를 허용합니다. 각주 참조로 요약된 동작을 변경하는데 관심이 있으면 <a class="reference internal" href="#customizing-parser-behaviour">구문 분석기 동작 사용자 정의</a> 섹션을 참조하십시오.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">configparser</span></code> --- 구성 파일 구문 분석기</a><ul>
<li><a class="reference internal" href="#quick-start">빠른 시작</a></li>
<li><a class="reference internal" href="#supported-datatypes">지원되는 데이터 형</a></li>
<li><a class="reference internal" href="#fallback-values">대체 값</a></li>
<li><a class="reference internal" href="#supported-ini-file-structure">지원되는 INI 파일 구조</a></li>
<li><a class="reference internal" href="#interpolation-of-values">값의 보간</a></li>
<li><a class="reference internal" href="#mapping-protocol-access">매핑 프로토콜 액세스</a></li>
<li><a class="reference internal" href="#customizing-parser-behaviour">구문 분석기 동작 사용자 정의</a></li>
<li><a class="reference internal" href="#legacy-api-examples">레거시 API 예제</a></li>
<li><a class="reference internal" href="#configparser-objects">ConfigParser 객체</a></li>
<li><a class="reference internal" href="#rawconfigparser-objects">RawConfigParser 객체</a></li>
<li><a class="reference internal" href="#exceptions">Exceptions</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="csv.html"
                        title="이전 장"><code class="docutils literal notranslate"><span class="pre">csv</span></code> --- CSV 파일 읽기와 쓰기</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="netrc.html"
                        title="다음 장"><code class="docutils literal notranslate"><span class="pre">netrc</span></code> --- netrc 파일 처리</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="netrc.html" title="netrc --- netrc 파일 처리"
             >다음</a> |</li>
        <li class="right" >
          <a href="csv.html" title="csv --- CSV 파일 읽기와 쓰기"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="fileformats.html" >파일 형식</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>