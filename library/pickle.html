
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>pickle --- 파이썬 객체 직렬화 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="copyreg --- pickle 지원 함수 등록" href="copyreg.html" />
    <link rel="prev" title="데이터 지속성" href="persistence.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/pickle.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="copyreg.html" title="copyreg --- pickle 지원 함수 등록"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="persistence.html" title="데이터 지속성"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="persistence.html" accesskey="U">데이터 지속성</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-pickle">
<span id="pickle-python-object-serialization"></span><h1><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> --- 파이썬 객체 직렬화<a class="headerlink" href="#module-pickle" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/pickle.py">Lib/pickle.py</a></p>
<hr class="docutils" id="index-0" />
<p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈은 파이썬 객체 구조의 직렬화와 역 직렬화를 위한 바이너리 프로토콜을 구현합니다. <em>&quot;피클링(pickling)&quot;</em>은 파이썬 객체 계층 구조가 바이트 스트림으로 변환되는 절차이며, <em>&quot;역 피클링(unpickling)&quot;</em>은 반대 연산으로, (<a class="reference internal" href="../glossary.html#term-binary-file"><span class="xref std std-term">바이너리 파일</span></a> 이나 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>로 부터의) 바이트 스트림을 객체 계층 구조로 복원합니다. 피클링(그리고 역 피클링)은 &quot;직렬화(serialization)&quot;, &quot;마샬링(marshalling)&quot; <a class="footnote-reference brackets" href="#id7" id="id1">1</a> 또는 &quot;평탄화(flattening)&quot; 라고도 합니다; 그러나, 혼란을 피하고자, 여기에서 사용된 용어는 &quot;피클링&quot; 과 &quot;역 피클링&quot; 입니다.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p><code class="docutils literal notranslate"><span class="pre">pickle</span></code> 모듈은 <strong>안전하지 않습니다</strong>. 신뢰할 수 있는 데이터만 언 피클 하십시오.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>신뢰할 수 없는 출처의 데이터를 언피클하는 것을 안전하게 만드는 것은 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 을
안전하게 만드는 것과 비슷한 정도로 어렵습니다. 안전하게 만들기 위해서는 언피클에 아주 강한
제약을 걸어야만 하는데, 피클링의 유용성을 크게 낮추게됩니다. 때문에 오직 신뢰할 수 있는
데이터만 사용하는 전략이 더 실용적입니다. 그렇게 하는 한가지 방법은 피클된 데이터에
암호적으로 서명을 첨부하는 것입니다.</p>
</div>
<p><strong>언 피클 시 임의의 코드를 실행하는</strong> 악의적인 피클 데이터를 구성할 수 있습니다. 신뢰할 수 없는 출처에서 왔거나 변조되었을 수 있는 데이터를 절대로 언 피클 하지 마십시오.</p>
<p>변조되지 않았음을 보장하려면 <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a>으로 데이터에 서명하는 것을 고려하십시오.</p>
<p>신뢰할 수 없는 데이터를 처리한다면, <a class="reference internal" href="json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a>과 같은 안전한 직렬화 형식이 더 적합 할 수 있습니다. <a class="reference internal" href="#comparison-with-json"><span class="std std-ref">json 과의 비교</span></a>를 참조하십시오.</p>
</div>
<div class="section" id="relationship-to-other-python-modules">
<h2>다른 파이썬 모듈과의 관계<a class="headerlink" href="#relationship-to-other-python-modules" title="제목 주소">¶</a></h2>
<div class="section" id="comparison-with-marshal">
<h3><code class="docutils literal notranslate"><span class="pre">marshal</span></code> 과의 비교<a class="headerlink" href="#comparison-with-marshal" title="제목 주소">¶</a></h3>
<p>파이썬이 <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 이라 불리는 좀 더 원시적인 직렬화 모듈을 가지고 있지만, 일반적으로 <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 은 항상 파이썬 객체를 직렬화하기 위해 선호되는 방법이어야 합니다. <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 은 주로 파이썬의 <code class="file docutils literal notranslate"><span class="pre">.pyc</span></code> 파일을 지원하기 위해 존재합니다.</p>
<p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈은 <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a>과 몇 가지 중요한 점에서 다릅니다:</p>
<ul>
<li><p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈은 이미 직렬화된 객체를 추적하므로 나중에 같은 객체에 대한 참조가 다시 직렬화되지 않습니다. <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 은 이렇게 하지 않습니다.</p>
<p>이는 재귀 객체와 객체 공유에 모두 관련이 있습니다. 재귀 객체는 자신에 대한 참조를 포함하는 객체입니다. 이것은 마샬에 의해 처리되지 않으며, 실제로 재귀 객체를 마샬 하려고 하면 파이썬 인터프리터가 충돌합니다. 객체 공유는 직렬화되는 객체 계층의 다른 위치에서 같은 객체에 대한 다중 참조가 있을 때 발생합니다. <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 은 그러한 객체를 한 번만 저장하고, 다른 모든 참조가 마스터 복사본을 가리키도록 만듭니다. 공유 객체는 공유된 상태로 유지되는데, 가변 객체의 경우 매우 중요할 수 있습니다.</p>
</li>
<li><p><a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a>은 사용자 정의 클래스와 인스턴스를 직렬화하는 데 사용할 수 없습니다. <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 은 클래스 인스턴스를 투명하게 저장하고 복원할 수 있지만, 클래스 정의는 객체를 저장할 때와 같은 모듈에 존재하고 임포트 할 수 있어야 합니다.</p></li>
<li><p><a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 직렬화 형식은 파이썬 버전 간에 이식성이 보장되지 않습니다. 가장 중요한 일은 <code class="file docutils literal notranslate"><span class="pre">.pyc</span></code> 파일을 지원하는 것이므로, 파이썬 구현자는 필요할 때 직렬화 형식을 과거 호환되지 않는 방식으로 변경할 권리를 갖습니다. <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 직렬화 형식은, 호환성 있는 피클 프로토콜이 선택되고 여러분의 데이터가 파이썬 2와 파이썬 3의 호환되지 않는 언어 경계를 가로지를 때 피클링과 역 피클링 코드가 두 파이썬 형의 차이점을 다루는 한, 파이썬 배포 간의 과거 호환성을 보장합니다.</p></li>
</ul>
</div>
<div class="section" id="comparison-with-json">
<span id="id2"></span><h3><code class="docutils literal notranslate"><span class="pre">json</span></code> 과의 비교<a class="headerlink" href="#comparison-with-json" title="제목 주소">¶</a></h3>
<p>pickle 프로토콜과 <a class="reference external" href="http://json.org">JSON (JavaScript Object Notation)</a> 간에는 근본적인 차이가 있습니다:</p>
<ul class="simple">
<li><p>JSON은 텍스트 직렬화 형식(유니코드 텍스트를 출력하지만, 대개는 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> 으로 인코딩됩니다)인 반면, pickle은 바이너리 직렬화 형식입니다.</p></li>
<li><p>JSON은 사람이 읽을 수 있지만, 피클은 그렇지 않습니다.</p></li>
<li><p>JSON은 상호 운용이 가능하며 파이썬 생태계 외부에서 널리 사용되는 반면, 피클은 파이썬으로만 한정됩니다.</p></li>
<li><p>JSON은, 기본적으로, 파이썬 내장형 일부만 표시할 수 있으며 사용자 정의 클래스는 표시할 수 없습니다; 피클은 매우 많은 수의 파이썬 형을 나타낼 수 있습니다 (그중 많은 것들은 파이썬의 인트로스펙션 기능을 영리하게 사용하여 자동으로; 복잡한 경우는 <a class="reference internal" href="#pickle-inst"><span class="std std-ref">특정 객체 API</span></a> 를 구현해서 해결할 수 있습니다);</p></li>
<li><p>pickle과 달리, 신뢰할 수 없는 JSON의 역 직렬화는 그 자체로 임의 코드 실행 취약점을 만들지는 않습니다.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> 모듈: JSON 직렬화와 역 직렬화를 가능하게 하는 표준 라이브러리 모듈.</p>
</div>
</div>
</div>
<div class="section" id="data-stream-format">
<span id="pickle-protocols"></span><h2>데이터 스트림 형식<a class="headerlink" href="#data-stream-format" title="제목 주소">¶</a></h2>
<p id="index-1"><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 이 사용하는 데이터 형식은 파이썬에 고유합니다. 이것은 JSON 또는 XDR (포인터 공유를 나타낼 수 없음)과 같은 외부 표준에 의해 부과된 제약이 없다는 장점이 있습니다. 그러나 비 파이썬 프로그램은 피클 된 파이썬 객체를 재구성할 수 없다는 것을 의미합니다.</p>
<p>기본적으로, <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 데이터 포맷은 상대적으로 간결한 바이너리 표현을 사용합니다. 최적의 크기 특성이 필요하다면, 피클 된 데이터를 효율적으로 <a class="reference internal" href="archiving.html"><span class="doc">압축</span></a> 할 수 있습니다.</p>
<p>모듈 <a class="reference internal" href="pickletools.html#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickletools</span></code></a> 에는 <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 에 의해 생성된 데이터 스트림을 분석하는 도구가 있습니다. <a class="reference internal" href="pickletools.html#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickletools</span></code></a> 소스 코드에는 피클 프로토콜에서 사용되는 옵코드(opcode)에 대한 광범위한 주석이 있습니다.</p>
<p>현재 피클링에 쓸 수 있는 6가지 프로토콜이 있습니다. 사용된 프로토콜이 높을수록, 생성된 피클을 읽으려면 더 최신 파이썬 버전이 필요합니다.</p>
<ul class="simple">
<li><p>프로토콜 버전 0은 최초의 &quot;사람이 읽을 수 있는&quot; 프로토콜이며 이전 버전의 파이썬과 과거 호환됩니다.</p></li>
<li><p>프로토콜 버전 1은 역시 이전 버전의 파이썬과 호환되는 오래된 바이너리 형식입니다.</p></li>
<li><p>프로토콜 버전 2는 파이썬 2.3에서 소개되었습니다. 그것은 훨씬 더 효율적인 <a class="reference internal" href="../glossary.html#term-new-style-class"><span class="xref std std-term">뉴스타일 클래스</span></a>의 피클링을 제공합니다. 프로토콜 2에 의해 개선된 사항에 대한 정보는 <span class="target" id="index-14"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0307"><strong>PEP 307</strong></a>을 참조하십시오.</p></li>
<li><p>프로토콜 버전 3은 파이썬 3.0에서 추가되었습니다. 명시적으로 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체를 지원하며 파이썬 2.x에서 역 피클 될 수 없습니다. 이것은 파이썬 3.0--3.7에서 기본 프로토콜이었습니다.</p></li>
<li><p>프로토콜 버전 4가 파이썬 3.4에 추가되었습니다. 매우 큰 객체, 더 많은 종류의 객체에 대한 피클링, 일부 데이터 형식 최적화에 대한 지원을 추가합니다. 파이썬 3.8부터 이것이 기본 프로토콜입니다. 프로토콜 4에 의해 개선된 사항에 대한 정보는 <span class="target" id="index-15"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3154"><strong>PEP 3154</strong></a>를 참조하십시오.</p></li>
<li><p>프로토콜 버전 5는 파이썬 3.8에서 추가되었습니다. 아웃 오브 밴드 데이터에 대한 지원과 인 밴드 데이터에 대한 속도 향상을 추가합니다. 프로토콜 5의 개선 사항에 대한 정보는 <span class="target" id="index-16"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0574"><strong>PEP 574</strong></a>를 참조하십시오.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>직렬화는 지속성보다 더 원시적인 개념입니다; <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 이 파일 객체를 읽거나 쓰기는 하지만, 지속적인 객체의 이름 지정도 (더 복잡한) 지속적인 객체에 대한 동시 액세스 문제도 처리하지 않습니다. <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈은 복잡한 객체를 바이트 스트림으로 변환할 수 있고 바이트 스트림을 같은 내부 구조를 가진 객체로 변환할 수 있습니다. 아마도 이러한 바이트 스트림으로 할 가장 분명한 작업은 파일에 쓰는 것이겠지만, 네트워크를 통해 보내거나 데이터베이스에 저장하는 것도 고려할 수 있습니다. <a class="reference internal" href="shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a> 모듈은 DBM 스타일의 데이터베이스 파일에 객체를 피클/역 피클 하는 간단한 인터페이스를 제공합니다.</p>
</div>
</div>
<div class="section" id="module-interface">
<h2>모듈 인터페이스<a class="headerlink" href="#module-interface" title="제목 주소">¶</a></h2>
<p>객체 계층 구조를 직렬화하려면, 단순히 <a class="reference internal" href="#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">dumps()</span></code></a> 함수를 호출하면 됩니다. 마찬가지로, 데이터 스트림을 역 직렬화하려면 <a class="reference internal" href="#pickle.loads" title="pickle.loads"><code class="xref py py-func docutils literal notranslate"><span class="pre">loads()</span></code></a> 함수를 호출합니다. 그러나, 직렬화와 역 직렬화에 대한 더 많은 제어를 원하면, 각각 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 나 <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a> 객체를 만들 수 있습니다.</p>
<p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈은 다음과 같은 상수를 제공합니다:</p>
<dl class="data">
<dt id="pickle.HIGHEST_PROTOCOL">
<code class="sig-prename descclassname">pickle.</code><code class="sig-name descname">HIGHEST_PROTOCOL</code><a class="headerlink" href="#pickle.HIGHEST_PROTOCOL" title="정의 주소">¶</a></dt>
<dd><p>정수, 사용 가능한 가장 높은 <a class="reference internal" href="#pickle-protocols"><span class="std std-ref">프로토콜 버전</span></a>. 이 값은 함수 <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a>와 <a class="reference internal" href="#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">dumps()</span></code></a> 그리고 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 생성자에 <em>protocol</em> 값으로 전달될 수 있습니다.</p>
</dd></dl>

<dl class="data">
<dt id="pickle.DEFAULT_PROTOCOL">
<code class="sig-prename descclassname">pickle.</code><code class="sig-name descname">DEFAULT_PROTOCOL</code><a class="headerlink" href="#pickle.DEFAULT_PROTOCOL" title="정의 주소">¶</a></dt>
<dd><p>정수, 피클링에 사용되는 기본 <a class="reference internal" href="#pickle-protocols"><span class="std std-ref">프로토콜 버전</span></a>. <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code class="xref py py-data docutils literal notranslate"><span class="pre">HIGHEST_PROTOCOL</span></code></a> 보다 작을 수 있습니다. 현재 기본 프로토콜은 4인데, 파이썬 3.4에서 처음 소개되었으며 이전 버전과 호환되지 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.0에서 변경: </span>기본 프로토콜은 3입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>기본 프로토콜은 4입니다.</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈은 피클링 절차를 보다 편리하게 하려고 다음과 같은 함수를 제공합니다:</p>
<dl class="function">
<dt id="pickle.dump">
<code class="sig-prename descclassname">pickle.</code><code class="sig-name descname">dump</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">file</em>, <em class="sig-param">protocol=None</em>, <em class="sig-param">*</em>, <em class="sig-param">fix_imports=True</em>, <em class="sig-param">buffer_callback=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.dump" title="정의 주소">¶</a></dt>
<dd><p>객체 <em>obj</em> 의 피클 된 표현을 열린 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a> <em>file</em> 에 씁니다. 이것은 <code class="docutils literal notranslate"><span class="pre">Pickler(file,</span> <span class="pre">protocol).dump(obj)</span></code> 와 동등합니다.</p>
<p>인자 <em>file</em>, <em>protocol</em>, <em>fix_imports</em> 및 <em>buffer_callback</em>은 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 생성자에서와 같은 의미입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><em>buffer_callback</em> 인자가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pickle.dumps">
<code class="sig-prename descclassname">pickle.</code><code class="sig-name descname">dumps</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">protocol=None</em>, <em class="sig-param">*</em>, <em class="sig-param">fix_imports=True</em>, <em class="sig-param">buffer_callback=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.dumps" title="정의 주소">¶</a></dt>
<dd><p>객체 <em>obj</em>의 피클 된 표현을 파일에 쓰는 대신 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체로 반환합니다.</p>
<p>인자 <em>protocol</em>, <em>fix_imports</em> 및 <em>buffer_callback</em>은 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 생성자에서와 같은 의미입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><em>buffer_callback</em> 인자가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pickle.load">
<code class="sig-prename descclassname">pickle.</code><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">file</em>, <em class="sig-param">*</em>, <em class="sig-param">fix_imports=True</em>, <em class="sig-param">encoding=&quot;ASCII&quot;</em>, <em class="sig-param">errors=&quot;strict&quot;</em>, <em class="sig-param">buffers=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.load" title="정의 주소">¶</a></dt>
<dd><p>열린 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a> <em>file</em> 에서 객체의 피클 된 표현을 읽고, 그 안에 지정된 객체 계층 구조를 재구성하여 반환합니다. 이것은 <code class="docutils literal notranslate"><span class="pre">Unpickler(file).load()</span></code> 와 동등합니다.</p>
<p>피클의 프로토콜 버전이 자동으로 감지되므로 프로토콜 인자가 필요하지 않습니다. 객체의 피클 된 표현 뒤에 남는 바이트열은 무시됩니다.</p>
<p>인자 <em>file</em>, <em>fix_imports</em>, <em>encoding</em>, <em>errors</em>, <em>strict</em> 및 <em>buffers</em>는 <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a> 생성자에서와 같은 의미입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><em>buffers</em> 인자가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pickle.loads">
<code class="sig-prename descclassname">pickle.</code><code class="sig-name descname">loads</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">*</em>, <em class="sig-param">fix_imports=True</em>, <em class="sig-param">encoding=&quot;ASCII&quot;</em>, <em class="sig-param">errors=&quot;strict&quot;</em>, <em class="sig-param">buffers=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.loads" title="정의 주소">¶</a></dt>
<dd><p>객체의 피클 된 표현 <em>data</em>의 재구성된 객체 계층 구조를 반환합니다. <em>data</em>는 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>여야 합니다.</p>
<p>피클의 프로토콜 버전이 자동으로 감지되므로 프로토콜 인자가 필요하지 않습니다. 객체의 피클 된 표현 뒤에 남는 바이트열은 무시됩니다.</p>
<p>인자 <em>file</em>, <em>fix_imports</em>, <em>encoding</em>, <em>errors</em>, <em>strict</em> 및 <em>buffers</em>는 <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a> 생성자에서와 같은 의미입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><em>buffers</em> 인자가 추가되었습니다.</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈은 세 가지 예외를 정의합니다:</p>
<dl class="exception">
<dt id="pickle.PickleError">
<em class="property">exception </em><code class="sig-prename descclassname">pickle.</code><code class="sig-name descname">PickleError</code><a class="headerlink" href="#pickle.PickleError" title="정의 주소">¶</a></dt>
<dd><p>다른 피클링 예외의 공통 베이스 클래스입니다. <a class="reference internal" href="exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a>을 상속합니다.</p>
</dd></dl>

<dl class="exception">
<dt id="pickle.PicklingError">
<em class="property">exception </em><code class="sig-prename descclassname">pickle.</code><code class="sig-name descname">PicklingError</code><a class="headerlink" href="#pickle.PicklingError" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 가 피클 가능하지 않은 객체를 만날 때 발생하는 에러. <a class="reference internal" href="#pickle.PickleError" title="pickle.PickleError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PickleError</span></code></a> 를 상속합니다.</p>
<p>어떤 종류의 객체가 피클 될 수 있는지 배우려면 <a class="reference internal" href="#pickle-picklable"><span class="std std-ref">어떤 것이 피클 되고 역 피클 될 수 있을까요?</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="exception">
<dt id="pickle.UnpicklingError">
<em class="property">exception </em><code class="sig-prename descclassname">pickle.</code><code class="sig-name descname">UnpicklingError</code><a class="headerlink" href="#pickle.UnpicklingError" title="정의 주소">¶</a></dt>
<dd><p>데이터 손상 또는 보안 위반과 같이 객체를 역 피클 할 때 문제가 있으면 발생하는 에러. <a class="reference internal" href="#pickle.PickleError" title="pickle.PickleError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PickleError</span></code></a> 를 상속합니다.</p>
<p>역 피클링 중에 다른 예외도 발생할 수 있음에 유의하십시오. AttributeError, EOFError, ImportError, IndexError 등이 발생할 수 있지만, 이에 국한되지는 않습니다.</p>
</dd></dl>

<p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈은 세 개의 클래스를 노출합니다, <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a>, <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a> 및 <a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a>:</p>
<dl class="class">
<dt id="pickle.Pickler">
<em class="property">class </em><code class="sig-prename descclassname">pickle.</code><code class="sig-name descname">Pickler</code><span class="sig-paren">(</span><em class="sig-param">file</em>, <em class="sig-param">protocol=None</em>, <em class="sig-param">*</em>, <em class="sig-param">fix_imports=True</em>, <em class="sig-param">buffer_callback=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Pickler" title="정의 주소">¶</a></dt>
<dd><p>피클 데이터 스트림을 쓸 바이너리 파일을 받아들입니다.</p>
<p>선택적 <em>protocol</em> 인자(정수)는 피클러가 주어진 프로토콜을 사용하도록 지시합니다; 지원되는 프로토콜은 0부터 <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code class="xref py py-data docutils literal notranslate"><span class="pre">HIGHEST_PROTOCOL</span></code></a> 입니다. 지정하지 않으면 기본값은 <a class="reference internal" href="#pickle.DEFAULT_PROTOCOL" title="pickle.DEFAULT_PROTOCOL"><code class="xref py py-data docutils literal notranslate"><span class="pre">DEFAULT_PROTOCOL</span></code></a> 입니다. 음수가 지정되면, <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code class="xref py py-data docutils literal notranslate"><span class="pre">HIGHEST_PROTOCOL</span></code></a> 이 선택됩니다.</p>
<p><em>file</em> 인자에는 단일 바이트열 인자를 받아들이는 write() 메서드가 있어야 합니다. 따라서 바이너리 쓰기를 위해 열린 디스크 상의 파일, <a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> 인스턴스 또는 이 인터페이스를 충족시키는 다른 사용자 정의 객체일 수 있습니다.</p>
<p><em>fix_imports</em> 가 참이고 <em>protocol</em> 이 3보다 작으면, pickle은 새로운 파이썬 3 이름을 파이썬 2에서 사용된 이전 모듈 이름에 매핑하려고 시도하여, 파이썬 2에서 피클 데이터 스트림을 읽을 수 있도록 합니다.</p>
<p><em>buffer_callback</em>이 None(기본값)이면, 버퍼 뷰는 피클 스트림의 일부로 <em>file</em>로 직렬화됩니다.</p>
<p><em>buffer_callback</em>이 None이 아니면, 버퍼 뷰로 여러 번 호출될 수 있습니다. 콜백이 거짓 값(가령 None)을 반환하면, 주어진 버퍼는 <a class="reference internal" href="#pickle-oob"><span class="std std-ref">아웃 오브 밴드</span></a>입니다; 그렇지 않으면 버퍼는 인 밴드, 즉 피클 스트림 내부에 직렬화됩니다.</p>
<p><em>buffer_callback</em>이 None이 아니고 <em>protocol</em>이 None이거나 5보다 작으면 에러입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><em>buffer_callback</em> 인자가 추가되었습니다.</p>
</div>
<dl class="method">
<dt id="pickle.Pickler.dump">
<code class="sig-name descname">dump</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Pickler.dump" title="정의 주소">¶</a></dt>
<dd><p>생성자에 주어진 열린 파일 객체에 <em>obj</em> 의 피클 된 표현을 씁니다.</p>
</dd></dl>

<dl class="method">
<dt id="pickle.Pickler.persistent_id">
<code class="sig-name descname">persistent_id</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Pickler.persistent_id" title="정의 주소">¶</a></dt>
<dd><p>기본적으로 아무것도 하지 않습니다. 이것은 서브 클래스가 재정의할 수 있게 하려고 존재합니다.</p>
<p><a class="reference internal" href="#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_id()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 반환하면, <em>obj</em> 는 보통 때처럼 피클 됩니다. 다른 값은 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 가 <em>obj</em> 의 지속성(persistent) ID로 반환 값을 출력하도록 합니다. 이 지속성 ID의 의미는 <a class="reference internal" href="#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Unpickler.persistent_load()</span></code></a> 에 의해 정의되어야 합니다. <a class="reference internal" href="#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_id()</span></code></a> 에 의해 반환된 값 자체는 지속성 ID를 가질 수 없음에 유의하십시오.</p>
<p>자세한 내용과 사용 예는 <a class="reference internal" href="#pickle-persistent"><span class="std std-ref">외부 객체의 지속성</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="attribute">
<dt id="pickle.Pickler.dispatch_table">
<code class="sig-name descname">dispatch_table</code><a class="headerlink" href="#pickle.Pickler.dispatch_table" title="정의 주소">¶</a></dt>
<dd><p>피클러 객체의 디스패치 테이블은 <a class="reference internal" href="copyreg.html#copyreg.pickle" title="copyreg.pickle"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyreg.pickle()</span></code></a> 을 사용하여 선언할 수 있는 <em>환원 함수(reduction functions)</em> 의 등록소입니다. 키가 클래스이고 값이 환원 함수인 매핑입니다. 환원 함수는 관련 클래스의 단일 인자를 취하며 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 메서드와 같은 인터페이스를 따라야 합니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>환원 함수가 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 와 같은 인터페이스를 갖기 위해서는 인자로 해당 클래스의
인스턴스를 받아들여야합니다. <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 의 <code class="docutils literal notranslate"><span class="pre">self</span></code> 에 해당합니다.</p>
</div>
<p>기본적으로, 피클러 객체는 <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> 어트리뷰트를 가지지 않을 것이고, 대신 <a class="reference internal" href="copyreg.html#module-copyreg" title="copyreg: Register pickle support functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code></a> 모듈에 의해 관리되는 전역 디스패치 테이블을 사용할 것입니다. 그러나 특정 피클러 객체의 피클링을 사용자 정의하기 위해서 <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> 어트리뷰트를 딕셔너리류 객체로 설정할 수 있습니다. 또는, <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 의 서브 클래스가 <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> 어트리뷰트를 가지고 있다면, 이 클래스의 인스턴스를 위한 기본 디스패치 테이블로 사용됩니다.</p>
<p>사용 예는 <a class="reference internal" href="#pickle-dispatch"><span class="std std-ref">디스패치 테이블</span></a>을 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pickle.Pickler.reducer_override">
<code class="sig-name descname">reducer_override</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Pickler.reducer_override" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 서브 클래스에서 정의할 수 있는 특수 환원기(reducer). 이 메서드는 <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a>에 있는 모든 감속기보다 우선순위가 높습니다. <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 메서드와 같은 인터페이스를 따라야 하며, 선택적으로 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>를 반환하여 <code class="docutils literal notranslate"><span class="pre">obj</span></code>를 피클 하기 위해 <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> 등록 환원기로 폴백(fallback)하도록 할 수 있습니다.</p>
<p>자세한 예는 <a class="reference internal" href="#reducer-override"><span class="std std-ref">형, 함수 및 기타 객체에 대한 사용자 정의 환원</span></a>을 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pickle.Pickler.fast">
<code class="sig-name descname">fast</code><a class="headerlink" href="#pickle.Pickler.fast" title="정의 주소">¶</a></dt>
<dd><p>폐지되었습니다. 참값으로 설정된 경우 빠른 모드를 활성화합니다. 빠른 모드는 메모 사용을 비활성화하므로, 불필요한 PUT 옵코드를 생성하지 않아 피클링 절차의 속도를 높입니다. 자신을 참조하는 객체에 사용되면 안 됩니다. 그렇지 않으면 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 가 무한 재귀에 빠집니다.</p>
<p>더 간결한 피클이 필요하면 <a class="reference internal" href="pickletools.html#pickletools.optimize" title="pickletools.optimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">pickletools.optimize()</span></code></a> 를 사용하십시오.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pickle.Unpickler">
<em class="property">class </em><code class="sig-prename descclassname">pickle.</code><code class="sig-name descname">Unpickler</code><span class="sig-paren">(</span><em class="sig-param">file</em>, <em class="sig-param">*</em>, <em class="sig-param">fix_imports=True</em>, <em class="sig-param">encoding=&quot;ASCII&quot;</em>, <em class="sig-param">errors=&quot;strict&quot;</em>, <em class="sig-param">buffers=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Unpickler" title="정의 주소">¶</a></dt>
<dd><p>피클 데이터 스트림을 읽는 데 사용될 바이너리 파일을 받아들입니다.</p>
<p>피클의 프로토콜 버전이 자동으로 감지되므로 프로토콜 인자가 필요하지 않습니다.</p>
<p>인자 <em>file</em> 에는 세 가지 메서드가 있어야 합니다, <a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedIOBase</span></code></a> 인터페이스 처럼, 정수 인자를 받아들이는 read() 메서드, 버퍼 인자를 받아들이는 readinto() 메서드 그리고 인자가 없는 readline() 메서드. 따라서 <em>file</em> 은 바이너리 읽기를 위해 열린 디스크 상의 파일, <a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> 객체 또는 이 인터페이스를 만족하는 다른 사용자 정의 객체일 수 있습니다.</p>
<p>선택적 인자 <em>fix_imports</em>, <em>encoding</em> 및 <em>errors</em>는 파이썬 2에서 생성된 피클 스트림에 대한 호환성 지원을 제어하는 데 사용됩니다. <em>fix_imports</em> 가 참이면, pickle은 이전 파이썬 2 이름을 파이썬 3에서 사용된 새로운 이름으로 매핑하려고 합니다. <em>encoding</em> 과 <em>errors</em> 는 파이썬 2에 의해 피클 된 8비트 문자열 인스턴스를 디코딩하는 방법을 pickle에게 알려줍니다. 기본값은 각각 'ASCII'와 'strict' 입니다. <em>encoding</em> 은 'bytes' 가 될 수 있는데, 8비트 문자열 인스턴스를 바이트열 객체로 읽습니다. NumPy 배열과 파이썬 2에서 피클 된 <a class="reference internal" href="datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a>, <a class="reference internal" href="datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a> 및 <a class="reference internal" href="datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time</span></code></a> 인스턴스를 역 피클링하려면 <code class="docutils literal notranslate"><span class="pre">encoding='latin1'</span></code>을 사용해야 합니다.</p>
<p><em>buffers</em>가 None(기본값)이면, 역 직렬화에 필요한 모든 데이터가 피클 스트림에 포함되어야 합니다. 이것은 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a>가 인스턴스 화 될 때 (또는 <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a>나 <a class="reference internal" href="#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">dumps()</span></code></a>가 호출될 때) <em>buffer_callback</em> 인자가 None이었음을 뜻합니다.</p>
<p><em>buffers</em>가 None이 아니면, 피클 스트림이 <a class="reference internal" href="#pickle-oob"><span class="std std-ref">아웃 오브 밴드</span></a> 버퍼 뷰를 참조할 때마다 소비되는 버퍼가 활성화된 객체의 이터러블이어야 합니다. 이러한 버퍼는 Pickler 객체의 <em>buffer_callback</em>에 순서대로 제공되었습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><em>buffers</em> 인자가 추가되었습니다.</p>
</div>
<dl class="method">
<dt id="pickle.Unpickler.load">
<code class="sig-name descname">load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Unpickler.load" title="정의 주소">¶</a></dt>
<dd><p>생성자에 주어진 열린 파일 객체에서 객체의 피클 된 표현을 읽고, 그 안에 지정된 객체 계층 구조를 재구성하여 반환합니다. 객체의 피클 된 표현 뒤에 남는 바이트열은 무시됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="pickle.Unpickler.persistent_load">
<code class="sig-name descname">persistent_load</code><span class="sig-paren">(</span><em class="sig-param">pid</em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Unpickler.persistent_load" title="정의 주소">¶</a></dt>
<dd><p>기본적으로 <a class="reference internal" href="#pickle.UnpicklingError" title="pickle.UnpicklingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnpicklingError</span></code></a>를 발생시킵니다.</p>
<p>정의되면, <a class="reference internal" href="#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_load()</span></code></a> 는 지속성 ID <em>pid</em> 로 지정된 객체를 반환해야 합니다. 유효하지 않은 지속성 ID가 발견되면 <a class="reference internal" href="#pickle.UnpicklingError" title="pickle.UnpicklingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnpicklingError</span></code></a>를 일으켜야 합니다.</p>
<p>자세한 내용과 사용 예는 <a class="reference internal" href="#pickle-persistent"><span class="std std-ref">외부 객체의 지속성</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="pickle.Unpickler.find_class">
<code class="sig-name descname">find_class</code><span class="sig-paren">(</span><em class="sig-param">module</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Unpickler.find_class" title="정의 주소">¶</a></dt>
<dd><p>필요하면 <em>module</em> 을 임포트하고 거기에서 <em>name</em> 이라는 객체를 반환합니다. 여기서 <em>module</em> 및 <em>name</em> 인자는 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체입니다. 그 이름이 제시하는 것과는 달리, <a class="reference internal" href="#pickle.Unpickler.find_class" title="pickle.Unpickler.find_class"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_class()</span></code></a> 는 함수를 찾는 데에도 사용됨에 유의하십시오.</p>
<p>로드되는 객체의 형과 로드 방법을 제어하기 위해 서브 클래스는 이것을 재정의할 수 있고, 잠재적으로 보안 위험을 감소시킵니다. 자세한 내용은 <a class="reference internal" href="#pickle-restrict"><span class="std std-ref">전역 제한하기</span></a>를 참조하십시오.</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">module</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>을 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">pickle.find_class</span></code>를 발생시킵니다.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pickle.PickleBuffer">
<em class="property">class </em><code class="sig-prename descclassname">pickle.</code><code class="sig-name descname">PickleBuffer</code><span class="sig-paren">(</span><em class="sig-param">buffer</em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.PickleBuffer" title="정의 주소">¶</a></dt>
<dd><p>피클 가능한 데이터를 나타내는 버퍼의 래퍼. <em>buffer</em>는 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>나 N-차원 배열과 같은 <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">버퍼 제공</span></a> 객체여야 합니다.</p>
<p><a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> 자체가 버퍼 제공자이므로, <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>와 같은 버퍼 제공 객체를 기대하는 다른 API로 전달할 수 있습니다.</p>
<p><a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> 객체는 피클 프로토콜 5 이상만 사용하여 직렬화할 수 있습니다. 그들은 <a class="reference internal" href="#pickle-oob"><span class="std std-ref">아웃 오브 밴드 직렬화</span></a> 대상입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
<dl class="method">
<dt id="pickle.PickleBuffer.raw">
<code class="sig-name descname">raw</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pickle.PickleBuffer.raw" title="정의 주소">¶</a></dt>
<dd><p>이 버퍼의 하부 메모리 영역의 <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>를 반환합니다. 반환된 객체는 <code class="docutils literal notranslate"><span class="pre">B</span></code> (부호 없는 바이트) 형식의 1-차원 C 연속 메모리 뷰입니다. 버퍼가 C나 포트란 연속적이지 않으면 <a class="reference internal" href="exceptions.html#BufferError" title="BufferError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BufferError</span></code></a>가 발생합니다.</p>
</dd></dl>

<dl class="method">
<dt id="pickle.PickleBuffer.release">
<code class="sig-name descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pickle.PickleBuffer.release" title="정의 주소">¶</a></dt>
<dd><p>PickleBuffer 객체에 의해 노출된 하부 버퍼를 해제합니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="what-can-be-pickled-and-unpickled">
<span id="pickle-picklable"></span><h2>어떤 것이 피클 되고 역 피클 될 수 있을까요?<a class="headerlink" href="#what-can-be-pickled-and-unpickled" title="제목 주소">¶</a></h2>
<p>다음 형을 피클 할 수 있습니다:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">True</span></code> 와 <code class="docutils literal notranslate"><span class="pre">False</span></code></p></li>
<li><p>정수, 실수, 복소수</p></li>
<li><p>문자열, 바이트열, 바이트 배열(bytearray)</p></li>
<li><p>피클 가능한 객체만 포함하는 튜플, 리스트, 집합과 딕셔너리</p></li>
<li><p>모듈의 최상위 수준에서 정의된 함수 (<a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 가 아니라 <a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a> 를 사용하는)</p></li>
<li><p>모듈의 최상위 수준에서 정의된 내장 함수</p></li>
<li><p>모듈의 최상위 수준에서 정의된 클래스</p></li>
<li><p>그런 클래스의 인스턴스 중에서 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 나 <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a> 를 호출한 결과가 피클 가능한 것들 (자세한 내용은 <a class="reference internal" href="#pickle-inst"><span class="std std-ref">클래스 인스턴스 피클링</span></a> 절을 참조하세요).</p></li>
</ul>
<p>피클 가능하지 않은 객체를 피클 하려고 하면 <a class="reference internal" href="#pickle.PicklingError" title="pickle.PicklingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PicklingError</span></code></a> 예외가 발생합니다; 이런 일이 일어났을 때, 특정할 수 없는 길이의 바이트열이 하부 파일에 이미 기록되었을 수 있습니다. 매우 재귀적인 데이터 구조를 피클 하려고 하면 최대 재귀 깊이를 초과할 수 있고, 이때 <a class="reference internal" href="exceptions.html#RecursionError" title="RecursionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RecursionError</span></code></a> 가 발생합니다. <a class="reference internal" href="sys.html#sys.setrecursionlimit" title="sys.setrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setrecursionlimit()</span></code></a> 을 사용하여 이 제한을 조심스럽게 올릴 수 있습니다.</p>
<p>함수(내장 및 사용자 정의)는 값이 아니라 &quot;완전히 정규화된&quot; 이름 참조로 피클 됨에 유의하십시오. <a class="footnote-reference brackets" href="#id8" id="id3">2</a> 이것은 함수가 정의된 모듈의 이름과 함께 함수의 이름만 피클 된다는 것을 의미합니다. 함수의 코드도 함수 어트리뷰트도 피클 되지 않습니다. 따라서 정의하는 모듈은 역 피클 환경에서 임포트 가능해야 하며, 모듈에는 그 이름의 객체가 있어야 합니다. 그렇지 않으면 예외가 발생합니다. <a class="footnote-reference brackets" href="#id9" id="id4">3</a></p>
<p>마찬가지로, 클래스는 이름 참조로 피클 되므로 역 피클링 환경에서 같은 제한이 적용됩니다. 클래스의 코드 나 데이터가 피클 되지 않음에 유의하세요. 그래서 다음 예제에서 클래스 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">attr</span></code> 은 역 피클링 환경에서 복원되지 않습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="n">attr</span> <span class="o">=</span> <span class="s1">&#39;A class attribute&#39;</span>

<span class="n">picklestring</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>이 예는 약간 오해의 소지가 있습니다. <code class="docutils literal notranslate"><span class="pre">picklestring</span></code> 에 <code class="docutils literal notranslate"><span class="pre">attr</span></code> 어트리뷰트의 값이 포함되지
않는 것은 맞습니다만, 언피클했을 때 <code class="docutils literal notranslate"><span class="pre">attr</span></code> 어트리뷰트가 사라지는 것은 아닙니다. 피클 데이터는
<code class="docutils literal notranslate"><span class="pre">Foo</span></code> 의 이름 참조만을 포함하고, 언피클하면 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 클래스에 대한 참조로 복원됩니다.
따라서 언피클 환경이 같은 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 의 정의를 포함하고 있다면 <code class="docutils literal notranslate"><span class="pre">attr</span></code> 어트리뷰트 역시 제공됩니다.
다만 <code class="docutils literal notranslate"><span class="pre">attr</span></code> 어트리뷰트가 수정되고 있는 상황이라면 피클 시점의 <code class="docutils literal notranslate"><span class="pre">attr</span></code> 어트리뷰트의 값이
복원되지는 않습니다.</p>
</div>
<p>이러한 제한이 피클 가능한 함수와 클래스가 모듈의 최상위 수준에서 정의되어야 하는 이유입니다.</p>
<p>마찬가지로, 클래스 인스턴스가 피클 될 때, 클래스의 코드와 데이터는 함께 피클 되지 않습니다. 인스턴스 데이터만 피클 됩니다. 이는 의도한 것으로, 클래스의 버그를 수정하거나 클래스에 메서드를 추가할 수 있고, 이전 버전의 클래스로 만들어진 객체를 여전히 로드 할 수 있습니다. 여러 버전의 클래스에 걸치는 수명이 긴 객체를 만들 계획이라면, 클래스의 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> 메서드로 적절한 변환을 할 수 있도록 객체에 버전 번호를 넣는 것이 좋습니다.</p>
</div>
<div class="section" id="pickling-class-instances">
<span id="pickle-inst"></span><h2>클래스 인스턴스 피클링<a class="headerlink" href="#pickling-class-instances" title="제목 주소">¶</a></h2>
<p>이 절에서는 클래스 인스턴스를 피클 및 역 피클 하는 방법을 정의, 사용자 정의 및 제어할 수 있는 일반적인 메커니즘을 설명합니다.</p>
<p>대부분은, 인스턴스를 피클 가능하게 만드는 데 추가 코드가 필요하지 않습니다. 기본적으로, pickle은 인트로스펙션을 통해 인스턴스의 클래스와 어트리뷰트를 조회합니다. 클래스 인스턴스가 역 피클 될 때, <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드는 보통 호출되지 <em>않습니다</em>. 기본 동작은, 먼저 초기화되지 않은 인스턴스를 만든 다음 저장된 어트리뷰트를 복원합니다. 다음 코드는 이 동작의 구현을 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attributes</span><span class="p">):</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>
</pre></div>
</div>
<p>클래스는 다음과 같은 하나 이상의 특수 메서드를 제공하여 기본 동작을 변경할 수 있습니다:</p>
<dl class="method">
<dt id="object.__getnewargs_ex__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getnewargs_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__getnewargs_ex__" title="정의 주소">¶</a></dt>
<dd><p>프로토콜 2 이상에서, <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a> 메서드를 구현하는 클래스는 역 피클링 때 <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 메서드에 전달되는 값을 지시할 수 있습니다. 이 메서드는 <code class="docutils literal notranslate"><span class="pre">(args,</span> <span class="pre">kwargs)</span></code> 쌍을 반환해야 합니다. <em>args</em> 는 위치 인자의 튜플이고 <em>kwargs</em> 는 이름있는 인자의 딕셔너리인데, 객체를 구성하는 데 사용됩니다. 그것들은 역 피클링 때 <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 메서드로 전달될 것입니다.</p>
<p>클래스의 <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 메서드에 키워드 전용 인자가 필요하면 이 메서드를 구현해야 합니다. 그렇지 않으면 호환성을 위해 <a class="reference internal" href="#object.__getnewargs__" title="object.__getnewargs__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs__()</span></code></a> 를 구현하는 것이 좋습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a> 는 이제 프로토콜 2와 3에서 사용됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__getnewargs__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getnewargs__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__getnewargs__" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a> 와 비슷한 목적을 수행하지만, 위치 인자만 지원합니다. 역 피클링 때 <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 메서드에 전달될 인자의 튜플 <code class="docutils literal notranslate"><span class="pre">args</span></code> 를 반환해야 합니다.</p>
<p><a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a> 가 정의되면 <a class="reference internal" href="#object.__getnewargs__" title="object.__getnewargs__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs__()</span></code></a> 는 호출되지 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>파이썬 3.6 이전에는, 프로토콜 2와 3에서 <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a> 대신 <a class="reference internal" href="#object.__getnewargs__" title="object.__getnewargs__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs__()</span></code></a> 가 호출되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__getstate__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getstate__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__getstate__" title="정의 주소">¶</a></dt>
<dd><p>클래스는 인스턴스가 피클 되는 방식에 더 많은 영향을 줄 수 있습니다; 클래스가 메서드 <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a> 를 정의하면, 인스턴스의 딕셔너리 내용 대신, 이 메서드가 호출되고 반환된 객체를 인스턴스의 내용으로 피클 합니다. <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a> 메서드가 없다면, 인스턴스의 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 가 평소와 같이 피클 됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__setstate__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__setstate__</code><span class="sig-paren">(</span><em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setstate__" title="정의 주소">¶</a></dt>
<dd><p>역 피클링 때, 클래스가 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> 를 정의하면, 그것은 역 피클 된 상태(state)로 호출됩니다. 이 경우 상태 객체가 딕셔너리일 필요는 없습니다. 그렇지 않으면, 피클 된 상태는 딕셔너리 여야하고 그 항목이 새 인스턴스의 딕셔너리에 삽입됩니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a> 가 거짓 값을 반환하면, <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> 메서드가 역 피클링 때 호출되지 않습니다.</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a> 와 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> 메서드를 사용하는 방법에 대한 더 자세한 정보는 <a class="reference internal" href="#pickle-state"><span class="std std-ref">상태 저장 객체 처리</span></a> 절을 참조하십시오.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>역 피클링 시간에, <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a>, 또는 <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 같은 메서드가 인스턴스에 호출될 수 있습니다. 그러한 메서드들이 어떤 내부 불변성이 참인 것에 의존하는 경우, 형은 그런 불변성을 유지하기 위해 <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 를 구현해야 합니다, 인스턴스를 역 피클링할 때 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>가 호출되지 않기 때문입니다.</p>
</div>
<p id="index-5">앞으로 살펴보겠지만, 피클은 위에서 설명한 메서드를 직접 사용하지 않습니다. 사실, 이 메서드들은 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 특수 메서드를 구현하는 복사 프로토콜의 일부입니다. 복사 프로토콜은 객체를 피클 하고 복사하는 데 필요한 데이터를 조회하기 위한 통일된 인터페이스를 제공합니다. <a class="footnote-reference brackets" href="#id10" id="id5">4</a></p>
<p>강력하기는 하지만, 여러분의 클래스에서 직접 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 를 구현하면 잘못되기 쉽습니다. 이런 이유로, 클래스 설계자는 가능하면 고수준 인터페이스(즉, <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a>, <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a> 및 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a>)를 사용해야 합니다. 하지만, 우리는 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 를 사용하는 것이 유일한 옵션이거나 더 효율적인 피클링을 제공하거나 혹은 둘 다인 경우를 보여줄 것입니다.</p>
<dl class="method">
<dt id="object.__reduce__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__reduce__" title="정의 주소">¶</a></dt>
<dd><p>인터페이스는 현재 다음과 같이 정의됩니다. <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 메서드는 아무런 인자도 받아들이지 않으며 문자열이나 바람직하게는 튜플을 반환합니다 (반환된 객체는 흔히 &quot;환원 값(reduce value)&quot;이라고 불립니다).</p>
<p>문자열이 반환되면, 문자열은 전역 변수의 이름으로 해석되어야 합니다. 모듈에 상대적인 객체의 지역 이름이어야 합니다; pickle 모듈은 객체의 모듈을 결정하기 위해 모듈 이름 공간을 검색합니다. 이 동작은 일반적으로 싱글톤에 유용합니다.</p>
<p>튜플이 반환될 때는, 길이가 2나 6이 되어야 합니다. 선택적인 항목은 생략되거나 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 값으로 제공될 수 있습니다. 각 항목의 의미는 순서대로 다음과 같습니다:</p>
<ul>
<li><p>객체의 초기 버전을 만들기 위해 호출할 콜러블 객체.</p></li>
<li><p>콜러블 객체에 대한 인자의 튜플. 콜러블 객체가 인자를 받아들이지 않으면 빈 튜플을 제공해야 합니다.</p></li>
<li><p>선택적으로, 객체의 상태. 앞에서 설명한 대로 객체의 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> 메서드에 전달됩니다. 객체에 그런 메서드가 없다면, 그 값은 딕셔너리 여야 하며 객체의 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 어트리뷰트에 추가됩니다.</p></li>
<li><p>선택적으로, 연속적인 항목을 생성하는 이터레이터(시퀀스가 아닙니다). 이 항목들은 <code class="docutils literal notranslate"><span class="pre">obj.append(item)</span></code> 을 사용하거나 한꺼번에 <code class="docutils literal notranslate"><span class="pre">obj.extend(list_of_items)</span></code> 를 사용하여 객체에 추가될 것입니다. 이것은 주로 리스트 서브 클래스에 사용되지만, 적절한 서명을 갖는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code>와 <code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code> 메서드가 있는 한 다른 클래스에서 사용될 수 있습니다. (<code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> 나 <code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code> 중 어느 것이 사용되는지는 어떤 피클 프로토콜 버전이 사용되는가와 추가 할 항목의 수에 따라 달려있으므로 둘 다 지원되어야 합니다.)</p></li>
<li><p>선택적으로, 연속적인 키-값 쌍을 생성하는 이터레이터(시퀀스가 아닙니다). 이 항목들은 <code class="docutils literal notranslate"><span class="pre">obj[key]</span> <span class="pre">=</span> <span class="pre">value</span></code> 를 사용하여 객체에 저장됩니다. 이것은 주로 딕셔너리 서브 클래스에 사용되지만, <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a> 을 구현하는 한 다른 클래스에서 사용될 수 있습니다.</p></li>
<li><p>선택적으로, <code class="docutils literal notranslate"><span class="pre">(obj,</span> <span class="pre">state)</span></code> 서명을 가진 콜러블. 이 콜러블은 <code class="docutils literal notranslate"><span class="pre">obj</span></code>의 정적 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> 메서드 대신에 특정 객체의 상태 갱신 동작을 프로그래밍 방식으로 제어할 수 있도록 합니다. <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면, 이 콜러블은 <code class="docutils literal notranslate"><span class="pre">obj</span></code>의 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a>보다 우선 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가: </span>선택적인 여섯 번째 튜플 항목 <code class="docutils literal notranslate"><span class="pre">(obj,</span> <span class="pre">state)</span></code>가 추가되었습니다.</p>
</div>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="object.__reduce_ex__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__reduce_ex__</code><span class="sig-paren">(</span><em class="sig-param">protocol</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__reduce_ex__" title="정의 주소">¶</a></dt>
<dd><p>또는, <a class="reference internal" href="#object.__reduce_ex__" title="object.__reduce_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce_ex__()</span></code></a> 메서드를 정의할 수 있습니다. 유일한 차이점은 이 메서드가 프로토콜 버전인 단일 정수 인자를 받아들여야 한다는 것입니다. 정의되면, pickle은 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 메서드보다 선호합니다. 또한, <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 는 자동으로 확장 버전의 동의어가 됩니다. 이 메서드의 주된 용도는 구형 파이썬 배포를 위해 과거 호환성 있는 환원 값을 제공하는 것입니다.</p>
</dd></dl>

<div class="section" id="persistence-of-external-objects">
<span id="pickle-persistent"></span><h3>외부 객체의 지속성<a class="headerlink" href="#persistence-of-external-objects" title="제목 주소">¶</a></h3>
<p id="index-6">객체 지속성의 효용을 위해, <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈은 피클 된 데이터 스트림 밖의 객체에 대한 참조 개념을 지원합니다. 이러한 객체는 지속성 ID에 의해 참조되며, 영숫자 문자열(프로토콜 0의 경우) <a class="footnote-reference brackets" href="#id11" id="id6">5</a> 또는 임의의 객체(모든 최신 프로토콜의 경우)여야 합니다.</p>
<p>그러한 지속성 ID의 해석은 <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈에 의해 정의되지 않습니다; 이 해석을 피클러와 역 피클러의 사용자 정의 메서드에 위임합니다, 각각 <a class="reference internal" href="#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_id()</span></code></a>와 <a class="reference internal" href="#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_load()</span></code></a>.</p>
<p>지속성 ID를 가진 객체를 피클 하기 위해서, 피클러는 객체를 인자로 받아서 그 객체에 대해 <code class="docutils literal notranslate"><span class="pre">None</span></code> 또는 지속성 ID를 반환하는 사용자 정의 <a class="reference internal" href="#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_id()</span></code></a> 메서드가 있어야 합니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 반환되면, 피클러는 단순히 객체를 피클 합니다. 지속성 ID 문자열이 반환되면, 피클러는 마커와 함께 해당 객체를 피클 하여 역 피클러가 이를 지속성 ID로 인식하게 합니다.</p>
<p>외부 객체를 역 피클 하려면, 역 피클러는 지속성 ID 객체를 받아들여 참조된 객체를 반환하는 사용자 정의 <a class="reference internal" href="#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_load()</span></code></a> 메서드를 가져야 합니다.</p>
<p>다음은 지속성 ID를 외부 객체를 참조로 피클 하는데 사용하는 방법을 보여주는 포괄적인 예입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 지속성 ID를 외부 객체를 참조로 피클 하는데 사용하는 방법을 보여주는 간단한 예제.</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>

<span class="c1"># 우리 데이터베이스의 레코드를 나타내는 간단한 클래스.</span>
<span class="n">MemoRecord</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;MemoRecord&quot;</span><span class="p">,</span> <span class="s2">&quot;key, task&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DBPickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">persistent_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="c1"># MemoRecord를 일반 클래스 인스턴스로 피클 하는 대신, 지속성 ID를 출력합니다.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">MemoRecord</span><span class="p">):</span>
            <span class="c1"># 여기서, 우리의 지속성 ID는 태그와 데이터베이스의 특정 레코드를 참조하는 키를 포함하는</span>
            <span class="c1"># 단순한 튜플입니다.</span>
            <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;MemoRecord&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># obj에 지속성 ID가 없으면, None을 반환합니다. 이것은 obj가 평소와 같이 피클 되어야</span>
            <span class="c1"># 함을 의미합니다.</span>
            <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">DBUnpickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Unpickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="n">connection</span>

    <span class="k">def</span> <span class="nf">persistent_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pid</span><span class="p">):</span>
        <span class="c1"># 이 메서드는, 지속성 ID를 만날 때마다 호출됩니다.</span>
        <span class="c1"># 여기에서, pid는 DBPickler가 반환한 튜플입니다.</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="n">type_tag</span><span class="p">,</span> <span class="n">key_id</span> <span class="o">=</span> <span class="n">pid</span>
        <span class="k">if</span> <span class="n">type_tag</span> <span class="o">==</span> <span class="s2">&quot;MemoRecord&quot;</span><span class="p">:</span>
            <span class="c1"># 데이터베이스에서 참조 된 레코드를 반입하여 리턴하십시오.</span>
            <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM memos WHERE key=?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key_id</span><span class="p">),))</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">task</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">MemoRecord</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 올바른 객체를 반환할 수 없으면 항상 에러를 일으켜야 합니다. 그렇지 않으면, 언피클러는</span>
            <span class="c1"># None이 지속성 ID에 의해 참조되는 객체라고 생각할 것입니다.</span>
            <span class="k">raise</span> <span class="n">pickle</span><span class="o">.</span><span class="n">UnpicklingError</span><span class="p">(</span><span class="s2">&quot;unsupported persistent object&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">io</span>
    <span class="kn">import</span> <span class="nn">pprint</span>

    <span class="c1"># 데이터베이스를 초기화하고 값을 채웁니다.</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)&quot;</span><span class="p">)</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;give food to fish&#39;</span><span class="p">,</span>
        <span class="s1">&#39;prepare group meeting&#39;</span><span class="p">,</span>
        <span class="s1">&#39;fight with a zebra&#39;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;INSERT INTO memos VALUES(NULL, ?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">task</span><span class="p">,))</span>

    <span class="c1"># 피클 할 레코드를 가져옵니다.</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM memos&quot;</span><span class="p">)</span>
    <span class="n">memos</span> <span class="o">=</span> <span class="p">[</span><span class="n">MemoRecord</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">]</span>
    <span class="c1"># 사용자 정의 DBPickler를 사용하여 레코드를 저장합니다.</span>
    <span class="n">file</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
    <span class="n">DBPickler</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Pickled records:&quot;</span><span class="p">)</span>
    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>

    <span class="c1"># 확인을 위해 레코드를 갱신합니다.</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;UPDATE memos SET task=&#39;learn italian&#39; WHERE key=1&quot;</span><span class="p">)</span>

    <span class="c1"># 피클 데이터 스트림에서 레코드를 로드합니다.</span>
    <span class="n">file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">memos</span> <span class="o">=</span> <span class="n">DBUnpickler</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unpickled records:&quot;</span><span class="p">)</span>
    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="dispatch-tables">
<span id="pickle-dispatch"></span><h3>디스패치 테이블<a class="headerlink" href="#dispatch-tables" title="제목 주소">¶</a></h3>
<p>피클링에 의존하는 다른 코드를 방해하지 않고 일부 클래스의 피클링을 사용자 정의하려면, 사설 디스패치 테이블을 갖는 피클러를 만들 수 있습니다.</p>
<p><a class="reference internal" href="copyreg.html#module-copyreg" title="copyreg: Register pickle support functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code></a> 모듈에 의해 관리되는 전역 디스패치 테이블은 <code class="xref py py-data docutils literal notranslate"><span class="pre">copyreg.dispatch_table</span></code>로 사용 가능합니다. 그러므로, 사설 디스패치 테이블로 <code class="xref py py-data docutils literal notranslate"><span class="pre">copyreg.dispatch_table</span></code> 의 수정된 복사본을 사용할 수 있습니다.</p>
<p>예를 들면</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">dispatch_table</span> <span class="o">=</span> <span class="n">copyreg</span><span class="o">.</span><span class="n">dispatch_table</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">dispatch_table</span><span class="p">[</span><span class="n">SomeClass</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_SomeClass</span>
</pre></div>
</div>
<p>는 <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code> 클래스를 특별히 처리하는 사설 디스패치 테이블을 갖는 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">pickle.Pickler</span></code></a> 의 인스턴스를 생성합니다. 또는, 코드</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyPickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">):</span>
    <span class="n">dispatch_table</span> <span class="o">=</span> <span class="n">copyreg</span><span class="o">.</span><span class="n">dispatch_table</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">dispatch_table</span><span class="p">[</span><span class="n">SomeClass</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_SomeClass</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">MyPickler</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>가 같은 일을 하지만, <code class="docutils literal notranslate"><span class="pre">MyPickler</span></code> 의 모든 인스턴스는 기본적으로 같은 디스패치 테이블을 공유합니다. <a class="reference internal" href="copyreg.html#module-copyreg" title="copyreg: Register pickle support functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code></a> 모듈을 사용하는 동등한 코드는 다음과 같습니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">copyreg</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="n">reduce_SomeClass</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="handling-stateful-objects">
<span id="pickle-state"></span><h3>상태 저장 객체 처리<a class="headerlink" href="#handling-stateful-objects" title="제목 주소">¶</a></h3>
<p id="index-7">다음은 클래스의 피클 동작을 수정하는 방법을 보여주는 예제입니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">TextReader</span></code> 클래스는 텍스트 파일을 열고, <code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code> 메서드가 호출될 때마다 줄 번호와 줄 내용을 반환합니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">TextReader</span></code> 인스턴스가 피클 되면, 파일 객체 멤버를 <em>제외한</em> 모든 어트리뷰트가 저장됩니다. 인스턴스가 역 피클 될 때, 파일이 다시 열리고, 마지막 위치에서 읽기가 다시 시작됩니다. <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> 와 <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a> 메서드가 이 행동을 구현하는 데 사용됩니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TextReader</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;텍스트 파일의 줄을 인쇄하고 번호를 매깁니다.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineno</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineno</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%i</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 우리의 모든 인스턴스 어트리뷰트를 포함하는 self.__dict__ 에서 객체의</span>
        <span class="c1"># 상태를 복사합니다. 원래 상태를 수정하지 않으려면 항상 dict.copy()</span>
        <span class="c1"># 메서드를 사용하십시오.</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># 피클 가능하지 않은 항목을 제거합니다.</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># 인스턴스 어트리뷰트(즉, filename 과 lineno)를 복원합니다.</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="c1"># 이전에 열린 파일의 상태를 복원합니다. 그렇게 하려면, 다시 열어서 행 수를 복원할</span>
        <span class="c1"># 때까지 읽어야 합니다.</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineno</span><span class="p">):</span>
            <span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="c1"># 마지막으로, 파일을 저장합니다.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span>
</pre></div>
</div>
<p>사용 예는 다음과 같은 식입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span> <span class="o">=</span> <span class="n">TextReader</span><span class="p">(</span><span class="s2">&quot;hello.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;1: Hello world!&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;2: I am line number two.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_reader</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">reader</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;3: Goodbye!&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="custom-reduction-for-types-functions-and-other-objects">
<span id="reducer-override"></span><h2>형, 함수 및 기타 객체에 대한 사용자 정의 환원<a class="headerlink" href="#custom-reduction-for-types-functions-and-other-objects" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
<p>때로, <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a>이 충분히 유연하지 않을 수 있습니다. 특히 객체의 형이 아닌 다른 기준에 따라 피클링을 사용자 정의하거나, 함수와 클래스 피클링을 사용자 정의하고 싶을 수 있습니다.</p>
<p>이럴 때, <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 클래스의 서브 클래스를 만들고 <a class="reference internal" href="#pickle.Pickler.reducer_override" title="pickle.Pickler.reducer_override"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reducer_override()</span></code></a> 메서드를 구현할 수 있습니다. 이 메서드는 임의의 환원 튜플을 반환할 수 있습니다 (<a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a>를 참조하십시오). 또는 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>를 반환하여 전통적인 동작으로 폴백(fallback)할 수 있습니다.</p>
<p><a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a>과 <a class="reference internal" href="#pickle.Pickler.reducer_override" title="pickle.Pickler.reducer_override"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reducer_override()</span></code></a>가 모두 정의되면, <a class="reference internal" href="#pickle.Pickler.reducer_override" title="pickle.Pickler.reducer_override"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reducer_override()</span></code></a> 메서드가 우선합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>성능상의 이유로, 다음과 같은 객체에 대해서는 <a class="reference internal" href="#pickle.Pickler.reducer_override" title="pickle.Pickler.reducer_override"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reducer_override()</span></code></a>가 호출되지 않을 수 있습니다: <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code> 및 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 및 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>의 정확한(exact) 인스턴스.</p>
</div>
<p>다음은 주어진 클래스를 피클링하고 재구성할 수 있도록 하는 간단한 예제입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="n">my_attribute</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">class</span> <span class="nc">MyPickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">reducer_override</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;MyClass를 위한 사용자 정의 환원자.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;MyClass&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">,</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">,</span>
                          <span class="p">{</span><span class="s1">&#39;my_attribute&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">my_attribute</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 다른 모든 객체는, 일반적인 환원을 사용합니다</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">MyPickler</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span>

<span class="k">del</span> <span class="n">MyClass</span>

<span class="n">unpickled_class</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unpickled_class</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">unpickled_class</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;MyClass&quot;</span>
<span class="k">assert</span> <span class="n">unpickled_class</span><span class="o">.</span><span class="n">my_attribute</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="out-of-band-buffers">
<span id="pickle-oob"></span><h2>아웃 오브 밴드 버퍼<a class="headerlink" href="#out-of-band-buffers" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
<p>일부 상황에서는, <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈을 사용하여 많은 양의 데이터를 전송합니다. 따라서 성능과 자원 소비를 보존하기 위해 메모리 복사 횟수를 최소화하는 것이 중요할 수 있습니다. 그러나, <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈의 정상적인 작동은, 객체의 그래프(graph)적인 구조를 순차적인 바이트 스트림으로 변환하기 때문에, 본질적으로 피클 스트림과의 데이터 복사를 수반합니다.</p>
<p><em>제공자(provider)</em>(전송될 객체 형의 구현)와 <em>소비자(consumer)</em>(통신 시스템의 구현)가 모두 피클 프로토콜 5 이상에서 제공되는 아웃 오브 밴드 전송 기능을 지원하면 이 제약 조건을 피할 수 있습니다.</p>
<div class="section" id="provider-api">
<h3>제공자 API<a class="headerlink" href="#provider-api" title="제목 주소">¶</a></h3>
<p>피클 될 대형 데이터 객체는 프로토콜 5 이상에 특화된 <a class="reference internal" href="#object.__reduce_ex__" title="object.__reduce_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce_ex__()</span></code></a> 메서드를 구현해야 합니다. 이 메서드는 대형 데이터에 대해 (예를 들어 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체 대신) <a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> 인스턴스를 반환합니다.</p>
<p><a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> 객체는 하부 버퍼가 아웃 오브 밴드 전송 대상이라는 <em>신호를 보냅니다</em>. 이러한 객체는 <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈의 일반적인 사용과 호환됩니다. 그러나, 소비자는 <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a>에게 그 버퍼를 스스로 처리하겠다고 알릴 수도 있습니다.</p>
</div>
<div class="section" id="consumer-api">
<h3>소비자 API<a class="headerlink" href="#consumer-api" title="제목 주소">¶</a></h3>
<p>통신 시스템은 객체 그래프를 직렬화할 때 생성된 <a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> 객체의 사용자 정의 처리를 활성화할 수 있습니다.</p>
<p>송신 측에서는, <em>buffer_callback</em> 인자를 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> (또는 <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a>나 <a class="reference internal" href="#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">dumps()</span></code></a> 함수)에 전달해야 합니다. 이 인자는 객체 그래프를 피클링할 때 생성된 각 <a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a>로 호출됩니다. <em>buffer_callback</em>에 의해 누적된 버퍼는 피클 스트림으로 복사되지 않고, 저렴한 마커만 삽입됩니다.</p>
<p>수신 측에서는, <em>buffer_callback</em>에 전달된 버퍼의 이터러블인 <em>buffers</em> 인자를 <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a> (또는 <a class="reference internal" href="#pickle.load" title="pickle.load"><code class="xref py py-func docutils literal notranslate"><span class="pre">load()</span></code></a>나 <a class="reference internal" href="#pickle.loads" title="pickle.loads"><code class="xref py py-func docutils literal notranslate"><span class="pre">loads()</span></code></a> 함수)에 전달해야 합니다. 그 이터러블은 <em>buffer_callback</em>에 전달된 것과 같은 순서로 버퍼를 만들어야 합니다. 이러한 버퍼는 피클링이 원래 <a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> 객체를 생성한 객체의 재구성자가 기대하는 데이터를 제공합니다.</p>
<p>송신 측과 수신 측 사이에서, 통신 시스템은 아웃 오브 밴드 버퍼를 위한 자체 전송 메커니즘을 자유롭게 구현할 수 있습니다. 잠재적인 최적화에는 공유 메모리나 데이터 유형에 따른 압축이 포함됩니다.</p>
</div>
<div class="section" id="example">
<h3>예제<a class="headerlink" href="#example" title="제목 주소">¶</a></h3>
<p>다음은 아웃 오브 버퍼 피클링에 참여할 수 있는 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 서브 클래스를 구현하는 간단한 예제입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ZeroCopyByteArray</span><span class="p">(</span><span class="nb">bytearray</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__reduce_ex__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">protocol</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_reconstruct</span><span class="p">,</span> <span class="p">(</span><span class="n">PickleBuffer</span><span class="p">(</span><span class="bp">self</span><span class="p">),),</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># PickleBuffer는 피클 프로토콜 &lt;= 4 에서는 금지됩니다.</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_reconstruct</span><span class="p">,</span> <span class="p">(</span><span class="nb">bytearray</span><span class="p">(</span><span class="bp">self</span><span class="p">),)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_reconstruct</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
            <span class="c1"># 원래 버퍼 객체에 대한 핸들을 얻습니다</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">cls</span><span class="p">:</span>
                <span class="c1"># 원래 버퍼 객체는 ZeroCopyByteArray 이며, 그대로 반환합니다.</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>재구성자(<code class="docutils literal notranslate"><span class="pre">_reconstruct</span></code> 클래스 메서드)는 올바른 형이면 버퍼를 제공하는 객체를 반환합니다. 이것은 이 장난감 예제에서 제로-복사 동작을 흉내 내는 손쉬운 방법입니다.</p>
<p>소비자 측에서는, 그 객체들을 일반적인 방법으로 피클 할 수 있습니다. 역 직렬화될 때 원래 객체의 사본을 제공합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">ZeroCopyByteArray</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">new_b</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">new_b</span><span class="p">)</span>  <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span> <span class="ow">is</span> <span class="n">new_b</span><span class="p">)</span>  <span class="c1"># False: 복사가 발생했습니다</span>
</pre></div>
</div>
<p>그러나 <em>buffer_callback</em>을 전달하고 역 직렬화할 때 누적된 버퍼를 돌려주면, 원래의 객체를 다시 얻을 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">ZeroCopyByteArray</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="n">buffers</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">buffer_callback</span><span class="o">=</span><span class="n">buffers</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
<span class="n">new_b</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">buffers</span><span class="o">=</span><span class="n">buffers</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">new_b</span><span class="p">)</span>  <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span> <span class="ow">is</span> <span class="n">new_b</span><span class="p">)</span>  <span class="c1"># True: 복사가 발생하지 않았습니다</span>
</pre></div>
</div>
<p>이 예제는 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>가 자체 메모리를 할당한다는 사실로 인해 제한됩니다: 즉, 다른 객체의 메모리를 사용하는 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 인스턴스를 만들 수 없습니다. 그러나, NumPy 배열과 같은 제삼자 데이터형에는 이러한 제한이 없으며, 별개의 프로세스나 시스템 간에 전송할 때 제로-복사 피클링(또는 최소한의 복사)을 사용할 수 있습니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><span class="target" id="index-17"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0574"><strong>PEP 574</strong></a> -- 아웃 오브 밴드 데이터를 포함하는 피클 프로토콜 5</p>
</div>
</div>
</div>
<div class="section" id="restricting-globals">
<span id="pickle-restrict"></span><h2>전역 제한하기<a class="headerlink" href="#restricting-globals" title="제목 주소">¶</a></h2>
<p id="index-9">기본적으로, 역 피클링은 피클 데이터에서 찾은 모든 클래스나 함수를 임포트 합니다. 많은 응용 프로그램에서는, 역 피클러가 임의 코드를 임포트하고 호출할 수 있으므로, 이 동작을 받아들일 수 없습니다. 이 손으로 만든 피클 데이터 스트림이 로드될 때 하는 일을 생각해보십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;cos</span><span class="se">\n</span><span class="s2">system</span><span class="se">\n</span><span class="s2">(S&#39;echo hello world&#39;</span><span class="se">\n</span><span class="s2">tR.&quot;</span><span class="p">)</span>
<span class="go">hello world</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> 은 <code class="docutils literal notranslate"><span class="pre">pickle.loads()</span></code> 가 반환한 값이고, <code class="docutils literal notranslate"><span class="pre">hello</span> <span class="pre">world</span></code> 는 언 피클 과정에서
콘솔에 출력된 내용입니다. 이 피클 스트림은 프로토콜 0으로 구성된 것인데, 끝부분에 있는 <code class="docutils literal notranslate"><span class="pre">R</span></code>
이 <code class="docutils literal notranslate"><span class="pre">REDUCE</span></code> 라는 옵코드입니다. <code class="docutils literal notranslate"><span class="pre">REDUCE</span></code> 는 콜러블과 튜플을 사용해서 호출한 후 결과를
취합니다. 즉 <code class="docutils literal notranslate"><span class="pre">0</span></code> 은 <code class="docutils literal notranslate"><span class="pre">os.system('echo</span> <span class="pre">hello</span> <span class="pre">world')</span></code> 의 반환 값입니다.
<a class="reference internal" href="pickletools.html#pickletools.dis" title="pickletools.dis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pickletools.dis()</span></code></a> 로 피클 스트림을 디코딩해보면 이렇습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickletools</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickletools</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;cos</span><span class="se">\n</span><span class="s2">system</span><span class="se">\n</span><span class="s2">(S&#39;echo hello world&#39;</span><span class="se">\n</span><span class="s2">tR.&quot;</span><span class="p">)</span>
<span class="go">    0: c    GLOBAL     &#39;os system&#39;</span>
<span class="go">   11: (    MARK</span>
<span class="go">   12: S        STRING     &#39;echo hello world&#39;</span>
<span class="go">   32: t        TUPLE      (MARK at 11)</span>
<span class="go">   33: R    REDUCE</span>
<span class="go">   34: .    STOP</span>
<span class="go">highest protocol among opcodes = 0</span>
</pre></div>
</div>
</div>
<p>이 예제에서, 역 피클러는 <a class="reference internal" href="os.html#os.system" title="os.system"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.system()</span></code></a> 함수를 임포트하고 문자열 인자 &quot;echo hello world&quot;를 적용합니다. 이 예제가 공격적이지는 않지만, 어떤 것들은 시스템을 손상할 수 있다고 상상하기 어렵지 않습니다.</p>
<p>이런 이유로, 여러분은 <a class="reference internal" href="#pickle.Unpickler.find_class" title="pickle.Unpickler.find_class"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Unpickler.find_class()</span></code></a>를 사용자 정의하여 언 피클 되는 것을 제어하고 싶을 수 있습니다. 이름이 제안하는 것과는 달리, <a class="reference internal" href="#pickle.Unpickler.find_class" title="pickle.Unpickler.find_class"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Unpickler.find_class()</span></code></a> 는 전역(즉, 클래스나 함수)이 요청될 때마다 호출됩니다. 따라서 전역을 완전히 금지하거나 안전한 부분집합으로 제한할 수 있습니다.</p>
<p>다음은 <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 모듈에서 몇 가지 안전한 클래스만 로드되도록 허용하는 역 피클러의 예입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">safe_builtins</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;range&#39;</span><span class="p">,</span>
    <span class="s1">&#39;complex&#39;</span><span class="p">,</span>
    <span class="s1">&#39;set&#39;</span><span class="p">,</span>
    <span class="s1">&#39;frozenset&#39;</span><span class="p">,</span>
    <span class="s1">&#39;slice&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">RestrictedUnpickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Unpickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">find_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># builtins의 안전한 클래스만 허용합니다.</span>
        <span class="k">if</span> <span class="n">module</span> <span class="o">==</span> <span class="s2">&quot;builtins&quot;</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">safe_builtins</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">builtins</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="c1"># 다른 모든 것을 금지합니다.</span>
        <span class="k">raise</span> <span class="n">pickle</span><span class="o">.</span><span class="n">UnpicklingError</span><span class="p">(</span><span class="s2">&quot;global &#39;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&#39; is forbidden&quot;</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">restricted_loads</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;pickle.loads()와 유사한 도움 함수.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">RestrictedUnpickler</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
</pre></div>
</div>
<p>우리의 역 피클러 작업이 의도한 사용 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">)]))</span>
<span class="go">[1, 2, range(0, 15)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;cos</span><span class="se">\n</span><span class="s2">system</span><span class="se">\n</span><span class="s2">(S&#39;echo hello world&#39;</span><span class="se">\n</span><span class="s2">tR.&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">pickle.UnpicklingError</span>: <span class="n">global &#39;os.system&#39; is forbidden</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;cbuiltins</span><span class="se">\n</span><span class="s1">eval</span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="gp">... </span>                 <span class="sa">b</span><span class="s1">&#39;(S</span><span class="se">\&#39;</span><span class="s1">getattr(__import__(&quot;os&quot;), &quot;system&quot;)&#39;</span>
<span class="gp">... </span>                 <span class="sa">b</span><span class="s1">&#39;(&quot;echo hello world&quot;)</span><span class="se">\&#39;\n</span><span class="s1">tR.&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">pickle.UnpicklingError</span>: <span class="n">global &#39;builtins.eval&#39; is forbidden</span>
</pre></div>
</div>
<p>예를 통해 알 수 있듯이, 역 피클을 허락하는 것에 주의를 기울여야 합니다. 따라서 보안이 중요하다면, <a class="reference internal" href="xmlrpc.client.html#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc.client</span></code></a> 나 제삼자 솔루션의 마샬링 API 같은 대안을 고려할 수 있습니다.</p>
</div>
<div class="section" id="performance">
<h2>성능<a class="headerlink" href="#performance" title="제목 주소">¶</a></h2>
<p>최신 버전의 피클 프로토콜(프로토콜 2 이상)은 몇 가지 공통 기능 및 내장형에 대한 효율적인 바이너리 인코딩을 제공합니다. 또한, <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 모듈은 C로 작성된 투명한 최적화기를 가지고 있습니다.</p>
</div>
<div class="section" id="examples">
<span id="pickle-example"></span><h2>예제<a class="headerlink" href="#examples" title="제목 주소">¶</a></h2>
<p>가장 간단한 코드로, <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a>와 <a class="reference internal" href="#pickle.load" title="pickle.load"><code class="xref py py-func docutils literal notranslate"><span class="pre">load()</span></code></a> 함수를 사용하십시오.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="c1"># pickle이 지원하는 임의의 객체 모음.</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">],</span>
    <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;character string&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;byte string&quot;</span><span class="p">),</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.pickle&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c1"># 사용 가능한 가장 높은 프로토콜을 사용하여 &#39;data&#39; 딕셔너리를 피클 합니다.</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
</pre></div>
</div>
<p>다음 예제는 결과로 나온 피클 데이터를 읽습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.pickle&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c1"># 사용된 프로토콜 버전이 자동으로 감지되므로, 지정할 필요가 없습니다.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt>모듈 <a class="reference internal" href="copyreg.html#module-copyreg" title="copyreg: Register pickle support functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code></a></dt><dd><p>확장형에 대한 피클 인터페이스 생성자 등록</p>
</dd>
<dt>모듈 <a class="reference internal" href="pickletools.html#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickletools</span></code></a></dt><dd><p>피클 된 데이터로 작업하고 분석하는 도구.</p>
</dd>
<dt>모듈 <a class="reference internal" href="shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a></dt><dd><p>객체의 인덱싱 된 데이터베이스; <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a>을 사용합니다.</p>
</dd>
<dt>모듈 <a class="reference internal" href="copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copy</span></code></a></dt><dd><p>얕거나 깊은 객체 복사.</p>
</dd>
<dt>모듈 <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a></dt><dd><p>내장형의 고성능 직렬화.</p>
</dd>
</dl>
</div>
<p class="rubric">각주</p>
<dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>이것을 <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 모듈과 혼동하지 마십시오.</p>
</dd>
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>이것이 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code> 함수가 pickle 될 수 없는 이유입니다: 모든 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 함수는 같은 이름을 공유합니다: <code class="docutils literal notranslate"><span class="pre">&lt;lambda&gt;</span></code>.</p>
</dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>발생하는 예외는 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 나 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 일 가능성이 크지만, 그 밖의 다른 것일 수 있습니다.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id5">4</a></span></dt>
<dd><p><a class="reference internal" href="copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copy</span></code></a> 모듈은 얕거나 깊은 복사 연산에 이 프로토콜을 사용합니다.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id6">5</a></span></dt>
<dd><p>영숫자 문자의 제한은 프로토콜 0에서 지속성 ID가 개행 문자로 구분되기 때문입니다. 따라서 지속성 ID에 개행 문자가 포함되면 결과 피클을 읽을 수 없게 됩니다.</p>
</dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> --- 파이썬 객체 직렬화</a><ul>
<li><a class="reference internal" href="#relationship-to-other-python-modules">다른 파이썬 모듈과의 관계</a><ul>
<li><a class="reference internal" href="#comparison-with-marshal"><code class="docutils literal notranslate"><span class="pre">marshal</span></code> 과의 비교</a></li>
<li><a class="reference internal" href="#comparison-with-json"><code class="docutils literal notranslate"><span class="pre">json</span></code> 과의 비교</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-stream-format">데이터 스트림 형식</a></li>
<li><a class="reference internal" href="#module-interface">모듈 인터페이스</a></li>
<li><a class="reference internal" href="#what-can-be-pickled-and-unpickled">어떤 것이 피클 되고 역 피클 될 수 있을까요?</a></li>
<li><a class="reference internal" href="#pickling-class-instances">클래스 인스턴스 피클링</a><ul>
<li><a class="reference internal" href="#persistence-of-external-objects">외부 객체의 지속성</a></li>
<li><a class="reference internal" href="#dispatch-tables">디스패치 테이블</a></li>
<li><a class="reference internal" href="#handling-stateful-objects">상태 저장 객체 처리</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-reduction-for-types-functions-and-other-objects">형, 함수 및 기타 객체에 대한 사용자 정의 환원</a></li>
<li><a class="reference internal" href="#out-of-band-buffers">아웃 오브 밴드 버퍼</a><ul>
<li><a class="reference internal" href="#provider-api">제공자 API</a></li>
<li><a class="reference internal" href="#consumer-api">소비자 API</a></li>
<li><a class="reference internal" href="#example">예제</a></li>
</ul>
</li>
<li><a class="reference internal" href="#restricting-globals">전역 제한하기</a></li>
<li><a class="reference internal" href="#performance">성능</a></li>
<li><a class="reference internal" href="#examples">예제</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="persistence.html"
                        title="이전 장">데이터 지속성</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="copyreg.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code> --- <code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> 지원 함수 등록</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="copyreg.html" title="copyreg --- pickle 지원 함수 등록"
             >다음</a> |</li>
        <li class="right" >
          <a href="persistence.html" title="데이터 지속성"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="persistence.html" >데이터 지속성</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>