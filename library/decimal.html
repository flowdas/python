
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>decimal --- 십진 고정 소수점 및 부동 소수점 산술 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="fractions --- 유리수" href="fractions.html" />
    <link rel="prev" title="cmath --- Mathematical functions for complex numbers" href="cmath.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/library/decimal.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="fractions.html" title="fractions --- 유리수"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="cmath.html" title="cmath --- Mathematical functions for complex numbers"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="numeric.html" accesskey="U">숫자와 수학 모듈</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-decimal">
<span id="decimal-decimal-fixed-point-and-floating-point-arithmetic"></span><h1><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> --- 십진 고정 소수점 및 부동 소수점 산술<a class="headerlink" href="#module-decimal" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/decimal.py">Lib/decimal.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 모듈은 빠르고 정확하게 자리 올림 하는 십진 부동 소수 산술을 지원합니다. <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 데이터형보다 다음과 같은 몇 가지 장점을 제공합니다:</p>
<ul>
<li><p class="first">Decimal &quot;은 사람을 염두에 두고 설계된 부동 소수점 모델에 기반하고, 필연적으로 최고 원리를 갖습니다 -- 컴퓨터는 사람들이 학교에서 배우는 산술과 같은 방식으로 동작하는 산술을 반드시 제공해야 한다.&quot; -- 십진 산술 명세에서 발췌.</p>
</li>
<li><p class="first">Decimal 수는 정확하게 표현할 수 있습니다. 반면에, <code class="xref py py-const docutils literal notranslate"><span class="pre">1.1</span></code>과 <code class="xref py py-const docutils literal notranslate"><span class="pre">2.2</span></code>와 같은 수는, 이진 부동 소수점으로 정확히 표현할 수 없습니다. 최종 사용자는 일반적으로 이진 부동 소수점에서 그러하듯이 <code class="docutils literal notranslate"><span class="pre">1.1</span> <span class="pre">+</span> <span class="pre">2.2</span></code> 가 <code class="xref py py-const docutils literal notranslate"><span class="pre">3.3000000000000003</span></code>처럼 표시되는 것을 기대하지 않을 것입니다.</p>
</li>
<li><p class="first">정확성은 산술에서도 유지됩니다. 십진 부동 소수점에서, <code class="docutils literal notranslate"><span class="pre">0.1</span> <span class="pre">+</span> <span class="pre">0.1</span> <span class="pre">+</span> <span class="pre">0.1</span> <span class="pre">-</span> <span class="pre">0.3</span></code> 는 정확하게 0과 같습니다. 이진 부동 소수점에서, 결과는 <code class="xref py py-const docutils literal notranslate"><span class="pre">5.5511151231257827e-017</span></code> 입니다. 0에 가깝지만, 차이가 신뢰할 수 있는 동등성 검사를 방해하고, 차이는 누적 될 수 있습니다. 이러한 이유로, 강한 동등성 불변 조건을 갖는 회계 응용 프로그램에서는 decimal이 선호됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">십진 소수를 유지하기 때문에, 진법 변환으로 인한 부정확함이 없다는 뜻이지, 산술의 결과를 항상
정확하게 유지할 수 있다는 뜻이 아닙니다. 가령 나눗셈이 수반되면 무한 소수가 만들어질 수 있는데,
Decimal 은 무한 소수를 정확하게 표현하지 못합니다. Decimal 은 항상 유한한 정밀도를 유지하고,
자리 올림을 통해 무한 소수의 근사값을 취합니다.</p>
</div>
</li>
<li><p class="first">decimal 모듈은 유효 자릿수의 개념을 포함하고 있으므로 <code class="docutils literal notranslate"><span class="pre">1.30</span> <span class="pre">+</span> <span class="pre">1.20</span></code> 은 <code class="xref py py-const docutils literal notranslate"><span class="pre">2.50</span></code> 입니다. 후행 0은 유효성을 나타내기 위해 유지됩니다. 이것은 화폐 응용에서는 관례적인 표현입니다. 곱셈의 경우, &quot;교과서&quot; 접근법은 피승수의 모든 숫자를 사용합니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">1.3</span> <span class="pre">*</span> <span class="pre">1.2</span></code> 는 <code class="xref py py-const docutils literal notranslate"><span class="pre">1.56</span></code> 이고, <code class="docutils literal notranslate"><span class="pre">1.30</span> <span class="pre">*</span> <span class="pre">1.20</span></code> 은 <code class="xref py py-const docutils literal notranslate"><span class="pre">1.5600</span></code> 입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">예전에는 (요즘은 없어졌을 가능성이 높습니다. 중3에게 물어보니 들어본적이 없다네요) 중등 교과 과정에
&quot;유효 숫자&quot; 라는 개념이 포함되어 있었습니다.
유효 숫자는 숫자의 불확실성에 관한 것인데, 주로 실험적으로 어떤 숫자를 얻을 때 쓸모있는 개념입니다.
가령 눈금자로 길이를 측정할 때 보통 마지막 눈금을 쪼개서 읽을겁니다. 가령 <code class="docutils literal notranslate"><span class="pre">1.25</span></code> cm. 그런데
정확히 눈금과 일치할 때는 <code class="docutils literal notranslate"><span class="pre">1.20</span></code> 이라고 읽을 것입니다. 이 때 <code class="docutils literal notranslate"><span class="pre">1.2</span></code> 와 <code class="docutils literal notranslate"><span class="pre">1.20</span></code> 은
다르며 끝의 <code class="docutils literal notranslate"><span class="pre">0</span></code> 은 한 수준 높은 정밀도를 표현합니다. 디지털 저울을 읽을 때도 마찬가지 입니다.
소수점 한자리까지 표시하는 저울과 두자리까지 표시하는 저울은 그 정밀도가 다릅니다.</p>
</div>
</li>
<li><p class="first">하드웨어 기반 이진 부동 소수점과는 달리, decimal 모듈은 사용자가 변경할 수 있는 정밀도(기본값은 28자리)를 가지며, 주어진 문제에 따라 필요한 만큼 커질 수 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1428571428571428571428571429&#39;)</span>
</pre></div>
</div>
</li>
<li><p class="first">이진 및 십진 부동 소수점 모두 출판된 표준에 따라 구현됩니다. 내장 float 형이 기능의 적당한 부분만을 드러내지만, decimal 모듈은 표준의 모든 필수 부분을 노출합니다. 필요한 경우, 프로그래머는 자리 올림(rounding) 및 신호(signal) 처리를 완전히 제어할 수 있습니다. 여기에는 정확하지 않은 연산을 차단하기 위한 예외를 사용하여 정확한 산술을 강제하는 옵션이 포함됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">rounding 을 흔히 쓰는 &quot;반올림&quot; 대신 &quot;자리 올림&quot; 이라고 번역합니다. decimal 에서 지원하는 rounding
은 8가지인데, 이중 일부만 &quot;반올림&quot;에 해당하기 때문입니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">signal 은 <a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 모듈의 시그널과 구분하기위해 &quot;신호&quot; 라고 번역합니다. 하지만 두 signal 이
아주 관계 없는 것은 아닙니다. 부동 소수점 산술은 하드웨어 구현을 염두에 두고 있는 것이고, 실제로
float 형을 통해 제공되고 있는 이진 부동 소수점은 대부분의 플랫폼에서 하드웨어에 기반합니다. 하드웨어에서
지원되는 경우 이진 부동 소수점 신호가 <code class="docutils literal notranslate"><span class="pre">SIGFPE</span></code> 시그널을 통하는 경우가 있습니다. 예전에는 <code class="docutils literal notranslate"><span class="pre">fpectl</span></code>
이라는 모듈을 통해 제한적으로나마 제어할 수 있는 방법을 제공했지만, 사실상 아무도 쓰지 않기 때문에
파이썬 3.7 에서는 아예 제거되었습니다.</p>
</div>
</li>
<li><p class="first">decimal 모듈은 &quot;편견 없이, (때로 고정 소수점 산술이라고도 불리는) 정확한 자리 올림 없는 십진 산술과 자리 올림 있는 부동 소수점 산술을 모두&quot; 지원하도록 설계되었습니다. -- 십진 산술 명세에서 발췌.</p>
</li>
</ul>
<p>모듈 설계의 중심 개념은 세 가지입니다: 십진수, 산술을 위한 컨텍스트, 신호(signal).</p>
<p>decimal 수는 불변입니다. 부호(sign), 계수(coefficient digits) 및 지수(exponent)로 구성됩니다. 유효성을 유지하기 위해, 계수는 후행 0을 자르지 않습니다. Decimal은 또한 <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">-Infinity</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 과 같은 특별한 값을 포함합니다. 표준은 또한 <code class="xref py py-const docutils literal notranslate"><span class="pre">-0</span></code>을 <code class="xref py py-const docutils literal notranslate"><span class="pre">+0</span></code>과 구별합니다.</p>
<p>산술 컨텍스트는 정밀도, 자리 올림 규칙, 지수에 대한 제한, 연산 결과를 나타내는 플래그 및 신호가 예외로 처리될지를 결정하는 트랩 활성화기(trap enabler)를 지정하는 환경입니다. 자리 올림 옵션에는 <a class="reference internal" href="#decimal.ROUND_CEILING" title="decimal.ROUND_CEILING"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_CEILING</span></code></a>, <a class="reference internal" href="#decimal.ROUND_DOWN" title="decimal.ROUND_DOWN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_DOWN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_FLOOR" title="decimal.ROUND_FLOOR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_FLOOR</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_DOWN" title="decimal.ROUND_HALF_DOWN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_DOWN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_UP</span></code></a>, <a class="reference internal" href="#decimal.ROUND_UP" title="decimal.ROUND_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_UP</span></code></a> 및 <a class="reference internal" href="#decimal.ROUND_05UP" title="decimal.ROUND_05UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_05UP</span></code></a> 가 있습니다.</p>
<p>신호는 계산 과정에서 발생하는 예외적인 조건의 그룹입니다. 응용 프로그램의 필요에 따라, 신호가 무시되거나, 정보로 간주하거나, 예외로 처리될 수 있습니다. decimal 모듈의 신호는 <a class="reference internal" href="#decimal.Clamped" title="decimal.Clamped"><code class="xref py py-const docutils literal notranslate"><span class="pre">Clamped</span></code></a>, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a>, <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a>, <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a>, <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a>, <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal notranslate"><span class="pre">Subnormal</span></code></a>, <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-const docutils literal notranslate"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="#decimal.Underflow" title="decimal.Underflow"><code class="xref py py-const docutils literal notranslate"><span class="pre">Underflow</span></code></a>, <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 입니다.</p>
<p>각 신호에는 플래그와 트랩 활성화기가 있습니다. 신호와 만났을 때, 플래그가 1로 설정되고 트랩 활성화기가 1로 설정된 경우, 예외가 발생합니다. 플래그는 상태가 유지되므로(sticky) 계산을 감시하기 전에 재설정할 필요가 있습니다.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<ul class="last simple">
<li>IBM의 일반 십진 산술 명세, <a class="reference external" href="http://speleotrove.com/decimal/decarith.html">The General Decimal Arithmetic Specification</a>.</li>
</ul>
</div>
<div class="section" id="quick-start-tutorial">
<span id="decimal-tutorial"></span><h2>빠른 시작 자습서<a class="headerlink" href="#quick-start-tutorial" title="제목 주소">¶</a></h2>
<p>decimal을 사용하는 일반적인 시작은 모듈을 임포트하고, <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 로 현재 컨텍스트를 보고, 필요하다면 정밀도, 자리 올림 또는 활성화된 트랩에 대해 새 값을 설정하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,</span>
<span class="go">        InvalidOperation])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">7</span>       <span class="c1"># 새 정밀도를 설정합니다</span>
</pre></div>
</div>
<p>Decimal 인스턴스는 정수, 문자열, 실수(float) 또는 튜플로 만들 수 있습니다. 정수 나 실수로 만들면 해당 정수 또는 실수의 정확한 값 변환이 일어납니다. Decimal 수는 &quot;숫자가 아님(Not a number)&quot;을 나타내는 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>, 양과 음의 <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code> 및 <code class="xref py py-const docutils literal notranslate"><span class="pre">-0</span></code>과 같은 특수한 값을 포함합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">Decimal(&#39;10&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.14&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.14&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.140000000000000124344978758017532527446746826171875&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Decimal(&#39;3.14&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="go">Decimal(&#39;1.4142135623730951&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.5&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.414213562373095048801688724&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;NaN&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-Infinity&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;-Infinity&#39;)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 신호를 트랩 하는 경우, 실수로 생성자나 대소비교에서 Decimal 수와 실수(float)를 혼합하면 예외가 발생합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">getcontext</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">FloatOperation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class &#39;decimal.FloatOperation&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.5&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">3.7</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class &#39;decimal.FloatOperation&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.5&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mf">3.5</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">예제 코드의 마지막에서 볼 수 있듯이, 동등 비교는 예외를 일으키지 않습니다.
또한 3.5 는 이진 부동 소수점으로 정확히 표현할 수 있는 수이기 때문에 비교 결과가 <code class="docutils literal notranslate"><span class="pre">True</span></code> 입니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">float 가 조용히 Decimal 로 변환되도록하면, float 값으로 이미 정확하지 않은 값이 들어갔을 가능성이
크기 때문에, Decimal 이 제공하는 정확한 산술이 의미가 없어질 수 있습니다. 이 때문에 정확한 산술이
중요한 응용에서는 <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 신호를 트랩해서 실수로라도 그런일이 일어나는 것을
막습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
<p>새로운 Decimal의 유효 숫자는 입력된 숫자의 개수에 의해서만 결정됩니다. 컨텍스트 정밀도 및 자리 올림은 오직 산술 연산 중에만 작용합니다.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.0&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.1415926535&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.7182818285&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.85987&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_UP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.7182818285&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.85988&#39;)</span>
</pre></div>
</div>
<p>C 버전의 내부 제한을 초과하면, Decimal 을 만들 때 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> 를 일으킵니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1e9999999999999999999&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.InvalidOperation</span>: <span class="n">[&lt;class &#39;decimal.InvalidOperation&#39;&gt;]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경.</span></p>
</div>
<p>Decimal은 파이썬의 다른 부분들과 잘 어울립니다. 다음은 십진 부동 소수점으로 부린 작은 묘기입니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">&#39;1.34 1.87 3.45 2.35 1.00 0.03 9.25&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;9.25&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">[Decimal(&#39;0.03&#39;), Decimal(&#39;1.00&#39;), Decimal(&#39;1.34&#39;), Decimal(&#39;1.87&#39;),</span>
<span class="go"> Decimal(&#39;2.35&#39;), Decimal(&#39;3.45&#39;), Decimal(&#39;9.25&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;19.29&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;1.34&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.3&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">5</span>
<span class="go">Decimal(&#39;6.70&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="go">Decimal(&#39;2.5058&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">%</span> <span class="n">a</span>
<span class="go">Decimal(&#39;0.77&#39;)</span>
</pre></div>
</div>
<p>그리고 Decimal에는 몇 가지 수학 함수도 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
<span class="go">Decimal(&#39;1.414213562373095048801688724&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.718281828459045235360287471&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ln</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.302585092994045684017991455&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">log10</span><span class="p">()</span>
<span class="go">Decimal(&#39;1&#39;)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><a class="reference internal" href="math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 모듈의 수학 함수들에 Decimal 을 제공해도 됩니다. 다만 <a class="reference internal" href="math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 모듈의 함수들은
float 로 변환한 값으로 계산한 후 float 값을 돌려줍니다.</p>
</div>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code> 메서드는 숫자를 고정된 지수로 자리 올림 합니다. 이 방법은 종종 결과를 고정된 자릿수로 자리 올림 하는 화폐 응용에 유용합니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.325&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;.01&#39;</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="go">Decimal(&#39;7.32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.325&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.&#39;</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_UP</span><span class="p">)</span>
<span class="go">Decimal(&#39;8&#39;)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">여기서 &quot;고정된 지수로 자리 올림&quot; 한다는 뜻은, 계수부를 정수로 만들때의 지수부가 지정한 값이 되도록
만든다는 뜻입니다. 때문에 소수점 밑의 자리수를 맞추는 결과를 줍니다.
첫번째 예에서, <code class="docutils literal notranslate"><span class="pre">Decimal('.01')</span></code> 은 <code class="docutils literal notranslate"><span class="pre">Decimal(1e-2)</span></code> 와 같아서 지수가 <code class="docutils literal notranslate"><span class="pre">-2</span></code> 입니다. 따라서
<code class="docutils literal notranslate"><span class="pre">Decimal('732e-2')</span></code> 가 되도록 자리 올림합니다. (실제로는 <code class="docutils literal notranslate"><span class="pre">ROUND_DOWN</span></code> 이라서 내림합니다.)
두번째 예에서, <code class="docutils literal notranslate"><span class="pre">Decimal('1.')</span></code> 는 <code class="docutils literal notranslate"><span class="pre">Decimal('1e0')</span></code> 이고, 지수가 <code class="docutils literal notranslate"><span class="pre">0</span></code> 이므로
<code class="docutils literal notranslate"><span class="pre">Decimal('8e0')</span></code> 으로 올림(ROUND_UP)합니다.</p>
</div>
<p>위에서 보듯이, <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 함수는 현재 컨텍스트에 액세스하고 설정을 변경할 수 있게 합니다. 이 방법은 대부분 응용 프로그램의 요구를 충족시킵니다.</p>
<p>고급 작업을 위해, Context() 생성자를 사용하여 대체 컨텍스트를 만드는 것이 유용할 수 있습니다. 대체 컨텍스트를 활성화하려면, <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> 함수를 사용하십시오.</p>
<p>표준에 따라, <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 모듈은 당장 사용할 수 있는 두 개의 표준 컨텍스트 <a class="reference internal" href="#decimal.BasicContext" title="decimal.BasicContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">BasicContext</span></code></a> 와 <a class="reference internal" href="#decimal.ExtendedContext" title="decimal.ExtendedContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">ExtendedContext</span></code></a> 를 제공합니다. 특히 전자는 많은 트랩이 활성화되어있어 디버깅에 유용합니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myothercontext</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_HALF_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">myothercontext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857142857142857142857142857142857142857142857142857142857&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ExtendedContext</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857143&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">BasicContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#143&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
    <span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div>
</div>
<p>컨텍스트에는 계산 중에 발생하는 예외 조건을 감시하기 위한 신호 플래그도 있습니다. 플래그는 명시적으로 지워질 때까지 설정된 상태로 유지되므로, <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear_flags()</span></code> 메서드를 사용하여 모니터링되는 각 계산 집합 앞에서 플래그를 지우는 것이 가장 좋습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">clear_flags</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">355</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">113</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.14159292&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])</span>
</pre></div>
</div>
<p><em>flags</em> 엔트리는 <code class="xref py py-const docutils literal notranslate"><span class="pre">Pi</span></code> 에 대한 유리수 근삿값이 자리 올림 되었고 (컨텍스트 정밀도 이상의 숫자가 버려졌습니다) 결과가 부정확하다는 (폐기된 숫자 일부는 0이 아닙니다) 것을 보여줍니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">355/113 은 <code class="xref py py-const docutils literal notranslate"><span class="pre">Pi</span></code> 와 소수점 6자리까지 일치하는 간단한 유리수 근사값입니다.</p>
</div>
<p>개별 트랩은 컨텍스트의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">traps</span></code> 필드에 있는 딕셔너리를 사용해서 설정합니다.:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">DivisionByZero</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#112&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
    <span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div>
</div>
<p>대부분 프로그램은 프로그램 시작 시에 한 번만 현재 컨텍스트를 조정합니다. 그리고, 많은 응용 프로그램에서, 데이터는 루프 내에서 단일형변환으로 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>로 변환되어, 프로그램 대부분은 다른 파이썬 숫자 형과 별로 다르지 않게 데이터를 조작합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">대체로 파이썬의 다른 숫자 형과 비슷하게 동작하지만, 정수 나눗셈에 음수가 포함될 때는 차이가 있기 때문에
조심해야합니다. 이 차이에 대해서는 밑에서 설명합니다.</p>
</div>
</div>
<div class="section" id="decimal-objects">
<span id="decimal-decimal"></span><h2>Decimal 객체<a class="headerlink" href="#decimal-objects" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="decimal.Decimal">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Decimal</code><span class="sig-paren">(</span><em>value=&quot;0&quot;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal" title="정의 주소">¶</a></dt>
<dd><p><em>value</em> 를 기반으로 새 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 객체를 만듭니다.</p>
<p><em>value</em> 는 정수, 문자열, 튜플, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 또는 다른 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 객체일 수 있습니다. <em>value</em> 가 주어지지 않으면, <code class="docutils literal notranslate"><span class="pre">Decimal('0')</span></code> 을 반환합니다. <em>value</em> 가 문자열이면, 앞뒤의 공백 문자 및 밑줄이 제거된 후 십진수 문자열 문법에 맞아야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sign</span>           <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;+&#39;</span> <span class="o">|</span> <span class="s1">&#39;-&#39;</span>
<span class="n">digit</span>          <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;0&#39;</span> <span class="o">|</span> <span class="s1">&#39;1&#39;</span> <span class="o">|</span> <span class="s1">&#39;2&#39;</span> <span class="o">|</span> <span class="s1">&#39;3&#39;</span> <span class="o">|</span> <span class="s1">&#39;4&#39;</span> <span class="o">|</span> <span class="s1">&#39;5&#39;</span> <span class="o">|</span> <span class="s1">&#39;6&#39;</span> <span class="o">|</span> <span class="s1">&#39;7&#39;</span> <span class="o">|</span> <span class="s1">&#39;8&#39;</span> <span class="o">|</span> <span class="s1">&#39;9&#39;</span>
<span class="n">indicator</span>      <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;e&#39;</span> <span class="o">|</span> <span class="s1">&#39;E&#39;</span>
<span class="n">digits</span>         <span class="p">::</span><span class="o">=</span>  <span class="n">digit</span> <span class="p">[</span><span class="n">digit</span><span class="p">]</span><span class="o">...</span>
<span class="n">decimal</span><span class="o">-</span><span class="n">part</span>   <span class="p">::</span><span class="o">=</span>  <span class="n">digits</span> <span class="s1">&#39;.&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">exponent</span><span class="o">-</span><span class="n">part</span>  <span class="p">::</span><span class="o">=</span>  <span class="n">indicator</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">infinity</span>       <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;Infinity&#39;</span> <span class="o">|</span> <span class="s1">&#39;Inf&#39;</span>
<span class="n">nan</span>            <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;NaN&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="s1">&#39;sNaN&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">value</span>  <span class="p">::</span><span class="o">=</span>  <span class="n">decimal</span><span class="o">-</span><span class="n">part</span> <span class="p">[</span><span class="n">exponent</span><span class="o">-</span><span class="n">part</span><span class="p">]</span> <span class="o">|</span> <span class="n">infinity</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">string</span> <span class="p">::</span><span class="o">=</span>  <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">numeric</span><span class="o">-</span><span class="n">value</span> <span class="o">|</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">nan</span>
</pre></div>
</div>
<p>위의 <code class="docutils literal notranslate"><span class="pre">digit</span></code> 가 나타나는 곳에는 다른 유니코드 십진수도 허용됩니다. 여기에는 다양한 다른 알파벳(예를 들어, 인도-아라비아와 데바나가리 숫자)의 십진수와 전각 숫자 <code class="docutils literal notranslate"><span class="pre">'\uff10'</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">'\uff19'</span></code> 까지 포함됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">인도-아라비아 숫자는 우리가 흔히 아라비아 숫자라고 부르는 것이고, 데바나가리(Devanāgarī) 숫자는
고대 인도의 문자입니다.</p>
</div>
<p><em>value</em> 가 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 이면, 세 개의 항목으로 구성되어야 합니다, 부호 (<code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> 은 양수, <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> 은 음수), 숫자의 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, 정수 지수. 예를 들어, <code class="docutils literal notranslate"><span class="pre">Decimal((0,</span> <span class="pre">(1,</span> <span class="pre">4,</span> <span class="pre">1,</span> <span class="pre">4),</span> <span class="pre">-3))</span></code> 은 <code class="docutils literal notranslate"><span class="pre">Decimal('1.414')</span></code> 를 반환합니다.</p>
<p><em>value</em> 가 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 면, 이진 부동 소수점 값은 손실 없이 정확한 십진수로 변환됩니다. 이 변환에는 종종 53자리 이상의 정밀도가 필요할 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">Decimal(float('1.1'))</span></code> 은 <code class="docutils literal notranslate"><span class="pre">Decimal('1.100000000000000088817841970012523233890533447265625')</span></code> 로 변환됩니다.</p>
<p><em>context</em> 정밀도는 저장되는 자릿수에 영향을 주지 않습니다. 저장되는 자릿수는 <em>value</em> 의 자릿수만으로 결정됩니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">Decimal('3.00000')</span></code> 은 컨텍스트 정밀도가 단지 3이라도 5개의 모든 0을 기록합니다.</p>
<p><em>context</em> 인자의 목적은 <em>value</em> 가 잘못된 문자열인 경우 어떻게 해야할지를 결정하는 것입니다. 컨텍스트가 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> 을 트랩하면, 예외가 발생합니다; 그렇지 않으면, 생성자는 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 의 값을 갖는 새 Decimal을 반환합니다.</p>
<p>일단 만들어지면, <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 객체는 불변입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>생성자에 대한 인자는 이제 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 인스턴스가 될 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 인자는 <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 트랩이 설정되면 예외를 발생시킵니다. 기본적으로 트랩은 꺼져 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>코드에서의 정수와 부동 소수점 리터럴과 마찬가지로, 밑줄로 무리 지을 수 있습니다.</p>
</div>
<p>십진 부동 소수점 객체는 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>나 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>와 같은 다른 내장 숫자 형과 많은 성질을 공유합니다. 일반적인 수학 연산과 특수 메서드가 모두 적용됩니다. 마찬가지로, 십진 객체는 복사, 피클, 인쇄, 딕셔너리 키로 사용, 집합 원소로 사용, 비교, 정렬 및 다른 형(가령 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 또는 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>)으로 코어션될 수 있습니다.</p>
<p>Decimal 객체에 대한 산술과 정수 및 실수에 대한 산술에는 약간의 차이가 있습니다. Decimal 객체에 나머지 연산자 <code class="docutils literal notranslate"><span class="pre">%</span></code> 가 적용될 때, 결과의 부호는 제수의 부호가 아닌 <em>피제수</em>의 부호가 됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal(&#39;-3&#39;)</span>
</pre></div>
</div>
<p>정수 나눗셈 연산자 <code class="docutils literal notranslate"><span class="pre">//</span></code> 의 동작 역시 비슷한 차이를 보입니다. 즉, 가장 가까운 정수로 내림하는 대신 실제 몫의 정수 부(0을 향해 자르기)를 돌려줍니다. 그래서 일반적인 항등식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y)</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> 를 유지합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="mi">7</span> <span class="o">//</span> <span class="mi">4</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal(&#39;-1&#39;)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">%</span></code> 와 <code class="docutils literal notranslate"><span class="pre">//</span></code> 연산자는 명세에 설명된 대로 각각 <code class="docutils literal notranslate"><span class="pre">remainder</span></code> 와 <code class="docutils literal notranslate"><span class="pre">divide-integer</span></code> 연산을 구현합니다.</p>
<p>Decimal 객체는 일반적으로 산술 연산에서 float 나 <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> 인스턴스와 결합 할 수 없습니다: 예를 들어, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 에 a <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>을 더하려고 하면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킵니다. 그러나, 파이썬의 비교 연산자를 사용하여 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스 <code class="docutils literal notranslate"><span class="pre">x</span></code> 와 다른 숫자 <code class="docutils literal notranslate"><span class="pre">y</span></code> 를 비교할 수 있습니다. 이렇게 해서 서로 다른 형의 숫자 간에 동등 비교를 할 때 혼란스러운 결과를 피합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스와 다른 숫자 형 사이의 혼합형 비교가 이제 완전히 지원됩니다.</p>
</div>
<p>표준 숫자 속성에 더해, 십진 부동 소수점 객체에는 여러 가지 특별한 메서드가 있습니다:</p>
<dl class="method">
<dt id="decimal.Decimal.adjusted">
<code class="descname">adjusted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.adjusted" title="정의 주소">¶</a></dt>
<dd><p>최상위 숫자만 남을 때까지 계수의 가장 오른쪽 숫자들을 밀어내도록 조정된 지수를 반환합니다. <code class="docutils literal notranslate"><span class="pre">Decimal('321e+5').adjusted()</span></code> 는 7을 반환합니다. 소수점으로부터의 최상위 유효 숫자의 위치를 결정하는 데 사용됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">'321e+5' 를 '3.21e+7' 로 변환한 후에 <cite>7</cite> 을 취한다는 뜻입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.as_integer_ratio">
<code class="descname">as_integer_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.as_integer_ratio" title="정의 주소">¶</a></dt>
<dd><p>주어진 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스를, 분모가 양수인 기약 분수로 나타내는 정수의 쌍 <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code> 을 돌려줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-3.14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(-157, 50)</span>
</pre></div>
</div>
<p>변환은 정확합니다. 무한대는 OverflowError를, NaN 은 ValueError를 일으킵니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p>이 변환이 정확하기는 하지만, 기약 분수를 만들기 때문에 유효 숫자를 모두 보존하지는 않습니다.</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-3.140&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(-157, 50)</span>
</pre></div>
</div>
</div>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
<dl class="method">
<dt id="decimal.Decimal.as_tuple">
<code class="descname">as_tuple</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.as_tuple" title="정의 주소">¶</a></dt>
<dd><p>숫자의 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> 표현을 반환합니다: <code class="docutils literal notranslate"><span class="pre">DecimalTuple(sign,</span> <span class="pre">digits,</span> <span class="pre">exponent)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.canonical">
<code class="descname">canonical</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.canonical" title="정의 주소">¶</a></dt>
<dd><p>인자의 규범적인 인코딩을 돌려줍니다. 현재 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스의 인코딩은 항상 규범적이므로, 이 연산은 인자를 변경하지 않고 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.compare">
<code class="descname">compare</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare" title="정의 주소">¶</a></dt>
<dd><p>두 Decimal 인스턴스의 값을 비교합니다. <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a> 는 Decimal 인스턴스를 반환하고, 피연산자 중 하나가 NaN이면 결과는 NaN입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="n">나</span> <span class="n">b</span> <span class="n">가</span> <span class="n">NaN</span>     <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-1&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">==</span> <span class="n">b</span>           <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">a.compare(b)</span></code> 의 결과가 어떻게 되는지에 대한 예시입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.compare_signal">
<code class="descname">compare_signal</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_signal" title="정의 주소">¶</a></dt>
<dd><p>이 연산은, 모든 NaN 이 신호를 준다는 것을 제외하면 <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a> 메서드와 같습니다. 즉, 피연산자가 모두 신호를 주는 NaN이 아니면, 모든 조용한 NaN 피연산자가 마치 신호를 주는 NaN 인 것처럼 처리됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.compare_total">
<code class="descname">compare_total</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_total" title="정의 주소">¶</a></dt>
<dd><p>두 개의 피연산자를 숫자 값 대신 추상 표현을 사용하여 비교합니다. <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a> 메서드와 비슷하지만, 결과는 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스에 대해 전 순서(total ordering)를 부여합니다. 같은 숫자 값을 갖지만 다른 표현의 두 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스는 이 순서에 의해 다른 것으로 비교됩니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;12.0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">compare_total</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;12&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-1&#39;)</span>
</pre></div>
</div>
<p>조용한 NaN과 신호를 주는 NaN도 전 순서에 포함됩니다. 이 함수의 결과는, 두 피연산자가 같은 표현을 가질 때 <code class="docutils literal notranslate"><span class="pre">Decimal('0')</span></code>, 첫 번째 피연산자가 전 순서에서 두 번째 피연산자보다 낮으면 <code class="docutils literal notranslate"><span class="pre">Decimal('-1')</span></code>, 첫 번째 피연산자가 전 순서에서 두 번째 피연산자보다 높으면 <code class="docutils literal notranslate"><span class="pre">Decimal('1')</span></code> 입니다. 전 순서에 대한 세부 사항은 명세를 참조하십시오.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p>전 순서에는 유효 숫자와 특수한 값에 대한 정의가 포함되지만, 일반적인 숫자 값의 대소 관계는
그대로 보존됩니다. 대략 이런 순서를 갖도록 정의됩니다.</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">-NaN</span> <span class="pre">-sNaN</span> <span class="pre">-Infinity</span> <span class="pre">-127</span> <span class="pre">-1.00</span> <span class="pre">-1</span> <span class="pre">-0.000</span> <span class="pre">-0</span> <span class="pre">0</span> <span class="pre">1.2300</span> <span class="pre">1.23</span> <span class="pre">1E+9</span> <span class="pre">Infinity</span> <span class="pre">sNaN</span> <span class="pre">NaN</span></code></p>
</div>
<p>이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다. 예외적으로, 두 번째 피연산자를 정확하게 변환할 수 없으면 C 버전은 InvalidOperation을 발생시킬 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.compare_total_mag">
<code class="descname">compare_total_mag</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_total_mag" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.compare_total" title="decimal.Decimal.compare_total"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare_total()</span></code></a>처럼 두 개의 피연산자를 숫자 값 대신 추상 표현을 사용하여 비교하지만, 각 피연산자의 부호를 무시합니다. <code class="docutils literal notranslate"><span class="pre">x.compare_total_mag(y)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.copy_abs().compare_total(y.copy_abs())</span></code> 와 동등합니다.</p>
<p>이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다. 예외적으로, 두 번째 피연산자를 정확하게 변환할 수 없으면 C 버전은 InvalidOperation을 발생시킬 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.conjugate">
<code class="descname">conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.conjugate" title="정의 주소">¶</a></dt>
<dd><p>그냥 self를 돌려줍니다. 이 메서드는 Decimal 명세를 준수하기 위한 것뿐입니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.copy_abs">
<code class="descname">copy_abs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_abs" title="정의 주소">¶</a></dt>
<dd><p>인자의 절댓값을 반환합니다. 이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.copy_negate">
<code class="descname">copy_negate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_negate" title="정의 주소">¶</a></dt>
<dd><p>인자의 음의 부정을 돌려줍니다. 이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.copy_sign">
<code class="descname">copy_sign</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_sign" title="정의 주소">¶</a></dt>
<dd><p>두 번째 피연산자의 부호와 같은 부호로 설정된 첫 번째 피연산자의 복사본을 반환합니다. 예를 들어:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy_sign</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-1.5&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-2.3&#39;)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 섹션에서는 인자나 피연산자를 언급할 때는, 서명에 나타나지는 않더라도 항상 self 를 포함해서
말하고 있습니다.</p>
</div>
<p>이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다. 예외적으로, 두 번째 피연산자를 정확하게 변환할 수 없으면 C 버전은 InvalidOperation을 발생시킬 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.exp">
<code class="descname">exp</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.exp" title="정의 주소">¶</a></dt>
<dd><p>주어진 숫자에 대한 (자연) 지수 함수 <code class="docutils literal notranslate"><span class="pre">e**x</span></code> 의 값을 반환합니다. 결과는 <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a> 자리 올림 모드를 사용하여 올바르게 자리 올림 됩니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.718281828459045235360287471&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">321</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.561702493119680037517373933E+139&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.from_float">
<code class="descname">from_float</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.from_float" title="정의 주소">¶</a></dt>
<dd><p>float를 십진수로 정확하게 변환하는 클래스 메서드.</p>
<p><cite>Decimal.from_float(0.1)</cite> 은 <cite>Decimal('0.1')</cite>과 같지 않음에 유의하십시오. 0.1은 이진 부동 소수점에서 정확하게 표현할 수 없으므로, 값은 가장 가까운 표현 가능 값인 <cite>0x1.999999999999ap-4</cite>로 저장됩니다. 십진수로 표시된 해당 값은 <cite>0.1000000000000000055511151231257827021181583404541015625</cite> 입니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">파이썬 3.2 이후부터는, <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스를 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>에서 직접 생성할 수 있습니다.</p>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1000000000000000055511151231257827021181583404541015625&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;NaN&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-Infinity&#39;)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.fma">
<code class="descname">fma</code><span class="sig-paren">(</span><em>other</em>, <em>third</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.fma" title="정의 주소">¶</a></dt>
<dd><p>합성된 곱셈-덧셈(fused multiply-add). 중간값 self*other의 자리 올림 없이 self*other+third를 반환합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">Decimal(&#39;11&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_canonical">
<code class="descname">is_canonical</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_canonical" title="정의 주소">¶</a></dt>
<dd><p>인자가 규범적이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다. 현재 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스는 항상 규범적이므로 이 연산은 항상 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_finite">
<code class="descname">is_finite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_finite" title="정의 주소">¶</a></dt>
<dd><p>인자가 유한 수이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 인자가 무한대나 NaN 이면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_infinite">
<code class="descname">is_infinite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_infinite" title="정의 주소">¶</a></dt>
<dd><p>인자가 양이나 음의 무한대면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_nan">
<code class="descname">is_nan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_nan" title="정의 주소">¶</a></dt>
<dd><p>인자가 (조용한 또는 신호를 주는) NaN이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_normal">
<code class="descname">is_normal</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_normal" title="정의 주소">¶</a></dt>
<dd><p>인자가 <em>정상(normal)</em> 유한 수이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다. 인자가 0, 비정상(subnormal), 무한대 또는 NaN 이면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">0 이 아닌 유한 수 중에서 규범적인 형태의 지수가 Emin 이상인 것들을 정상수(normal number)라고
부르고, Emin 보다 작은 것들을 비정상수(subnormal number)라고 부릅니다. 비정상수는 유효숫자를
일부 희생하면서 여전히 계산 가능합니다. 이런 방식으로 다룰 수 있는 최소 지수는
<a class="reference internal" href="#decimal.Context.Etiny" title="decimal.Context.Etiny"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.Etiny()</span></code></a> 입니다. Emin 근처에서 갑작스럽게 계산을 포기하기 보다, 정확도를
조금씩 잃어가는 것을 허용하고자 하는 것입니다. 이런 방식을 점진적인 언더플로우라고 합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_qnan">
<code class="descname">is_qnan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_qnan" title="정의 주소">¶</a></dt>
<dd><p>인자가 조용한 NaN이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_signed">
<code class="descname">is_signed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_signed" title="정의 주소">¶</a></dt>
<dd><p>인자가 음의 부호를 가지면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다. 0과 NaN 모두 부호를 가질 수 있다는 것에 유의하세요.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_snan">
<code class="descname">is_snan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_snan" title="정의 주소">¶</a></dt>
<dd><p>인자가 신호를 주는 NaN이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_subnormal">
<code class="descname">is_subnormal</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_subnormal" title="정의 주소">¶</a></dt>
<dd><p>인자가 비정상(subnormal)이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_zero">
<code class="descname">is_zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_zero" title="정의 주소">¶</a></dt>
<dd><p>인자가 (양 또는 음의) 0이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.ln">
<code class="descname">ln</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.ln" title="정의 주소">¶</a></dt>
<dd><p>피연산자의 자연로그(밑 e)를 반환합니다. 결과는 <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a> 자리 올림 모드를 사용하여 올바르게 반올림됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.log10">
<code class="descname">log10</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.log10" title="정의 주소">¶</a></dt>
<dd><p>피연산자의 상용로그를 반환합니다. 결과는 <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a> 자리 올림 모드를 사용하여 올바르게 반올림됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logb">
<code class="descname">logb</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logb" title="정의 주소">¶</a></dt>
<dd><p>0이 아닌 수의 경우, 피연산자의 조정된 지수를 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스로 반환합니다. 피연산자가 0이면 <code class="docutils literal notranslate"><span class="pre">Decimal('-Infinity')</span></code> 가 반환되고 <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 플래그가 발생합니다. 피연산자가 무한대면 <code class="docutils literal notranslate"><span class="pre">Decimal('Infinity')</span></code> 가 반환됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">피연산자의 부호를 무시하고 지수부를 취하는 연산입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logical_and">
<code class="descname">logical_and</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_and" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_and" title="decimal.Decimal.logical_and"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_and()</span></code></a> 는 두 개의 <em>논리적 피연산자</em>(<a class="reference internal" href="#logical-operands-label"><span class="std std-ref">논리적 피연산자</span></a>를 보세요)를 취하는 논리적 연산입니다. 결과는 두 피연산자의 자릿수별 <code class="docutils literal notranslate"><span class="pre">and</span></code> 입니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logical_invert">
<code class="descname">logical_invert</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_invert" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_invert" title="decimal.Decimal.logical_invert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_invert()</span></code></a> 는 논리적 연산입니다. 결과는 피연산자의 자릿수별 반전입니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logical_or">
<code class="descname">logical_or</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_or" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_or" title="decimal.Decimal.logical_or"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_or()</span></code></a> 는 두 개의 <em>논리적 피연산자</em>(<a class="reference internal" href="#logical-operands-label"><span class="std std-ref">논리적 피연산자</span></a>를 보세요)를 취하는 논리적 연산입니다. 결과는 두 피연산자의 자릿수별 <code class="docutils literal notranslate"><span class="pre">or</span></code> 입니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logical_xor">
<code class="descname">logical_xor</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_xor" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_xor" title="decimal.Decimal.logical_xor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_xor()</span></code></a>은 두 개의 <em>논리적 피연산자</em>(<a class="reference internal" href="#logical-operands-label"><span class="std std-ref">논리적 피연산자</span></a>를 보세요)를 취하는 논리적 연산입니다. 결과는 두 피연산자의 자릿수별 배타적 or입니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.max" title="정의 주소">¶</a></dt>
<dd><p>컨텍스트 자리 올림 규칙이 반환되기 전에 적용되고 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 값이 (컨텍스트와 신호를 주는지 조용한지에 따라) 신호를 주거나 무시되는 것을 제외하고 <code class="docutils literal notranslate"><span class="pre">max(self,</span> <span class="pre">other)</span></code> 와 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.max_mag">
<code class="descname">max_mag</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.max_mag" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.max" title="decimal.Decimal.max"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max()</span></code></a>와 비슷하지만, 피연산자의 절댓값을 사용하여 비교가 이루어집니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.min" title="정의 주소">¶</a></dt>
<dd><p>컨텍스트 자리 올림 규칙이 반환되기 전에 적용되고 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 값이 (컨텍스트와 신호를 주는지 조용한지에 따라) 신호를 주거나 무시되는 것을 제외하고 <code class="docutils literal notranslate"><span class="pre">min(self,</span> <span class="pre">other)</span></code> 와 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.min_mag">
<code class="descname">min_mag</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.min_mag" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.min" title="decimal.Decimal.min"><code class="xref py py-meth docutils literal notranslate"><span class="pre">min()</span></code></a>과 비슷하지만, 피연산자의 절댓값을 사용하여 비교가 이루어집니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.next_minus">
<code class="descname">next_minus</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_minus" title="정의 주소">¶</a></dt>
<dd><p>주어진 피연산자보다 작고, 주어진 컨텍스트(또는 context가 주어지지 않으면 현재 스레드의 컨텍스트)에서 표현 가능한 가장 큰 수를 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.next_plus">
<code class="descname">next_plus</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_plus" title="정의 주소">¶</a></dt>
<dd><p>주어진 피연산자보다 크고, 주어진 컨텍스트(또는 context가 주어지지 않으면 현재 스레드의 컨텍스트)에서 표현 가능한 가장 작은 수를 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.next_toward">
<code class="descname">next_toward</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_toward" title="정의 주소">¶</a></dt>
<dd><p>두 피연산자가 같지 않으면, 두 번째 피연산자의 방향으로 첫 번째 피연산자에 가장 가까운 숫자를 반환합니다. 두 피연산자가 수치로 같으면, 첫 번째 피연산자의 복사본을 반환하는데, 부호를 두 번째 피연산자의 것으로 설정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.normalize" title="정의 주소">¶</a></dt>
<dd><p>가장 오른쪽 끝에 오는 0을 제거하고 결과를 <code class="xref py py-const docutils literal notranslate"><span class="pre">Decimal('0')</span></code>과 같은 모든 결과를 <code class="xref py py-const docutils literal notranslate"><span class="pre">Decimal('0e0')</span></code>으로 변환하여 숫자를 정규화합니다. 등가 클래스의 어트리뷰트에 대한 규범적인 값을 만드는 데 사용됩니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">Decimal('32.100')</span></code> 과 <code class="docutils literal notranslate"><span class="pre">Decimal('0.321000e+2')</span></code> 는 모두 같은 값인 <code class="docutils literal notranslate"><span class="pre">Decimal('32.1')</span></code> 로 정규화됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 연산은 정규화라기 보다는, 숫자를 동등 비교가 유지되는 범위내에서 가장 단순한 형태로 환원시키는
것입니다. 실제로 Decimal 명세에서는 이 연산의 이름이 <code class="docutils literal notranslate"><span class="pre">reduce</span></code> 로 변경되었습니다. 하지만
이 변경의 더 큰 이유는, 이 연산이 정상수(normal number)와 아무 관련이 없다는 것입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.number_class">
<code class="descname">number_class</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.number_class" title="정의 주소">¶</a></dt>
<dd><p>피연산자의 <em>클래스</em> 를 설명하는 문자열을 반환합니다. 반환 값은 다음 10개의 문자열 중 하나입니다.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&quot;-Infinity&quot;</span></code>, 피연산자가 음의 무한대임을 나타냅니다.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;-Normal&quot;</span></code>, 피연산자가 음의 정상 수임을 나타냅니다.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;-Subnormal&quot;</span></code>, 피연산자가 음의 비정상 수임을 나타냅니다.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;-Zero&quot;</span></code>, 피연산자가 음의 0임을 나타냅니다.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;+Zero&quot;</span></code>, 피연산자가 양의 0임을 나타냅니다.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;+Subnormal&quot;</span></code>, 피연산자가 양의 비정상 수임을 나타냅니다.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;+Normal&quot;</span></code>, 피연산자가 양의 정상 수임을 나타냅니다.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;+Infinity&quot;</span></code>, 피연산자가 양의 무한대임을 나타냅니다.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;NaN&quot;</span></code>, 피연산자가 조용한 NaN(Not a Number)임을 나타냅니다.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;sNaN&quot;</span></code>, 피연산자가 신호를 주는 NaN임을 나타냅니다.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.quantize">
<code class="descname">quantize</code><span class="sig-paren">(</span><em>exp</em>, <em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.quantize" title="정의 주소">¶</a></dt>
<dd><p>자리 올림 후에 첫 번째 피연산자와 같고 두 번째 피연산자의 지수를 갖는 값을 반환합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.41421356&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.000&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;1.414&#39;)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 연산은 계수부를 정수로 만들때의 지수부가 <em>exp</em> 의 지수부와 같도록 만듭니다. 이 결과
소수점 밑의 자릿수를 <em>exp</em> 와 일치하도록 자리 올림하게됩니다. 때문에 <em>exp</em> 를 자릿수를
표현하는 탬플릿 처럼 사용하면 됩니다.</p>
</div>
<p>다른 연산과 달리, quantize 연산 후의 계수의 길이가 정밀도보다 크면, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> 신호를 줍니다. 이는, 에러 조건이 없으면, quantize 된 지수가 항상 오른쪽 피연산자의 지수와 같음을 보장합니다.</p>
<p>또한, 다른 연산과는 달리, 결과가 비정상(subnormal)이고 부정확한 경우조차도, quantize는 결코 Underflow 신호를 보내지 않습니다.</p>
<p>두 번째 피연산자의 지수가 첫 번째 피연산자의 지수보다 크면 자리 올림이 필요할 수 있습니다. 이 경우, 자리 올림 모드는 (주어지면) <code class="docutils literal notranslate"><span class="pre">rounding</span></code> 인자에 의해 결정됩니다. 그렇지 않으면 주어진 <code class="docutils literal notranslate"><span class="pre">context</span></code> 인자에 의해 결정됩니다; 두 인자 모두 주어지지 않으면, 현재 스레드의 컨텍스트의 자리 올림 모드가 사용됩니다.</p>
<p>결과 지수가 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> 보다 크거나 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Etiny</span></code> 보다 작을 때마다 에러가 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.radix">
<code class="descname">radix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.radix" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 클래스가 모든 산술을 수행하는 진수(기수)인 <code class="docutils literal notranslate"><span class="pre">Decimal(10)</span></code> 을 반환합니다. 명세와의 호환성을 위해 포함됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.remainder_near">
<code class="descname">remainder_near</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.remainder_near" title="정의 주소">¶</a></dt>
<dd><p><em>self</em> 를 <em>other</em> 로 나눈 나머지를 반환합니다. 이것은 나머지의 절댓값을 최소화하기 위해 나머지의 부호가 선택된다는 점에서 <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">%</span> <span class="pre">other</span></code> 와 다릅니다. 좀 더 정확히 말하면, 반환 값은 <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">other</span></code> 인데, 여기서 <code class="docutils literal notranslate"><span class="pre">n</span></code> 은 <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">/</span> <span class="pre">other</span></code> 의 정확한 값에 가장 가까운 정수이고, 두 개의 정수와의 거리가 같으면 짝수가 선택됩니다.</p>
<p>결과가 0이면 그 부호는 <em>self</em> 의 부호가 됩니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;-2&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;5&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;-5&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.rotate" title="정의 주소">¶</a></dt>
<dd><p>첫 번째 피연산자의 계수를 두 번째 피연산자로 지정된 양만큼 회전한 결과를 반환합니다. 두 번째 피연산자는 -precision에서 precision 범위의 정수여야 합니다. 두 번째 피연산자의 절댓값은 회전할 자리의 수를 나타냅니다. 두 번째 피연산자가 양수면 왼쪽으로 회전합니다; 그렇지 않으면 오른쪽으로 회전합니다. 필요하면 정밀도에 맞추기 위해 첫 번째 피연산자의 계수에 0이 왼쪽에 채워집니다. 첫 번째 피연산자의 부호와 지수는 변경되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.same_quantum">
<code class="descname">same_quantum</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.same_quantum" title="정의 주소">¶</a></dt>
<dd><p>self와 other가 같은 지수를 가졌는지 또는 둘 다 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 인지 검사합니다.</p>
<p>이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다. 예외적으로, 두 번째 피연산자를 정확하게 변환할 수 없으면 C 버전은 InvalidOperation을 발생시킬 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.scaleb">
<code class="descname">scaleb</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.scaleb" title="정의 주소">¶</a></dt>
<dd><p>첫 번째 피연산자의 지수를 두 번째 피연산자만큼 조정한 값을 반환합니다. 달리 표현하면, 첫 번째 피연산자에 <code class="docutils literal notranslate"><span class="pre">10**other</span></code> 를 곱한 값을 반환합니다. 두 번째 피연산자는 정수여야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.shift">
<code class="descname">shift</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.shift" title="정의 주소">¶</a></dt>
<dd><p>첫 번째 피연산자의 계수를 두 번째 피연산자로 지정된 양만큼 이동한 결과를 반환합니다. 두 번째 피연산자는 -precision에서 precision 범위의 정수여야 합니다. 두 번째 피연산자의 절댓값은 이동할 자리의 수를 나타냅니다. 두 번째 피연산자가 양수면 왼쪽으로 이동합니다; 그렇지 않으면 오른쪽으로 이동합니다. 이동으로 인해 계수에 들어오는 숫자는 0입니다. 첫 번째 피연산자의 부호와 지수는 변경되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.sqrt">
<code class="descname">sqrt</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.sqrt" title="정의 주소">¶</a></dt>
<dd><p>인자의 제곱근을 완전한 정밀도로 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.to_eng_string">
<code class="descname">to_eng_string</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_eng_string" title="정의 주소">¶</a></dt>
<dd><p>문자열로 변환합니다. 지수가 필요하면 공학 표기법을 사용합니다.</p>
<p>공학 표기법의 지수는 3의 배수입니다. 이렇게 하면 소수점 왼쪽에 최대 3자리를 남기게 되고, 하나나 두 개의 후행 0을 추가해야 할 수 있습니다.</p>
<p>예를 들어, 이 메서드는 <code class="docutils literal notranslate"><span class="pre">Decimal('123E+1')</span></code> 을 <code class="docutils literal notranslate"><span class="pre">Decimal('1.23E+3')</span></code> 으로 변환합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">문자열로 변환하기 때문에, <code class="docutils literal notranslate"><span class="pre">Decimal('1.23E+3')</span></code> 이 아니라 <code class="docutils literal notranslate"><span class="pre">'1.23E+3'</span></code> 을 반환합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.to_integral">
<code class="descname">to_integral</code><span class="sig-paren">(</span><em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.to_integral_value" title="decimal.Decimal.to_integral_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_integral_value()</span></code></a> 메서드와 같습니다. <code class="docutils literal notranslate"><span class="pre">to_integral</span></code> 이름은 이전 버전과의 호환성을 위해 유지되었습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.to_integral_exact">
<code class="descname">to_integral_exact</code><span class="sig-paren">(</span><em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral_exact" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> 나 <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a> 신호를 주면서 가장 가까운 정수로 자리 올림 합니다. 자리 올림 모드는 (주어지면) <code class="docutils literal notranslate"><span class="pre">rounding</span></code> 매개 변수에 의해, 그렇지 않으면 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">context</span></code> 에 의해 결정됩니다. 두 매개 변수 모두 지정되지 않으면, 현재 컨텍스트의 자리 올림 모드가 사용됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.to_integral_value">
<code class="descname">to_integral_value</code><span class="sig-paren">(</span><em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral_value" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> 나 <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a> 신호를 주지 않고 가장 가까운 정수로 자리 올림 합니다. 주어지면, <em>rounding</em> 을 적용합니다; 그렇지 않으면, 제공된 <em>context</em> 나 현재 컨텍스트의 자리 올림 방법을 사용합니다.</p>
</dd></dl>

</dd></dl>

<div class="section" id="logical-operands">
<span id="logical-operands-label"></span><h3>논리적 피연산자<a class="headerlink" href="#logical-operands" title="제목 주소">¶</a></h3>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_and()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_invert()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_or()</span></code>와 <code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_xor()</span></code> 메서드는 인자가 <em>논리적 피연산자</em> 이길 기대합니다. <em>논리적 피연산자</em> 는 지수와 부호가 모두 0이고 숫자는 모두 <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> 또는 <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> 인 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">Decimal('11010')</span></code> 은 논리적 피연산자이지만, <code class="docutils literal notranslate"><span class="pre">Decimal('-11010')</span></code> 는
부호가 있기 때문에, <code class="docutils literal notranslate"><span class="pre">Decimal('12')</span></code> 는 <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> 과 <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> 이외의
숫자가 들어있기 때문에 논리적 피연산자가 아닙니다. 논리적 연산은 각 자릿수별로 이루어집니다.
즉, <code class="docutils literal notranslate"><span class="pre">Decimal('101').logical_or(Decimal('10'))</span></code> 은 <code class="docutils literal notranslate"><span class="pre">Decimal('111')</span></code>
이 됩니다.</p>
</div>
</div>
</div>
<div class="section" id="context-objects">
<span id="decimal-context"></span><h2>Context 객체<a class="headerlink" href="#context-objects" title="제목 주소">¶</a></h2>
<p>컨텍스트는 산술 연산을 위한 환경입니다. 정밀도를 제어하고, 자리 올림 규칙을 설정하며, 어떤 신호가 예외로 처리되는지 결정하고, 지수의 범위를 제한합니다.</p>
<p>각 스레드는 자신만의 현재 컨텍스트를 가지는데, <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 와 <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> 함수를 사용하여 액세스하거나 변경합니다:</p>
<dl class="function">
<dt id="decimal.getcontext">
<code class="descclassname">decimal.</code><code class="descname">getcontext</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.getcontext" title="정의 주소">¶</a></dt>
<dd><p>활성 스레드의 현재 컨텍스트를 돌려줍니다.</p>
</dd></dl>

<dl class="function">
<dt id="decimal.setcontext">
<code class="descclassname">decimal.</code><code class="descname">setcontext</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.setcontext" title="정의 주소">¶</a></dt>
<dd><p>활성 스레드의 현재 컨텍스트를 <em>c</em> 로 설정합니다.</p>
</dd></dl>

<p>또한 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문과 <a class="reference internal" href="#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">localcontext()</span></code></a> 함수를 사용하여 활성 컨텍스트를 일시적으로 변경할 수 있습니다.</p>
<dl class="function">
<dt id="decimal.localcontext">
<code class="descclassname">decimal.</code><code class="descname">localcontext</code><span class="sig-paren">(</span><em>ctx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.localcontext" title="정의 주소">¶</a></dt>
<dd><p>with-문으로 진입할 때 활성 스레드의 현재 컨텍스트를 <em>ctx</em> 의 복사본으로 설정하고, with-문을 빠져나올 때 이전의 컨텍스트를 복원하는 컨텍스트 관리자를 돌려줍니다. 컨텍스트를 지정하지 않으면 현재 컨텍스트의 복사본이 사용됩니다.</p>
<p>예를 들어, 다음 코드는 현재 십진 정밀도를 42자리로 설정하고, 계산을 수행한 다음, 이전 컨텍스트를 자동으로 복원합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">localcontext</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">()</span> <span class="k">as</span> <span class="n">ctx</span><span class="p">:</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">42</span>   <span class="c1"># 높은 정밀도 계산을 수행합니다</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_something</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="o">+</span><span class="n">s</span>  <span class="c1"># 최종 결과를 기본 정밀도로 되돌립니다</span>
</pre></div>
</div>
</dd></dl>

<p>아래에 설명된 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 생성자를 사용하여 새로운 컨텍스트를 만들 수도 있습니다. 또한, 이 모듈은 세 가지 미리 만들어진 컨텍스트를 제공합니다:</p>
<dl class="class">
<dt id="decimal.BasicContext">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">BasicContext</code><a class="headerlink" href="#decimal.BasicContext" title="정의 주소">¶</a></dt>
<dd><p>이것은 일반 십진 산술 명세에서 정의된 표준 컨텍스트입니다. 정밀도는 9로 설정됩니다. 자리 올림은 <a class="reference internal" href="#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_UP</span></code></a>으로 설정됩니다. 모든 플래그가 지워집니다. 모든 트랩은 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a>, <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a>, <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal notranslate"><span class="pre">Subnormal</span></code></a>을 제외하고는 활성화됩니다 (예외로 처리됩니다).</p>
<p>많은 트랩이 활성화되었으므로, 이 컨텍스트는 디버깅에 유용합니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.ExtendedContext">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">ExtendedContext</code><a class="headerlink" href="#decimal.ExtendedContext" title="정의 주소">¶</a></dt>
<dd><p>이것은 일반 십진 산술 명세에서 정의된 표준 컨텍스트입니다. 정밀도는 9로 설정됩니다. 자리 올림은 <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>으로 설정됩니다. 모든 플래그가 지워집니다. 아무 트랩도 활성화되지 않습니다 (그래서 계산 중에 예외가 발생하지 않습니다).</p>
<p>트랩이 비활성화되었으므로, 이 컨텍스트는 예외를 발생시키기보다 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 이나 <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code> 의 결괏값을 선호하는 응용 프로그램에 유용합니다. 이는 응용 프로그램이 그렇지 않으면 프로그램을 중단시킬 수 있는 조건이 있는 경우에도 실행을 완료할 수 있도록 합니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.DefaultContext">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">DefaultContext</code><a class="headerlink" href="#decimal.DefaultContext" title="정의 주소">¶</a></dt>
<dd><p>이 컨텍스트는 새로운 컨텍스트의 프로토타입으로 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 생성자에 의해 사용됩니다. 필드(가령 정밀도)를 변경하면 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 생성자에 의해 생성된 새로운 컨텍스트에 대한 기본값을 변경하는 효과가 있습니다.</p>
<p>이 컨텍스트는 다중 스레드 환경에서 가장 유용합니다. 스레드가 시작되기 전에 필드 중 하나를 변경하면 시스템 전체의 기본값을 설정하는 효과가 있습니다. 스레드가 시작된 후에 필드를 변경하는 것은. 스레드 동기화를 통해 경쟁 조건을 방지해야 하므로 권장되지 않습니다.</p>
<p>단일 스레드 환경에서는, 이 컨텍스트를 아예 사용하지 않는 것이 좋습니다. 대신, 아래에 설명된 대로 명시적으로 컨텍스트를 만드십시오.</p>
<p>기본값은 <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code>=<code class="xref py py-const docutils literal notranslate"><span class="pre">28</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">rounding</span></code>=<a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a> 이고 <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-class docutils literal notranslate"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a>, <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 트랩이 활성화됩니다.</p>
</dd></dl>

<p>3개의 제공된 컨텍스트 외에도, 새로운 컨텍스트를 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 생성자를 사용하여 만들 수 있습니다.</p>
<dl class="class">
<dt id="decimal.Context">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Context</code><span class="sig-paren">(</span><em>prec=None</em>, <em>rounding=None</em>, <em>Emin=None</em>, <em>Emax=None</em>, <em>capitals=None</em>, <em>clamp=None</em>, <em>flags=None</em>, <em>traps=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context" title="정의 주소">¶</a></dt>
<dd><p>새로운 컨텍스트를 만듭니다. 필드가 지정되지 않았거나 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이면, 기본값은 <a class="reference internal" href="#decimal.DefaultContext" title="decimal.DefaultContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">DefaultContext</span></code></a> 에서 복사됩니다. <em>flags</em> 필드가 지정되지 않았거나 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이면, 모든 플래그가 지워집니다.</p>
<p><em>prec</em> 는 컨텍스트에서 산술 연산의 정밀도를 설정하는 [<code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>, <a class="reference internal" href="#decimal.MAX_PREC" title="decimal.MAX_PREC"><code class="xref py py-const docutils literal notranslate"><span class="pre">MAX_PREC</span></code></a>] 범위의 정수입니다.</p>
<p><em>rounding</em> 옵션은 <a class="reference internal" href="#rounding-modes">자리 올림 모드</a> 섹션에 나열된 상수 중 하나입니다.</p>
<p><em>traps</em> 과 <em>flags</em> 필드는 설정할 신호를 나열합니다. 일반적으로, 새 컨텍스트는 트랩만 설정하고 플래그는 지워진 채로 두어야 합니다.</p>
<p><em>Emin</em> 과 <em>Emax</em> 필드는 지수에 허용되는 한계를 지정하는 정수입니다. <em>Emin</em> 은 [<a class="reference internal" href="#decimal.MIN_EMIN" title="decimal.MIN_EMIN"><code class="xref py py-const docutils literal notranslate"><span class="pre">MIN_EMIN</span></code></a>, <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>], <em>Emax</em> 는 [<code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>, <a class="reference internal" href="#decimal.MAX_EMAX" title="decimal.MAX_EMAX"><code class="xref py py-const docutils literal notranslate"><span class="pre">MAX_EMAX</span></code></a>] 범위 내에 있어야 합니다.</p>
<p><em>capitals</em> 필드는 <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> 또는 <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>(기본값)입니다. <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>로 설정하면, 지수는 대문자 <code class="xref py py-const docutils literal notranslate"><span class="pre">E</span></code>와 함께 인쇄됩니다; 그렇지 않으면 소문자 <code class="xref py py-const docutils literal notranslate"><span class="pre">e</span></code> 가 사용됩니다: <code class="xref py py-const docutils literal notranslate"><span class="pre">Decimal('6.02e+23')</span></code>.</p>
<p><em>clamp</em> 필드는 <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> (기본값) 또는 <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> 입니다. <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>로 설정하면, 이 컨텍스트에서 표현할 수 있는 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스의 지수 <code class="docutils literal notranslate"><span class="pre">e</span></code> 는 <code class="docutils literal notranslate"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">e</span> <span class="pre">&lt;=</span> <span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> 입니다. <em>clamp</em> 가 <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> 이면 더 약한 조건이 유지됩니다: <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스의 조정된 최대 <code class="docutils literal notranslate"><span class="pre">Emax</span></code> 입니다. <em>clamp</em> 가 <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> 일 때, 큰 정상 수는, 가능할 때, 지수 제약 조건을 맞추기 위해 지수가 감소하고 해당 숫자만큼의 0이 계수에 더해집니다; 이것은 수의 값을 보존하지만 유효한 후미 0에 대한 정보를 잃어버립니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">&#39;1.23e999&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.23000E+999&#39;)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p>지수가 <code class="docutils literal notranslate"><span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code>, 즉 994 로 줄어든다는 뜻입니다. 이 지수에 맞추기 위해
세 개의 0을 추가했습니다:</p>
<div class="last highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.23000E+999&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as_tuple</span><span class="p">()</span>
<span class="go">DecimalTuple(sign=0, digits=(1, 2, 3, 0, 0, 0), exponent=994)</span>
</pre></div>
</div>
</div>
<p><code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> 의 <em>clamp</em> 값은 IEEE 754에 명시된 고정 폭 십진수 교환 형식과 호환되도록 합니다.</p>
<p><a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 클래스는 주어진 컨텍스트에서 직접 산술을 하는데 필요한 다수의 메서드뿐만 아니라 여러 가지 범용 메서드를 정의합니다. 이에 더해, 위에서 설명한 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 메서드마다 (<code class="xref py py-meth docutils literal notranslate"><span class="pre">adjusted()</span></code>와 <code class="xref py py-meth docutils literal notranslate"><span class="pre">as_tuple()</span></code> 메서드는 예외입니다) 대응하는 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 메서드가 있습니다. 예를 들어, <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 인스턴스 <code class="docutils literal notranslate"><span class="pre">C</span></code> 와 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스 <code class="docutils literal notranslate"><span class="pre">x</span></code> 에 대해서, <code class="docutils literal notranslate"><span class="pre">C.exp(x)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.exp(context=C)</span></code> 와 동등합니다. 각각 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 메서드는 Decimal 인스턴스가 받아들여지는 곳 어디에서나 파이썬 정수(<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 의 인스턴스)를 받아들입니다.</p>
<dl class="method">
<dt id="decimal.Context.clear_flags">
<code class="descname">clear_flags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.clear_flags" title="정의 주소">¶</a></dt>
<dd><p>모든 플래그를 <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>으로 재설정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.clear_traps">
<code class="descname">clear_traps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.clear_traps" title="정의 주소">¶</a></dt>
<dd><p>모든 트랩을 <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>으로 재설정합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy" title="정의 주소">¶</a></dt>
<dd><p>컨텍스트의 복사본을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy_decimal">
<code class="descname">copy_decimal</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_decimal" title="정의 주소">¶</a></dt>
<dd><p>Decimal 인스턴스 num의 복사본을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.create_decimal">
<code class="descname">create_decimal</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.create_decimal" title="정의 주소">¶</a></dt>
<dd><p><em>self</em> 를 컨텍스트로 사용해서, <em>num</em> 으로 새 Decimal 인스턴스를 만듭니다. <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 생성자와 달리, 컨텍스트 정밀도, 자리 올림 방법, 플래그 및 트랩이 변환에 적용됩니다.</p>
<p>이는 상수가 보통 응용 프로그램에 필요한 것보다 더 큰 정밀도로 제공되기 때문에 유용합니다. 또 다른 이점은 자리 올림이 현재 정밀도를 초과하는 자릿수로 인한 의도하지 않은 결과를 즉시 제거한다는 것입니다. 다음 예제에서, 자리 올림 되지 않은 입력을 사용한다는 것은 합계에 0을 추가하면 결과가 달라질 수 있음을 의미합니다.:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.4445&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.0023&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.45&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.4445&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.0023&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.44&#39;)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">정밀도가 3인 컨텍스트에서 유효숫자가 5자리인 상수들로 산술을 하고 있습니다. 첫 번째 산술은
<code class="docutils literal notranslate"><span class="pre">Decimal('4.4468')</span></code> 을 유효숫자 3개로 자리 올림해서 <code class="docutils literal notranslate"><span class="pre">Decimal('4.45')</span></code> 가
얻어집니다. 하지만 두 번째 산술은 <code class="docutils literal notranslate"><span class="pre">Decimal('3.4445')</span> <span class="pre">+</span> <span class="pre">Decimal(0)</span></code> 이 먼저
<code class="docutils literal notranslate"><span class="pre">Decimal('3.4445')</span></code> 를 주고 이 값은 다시 <code class="docutils literal notranslate"><span class="pre">Decimal('3.44')</span></code> 로 자리 올림됩니다.
이 값이 다시 <code class="docutils literal notranslate"><span class="pre">Decimal('1.0023')</span></code> 와 더해지면 <code class="docutils literal notranslate"><span class="pre">`Decimal('4.4423')``</span></code> 을 거쳐
<code class="docutils literal notranslate"><span class="pre">Decimal('4.44')</span></code> 로 자리 올림됩니다. 중간 자리 올림 때문에 <code class="docutils literal notranslate"><span class="pre">Decimal(0)</span></code> 을 더하는
것 만으로 두 결과가 달라집니다. 일관된 결과를 얻으려면 상수들을 <a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_decimal()</span></code></a>
로 미리 변환해서 사용하라는 뜻입니다.</p>
</div>
<p>이 메서드는 IBM 명세의 to-number 연산을 구현합니다. 인자가 문자열이면, 선행 또는 후행 공백이나 밑줄이 허용되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.create_decimal_from_float">
<code class="descname">create_decimal_from_float</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.create_decimal_from_float" title="정의 주소">¶</a></dt>
<dd><p>float <em>f</em> 로 새 Decimal 인스턴스를 만들지만, <em>self</em> 를 컨텍스트로 사용하여 자리 올림 합니다. <a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Decimal.from_float()</span></code></a> 클래스 메서드와는 달리, 컨텍스트 정밀도, 자리 올림 방법, 플래그 및 트랩이 변환에 적용됩니다.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.1415&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">decimal.Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.Etiny">
<code class="descname">Etiny</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.Etiny" title="정의 주소">¶</a></dt>
<dd><p>비정상 결과에 대한 최소 지수 값인 <code class="docutils literal notranslate"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> 과 같은 값을 반환합니다. 언더 플로우가 발생하면, 지수는 <a class="reference internal" href="#decimal.Context.Etiny" title="decimal.Context.Etiny"><code class="xref py py-const docutils literal notranslate"><span class="pre">Etiny</span></code></a> 로 설정됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.Etop">
<code class="descname">Etop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.Etop" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> 과 같은 값을 반환합니다.</p>
</dd></dl>

<p>십진수로 작업하는 일반적인 접근법은 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 인스턴스를 생성한 다음 활성 스레드의 현재 컨텍스트 내에서 진행되는 산술 연산을 적용하는 것입니다. 다른 방법은 특정 컨텍스트 내에서 계산하기 위해 컨텍스트 메서드를 사용하는 것입니다. 메서드는 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 클래스의 메서드와 비슷하며 여기에서는 간단히 설명합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">여기에 나오는 설명은 대단히 축약된 것입니다. 사용하기 전에 대응하는 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 메서드의
설명을 확인하세요.</p>
</div>
<dl class="method">
<dt id="decimal.Context.abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.abs" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 의 절댓값을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.add" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 와 <em>y</em> 의 합을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.canonical">
<code class="descname">canonical</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.canonical" title="정의 주소">¶</a></dt>
<dd><p>같은 Decimal 객체 <em>x</em> 를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.compare">
<code class="descname">compare</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 와 <em>y</em> 를 수치로 비교합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.compare_signal">
<code class="descname">compare_signal</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_signal" title="정의 주소">¶</a></dt>
<dd><p>두 피연산자의 값을 수치로 비교합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.compare_total">
<code class="descname">compare_total</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_total" title="정의 주소">¶</a></dt>
<dd><p>추상 표현을 사용하여 두 피연산자를 비교합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.compare_total_mag">
<code class="descname">compare_total_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_total_mag" title="정의 주소">¶</a></dt>
<dd><p>부호를 무시하고, 추상 표현을 사용하여 두 피연산자를 비교합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy_abs">
<code class="descname">copy_abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_abs" title="정의 주소">¶</a></dt>
<dd><p>부호가 0으로 설정되어있는 <em>x</em> 의 복사본을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy_negate">
<code class="descname">copy_negate</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_negate" title="정의 주소">¶</a></dt>
<dd><p>부호가 반전된 <em>x</em> 복사본을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy_sign">
<code class="descname">copy_sign</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_sign" title="정의 주소">¶</a></dt>
<dd><p><em>y</em> 에서 <em>x</em> 로 부호를 복사합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.divide">
<code class="descname">divide</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divide" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 를 <em>y</em> 로 나눈 값을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.divide_int">
<code class="descname">divide_int</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divide_int" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 를 <em>y</em> 로 나눈 후 정수로 잘라낸 값을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.divmod">
<code class="descname">divmod</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divmod" title="정의 주소">¶</a></dt>
<dd><p>두 숫자를 나누고 결과의 정수 부분을 반환합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">잘못 설명되어 있습니다. 내장 <a class="reference internal" href="functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> 처럼 몫과 나머지를 튜플로 돌려줍니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.exp">
<code class="descname">exp</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.exp" title="정의 주소">¶</a></dt>
<dd><p><cite>e ** x</cite>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.fma">
<code class="descname">fma</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.fma" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 에 <em>y</em> 를 곱한 후 <em>z</em> 를 더한 값을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_canonical">
<code class="descname">is_canonical</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_canonical" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 규범적일 경우 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_finite">
<code class="descname">is_finite</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_finite" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 유한이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_infinite">
<code class="descname">is_infinite</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_infinite" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 무한대면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_nan">
<code class="descname">is_nan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_nan" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 qNaN 이나 sNaN 이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_normal">
<code class="descname">is_normal</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_normal" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 정상 수면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_qnan">
<code class="descname">is_qnan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_qnan" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 조용한 NaN이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_signed">
<code class="descname">is_signed</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_signed" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 음수면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_snan">
<code class="descname">is_snan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_snan" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 신호를 주는 NaN 이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_subnormal">
<code class="descname">is_subnormal</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_subnormal" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 비정상이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_zero">
<code class="descname">is_zero</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_zero" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 0이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.ln">
<code class="descname">ln</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.ln" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 의 자연로그(밑 e)를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.log10">
<code class="descname">log10</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.log10" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 의 상용로그를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logb">
<code class="descname">logb</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logb" title="정의 주소">¶</a></dt>
<dd><p>피연산자의 최상위 유효 숫자의 크기의 지수를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logical_and">
<code class="descname">logical_and</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_and" title="정의 주소">¶</a></dt>
<dd><p>각 피연산자의 자릿수별로 논리적 연산 <em>and</em> 를 적용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logical_invert">
<code class="descname">logical_invert</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_invert" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 의 모든 자릿수를 반전합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logical_or">
<code class="descname">logical_or</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_or" title="정의 주소">¶</a></dt>
<dd><p>각 피연산자의 자릿수별로 논리적 연산 <em>or</em> 를 적용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logical_xor">
<code class="descname">logical_xor</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_xor" title="정의 주소">¶</a></dt>
<dd><p>각 피연산자의 자릿수별로 논리적 연산 <em>xor</em> 를 적용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.max" title="정의 주소">¶</a></dt>
<dd><p>두 값을 수치로 비교해, 최댓값을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.max_mag">
<code class="descname">max_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.max_mag" title="정의 주소">¶</a></dt>
<dd><p>부호를 무시하고 값을 수치로 비교합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.min" title="정의 주소">¶</a></dt>
<dd><p>두 값을 수치로 비교해, 최솟값을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.min_mag">
<code class="descname">min_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.min_mag" title="정의 주소">¶</a></dt>
<dd><p>부호를 무시하고 값을 수치로 비교합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.minus">
<code class="descname">minus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.minus" title="정의 주소">¶</a></dt>
<dd><p>minus는 파이썬에서 단항 접두사 빼기 연산자에 해당합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.multiply">
<code class="descname">multiply</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.multiply" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 와 <em>y</em> 의 곱을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.next_minus">
<code class="descname">next_minus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_minus" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 보다 작고 표현 가능한 가장 큰 수를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.next_plus">
<code class="descname">next_plus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_plus" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 보다 크고 표현 가능한 가장 작은 수를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.next_toward">
<code class="descname">next_toward</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_toward" title="정의 주소">¶</a></dt>
<dd><p><em>y</em> 방향으로 <em>x</em> 에 가장 가까운 숫자를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.normalize" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 를 가장 간단한 형태로 환원합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.number_class">
<code class="descname">number_class</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.number_class" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 의 클래스를 가리키는 문자열을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.plus">
<code class="descname">plus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.plus" title="정의 주소">¶</a></dt>
<dd><p>plus는 파이썬에서 단항 접두사 더하기 연산자에 해당합니다. 이 연산은 컨텍스트 정밀도와 자리 올림을 적용하므로 항등 연산이 <em>아닙니다</em>.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.power">
<code class="descname">power</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>modulo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.power" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">x</span></code> 의 <code class="docutils literal notranslate"><span class="pre">y</span></code> 거듭제곱을 돌려줍니다. 주어지면 <code class="docutils literal notranslate"><span class="pre">modulo</span></code> 모듈로로 환원합니다.</p>
<p>두 인자로는 <code class="docutils literal notranslate"><span class="pre">x**y</span></code> 를 계산합니다. <code class="docutils literal notranslate"><span class="pre">x</span></code> 가 음수면 <code class="docutils literal notranslate"><span class="pre">y</span></code> 는 정수여야 합니다. <code class="docutils literal notranslate"><span class="pre">y</span></code> 가 정수이고 결과가 유한하고 'precision' 자릿수로 정확하게 표현될 수 있지 않은 이상 결과는 부정확합니다. 컨텍스트의 자리 올림 모드가 사용됩니다. 결과는 항상 파이썬 버전에서 정확하게 자리 올림 됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>C 모듈은 올바르게 자리 올림 된 <a class="reference internal" href="#decimal.Context.exp" title="decimal.Context.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>와 <a class="reference internal" href="#decimal.Context.ln" title="decimal.Context.ln"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ln()</span></code></a> 함수로 <a class="reference internal" href="#decimal.Context.power" title="decimal.Context.power"><code class="xref py py-meth docutils literal notranslate"><span class="pre">power()</span></code></a>를 계산합니다. 결과는 잘 정의되어 있지만 &quot;거의 항상 올바르게 자리 올림 될&quot; 뿐입니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">C 버전은 <code class="docutils literal notranslate"><span class="pre">x**y</span></code> 를 <code class="docutils literal notranslate"><span class="pre">exp(y</span> <span class="pre">*</span> <span class="pre">ln(x))</span></code> 의 형태로 계산한다는 뜻입니다. 이 과정에서
중간 자리 올림이 발생할 수 있는데, 언제나 올바르게 자리 올림된다는 보장은 없다는 뜻입니다.</p>
</div>
<p>세 인자로는 <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code> 를 계산합니다. 세 인자 형식의 경우, 인자에 다음과 같은 제한이 있습니다:</p>
<blockquote>
<div><ul class="simple">
<li>세 인자는 모두 정수여야 합니다.</li>
<li><code class="docutils literal notranslate"><span class="pre">y</span></code> 는 음수가 아니어야 합니다.</li>
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> 나 <code class="docutils literal notranslate"><span class="pre">y</span></code> 중 적어도 하나는 0이 아니어야 합니다</li>
<li><code class="docutils literal notranslate"><span class="pre">modulo</span></code> 는 0이 아니고 최대 'precision' 자릿수를 가져야 합니다</li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Context.power(x,</span> <span class="pre">y,</span> <span class="pre">modulo)</span></code> 의 결괏값은 무한 정밀도로 <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code> 를 계산할 때 얻을 수 있는 값과 같지만, 더 효율적으로 계산됩니다. 결과의 지수는 <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> 및 <code class="docutils literal notranslate"><span class="pre">modulo</span></code> 의 지수와 관계없이 0입니다. 결과는 항상 정확합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.quantize">
<code class="descname">quantize</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.quantize" title="정의 주소">¶</a></dt>
<dd><p><em>y</em> 의 지수를 가지는 (자리 올림 된) <em>x</em> 와 같은 값을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.radix">
<code class="descname">radix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.radix" title="정의 주소">¶</a></dt>
<dd><p>Decimal이기 때문에 단지 10을 반환합니다, :)</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.remainder">
<code class="descname">remainder</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.remainder" title="정의 주소">¶</a></dt>
<dd><p>정수 나눗셈의 나머지를 반환합니다.</p>
<p>결과가 0이 아닐 때, 결과의 부호는 원래의 피제수와 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.remainder_near">
<code class="descname">remainder_near</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.remainder_near" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">n</span></code> 을 반환하는데, <em>n</em> 은 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> 의 정확한 값에 가장 가까운 정수입니다 (결과가 0이면 그 부호는 <em>x</em> 의 부호가 됩니다).</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.rotate" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 를 <em>y</em> 번 회전한 복사본을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.same_quantum">
<code class="descname">same_quantum</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.same_quantum" title="정의 주소">¶</a></dt>
<dd><p>두 피연산자의 지수가 같으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.scaleb">
<code class="descname">scaleb</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.scaleb" title="정의 주소">¶</a></dt>
<dd><p>첫 번째 피연산자의 지수에 두 번째 값을 더해서 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.shift">
<code class="descname">shift</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.shift" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 를 <em>y</em> 번 이동한 복사본을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.sqrt">
<code class="descname">sqrt</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.sqrt" title="정의 주소">¶</a></dt>
<dd><p>음이 아닌 수의 제곱근을 컨텍스트의 정밀도로 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.subtract">
<code class="descname">subtract</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.subtract" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 와 <em>y</em> 의 차를 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.to_eng_string">
<code class="descname">to_eng_string</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_eng_string" title="정의 주소">¶</a></dt>
<dd><p>문자열로 변환합니다. 지수가 필요하면 공학 표기법을 사용합니다.</p>
<p>공학 표기법의 지수는 3의 배수입니다. 이렇게 하면 소수점 왼쪽에 최대 3자리를 남기게 되고, 하나나 두 개의 후행 0을 추가해야 할 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.to_integral_exact">
<code class="descname">to_integral_exact</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_integral_exact" title="정의 주소">¶</a></dt>
<dd><p>정수로 자리 올림 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.to_sci_string">
<code class="descname">to_sci_string</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_sci_string" title="정의 주소">¶</a></dt>
<dd><p>과학 표기법을 사용하여 숫자를 문자열로 변환합니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="constants">
<span id="decimal-rounding-modes"></span><h2>상수<a class="headerlink" href="#constants" title="제목 주소">¶</a></h2>
<p>이 절의 상수는 C 모듈에서만 의미가 있습니다. 호환성을 위해 순수 파이썬 버전에도 포함되어 있습니다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="29%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">32-비트</th>
<th class="head">64-비트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><dl class="first last data">
<dt id="decimal.MAX_PREC">
<code class="descclassname">decimal.</code><code class="descname">MAX_PREC</code><a class="headerlink" href="#decimal.MAX_PREC" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><code class="xref py py-const docutils literal notranslate"><span class="pre">425000000</span></code></td>
<td><code class="xref py py-const docutils literal notranslate"><span class="pre">999999999999999999</span></code></td>
</tr>
<tr class="row-odd"><td><dl class="first last data">
<dt id="decimal.MAX_EMAX">
<code class="descclassname">decimal.</code><code class="descname">MAX_EMAX</code><a class="headerlink" href="#decimal.MAX_EMAX" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><code class="xref py py-const docutils literal notranslate"><span class="pre">425000000</span></code></td>
<td><code class="xref py py-const docutils literal notranslate"><span class="pre">999999999999999999</span></code></td>
</tr>
<tr class="row-even"><td><dl class="first last data">
<dt id="decimal.MIN_EMIN">
<code class="descclassname">decimal.</code><code class="descname">MIN_EMIN</code><a class="headerlink" href="#decimal.MIN_EMIN" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><code class="xref py py-const docutils literal notranslate"><span class="pre">-425000000</span></code></td>
<td><code class="xref py py-const docutils literal notranslate"><span class="pre">-999999999999999999</span></code></td>
</tr>
<tr class="row-odd"><td><dl class="first last data">
<dt id="decimal.MIN_ETINY">
<code class="descclassname">decimal.</code><code class="descname">MIN_ETINY</code><a class="headerlink" href="#decimal.MIN_ETINY" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><code class="xref py py-const docutils literal notranslate"><span class="pre">-849999999</span></code></td>
<td><code class="xref py py-const docutils literal notranslate"><span class="pre">-1999999999999999997</span></code></td>
</tr>
</tbody>
</table>
<dl class="data">
<dt id="decimal.HAVE_THREADS">
<code class="descclassname">decimal.</code><code class="descname">HAVE_THREADS</code><a class="headerlink" href="#decimal.HAVE_THREADS" title="정의 주소">¶</a></dt>
<dd><p>기본값은 <code class="docutils literal notranslate"><span class="pre">True</span></code> 입니다. 파이썬이 스레드 없이 컴파일되면, C 버전은 값비싼 스레드 로컬 컨텍스트 사용을 자동으로 비활성화시킵니다. 이 경우 값은 <code class="docutils literal notranslate"><span class="pre">False</span></code> 입니다.</p>
</dd></dl>

</div>
<div class="section" id="rounding-modes">
<h2>자리 올림 모드<a class="headerlink" href="#rounding-modes" title="제목 주소">¶</a></h2>
<dl class="data">
<dt id="decimal.ROUND_CEILING">
<code class="descclassname">decimal.</code><code class="descname">ROUND_CEILING</code><a class="headerlink" href="#decimal.ROUND_CEILING" title="정의 주소">¶</a></dt>
<dd><p><code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code>를 향해 올립니다.</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_DOWN">
<code class="descclassname">decimal.</code><code class="descname">ROUND_DOWN</code><a class="headerlink" href="#decimal.ROUND_DOWN" title="정의 주소">¶</a></dt>
<dd><p>0을 향해 자리 올림 합니다.</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_FLOOR">
<code class="descclassname">decimal.</code><code class="descname">ROUND_FLOOR</code><a class="headerlink" href="#decimal.ROUND_FLOOR" title="정의 주소">¶</a></dt>
<dd><p><code class="xref py py-const docutils literal notranslate"><span class="pre">-Infinity</span></code>를 향해 내립니다.</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_HALF_DOWN">
<code class="descclassname">decimal.</code><code class="descname">ROUND_HALF_DOWN</code><a class="headerlink" href="#decimal.ROUND_HALF_DOWN" title="정의 주소">¶</a></dt>
<dd><p>가장 가까운 값으로 반올림하고, 동률이면 0에서 가까운 것을 선택합니다.</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_HALF_EVEN">
<code class="descclassname">decimal.</code><code class="descname">ROUND_HALF_EVEN</code><a class="headerlink" href="#decimal.ROUND_HALF_EVEN" title="정의 주소">¶</a></dt>
<dd><p>가장 가까운 값으로 반올림하고, 동률이면 짝수를 선택합니다.</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_HALF_UP">
<code class="descclassname">decimal.</code><code class="descname">ROUND_HALF_UP</code><a class="headerlink" href="#decimal.ROUND_HALF_UP" title="정의 주소">¶</a></dt>
<dd><p>가장 가까운 값으로 반올림하고, 동률이면 0에서 먼 것을 선택합니다.</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_UP">
<code class="descclassname">decimal.</code><code class="descname">ROUND_UP</code><a class="headerlink" href="#decimal.ROUND_UP" title="정의 주소">¶</a></dt>
<dd><p>0에서 먼 쪽으로 자리 올림 합니다.</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_05UP">
<code class="descclassname">decimal.</code><code class="descname">ROUND_05UP</code><a class="headerlink" href="#decimal.ROUND_05UP" title="정의 주소">¶</a></dt>
<dd><p>0을 향해 자리 올림 했을 때 마지막 숫자가 0이나 5면 0에서 먼 쪽으로 자리 올림 합니다. 그렇지 않으면 0을 향해 자리 올림 합니다.</p>
</dd></dl>

</div>
<div class="section" id="signals">
<span id="decimal-signals"></span><h2>신호<a class="headerlink" href="#signals" title="제목 주소">¶</a></h2>
<p>신호는 계산 중 발생하는 조건을 나타냅니다. 각각은 하나의 컨텍스트 플래그와 하나의 컨텍스트 트랩 활성화기에 대응합니다.</p>
<p>컨텍스트 플래그는 조건이 발생할 때마다 설정됩니다. 계산 후에, 플래그는 정보를 얻기 위한 목적으로 확인될 수 있습니다 (예를 들어, 계산이 정확한지를 판별하기 위해). 플래그를 확인한 후 다음 계산을 시작하기 전에 모든 플래그를 지우십시오.</p>
<p>컨텍스트의 트랩 활성화기가 신호에 대해 설정되면, 조건은 파이썬 예외를 일으킵니다. 예를 들어, <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 트랩이 설정되면, 이 조건을 만날 때 <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 예외가 발생합니다.</p>
<dl class="class">
<dt id="decimal.Clamped">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Clamped</code><a class="headerlink" href="#decimal.Clamped" title="정의 주소">¶</a></dt>
<dd><p>표현 제약 조건에 맞도록 지수를 변경했습니다.</p>
<p>일반적으로, 지수가 컨텍스트의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emin</span></code>과 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> 한계를 벗어날 때 클램핑이 발생합니다. 가능하면, 계수에 0을 추가하여 지수를 줄입니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.DecimalException">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">DecimalException</code><a class="headerlink" href="#decimal.DecimalException" title="정의 주소">¶</a></dt>
<dd><p>다른 신호의 베이스 클래스이고 <a class="reference internal" href="exceptions.html#ArithmeticError" title="ArithmeticError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code></a> 의 서브 클래스입니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.DivisionByZero">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">DivisionByZero</code><a class="headerlink" href="#decimal.DivisionByZero" title="정의 주소">¶</a></dt>
<dd><p>무한대가 아닌 숫자를 0으로 나눴다는 신호를 줍니다.</p>
<p>나눗셈, 모듈로 나눗셈 또는 음수로 숫자를 거듭제곱할 때 발생할 수 있습니다. 이 신호가 트랩 되지 않으면, 계산에 제공된 입력의 부호에 따라 <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code> 나 <code class="xref py py-const docutils literal notranslate"><span class="pre">-Infinity</span></code>를 돌려줍니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.Inexact">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Inexact</code><a class="headerlink" href="#decimal.Inexact" title="정의 주소">¶</a></dt>
<dd><p>자리 올림이 발생했고 결과가 정확하지 않음을 나타냅니다.</p>
<p>자리 올림 도중 0이 아닌 숫자가 삭제된 경우 신호를 줍니다. 자리 올림 된 결과가 반환됩니다. 신호 플래그나 트랩은 결과가 정확하지 않을 때를 감지하는 데 사용됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.InvalidOperation">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">InvalidOperation</code><a class="headerlink" href="#decimal.InvalidOperation" title="정의 주소">¶</a></dt>
<dd><p>유효하지 않은 연산이 수행되었습니다.</p>
<p>의미가 없는 연산이 요청되었음을 나타냅니다. 트랩 되지 않으면, <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 을 반환합니다. 가능한 원인은 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Infinity</span> <span class="o">-</span> <span class="n">Infinity</span>
<span class="mi">0</span> <span class="o">*</span> <span class="n">Infinity</span>
<span class="n">Infinity</span> <span class="o">/</span> <span class="n">Infinity</span>
<span class="n">x</span> <span class="o">%</span> <span class="mi">0</span>
<span class="n">Infinity</span> <span class="o">%</span> <span class="n">x</span>
<span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="o">**</span> <span class="mi">0</span>
<span class="n">x</span> <span class="o">**</span> <span class="p">(</span><span class="n">non</span><span class="o">-</span><span class="n">integer</span><span class="p">)</span>
<span class="n">x</span> <span class="o">**</span> <span class="n">Infinity</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">정수가 아닌 값이나 무한대로 거듭제곱하는 경우는 <code class="docutils literal notranslate"><span class="pre">x</span></code> 가 음수일 때만 해당됩니다. 정수가
아닌 값으로 음수를 거듭제곱하면 복소수가 되고, 무한대로 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 보다 작거나 같은 음수를
거듭제곱하면 부호가 결정되지 않기 때문입니다. <code class="docutils literal notranslate"><span class="pre">-1</span></code> 보다 큰 음수를 무한대로 거듭제곱하면
<code class="docutils literal notranslate"><span class="pre">0</span></code> 이지만, 이 경우도 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> 신호를 줍니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="decimal.Overflow">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Overflow</code><a class="headerlink" href="#decimal.Overflow" title="정의 주소">¶</a></dt>
<dd><p>수치적 오버플로.</p>
<p>자리 올림 후에 지수가 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> 보다 큼을 나타냅니다. 트랩 되지 않으면, 결과는 자리 올림 모드에 따라 달라지는데, 가장 큰 표현 가능한 유한 수로 안쪽으로 당기거나 <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code>를 향해 바깥쪽으로 자리 올림 됩니다. 두 경우 모두 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inexact</span></code></a>와 <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rounded</span></code></a> 신호도 줍니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.Rounded">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Rounded</code><a class="headerlink" href="#decimal.Rounded" title="정의 주소">¶</a></dt>
<dd><p>정보가 손실되지는 않았지만 자리 올림이 발생했습니다.</p>
<p>자리 올림이 자릿수를 버릴 때마다 신호를 줍니다; 그 자릿수가 0일 때도 그렇습니다 (가령 <code class="xref py py-const docutils literal notranslate"><span class="pre">5.00</span></code>을 <code class="xref py py-const docutils literal notranslate"><span class="pre">5.0</span></code>으로 자리 올림). 트랩 되지 않으면, 결과를 그대로 반환합니다. 이 신호는 유효숫자의 손실을 감지하는 데 사용됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.Subnormal">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Subnormal</code><a class="headerlink" href="#decimal.Subnormal" title="정의 주소">¶</a></dt>
<dd><p>자리 올림 전에 지수가 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emin</span></code> 보다 작습니다.</p>
<p>연산 결과가 비정상(지수가 너무 작음)일 때 발생합니다. 트랩 되지 않으면, 결과를 그대로 반환합니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.Underflow">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Underflow</code><a class="headerlink" href="#decimal.Underflow" title="정의 주소">¶</a></dt>
<dd><p>결과가 0으로 자리 올림 되는 수치적 언더플로.</p>
<p>자리 올림에 의해 비정상 결과가 0으로 밀릴 때 발생합니다. <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inexact</span></code></a>와 <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subnormal</span></code></a> 신호도 줍니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.FloatOperation">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">FloatOperation</code><a class="headerlink" href="#decimal.FloatOperation" title="정의 주소">¶</a></dt>
<dd><p>float와 Decimal을 혼합하는 데 더 엄격한 의미를 사용합니다.</p>
<p>신호가 트랩되지 않으면 (기본값), <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 생성자, <a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_decimal()</span></code></a> 및 모든 비교 연산자에서 float와 Decimal을 혼합 할 수 있습니다. 변환과 비교 모두 정확합니다. 복합 연산의 발생은 컨텍스트 플래그에 <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 을 설정하여 조용히 기록됩니다. <a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_float()</span></code></a> 나 <a class="reference internal" href="#decimal.Context.create_decimal_from_float" title="decimal.Context.create_decimal_from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_decimal_from_float()</span></code></a> 를 사용한 명시적 변환은 플래그를 설정하지 않습니다.</p>
<p>그렇지 않으면 (신호가 트랩되면), 같음 비교와 명시적 변환만 조용히 수행됩니다. 다른 모든 혼합된 연산은 <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> 을 발생시킵니다.</p>
</dd></dl>

<p>다음 표는 신호의 계층 구조를 요약한 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">exceptions</span><span class="o">.</span><span class="n">ArithmeticError</span><span class="p">(</span><span class="n">exceptions</span><span class="o">.</span><span class="n">Exception</span><span class="p">)</span>
    <span class="n">DecimalException</span>
        <span class="n">Clamped</span>
        <span class="n">DivisionByZero</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ZeroDivisionError</span><span class="p">)</span>
        <span class="n">Inexact</span>
            <span class="n">Overflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">)</span>
            <span class="n">Underflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">,</span> <span class="n">Subnormal</span><span class="p">)</span>
        <span class="n">InvalidOperation</span>
        <span class="n">Rounded</span>
        <span class="n">Subnormal</span>
        <span class="n">FloatOperation</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TypeError</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="floating-point-notes">
<span id="decimal-notes"></span><h2>부동 소수점 노트<a class="headerlink" href="#floating-point-notes" title="제목 주소">¶</a></h2>
<div class="section" id="mitigating-round-off-error-with-increased-precision">
<h3>증가시킨 정밀도로 자리 올림 오차 줄이기<a class="headerlink" href="#mitigating-round-off-error-with-increased-precision" title="제목 주소">¶</a></h3>
<p>십진 부동 소수점을 사용하면 십진수 표현 오차가 없어집니다 (<code class="xref py py-const docutils literal notranslate"><span class="pre">0.1</span></code>을 정확히 나타낼 수 있습니다); 그러나 0이 아닌 숫자가 고정된 정밀도를 초과할 때 일부 연산은 여전히 자리 올림 오차를 일으킬 수 있습니다.</p>
<p>자리 올림 오차의 효과는 거의 상쇄되는 양을 더하거나 빼는 것에 의해 증폭되어 유효숫자의 손실로 이어질 수 있습니다. Knuth는 불충분한 정밀도로 자리 올림 된 부동 소수점 산술로 인해 덧셈의 결합 법칙과 배분 법칙이 파괴되는 두 가지 사례를 제공합니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># Seminumerical Algorithms, 4.2.2 절에서 인용한 예제.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">getcontext</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">8</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.51111111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="go">Decimal(&#39;9.5111111&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;10&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.0000003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.01&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">Seminumerical Algorithms 는 Knuth 의 The Art of Computer Programming 시리즈의
2권입니다. 번역본도 나와 있습니다.</p>
</div>
<p><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 모듈은 유효숫자의 손실을 피할 수 있을 만큼 정밀도를 확장함으로써 항등 관계를 복구할 수 있게 합니다 :</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.51111111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="go">Decimal(&#39;9.51111111&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;9.51111111&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.0000003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
</pre></div>
</div>
</div>
<div class="section" id="special-values">
<h3>특수 값<a class="headerlink" href="#special-values" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 모듈의 수 체계는 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">sNaN</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">-Infinity</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code>와 두 개의 0 <code class="xref py py-const docutils literal notranslate"><span class="pre">+0</span></code>과 <code class="xref py py-const docutils literal notranslate"><span class="pre">-0</span></code>을 포함하는 특수 값을 제공합니다.</p>
<p>무한대는 다음과 같이 직접 생성될 수 있습니다: <code class="docutils literal notranslate"><span class="pre">Decimal('Infinity')</span></code>. 또한, <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> 신호가 트랩 되지 않을 때 0으로 나눠서 발생할 수 있습니다. 마찬가지로, <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Overflow</span></code></a> 신호가 트랩 되지 않을 때, 무한대는 표현 가능한 가장 큰 수의 한계를 넘어서 자리 올림 된 결과가 될 수 있습니다.</p>
<p>무한대는 부호가 있고 (아핀) 산술 연산에 사용될 수 있는데, 매우 크고 불확정적(indeterminate)인 숫자로 취급됩니다. 예를 들어, 무한대에 상수를 더하면 또 다른 무한대를 줍니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">수 체계에서 무한대를 표현하는 두 가지 방법이 있습니다. 하나는 사영 무한(projective infinity)이라는
것으로, 무한대를 부호가 없는 (+가 아니라 아예 부호라는 것이 없는) 것으로 보고 아주 큰 수와 아주 작은 수
모두 하나의 무한대로 표현합니다. 이에 반해 아핀 무한(affine innfinity)이라는 것은 무한대를 부호가
있는 값으로 보고, 아주 큰 수와 아주 작은 수를 두 개의 무한대 (<code class="xref py py-const docutils literal notranslate"><span class="pre">-Infinity</span></code>,
<code class="xref py py-const docutils literal notranslate"><span class="pre">Infinity</span></code>) 로 따로 표현합니다. <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 모듈이 따르고 있는 명세는 아핀 무한을
사용합니다.</p>
</div>
<p>어떤 연산은 불확정적이고, <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 을 반환하거나, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> 신호가 트랩 되면, 예외를 발생시킵니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">0/0</span></code> 은 &quot;숫자가 아님(not a number)&quot;을 의미하는 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 을 반환합니다. 이 종류의 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 은 조용하고, 한 번 만들어지면 다른 연산에 포함될 때 항상 다른 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 을 생성합니다. 이 동작은 때때로 빠진 입력이 있는 일련의 계산에 유용할 수 있습니다 --- 특정 결과를 잘못된 것으로 표시하면서 계산을 진행할 수 있도록 합니다.</p>
<p>다른 종류는 <code class="xref py py-const docutils literal notranslate"><span class="pre">sNaN</span></code> 인데, 모든 연산 후에 조용히 남아 있는 대신 신호를 줍니다. 이것은 유효하지 않은 결과가 특수한 처리를 위해 계산을 중단시켜야 할 때 유용한 반환 값입니다.</p>
<p>파이썬의 비교 연산자의 동작은 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 이 관련되어있을 때 약간 의외일 수 있습니다. 피연산자 중 하나가 조용하거나 신호를 주는 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 일 때, 같음 검사는 항상 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환하고 (심지어 <code class="docutils literal notranslate"><span class="pre">Decimal('NaN')==Decimal('NaN')</span></code> 조차도), 다름 검사는 항상 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다. <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 연산자 중 하나를 사용하여 두 Decimal을 비교하려는 시도는 피연산자 중 어느 것이 든 <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 이면 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> 신호를 발생시킵니다. 이 신호가 트랩 되지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다. 일반 십진 산술 명세는 직접 비교의 동작을 명시하지 않습니다; <code class="xref py py-const docutils literal notranslate"><span class="pre">NaN</span></code> 을 포함하는 비교를 위한 이러한 규칙은 IEEE 854 표준(섹션 5.7의 표 3을 보세요)에서 가져온 것입니다. 엄격한 표준 준수를 위해서는, 대신 <code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code> 및 <code class="xref py py-meth docutils literal notranslate"><span class="pre">compare-signal()</span></code> 메서드를 사용하십시오.</p>
<p>부호 있는 0은 언더플로 하는 계산의 결과일 수 있습니다. 계산을 더 정밀하게 수행한다면 얻게 될 결과의 기호를 유지합니다. 크기가 0이기 때문에, 양과 음의 0은 같다고 취급되며 부호는 정보 용입니다.</p>
<p>서로 다른 부호를 갖는 부호 있는 0이 같은 것에 더해, 여전히 동등한 값이지만 다른 정밀도를 갖는 여러 표현이 존재합니다. 익숙해지는데 약간 시간이 필요합니다. 정규화된 부동 소수점 표현에 익숙한 사람들에게는, 다음 계산이 0과 같은 값을 반환한다는 것이 즉시 명백하지는 않습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;Infinity&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;0E-1000026&#39;)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="working-with-threads">
<span id="decimal-threads"></span><h2>스레드로 작업하기<a class="headerlink" href="#working-with-threads" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 함수는 스레드마다 다른 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 객체에 접근합니다. 별도의 스레드 컨텍스트를 갖는다는 것은 스레드가 다른 스레드를 방해하지 않고 변경할 수 있음을 의미합니다 (가령 <code class="docutils literal notranslate"><span class="pre">getcontext().prec=10</span></code>).</p>
<p>마찬가지로, <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> 함수는 자동으로 대상을 현재 스레드에 할당합니다.</p>
<p><a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> 가 <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 전에 호출되지 않았다면, <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 는 현재 스레드에서 사용할 새로운 컨텍스트를 자동으로 생성합니다.</p>
<p>새 컨텍스트는 <em>DefaultContext</em> 라는 프로토타입 컨텍스트에서 복사됩니다. 각 스레드가 응용 프로그램 전체에서 같은 값을 사용하도록 기본값을 제어하려면, <em>DefaultContext</em> 객체를 직접 수정하십시오. <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> 를 호출하는 스레드 사이에 경쟁 조건이 없도록, 어떤 스레드가 시작되기 <em>전에</em> 수행되어야 합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 시작될 모든 스레드에 대해 응용 프로그램 전체 기본값을 설정합니다</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_DOWN</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span> <span class="o">=</span> <span class="n">ExtendedContext</span><span class="o">.</span><span class="n">traps</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">InvalidOperation</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">setcontext</span><span class="p">(</span><span class="n">DefaultContext</span><span class="p">)</span>

<span class="c1"># 그런 다음, 스레드를 시작할 수 있습니다</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t3</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
 <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="recipes">
<span id="decimal-recipes"></span><h2>조리법<a class="headerlink" href="#recipes" title="제목 주소">¶</a></h2>
<p>다음은 유틸리티 함수로 사용되고 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 클래스로 작업하는 방법을 보여주는 몇 가지 조리법입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">moneyfmt</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">curr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span>
             <span class="n">pos</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">trailneg</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decimal을 화폐 형식 문자열로 변환합니다.</span>

<span class="sd">    places:  필수적, 소수점 뒤로 필요한 자릿수</span>
<span class="sd">    curr:    선택적, 부호 앞에 오는 통화 기호 (비어있어도 됩니다)</span>
<span class="sd">    sep:     선택적, 자리수 구분자 (콤마, 마침표, 스페이스, 또는 빈문자열)</span>
<span class="sd">    dp:      소수점 (콤마나 마침표)</span>
<span class="sd">             places 가 0 일 때만 빈문자열로 지정하세요</span>
<span class="sd">    pos:     선택적, 양수를 위한 부호: &#39;+&#39;, 스페이스 또는 빈문자열</span>
<span class="sd">    neg:     선택적, 음수를 위한 부호: &#39;-&#39;, &#39;(&#39;, 스페이스 또는 빈문자열</span>
<span class="sd">    trailneg:선택적, 후행 음수 표시:  &#39;-&#39;, &#39;)&#39;, 스페이스 또는 빈문자열</span>

<span class="sd">    &gt;&gt;&gt; d = Decimal(&#39;-1234567.8901&#39;)</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;)</span>
<span class="sd">    &#39;-$1,234,567.89&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, places=0, sep=&#39;.&#39;, dp=&#39;&#39;, neg=&#39;&#39;, trailneg=&#39;-&#39;)</span>
<span class="sd">    &#39;1.234.568-&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;, neg=&#39;(&#39;, trailneg=&#39;)&#39;)</span>
<span class="sd">    &#39;($1,234,567.89)&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(123456789), sep=&#39; &#39;)</span>
<span class="sd">    &#39;123 456 789.00&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(&#39;-0.02&#39;), neg=&#39;&lt;&#39;, trailneg=&#39;&gt;&#39;)</span>
<span class="sd">    &#39;&lt;0.02&gt;&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="n">places</span>      <span class="c1"># 2 places --&gt; &#39;0.01&#39;</span>
    <span class="n">sign</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">as_tuple</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">digits</span><span class="p">))</span>
    <span class="n">build</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">pop</span>
    <span class="k">if</span> <span class="n">sign</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">trailneg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">places</span><span class="p">):</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">()</span> <span class="k">if</span> <span class="n">digits</span> <span class="k">else</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">places</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">digits</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">build</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">neg</span> <span class="k">if</span> <span class="n">sign</span> <span class="k">else</span> <span class="n">pos</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">pi</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;현재 정밀도로 Pi 를 계산합니다.</span>

<span class="sd">    &gt;&gt;&gt; print(pi())</span>
<span class="sd">    3.141592653589793238462643383</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># 중단 단계를 위한 추가의 유효숫자</span>
    <span class="n">three</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>      <span class="c1"># 일반 float 에 사용하려면 &quot;three=3.0&quot; 로 치환하세요</span>
    <span class="n">lasts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">three</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">24</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">na</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="n">na</span><span class="p">,</span> <span class="n">na</span><span class="o">+</span><span class="mi">8</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="n">d</span><span class="o">+</span><span class="n">da</span><span class="p">,</span> <span class="n">da</span><span class="o">+</span><span class="mi">32</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>               <span class="c1"># 단항 플러스 연산자는 새 정밀도를 적용합니다</span>

<span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;e 의 x 제곱을 반환합니다.  결과 형은 입력 형과 일치합니다.</span>

<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(1)))</span>
<span class="sd">    2.718281828459045235360287471</span>
<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(2)))</span>
<span class="sd">    7.389056098930650227230427461</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2.0))</span>
<span class="sd">    7.38905609893</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2+0j))</span>
<span class="sd">    (7.38905609893+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;라디안으로 측정된 x 의 코사인(cosine)을 반환합니다.</span>

<span class="sd">    테일러 전개 근사법은 x 가 작음 값을 때 잘 작동합니다.</span>
<span class="sd">    큰 값의 경우, 먼저 x = x % (2 * pi) 를 계산하세요.</span>

<span class="sd">    &gt;&gt;&gt; print(cos(Decimal(&#39;0.5&#39;)))</span>
<span class="sd">    0.8775825618903727161162815826</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5))</span>
<span class="sd">    0.87758256189</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5+0j))</span>
<span class="sd">    (0.87758256189+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;라디안으로 측정된 x 의 사인(sine)을 반환합니다.</span>

<span class="sd">    테일러 전개 근사법은 x 가 작음 값을 때 잘 작동합니다.</span>
<span class="sd">    큰 값의 경우, 먼저 x = x % (2 * pi) 를 계산하세요.</span>

<span class="sd">    &gt;&gt;&gt; print(sin(Decimal(&#39;0.5&#39;)))</span>
<span class="sd">    0.4794255386042030002732879352</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5))</span>
<span class="sd">    0.479425538604</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5+0j))</span>
<span class="sd">    (0.479425538604+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>
</pre></div>
</div>
</div>
<div class="section" id="decimal-faq">
<span id="id1"></span><h2>Decimal FAQ<a class="headerlink" href="#decimal-faq" title="제목 주소">¶</a></h2>
<p>Q. <code class="docutils literal notranslate"><span class="pre">decimal.Decimal('1234.5')</span></code> 라고 입력하는 것은 귀찮은 일입니다. 대화형 인터프리터를 사용할 때 타자를 최소화할 방법이 있습니까?</p>
<p>A. 일부 사용자는 생성자를 하나의 문자로 축약합니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">(</span><span class="s1">&#39;1.23&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">D</span><span class="p">(</span><span class="s1">&#39;3.45&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.68&#39;)</span>
</pre></div>
</div>
<p>Q. 소수점 두 자리의 고정 소수점 응용 프로그램에서, 일부 입력에 여러 자리가 있고 자리 올림 해야 합니다. 어떤 것은 여분의 자릿수가 없다고 가정되지만, 유효성 검사가 필요합니다. 어떤 방법을 사용해야 합니까?</p>
<p>A. <code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code> 메서드는 고정된 소수 자릿수로 자리 올림 합니다. <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> 트랩이 설정되면, 유효성 검사에도 유용합니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">TWOPLACES</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>       <span class="c1"># Decimal(&#39;0.01&#39;) 과 같습니다</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># 두 자리로 자리 올림합니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.214&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.21&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># 숫자가 두 자리를 넘지 않는지 확인합니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.21&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="go">Decimal(&#39;3.21&#39;)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.214&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<p>Q. 일단 유효한 두 자리 입력이 있으면, 응용 프로그램 전체에서 해당 불변성을 어떻게 유지합니까?</p>
<p>A. 정수로 더하기, 빼기 및 곱하기와 같은 일부 연산은 고정 소수점을 자동으로 보존합니다. 나눗셈과 정수가 아닌 수로 곱하는 것과 같은 다른 연산은, 소수점 이하 자릿수를 바꿀 것이고, 뒤에 <code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code> 단계를 적용할 필요가 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;102.72&#39;</span><span class="p">)</span>           <span class="c1"># 초기 고정 소수점 값</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.17&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>                           <span class="c1"># 덧셈은 고정 소수점을 보존합니다</span>
<span class="go">Decimal(&#39;105.89&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
<span class="go">Decimal(&#39;99.55&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">42</span>                          <span class="c1"># 정수로 곱하는 것도 마찬가지입니다</span>
<span class="go">Decimal(&#39;4314.24&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># 정수가 아닌 수로 곱할 때는 quantize 해야만 합니다</span>
<span class="go">Decimal(&#39;325.62&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># 나눗셈도 quantize 해야 합니다</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
</pre></div>
</div>
<p>고정 소수점 응용 프로그램을 개발할 때, <code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code> 단계를 처리하는 함수를 정의하는 것이 편리합니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>                       <span class="c1"># 자동적으로 고정 소수점을 보존합니다</span>
<span class="go">Decimal(&#39;325.62&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">div</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
</pre></div>
</div>
<p>Q. 같은 값을 표현하는 여러 가지 방법이 있습니다. 숫자 <code class="xref py py-const docutils literal notranslate"><span class="pre">200</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">200.000</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">2E2</span></code>, 그리고 <code class="xref py py-const docutils literal notranslate"><span class="pre">02E+4</span></code> 는 모두 다양한 정밀도로 같은 값을 가집니다. 이것들은 단일하게 인식할 수 있는 표준적인 값으로 변환할 방법이 있습니까?</p>
<p>A. the <code class="xref py py-meth docutils literal notranslate"><span class="pre">normalize()</span></code> 메서드는 모든 해당 값을 단일 표현으로 매핑합니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">&#39;200 200.000 2E2 .02E+4&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
<span class="go">[Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;)]</span>
</pre></div>
</div>
<p>Q. 일부 십진수 값은 항상 지수 표기법으로 인쇄됩니다. 지수가 아닌 표현을 얻을 방법이 있습니까?</p>
<p>A. 일부 값의 경우, 지수 표기법만이 계수에 있는 유효 숫자를 나타낼 수 있습니다. 예를 들어 <code class="xref py py-const docutils literal notranslate"><span class="pre">5.0E+3</span></code>을 <code class="xref py py-const docutils literal notranslate"><span class="pre">5000</span></code>으로 표현하면 값은 일정하게 유지되지만, 원본의 두 자리 유효숫자를 표시할 수 없습니다.</p>
<p>응용 프로그램이 유효 숫자를 추적하는 데 신경 쓰지 않으면, 지수 및 후행 0을 제거하고 유효숫자를 잃지만, 값이 바뀌지 않도록 하기는 쉽습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">remove_exponent</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">to_integral</span><span class="p">()</span> <span class="k">else</span> <span class="n">d</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">remove_exponent</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;5E+3&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;5000&#39;)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">remove_exponent</span></code> 가 언제나 지수 표기법을 사용하지 않는 것은 아닙니다.</p>
</div>
<p>Q. 일반 float를 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>로 변환하는 방법이 있습니까?</p>
<p>A. 그렇습니다. 모든 이진 부동 소수점은 Decimal로 정확히 표현될 수 있습니다. 하지만 정확한 변환이 취하는 정밀도는 직관이 제안하는 것보다 더 클 수 있습니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.141592653589793115997963468544185161590576171875&#39;)</span>
</pre></div>
</div>
<p>Q. 복잡한 계산에서, 정밀도가 부족하거나 자리 올림 이상이 발생하여 엉터리 결과를 얻지는 않았는지 확인하려면 어떻게 해야 합니까?</p>
<p>A. decimal 모듈은 결과를 쉽게 테스트할 수 있게 합니다. 가장 좋은 방법은 더 높은 정밀도와 다양한 자리 올림 모드를 사용하여 계산을 다시 실행하는 것입니다. 크게 다른 결과는 정밀도 부족, 자리 올림 모드 문제, 부적절한 입력 또는 수치가 불안정한 알고리즘을 나타냅니다.</p>
<p>컨텍스트 정밀도가 입력이 아닌 연산 결과에 적용된다는 사실을 확인했습니다. 다른 정밀도의 값을 혼합할 때 주의해야 할 것이 있습니까?</p>
<p>A. 그렇습니다. 원칙은 모든 값이 정확한 것으로 간주하므로 해당 값에 대한 산술도 마찬가지라는 것입니다. 결과 만 자리 올림 됩니다. 입력에 대한 이점은 &quot;입력하는 것이 얻는 것&quot;이라는 것입니다. 단점은 입력값을 자리 올림 하는 것을 잊어버리면 결과가 이상하게 보일 수 있다는 점입니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.104&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.104&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.21&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.104&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.000&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.104&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.20&#39;)</span>
</pre></div>
</div>
<p>해법은 정밀도를 높이거나 단항 플러스 연산을 사용하여 입력의 자리 올림을 강제 수행하는 것입니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">+</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.23456789&#39;</span><span class="p">)</span>      <span class="c1"># 단항 플러스는 자리 올림을 일으킵니다</span>
<span class="go">Decimal(&#39;1.23&#39;)</span>
</pre></div>
</div>
<p>다른 방법으로, 입력은 <a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.create_decimal()</span></code></a> 메서드를 사용하여 생성 시에 자리 올림 될 수 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">&#39;1.2345678&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.2345&#39;)</span>
</pre></div>
</div>
<p>Q. Is the CPython implementation fast for large numbers?</p>
<p>A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of
the decimal module integrate the high speed <a class="reference external" href="https://www.bytereef.org/mpdecimal/doc/libmpdec/index.html">libmpdec</a> library for
arbitrary precision correctly-rounded decimal floating point arithmetic.
<code class="docutils literal notranslate"><span class="pre">libmpdec</span></code> uses <a class="reference external" href="https://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba multiplication</a>
for medium-sized numbers and the <a class="reference external" href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general)#Number-theoretic_transform">Number Theoretic Transform</a>
for very large numbers.  However, to realize this performance gain, the
context needs to be set for unrounded calculations.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">getcontext</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="n">MAX_PREC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">Emax</span> <span class="o">=</span> <span class="n">MAX_EMAX</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">Emin</span> <span class="o">=</span> <span class="n">MIN_EMIN</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">decimal</span></code> --- 십진 고정 소수점 및 부동 소수점 산술</a><ul>
<li><a class="reference internal" href="#quick-start-tutorial">빠른 시작 자습서</a></li>
<li><a class="reference internal" href="#decimal-objects">Decimal 객체</a><ul>
<li><a class="reference internal" href="#logical-operands">논리적 피연산자</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-objects">Context 객체</a></li>
<li><a class="reference internal" href="#constants">상수</a></li>
<li><a class="reference internal" href="#rounding-modes">자리 올림 모드</a></li>
<li><a class="reference internal" href="#signals">신호</a></li>
<li><a class="reference internal" href="#floating-point-notes">부동 소수점 노트</a><ul>
<li><a class="reference internal" href="#mitigating-round-off-error-with-increased-precision">증가시킨 정밀도로 자리 올림 오차 줄이기</a></li>
<li><a class="reference internal" href="#special-values">특수 값</a></li>
</ul>
</li>
<li><a class="reference internal" href="#working-with-threads">스레드로 작업하기</a></li>
<li><a class="reference internal" href="#recipes">조리법</a></li>
<li><a class="reference internal" href="#decimal-faq">Decimal FAQ</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="cmath.html"
                        title="이전 장"><code class="docutils literal notranslate"><span class="pre">cmath</span></code> --- Mathematical functions for complex numbers</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="fractions.html"
                        title="다음 장"><code class="docutils literal notranslate"><span class="pre">fractions</span></code> --- 유리수</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="fractions.html" title="fractions --- 유리수"
             >다음</a> |</li>
        <li class="right" >
          <a href="cmath.html" title="cmath --- Mathematical functions for complex numbers"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="numeric.html" >숫자와 수학 모듈</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1 를 사용해서 만들었습니다.
    </div>

  </body>
</html>