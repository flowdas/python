
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>9.4. decimal --- 십진 고정 소수점 및 부동 소수점 산술 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="9.5. fractions --- Rational numbers" href="fractions.html" />
    <link rel="prev" title="9.3. cmath --- Mathematical functions for complex numbers" href="cmath.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/library/decimal.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="fractions.html" title="9.5. fractions --- Rational numbers"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="cmath.html" title="9.3. cmath --- Mathematical functions for complex numbers"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="numeric.html" accesskey="U">9. 숫자와 수학 모듈</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-decimal">
<span id="decimal-decimal-fixed-point-and-floating-point-arithmetic"></span><h1>9.4. <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> --- 십진 고정 소수점 및 부동 소수점 산술<a class="headerlink" href="#module-decimal" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/decimal.py">Lib/decimal.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> 모듈은 빠르고 정확하게 자리 올림하는 십진 부동 소수 산술을 지원합니다. <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 데이터 형에 비해 다음과 같은 몇 가지 장점을 제공합니다:</p>
<ul>
<li><p class="first">Decimal &quot;은 사람을 염두에 두고 설계된 부동 소수점 모델에 기반하고, 필연적으로 최고 원리를 갖습니다 -- 컴퓨터는 사람들이 학교에서 배우는 산술과 같은 방식으로 동작하는 산술을 반드시 제공해야한다.&quot; -- 십진 산술 명세에서 발췌.</p>
</li>
<li><p class="first">Decimal 수는 정확하게 표현할 수 있습니다. 반면에, <code class="xref py py-const docutils literal"><span class="pre">1.1</span></code> 과 <code class="xref py py-const docutils literal"><span class="pre">2.2</span></code> 와 같은 수는 이진 부동 소수점으로 정확히 표현할 수 없습니다. 최종 사용자는 일반적으로 이진 부동 소수점에서 그러하듯이 <code class="docutils literal"><span class="pre">1.1</span> <span class="pre">+</span> <span class="pre">2.2</span></code> 가 <code class="xref py py-const docutils literal"><span class="pre">3.3000000000000003</span></code> 처럼 표시되는 것을 기대하지 않을 것입니다.</p>
</li>
<li><p class="first">정확성은 산술에서도 유지됩니다. 십진 부동 소수점에서, <code class="docutils literal"><span class="pre">0.1</span> <span class="pre">+</span> <span class="pre">0.1</span> <span class="pre">+</span> <span class="pre">0.1</span> <span class="pre">-</span> <span class="pre">0.3</span></code> 는 정확하게 0과 같습니다. 이진 부동 소수점에서, 결과는 <code class="xref py py-const docutils literal"><span class="pre">5.5511151231257827e-017</span></code> 입니다. 0에 가깝지만 차이점은 신뢰할 수 있는 동등성 검사를 방해하고, 차이는 누적 될 수 있습니다. 이러한 이유로, 강한 동등성 불변 조건을 갖는 회계 응용 프로그램에서는 decimal이 선호됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">십진 소수를 유지하기 때문에, 진법 변환으로 인한 부정확함이 없다는 뜻이지, 산술의 결과를 항상
정확하게 유지할 수 있다는 뜻이 아닙니다. 가령 나눗셈이 수반되면 무한 소수가 만들어질 수 있는데,
Decimal 은 무한 소수를 정확하게 표현하지 못합니다. Decimal 은 항상 유한한 정밀도를 유지하고,
자리올림을 통해 무한 소수의 근사값을 취합니다.</p>
</div>
</li>
<li><p class="first">decimal 모듈은 유효 자릿수의 개념을 포함하고 있으므로 <code class="docutils literal"><span class="pre">1.30</span> <span class="pre">+</span> <span class="pre">1.20</span></code> 은 <code class="xref py py-const docutils literal"><span class="pre">2.50</span></code> 입니다. 후행 0은 유효성을 나타 내기 위해 유지됩니다. 이것은 화폐 응용에서는 관례적인 표현입니다. 곱셈의 경우, &quot;교과서&quot; 접근법은 피승수의 모든 숫자를 사용합니다. 예를 들어 <code class="docutils literal"><span class="pre">1.3</span> <span class="pre">*</span> <span class="pre">1.2</span></code> 는 <code class="xref py py-const docutils literal"><span class="pre">1.56</span></code> 이고, <code class="docutils literal"><span class="pre">1.30</span> <span class="pre">*</span> <span class="pre">1.20</span></code> 은 <code class="xref py py-const docutils literal"><span class="pre">1.5600</span></code> 입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">예전에는 (요즘은 없어졌을 가능성이 높습니다. 중3에게 물어보니 들어본적이 없다네요) 중등 교과 과정에
&quot;유효 숫자&quot; 라는 개념이 포함되어 있었습니다.
유효 숫자는 숫자의 불확실성에 관한 것인데, 주로 실험적으로 어떤 숫자를 얻을 때 쓸모있는 개념입니다.
가령 눈금자로 길이를 측정할 때 보통 마지막 눈금을 쪼개서 읽을겁니다. 가령 <code class="docutils literal"><span class="pre">1.25</span></code> cm. 그런데
정확히 눈금과 일치할 때는 <code class="docutils literal"><span class="pre">1.20</span></code> 이라고 읽을 것입니다. 이 때 <code class="docutils literal"><span class="pre">1.2</span></code> 와 <code class="docutils literal"><span class="pre">1.20</span></code> 은
다르며 끝의 <code class="docutils literal"><span class="pre">0</span></code> 은 한 수준 높은 정밀도를 표현합니다. 디지털 저울을 읽을 때도 마찬가지 입니다.
소수점 한자리까지 표시하는 저울과 두자리까지 표시하는 저울은 그 정밀도가 다릅니다.</p>
</div>
</li>
<li><p class="first">하드웨어 기반 이진 부동 소수점과는 달리, decimal 모듈은 사용자가 변경할 수있는 정밀도(기본값은 28 자리)를 가지며, 주어진 문제에 따라 필요한만큼 커질 수 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1428571428571428571428571429&#39;)</span>
</pre></div>
</div>
</li>
<li><p class="first">이진 및 십진 부동 소수점 모두 출판된 표준에 따라 구현됩니다. 내장 float 형이 기능의 적당한 부분만을 드러내는 반면, decimal 모듈은 표준의 모든 필수 부분을 노출합니다. 필요한 경우, 프로그래머는 자리 올림(rounding) 및 신호(signal) 처리를 완전히 제어 할 수 있습니다. 여기에는 정확하지 않은 연산을 차단하기 위한 예외를 사용하여 정확한 산술을 강제하는 옵션이 포함됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">rounding 을 흔히 쓰는 &quot;빈올림&quot; 대신 &quot;자리올림&quot; 이라고 번역합니다. decimal 에서 지원하는 rounding
은 8가지인데, 이중 일부만 &quot;빈올림&quot;에 해당하기 때문입니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">signal 은 <a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal"><span class="pre">signal</span></code></a> 모듈의 시그널과 구분하기위해 &quot;신호&quot; 라고 번역합니다. 하지만 두 signal 이
아주 관계 없는 것은 아닙니다. 부동 소수점 산술은 하드웨어 구현을 염두에 두고 있는 것이고, 실제로
float 형을 통해 제공되고 있는 이진 부동 소수점은 대부분의 플랫폼에서 하드웨어에 기반합니다. 하드웨어에서
지원되는 경우 이진 부동 소수점 신호가 <code class="docutils literal"><span class="pre">SIGFPE</span></code> 시그널을 통하는 경우가 있습니다. 예전에는 <code class="docutils literal"><span class="pre">fpectl</span></code>
이라는 모듈을 통해 제한적으로나마 제어할 수 있는 방법을 제공했지만, 사실상 아무도 쓰지 않기 때문에
파이썬 3.7 에서는 아예 제거되었습니다.</p>
</div>
</li>
<li><p class="first">decimal 모듈은 &quot;편견없이, (때로 고정 소수점 산술 이라고도 불리는) 정확한 자리 올림없는 십진 산술과 자리 올림있는 부동 소수점 산술을 모두&quot; 지원하도록 설계되었습니다. -- 십진 산술 명세에서 발췌.</p>
</li>
</ul>
<p>모듈 설계의 중심 개념은 세 가지입니다: 십진수, 산술을 위한 컨텍스트, 신호(signal).</p>
<p>decimal 수는 불변입니다. 부호(sign), 계수(coefficient digits) 및 지수(exponent)로 구성됩니다. 유효성을 유지하기 위해, 계수는 후행 0을 자르지 않습니다. Decimal은 또한 <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code>, <code class="xref py py-const docutils literal"><span class="pre">-Infinity</span></code>, <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> 과 같은 특별한 값을 포함합니다. 표준은 또한 <code class="xref py py-const docutils literal"><span class="pre">-0</span></code> 을 <code class="xref py py-const docutils literal"><span class="pre">+0</span></code> 과 구별합니다.</p>
<p>산술 컨텍스트는 정밀도, 자리 올림 규칙, 지수에 대한 제한, 연산 결과를 나타내는 플래그 및 신호가 예외로 처리될지를 결정하는 트랩 활성화기(trap enabler)를 지정하는 환경입니다. 자리 올림 옵션에는 <a class="reference internal" href="#decimal.ROUND_CEILING" title="decimal.ROUND_CEILING"><code class="xref py py-const docutils literal"><span class="pre">ROUND_CEILING</span></code></a>, <a class="reference internal" href="#decimal.ROUND_DOWN" title="decimal.ROUND_DOWN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_DOWN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_FLOOR" title="decimal.ROUND_FLOOR"><code class="xref py py-const docutils literal"><span class="pre">ROUND_FLOOR</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_DOWN" title="decimal.ROUND_HALF_DOWN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_DOWN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_UP</span></code></a>, <a class="reference internal" href="#decimal.ROUND_UP" title="decimal.ROUND_UP"><code class="xref py py-const docutils literal"><span class="pre">ROUND_UP</span></code></a> 및 <a class="reference internal" href="#decimal.ROUND_05UP" title="decimal.ROUND_05UP"><code class="xref py py-const docutils literal"><span class="pre">ROUND_05UP</span></code></a> 가 있습니다.</p>
<p>신호는 계산 과정에서 발생하는 예외적인 조건의 그룹입니다. 응용 프로그램의 필요에 따라, 신호가 무시되거나, 정보로 간주되거나, 예외로 처리 될 수 있습니다. decimal 모듈의 신호는 <a class="reference internal" href="#decimal.Clamped" title="decimal.Clamped"><code class="xref py py-const docutils literal"><span class="pre">Clamped</span></code></a>, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal"><span class="pre">InvalidOperation</span></code></a>, <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal"><span class="pre">DivisionByZero</span></code></a>, <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a>, <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal"><span class="pre">Rounded</span></code></a>, <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal"><span class="pre">Subnormal</span></code></a>, <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-const docutils literal"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="#decimal.Underflow" title="decimal.Underflow"><code class="xref py py-const docutils literal"><span class="pre">Underflow</span></code></a>, <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-const docutils literal"><span class="pre">FloatOperation</span></code></a> 입니다.</p>
<p>각 신호에는 플래그와 트랩 활성화기가 있습니다. 신호와 만났을 때, 플래그가 1로 설정되고 트랩 활성화기가 1로 설정된 경우, 예외가 발생합니다. 플래그는 상태가 유지되므로(sticky) 계산을 모니터링하기 전에 재설정할 필요가 있습니다.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<ul class="last simple">
<li>IBM의 일반 십진 산술 명세, <a class="reference external" href="http://speleotrove.com/decimal/decarith.html">The General Decimal Arithmetic Specification</a>.</li>
</ul>
</div>
<div class="section" id="quick-start-tutorial">
<span id="decimal-tutorial"></span><h2>9.4.1. 빠른 시작 자습서<a class="headerlink" href="#quick-start-tutorial" title="제목 주소">¶</a></h2>
<p>decimal을 사용하는 일반적인 시작은 모듈을 임포트하고, <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a> 로 현재 컨텍스트를 보고, 필요하다면 정밀도, 자리 올림 또는 활성화된 트랩에 대해 새 값을 설정하는 것입니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,</span>
<span class="go">        InvalidOperation])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">7</span>       <span class="c1"># 새 정밀도를 설정합니다</span>
</pre></div>
</div>
<p>Decimal 인스턴스는 정수, 문자열, 실수(float)또는 튜플로 만들 수 있습니다. 정수 나 실수로 만들면 해당 정수 또는 실수의 정확한 값 변환이 일어납니다. Decimal 수는 &quot;숫자가 아님(Not a number)&quot; 을 나타내는 <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>, 양과 음의 <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code> 및 <code class="xref py py-const docutils literal"><span class="pre">-0</span></code> 과 같은 특수한 값을 포함합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">Decimal(&#39;10&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.14&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.14&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.140000000000000124344978758017532527446746826171875&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Decimal(&#39;3.14&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="go">Decimal(&#39;1.4142135623730951&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.5&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.414213562373095048801688724&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;NaN&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-Infinity&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;-Infinity&#39;)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal"><span class="pre">FloatOperation</span></code></a> 신호를 트랩하는 경우, 실수로 생성자나 대소비교에서 Decimal 수와 실수(float)를 혼합하면 예외가 발생합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">getcontext</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">FloatOperation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class &#39;decimal.FloatOperation&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.5&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">3.7</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class &#39;decimal.FloatOperation&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.5&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mf">3.5</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">예제 코드의 마지막에서 볼 수 있듯이, 동등 비교는 예외를 일으키지 않습니다.
또한 3.5 는 이진 부동 소수점으로 정확히 표현할 수 있는 수이기 때문에 비교 결과가 <code class="docutils literal"><span class="pre">True</span></code> 입니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">float 가 조용히 Decimal 로 변환되도록하면, float 값으로 이미 정확하지 않은 값이 들어갔을 가능성이
크기 때문에, Decimal 이 제공하는 정확한 산술이 의미가 없어질 수 있습니다. 이 때문에 정확한 산술이
중요한 응용에서는 <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal"><span class="pre">FloatOperation</span></code></a> 신호를 트랩해서 실수로라도 그런일이 일어나는 것을
막습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
<p>새로운 Decimal의 유효 숫자는 입력 된 숫자의 개수에 의해서만 결정됩니다. 컨텍스트 정밀도 및 자리 올림은 오직 산술 연산 중에만 작용합니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.0&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.1415926535&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.7182818285&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.85987&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_UP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.7182818285&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.85988&#39;)</span>
</pre></div>
</div>
<p>C 버전의 내부 제한을 초과하면, Decimal 을 만들 때 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal"><span class="pre">InvalidOperation</span></code></a> 를 일으킵니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1e9999999999999999999&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.InvalidOperation</span>: <span class="n">[&lt;class &#39;decimal.InvalidOperation&#39;&gt;]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경.</span></p>
</div>
<p>Decimal은 파이썬의 다른 부분들과 잘 어울립니다. 다음은 십진 부동 소수점으로 부린 작은 묘기입니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">&#39;1.34 1.87 3.45 2.35 1.00 0.03 9.25&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;9.25&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">[Decimal(&#39;0.03&#39;), Decimal(&#39;1.00&#39;), Decimal(&#39;1.34&#39;), Decimal(&#39;1.87&#39;),</span>
<span class="go"> Decimal(&#39;2.35&#39;), Decimal(&#39;3.45&#39;), Decimal(&#39;9.25&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;19.29&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;1.34&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.3&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">5</span>
<span class="go">Decimal(&#39;6.70&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="go">Decimal(&#39;2.5058&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">%</span> <span class="n">a</span>
<span class="go">Decimal(&#39;0.77&#39;)</span>
</pre></div>
</div>
<p>그리고 Decimal에는 몇 가지 수학 함수도 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
<span class="go">Decimal(&#39;1.414213562373095048801688724&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.718281828459045235360287471&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ln</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.302585092994045684017991455&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">log10</span><span class="p">()</span>
<span class="go">Decimal(&#39;1&#39;)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><a class="reference internal" href="math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal"><span class="pre">math</span></code></a> 모듈의 수학 함수들에 Decimal 을 제공해도 됩니다. 다만 <a class="reference internal" href="math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal"><span class="pre">math</span></code></a> 모듈의 함수들은
float 로 변환한 값으로 계산한 후 float 값을 돌려줍니다.</p>
</div>
<p><code class="xref py py-meth docutils literal"><span class="pre">quantize()</span></code> 메서드는 숫자를 고정 된 지수로 자리 올림합니다. 이 방법은 종종 결과를 고정 된 자리수로 자리 올림하는 화폐 응용에 유용합니다.:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.325&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;.01&#39;</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="go">Decimal(&#39;7.32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.325&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.&#39;</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_UP</span><span class="p">)</span>
<span class="go">Decimal(&#39;8&#39;)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">여기서 &quot;고정된 지수로 자리올림&quot; 한다는 뜻은, 계수부를 정수로 만들때의 지수부가 지정한 값이 되도록
만든다는 뜻입니다. 때문에 소수점 밑의 자리수를 맞추는 결과를 줍니다.
첫번째 예에서, <code class="docutils literal"><span class="pre">Decimal('.01')</span></code> 은 <code class="docutils literal"><span class="pre">Decimal(1e-2)</span></code> 와 같아서 지수가 <code class="docutils literal"><span class="pre">-2</span></code> 입니다. 따라서
<code class="docutils literal"><span class="pre">Decimal('732e-2')</span></code> 가 되도록 자리올림합니다. (실제로는 <code class="docutils literal"><span class="pre">ROUND_DOWN</span></code> 이라서 내림합니다.)
두번째 예에서, <code class="docutils literal"><span class="pre">Decimal('1.')</span></code> 는 <code class="docutils literal"><span class="pre">Decimal('1e0')</span></code> 이고, 지수가 <code class="docutils literal"><span class="pre">0</span></code> 이므로
<code class="docutils literal"><span class="pre">Decimal('8e0')</span></code> 으로 올림(ROUND_UP)합니다.</p>
</div>
<p>위에서 보듯이, <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a> 함수는 현재 컨텍스트에 액세스하고 설정을 변경할 수 있게 합니다. 이 방법은 대부분 응용 프로그램의 요구를 충족시킵니다.</p>
<p>고급 작업을 위해, Context() 생성자를 사용하여 대체 컨텍스트를 만드는 것이 유용 할 수 있습니다. 대체 컨텍스트를 활성화하려면, <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal"><span class="pre">setcontext()</span></code></a> 함수를 사용하십시오.</p>
<p>표준에 따라, <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> 모듈은 당장 사용할 수 있는 두 개의 표준 컨텍스트 <a class="reference internal" href="#decimal.BasicContext" title="decimal.BasicContext"><code class="xref py py-const docutils literal"><span class="pre">BasicContext</span></code></a> 와 <a class="reference internal" href="#decimal.ExtendedContext" title="decimal.ExtendedContext"><code class="xref py py-const docutils literal"><span class="pre">ExtendedContext</span></code></a> 를 제공합니다. 특히 전자는 많은 트랩이 활성화되어있어 디버깅에 유용합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myothercontext</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_HALF_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">myothercontext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857142857142857142857142857142857142857142857142857142857&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ExtendedContext</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857143&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">BasicContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#143&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
    <span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div>
</div>
<p>컨텍스트에는 계산 중에 발생하는 예외 조건을 모니터링하기위한 신호 플래그도 있습니다. 플래그는 명시 적으로 지워질 때까지 설정된 상태로 유지되므로, <code class="xref py py-meth docutils literal"><span class="pre">clear_flags()</span></code> 메서드를 사용하여 모니터링되는 각 계산 집합 앞에서 플래그를 지우는 것이 가장 좋습니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">clear_flags</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">355</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">113</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.14159292&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])</span>
</pre></div>
</div>
<p><em>flags</em> 엔트리는 <code class="xref py py-const docutils literal"><span class="pre">Pi</span></code> 에 대한 유리수 근사값이 자리 올림되었고 (컨텍스트 정밀도 이상의 숫자가 버려졌습니다) 결과가 부정확하다는 (폐기 된 숫자 일부는 0이 아닙니다) 것을 보여줍니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">355/113 은 <code class="xref py py-const docutils literal"><span class="pre">Pi</span></code> 와 소수점 6자리까지 일치하는 간단한 유리수 근사값입니다.</p>
</div>
<p>개별 트랩은 컨텍스트의 <code class="xref py py-attr docutils literal"><span class="pre">traps</span></code> 필드에있는 딕셔너리를 사용해서 설정합니다.:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">DivisionByZero</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#112&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
    <span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div>
</div>
<p>대부분의 프로그램은 프로그램 시작시에 한 번만 현재 컨텍스트를 조정합니다. 그리고, 많은 응용 프로그램에서, 데이터는 루프 내에서 단일 캐스트로 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 로 변환되어, 프로그램의 대부분은 다른 파이썬 숫자 형과 별로 다르지 않게 데이터를 조작합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">대체로 파이썬의 다른 숫자 형과 비슷하게 동작하지만, 정수 나눗셈에 음수가 포함될 때는 차이가 있기 때문에
조심해야합니다. 이 차이에 대해서는 밑에서 설명합니다.</p>
</div>
</div>
<div class="section" id="decimal-objects">
<span id="decimal-decimal"></span><h2>9.4.2. Decimal 객체<a class="headerlink" href="#decimal-objects" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="decimal.Decimal">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Decimal</code><span class="sig-paren">(</span><em>value=&quot;0&quot;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal" title="정의 주소">¶</a></dt>
<dd><p><em>value</em> 를 기반으로 새 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 객체를 만듭니다.</p>
<p><em>value</em> 는 정수, 문자열, 튜플, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 또는 다른 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 객체 일 수 있습니다. <em>value</em> 가 주어지지 않으면, <code class="docutils literal"><span class="pre">Decimal('0')</span></code> 을 반환합니다. <em>value</em> 가 문자열이면, 앞뒤의 공백 문자 및 밑줄이 제거 된 후 십진수 문자열 문법에 맞아야합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">sign</span>           <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;+&#39;</span> <span class="o">|</span> <span class="s1">&#39;-&#39;</span>
<span class="n">digit</span>          <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;0&#39;</span> <span class="o">|</span> <span class="s1">&#39;1&#39;</span> <span class="o">|</span> <span class="s1">&#39;2&#39;</span> <span class="o">|</span> <span class="s1">&#39;3&#39;</span> <span class="o">|</span> <span class="s1">&#39;4&#39;</span> <span class="o">|</span> <span class="s1">&#39;5&#39;</span> <span class="o">|</span> <span class="s1">&#39;6&#39;</span> <span class="o">|</span> <span class="s1">&#39;7&#39;</span> <span class="o">|</span> <span class="s1">&#39;8&#39;</span> <span class="o">|</span> <span class="s1">&#39;9&#39;</span>
<span class="n">indicator</span>      <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;e&#39;</span> <span class="o">|</span> <span class="s1">&#39;E&#39;</span>
<span class="n">digits</span>         <span class="p">::</span><span class="o">=</span>  <span class="n">digit</span> <span class="p">[</span><span class="n">digit</span><span class="p">]</span><span class="o">...</span>
<span class="n">decimal</span><span class="o">-</span><span class="n">part</span>   <span class="p">::</span><span class="o">=</span>  <span class="n">digits</span> <span class="s1">&#39;.&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">exponent</span><span class="o">-</span><span class="n">part</span>  <span class="p">::</span><span class="o">=</span>  <span class="n">indicator</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">infinity</span>       <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;Infinity&#39;</span> <span class="o">|</span> <span class="s1">&#39;Inf&#39;</span>
<span class="n">nan</span>            <span class="p">::</span><span class="o">=</span>  <span class="s1">&#39;NaN&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="s1">&#39;sNaN&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">value</span>  <span class="p">::</span><span class="o">=</span>  <span class="n">decimal</span><span class="o">-</span><span class="n">part</span> <span class="p">[</span><span class="n">exponent</span><span class="o">-</span><span class="n">part</span><span class="p">]</span> <span class="o">|</span> <span class="n">infinity</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">string</span> <span class="p">::</span><span class="o">=</span>  <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">numeric</span><span class="o">-</span><span class="n">value</span> <span class="o">|</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">nan</span>
</pre></div>
</div>
<p>위의 <code class="docutils literal"><span class="pre">digit</span></code> 가 나타나는 곳에는 다른 유니 코드 십진수도 허용됩니다. 여기에는 다양한 다른 알파벳(예를 들어, 인도-아라비아와 데바나가리 숫자)의 십진수와 전각 숫자 <code class="docutils literal"><span class="pre">'\uff10'</span></code> 에서 <code class="docutils literal"><span class="pre">'\uff19'</span></code> 까지 포함됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">인도-아라비아 숫자는 우리가 흔히 아라비아 숫자라고 부르는 것이고, 데바나가리(Devanāgarī) 숫자는
고대 인도의 문자입니다.</p>
</div>
<p><em>value</em> 가 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> 이면, 세 개의 항목으로 구성되어야 합니다, 부호 (<code class="xref py py-const docutils literal"><span class="pre">0</span></code> 은 양수, <code class="xref py py-const docutils literal"><span class="pre">1</span></code> 은 음수), 숫자의 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>, 정수 지수. 예를 들어, <code class="docutils literal"><span class="pre">Decimal((0,</span> <span class="pre">(1,</span> <span class="pre">4,</span> <span class="pre">1,</span> <span class="pre">4),</span> <span class="pre">-3))</span></code> 은 <code class="docutils literal"><span class="pre">Decimal('1.414')</span></code> 를 반환합니다.</p>
<p><em>value</em> 가 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 면, 이진 부동 소수점 값은 손실 없이 정확한 십진수로 변환됩니다. 이 변환에는 종종 53 자리 이상의 정밀도가 필요할 수 있습니다. 예를 들어, <code class="docutils literal"><span class="pre">Decimal(float('1.1'))</span></code> 은 <code class="docutils literal"><span class="pre">Decimal('1.100000000000000088817841970012523233890533447265625')</span></code> 로 변환됩니다.</p>
<p><em>context</em> 정밀도는 저장되는 자릿수에 영향을주지 않습니다. 저장되는 자릿수는 <em>value</em> 의 자릿수만으로 결정됩니다. 예를 들어 <code class="docutils literal"><span class="pre">Decimal('3.00000')</span></code> 은 컨텍스트 정밀도가 단지 3 이라도 5 개의 모든 0을 기록합니다.</p>
<p><em>context</em> 인자의 목적은 <em>value</em> 가 잘못된 문자열인 경우 어떻게 해야할지를 결정하는 것입니다. 컨텍스트가 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal"><span class="pre">InvalidOperation</span></code></a> 을 트랩하면, 예외가 발생합니다; 그렇지 않으면, 생성자는 <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> 의 값을 갖는 새 Decimal을 반환합니다.</p>
<p>일단 만들어지면, <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 객체는 불변입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>생성자에 대한 인자는 이제 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 인스턴스가 될 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 인자는 <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal"><span class="pre">FloatOperation</span></code></a> 트랩이 설정되면 예외를 발생시킵니다. 기본적으로 트랩은 꺼져 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>코드에서의 정수 와 부동 소수점 리터럴과 마찬가지로, 밑줄로 무리지을 수 있습니다.</p>
</div>
<p>십진 부동 소수점 객체는 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 와 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 와 같은 다른 내장 숫자 형과 많은 성질을 공유합니다. 일반적인 수학 연산과 특수 메서드가 모두 적용됩니다. 마찬가지로, 십진 객체는 복사, 피클, 인쇄, 틱셔너리 키로 사용, 집합 원소로 사용, 비교, 정렬 및 다른 형(가령 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 또는 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>)으로 커어션될 수 있습니다.</p>
<p>Decimal 객체에 대한 산술과 정수 및 실수에 대한 산술에는 약간의 차이가 있습니다. Decimal 객체에 나머지 연산자 <code class="docutils literal"><span class="pre">%</span></code> 가 적용될 때, 결과의 부호는 제수의 부호가 아닌 <em>피제수</em>의 부호가됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal(&#39;-3&#39;)</span>
</pre></div>
</div>
<p>정수 나눗셈 연산자 <code class="docutils literal"><span class="pre">//</span></code> 의 동작 역시 비슷한 차이를 보입니다. 즉, 가장 가까운 정수로 내림하는 대신 실제 몫의 정수부(0을 향해 자르기)를 돌려줍니다. 그래서 일반적인 항등식 <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y)</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> 를 유지합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="mi">7</span> <span class="o">//</span> <span class="mi">4</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal(&#39;-1&#39;)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">%</span></code> 와 <code class="docutils literal"><span class="pre">//</span></code> 연산자는 명세에 설명 된대로 각각 <code class="docutils literal"><span class="pre">remainder</span></code> 와 <code class="docutils literal"><span class="pre">divide-integer</span></code> 연산을 구현합니다.</p>
<p>Decimal 객체는 일반적으로 산술 연산에서 float 나 <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal"><span class="pre">fractions.Fraction</span></code></a> 인스턴스와 결합 할 수 없습니다: 예를 들어, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 에 a <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 을 더하려고 하면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 를 일으킵니다. 그러나, 파이썬의 비교 연산자를 사용하여 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 인스턴스 <code class="docutils literal"><span class="pre">x</span></code> 와 다른 숫자 <code class="docutils literal"><span class="pre">y</span></code> 를 비교할 수 있습니다. 이렇게해서 서로 다른 형의 숫자간에 동등 비교를 할 때 혼란스러운 결과를 피합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 인스턴스와 다른 숫자 형 사이의 혼합 형 비교가 이제 완전히 지원됩니다.</p>
</div>
<p>표준 숫자 속성에 더해, 십진 부동 소수점 객체에는 여러 가지 특별한 메서드가 있습니다:</p>
<dl class="method">
<dt id="decimal.Decimal.adjusted">
<code class="descname">adjusted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.adjusted" title="정의 주소">¶</a></dt>
<dd><p>최상위 숫자만 남을 때까지 계수의 가장 오른쪽 숫자들을 밀어내도록 조정된 지수를 반환합니다. <code class="docutils literal"><span class="pre">Decimal('321e+5').adjusted()</span></code> 는 7을 반환합니다. 소수점으로 부터의 최상위 유효 숫자의 위치를 ​​결정하는 데 사용됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">'321e+5' 를 '3.21e+7' 로 변환한 후에 <cite>7</cite> 을 취한다는 뜻입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.as_integer_ratio">
<code class="descname">as_integer_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.as_integer_ratio" title="정의 주소">¶</a></dt>
<dd><p>주어진 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 인스턴스를, 분모가 양수인 기약 분수로 나타내는 정수의 쌍 <code class="docutils literal"><span class="pre">(n,</span> <span class="pre">d)</span></code> 을 돌려줍니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-3.14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(-157, 50)</span>
</pre></div>
</div>
<p>변환은 정확합니다. 무한대는 OverflowError를, NaN 은 ValueError를 일으킵니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p>이 변환이 정확하기는 하지만, 기약 분수를 만들기 때문에 유효 숫자를 모두 보존하지는 않습니다.</p>
<div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-3.140&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(-157, 50)</span>
</pre></div>
</div>
</div>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
<dl class="method">
<dt id="decimal.Decimal.as_tuple">
<code class="descname">as_tuple</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.as_tuple" title="정의 주소">¶</a></dt>
<dd><p>숫자의 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> 표현을 반환합니다: <code class="docutils literal"><span class="pre">DecimalTuple(sign,</span> <span class="pre">digits,</span> <span class="pre">exponent)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.canonical">
<code class="descname">canonical</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.canonical" title="정의 주소">¶</a></dt>
<dd><p>인자의 규범적인 인코딩을 돌려줍니다. 현재 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 인스턴스의 인코딩은 항상 규범적이므로, 이 연산은 인자를 변경하지 않고 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.compare">
<code class="descname">compare</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare" title="정의 주소">¶</a></dt>
<dd><p>두 Decimal 인스턴스의 값을 비교합니다. <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal"><span class="pre">compare()</span></code></a> 는 Decimal 인스턴스를 반환하고, 피연산자 중 하나가 NaN이면 결과는 NaN입니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="n">나</span> <span class="n">b</span> <span class="n">가</span> <span class="n">NaN</span>     <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-1&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">==</span> <span class="n">b</span>           <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><code class="docutils literal"><span class="pre">a.compare(b)</span></code> 의 결과가 어떻게 되는지에 대한 예시입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.compare_signal">
<code class="descname">compare_signal</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_signal" title="정의 주소">¶</a></dt>
<dd><p>이 연산은, 모든 NaN 이 신호를 준다는 것을 제외하면 <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal"><span class="pre">compare()</span></code></a> 메서드와 같습니다. 즉, 피연산자가 모두 신호를 주는 NaN이 아니면, 모든 조용한 NaN 피연산자가 마치 신호를 주는 NaN 인 것처럼 처리됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.compare_total">
<code class="descname">compare_total</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_total" title="정의 주소">¶</a></dt>
<dd><p>두 개의 피연산자를 숫자 값 대신 추상 표현을 사용하여 비교합니다. <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal"><span class="pre">compare()</span></code></a> 메서드와 비슷하지만, 결과는 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 인스턴스에 대해 전 순서(total ordering)를 부여합니다. 같은 숫자 값을 갖지만 다른 표현의 두 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 인스턴스는 이 순서에의해 다른 것으로 비교됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;12.0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">compare_total</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;12&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-1&#39;)</span>
</pre></div>
</div>
<p>조용한 NaN과 신호를 주는 NaN도 전 순서에 포함됩니다. 이 함수의 결과는, 두 피연산자가 같은 표현을 가질 때 <code class="docutils literal"><span class="pre">Decimal('0')</span></code>, 첫 번째 피연산자가 전 순서에서 두 번째 피연산자보다 낮으면 <code class="docutils literal"><span class="pre">Decimal('-1')</span></code>, 첫 번째 피연산자가 전 순서에서 두 번째 피연산자보다 높으면 <code class="docutils literal"><span class="pre">Decimal('1')</span></code> 입니다. 전 순서에 대한 세부 사항은 명세를 참조하십시오.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p>전 순서에는 유효 숫자와 특수한 값에 대한 정의가 포함되지만, 일반적인 숫자 값의 대소 관계는
그대로 보존됩니다. 대략 이런 순서를 갖도록 정의됩니다.</p>
<p class="last"><code class="docutils literal"><span class="pre">-NaN</span> <span class="pre">-sNaN</span> <span class="pre">-Infinity</span> <span class="pre">-127</span> <span class="pre">-1.00</span> <span class="pre">-1</span> <span class="pre">-0.000</span> <span class="pre">-0</span> <span class="pre">0</span> <span class="pre">1.2300</span> <span class="pre">1.23</span> <span class="pre">1E+9</span> <span class="pre">Infinity</span> <span class="pre">sNaN</span> <span class="pre">NaN</span></code></p>
</div>
<p>이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다. 예외적으로, 두 번째 피연산자를 정확하게 변환할 수 없으면 C 버전은 InvalidOperation을 발생시킬 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.compare_total_mag">
<code class="descname">compare_total_mag</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_total_mag" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.compare_total" title="decimal.Decimal.compare_total"><code class="xref py py-meth docutils literal"><span class="pre">compare_total()</span></code></a> 처럼 두 개의 피연산자를 숫자 값 대신 추상 표현을 사용하여 비교하지만, 각 피연산자의 부호를 무시합니다. <code class="docutils literal"><span class="pre">x.compare_total_mag(y)</span></code> 는 <code class="docutils literal"><span class="pre">x.copy_abs().compare_total(y.copy_abs())</span></code> 와 동등합니다.</p>
<p>이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다. 예외적으로, 두 번째 피연산자를 정확하게 변환할 수 없으면 C 버전은 InvalidOperation을 발생시킬 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.conjugate">
<code class="descname">conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.conjugate" title="정의 주소">¶</a></dt>
<dd><p>그냥 self를 돌려줍니다. 이 메서드는 Decimal 명세를 준수하기 위한 것 뿐입니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.copy_abs">
<code class="descname">copy_abs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_abs" title="정의 주소">¶</a></dt>
<dd><p>인자의 절대 값을 반환합니다. 이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.copy_negate">
<code class="descname">copy_negate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_negate" title="정의 주소">¶</a></dt>
<dd><p>인자의 음의 부정을 돌려줍니다. 이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.copy_sign">
<code class="descname">copy_sign</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_sign" title="정의 주소">¶</a></dt>
<dd><p>두 번째 피연산자의 부호와 같은 부호로 설정된 첫 번째 피연산자의 복사본을 반환합니다. 예를 들어:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy_sign</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-1.5&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-2.3&#39;)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 섹션에서는 인자나 피연산자를 언급할 때는, 서명에 나타나지는 않더라도 항상 self 를 포함해서
말하고 있습니다.</p>
</div>
<p>이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다. 예외적으로, 두 번째 피연산자를 정확하게 변환할 수 없으면 C 버전은 InvalidOperation을 발생시킬 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.exp">
<code class="descname">exp</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.exp" title="정의 주소">¶</a></dt>
<dd><p>주어진 숫자에 대한 (자연) 지수 함수 <code class="docutils literal"><span class="pre">e**x</span></code> 의 값을 반환합니다. 결과는 <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a> 자리 올림 모드를 사용하여 올바르게 자리 올림됩니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.718281828459045235360287471&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">321</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.561702493119680037517373933E+139&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.from_float">
<code class="descname">from_float</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.from_float" title="정의 주소">¶</a></dt>
<dd><p>float를 십진수로 정확하게 변환하는 클래스 메서드.</p>
<p><cite>Decimal.from_float(0.1)</cite> 은 <cite>Decimal('0.1')</cite> 과 같지 않음에 유의하십시오. 0.1은 이진 부동 소수점에서 정확하게 표현할 수 없기 때문에, 값은 가장 가까운 표현 가능 값인 <cite>0x1.999999999999ap-4</cite> 로 저장됩니다. 십진수로 표시된 해당 값은 <cite>0.1000000000000000055511151231257827021181583404541015625</cite> 입니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">파이썬 3.2 이후부터는, <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 인스턴스를 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 에서 직접 생성 할 수 있습니다.</p>
</div>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1000000000000000055511151231257827021181583404541015625&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;NaN&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-Infinity&#39;)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.fma">
<code class="descname">fma</code><span class="sig-paren">(</span><em>other</em>, <em>third</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.fma" title="정의 주소">¶</a></dt>
<dd><p>합성된 곱셈-덧셈(fused multiply-add). 중간 값 self*other의 자리 올림 없이 self*other+third를 반환합니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">Decimal(&#39;11&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_canonical">
<code class="descname">is_canonical</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_canonical" title="정의 주소">¶</a></dt>
<dd><p>인자가 규범적이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> 를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> 를 반환합니다. 현재 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 인스턴스는 항상 규범적이므로 이 연산은 항상 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> 를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_finite">
<code class="descname">is_finite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_finite" title="정의 주소">¶</a></dt>
<dd><p>인자가 유한 수이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> 를 반환하고, 인자가 무한대나 NaN 이면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> 를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_infinite">
<code class="descname">is_infinite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_infinite" title="정의 주소">¶</a></dt>
<dd><p>인자가 양이나 음의 무한대면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> 를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> 를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_nan">
<code class="descname">is_nan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_nan" title="정의 주소">¶</a></dt>
<dd><p>인자가 (조용한 또는 신호를 주는) NaN이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> 를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> 를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_normal">
<code class="descname">is_normal</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_normal" title="정의 주소">¶</a></dt>
<dd><p>인자가 <em>정상(normal)</em> 유한 수이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> 를 반환합니다. 인자가 0, 비정상(subnormal), 무한 또는 NaN 이면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> 를 반환합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">0 이 아닌 유한 수 중에서 규범적인 형태의 지수가 Emin 이상인 것들을 정상수(normal number)라고
부르고, Emin 보다 작은 것들을 비정상수(subnormal number)라고 부릅니다. 비정상수는 유효숫자를
일부 희생하면서 여전히 계산 가능합니다. 이런 방식으로 다룰 수 있는 최소 지수는
<a class="reference internal" href="#decimal.Context.Etiny" title="decimal.Context.Etiny"><code class="xref py py-meth docutils literal"><span class="pre">Context.Etiny()</span></code></a> 입니다. Emin 근처에서 갑작스럽게 계산을 포기하기 보다, 정확도를
조금씩 잃어가는 것을 허용하고자 하는 것입니다. 이런 방식을 점진적인 언더플로우라고 합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_qnan">
<code class="descname">is_qnan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_qnan" title="정의 주소">¶</a></dt>
<dd><p>인자가 조용한 NaN이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> 를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> 를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_signed">
<code class="descname">is_signed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_signed" title="정의 주소">¶</a></dt>
<dd><p>인자가 음의 부호를 가지면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> 를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> 를 반환합니다. 0과 NaN 모두 부호를 가질 수 있다는 것에 유의하세요.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_snan">
<code class="descname">is_snan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_snan" title="정의 주소">¶</a></dt>
<dd><p>인자가 신호를 주는 NaN이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> 를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> 를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_subnormal">
<code class="descname">is_subnormal</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_subnormal" title="정의 주소">¶</a></dt>
<dd><p>인자가 비정상(subnormal)이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> 를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> 를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.is_zero">
<code class="descname">is_zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_zero" title="정의 주소">¶</a></dt>
<dd><p>인자가 (양 또는 음의) 0이면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> 를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> 를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.ln">
<code class="descname">ln</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.ln" title="정의 주소">¶</a></dt>
<dd><p>피연산자의 자연 로그(밑 e)를 반환합니다. 결과는 <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a> 자리 올림 모드를 사용하여 올바르게 반올림됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.log10">
<code class="descname">log10</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.log10" title="정의 주소">¶</a></dt>
<dd><p>피연산자의 상용 로그를 반환합니다. 결과는 <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a> 자리 올림 모드를 사용하여 올바르게 반올림됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logb">
<code class="descname">logb</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logb" title="정의 주소">¶</a></dt>
<dd><p>0이 아닌 수의 경우, 피연산자의 조정된 지수를 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 인스턴스로 반환합니다. 피연산자가 0이면 <code class="docutils literal"><span class="pre">Decimal('-Infinity')</span></code> 가 반환되고 <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal"><span class="pre">DivisionByZero</span></code></a> 플래그가 발생합니다. 피연산자가 무한대면 <code class="docutils literal"><span class="pre">Decimal('Infinity')</span></code> 가 반환됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">피연산자의 부호를 무시하고 지수부를 취하는 연산입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logical_and">
<code class="descname">logical_and</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_and" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_and" title="decimal.Decimal.logical_and"><code class="xref py py-meth docutils literal"><span class="pre">logical_and()</span></code></a> 는 두 개의 <em>논리적 피연산자</em>(<a class="reference internal" href="#logical-operands-label"><span class="std std-ref">논리적 피연산자</span></a> 를 보세요)를 취하는 논리적 연산입니다. 결과는 두 피연산자의 자릿수별 <code class="docutils literal"><span class="pre">and</span></code> 입니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logical_invert">
<code class="descname">logical_invert</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_invert" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_invert" title="decimal.Decimal.logical_invert"><code class="xref py py-meth docutils literal"><span class="pre">logical_invert()</span></code></a> 는 논리적 연산입니다. 결과는 피연산자의 자릿수별 반전입니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logical_or">
<code class="descname">logical_or</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_or" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_or" title="decimal.Decimal.logical_or"><code class="xref py py-meth docutils literal"><span class="pre">logical_or()</span></code></a> 는 두 개의 <em>논리적 피연산자</em>(<a class="reference internal" href="#logical-operands-label"><span class="std std-ref">논리적 피연산자</span></a> 를 보세요)를 취하는 논리적 연산입니다. 결과는 두 피연산자의 자릿수별 <code class="docutils literal"><span class="pre">or</span></code> 입니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.logical_xor">
<code class="descname">logical_xor</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_xor" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_xor" title="decimal.Decimal.logical_xor"><code class="xref py py-meth docutils literal"><span class="pre">logical_xor()</span></code></a> 은 두 개의 <em>논리적 피연산자</em>(<a class="reference internal" href="#logical-operands-label"><span class="std std-ref">논리적 피연산자</span></a> 를 보세요)를 취하는 논리적 연산입니다. 결과는 두 피연산자의 자릿수별 배타적 or 입니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.max" title="정의 주소">¶</a></dt>
<dd><p>컨텓스트 자리 올림 규칙이 반환되기 전에 적용되고 <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> 값이 (컨텍스트와 신호를 주는지 조용한지에 따라) 신호를 주거나 무시되는 것을 제외하고 <code class="docutils literal"><span class="pre">max(self,</span> <span class="pre">other)</span></code> 와 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.max_mag">
<code class="descname">max_mag</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.max_mag" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.max" title="decimal.Decimal.max"><code class="xref py py-meth docutils literal"><span class="pre">max()</span></code></a> 와 비슷하지만, 피연산자의 절대 값을 사용하여 비교가 이루어집니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.min" title="정의 주소">¶</a></dt>
<dd><p>컨텓스트 자리 올림 규칙이 반환되기 전에 적용되고 <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> 값이 (컨텍스트와 신호를 주는지 조용한지에 따라) 신호를 주거나 무시되는 것을 제외하고 <code class="docutils literal"><span class="pre">min(self,</span> <span class="pre">other)</span></code> 와 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.min_mag">
<code class="descname">min_mag</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.min_mag" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.min" title="decimal.Decimal.min"><code class="xref py py-meth docutils literal"><span class="pre">min()</span></code></a> 와 비슷하지만, 피연산자의 절대 값을 사용하여 비교가 이루어집니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.next_minus">
<code class="descname">next_minus</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_minus" title="정의 주소">¶</a></dt>
<dd><p>주어진 피연산자보다 작고, 주어진 컨텍스트(또는 context 가 주어지지 않으면 현재 스레드의 컨텍스트)에서 표현 가능한 가장 큰 수를 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.next_plus">
<code class="descname">next_plus</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_plus" title="정의 주소">¶</a></dt>
<dd><p>주어진 피연산자보다 크고, 주어진 컨텍스트(또는 context 가 주어지지 않으면 현재 스레드의 컨텍스트)에서 표현 가능한 가장 작은 수를 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.next_toward">
<code class="descname">next_toward</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_toward" title="정의 주소">¶</a></dt>
<dd><p>두 피연산자가 같지 않으면, 두 번째 피연산자의 방향으로 첫 번째 피연산자에 가장 가까운 숫자를 반환합니다. 두 피연산자가 수치적으로 같으면, 첫 번째 피연산자의 복사본을 반환하는데, 부호를 두 번째 피연산자의 것으로 설정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.normalize" title="정의 주소">¶</a></dt>
<dd><p>가장 오른쪽 끝에 오는 0을 제거하고 결과를 <code class="xref py py-const docutils literal"><span class="pre">Decimal('0')</span></code> 과 같은 모든 결과를 <code class="xref py py-const docutils literal"><span class="pre">Decimal('0e0')</span></code> 으로 변환하여 숫자를 정규화합니다. 등가 클래스의 어트리뷰트에 대한 규범적인 값을 만드는데 데 사용됩니다. 예를 들어, <code class="docutils literal"><span class="pre">Decimal('32.100')</span></code> 과 <code class="docutils literal"><span class="pre">Decimal('0.321000e+2')</span></code> 는 모두 같은 값인 <code class="docutils literal"><span class="pre">Decimal('32.1')</span></code> 로 정규화됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 연산은 정규화라기 보다는, 숫자를 동등 비교가 유지되는 범위내에서 가장 단순한 형태로 환원시키는
것입니다. 실제로 Decimal 명세에서는 이 연산의 이름이 <code class="docutils literal"><span class="pre">reduce</span></code> 로 변경되었습니다. 하지만
이 변경의 더 큰 이유는, 이 연산이 정상수(normal number)와 아무 관련이 없다는 것입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.number_class">
<code class="descname">number_class</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.number_class" title="정의 주소">¶</a></dt>
<dd><p>피연산자의 <em>클래스</em> 를 설명하는 문자열을 반환합니다. 반환 값은 다음 10 개의 문자열 중 하나입니다.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&quot;-Infinity&quot;</span></code>, 피연산자가 음의 무한대임을 나타냅니다.</li>
<li><code class="docutils literal"><span class="pre">&quot;-Normal&quot;</span></code>, 피연산자가 음의 정상수임을 나타냅니다.</li>
<li><code class="docutils literal"><span class="pre">&quot;-Subnormal&quot;</span></code>, 피연산자가 음의 비정상수임을 나타냅니다.</li>
<li><code class="docutils literal"><span class="pre">&quot;-Zero&quot;</span></code>, 피연산자가 음의 0임을 나타냅니다.</li>
<li><code class="docutils literal"><span class="pre">&quot;+Zero&quot;</span></code>, 피연산자가 양의 0임을 나타냅니다.</li>
<li><code class="docutils literal"><span class="pre">&quot;+Subnormal&quot;</span></code>, 피연산자가 양의 비정상수임을 나타냅니다.</li>
<li><code class="docutils literal"><span class="pre">&quot;+Normal&quot;</span></code>, 피연산자가 양의 정상수임을 나타냅니다.</li>
<li><code class="docutils literal"><span class="pre">&quot;+Infinity&quot;</span></code>, 피연산자가 양의 무한대임을 나타냅니다.</li>
<li><code class="docutils literal"><span class="pre">&quot;NaN&quot;</span></code>, 피연산자가 조용한 NaN(Not a Number)임을 나타냅니다.</li>
<li><code class="docutils literal"><span class="pre">&quot;sNaN&quot;</span></code>, 피연산자가 신호를 주는 NaN임을 나타냅니다.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.quantize">
<code class="descname">quantize</code><span class="sig-paren">(</span><em>exp</em>, <em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.quantize" title="정의 주소">¶</a></dt>
<dd><p>자리 올림 후에 첫 번째 피연산자와 같고 두 번째 피연산자의 지수를 갖는 값을 반환합니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.41421356&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.000&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;1.414&#39;)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 연산은 계수부를 정수로 만들때의 지수부가 <em>exp</em> 의 지수부와 같도록 만듭니다. 이 결과
소수점 밑의 자릿수를 <em>exp</em> 와 일치하도록 자리 올림하게됩니다. 때문에 <em>exp</em> 를 자릿수를
표현하는 탬플릿 처럼 사용하면 됩니다.</p>
</div>
<p>다른 연산과 달리, quantize 연산 후의 계수의 길이가 정밀도보다 크면, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal"><span class="pre">InvalidOperation</span></code></a> 신호를 줍니다. 이는, 에러 조건이 없으면, quantize된 지수가 항상 오른쪽 피연산자의 지수와 같음을 보장합니다.</p>
<p>또한 다른 연산과는 달리, 결과가 비정상(subnormal)이고 부정확한 경우조차도, quantize는 결코 Underflow 신호를 보내지 않습니다.</p>
<p>두 번째 피연산자의 지수가 첫 번째 피연산자의 지수보다 크면 자리 올림이 필요할 수 있습니다. 이 경우, 자리 올림 모드는 주어진 경우 <code class="docutils literal"><span class="pre">rounding</span></code> 인자에 의해 결정됩니다. 그렇지 않으면 주어진 <code class="docutils literal"><span class="pre">context</span></code> 인자에 의해 결정됩니다; 두 인자 모두 주어지지 않으면, 현재 스레드의 컨텍스트의 자리 올림 모드가 사용됩니다.</p>
<p>결과 지수가 <code class="xref py py-attr docutils literal"><span class="pre">Emax</span></code> 보다 크거나 <code class="xref py py-attr docutils literal"><span class="pre">Etiny</span></code> 보다 작을 때마다 에러가 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.radix">
<code class="descname">radix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.radix" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 클래스가 모든 산술을 수행하는 진수(기수)인 <code class="docutils literal"><span class="pre">Decimal(10)</span></code> 을 반환합니다. 명세와의 호환성을 위해 포함됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.remainder_near">
<code class="descname">remainder_near</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.remainder_near" title="정의 주소">¶</a></dt>
<dd><p><em>self</em> 를 <em>other</em> 로 나눈 나머지를 반환합니다. 이것은 나머지의 절대값을 최소화하기 위해 나머지의 부호가 선택된다는 점에서 <code class="docutils literal"><span class="pre">self</span> <span class="pre">%</span> <span class="pre">other</span></code> 와 다릅니다. 좀 더 정확히 말하면, 반환 값은 <code class="docutils literal"><span class="pre">self</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">other</span></code> 인데, 여기서 <code class="docutils literal"><span class="pre">n</span></code> 은 <code class="docutils literal"><span class="pre">self</span> <span class="pre">/</span> <span class="pre">other</span></code> 의 정확한 값에 가장 가까운 정수이고, 두 개의 정수와의 거리가 같으면 짝수가 선택됩니다.</p>
<p>결과가 0이면 그 부호는 <em>self</em> 의 부호가됩니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;-2&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;5&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;-5&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.rotate" title="정의 주소">¶</a></dt>
<dd><p>첫 번째 피연산자의 계수를 두 번째 피연산자로 지정된 양만큼 회전한 결과를 반환합니다. 두 번째 피연산자는 -precision 에서 precision 범위의 정수여야 합니다. 두 번째 피연산자의 절대값은 회전할 자리의 수를 나타냅니다. 두 번째 피연산자가 양수면 왼쪽으로 회전합니다; 그렇지 않으면 오른쪽으로 회전합니다. 필요하면 정밀도에 맞추기위해 첫 번째 피연산자의 계수에 0이 왼쪽에 채워집니다. 첫 번째 피연산자의 부호와 지수는 변경되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.same_quantum">
<code class="descname">same_quantum</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.same_quantum" title="정의 주소">¶</a></dt>
<dd><p>self와 other가 같은 지수를 가졌는지 또는 둘 다 <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> 인지 검사합니다.</p>
<p>이 연산은 컨텍스트의 영향을 받지 않고, 조용합니다: 어떤 플래그도 변경되지 않고, 어떤 자리 올림도 수행되지 않습니다. 예외적으로, 두 번째 피연산자를 정확하게 변환할 수 없으면 C 버전은 InvalidOperation을 발생시킬 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.scaleb">
<code class="descname">scaleb</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.scaleb" title="정의 주소">¶</a></dt>
<dd><p>첫 번째 비연산자의 지수를 두 번째 피연산자만큼 조정한 값을 반환합니다. 달리표현하면, 첫 번째 피연산자에 <code class="docutils literal"><span class="pre">10**other</span></code> 를 곱한값을 반환합니다. 두 번째 피연산자는 정수여야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.shift">
<code class="descname">shift</code><span class="sig-paren">(</span><em>other</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.shift" title="정의 주소">¶</a></dt>
<dd><p>첫 번째 피연산자의 계수를 두 번째 피연산자로 지정된 양만큼 이동한 결과를 반환합니다. 두 번째 피연산자는 -precision 에서 precision 범위의 정수여야 합니다. 두 번째 피연산자의 절대값은 이동할 자리의 수를 나타냅니다. 두 번째 피연산자가 양수면 왼쪽으로 이동합니다; 그렇지 않으면 오른쪽으로 이동합니다. 이동으로 인해 계수에 들어오는 숫자는 0입니다. 첫 번째 피연산자의 부호와 지수는 변경되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.sqrt">
<code class="descname">sqrt</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.sqrt" title="정의 주소">¶</a></dt>
<dd><p>인자의 제곱근을 완전한 정밀도로 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.to_eng_string">
<code class="descname">to_eng_string</code><span class="sig-paren">(</span><em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_eng_string" title="정의 주소">¶</a></dt>
<dd><p>문자열로 변환합니다. 지수가 필요하면 공학 표기법을 사용합니다.</p>
<p>공학 표기법의 지수는 3의 배수입니다. 이렇게 하면 소수점 왼쪽에 최대 3 자리를 남기게되고, 하나나 두 개의 후행 0을 추가해야 할 수 있습니다.</p>
<p>예를 들어, 이 메서드는 <code class="docutils literal"><span class="pre">Decimal('123E+1')</span></code> 을 <code class="docutils literal"><span class="pre">Decimal('1.23E+3')</span></code> 으로 변환합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">문자열로 변환하기 때문에, <code class="docutils literal"><span class="pre">Decimal('1.23E+3')</span></code> 이 아니라 <code class="docutils literal"><span class="pre">'1.23E+3'</span></code> 을 반환합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.to_integral">
<code class="descname">to_integral</code><span class="sig-paren">(</span><em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.to_integral_value" title="decimal.Decimal.to_integral_value"><code class="xref py py-meth docutils literal"><span class="pre">to_integral_value()</span></code></a> 메서드와 같습니다. <code class="docutils literal"><span class="pre">to_integral</span></code> 이름은 이전 버전과의 호환성을 위해 유지되었습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.to_integral_exact">
<code class="descname">to_integral_exact</code><span class="sig-paren">(</span><em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral_exact" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a> 나 <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal"><span class="pre">Rounded</span></code></a> 신호를 주면서 가장 가까운 정수로 자리 올림 합니다. 자리 올림 모드는 주어진 경우 <code class="docutils literal"><span class="pre">rounding</span></code> 매개 변수에 의해, 그렇지 않으면 그렇지 않으면  <code class="docutils literal"><span class="pre">context</span></code> 에 의해 결정됩니다. 두 매개 변수 모두 지정되지 않으면, 현재 컨텍스트의 자리 올림 모드가 사용됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Decimal.to_integral_value">
<code class="descname">to_integral_value</code><span class="sig-paren">(</span><em>rounding=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral_value" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a> 나 <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal"><span class="pre">Rounded</span></code></a> 신호를 주지 않고 가장 가까운 정수로 자리 올림 합니다. 주어지면, <em>rounding</em> 을 적용합니다; 그렇지 않으면, 제공된 <em>context</em> 나 현재 컨텍스트의 자리 올림 방법을 사용합니다.</p>
</dd></dl>

</dd></dl>

<div class="section" id="logical-operands">
<span id="logical-operands-label"></span><h3>9.4.2.1. 논리적 피연산자<a class="headerlink" href="#logical-operands" title="제목 주소">¶</a></h3>
<p><code class="xref py py-meth docutils literal"><span class="pre">logical_and()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">logical_invert()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">logical_or()</span></code> 와 <code class="xref py py-meth docutils literal"><span class="pre">logical_xor()</span></code> 메서드는 인자가 <em>논리적 피연산자</em> 이길 기대합니다. <em>논리적 피연산자</em> 는 지수와 부호가 모두 0이고 숫자는 모두 <code class="xref py py-const docutils literal"><span class="pre">0</span></code> 또는 <code class="xref py py-const docutils literal"><span class="pre">1</span></code> 인 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 인스턴스입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><code class="docutils literal"><span class="pre">Decimal('11010')</span></code> 은 논리적 피연산자이지만, <code class="docutils literal"><span class="pre">Decimal('-11010')</span></code> 는
부호가 있기 때문에, <code class="docutils literal"><span class="pre">Decimal('12')</span></code> 는 <code class="xref py py-const docutils literal"><span class="pre">0</span></code> 과 <code class="xref py py-const docutils literal"><span class="pre">1</span></code> 이외의
숫자가 들어있기 때문에 논리적 피연산자가 아닙니다. 논리적 연산은 각 자릿수별로 이루어집니다.
즉, <code class="docutils literal"><span class="pre">Decimal('101').logical_or(Decimal('10'))</span></code> 은 <code class="docutils literal"><span class="pre">Decimal('111')</span></code>
이 됩니다.</p>
</div>
</div>
</div>
<div class="section" id="context-objects">
<span id="decimal-context"></span><h2>9.4.3. Context 객체<a class="headerlink" href="#context-objects" title="제목 주소">¶</a></h2>
<p>컨텍스트는 산술 연산을 위한 환경입니다. 정밀도를 제어하고, 자리 올림 규칙을 설정하며, 어떤 신호가 예외로 처리되는지 결정하고, 지수의 범위를 제한합니다.</p>
<p>각 스레드는 자신만의 현재 컨텍스트를 가지는데, <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a> 와 <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal"><span class="pre">setcontext()</span></code></a> 함수를 사용하여 액세스하거나 변경합니다:</p>
<dl class="function">
<dt id="decimal.getcontext">
<code class="descclassname">decimal.</code><code class="descname">getcontext</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.getcontext" title="정의 주소">¶</a></dt>
<dd><p>활성 스레드의 현재 컨텍스트를 돌려줍니다.</p>
</dd></dl>

<dl class="function">
<dt id="decimal.setcontext">
<code class="descclassname">decimal.</code><code class="descname">setcontext</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.setcontext" title="정의 주소">¶</a></dt>
<dd><p>활성 스레드의 현재 컨텍스트를 <em>c</em> 로 설정합니다.</p>
</dd></dl>

<p>또한 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 문과 <a class="reference internal" href="#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal"><span class="pre">localcontext()</span></code></a> 함수를 사용하여 활성 컨텍스트를 일시적으로 변경할 수 있습니다.</p>
<dl class="function">
<dt id="decimal.localcontext">
<code class="descclassname">decimal.</code><code class="descname">localcontext</code><span class="sig-paren">(</span><em>ctx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.localcontext" title="정의 주소">¶</a></dt>
<dd><p>with-문으로 진입할 때 활성 스레드의 현재 컨텍스트를 <em>ctx</em> 의 복사본으로 설정하고, with-문을 빠져나올 때 이전의 컨텍스트를 복원하는 컨텍스트 관리자를 돌려줍니다. 컨텍스트를 지정하지 않으면 현재 컨텍스트의 복사본이 사용됩니다.</p>
<p>예를 들어, 다음 코드는 현재 십진 정밀도를 42 자리로 설정하고, 계산을 수행 한 다음, 이전 컨텍스트를 자동으로 복원합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">localcontext</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">()</span> <span class="k">as</span> <span class="n">ctx</span><span class="p">:</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">42</span>   <span class="c1"># 높은 정밀도 계산을 수행합니다</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_something</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="o">+</span><span class="n">s</span>  <span class="c1"># 최종 결과를 기본 정밀도로 되돌립니다</span>
</pre></div>
</div>
</dd></dl>

<p>아래에 설명 된 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> 생성자를 사용하여 새로운 컨텍스트를 만들 수도 있습니다. 또한, 이 모듈은 세 가지 미리 만들어진 컨텍스트를 제공합니다:</p>
<dl class="class">
<dt id="decimal.BasicContext">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">BasicContext</code><a class="headerlink" href="#decimal.BasicContext" title="정의 주소">¶</a></dt>
<dd><p>이것은 일반 십진 산술 명세에서 정의된 표준 컨텍스트입니다. 정밀도는 9로 설정됩니다. 자리 올림은 <a class="reference internal" href="#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_UP</span></code></a> 으로 설정됩니다. 모든 플래그가 지워집니다. 모든 트랩은 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a>, <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal"><span class="pre">Rounded</span></code></a>, <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal"><span class="pre">Subnormal</span></code></a> 를 제외하고는 활성화됩니다 (예외로 처리됩니다).</p>
<p>많은 트랩이 활성화되었으므로, 이 컨텍스트는 디버깅에 유용합니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.ExtendedContext">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">ExtendedContext</code><a class="headerlink" href="#decimal.ExtendedContext" title="정의 주소">¶</a></dt>
<dd><p>이것은 일반 십진 산술 명세에서 정의 된 표준 컨텍스트입니다. 정밀도는 9로 설정됩니다. 자리 올림은 <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a> 으로 설정됩니다. 모든 플래그가 지워집니다. 아무 트랩도 활성화되지 않습니다 (그래서 계산 중에 예외가 발생하지 않습니다).</p>
<p>트랩이 비활성화되었으므로, 이 컨텍스트는 예외를 발생시키기보다 <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> 이나 <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code> 의 결과값을 선호하는 응용 프로그램에 유용합니다. 이는 응용 프로그램이 그렇지 않을 경우 프로그램을 중단시킬 수 있는 조건이 있는 경우에도 실행을 완료할 수 있도록합니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.DefaultContext">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">DefaultContext</code><a class="headerlink" href="#decimal.DefaultContext" title="정의 주소">¶</a></dt>
<dd><p>이 컨텍스트는 새로운 컨텍스트의 프로토 타입으로 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> 생성자에 의해 사용됩니다. 필드(가령 정밀도)를 변경하면 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> 생성자에 의해 생성된 새로운 컨텍스트에 대한 기본값을 변경하는 효과가 있습니다.</p>
<p>이 컨텍스트는 다중 스레드 환경에서 가장 유용합니다. 스레드가 시작되기 전에 필드 중 하나를 변경하면 시스템 전체의 기본값을 설정하는 효과가 있습니다. 스레드가 시작된 후에 필드를 변경하는 것은. 스레드 동기화를 통해 경쟁 조건을 방지해야하므로 권장되지 않습니다.</p>
<p>단일 스레드 환경에서는, 이 컨텍스트를 아예 사용하지 않는 것이 좋습니다. 대신, 아래에 설명 된대로 명시 적으로 컨텍스트를 만드십시오.</p>
<p>기본값은 <code class="xref py py-attr docutils literal"><span class="pre">prec</span></code>=<code class="xref py py-const docutils literal"><span class="pre">28</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">rounding</span></code>=<a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal"><span class="pre">ROUND_HALF_EVEN</span></code></a> 이고 <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-class docutils literal"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal"><span class="pre">InvalidOperation</span></code></a>, <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal"><span class="pre">DivisionByZero</span></code></a> 트랩이 활성화됩니다.</p>
</dd></dl>

<p>3 개의 제공된 컨텍스트 외에도, 새로운 컨텍스트를 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> 생성자를 사용하여 만들 수 있습니다.</p>
<dl class="class">
<dt id="decimal.Context">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Context</code><span class="sig-paren">(</span><em>prec=None</em>, <em>rounding=None</em>, <em>Emin=None</em>, <em>Emax=None</em>, <em>capitals=None</em>, <em>clamp=None</em>, <em>flags=None</em>, <em>traps=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context" title="정의 주소">¶</a></dt>
<dd><p>새로운 컨텍스트를 만듭니다. 필드가 지정되지 않았거나 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> 이면, 기본값은 <a class="reference internal" href="#decimal.DefaultContext" title="decimal.DefaultContext"><code class="xref py py-const docutils literal"><span class="pre">DefaultContext</span></code></a> 에서 복사됩니다. <em>flags</em> 필드가 지정되지 않았거나 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> 이면, 모든 플래그가 지워집니다.</p>
<p><em>prec</em> 는 컨텍스트에서 산술 연산의 정밀도를 설정하는 [<code class="xref py py-const docutils literal"><span class="pre">1</span></code>, <a class="reference internal" href="#decimal.MAX_PREC" title="decimal.MAX_PREC"><code class="xref py py-const docutils literal"><span class="pre">MAX_PREC</span></code></a>] 범위의 정수입니다.</p>
<p><em>rounding</em> 옵션은 <a class="reference internal" href="#rounding-modes">자리 올림 모드</a> 섹션에 나열된 상수 중 하나입니다.</p>
<p><em>traps</em> 과 <em>flags</em> 필드는 설정할 신호를 나열합니다. 일반적으로, 새 컨텍스트는 트랩만 설정하고 플래그는 지워진 채로 두어야합니다.</p>
<p><em>Emin</em> 과 <em>Emax</em> 필드는 지수에 허용되는 한계를 지정하는 정수입니다. <em>Emin</em> 은 [<a class="reference internal" href="#decimal.MIN_EMIN" title="decimal.MIN_EMIN"><code class="xref py py-const docutils literal"><span class="pre">MIN_EMIN</span></code></a>, <code class="xref py py-const docutils literal"><span class="pre">0</span></code>], <em>Emax</em> 는 [<code class="xref py py-const docutils literal"><span class="pre">0</span></code>, <a class="reference internal" href="#decimal.MAX_EMAX" title="decimal.MAX_EMAX"><code class="xref py py-const docutils literal"><span class="pre">MAX_EMAX</span></code></a>] 범위 내에 있어야합니다.</p>
<p><em>capitals</em> 필드는 <code class="xref py py-const docutils literal"><span class="pre">0</span></code> 또는 <code class="xref py py-const docutils literal"><span class="pre">1</span></code>(기본값)입니다. <code class="xref py py-const docutils literal"><span class="pre">1</span></code> 로 설정하면, 지수는 대문자 <code class="xref py py-const docutils literal"><span class="pre">E</span></code>와 함께 인쇄됩니다; 그렇지 않으면 소문자 <code class="xref py py-const docutils literal"><span class="pre">e</span></code> 가 사용됩니다: <code class="xref py py-const docutils literal"><span class="pre">Decimal('6.02e+23')</span></code>.</p>
<p><em>clamp</em> 필드는 <code class="xref py py-const docutils literal"><span class="pre">0</span></code> (기본값) 또는 <code class="xref py py-const docutils literal"><span class="pre">1</span></code> 입니다. <code class="xref py py-const docutils literal"><span class="pre">1</span></code> 로 설정하면, 이 컨텍스트에서 표현할 수있는 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 인스턴스의 지수 <code class="docutils literal"><span class="pre">e</span></code> 는 <code class="docutils literal"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">e</span> <span class="pre">&lt;=</span> <span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> 입니다. <em>clamp</em> 가 <code class="xref py py-const docutils literal"><span class="pre">0</span></code> 이면 더 약한 조건이 유지됩니다: <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 인스턴스의 조정된 최대 <code class="docutils literal"><span class="pre">Emax</span></code> 입니다. <em>clamp</em> 가 <code class="xref py py-const docutils literal"><span class="pre">1</span></code> 일 때, 큰 정상수는, 가능할 때, 지수 제약 조건을 맞추기 위해 지수가 감소되고 해당 숫자만큼의 0이 계수에 더해집니다; 이것은 수의 값을 보존하지만 유효한 후미 0에 대한 정보를 잃어 버립니다. 예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">&#39;1.23e999&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.23000E+999&#39;)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p>지수가 <code class="docutils literal"><span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code>, 즉 994 로 줄어든다는 뜻입니다. 이 지수에 맞추기 위해
세 개의 0을 추가했습니다:</p>
<div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.23000E+999&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as_tuple</span><span class="p">()</span>
<span class="go">DecimalTuple(sign=0, digits=(1, 2, 3, 0, 0, 0), exponent=994)</span>
</pre></div>
</div>
</div>
<p><code class="xref py py-const docutils literal"><span class="pre">1</span></code> 의 <em>clamp</em> 값은 IEEE 754에 명시된 고정 폭 십진수 교환 형식과 호환되도록 합니다.</p>
<p><a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> 클래스는 주어진 컨텍스트에서 직접적으로 산술을 하기위한 다수의 메서드뿐만 아니라 여러 가지 범용 메서드를 정의합니다. 이에 더해, 위에서 설명한 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 메서드마다 (<code class="xref py py-meth docutils literal"><span class="pre">adjusted()</span></code> 과 <code class="xref py py-meth docutils literal"><span class="pre">as_tuple()</span></code> 메서드는 예외입니다) 대응하는 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> 메서드가 있습니다. 예를 들어, <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> 인스턴스 <code class="docutils literal"><span class="pre">C</span></code> 와 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 인스턴스 <code class="docutils literal"><span class="pre">x</span></code> 에 대해서, <code class="docutils literal"><span class="pre">C.exp(x)</span></code> 는 <code class="docutils literal"><span class="pre">x.exp(context=C)</span></code> 와 동등합니다. 각각 <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> 메서드는 Decimal 인스턴스가 받아 들여지는 곳 어디에서나 파이썬 정수(<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 의 인스턴스)를 받아들입니다.</p>
<dl class="method">
<dt id="decimal.Context.clear_flags">
<code class="descname">clear_flags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.clear_flags" title="정의 주소">¶</a></dt>
<dd><p>모든 플래그를 <code class="xref py py-const docutils literal"><span class="pre">0</span></code> 으로 재설정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.clear_traps">
<code class="descname">clear_traps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.clear_traps" title="정의 주소">¶</a></dt>
<dd><p>모든 트랩을 <code class="xref py py-const docutils literal"><span class="pre">0</span></code> 으로 재설정합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy" title="정의 주소">¶</a></dt>
<dd><p>컨텍스트의 복사본을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy_decimal">
<code class="descname">copy_decimal</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_decimal" title="정의 주소">¶</a></dt>
<dd><p>Decimal 인스턴스 num의 복사본을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.create_decimal">
<code class="descname">create_decimal</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.create_decimal" title="정의 주소">¶</a></dt>
<dd><p><em>self</em> 를 컨텍스트로 사용해서, <em>num</em> 으로 새 Decimal 인스턴스를 만듭니다. <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 생성자와 달리, 컨텍스트 정밀도, 자리 올림 방법, 플래그 및 트랩이 변환에 적용됩니다.</p>
<p>이는 상수가 보통 응용 프로그램에 필요한 것보다 더 큰 정밀도로 제공되기 때문에 유용합니다. 또 다른 이점은 자리 올림이 현재 정밀도를 초과하는 자릿수로 인한 의도하지 않은 결과를 즉시 제거한다는 것입니다. 다음 예제에서, 자리 올림되지 않은 입력을 사용한다는 것은 합계에 0을 추가하면 결과가 달라질 수 있음을 의미합니다.:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.4445&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.0023&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.45&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.4445&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.0023&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.44&#39;)</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">정밀도가 3인 컨텍스트에서 유효숫자가 5자리인 상수들로 산술을 하고 있습니다. 찻 번째 산술은
<code class="docutils literal"><span class="pre">Decimal('4.4468')</span></code> 을 유효숫자 3개로 자리 올림해서 <code class="docutils literal"><span class="pre">Decimal('4.45')</span></code> 가
얻어집니다. 하지만 두 번째 산술은 <code class="docutils literal"><span class="pre">Decimal('3.4445')</span> <span class="pre">+</span> <span class="pre">Decimal(0)</span></code> 이 먼저
<code class="docutils literal"><span class="pre">Decimal('3.4445')</span></code> 를 주고 이 값은 다시 <code class="docutils literal"><span class="pre">Decimal('3.44')</span></code> 로 자리올림됩니다.
이 값이 다시 <code class="docutils literal"><span class="pre">Decimal('1.0023')</span></code> 와 더해지면 <code class="docutils literal"><span class="pre">`Decimal('4.4423')``</span></code> 을 거쳐
<code class="docutils literal"><span class="pre">Decimal('4.44')</span></code> 로 자리 올림됩니다. 중간 자리 올림 때문에 <code class="docutils literal"><span class="pre">Decimal(0)</span></code> 을 더하는
것 만으로 두 결과가 달라집니다. 일관된 결과를 얻으려면 상수들을 <a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal"><span class="pre">create_decimal()</span></code></a>
로 미리 변환해서 사용하라는 뜻입니다.</p>
</div>
<p>이 메서드는 IBM 명세의 to-number 연산을 구현합니다. 인자가 문자열이면, 선행 또는 후행 공백이나 밑줄이 허용되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.create_decimal_from_float">
<code class="descname">create_decimal_from_float</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.create_decimal_from_float" title="정의 주소">¶</a></dt>
<dd><p>float <em>f</em> 로 새 Decimal 인스턴스를 만들지만, <em>self</em> 를 컨텍스트로 사용하여 자리 올림합니다. <a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal"><span class="pre">Decimal.from_float()</span></code></a> 클래스 메서드와는 달리, 컨텍스트 정밀도, 자리 올림 방법, 플래그 및 트랩이 변환에 적용됩니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.1415&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">decimal.Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.Etiny">
<code class="descname">Etiny</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.Etiny" title="정의 주소">¶</a></dt>
<dd><p>비정상 결과에 대한 최소 지수 값인 <code class="docutils literal"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> 과 같은 값을 반환합니다. 언더 플로우가 발생하면, 지수는 <a class="reference internal" href="#decimal.Context.Etiny" title="decimal.Context.Etiny"><code class="xref py py-const docutils literal"><span class="pre">Etiny</span></code></a> 로 설정됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.Etop">
<code class="descname">Etop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.Etop" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> 과 같은 값을 반환합니다.</p>
</dd></dl>

<p>십진수로 작업하는 일반적인 접근법은 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 인스턴스를 생성 한 다음 활성 스레드의 현재 컨텍스트 내에서 진행되는 산술 연산을 적용하는 것입니다. 다른 방법은 특정 컨텍스트 내에서 계산하기 위해 컨텍스트 메서드를 사용하는 것입니다. 메서드는 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 클래스의 메서드와 비슷하며 여기에서는 간단히 설명합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">여기에 나오는 설명은 대단히 축약된 것입니다. 사용하기 전에 대응하는 <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 메서드의
설명을 확인하세요.</p>
</div>
<dl class="method">
<dt id="decimal.Context.abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.abs" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 의 절대값을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.add" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 와 <em>y</em> 의 합을 돌려 줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.canonical">
<code class="descname">canonical</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.canonical" title="정의 주소">¶</a></dt>
<dd><p>같은 Decimal 객체 <em>x</em> 를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.compare">
<code class="descname">compare</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 와 <em>y</em> 를 수치로 비교합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.compare_signal">
<code class="descname">compare_signal</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_signal" title="정의 주소">¶</a></dt>
<dd><p>두 피연산자의 값을 수치로 비교합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.compare_total">
<code class="descname">compare_total</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_total" title="정의 주소">¶</a></dt>
<dd><p>추상 표현을 사용하여 두 피연산자를 비교합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.compare_total_mag">
<code class="descname">compare_total_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_total_mag" title="정의 주소">¶</a></dt>
<dd><p>부호를 무시하고, 추상 표현을 사용하여 두 피연산자를 비교합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy_abs">
<code class="descname">copy_abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_abs" title="정의 주소">¶</a></dt>
<dd><p>부호가 0으로 설정되어있는 <em>x</em> 의 복사본을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy_negate">
<code class="descname">copy_negate</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_negate" title="정의 주소">¶</a></dt>
<dd><p>부호가 반전 된 <em>x</em> 복사본을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.copy_sign">
<code class="descname">copy_sign</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_sign" title="정의 주소">¶</a></dt>
<dd><p><em>y</em> 에서 <em>x</em> 로 부호를 복사합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.divide">
<code class="descname">divide</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divide" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 를 <em>y</em> 로 나눈 값을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.divide_int">
<code class="descname">divide_int</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divide_int" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 를 <em>y</em> 로 나눈 후 정수로 잘라낸 값을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.divmod">
<code class="descname">divmod</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divmod" title="정의 주소">¶</a></dt>
<dd><p>두 숫자를 나누고 결과의 정수 부분을 반환합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">잘못 설명되어 있습니다. 내장 <a class="reference internal" href="functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a> 처럼 몫과 나머지를 튜플로 돌려줍니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.exp">
<code class="descname">exp</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.exp" title="정의 주소">¶</a></dt>
<dd><p><cite>e ** x</cite> 을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.fma">
<code class="descname">fma</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.fma" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 에 <em>y</em> 를 곱한 후 <em>z</em> 를 더한 값을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_canonical">
<code class="descname">is_canonical</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_canonical" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 규범적일 경우 <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_finite">
<code class="descname">is_finite</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_finite" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 유한이면 <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_infinite">
<code class="descname">is_infinite</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_infinite" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 무한대면 <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_nan">
<code class="descname">is_nan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_nan" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 qNaN 이나 sNaN 이면 <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_normal">
<code class="descname">is_normal</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_normal" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 정상수면 <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_qnan">
<code class="descname">is_qnan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_qnan" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 조용한 NaN이면 <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_signed">
<code class="descname">is_signed</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_signed" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 음수면 <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_snan">
<code class="descname">is_snan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_snan" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 신호를 주는 NaN 이면 <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_subnormal">
<code class="descname">is_subnormal</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_subnormal" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 비정상이면 <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.is_zero">
<code class="descname">is_zero</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_zero" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 가 0이면 <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.ln">
<code class="descname">ln</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.ln" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 의 자연 로그(밑 e)를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.log10">
<code class="descname">log10</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.log10" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 의 상용 로그를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logb">
<code class="descname">logb</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logb" title="정의 주소">¶</a></dt>
<dd><p>피연산자의 최상위 유효 숫자의 크기의 지수를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logical_and">
<code class="descname">logical_and</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_and" title="정의 주소">¶</a></dt>
<dd><p>각 피연산자의 자릿수 별로 논리적 연산 <em>and</em> 를 적용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logical_invert">
<code class="descname">logical_invert</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_invert" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 의 모든 자릿수를 반전합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logical_or">
<code class="descname">logical_or</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_or" title="정의 주소">¶</a></dt>
<dd><p>각 피연산자의 자릿수 별로 논리적 연산 <em>or</em> 를 적용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.logical_xor">
<code class="descname">logical_xor</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_xor" title="정의 주소">¶</a></dt>
<dd><p>각 피연산자의 자릿수 별로 논리적 연산 <em>xor</em> 를 적용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.max" title="정의 주소">¶</a></dt>
<dd><p>두 값을 수치 적으로 비교해, 최대값을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.max_mag">
<code class="descname">max_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.max_mag" title="정의 주소">¶</a></dt>
<dd><p>부호를 무시하고 값을 수치 적으로 비교합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.min" title="정의 주소">¶</a></dt>
<dd><p>두 값을 수치 적으로 비교해, 최소값을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.min_mag">
<code class="descname">min_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.min_mag" title="정의 주소">¶</a></dt>
<dd><p>부호를 무시하고 값을 수치 적으로 비교합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.minus">
<code class="descname">minus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.minus" title="정의 주소">¶</a></dt>
<dd><p>minus는 파이썬에서 단항 접두사 빼기 연산자에 해당합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.multiply">
<code class="descname">multiply</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.multiply" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 와 <em>y</em> 의 곱을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.next_minus">
<code class="descname">next_minus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_minus" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 보다 작고 표현 가능한 가장 큰 수를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.next_plus">
<code class="descname">next_plus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_plus" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 보다 크고 표현 가능한 가장 작은 수를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.next_toward">
<code class="descname">next_toward</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_toward" title="정의 주소">¶</a></dt>
<dd><p><em>y</em> 방향으로 <em>x</em> 에 가장 가까운 숫자를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.normalize" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 를 가장 간단한 형태로 환원합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.number_class">
<code class="descname">number_class</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.number_class" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 의 클래스를 가리키는 문자열을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.plus">
<code class="descname">plus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.plus" title="정의 주소">¶</a></dt>
<dd><p>plus는 파이썬에서 단항 접두사 더하기 연산자에 해당합니다. 이 연산은 컨텍스트 정밀도와 자리 올림을 적용하므로 항등 연산이 <em>아닙니다</em>.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.power">
<code class="descname">power</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>modulo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.power" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">x</span></code> 의 <code class="docutils literal"><span class="pre">y</span></code> 거듭 제곱을 돌려줍니다. 주어지면 <code class="docutils literal"><span class="pre">modulo</span></code> 모듈로로 환원합니다.</p>
<p>두 인자로는 <code class="docutils literal"><span class="pre">x**y</span></code> 를 계산합니다. <code class="docutils literal"><span class="pre">x</span></code> 가 음수면 <code class="docutils literal"><span class="pre">y</span></code> 는 정수여야 합니다. <code class="docutils literal"><span class="pre">y</span></code> 가 정수이고 결과가 유한하고 'precision' 자릿수로 정확하게 표현될 수 있지 않은 이상 결과는 부정확합니다. 컨텍스트의 자리 올림 모드가 사용됩니다. 결과는 항상 파이썬 버전에서 정확하게 자리 올림됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>C 모듈은 올바르게 자리 올림된 <a class="reference internal" href="#decimal.Context.exp" title="decimal.Context.exp"><code class="xref py py-meth docutils literal"><span class="pre">exp()</span></code></a> 와 <a class="reference internal" href="#decimal.Context.ln" title="decimal.Context.ln"><code class="xref py py-meth docutils literal"><span class="pre">ln()</span></code></a> 함수로 <a class="reference internal" href="#decimal.Context.power" title="decimal.Context.power"><code class="xref py py-meth docutils literal"><span class="pre">power()</span></code></a> 를 계산합니다. 결과는 잘 정의되어 있지만 &quot;거의 항상 올바르게 자리 올림될&quot; 뿐 입니다.</p>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">C 버전은 <code class="docutils literal"><span class="pre">x**y</span></code> 를 <code class="docutils literal"><span class="pre">exp(y</span> <span class="pre">*</span> <span class="pre">ln(x))</span></code> 의 형태로 계산한다는 뜻입니다. 이 과정에서
중간 자리 올림이 발생할 수 있는데, 언제나 올바르게 자리 올림된다는 보장은 없다는 뜻입니다.</p>
</div>
<p>세 인자로는 <code class="docutils literal"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code> 를 계산합니다. 세 인자 형식의 경우, 인자에 다음과 같은 제한이 있습니다:</p>
<blockquote>
<div><ul class="simple">
<li>세 인자는 모두 정수여야 합니다.</li>
<li><code class="docutils literal"><span class="pre">y</span></code> 는 음수가 아니어야 합니다.</li>
<li><code class="docutils literal"><span class="pre">x</span></code> 나 <code class="docutils literal"><span class="pre">y</span></code> 중 적어도 하나는 0이 아니어야 합니다</li>
<li><code class="docutils literal"><span class="pre">modulo</span></code> 는 0이 아니고 최대 'precision' 자릿수를 가져야합니다</li>
</ul>
</div></blockquote>
<p><code class="docutils literal"><span class="pre">Context.power(x,</span> <span class="pre">y,</span> <span class="pre">modulo)</span></code> 의 결과 값은 무한 정밀도로 <code class="docutils literal"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code> 를 계산할 때 얻을 수 있는 값과 동일하지만, 더 효율적으로 계산됩니다. 결과의 지수는 <code class="docutils literal"><span class="pre">x</span></code>, <code class="docutils literal"><span class="pre">y</span></code> 및 <code class="docutils literal"><span class="pre">modulo</span></code> 의 지수에 관계없이 0입니다. 결과는 항상 정확합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.quantize">
<code class="descname">quantize</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.quantize" title="정의 주소">¶</a></dt>
<dd><p><em>y</em> 의 지수를 가지는 (자리올림 된) <em>x</em> 와 같은 값을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.radix">
<code class="descname">radix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.radix" title="정의 주소">¶</a></dt>
<dd><p>Decimal이기 때문에 단지 10을 반환합니다, :)</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.remainder">
<code class="descname">remainder</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.remainder" title="정의 주소">¶</a></dt>
<dd><p>정수 나눗셈의 나머지를 반환합니다.</p>
<p>결과가 0이 아닐 때, 결과의 부호는 원래의 피제수와 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.remainder_near">
<code class="descname">remainder_near</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.remainder_near" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">n</span></code> 을 반환하는데, <em>n</em> 은 <code class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> 의 정확한 값에 가장 가까운 정수입니다 (결과가 0이면 그 부호는 <em>x</em> 의 부호가 됩니다).</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.rotate" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 를 <em>y</em> 번 회전한 복사본을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.same_quantum">
<code class="descname">same_quantum</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.same_quantum" title="정의 주소">¶</a></dt>
<dd><p>두 피연산자의 지수가 같으면 <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.scaleb">
<code class="descname">scaleb</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.scaleb" title="정의 주소">¶</a></dt>
<dd><p>첫 번째 피연산자의 지수에 두 번째 값을 더해서 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.shift">
<code class="descname">shift</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.shift" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 를 <em>y</em> 번 이동한 복사본을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.sqrt">
<code class="descname">sqrt</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.sqrt" title="정의 주소">¶</a></dt>
<dd><p>음이 아닌 수의 제곱근을 컨텍스트의 정밀도로 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.subtract">
<code class="descname">subtract</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.subtract" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 와 <em>y</em> 의 차를 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.to_eng_string">
<code class="descname">to_eng_string</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_eng_string" title="정의 주소">¶</a></dt>
<dd><p>문자열로 변환합니다. 지수가 필요하면 공학 표기법을 사용합니다.</p>
<p>공학 표기법의 지수는 3의 배수입니다. 이렇게 하면 소수점 왼쪽에 최대 3 자리를 남기게되고, 하나나 두 개의 후행 0을 추가해야 할 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.to_integral_exact">
<code class="descname">to_integral_exact</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_integral_exact" title="정의 주소">¶</a></dt>
<dd><p>정수로 자리 올림합니다.</p>
</dd></dl>

<dl class="method">
<dt id="decimal.Context.to_sci_string">
<code class="descname">to_sci_string</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_sci_string" title="정의 주소">¶</a></dt>
<dd><p>과학 표기법을 사용하여 숫자를 문자열로 변환합니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="constants">
<span id="decimal-rounding-modes"></span><h2>9.4.4. 상수<a class="headerlink" href="#constants" title="제목 주소">¶</a></h2>
<p>이 절의 상수는 C 모듈에서만 의미가 있습니다. 호환성을 위해 순수 파이썬 버전에도 포함되어 있습니다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="29%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">32-비트</th>
<th class="head">64-비트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><dl class="first last data">
<dt id="decimal.MAX_PREC">
<code class="descclassname">decimal.</code><code class="descname">MAX_PREC</code><a class="headerlink" href="#decimal.MAX_PREC" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><code class="xref py py-const docutils literal"><span class="pre">425000000</span></code></td>
<td><code class="xref py py-const docutils literal"><span class="pre">999999999999999999</span></code></td>
</tr>
<tr class="row-odd"><td><dl class="first last data">
<dt id="decimal.MAX_EMAX">
<code class="descclassname">decimal.</code><code class="descname">MAX_EMAX</code><a class="headerlink" href="#decimal.MAX_EMAX" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><code class="xref py py-const docutils literal"><span class="pre">425000000</span></code></td>
<td><code class="xref py py-const docutils literal"><span class="pre">999999999999999999</span></code></td>
</tr>
<tr class="row-even"><td><dl class="first last data">
<dt id="decimal.MIN_EMIN">
<code class="descclassname">decimal.</code><code class="descname">MIN_EMIN</code><a class="headerlink" href="#decimal.MIN_EMIN" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><code class="xref py py-const docutils literal"><span class="pre">-425000000</span></code></td>
<td><code class="xref py py-const docutils literal"><span class="pre">-999999999999999999</span></code></td>
</tr>
<tr class="row-odd"><td><dl class="first last data">
<dt id="decimal.MIN_ETINY">
<code class="descclassname">decimal.</code><code class="descname">MIN_ETINY</code><a class="headerlink" href="#decimal.MIN_ETINY" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</td>
<td><code class="xref py py-const docutils literal"><span class="pre">-849999999</span></code></td>
<td><code class="xref py py-const docutils literal"><span class="pre">-1999999999999999997</span></code></td>
</tr>
</tbody>
</table>
<dl class="data">
<dt id="decimal.HAVE_THREADS">
<code class="descclassname">decimal.</code><code class="descname">HAVE_THREADS</code><a class="headerlink" href="#decimal.HAVE_THREADS" title="정의 주소">¶</a></dt>
<dd><p>기본값은 <code class="docutils literal"><span class="pre">True</span></code> 입니다. 파이썬이 스레드없이 컴파일되면, C 버전은 값 비싼 스레드 로컬 컨텍스트 사용을 자동으로 비활성화시킵니다. 이 경우 값은 <code class="docutils literal"><span class="pre">False</span></code> 입니다.</p>
</dd></dl>

</div>
<div class="section" id="rounding-modes">
<h2>9.4.5. 자리 올림 모드<a class="headerlink" href="#rounding-modes" title="제목 주소">¶</a></h2>
<dl class="data">
<dt id="decimal.ROUND_CEILING">
<code class="descclassname">decimal.</code><code class="descname">ROUND_CEILING</code><a class="headerlink" href="#decimal.ROUND_CEILING" title="정의 주소">¶</a></dt>
<dd><p><code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code> 을 향해 올립니다.</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_DOWN">
<code class="descclassname">decimal.</code><code class="descname">ROUND_DOWN</code><a class="headerlink" href="#decimal.ROUND_DOWN" title="정의 주소">¶</a></dt>
<dd><p>0을 향해 자리 올림합니다.</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_FLOOR">
<code class="descclassname">decimal.</code><code class="descname">ROUND_FLOOR</code><a class="headerlink" href="#decimal.ROUND_FLOOR" title="정의 주소">¶</a></dt>
<dd><p><code class="xref py py-const docutils literal"><span class="pre">-Infinity</span></code> 를 향해 내립니다.</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_HALF_DOWN">
<code class="descclassname">decimal.</code><code class="descname">ROUND_HALF_DOWN</code><a class="headerlink" href="#decimal.ROUND_HALF_DOWN" title="정의 주소">¶</a></dt>
<dd><p>가장 가까운 값으로 반올림하고, 동률이면 0 에서 가까운 것을 선택합니다.</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_HALF_EVEN">
<code class="descclassname">decimal.</code><code class="descname">ROUND_HALF_EVEN</code><a class="headerlink" href="#decimal.ROUND_HALF_EVEN" title="정의 주소">¶</a></dt>
<dd><p>가장 가까운 값으로 반올림하고, 동률이면 짝수를 선택합니다.</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_HALF_UP">
<code class="descclassname">decimal.</code><code class="descname">ROUND_HALF_UP</code><a class="headerlink" href="#decimal.ROUND_HALF_UP" title="정의 주소">¶</a></dt>
<dd><p>가장 가까운 값으로 반올림하고, 동률이면 0 에서 먼 것을 선택합니다.</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_UP">
<code class="descclassname">decimal.</code><code class="descname">ROUND_UP</code><a class="headerlink" href="#decimal.ROUND_UP" title="정의 주소">¶</a></dt>
<dd><p>0에서 먼 쪽으로 자리 올림합니다.</p>
</dd></dl>

<dl class="data">
<dt id="decimal.ROUND_05UP">
<code class="descclassname">decimal.</code><code class="descname">ROUND_05UP</code><a class="headerlink" href="#decimal.ROUND_05UP" title="정의 주소">¶</a></dt>
<dd><p>0을 향해 자리 올림했을 때 마지막 숫자가 0 이나 5면 0에서 먼 쪽으로 자리 올림합니다. 그렇지 않으면 0을 향해 자리 올림합니다.</p>
</dd></dl>

</div>
<div class="section" id="signals">
<span id="decimal-signals"></span><h2>9.4.6. 신호<a class="headerlink" href="#signals" title="제목 주소">¶</a></h2>
<p>신호는 계산 중 발생하는 조건을 나타냅니다. 각각은 하나의 컨텍스트 플래그 와 하나의 컨텍스트 트랩 활성화기에 대응합니다.</p>
<p>컨텍스트 플래그는 조건이 발생할 때마다 설정됩니다. 계산 후에, 플래그는 정보를 얻기위한 목적으로 확인될 수 있습니다 (예를 들어, 계산이 정확한지를 판별하기 위해). 플래그를 확인한 후 다음 계산을 시작하기 전에 모든 플래그를 지우십시오.</p>
<p>컨텍스트의 트랩 홀성화기가 신호에 대해 설정되면, 조건은 파이썬 예외를 일으킵니다. 예를 들어, <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal"><span class="pre">DivisionByZero</span></code></a> 트랩이 설정되면, 이 조건을 만날 때 <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal"><span class="pre">DivisionByZero</span></code></a> 예외가 발생합니다.</p>
<dl class="class">
<dt id="decimal.Clamped">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Clamped</code><a class="headerlink" href="#decimal.Clamped" title="정의 주소">¶</a></dt>
<dd><p>표현 제약 조건에 맞도록 지수를 변경했습니다.</p>
<p>일반적으로, 지수가 컨텍스트의 <code class="xref py py-attr docutils literal"><span class="pre">Emin</span></code> 과 <code class="xref py py-attr docutils literal"><span class="pre">Emax</span></code> 한계를 벗어날 때 클램핑이 발생합니다. 가능하면, 계수에 0을 추가하여 지수를 줄입니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.DecimalException">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">DecimalException</code><a class="headerlink" href="#decimal.DecimalException" title="정의 주소">¶</a></dt>
<dd><p>다른 신호의 베이스 클래스이고 <a class="reference internal" href="exceptions.html#ArithmeticError" title="ArithmeticError"><code class="xref py py-exc docutils literal"><span class="pre">ArithmeticError</span></code></a> 의 서브 클래스입니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.DivisionByZero">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">DivisionByZero</code><a class="headerlink" href="#decimal.DivisionByZero" title="정의 주소">¶</a></dt>
<dd><p>무한이 아닌 숫자를 0으로 나눴다는 신호를 줍니다.</p>
<p>나눗셈, 모듈로 나눗셈 또는 음수로 숫자를 거듭제곱할 때 발생할 수 있습니다. 이 신호가 트랩되지 않으면, 계산에 제공된 입력의 부호에 따라 <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code> 나 <code class="xref py py-const docutils literal"><span class="pre">-Infinity</span></code> 를 돌려줍니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.Inexact">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Inexact</code><a class="headerlink" href="#decimal.Inexact" title="정의 주소">¶</a></dt>
<dd><p>자리 올림이 발생했고 결과가 정확하지 않음을 나타냅니다.</p>
<p>자리 올림 도중 0이 아닌 숫자가 삭제 된 경우 신호를 줍니다. 자리 올림된 결과가 반환됩니다. 신호 플래그나 트랩은 결과가 정확하지 않을 때를 감지하는 데 사용됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.InvalidOperation">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">InvalidOperation</code><a class="headerlink" href="#decimal.InvalidOperation" title="정의 주소">¶</a></dt>
<dd><p>유효하지 않은 연산이 수행되었습니다.</p>
<p>의미가없는 연산이 요청되었음을 나타냅니다. 트랩되지 않으면, <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> 을 반환합니다. 가능한 원인은 다음과 같습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">Infinity</span> <span class="o">-</span> <span class="n">Infinity</span>
<span class="mi">0</span> <span class="o">*</span> <span class="n">Infinity</span>
<span class="n">Infinity</span> <span class="o">/</span> <span class="n">Infinity</span>
<span class="n">x</span> <span class="o">%</span> <span class="mi">0</span>
<span class="n">Infinity</span> <span class="o">%</span> <span class="n">x</span>
<span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="o">**</span> <span class="mi">0</span>
<span class="n">x</span> <span class="o">**</span> <span class="p">(</span><span class="n">non</span><span class="o">-</span><span class="n">integer</span><span class="p">)</span>
<span class="n">x</span> <span class="o">**</span> <span class="n">Infinity</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">정수가 아닌 값이나 무한대로 거듭제곱하는 경우는 <code class="docutils literal"><span class="pre">x</span></code> 가 음수일 때만 해당됩니다. 정수가
아닌 값으로 음수를 거듭제곱하면 복소수가 되고, 무한대로 <code class="docutils literal"><span class="pre">-1</span></code> 보다 작거나 같은 음수를
거듭제곱하면 부호가 결정되지 않기 때문입니다. <code class="docutils literal"><span class="pre">-1</span></code> 보다 큰 음수를 무한대로 거듭제곱하면
<code class="docutils literal"><span class="pre">0</span></code> 이지만, 이 경우도 <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal"><span class="pre">InvalidOperation</span></code></a> 신호를 줍니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="decimal.Overflow">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Overflow</code><a class="headerlink" href="#decimal.Overflow" title="정의 주소">¶</a></dt>
<dd><p>수치적 오버 플로우.</p>
<p>자리 올림후에 지수가 <code class="xref py py-attr docutils literal"><span class="pre">Emax</span></code> 보다 큼을 나타냅니다. 트랩되지 않으면, 결과는 자리 올림 모드에 따라 달라지는데, 가장 큰 표현 가능한 유한 수로 안쪽으로 당기거나 <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code> 를 향해 바깥쪽으로 자리 올림됩니다. 두 경우 모두 <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal"><span class="pre">Inexact</span></code></a> 와 <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-class docutils literal"><span class="pre">Rounded</span></code></a> 신호도 줍니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.Rounded">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Rounded</code><a class="headerlink" href="#decimal.Rounded" title="정의 주소">¶</a></dt>
<dd><p>정보가 손실되지는 않았지만 자리 올림이 발생했습니다.</p>
<p>자리 올림이 자릿수를 버일 때마다 신호를 줍니다; 그 자릿수가 0 일때도 그렇습니다 (가령 <code class="xref py py-const docutils literal"><span class="pre">5.00</span></code> 을 <code class="xref py py-const docutils literal"><span class="pre">5.0</span></code> 로 자리 올림). 트랩되지 않으면, 결과를 그대로 반환합니다. 이 신호는 유효숫자의 손실을 감지하는 데 사용됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.Subnormal">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Subnormal</code><a class="headerlink" href="#decimal.Subnormal" title="정의 주소">¶</a></dt>
<dd><p>자리 올림 전에 지수가 <code class="xref py py-attr docutils literal"><span class="pre">Emin</span></code> 보다 작습니다.</p>
<p>연산 결과가 비정상(지수가 너무 작음)일 때 발생합니다. 트랩되지 않으면, 결과를 그대로 반환합니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.Underflow">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Underflow</code><a class="headerlink" href="#decimal.Underflow" title="정의 주소">¶</a></dt>
<dd><p>결과가 0으로 자리 올림되는 수치적 언더 플로우.</p>
<p>자리 올림에 의해 비정상 결과가 0으로 푸시 될 때 발생합니다. <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal"><span class="pre">Inexact</span></code></a> 과 <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-class docutils literal"><span class="pre">Subnormal</span></code></a> 신호도 줍니다.</p>
</dd></dl>

<dl class="class">
<dt id="decimal.FloatOperation">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">FloatOperation</code><a class="headerlink" href="#decimal.FloatOperation" title="정의 주소">¶</a></dt>
<dd><p>float와 Decimal을 혼합하는 데 더 엄격한 의미를 사용합니다.</p>
<p>신호가 트랩되지 않으면 (기본값), <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> 생성자, <a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal"><span class="pre">create_decimal()</span></code></a> 및 모든 비교 연산자에서 float와 Decimal을 혼합 할 수 있습니다. 변환과 비교 모두 정확합니다. 복합 연산의 발생은 컨텍스트 플래그에 <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal"><span class="pre">FloatOperation</span></code></a> 을 설정하여 조용히 기록됩니다. <a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal"><span class="pre">from_float()</span></code></a> 나 <a class="reference internal" href="#decimal.Context.create_decimal_from_float" title="decimal.Context.create_decimal_from_float"><code class="xref py py-meth docutils literal"><span class="pre">create_decimal_from_float()</span></code></a> 를 사용한 명시적 변환은 플래그를 설정하지 않습니다.</p>
<p>그렇지 않으면 (신호가 트랩되면), 같음 비교와 명시적 변환만 조용히 수행됩니다. 다른 모든 혼합된 연산은 <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal"><span class="pre">FloatOperation</span></code></a> 을 발생시킵니다.</p>
</dd></dl>

<p>다음 표는 신호의 계층 구조를 요약한 것입니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">exceptions</span><span class="o">.</span><span class="n">ArithmeticError</span><span class="p">(</span><span class="n">exceptions</span><span class="o">.</span><span class="n">Exception</span><span class="p">)</span>
    <span class="n">DecimalException</span>
        <span class="n">Clamped</span>
        <span class="n">DivisionByZero</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ZeroDivisionError</span><span class="p">)</span>
        <span class="n">Inexact</span>
            <span class="n">Overflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">)</span>
            <span class="n">Underflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">,</span> <span class="n">Subnormal</span><span class="p">)</span>
        <span class="n">InvalidOperation</span>
        <span class="n">Rounded</span>
        <span class="n">Subnormal</span>
        <span class="n">FloatOperation</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TypeError</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="floating-point-notes">
<span id="decimal-notes"></span><h2>9.4.7. 부동 소수점 노트<a class="headerlink" href="#floating-point-notes" title="제목 주소">¶</a></h2>
<div class="section" id="mitigating-round-off-error-with-increased-precision">
<h3>9.4.7.1. 증가된 정밀도로 자리 올림 오차 줄이기<a class="headerlink" href="#mitigating-round-off-error-with-increased-precision" title="제목 주소">¶</a></h3>
<p>The use of decimal floating point eliminates decimal representation error
(making it possible to represent <code class="xref py py-const docutils literal"><span class="pre">0.1</span></code> exactly); however, some operations
can still incur round-off error when non-zero digits exceed the fixed precision.</p>
<p>The effects of round-off error can be amplified by the addition or subtraction
of nearly offsetting quantities resulting in loss of significance.  Knuth
provides two instructive examples where rounded floating point arithmetic with
insufficient precision causes the breakdown of the associative and distributive
properties of addition:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># Examples from Seminumerical Algorithms, Section 4.2.2.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">getcontext</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">8</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.51111111&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;9.5111111&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.0000003&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.01&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.0060000&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> module makes it possible to restore the identities by
expanding the precision sufficiently to avoid loss of significance:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.51111111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="go">Decimal(&#39;9.51111111&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;9.51111111&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.0000003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
</pre></div>
</div>
</div>
<div class="section" id="special-values">
<h3>9.4.7.2. 특수 값<a class="headerlink" href="#special-values" title="제목 주소">¶</a></h3>
<p>The number system for the <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> module provides special values
including <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>, <code class="xref py py-const docutils literal"><span class="pre">sNaN</span></code>, <code class="xref py py-const docutils literal"><span class="pre">-Infinity</span></code>, <code class="xref py py-const docutils literal"><span class="pre">Infinity</span></code>,
and two zeros, <code class="xref py py-const docutils literal"><span class="pre">+0</span></code> and <code class="xref py py-const docutils literal"><span class="pre">-0</span></code>.</p>
<p>Infinities can be constructed directly with:  <code class="docutils literal"><span class="pre">Decimal('Infinity')</span></code>. Also,
they can arise from dividing by zero when the <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal"><span class="pre">DivisionByZero</span></code></a> signal is
not trapped.  Likewise, when the <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-exc docutils literal"><span class="pre">Overflow</span></code></a> signal is not trapped, infinity
can result from rounding beyond the limits of the largest representable number.</p>
<p>The infinities are signed (affine) and can be used in arithmetic operations
where they get treated as very large, indeterminate numbers.  For instance,
adding a constant to infinity gives another infinite result.</p>
<p>Some operations are indeterminate and return <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>, or if the
<a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal"><span class="pre">InvalidOperation</span></code></a> signal is trapped, raise an exception.  For example,
<code class="docutils literal"><span class="pre">0/0</span></code> returns <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> which means &quot;not a number&quot;.  This variety of
<code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> is quiet and, once created, will flow through other computations
always resulting in another <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>.  This behavior can be useful for a
series of computations that occasionally have missing inputs --- it allows the
calculation to proceed while flagging specific results as invalid.</p>
<p>A variant is <code class="xref py py-const docutils literal"><span class="pre">sNaN</span></code> which signals rather than remaining quiet after every
operation.  This is a useful return value when an invalid result needs to
interrupt a calculation for special handling.</p>
<p>The behavior of Python's comparison operators can be a little surprising where a
<code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> is involved.  A test for equality where one of the operands is a
quiet or signaling <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> always returns <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> (even when doing
<code class="docutils literal"><span class="pre">Decimal('NaN')==Decimal('NaN')</span></code>), while a test for inequality always returns
<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>.  An attempt to compare two Decimals using any of the <code class="docutils literal"><span class="pre">&lt;</span></code>,
<code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code> or <code class="docutils literal"><span class="pre">&gt;=</span></code> operators will raise the <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal"><span class="pre">InvalidOperation</span></code></a> signal
if either operand is a <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code>, and return <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a> if this signal is
not trapped.  Note that the General Decimal Arithmetic specification does not
specify the behavior of direct comparisons; these rules for comparisons
involving a <code class="xref py py-const docutils literal"><span class="pre">NaN</span></code> were taken from the IEEE 854 standard (see Table 3 in
section 5.7).  To ensure strict standards-compliance, use the <code class="xref py py-meth docutils literal"><span class="pre">compare()</span></code>
and <code class="xref py py-meth docutils literal"><span class="pre">compare-signal()</span></code> methods instead.</p>
<p>The signed zeros can result from calculations that underflow. They keep the sign
that would have resulted if the calculation had been carried out to greater
precision.  Since their magnitude is zero, both positive and negative zeros are
treated as equal and their sign is informational.</p>
<p>In addition to the two signed zeros which are distinct yet equal, there are
various representations of zero with differing precisions yet equivalent in
value.  This takes a bit of getting used to.  For an eye accustomed to
normalized floating point representations, it is not immediately obvious that
the following calculation returns a value equal to zero:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;Infinity&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;0E-1000026&#39;)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="working-with-threads">
<span id="decimal-threads"></span><h2>9.4.8. 스레드로 작업하기<a class="headerlink" href="#working-with-threads" title="제목 주소">¶</a></h2>
<p>The <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a> function accesses a different <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal"><span class="pre">Context</span></code></a> object for
each thread.  Having separate thread contexts means that threads may make
changes (such as <code class="docutils literal"><span class="pre">getcontext().prec=10</span></code>) without interfering with other threads.</p>
<p>Likewise, the <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal"><span class="pre">setcontext()</span></code></a> function automatically assigns its target to
the current thread.</p>
<p>If <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal"><span class="pre">setcontext()</span></code></a> has not been called before <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a>, then
<a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a> will automatically create a new context for use in the
current thread.</p>
<p>The new context is copied from a prototype context called <em>DefaultContext</em>. To
control the defaults so that each thread will use the same values throughout the
application, directly modify the <em>DefaultContext</em> object. This should be done
<em>before</em> any threads are started so that there won't be a race condition between
threads calling <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal"><span class="pre">getcontext()</span></code></a>. For example:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># Set applicationwide defaults for all threads about to be launched</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_DOWN</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span> <span class="o">=</span> <span class="n">ExtendedContext</span><span class="o">.</span><span class="n">traps</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">InvalidOperation</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">setcontext</span><span class="p">(</span><span class="n">DefaultContext</span><span class="p">)</span>

<span class="c1"># Afterwards, the threads can be started</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t3</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
 <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="recipes">
<span id="decimal-recipes"></span><h2>9.4.9. 조리법<a class="headerlink" href="#recipes" title="제목 주소">¶</a></h2>
<p>Here are a few recipes that serve as utility functions and that demonstrate ways
to work with the <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a> class:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">moneyfmt</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">curr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span>
             <span class="n">pos</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">trailneg</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert Decimal to a money formatted string.</span>

<span class="sd">    places:  required number of places after the decimal point</span>
<span class="sd">    curr:    optional currency symbol before the sign (may be blank)</span>
<span class="sd">    sep:     optional grouping separator (comma, period, space, or blank)</span>
<span class="sd">    dp:      decimal point indicator (comma or period)</span>
<span class="sd">             only specify as blank when places is zero</span>
<span class="sd">    pos:     optional sign for positive numbers: &#39;+&#39;, space or blank</span>
<span class="sd">    neg:     optional sign for negative numbers: &#39;-&#39;, &#39;(&#39;, space or blank</span>
<span class="sd">    trailneg:optional trailing minus indicator:  &#39;-&#39;, &#39;)&#39;, space or blank</span>

<span class="sd">    &gt;&gt;&gt; d = Decimal(&#39;-1234567.8901&#39;)</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;)</span>
<span class="sd">    &#39;-$1,234,567.89&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, places=0, sep=&#39;.&#39;, dp=&#39;&#39;, neg=&#39;&#39;, trailneg=&#39;-&#39;)</span>
<span class="sd">    &#39;1.234.568-&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;, neg=&#39;(&#39;, trailneg=&#39;)&#39;)</span>
<span class="sd">    &#39;($1,234,567.89)&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(123456789), sep=&#39; &#39;)</span>
<span class="sd">    &#39;123 456 789.00&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(&#39;-0.02&#39;), neg=&#39;&lt;&#39;, trailneg=&#39;&gt;&#39;)</span>
<span class="sd">    &#39;&lt;0.02&gt;&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="n">places</span>      <span class="c1"># 2 places --&gt; &#39;0.01&#39;</span>
    <span class="n">sign</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">as_tuple</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">digits</span><span class="p">))</span>
    <span class="n">build</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">pop</span>
    <span class="k">if</span> <span class="n">sign</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">trailneg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">places</span><span class="p">):</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">()</span> <span class="k">if</span> <span class="n">digits</span> <span class="k">else</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">places</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">digits</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">build</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">neg</span> <span class="k">if</span> <span class="n">sign</span> <span class="k">else</span> <span class="n">pos</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">pi</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compute Pi to the current precision.</span>

<span class="sd">    &gt;&gt;&gt; print(pi())</span>
<span class="sd">    3.141592653589793238462643383</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># extra digits for intermediate steps</span>
    <span class="n">three</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>      <span class="c1"># substitute &quot;three=3.0&quot; for regular floats</span>
    <span class="n">lasts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">three</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">24</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">na</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="n">na</span><span class="p">,</span> <span class="n">na</span><span class="o">+</span><span class="mi">8</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="n">d</span><span class="o">+</span><span class="n">da</span><span class="p">,</span> <span class="n">da</span><span class="o">+</span><span class="mi">32</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>               <span class="c1"># unary plus applies the new precision</span>

<span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return e raised to the power of x.  Result type matches input type.</span>

<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(1)))</span>
<span class="sd">    2.718281828459045235360287471</span>
<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(2)))</span>
<span class="sd">    7.389056098930650227230427461</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2.0))</span>
<span class="sd">    7.38905609893</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2+0j))</span>
<span class="sd">    (7.38905609893+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the cosine of x as measured in radians.</span>

<span class="sd">    The Taylor series approximation works best for a small value of x.</span>
<span class="sd">    For larger values, first compute x = x % (2 * pi).</span>

<span class="sd">    &gt;&gt;&gt; print(cos(Decimal(&#39;0.5&#39;)))</span>
<span class="sd">    0.8775825618903727161162815826</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5))</span>
<span class="sd">    0.87758256189</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5+0j))</span>
<span class="sd">    (0.87758256189+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the sine of x as measured in radians.</span>

<span class="sd">    The Taylor series approximation works best for a small value of x.</span>
<span class="sd">    For larger values, first compute x = x % (2 * pi).</span>

<span class="sd">    &gt;&gt;&gt; print(sin(Decimal(&#39;0.5&#39;)))</span>
<span class="sd">    0.4794255386042030002732879352</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5))</span>
<span class="sd">    0.479425538604</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5+0j))</span>
<span class="sd">    (0.479425538604+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>
</pre></div>
</div>
</div>
<div class="section" id="decimal-faq">
<span id="id1"></span><h2>9.4.10. Decimal FAQ<a class="headerlink" href="#decimal-faq" title="제목 주소">¶</a></h2>
<p>Q. It is cumbersome to type <code class="docutils literal"><span class="pre">decimal.Decimal('1234.5')</span></code>.  Is there a way to
minimize typing when using the interactive interpreter?</p>
<p>A. Some users abbreviate the constructor to just a single letter:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">(</span><span class="s1">&#39;1.23&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">D</span><span class="p">(</span><span class="s1">&#39;3.45&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.68&#39;)</span>
</pre></div>
</div>
<p>Q. In a fixed-point application with two decimal places, some inputs have many
places and need to be rounded.  Others are not supposed to have excess digits
and need to be validated.  What methods should be used?</p>
<p>A. The <code class="xref py py-meth docutils literal"><span class="pre">quantize()</span></code> method rounds to a fixed number of decimal places. If
the <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal"><span class="pre">Inexact</span></code></a> trap is set, it is also useful for validation:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">TWOPLACES</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>       <span class="c1"># same as Decimal(&#39;0.01&#39;)</span>
</pre></div>
</div>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Round to two places</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.214&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.21&#39;)</span>
</pre></div>
</div>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Validate that a number does not exceed two places</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.21&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="go">Decimal(&#39;3.21&#39;)</span>
</pre></div>
</div>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.214&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<p>Q. Once I have valid two place inputs, how do I maintain that invariant
throughout an application?</p>
<p>A. Some operations like addition, subtraction, and multiplication by an integer
will automatically preserve fixed point.  Others operations, like division and
non-integer multiplication, will change the number of decimal places and need to
be followed-up with a <code class="xref py py-meth docutils literal"><span class="pre">quantize()</span></code> step:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;102.72&#39;</span><span class="p">)</span>           <span class="c1"># Initial fixed-point values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.17&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>                           <span class="c1"># Addition preserves fixed-point</span>
<span class="go">Decimal(&#39;105.89&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
<span class="go">Decimal(&#39;99.55&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">42</span>                          <span class="c1"># So does integer multiplication</span>
<span class="go">Decimal(&#39;4314.24&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># Must quantize non-integer multiplication</span>
<span class="go">Decimal(&#39;325.62&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># And quantize division</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
</pre></div>
</div>
<p>In developing fixed-point applications, it is convenient to define functions
to handle the <code class="xref py py-meth docutils literal"><span class="pre">quantize()</span></code> step:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>                       <span class="c1"># Automatically preserve fixed-point</span>
<span class="go">Decimal(&#39;325.62&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">div</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
</pre></div>
</div>
<p>Q. There are many ways to express the same value.  The numbers <code class="xref py py-const docutils literal"><span class="pre">200</span></code>,
<code class="xref py py-const docutils literal"><span class="pre">200.000</span></code>, <code class="xref py py-const docutils literal"><span class="pre">2E2</span></code>, and <code class="xref py py-const docutils literal"><span class="pre">02E+4</span></code> all have the same value at
various precisions. Is there a way to transform them to a single recognizable
canonical value?</p>
<p>A. The <code class="xref py py-meth docutils literal"><span class="pre">normalize()</span></code> method maps all equivalent values to a single
representative:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">&#39;200 200.000 2E2 .02E+4&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
<span class="go">[Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;)]</span>
</pre></div>
</div>
<p>Q. Some decimal values always print with exponential notation.  Is there a way
to get a non-exponential representation?</p>
<p>A. For some values, exponential notation is the only way to express the number
of significant places in the coefficient.  For example, expressing
<code class="xref py py-const docutils literal"><span class="pre">5.0E+3</span></code> as <code class="xref py py-const docutils literal"><span class="pre">5000</span></code> keeps the value constant but cannot show the
original's two-place significance.</p>
<p>If an application does not care about tracking significance, it is easy to
remove the exponent and trailing zeroes, losing significance, but keeping the
value unchanged:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">remove_exponent</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">to_integral</span><span class="p">()</span> <span class="k">else</span> <span class="n">d</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">remove_exponent</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;5E+3&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;5000&#39;)</span>
</pre></div>
</div>
<p>Q. Is there a way to convert a regular float to a <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>?</p>
<p>A. Yes, any binary floating point number can be exactly expressed as a
Decimal though an exact conversion may take more precision than intuition would
suggest:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.141592653589793115997963468544185161590576171875&#39;)</span>
</pre></div>
</div>
<p>Q. Within a complex calculation, how can I make sure that I haven't gotten a
spurious result because of insufficient precision or rounding anomalies.</p>
<p>A. The decimal module makes it easy to test results.  A best practice is to
re-run calculations using greater precision and with various rounding modes.
Widely differing results indicate insufficient precision, rounding mode issues,
ill-conditioned inputs, or a numerically unstable algorithm.</p>
<p>Q. I noticed that context precision is applied to the results of operations but
not to the inputs.  Is there anything to watch out for when mixing values of
different precisions?</p>
<p>A. Yes.  The principle is that all values are considered to be exact and so is
the arithmetic on those values.  Only the results are rounded.  The advantage
for inputs is that &quot;what you type is what you get&quot;.  A disadvantage is that the
results can look odd if you forget that the inputs haven't been rounded:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.104&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.104&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.21&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.104&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.000&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.104&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.20&#39;)</span>
</pre></div>
</div>
<p>The solution is either to increase precision or to force rounding of inputs
using the unary plus operation:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">+</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.23456789&#39;</span><span class="p">)</span>      <span class="c1"># unary plus triggers rounding</span>
<span class="go">Decimal(&#39;1.23&#39;)</span>
</pre></div>
</div>
<p>Alternatively, inputs can be rounded upon creation using the
<a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal"><span class="pre">Context.create_decimal()</span></code></a> method:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">&#39;1.2345678&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.2345&#39;)</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">9.4. <code class="docutils literal"><span class="pre">decimal</span></code> --- 십진 고정 소수점 및 부동 소수점 산술</a><ul>
<li><a class="reference internal" href="#quick-start-tutorial">9.4.1. 빠른 시작 자습서</a></li>
<li><a class="reference internal" href="#decimal-objects">9.4.2. Decimal 객체</a><ul>
<li><a class="reference internal" href="#logical-operands">9.4.2.1. 논리적 피연산자</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-objects">9.4.3. Context 객체</a></li>
<li><a class="reference internal" href="#constants">9.4.4. 상수</a></li>
<li><a class="reference internal" href="#rounding-modes">9.4.5. 자리 올림 모드</a></li>
<li><a class="reference internal" href="#signals">9.4.6. 신호</a></li>
<li><a class="reference internal" href="#floating-point-notes">9.4.7. 부동 소수점 노트</a><ul>
<li><a class="reference internal" href="#mitigating-round-off-error-with-increased-precision">9.4.7.1. 증가된 정밀도로 자리 올림 오차 줄이기</a></li>
<li><a class="reference internal" href="#special-values">9.4.7.2. 특수 값</a></li>
</ul>
</li>
<li><a class="reference internal" href="#working-with-threads">9.4.8. 스레드로 작업하기</a></li>
<li><a class="reference internal" href="#recipes">9.4.9. 조리법</a></li>
<li><a class="reference internal" href="#decimal-faq">9.4.10. Decimal FAQ</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="cmath.html"
                        title="이전 장">9.3. <code class="docutils literal"><span class="pre">cmath</span></code> --- Mathematical functions for complex numbers</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="fractions.html"
                        title="다음 장">9.5. <code class="docutils literal"><span class="pre">fractions</span></code> --- Rational numbers</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="fractions.html" title="9.5. fractions --- Rational numbers"
             >다음</a> |</li>
        <li class="right" >
          <a href="cmath.html" title="9.3. cmath --- Mathematical functions for complex numbers"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="numeric.html" >9. 숫자와 수학 모듈</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2018, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 를 사용해서 만들었습니다.
    </div>

  </body>
</html>