
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>email.message: 전자 메일 메시지 표현 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="email.parser: 전자 메일 메시지 구문 분석" href="email.parser.html" />
    <link rel="prev" title="email --- 전자 메일과 MIME 처리 패키지" href="email.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/email.message.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="email.parser.html" title="email.parser: 전자 메일 메시지 구문 분석"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="email.html" title="email --- 전자 메일과 MIME 처리 패키지"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >인터넷 데이터 처리</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 전자 메일과 MIME 처리 패키지</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-email.message">
<span id="email-message-representing-an-email-message"></span><h1><a class="reference internal" href="#module-email.message" title="email.message: The base class representing email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message</span></code></a>: 전자 메일 메시지 표현<a class="headerlink" href="#module-email.message" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/email/message.py">Lib/email/message.py</a></p>
<hr class="docutils" />
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가: </span><a class="footnote-reference brackets" href="#id2" id="id1">1</a></p>
</div>
<p><a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 패키지의 중심 클래스는 <a class="reference internal" href="#module-email.message" title="email.message: The base class representing email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message</span></code></a> 모듈에서 임포트 되는 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 클래스입니다. <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 객체 모델의 베이스 클래스입니다. <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>는 헤더 필드 설정과 조회, 메시지 본문 액세스 및 구조화된 메시지 작성이나 수정을 위한 핵심 기능을 제공합니다.</p>
<p>전자 메일 메시지는 <em>헤더(headers)</em>와 <em>페이 로드(payload)</em>(<em>내용(content)</em>이라고도 합니다)로 구성됩니다. 헤더는 <span class="target" id="index-22"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>나 <span class="target" id="index-23"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6532.html"><strong>RFC 6532</strong></a> 스타일 필드 이름과 값이며, 필드 이름과 값은 콜론으로 구분됩니다. 콜론은 필드 이름이나 필드 값의 일부가 아닙니다. 페이 로드는 간단한 텍스트 메시지, 바이너리 객체 또는 각각 자신만의 헤더 집합과 자신만의 페이 로드를 갖는 서브 메시지들의 구조화된 시퀀스일 수 있습니다. 마지막 유형의 페이 로드는 <em class="mimetype">multipart/*</em>나 <em class="mimetype">message/rfc822</em>와 같은 MIME 유형을 가진 메시지로 표시됩니다.</p>
<p><a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 객체가 제공하는 개념적 모델은 메시지의 <span class="target" id="index-24"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a> 본문을 나타내는 <em>payload</em>와 결합 된 헤더들의 순서 있는 딕셔너리이며, 본문은 서브-<code class="docutils literal notranslate"><span class="pre">EmailMessage</span></code> 객체의 리스트일 수 있습니다. 헤더 이름과 값에 액세스하기 위한 일반적인 딕셔너리 메서드 외에도, 헤더에서 특수 정보(예를 들어 MIME 콘텐츠 유형)에 액세스하고, 페이 로드를 다루고, 메시지의 직렬화된 버전을 생성하고, 객체 트리를 재귀적으로 탐색하는 메서드가 있습니다.</p>
<p><a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 딕셔너리류 인터페이스는 ASCII 값이어야 하는 헤더 이름으로 인덱싱됩니다. 딕셔너리의 값은 몇 가지 추가 메서드가 있는 문자열입니다. 헤더는 대소 문자를 유지하면서 저장되고 반환되지만, 필드 이름은 대소 문자를 구분하지 않고 일치합니다. 실제 딕셔너리와 달리, 키 순서가 있으며 중복된 키를 가질 수 있습니다. 중복 키가 있는 헤더로 작업하기 위한 추가 메서드가 제공됩니다.</p>
<p><em>페이 로드</em>는 간단한 메시지 객체의 경우 문자열이나 바이트열 객체이고, <em class="mimetype">multipart/*</em>와 <em class="mimetype">message/rfc822</em> 메시지 객체와 같은 MIME 컨테이너 문서에서는 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 객체의 리스트입니다.</p>
<dl class="class">
<dt id="email.message.EmailMessage">
<em class="property">class </em><code class="sig-prename descclassname">email.message.</code><code class="sig-name descname">EmailMessage</code><span class="sig-paren">(</span><em class="sig-param">policy=default</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage" title="정의 주소">¶</a></dt>
<dd><p><em>policy</em>가 지정되면, 그것이 지정하는 규칙을 사용하여 메시지 표현을 갱신하고 직렬화합니다. <em>policy</em>가 설정되지 않으면, 줄 종료를 제외하고는 전자 메일 RFC 규칙을 따르는 <a class="reference internal" href="email.policy.html#email.policy.default" title="email.policy.default"><code class="xref py py-class docutils literal notranslate"><span class="pre">default</span></code></a> 정책을 사용합니다 (RFC가 요구하는 <code class="docutils literal notranslate"><span class="pre">\r\n</span></code> 대신에, 파이썬 표준 <code class="docutils literal notranslate"><span class="pre">\n</span></code> 줄 종료를 사용합니다). 자세한 내용은 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 설명서를 참조하십시오.</p>
<dl class="method">
<dt id="email.message.EmailMessage.as_string">
<code class="sig-name descname">as_string</code><span class="sig-paren">(</span><em class="sig-param">unixfrom=False</em>, <em class="sig-param">maxheaderlen=None</em>, <em class="sig-param">policy=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.as_string" title="정의 주소">¶</a></dt>
<dd><p>전체 메시지를 평평하게 만든 문자열을 반환합니다. 선택적 <em>unixfrom</em>이 참이면, 봉투 헤더(envelope header)가 반환된 문자열에 포함됩니다. <em>unixfrom</em>의 기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code>입니다. 베이스 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 클래스와의 과거 호환성을 위해 <em>maxheaderlen</em>이 허용되지만, 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>이고, 이는 기본적으로 줄 길이가 정책의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">max_line_length</span></code>에 의해 제어됨을 의미합니다. <em>policy</em> 인자는 메시지 인스턴스에서 얻은 기본 정책을 대체하는 데 사용될 수 있습니다. 지정된 <em>policy</em>가 <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>로 전달되기 때문에, 메서드가 생성하는 포매팅의 일부를 제어하는 데 사용할 수 있습니다.</p>
<p>문자열로의 변환을 완료하기 위해 기본값을 채워야 하면 메시지를 평평하게 만들 때 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>에 대한 변경이 발생할 수 있습니다 (예를 들어, MIME 경계(boundaries)가 생성되거나 수정될 수 있습니다).</p>
<p>이 메서드는 편의상 제공되며, 응용 프로그램에서 메시지를 직렬화하는 가장 유용한 방법은 아닐 수 있습니다, 특히 여러 메시지를 다룬다면 그렇습니다. 메시지 직렬화를 위한 더 유연한 API는 <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.generator.Generator</span></code></a>를 참조하십시오. 또한 이 메서드는 <a class="reference internal" href="email.policy.html#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>(기본값)일 때 &quot;7비트 클린&quot;으로 직렬화된 메시지를 생성하는 것으로 제한됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><em>maxheaderlen</em>이 지정되지 않았을 때의 기본 동작은 기본값을 0으로 하는 것에서 정책(policy)의 <em>max_line_length</em> 값을 기본값으로 사용하는 것으로 변경되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__str__" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">as_string(policy=self.policy.clone(utf8=True))</span></code>와 동등합니다. <code class="docutils literal notranslate"><span class="pre">str(msg)</span></code>가 직렬화된 메시지를 포함하는 문자열을 읽을 수 있는 형식으로 생성할 수 있도록 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>이 메서드는 <code class="docutils literal notranslate"><span class="pre">utf8=True</span></code>를 사용하도록 변경되어, <a class="reference internal" href="#email.message.EmailMessage.as_string" title="email.message.EmailMessage.as_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_string()</span></code></a>의 직접적인 별칭인 대신, <span class="target" id="index-25"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6531.html"><strong>RFC 6531</strong></a>과 유사한 메시지 표현을 생성합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.as_bytes">
<code class="sig-name descname">as_bytes</code><span class="sig-paren">(</span><em class="sig-param">unixfrom=False</em>, <em class="sig-param">policy=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.as_bytes" title="정의 주소">¶</a></dt>
<dd><p>전체 메시지를 평평하게 만든 바이트열 객체를 반환합니다. 선택적 <em>unixfrom</em>이 참이면, 봉투 헤더(envelope header)가 반환된 문자열에 포함됩니다. <em>unixfrom</em>의 기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code>입니다. <em>policy</em> 인자는 메시지 인스턴스에서 얻은 기본 정책을 대체하는 데 사용될 수 있습니다. 지정된 <em>policy</em>가 <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a>로 전달되기 때문에, 메서드가 생성하는 포매팅의 일부를 제어하는 데 사용할 수 있습니다.</p>
<p>문자열로의 변환을 완료하기 위해 기본값을 채워야 하면 메시지를 평평하게 만들 때 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>에 대한 변경이 발생할 수 있습니다 (예를 들어, MIME 경계(boundaries)가 생성되거나 수정될 수 있습니다).</p>
<p>이 메서드는 편의상 제공되며, 응용 프로그램에서 메시지를 직렬화하는 가장 유용한 방법은 아닐 수 있습니다, 특히 여러 메시지를 다룬다면 그렇습니다. 메시지 직렬화를 위한 더 유연한 API는 <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.generator.BytesGenerator</span></code></a>를 참조하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.__bytes__">
<code class="sig-name descname">__bytes__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__bytes__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#email.message.EmailMessage.as_bytes" title="email.message.EmailMessage.as_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_bytes()</span></code></a>와 동등합니다. <code class="docutils literal notranslate"><span class="pre">bytes(msg)</span></code>가 직렬화된 메시지를 포함하는 바이트열 객체를 생성할 수 있도록 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.is_multipart">
<code class="sig-name descname">is_multipart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.is_multipart" title="정의 주소">¶</a></dt>
<dd><p>메시지의 페이 로드가 서브-<a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 객체의 리스트면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다. <a class="reference internal" href="#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환할 때, 페이 로드는 문자열 객체(CTE 인코딩된 바이너리 페이 로드일 수 있습니다)여야 합니다. <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환하는 <a class="reference internal" href="#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a>가 반드시 &quot;msg.get_content_maintype() == 'multipart'&quot;가 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환한다는 것을 의미하지는 않습니다. 예를 들어, <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">message/rfc822</span></code> 유형일 때 <code class="docutils literal notranslate"><span class="pre">is_multipart</span></code>는 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.set_unixfrom">
<code class="sig-name descname">set_unixfrom</code><span class="sig-paren">(</span><em class="sig-param">unixfrom</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_unixfrom" title="정의 주소">¶</a></dt>
<dd><p>메시지의 봉투 헤더(envelope header)를 문자열이어야 하는 <em>unixfrom</em>으로 설정합니다. (이 헤더에 대한 간단한 설명은 <a class="reference internal" href="mailbox.html#mailbox.mboxMessage" title="mailbox.mboxMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">mboxMessage</span></code></a>를 참조하십시오.)</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.get_unixfrom">
<code class="sig-name descname">get_unixfrom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_unixfrom" title="정의 주소">¶</a></dt>
<dd><p>메시지의 봉투 헤더(envelope header)를 반환합니다. 봉투 헤더가 설정되지 않았으면 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다.</p>
</dd></dl>

<p>다음 메서드는 메시지 헤더에 액세스하기 위한 매핑류 인터페이스를 구현합니다. 이 메서드들과 일반 매핑(즉, 딕셔너리) 인터페이스 사이에는 의미상 차이가 있습니다. 예를 들어, 딕셔너리에는 중복 키가 없지만, 여기서는 중복 메시지 헤더가 있을 수 있습니다. 또한 딕셔너리에서는 <a class="reference internal" href="#email.message.EmailMessage.keys" title="email.message.EmailMessage.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code></a>가 반환한 키의 순서가 보장되지 않지만, <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 객체에서는 헤더가 항상 원래 메시지에 나타난 순서대로, 또는 나중에 메시지에 추가된 순서대로 반환됩니다. 삭제한 후 다시 추가된 헤더는 항상 헤더 리스트의 끝에 추가됩니다.</p>
<p>이러한 의미적 차이는 의도적이며 가장 흔한 사용 사례에서의 편의를 추구하는 쪽으로 기울어져 있습니다.</p>
<p>모든 경우에, 메시지에 존재하는 봉투 헤더는 매핑 인터페이스에 포함되지 않습니다.</p>
<dl class="method">
<dt id="email.message.EmailMessage.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__len__" title="정의 주소">¶</a></dt>
<dd><p>중복을 포함하여, 총 헤더 수를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.__contains__">
<code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__contains__" title="정의 주소">¶</a></dt>
<dd><p>메시지 객체에 <em>name</em>이라는 필드가 있으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다. 대소 문자를 구분하지 않고 일치하며, <em>name</em>은 후행 콜론을 포함하지 않습니다. <code class="docutils literal notranslate"><span class="pre">in</span></code> 연산자에 사용됩니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="s1">&#39;message-id&#39;</span> <span class="ow">in</span> <span class="n">myMessage</span><span class="p">:</span>
   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Message-ID:&#39;</span><span class="p">,</span> <span class="n">myMessage</span><span class="p">[</span><span class="s1">&#39;message-id&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__getitem__" title="정의 주소">¶</a></dt>
<dd><p>이름으로 지정된 헤더 필드의 값을 반환합니다. <em>name</em>은 콜론 필드 구분자를 포함하지 않습니다. 헤더가 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다; <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>가 발생하지 않습니다.</p>
<p>이름이 지정된 필드가 메시지 헤더에 두 번 이상 나타나면, 해당 필드 값 중 정확히 어떤 필드 값이 반환되는지 정의되지 않습니다. <a class="reference internal" href="#email.message.EmailMessage.get_all" title="email.message.EmailMessage.get_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_all()</span></code></a> 메서드를 사용하여 <em>name</em>으로 이름이 지정된 모든 기존 헤더의 값을 가져오십시오.</p>
<p>표준 (<code class="docutils literal notranslate"><span class="pre">compat32</span></code>가 아닌) 정책을 사용하여, 반환된 값은 <a class="reference internal" href="email.headerregistry.html#email.headerregistry.BaseHeader" title="email.headerregistry.BaseHeader"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.headerregistry.BaseHeader</span></code></a>의 서브 클래스 인스턴스입니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.__setitem__">
<code class="sig-name descname">__setitem__</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">val</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__setitem__" title="정의 주소">¶</a></dt>
<dd><p>필드 이름이 <em>name</em>이고 값이 <em>val</em>인 헤더를 메시지에 추가합니다. 필드는 메시지의 기존 헤더들 끝에 추가됩니다.</p>
<p>같은 이름을 가진 기존 헤더를 덮어쓰거나 삭제하지 <em>않습니다</em>. 새 헤더가 메시지에서 필드 이름이 <em>name</em>인 유일한 것이 되도록 하려면, 먼저 필드를 삭제하십시오. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">del</span> <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">]</span>
<span class="n">msg</span><span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Python roolz!&#39;</span>
</pre></div>
</div>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code>가 (표준 정책에서처럼) 특정 헤더를 고유한(unique) 것으로 정의하면, 이 메서드는 헤더가 이미 존재할 때 해당 헤더에 값을 할당하려고 시도하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킬 수 있습니다. 이 동작은 일관성을 위해 의도적이지만, 향후 이러한 대입이 기존 헤더를 자동으로 삭제하도록 선택할 수 있기 때문에, 이것에 의존하지 마십시오.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.__delitem__">
<code class="sig-name descname">__delitem__</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__delitem__" title="정의 주소">¶</a></dt>
<dd><p>메시지 헤더에서 이름이 <em>name</em>인 모든 필드를 삭제합니다. 해당 이름의 필드가 헤더에 없어도 예외가 발생하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.keys">
<code class="sig-name descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.keys" title="정의 주소">¶</a></dt>
<dd><p>메시지의 모든 헤더 필드 이름의 리스트를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.values">
<code class="sig-name descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.values" title="정의 주소">¶</a></dt>
<dd><p>메시지의 모든 필드 값의 리스트를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.items">
<code class="sig-name descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.items" title="정의 주소">¶</a></dt>
<dd><p>메시지의 모든 필드 헤더와 값을 담은 2-튜플의 리스트를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">failobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get" title="정의 주소">¶</a></dt>
<dd><p>명명된 헤더 필드의 값을 반환합니다. 명명된 헤더가 없을 때 선택적 <em>failobj</em>가 반환된다는 점을 제외하면 <a class="reference internal" href="#email.message.EmailMessage.__getitem__" title="email.message.EmailMessage.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>와 같습니다 (<em>failobj</em>의 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<p>추가적인 유용한 헤더 관련 메서드는 다음과 같습니다:</p>
<dl class="method">
<dt id="email.message.EmailMessage.get_all">
<code class="sig-name descname">get_all</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">failobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_all" title="정의 주소">¶</a></dt>
<dd><p><em>name</em>으로 명명된 필드의 모든 값의 리스트를 반환합니다. 메시지에 그런 이름의 헤더가 없으면 <em>failobj</em>가 반환됩니다 (기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.add_header">
<code class="sig-name descname">add_header</code><span class="sig-paren">(</span><em class="sig-param">_name</em>, <em class="sig-param">_value</em>, <em class="sig-param">**_params</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.add_header" title="정의 주소">¶</a></dt>
<dd><p>확장된 헤더 설정. 이 메서드는 추가 헤더 파라미터가 키워드 인자로 제공될 수 있다는 점을 제외하고는 <a class="reference internal" href="#email.message.EmailMessage.__setitem__" title="email.message.EmailMessage.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>과 유사합니다. <em>_name</em>은 추가할 헤더 필드이고 <em>_value</em>는 헤더의 <em>기본(primary)</em>값입니다.</p>
<p>키워드 인자 딕셔너리 <em>_params</em>의 각 항목에 대해, 키는 파라미터 이름으로 사용되며 밑줄은 대시로 변환됩니다 (대시는 파이썬 식별자에서 유효하지 않기 때문입니다). 일반적으로, 값이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면 파라미터가 <code class="docutils literal notranslate"><span class="pre">key=&quot;value&quot;</span></code>로 추가되며, None이면 키만 추가됩니다.</p>
<p>값에 ASCII가 아닌 문자가 포함되면, 값을 <code class="docutils literal notranslate"><span class="pre">(CHARSET,</span> <span class="pre">LANGUAGE,</span> <span class="pre">VALUE)</span></code> 형식의 3-튜플로 지정하여 문자 집합과 언어를 명시적으로 제어 할 수 있습니다. 여기서 <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code>은 값을 인코딩하는 데 사용할 문자 집합의 이름을 지정하는 문자열이고, <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code>는 보통 <code class="docutils literal notranslate"><span class="pre">None</span></code>이나 빈 문자열(다른 가능성은 <span class="target" id="index-26"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2231.html"><strong>RFC 2231</strong></a>을 참조하십시오)로 설정되고, <code class="docutils literal notranslate"><span class="pre">VALUE</span></code>는 비 ASCII 코드 포인트를 포함하는 문자열 값입니다. 3-튜플이 전달되지 않고 값에 ASCII가 아닌 문자가 포함되면, <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code>으로 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code>, <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code>로 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 사용하여 <span class="target" id="index-27"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2231.html"><strong>RFC 2231</strong></a> 형식으로 자동 인코딩됩니다.</p>
<p>예를 들면 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Content-Disposition&#39;</span><span class="p">,</span> <span class="s1">&#39;attachment&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;bud.gif&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>이것은 다음과 같은 헤더를 추가합니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Content</span><span class="o">-</span><span class="n">Disposition</span><span class="p">:</span> <span class="n">attachment</span><span class="p">;</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;bud.gif&quot;</span>
</pre></div>
</div>
<p>비 ASCII 문자가 있는 확장 인터페이스의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Content-Disposition&#39;</span><span class="p">,</span> <span class="s1">&#39;attachment&#39;</span><span class="p">,</span>
               <span class="n">filename</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;iso-8859-1&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;Fußballer.ppt&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.replace_header">
<code class="sig-name descname">replace_header</code><span class="sig-paren">(</span><em class="sig-param">_name</em>, <em class="sig-param">_value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.replace_header" title="정의 주소">¶</a></dt>
<dd><p>헤더를 교체합니다. 메시지에서 발견된 <em>_name</em>과 일치하는 첫 번째 헤더를 교체하고, 원래 헤더의 헤더 순서와 필드 이름 케이스(case)를 유지합니다. 일치하는 헤더가 없으면 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.get_content_type">
<code class="sig-name descname">get_content_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_type" title="정의 주소">¶</a></dt>
<dd><p><em class="mimetype">maintype/subtype</em> 형식의 소문자로 강제 변환된 메시지의 콘텐츠 유형을 반환합니다. 메시지에 <em class="mailheader">Content-Type</em> 헤더가 없으면 <a class="reference internal" href="#email.message.EmailMessage.get_default_type" title="email.message.EmailMessage.get_default_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_default_type()</span></code></a>이 반환하는 값을 반환합니다. <em class="mailheader">Content-Type</em> 헤더가 유효하지 않으면 <code class="docutils literal notranslate"><span class="pre">text/plain</span></code>을 반환합니다.</p>
<p>(<span class="target" id="index-28"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a>에 따라, 메시지는 항상 기본 유형을 가지며, <a class="reference internal" href="#email.message.EmailMessage.get_content_type" title="email.message.EmailMessage.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a>은 항상 값을 반환합니다. <span class="target" id="index-29"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a>는 <em class="mimetype">multipart/digest</em> 컨테이너 내에 등장하면 기본 유형이 <em class="mimetype">message/rfc822</em>이고, 그렇지 않으면 기본 유형을 <em class="mimetype">text/plain</em>으로 정의합니다. <em class="mailheader">Content-Type</em> 헤더가 유효하지 않은 유형 지정이면, <span class="target" id="index-30"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a>는 기본 유형을 <em class="mimetype">text/plain</em>으로 강제합니다.)</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.get_content_maintype">
<code class="sig-name descname">get_content_maintype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_maintype" title="정의 주소">¶</a></dt>
<dd><p>메시지의 메인 콘텐츠 유형을 반환합니다. 이것은 <a class="reference internal" href="#email.message.EmailMessage.get_content_type" title="email.message.EmailMessage.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a>이 반환한 문자열의 <em class="mimetype">maintype</em> 부분입니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.get_content_subtype">
<code class="sig-name descname">get_content_subtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_subtype" title="정의 주소">¶</a></dt>
<dd><p>메시지의 서브 콘텐츠 유형을 반환합니다. 이것은 <a class="reference internal" href="#email.message.EmailMessage.get_content_type" title="email.message.EmailMessage.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a>이 반환한 문자열의 <em class="mimetype">subtype</em> 부분입니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.get_default_type">
<code class="sig-name descname">get_default_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_default_type" title="정의 주소">¶</a></dt>
<dd><p>기본 콘텐츠 유형을 반환합니다. <em class="mimetype">multipart/digest</em> 컨테이너의 서브 파트인 메시지를 제외하고 대부분의 메시지는 기본 콘텐츠 유형이 <em class="mimetype">text/plain</em>입니다. 이러한 서브 파트는 기본 콘텐츠 유형이 <em class="mimetype">message/rfc822</em>입니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.set_default_type">
<code class="sig-name descname">set_default_type</code><span class="sig-paren">(</span><em class="sig-param">ctype</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_default_type" title="정의 주소">¶</a></dt>
<dd><p>기본 콘텐츠 유형을 설정합니다. <em>ctype</em>은 <em class="mimetype">text/plain</em>이나 <em class="mimetype">message/rfc822</em>여야 하지만, 이것을 강제하지는 않습니다. 기본 콘텐츠 유형은 <em class="mailheader">Content-Type</em> 헤더에 저장되지 않기 때문에, 메시지에 <em class="mailheader">Content-Type</em> 헤더가 없을 때 <code class="docutils literal notranslate"><span class="pre">get_content_type</span></code> 메서드의 반환 값에만 영향을 줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.set_param">
<code class="sig-name descname">set_param</code><span class="sig-paren">(</span><em class="sig-param">param</em>, <em class="sig-param">value</em>, <em class="sig-param">header='Content-Type'</em>, <em class="sig-param">requote=True</em>, <em class="sig-param">charset=None</em>, <em class="sig-param">language=''</em>, <em class="sig-param">replace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_param" title="정의 주소">¶</a></dt>
<dd><p><em class="mailheader">Content-Type</em> 헤더에 파라미터를 설정합니다. 파라미터가 이미 헤더에 존재하면, 해당 값을 <em>value</em>로 바꿉니다. <em>header</em>가 <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code>(기본값)이고 헤더가 메시지에 아직 없으면, 헤더를 추가하고 값을 <em class="mimetype">text/plain</em>으로 설정한 다음 새 파라미터 값을 추가합니다. 선택적 <em>header</em>는 <em class="mailheader">Content-Type</em>의 대체 헤더를 지정합니다.</p>
<p>값에 ASCII가 아닌 문자가 포함되면, 선택적 <em>charset</em>과 <em>language</em> 매개 변수를 사용하여 문자 집합과 언어를 명시적으로 지정할 수 있습니다. 선택적 <em>language</em>는 <span class="target" id="index-31"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2231.html"><strong>RFC 2231</strong></a> 언어를 지정하며, 기본값은 빈 문자열입니다. <em>charset</em>과 <em>language</em>는 모두 문자열이어야 합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">utf8</span></code> <em>charset</em>과 <code class="docutils literal notranslate"><span class="pre">None</span></code> <em>language</em>를 사용하는 것입니다.</p>
<p><em>replace</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>(기본값)이면 헤더는 헤더 리스트의 끝으로 이동합니다. <em>replace</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, 헤더는 제자리에서 갱신됩니다.</p>
<p><a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 객체에 <em>requote</em> 매개 변수를 사용하는 것은 폐지되었습니다.</p>
<p>헤더의 기존 파라미터값은 헤더 값의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">params</span></code> 어트리뷰트를 통해 액세스 할 수 있음에 유의하십시오 (예를 들어, <code class="docutils literal notranslate"><span class="pre">msg['Content-Type'].params['charset']</span></code>).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">replace</span></code> 키워드가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.del_param">
<code class="sig-name descname">del_param</code><span class="sig-paren">(</span><em class="sig-param">param</em>, <em class="sig-param">header='content-type'</em>, <em class="sig-param">requote=True</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.del_param" title="정의 주소">¶</a></dt>
<dd><p><em class="mailheader">Content-Type</em> 헤더에서 지정된 파라미터를 완전히 제거합니다. 헤더는 해당 파라미터나 그 값 없이 제자리에서 다시 작성됩니다. 선택적 <em>header</em>는 <em class="mailheader">Content-Type</em>의 대체 헤더를 지정합니다.</p>
<p><a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 객체에 <em>requote</em> 매개 변수를 사용하는 것은 폐지되었습니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.get_filename">
<code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param">failobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_filename" title="정의 주소">¶</a></dt>
<dd><p>메시지의 <em class="mailheader">Content-Disposition</em> 헤더의 <code class="docutils literal notranslate"><span class="pre">filename</span></code> 파라미터값을 반환합니다. 헤더에 <code class="docutils literal notranslate"><span class="pre">filename</span></code> 파라미터가 없으면, 이 메서드는 <em class="mailheader">Content-Type</em> 헤더에서 <code class="docutils literal notranslate"><span class="pre">name</span></code> 파라미터를 찾는 것으로 폴백(fallback)합니다. 둘 다 없거나 헤더가 없으면, <em>failobj</em>가 반환됩니다. 반환된 문자열은 항상 <a class="reference internal" href="email.utils.html#email.utils.unquote" title="email.utils.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.unquote()</span></code></a>에 따라 unquote 됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.get_boundary">
<code class="sig-name descname">get_boundary</code><span class="sig-paren">(</span><em class="sig-param">failobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_boundary" title="정의 주소">¶</a></dt>
<dd><p>메시지의 <em class="mailheader">Content-Type</em> 헤더의 <code class="docutils literal notranslate"><span class="pre">boundary</span></code> 파라미터값, 또는 헤더가 없거나 <code class="docutils literal notranslate"><span class="pre">boundary</span></code> 파라미터가 없으면 <em>failobj</em>를 반환합니다. 반환된 문자열은 항상 <a class="reference internal" href="email.utils.html#email.utils.unquote" title="email.utils.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.unquote()</span></code></a>에 따라 unquote 됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.set_boundary">
<code class="sig-name descname">set_boundary</code><span class="sig-paren">(</span><em class="sig-param">boundary</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_boundary" title="정의 주소">¶</a></dt>
<dd><p><em class="mailheader">Content-Type</em> 헤더의 <code class="docutils literal notranslate"><span class="pre">boundary</span></code> 파라미터를 <em>boundary</em>로 설정합니다. 필요하면 <a class="reference internal" href="#email.message.EmailMessage.set_boundary" title="email.message.EmailMessage.set_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_boundary()</span></code></a>는 항상 <em>boundary</em>를 quote 합니다. 메시지 객체에 <em class="mailheader">Content-Type</em> 헤더가 없으면 <a class="reference internal" href="email.errors.html#email.errors.HeaderParseError" title="email.errors.HeaderParseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HeaderParseError</span></code></a>가 발생합니다.</p>
<p><a class="reference internal" href="#email.message.EmailMessage.set_boundary" title="email.message.EmailMessage.set_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_boundary()</span></code></a>가 헤더 리스트에서 <em class="mailheader">Content-Type</em> 헤더의 순서를 유지하기 때문에, 이 메서드를 사용하는 것은 이전 <em class="mailheader">Content-Type</em> 헤더를 삭제하고 <a class="reference internal" href="#email.message.EmailMessage.add_header" title="email.message.EmailMessage.add_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_header()</span></code></a>를 통해 새 boundary로 새 헤더를 추가하는 것과는 미묘한 차이가 있음에 유의하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.get_content_charset">
<code class="sig-name descname">get_content_charset</code><span class="sig-paren">(</span><em class="sig-param">failobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_charset" title="정의 주소">¶</a></dt>
<dd><p><em class="mailheader">Content-Type</em> 헤더의 <code class="docutils literal notranslate"><span class="pre">charset</span></code> 파라미터를 소문자로 강제 변환하여 반환합니다. <em class="mailheader">Content-Type</em> 헤더가 없거나 헤더에 <code class="docutils literal notranslate"><span class="pre">charset</span></code> 파라미터가 없으면 <em>failobj</em>가 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.get_charsets">
<code class="sig-name descname">get_charsets</code><span class="sig-paren">(</span><em class="sig-param">failobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_charsets" title="정의 주소">¶</a></dt>
<dd><p>메시지 내의 문자 집합 이름들을 포함하는 리스트를 반환합니다. 메시지가 <em class="mimetype">multipart</em>이면, 리스트는 페이 로드의 각 서브 파트마다 하나의 요소를 포함하며, 그렇지 않으면 길이 1인 리스트가 됩니다.</p>
<p>리스트의 각 항목은 표현된 서브 파트에 대한 <em class="mailheader">Content-Type</em> 헤더의 <code class="docutils literal notranslate"><span class="pre">charset</span></code> 파라미터의 값인 문자열입니다. 서브 파트에 <em class="mailheader">Content-Type</em> 헤더가 없거나, <code class="docutils literal notranslate"><span class="pre">charset</span></code> 파라미터가 없거나, <em class="mimetype">text</em> 메인 MIME 유형이 아니면, 반환된 리스트의 해당 항목은 <em>failobj</em>입니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.is_attachment">
<code class="sig-name descname">is_attachment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.is_attachment" title="정의 주소">¶</a></dt>
<dd><p><em class="mailheader">Content-Disposition</em> 헤더가 있고 (대소 문자를 구분하지 않는) 값이 <code class="docutils literal notranslate"><span class="pre">attachment</span></code>이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4.2에서 변경: </span><a class="reference internal" href="email.compat32-message.html#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a>와 일관성을 유지하기 위해, is_attachment는 이제 프로퍼티 대신 메서드입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.get_content_disposition">
<code class="sig-name descname">get_content_disposition</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_disposition" title="정의 주소">¶</a></dt>
<dd><p>메시지의 <em class="mailheader">Content-Disposition</em> 헤더가 있으면 소문자로 변환된 (파라미터 없는) 값을, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 메시지가 <span class="target" id="index-32"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2183.html"><strong>RFC 2183</strong></a>을 따르면, 이 메서드의 가능한 값은 <em>inline</em>, <em>attachment</em> 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<p>다음 메서드는 메시지의 내용(페이 로드)을 조사하고 조작하는 것과 관련이 있습니다.</p>
<dl class="method">
<dt id="email.message.EmailMessage.walk">
<code class="sig-name descname">walk</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.walk" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#email.message.EmailMessage.walk" title="email.message.EmailMessage.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a> 메서드는 메시지 객체 트리의 모든 파트와 서브 파트를 깊이 우선 탐색 순서로 이터레이트 하는 데 사용할 수 있는 범용 제너레이터입니다. 일반적으로 <a class="reference internal" href="#email.message.EmailMessage.walk" title="email.message.EmailMessage.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a>를 <code class="docutils literal notranslate"><span class="pre">for</span></code> 루프에서 이터레이터로 사용합니다; 각 이터레이션은 다음 서브 파트를 반환합니다.</p>
<p>다음은 멀티 파트 메시지 구조의 모든 파트의 MIME 유형을 인쇄하는 예입니다:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">walk</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">get_content_type</span><span class="p">())</span>
<span class="go">multipart/report</span>
<span class="go">text/plain</span>
<span class="go">message/delivery-status</span>
<span class="go">text/plain</span>
<span class="go">text/plain</span>
<span class="go">message/rfc822</span>
<span class="go">text/plain</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">msg.get_content_maintype()</span> <span class="pre">==</span> <span class="pre">'multipart'</span></code>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환하더라도, <code class="docutils literal notranslate"><span class="pre">walk</span></code>는 <a class="reference internal" href="#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환하는 모든 파트의 서브 파트를 이터레이트 합니다. <code class="docutils literal notranslate"><span class="pre">_structure</span></code> 디버그 도우미 함수를 사용하여 예제에서 이를 확인할 수 있습니다:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email.iterators</span> <span class="k">import</span> <span class="n">_structure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">walk</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">get_content_maintype</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;multipart&#39;</span><span class="p">,</span>
<span class="gp">... </span>          <span class="n">part</span><span class="o">.</span><span class="n">is_multipart</span><span class="p">())</span>
<span class="go">True True</span>
<span class="go">False False</span>
<span class="go">False True</span>
<span class="go">False False</span>
<span class="go">False False</span>
<span class="go">False True</span>
<span class="go">False False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_structure</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="go">multipart/report</span>
<span class="go">    text/plain</span>
<span class="go">    message/delivery-status</span>
<span class="go">        text/plain</span>
<span class="go">        text/plain</span>
<span class="go">    message/rfc822</span>
<span class="go">        text/plain</span>
</pre></div>
</div>
<p>여기서 <code class="docutils literal notranslate"><span class="pre">message</span></code> 파트는 <code class="docutils literal notranslate"><span class="pre">multiparts</span></code>는 아니지만, 서브 파트를 포함합니다. <code class="docutils literal notranslate"><span class="pre">is_multipart()</span></code>는 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환하고 <code class="docutils literal notranslate"><span class="pre">walk</span></code>는 서브 파트로 내려갑니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.get_body">
<code class="sig-name descname">get_body</code><span class="sig-paren">(</span><em class="sig-param">preferencelist=('related'</em>, <em class="sig-param">'html'</em>, <em class="sig-param">'plain')</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_body" title="정의 주소">¶</a></dt>
<dd><p>메시지의 &quot;본문&quot;이 될 수 있는 가장 적합한 후보인 MIME 파트를 반환합니다.</p>
<p><em>preferencelist</em>는 <code class="docutils literal notranslate"><span class="pre">related</span></code>, <code class="docutils literal notranslate"><span class="pre">html</span></code> 및 <code class="docutils literal notranslate"><span class="pre">plain</span></code> 집합의 문자열 시퀀스이어야 하며, 반환된 파트의 콘텐츠 유형에 대한 선호 순서를 나타냅니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">get_body</span></code> 메서드가 호출된 객체와 일치하는 후보를 찾기 시작합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">related</span></code>가 <em>preferencelist</em>에 포함되지 않으면, (서브) 파트가 선호와 일치하면 후보로 만난 모든 관련(related)의 루트 파트(또는 루트 파트의 서브 파트)를 고려합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>와 만날 때, <code class="docutils literal notranslate"><span class="pre">start</span></code> 파라미터를 확인하고 일치하는 <em class="mailheader">Content-ID</em>가 있는 파트를 발견하면, 일치하는 후보를 찾을 때만 고려합니다. 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>의 첫 번째 (기본 루트) 파트만 고려합니다.</p>
<p>파트에 <em class="mailheader">Content-Disposition</em> 헤더가 있으면, 헤더 값이 <code class="docutils literal notranslate"><span class="pre">inline</span></code>일 때만 해당 파트를 후보로 간주합니다.</p>
<p><em>preferencelist</em>의 선호 어느 것과도 일치하는 후보가 없으면, <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<p>참고: (1) 대부분의 응용 프로그램에서 실제로 의미가 있는 <em>preferencelist</em> 조합은 <code class="docutils literal notranslate"><span class="pre">('plain',)</span></code>, <code class="docutils literal notranslate"><span class="pre">('html',</span> <span class="pre">'plain')</span></code> 및 기본 <code class="docutils literal notranslate"><span class="pre">('related',</span> <span class="pre">'html',</span> <span class="pre">'plain')</span></code>뿐입니다. (2) <code class="docutils literal notranslate"><span class="pre">get_body</span></code>가 호출되는 객체에서 일치가 시작되므로, <em>preferencelist</em>가 기본값이면 <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>에서 <code class="docutils literal notranslate"><span class="pre">get_body</span></code>를 호출하면 객체 자신을 반환합니다. (3) <em class="mailheader">Content-Type</em>을 지정하지 않거나 <em class="mailheader">Content-Type</em> 헤더가 유효하지 않은 메시지(또는 메시지 파트)는 마치 <code class="docutils literal notranslate"><span class="pre">text/plain</span></code> 유형인 것처럼 처리되어, 간혹 <code class="docutils literal notranslate"><span class="pre">get_body</span></code>가 예기치 않은 결과를 반환하도록 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.iter_attachments">
<code class="sig-name descname">iter_attachments</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.iter_attachments" title="정의 주소">¶</a></dt>
<dd><p>&quot;본문&quot; 파트 후보가 아닌 메시지의 모든 직접적인 서브 파트에 대한 이터레이터를 반환합니다. 즉, <code class="docutils literal notranslate"><span class="pre">text/plain</span></code>, <code class="docutils literal notranslate"><span class="pre">text/html</span></code>, <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">multipart/alternative</span></code> 각각의 첫 번째 등장을 건너뛰고 (<em class="mailheader">Content-Disposition: attachment</em>를 통해 첨부 파일로 명시적으로 표시되지 않은 한), 나머지 모든 파트를 반환합니다. <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>에 직접 적용될 때, 루트 파트(즉: <code class="docutils literal notranslate"><span class="pre">start</span></code> 파라미터가 가리키는 파트나 <code class="docutils literal notranslate"><span class="pre">start</span></code> 파라미터가 없거나 <code class="docutils literal notranslate"><span class="pre">start</span></code> 파라미터가 파트들의 <em class="mailheader">Content-ID</em>와 일치하지 않으면 첫 번째 파트)를 제외한 모든 관련 파트에 대한 이터레이터를 반환합니다. <code class="docutils literal notranslate"><span class="pre">multipart/alternative</span></code> 또는 비-<code class="docutils literal notranslate"><span class="pre">multipart</span></code>에 직접 적용되면 빈 이터레이터를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.iter_parts">
<code class="sig-name descname">iter_parts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.iter_parts" title="정의 주소">¶</a></dt>
<dd><p>메시지의 모든 직계 서브 파트에 대한 이터레이터를 반환합니다. <code class="docutils literal notranslate"><span class="pre">multipart</span></code>가 아니면 비어있게 됩니다. (<a class="reference internal" href="#email.message.EmailMessage.walk" title="email.message.EmailMessage.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a>도 참조하십시오.)</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.get_content">
<code class="sig-name descname">get_content</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">content_manager=None</em>, <em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content" title="정의 주소">¶</a></dt>
<dd><p><em>content_manager</em>의 <a class="reference internal" href="email.contentmanager.html#email.contentmanager.ContentManager.get_content" title="email.contentmanager.ContentManager.get_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content()</span></code></a> 메서드를 호출합니다. 추가 인자로 제공되는 인자나 키워드와 함께 self를 메시지 객체로 전달합니다. <em>content_manager</em>가 지정되지 않으면, 현재 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a>가 지정하는 <code class="docutils literal notranslate"><span class="pre">content_manager</span></code>를 사용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.set_content">
<code class="sig-name descname">set_content</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">content_manager=None</em>, <em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_content" title="정의 주소">¶</a></dt>
<dd><p><em>content_manager</em>의 <a class="reference internal" href="email.contentmanager.html#email.contentmanager.ContentManager.set_content" title="email.contentmanager.ContentManager.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> 메서드를 호출합니다. 추가 인자로 제공되는 인자나 키워드와 함께 self를 메시지 객체로 전달합니다. <em>content_manager</em>가 지정되지 않으면, 현재 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a>가 지정하는 <code class="docutils literal notranslate"><span class="pre">content_manager</span></code>를 사용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.make_related">
<code class="sig-name descname">make_related</code><span class="sig-paren">(</span><em class="sig-param">boundary=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.make_related" title="정의 주소">¶</a></dt>
<dd><p>비 <code class="docutils literal notranslate"><span class="pre">multipart</span></code> 메시지를 <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> 메시지로 변환합니다. 기존 <em class="mailheader">Content-</em> 헤더와 페이 로드를 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>의 (새로운) 첫 파트로 옮깁니다. <em>boundary</em>가 지정되면, multipart에서 경계 문자열로 사용하고, 그렇지 않으면 필요할 때 (예를 들어, 메시지가 직렬화될 때) 경계가 자동으로 만들어지도록 둡니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.make_alternative">
<code class="sig-name descname">make_alternative</code><span class="sig-paren">(</span><em class="sig-param">boundary=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.make_alternative" title="정의 주소">¶</a></dt>
<dd><p>비 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>나 <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>를 <code class="docutils literal notranslate"><span class="pre">multipart/alternative</span></code>로 변환합니다. 기존 <em class="mailheader">Content-</em> 헤더와 페이 로드를 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>의 (새로운) 첫 파트로 옮깁니다. <em>boundary</em>가 지정되면, multipart에서 경계 문자열로 사용하고, 그렇지 않으면 필요할 때 (예를 들어, 메시지가 직렬화될 때) 경계가 자동으로 만들어지도록 둡니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.make_mixed">
<code class="sig-name descname">make_mixed</code><span class="sig-paren">(</span><em class="sig-param">boundary=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.make_mixed" title="정의 주소">¶</a></dt>
<dd><p>비 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>, <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">multipart-alternative</span></code>를 <code class="docutils literal notranslate"><span class="pre">multipart/mixed</span></code>로 변환합니다. 기존 <em class="mailheader">Content-</em> 헤더와 페이 로드를 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>의 (새로운) 첫 파트로 옮깁니다. <em>boundary</em>가 지정되면, multipart에서 경계 문자열로 사용하고, 그렇지 않으면 필요할 때 (예를 들어, 메시지가 직렬화될 때) 경계가 자동으로 만들어지도록 둡니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.add_related">
<code class="sig-name descname">add_related</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">content_manager=None</em>, <em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.add_related" title="정의 주소">¶</a></dt>
<dd><p>메시지가 <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>이면, 새 메시지 객체를 만들고, 모든 인자를 그것의 <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> 메서드에 전달하고, 그것을 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>에 <a class="reference internal" href="email.compat32-message.html#email.message.Message.attach" title="email.message.Message.attach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">attach()</span></code></a>합니다. 메시지가 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>가 아니면, <a class="reference internal" href="#email.message.EmailMessage.make_related" title="email.message.EmailMessage.make_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_related()</span></code></a>를 호출한 다음 위에서처럼 진행합니다. 메시지가 다른 유형의 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>이면, <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다. <em>content_manager</em>가 지정되지 않으면, 현재 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a>가 지정하는 <code class="docutils literal notranslate"><span class="pre">content_manager</span></code>를 사용합니다. 추가된 파트에 <em class="mailheader">Content-Disposition</em> 헤더가 없으면, 값 <code class="docutils literal notranslate"><span class="pre">inline</span></code>으로 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.add_alternative">
<code class="sig-name descname">add_alternative</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">content_manager=None</em>, <em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.add_alternative" title="정의 주소">¶</a></dt>
<dd><p>메시지가 <code class="docutils literal notranslate"><span class="pre">multipart/alternative</span></code>이면, 새 메시지 객체를 만들고, 모든 인자를 그것의 <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> 메서드에 전달하고, 그것을 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>에 <a class="reference internal" href="email.compat32-message.html#email.message.Message.attach" title="email.message.Message.attach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">attach()</span></code></a>합니다. 메시지가 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>가 아니거나 <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>이면, <a class="reference internal" href="#email.message.EmailMessage.make_alternative" title="email.message.EmailMessage.make_alternative"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_alternative()</span></code></a>를 호출한 다음 위에서처럼 진행합니다. 메시지가 다른 유형의 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>이면, <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다. <em>content_manager</em>가 지정되지 않으면, 현재 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a>가 지정하는 <code class="docutils literal notranslate"><span class="pre">content_manager</span></code>를 사용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.add_attachment">
<code class="sig-name descname">add_attachment</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">content_manager=None</em>, <em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.add_attachment" title="정의 주소">¶</a></dt>
<dd><p>메시지가 <code class="docutils literal notranslate"><span class="pre">multipart/mixed</span></code>이면, 새 메시지 객체를 만들고, 모든 인자를 그것의 <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> 메서드에 전달하고, 그것을 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>에 <a class="reference internal" href="email.compat32-message.html#email.message.Message.attach" title="email.message.Message.attach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">attach()</span></code></a>합니다. 메시지가 <code class="docutils literal notranslate"><span class="pre">multipart</span></code>가 아니거나, <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>나 <code class="docutils literal notranslate"><span class="pre">multipart/alternative</span></code>이면, <a class="reference internal" href="#email.message.EmailMessage.make_mixed" title="email.message.EmailMessage.make_mixed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_mixed()</span></code></a>를 호출한 다음 위에서처럼 진행합니다. <em>content_manager</em>가 지정되지 않으면, 현재 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a>가 지정하는 <code class="docutils literal notranslate"><span class="pre">content_manager</span></code>를 사용합니다. 추가된 파트에 <em class="mailheader">Content-Disposition</em> 헤더가 없으면, 값 <code class="docutils literal notranslate"><span class="pre">attachment</span></code>로 추가합니다. 이 메서드는 <code class="docutils literal notranslate"><span class="pre">content_manager</span></code>에 적절한 옵션을 전달하여 명시적 첨부(<em class="mailheader">Content-Disposition: attachment</em>)와 <code class="docutils literal notranslate"><span class="pre">inline</span></code> 첨부(<em class="mailheader">Content-Disposition: inline</em>)에 모두 사용할 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.clear" title="정의 주소">¶</a></dt>
<dd><p>페이 로드와 모든 헤더를 제거합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.EmailMessage.clear_content">
<code class="sig-name descname">clear_content</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.clear_content" title="정의 주소">¶</a></dt>
<dd><p>페이 로드와 모든 <code class="xref py py-exc docutils literal notranslate"><span class="pre">Content-</span></code> 헤더를 제거하고, 다른 모든 헤더는 원래 순서대로 그대로 둡니다.</p>
</dd></dl>

<p><a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 객체에는 다음과 같은 인스턴스 어트리뷰트가 있습니다:</p>
<dl class="attribute">
<dt id="email.message.EmailMessage.preamble">
<code class="sig-name descname">preamble</code><a class="headerlink" href="#email.message.EmailMessage.preamble" title="정의 주소">¶</a></dt>
<dd><p>MIME 문서의 형식은 헤더 다음의 빈 줄과 첫 번째 멀티 파트 경계 문자열 사이에 어떤 텍스트를 허용합니다. 일반적으로 이 텍스트는 표준 MIME 방어구를 벗어나기 때문에 MIME을 인식하는 메일 리더에서 보이지 않습니다. 그러나, 메시지의 원시 텍스트를 보거나, MIME을 인식하지 않는 리더에서 메시지를 볼 때 이 텍스트가 나타날 수 있습니다.</p>
<p><em>preamble</em> 어트리뷰트는 MIME 문서에 있는 이 선행 방어구 밖 텍스트를 포함합니다. <a class="reference internal" href="email.parser.html#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a>가 헤더 다음이지만 첫 번째 경계 문자열 이전에 있는 어떤 텍스트를 발견하면, 이 텍스트를 메시지의 <em>preamble</em> 어트리뷰트에 대입합니다. <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>가 MIME 메시지의 일반 텍스트(plain text) 표현을 기록할 때, 메시지가 <em>preamble</em> 어트리뷰트를 가진 것을 발견하면, 헤더와 첫 번째 경계 사이의 영역에 이 텍스트를 씁니다. 자세한 내용은 <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code></a>와 <a class="reference internal" href="email.generator.html#module-email.generator" title="email.generator: Generate flat text email messages from a message structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.generator</span></code></a>를 참조하십시오.</p>
<p>메시지 객체에 preamble이 없으면, <em>preamble</em> 어트리뷰트는 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.message.EmailMessage.epilogue">
<code class="sig-name descname">epilogue</code><a class="headerlink" href="#email.message.EmailMessage.epilogue" title="정의 주소">¶</a></dt>
<dd><p><em>epilogue</em> 어트리뷰트는 메시지의 마지막 경계와 끝 사이에 나타나는 텍스트를 포함한다는 점을 제외하고 <em>preamble</em> 어트리뷰트와 같은 방식으로 작동합니다. <a class="reference internal" href="#email.message.EmailMessage.preamble" title="email.message.EmailMessage.preamble"><code class="xref py py-attr docutils literal notranslate"><span class="pre">preamble</span></code></a>과 마찬가지로 epilog 텍스트가 없으면, 이 어트리뷰트는 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.message.EmailMessage.defects">
<code class="sig-name descname">defects</code><a class="headerlink" href="#email.message.EmailMessage.defects" title="정의 주소">¶</a></dt>
<dd><p><em>defects</em> 어트리뷰트는 이 메시지를 구문 분석할 때 발견된 모든 문제점의 리스트를 포함합니다. 가능한 구문 분석 결함에 대한 자세한 설명은 <a class="reference internal" href="email.errors.html#module-email.errors" title="email.errors: The exception classes used by the email package."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.errors</span></code></a>를 참조하십시오.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="email.message.MIMEPart">
<em class="property">class </em><code class="sig-prename descclassname">email.message.</code><code class="sig-name descname">MIMEPart</code><span class="sig-paren">(</span><em class="sig-param">policy=default</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.MIMEPart" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 MIME 메시지의 서브 파트를 나타냅니다. 서브 파트에는 자체 <em class="mailheader">MIME-Version</em> 헤더가 필요하지 않아서, <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a>를 호출할 때 <em class="mailheader">MIME-Version</em> 헤더가 추가되지 않는다는 점을 제외하면 <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>와 같습니다.</p>
</dd></dl>

<p class="rubric">각주</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>원래 3.4에서 <a class="reference internal" href="../glossary.html#term-provisional-package"><span class="xref std std-term">잠정 모듈</span></a>로 추가되었습니다. 레거시 메시지 클래스를 위한 설명서는 <a class="reference internal" href="email.compat32-message.html#compat32-message"><span class="std std-ref">email.message.Message: Representing an email message using the compat32 API</span></a>로 옮겼습니다.</p>
</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>이전 항목</h4>
  <p class="topless"><a href="email.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 전자 메일과 MIME 처리 패키지</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="email.parser.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code>: 전자 메일 메시지 구문 분석</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="email.parser.html" title="email.parser: 전자 메일 메시지 구문 분석"
             >다음</a> |</li>
        <li class="right" >
          <a href="email.html" title="email --- 전자 메일과 MIME 처리 패키지"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >인터넷 데이터 처리</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 전자 메일과 MIME 처리 패키지</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>