
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>email.policy: 정책 객체 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="email.errors: 예외와 결함 클래스" href="email.errors.html" />
    <link rel="prev" title="email.generator: MIME 문서 생성" href="email.generator.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/email.policy.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="email.errors.html" title="email.errors: 예외와 결함 클래스"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="email.generator.html" title="email.generator: MIME 문서 생성"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >인터넷 데이터 처리</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 전자 메일과 MIME 처리 패키지</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-email.policy">
<span id="email-policy-policy-objects"></span><h1><a class="reference internal" href="#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.policy</span></code></a>: 정책 객체<a class="headerlink" href="#module-email.policy" title="제목 주소">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/email/policy.py">Lib/email/policy.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 패키지의 주요 초점은 다양한 전자 우편과 MIME RFC에 설명된 대로 전자 우편 메시지를 처리하는 것입니다. 그러나 전자 우편 메시지의 일반적인 형식(각각 이름, 콜론, 값 순으로 구성된 헤더 필드의 블록, 빈 줄과 임의의 '본문' 이 뒤따르는 전체 블록)은 전자 우편 영역 밖에서도 용도가 발견되는 형식입니다. 이러한 용도 중 일부는 메인 전자 우편 RFC와 상당히 유사하지만, 일부는 그렇지 않습니다. 전자 우편으로 작업할 때에도, RFC의 엄격한 준수를 위반하는 것이 바람직할 때가 있습니다. 가령 표준을 따르지 않는 전자 우편 서버와 상호 운영되거나 표준을 위반하는 방식으로 사용하기 원하는 확장을 구현하는 전자 우편을 생성하는 경우가 그렇습니다.</p>
<p>정책 객체는 email 패키지에 이러한 개별 사용 사례를 모두 처리 할 수 있는 유연성을 제공합니다.</p>
<p><a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 객체는 사용 중에 email 패키지의 다양한 구성 요소 동작을 제어하는 일련의 어트리뷰트와 메서드를 캡슐화합니다. <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 인스턴스는 email 패키지의 다양한 클래스와 메서드로 전달되어 기본 동작을 변경할 수 있습니다. 설정 가능한 값과 기본값은 아래에 설명되어 있습니다.</p>
<p>email 패키지의 모든 클래스에서 사용되는 기본 정책이 있습니다. 모든 <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a> 클래스와 관련 편의 함수 및 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 클래스의 경우, 이것은 사전 정의된 인스턴스 <a class="reference internal" href="#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-const docutils literal notranslate"><span class="pre">compat32</span></code></a>를 통한 <a class="reference internal" href="#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compat32</span></code></a> 정책입니다. 이 정책은 파이썬 3.3 이전 버전의 email 패키지와 완전한 과거 호환성(어떤 경우에는, 버그 호환성을 포함합니다)을 제공합니다.</p>
<p><a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>에 대한 <em>policy</em> 키워드의 기본값은 사전 정의된 인스턴스 <a class="reference internal" href="#email.policy.default" title="email.policy.default"><code class="xref py py-data docutils literal notranslate"><span class="pre">default</span></code></a>를 통한 <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a> 정책입니다.</p>
<p><a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>나 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 객체가 만들어질 때, 정책을 획득합니다. 메시지가 <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a>로 만들어지면, 구문 분석기에 전달된 정책이 만들어지는 메시지가 사용하는 정책이 됩니다. 프로그램이 메시지를 만들면, 만들 때 정책을 지정할 수 있습니다. 메시지가 <a class="reference internal" href="email.generator.html#module-email.generator" title="email.generator: Generate flat text email messages from a message structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">generator</span></code></a>에 전달될 때, 제너레이터는 기본적으로 메시지의 정책을 사용하지만, 특정 정책을 제너레이터에 전달하여 메시지 객체에 저장된 정책을 재정의할 수도 있습니다.</p>
<p><a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code></a> 클래스와 구문 분석기 편의 함수에 대한 <em>policy</em> 키워드의 기본값은 이후 버전의 파이썬에서 <strong>변경될 예정</strong>입니다. 따라서 <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a> 모듈에서 설명된 클래스와 함수를 호출할 때는 <strong>항상 사용할 정책을 명시적으로 지정</strong>해야 합니다.</p>
<p>이 설명서의 첫 부분은 <a class="reference internal" href="#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-const docutils literal notranslate"><span class="pre">compat32</span></code></a>를 포함한 모든 정책 객체에 공통적인 기능을 정의하는 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">추상 베이스 클래스</span></a> 인 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a>의 기능을 다룹니다. 여기에는 email 패키지에 의해 내부적으로 호출되는 특정 훅 메서드가 포함되며, 사용자 정의 정책은 다른 동작을 얻기 위해 재정의할 수 있습니다. 두 번째 부분에서는 표준 동작과 이전 버전과 호환되는 동작과 기능을 각각 제공하는 훅을 구현하는 구상 클래스 <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a>와 <a class="reference internal" href="#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compat32</span></code></a>를 설명합니다.</p>
<p><a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 인스턴스는 불변이지만, 복제할 수 있는데, 클래스 생성자와 같은 키워드 인자를 받아들이고 원본의 사본이지만 지정된 어트리뷰트 값이 변경된 새 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 인스턴스를 반환합니다.</p>
<p>예를 들어, 다음 코드를 사용하여 디스크의 파일에서 전자 우편 메시지를 읽고 유닉스 시스템의 시스템 <code class="docutils literal notranslate"><span class="pre">sendmail</span></code> 프로그램으로 전달할 수 있습니다:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email</span> <span class="k">import</span> <span class="n">message_from_binary_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email.generator</span> <span class="k">import</span> <span class="n">BytesGenerator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email</span> <span class="k">import</span> <span class="n">policy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">subprocess</span> <span class="k">import</span> <span class="n">Popen</span><span class="p">,</span> <span class="n">PIPE</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;mymsg.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">msg</span> <span class="o">=</span> <span class="n">message_from_binary_file</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">policy</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;sendmail&#39;</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;To&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">addresses</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">stdin</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">BytesGenerator</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">stdin</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>여기서 우리는 <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a>에게 <code class="docutils literal notranslate"><span class="pre">sendmail</span></code>의 <code class="docutils literal notranslate"><span class="pre">stdin</span></code>으로 공급할 바이너리 문자열을 만들 때 RFC 올바른 줄 구분자 문자를 사용하도록 지시합니다. 기본 정책은 <code class="docutils literal notranslate"><span class="pre">\n</span></code> 줄 구분자를 사용합니다.</p>
<p>일부 email 패키지 메서드는 <em>policy</em> 키워드 인자를 받아들여, 해당 메서드에 대한 정책을 대체 할 수 있도록 합니다. 예를 들어, 다음 코드는 이전 예제의 <em>msg</em> 객체의 <a class="reference internal" href="email.compat32-message.html#email.message.Message.as_bytes" title="email.message.Message.as_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_bytes()</span></code></a> 메서드를 사용하고 실행 중인 플랫폼의 기본 줄 구분자를 사용하여 메시지를 파일에 씁니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;converted.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">as_bytes</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)))</span>
<span class="go">17</span>
</pre></div>
</div>
<p>더하기 연산자를 사용하여 정책 객체를 결합하여, 기본값이 아닌 설정이 합쳐진 조합으로 설정된 정책 객체를 생성할 수도 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">compat_SMTP</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compat_strict</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">raise_on_defect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compat_strict_SMTP</span> <span class="o">=</span> <span class="n">compat_SMTP</span> <span class="o">+</span> <span class="n">compat_strict</span>
</pre></div>
</div>
<p>이 연산은 교환적(commutative)이지 않습니다; 즉, 객체가 더해지는 순서가 중요합니다. 예시하면 이렇습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">policy100</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">max_line_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">policy80</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">max_line_length</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span> <span class="o">=</span> <span class="n">policy100</span> <span class="o">+</span> <span class="n">policy80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span><span class="o">.</span><span class="n">max_line_length</span>
<span class="go">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span> <span class="o">=</span> <span class="n">policy80</span> <span class="o">+</span> <span class="n">policy100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span><span class="o">.</span><span class="n">max_line_length</span>
<span class="go">100</span>
</pre></div>
</div>
<dl class="class">
<dt id="email.policy.Policy">
<em class="property">class </em><code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">Policy</code><span class="sig-paren">(</span><em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy" title="정의 주소">¶</a></dt>
<dd><p>모든 정책 클래스의 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">추상 베이스 클래스</span></a>입니다. 불변 속성, <a class="reference internal" href="#email.policy.Policy.clone" title="email.policy.Policy.clone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clone()</span></code></a> 메서드 및 생성자 시맨틱의 구현뿐만 아니라 몇 가지 간단한 메서드에 대한 기본 구현을 제공합니다.</p>
<p>정책 클래스의 생성자에는 다양한 키워드 인자가 전달될 수 있습니다. 지정할 수 있는 인자는 이 클래스의 메서드 이외의 프로퍼티, 그리고 구상 클래스의 메서드 이외의 프로퍼티입니다. 생성자에 지정된 값은 해당 어트리뷰트의 기본값을 재정의합니다.</p>
<p>이 클래스는 다음 프로퍼티를 정의합니다. 따라서, 모든 정책 클래스의 생성자에 다음에 대한 값이 전달될 수 있습니다:</p>
<dl class="attribute">
<dt id="email.policy.Policy.max_line_length">
<code class="sig-name descname">max_line_length</code><a class="headerlink" href="#email.policy.Policy.max_line_length" title="정의 주소">¶</a></dt>
<dd><p>줄 종료 문자를 포함하지 않고, 직렬화된 출력에서 줄의 최대 길이. <span class="target" id="index-20"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>에 따라 기본값은 78입니다. <code class="docutils literal notranslate"><span class="pre">0</span></code>이나 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 값은 줄 바꿈을 전혀 수행하지 않아야 함을 나타냅니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.linesep">
<code class="sig-name descname">linesep</code><a class="headerlink" href="#email.policy.Policy.linesep" title="정의 주소">¶</a></dt>
<dd><p>직렬화된 출력에서 줄을 종료하는 데 사용되는 문자열입니다. RFC는 <code class="docutils literal notranslate"><span class="pre">\r\n</span></code>을 요구하지만, 기본값은 파이썬에서 사용하는 내부 줄 종료 규칙을 따라 <code class="docutils literal notranslate"><span class="pre">\n</span></code>입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.cte_type">
<code class="sig-name descname">cte_type</code><a class="headerlink" href="#email.policy.Policy.cte_type" title="정의 주소">¶</a></dt>
<dd><p>사용해야 하는 콘텐츠 전송 인코딩(Content Transfer Encoding) 유형을 제어합니다. 가능한 값은 다음과 같습니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">7bit</span></code></p></td>
<td><p>모든 데이터는 &quot;7비트 클린&quot;(ASCII 전용)이어야 합니다. 즉, 필요하면 quoted-printable이나 base64 인코딩을 사용하여 데이터를 인코딩합니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">8bit</span></code></p></td>
<td><p>데이터는 7비트 클린으로 제한되지 않습니다. 헤더의 데이터는 여전히 ASCII 전용이어야 하므로 인코딩되지만 (예외는 아래 <a class="reference internal" href="#email.policy.Policy.fold_binary" title="email.policy.Policy.fold_binary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold_binary()</span></code></a>와 <a class="reference internal" href="#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a>을 참조하십시오), 본문 부분은 <code class="docutils literal notranslate"><span class="pre">8bit</span></code> CTE를 사용할 수 있습니다.</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">8bit</span></code> <code class="docutils literal notranslate"><span class="pre">cte_type</span></code> 값은 문자열이 바이너리 데이터를 포함할 수 없어서 <code class="docutils literal notranslate"><span class="pre">Generator</span></code>가 아닌 <code class="docutils literal notranslate"><span class="pre">BytesGenerator</span></code>에서만 작동합니다. <code class="docutils literal notranslate"><span class="pre">Generator</span></code>가 <code class="docutils literal notranslate"><span class="pre">cte_type=8bit</span></code>를 지정하는 정책에 따라 작동하면, <code class="docutils literal notranslate"><span class="pre">cte_type</span></code>이 <code class="docutils literal notranslate"><span class="pre">7bit</span></code>인 것처럼 동작합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.raise_on_defect">
<code class="sig-name descname">raise_on_defect</code><a class="headerlink" href="#email.policy.Policy.raise_on_defect" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>이면, 만나는 모든 결함을 에러로 발생시킵니다. <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>(기본값)이면, 결함은 <a class="reference internal" href="#email.policy.Policy.register_defect" title="email.policy.Policy.register_defect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_defect()</span></code></a> 메서드로 전달됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.mangle_from_">
<code class="sig-name descname">mangle_from_</code><a class="headerlink" href="#email.policy.Policy.mangle_from_" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>이면, 본문에서 <em>&quot;From &quot;</em>으로 시작하는 줄은 <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>를 앞에 배치하여 이스케이프 됩니다. 이 매개 변수는 제너레이터가 메시지를 직렬화할 때 사용됩니다. 기본값: <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가: </span><em>mangle_from_</em> 매개 변수.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.message_factory">
<code class="sig-name descname">message_factory</code><a class="headerlink" href="#email.policy.Policy.message_factory" title="정의 주소">¶</a></dt>
<dd><p>새로운 빈 메시지 객체를 생성하기 위한 팩토리 함수. 메시지를 구축할 때 구분 분석기가 사용합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>이며, 이때 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>가 사용됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<p>다음 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 메서드는 email 라이브러리를 사용하여 사용자 정의 설정으로 정책 인스턴스를 만드는 코드가 호출하기 위한 것입니다:</p>
<dl class="method">
<dt id="email.policy.Policy.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.clone" title="정의 주소">¶</a></dt>
<dd><p>키워드 인자로 새로운 값이 부여되는 어트리뷰트를 제외하고, 어트리뷰트가 현재 인스턴스와 같은 값을 갖는 새로운 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 인스턴스를 반환합니다.</p>
</dd></dl>

<p>나머지 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 메서드는 email 패키지 코드에 의해 호출되며, email 패키지를 사용하는 응용 프로그램에 의해 호출되는 용도가 아닙니다. 사용자 정의 정책은 이 모든 메서드를 구현해야 합니다.</p>
<dl class="method">
<dt id="email.policy.Policy.handle_defect">
<code class="sig-name descname">handle_defect</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">defect</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.handle_defect" title="정의 주소">¶</a></dt>
<dd><p><em>obj</em>에서 찾은 <em>defect</em>를 처리합니다. email 패키지가 이 메서드를 호출할 때, <em>defect</em>는 항상 <code class="xref py py-class docutils literal notranslate"><span class="pre">Defect</span></code>의 서브 클래스입니다.</p>
<p>기본 구현은 <a class="reference internal" href="#email.policy.Policy.raise_on_defect" title="email.policy.Policy.raise_on_defect"><code class="xref py py-attr docutils literal notranslate"><span class="pre">raise_on_defect</span></code></a> 플래그를 확인합니다. <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, <em>defect</em>가 예외로 발생합니다. <code class="docutils literal notranslate"><span class="pre">False</span></code>(기본값)이면 <em>obj</em>와 <em>defect</em>가 <a class="reference internal" href="#email.policy.Policy.register_defect" title="email.policy.Policy.register_defect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_defect()</span></code></a>로 전달됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.register_defect">
<code class="sig-name descname">register_defect</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">defect</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.register_defect" title="정의 주소">¶</a></dt>
<dd><p><em>obj</em>에 <em>defect</em>를 등록합니다. email 패키지에서, <em>defect</em>는 항상 <code class="xref py py-class docutils literal notranslate"><span class="pre">Defect</span></code>의 서브 클래스입니다.</p>
<p>기본 구현은 <em>obj</em>의 <code class="docutils literal notranslate"><span class="pre">defects</span></code> 어트리뷰트의 <code class="docutils literal notranslate"><span class="pre">append</span></code> 메서드를 호출합니다. email 패키지가 <a class="reference internal" href="#email.policy.Policy.handle_defect" title="email.policy.Policy.handle_defect"><code class="xref py py-attr docutils literal notranslate"><span class="pre">handle_defect</span></code></a>를 호출할 때, <em>obj</em>는 일반적으로 <code class="docutils literal notranslate"><span class="pre">append</span></code> 메서드가 있는 <code class="docutils literal notranslate"><span class="pre">defects</span></code> 어트리뷰트가 있습니다. email 패키지와 함께 사용되는 사용자 정의 객체 형(예를 들어, 사용자 정의 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 객체)도 이러한 어트리뷰트를 제공해야 합니다, 그렇지 않으면 구문 분석된 메시지의 결함이 예기치 않은 에러를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_max_count">
<code class="sig-name descname">header_max_count</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_max_count" title="정의 주소">¶</a></dt>
<dd><p><em>name</em>이라는 헤더의 최대 허용 개수를 반환합니다.</p>
<p>헤더가 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>나 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 객체에 추가될 때 호출됩니다. 반환 값이 <code class="docutils literal notranslate"><span class="pre">0</span></code>이나 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니고, 반환 값보다 크거나 같은 수의 이름이 <em>name</em>인 헤더가 이미 있으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">Message.__setitem__</span></code>의 기본 동작은 값을 헤더 리스트에 추가하는 것이므로, 깨닫지 못하는 사이에 중복 헤더를 만들기 쉽습니다. 이 메서드는 특정 헤더를 <code class="docutils literal notranslate"><span class="pre">Message</span></code>에 프로그래밍 방식으로 추가할 수 있는 인스턴스의 수를 제한할 수 있도록 합니다. (이 제약은 구문 분석기가 보지 않습니다, 구문 분석기는 구문 분석 중인 메시지에 존재하는 수 만큼 헤더를 충실하게 생성합니다.)</p>
<p>기본 구현은 모든 헤더 이름에 대해 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_source_parse">
<code class="sig-name descname">header_source_parse</code><span class="sig-paren">(</span><em class="sig-param">sourcelines</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_source_parse" title="정의 주소">¶</a></dt>
<dd><p>email 패키지는 문자열 리스트로 이 메서드를 호출하며, 각 문자열은 구문 분석 중인 소스에서 발견된 줄 구분 문자로 끝납니다. 첫 번째 줄에는 필드 헤더 이름과 구분자가 포함됩니다. 소스의 모든 공백이 유지됩니다. 이 메서드는 구문 분석된 헤더를 나타내기 위해 <code class="docutils literal notranslate"><span class="pre">Message</span></code>에 저장될 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> 튜플을 반환해야 합니다.</p>
<p>구현이 기존 email 패키지 정책과의 호환성을 유지하기 원한다면, <em>name</em>은 대소 문자를 유지한 이름( '<code class="docutils literal notranslate"><span class="pre">:</span></code>' 구분자까지의 모든 문자)이어야 하지만, <em>value</em>는 선행 공백이 제거되고 펼쳐진(unfolded) 값(모든 줄 구분자 문자는 제거하지만, 공백은 그대로 유지한)이어야 합니다.</p>
<p><em>sourcelines</em>는 서로게이트 이스케이프 된 바이너리 데이터를 포함할 수 있습니다.</p>
<p>기본 구현이 없습니다</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_store_parse">
<code class="sig-name descname">header_store_parse</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_store_parse" title="정의 주소">¶</a></dt>
<dd><p>email 패키지는 (구문 분석기가 만든 <code class="docutils literal notranslate"><span class="pre">Message</span></code>가 아니라) 응용 프로그램이 <code class="docutils literal notranslate"><span class="pre">Message</span></code>를 프로그래밍 방식으로 수정할 때, 응용 프로그램이 제공한 name과 value로 이 메서드를 호출합니다. 이 메서드는 헤더를 나타내기 위해 <code class="docutils literal notranslate"><span class="pre">Message</span></code>에 저장될 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> 튜플을 반환해야 합니다.</p>
<p>구현이 기존 email 패키지 정책과의 호환성을 유지하기 원한다면, <em>name</em>과 <em>value</em>는 전달된 인자의 내용을 변경하지 않는 문자열이나 문자열의 서브 클래스여야 합니다.</p>
<p>기본 구현이 없습니다</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_fetch_parse">
<code class="sig-name descname">header_fetch_parse</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_fetch_parse" title="정의 주소">¶</a></dt>
<dd><p>email 패키지는 응용 프로그램이 해당 헤더를 요청할 때 <code class="docutils literal notranslate"><span class="pre">Message</span></code>에 현재 저장된 <em>name</em>과 <em>value</em>로 이 메서드를 호출하며, 메서드가 반환하는 것은 꺼내는 헤더의 값으로 응용 프로그램에 다시 전달됩니다. <code class="docutils literal notranslate"><span class="pre">Message</span></code>에 같은 이름을 가진 헤더가 두 개 이상 있을 수 있음에 유의하십시오; 이 메서드로는 응용 프로그램으로 반환될 헤더의 특정 이름과 값이 전달됩니다.</p>
<p><em>value</em>는 서로게이트 이스케이프 된 바이너리 데이터를 포함할 수 있습니다. 이 메서드가 반환하는 값에는 서로게이트 이스케이프 된 바이너리 데이터가 없어야 합니다.</p>
<p>기본 구현이 없습니다</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.fold">
<code class="sig-name descname">fold</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.fold" title="정의 주소">¶</a></dt>
<dd><p>email 패키지는 지정된 헤더에 대해 <code class="docutils literal notranslate"><span class="pre">Message</span></code>에 현재 저장된 <em>name</em>과 <em>value</em>로 이 메서드를 호출합니다. 이 메서드는 <em>name</em>을 <em>value</em>와 합치고 적절한 위치에 <a class="reference internal" href="#email.policy.Policy.linesep" title="email.policy.Policy.linesep"><code class="xref py py-attr docutils literal notranslate"><span class="pre">linesep</span></code></a> 문자를 삽입하여 (정책 설정에 따라) 올바르게 &quot;접힌(folded)&quot; 헤더를 나타내는 문자열을 반환해야 합니다. 전자 우편 헤더 접기 규칙에 대한 설명은 <span class="target" id="index-21"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>를 참조하십시오.</p>
<p><em>value</em>는 서로게이트 이스케이프 된 바이너리 데이터를 포함할 수 있습니다. 메서드가 반환한 문자열에는 서로게이트 이스케이프 된 바이너리 데이터가 없어야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.fold_binary">
<code class="sig-name descname">fold_binary</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.fold_binary" title="정의 주소">¶</a></dt>
<dd><p>반환 값이 문자열이 아니라 바이트열 객체여야 한다는 점을 제외하고는 <a class="reference internal" href="#email.policy.Policy.fold" title="email.policy.Policy.fold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold()</span></code></a>와 같습니다.</p>
<p><em>value</em>는 서로게이트 이스케이프 된 바이너리 데이터를 포함할 수 있습니다. 이들은 반환된 바이트열 객체에서 바이너리 데이터로 다시 변환될 수 있습니다.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="email.policy.EmailPolicy">
<em class="property">class </em><code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">EmailPolicy</code><span class="sig-paren">(</span><em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy" title="정의 주소">¶</a></dt>
<dd><p>이 구상 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a>는 현재 전자 우편 RFC를 완전히 준수하기 위한 동작을 제공합니다. 여기에는 <span class="target" id="index-22"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>, <span class="target" id="index-23"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html"><strong>RFC 2047</strong></a> 및 현재 MIME RFC가 포함되지만 이에 국한되지는 않습니다.</p>
<p>이 정책은 새로운 헤더 구문 분석과 접기(folding) 알고리즘을 추가합니다. 단순한 문자열 대신, 헤더는 필드 유형에 따라 달라지는 어트리뷰트를 가진 <code class="docutils literal notranslate"><span class="pre">str</span></code> 서브 클래스입니다. 구문 분석과 접기 알고리즘은 <span class="target" id="index-24"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html"><strong>RFC 2047</strong></a>과 <span class="target" id="index-25"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>를 완전히 구현합니다.</p>
<p><a class="reference internal" href="#email.policy.Policy.message_factory" title="email.policy.Policy.message_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">message_factory</span></code></a> 어트리뷰트의 기본값은 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>입니다.</p>
<p>모든 정책에 적용되는 위에 나열된 설정 가능 어트리뷰트 외에도, 이 정책은 다음과 같은 어트리뷰트를 추가합니다:</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가: </span><a class="footnote-reference brackets" href="#id2" id="id1">1</a></p>
</div>
<dl class="attribute">
<dt id="email.policy.EmailPolicy.utf8">
<code class="sig-name descname">utf8</code><a class="headerlink" href="#email.policy.EmailPolicy.utf8" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">False</span></code>이면, <span class="target" id="index-26"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>를 따르고 헤더에서 ASCII가 아닌 문자를 &quot;인코딩된 단어&quot;로 인코딩하여 지원합니다. <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, <span class="target" id="index-27"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6532.html"><strong>RFC 6532</strong></a>를 따르고 헤더에 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> 인코딩을 사용합니다. 이러한 방식으로 포맷된 메시지는 <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> 확장(<span class="target" id="index-28"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6531.html"><strong>RFC 6531</strong></a>)을 지원하는 SMTP 서버로 전달될 수 있습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.EmailPolicy.refold_source">
<code class="sig-name descname">refold_source</code><a class="headerlink" href="#email.policy.EmailPolicy.refold_source" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Message</span></code> 객체의 헤더 값이 (프로그램이 설정하는 것과 대조적으로) <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a>에서 온 것이면, 이 어트리뷰트는 메시지를 직렬화된 형식으로 다시 변환할 때 제너레이터가 그 값을 다시 접어야 하는지를 나타냅니다. 가능한 값은 다음과 같습니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">none</span></code></p></td>
<td><p>모든 소스 값은 원래 접기를 사용합니다</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">long</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">max_line_length</span></code>보다 긴 줄이 있는 소스 값은 다시 접힙니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">all</span></code></p></td>
<td><p>모든 값이 다시 접힙니다.</p></td>
</tr>
</tbody>
</table>
<p>기본값은 <code class="docutils literal notranslate"><span class="pre">long</span></code>입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.EmailPolicy.header_factory">
<code class="sig-name descname">header_factory</code><a class="headerlink" href="#email.policy.EmailPolicy.header_factory" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">name</span></code>과 <code class="docutils literal notranslate"><span class="pre">value</span></code> 두 개의 인자를 취하는 콜러블. 여기서 <code class="docutils literal notranslate"><span class="pre">name</span></code>은 헤더 필드 이름이고 <code class="docutils literal notranslate"><span class="pre">value</span></code>는 펼쳐진 헤더 필드 값이며 해당 헤더를 나타내는 문자열 서브 클래스를 반환합니다. 다양한 주소와 날짜 <span class="target" id="index-29"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a> 헤더 필드 유형과 주요 MIME 헤더 필드 유형에 대한 사용자 정의 구문 분석을 지원하는 기본 <code class="docutils literal notranslate"><span class="pre">header_factory</span></code>(<a class="reference internal" href="email.headerregistry.html#module-email.headerregistry" title="email.headerregistry: Automatic Parsing of headers based on the field name"><code class="xref py py-mod docutils literal notranslate"><span class="pre">headerregistry</span></code></a>를 참조하십시오)가 제공됩니다. 향후 추가 사용자 정의 구문 분석에 대한 지원이 추가될 것입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.EmailPolicy.content_manager">
<code class="sig-name descname">content_manager</code><a class="headerlink" href="#email.policy.EmailPolicy.content_manager" title="정의 주소">¶</a></dt>
<dd><p>적어도 두 개의 메서드가 있는 객체: get_content와 set_content. <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 객체의 <a class="reference internal" href="email.message.html#email.message.EmailMessage.get_content" title="email.message.EmailMessage.get_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content()</span></code></a>나 <a class="reference internal" href="email.message.html#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> 메서드가 호출될 때, 이 객체의 해당 메서드를 호출하는데, 메시지 객체를 첫 번째 인자로 전달하고 전달된 다른 인자와 키워드를 추가 인자로 전달합니다. 기본적으로 <code class="docutils literal notranslate"><span class="pre">content_manager</span></code>는 <a class="reference internal" href="email.contentmanager.html#email.contentmanager.raw_data_manager" title="email.contentmanager.raw_data_manager"><code class="xref py py-data docutils literal notranslate"><span class="pre">raw_data_manager</span></code></a>로 설정됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<p>이 클래스는 다음과 같은 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a>의 추상 메서드의 구상 구현을 제공합니다:</p>
<dl class="method">
<dt id="email.policy.EmailPolicy.header_max_count">
<code class="sig-name descname">header_max_count</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_max_count" title="정의 주소">¶</a></dt>
<dd><p>지정된 이름의 헤더를 나타내는 데 사용되는 특수화된 클래스의 <a class="reference internal" href="email.headerregistry.html#email.headerregistry.BaseHeader.max_count" title="email.headerregistry.BaseHeader.max_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_count</span></code></a> 어트리뷰트 값을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.header_source_parse">
<code class="sig-name descname">header_source_parse</code><span class="sig-paren">(</span><em class="sig-param">sourcelines</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_source_parse" title="정의 주소">¶</a></dt>
<dd><p>이름은 '<code class="docutils literal notranslate"><span class="pre">:</span></code>'까지의 모든 것으로 구문 분석되고 수정되지 않은 상태로 반환됩니다. 값은 첫 번째 줄의 나머지 부분에서 선행 공백을 제거한 후에 모든 후속 줄을 이어붙이고 후행 캐리지 리턴이나 줄 바꿈 문자를 제거하여 결정됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.header_store_parse">
<code class="sig-name descname">header_store_parse</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_store_parse" title="정의 주소">¶</a></dt>
<dd><p>이름은 변경되지 않고 반환됩니다. 입력값에 <code class="docutils literal notranslate"><span class="pre">name</span></code> 어트리뷰트가 있고 대소 문자를 무시하고 <em>name</em>과 일치하면, 값은 변경되지 않고 반환됩니다. 그렇지 않으면 <em>name</em>과 <em>value</em>는 <code class="docutils literal notranslate"><span class="pre">header_factory</span></code>로 전달되고, 결과 헤더 객체가 값으로 반환됩니다. 이 경우 입력값에 CR이나 LF 문자가 포함되어 있으면 <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>가 발생합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.header_fetch_parse">
<code class="sig-name descname">header_fetch_parse</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_fetch_parse" title="정의 주소">¶</a></dt>
<dd><p>값에 <code class="docutils literal notranslate"><span class="pre">name</span></code> 어트리뷰트가 있으면, 수정되지 않은 상태로 반환됩니다. 그렇지 않으면 <em>name</em>과 CR이나 LF 문자가 제거된 <em>value</em>가 <code class="docutils literal notranslate"><span class="pre">header_factory</span></code>로 전달되고, 결과 헤더 객체가 반환됩니다. 서로게이트 이스케이프 된 바이트열은 유니코드 알 수 없는 문자 글리프(unknown-character glyph)로 바뀝니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.fold">
<code class="sig-name descname">fold</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.fold" title="정의 주소">¶</a></dt>
<dd><p>헤더 접기는 <a class="reference internal" href="#email.policy.EmailPolicy.refold_source" title="email.policy.EmailPolicy.refold_source"><code class="xref py py-attr docutils literal notranslate"><span class="pre">refold_source</span></code></a> 정책 설정에 의해 제어됩니다. 값은 <code class="docutils literal notranslate"><span class="pre">name</span></code> 어트리뷰트가 없을 때, 그리고 그때만 '소스값'으로 간주합니다 (<code class="docutils literal notranslate"><span class="pre">name</span></code> 어트리뷰트가 있다는 것은 헤더 객체나 그 일종이라는 뜻입니다). 정책에 따라 소스값을 다시 접어야 할 필요가 있으면, <code class="docutils literal notranslate"><span class="pre">header_factory</span></code>에 <em>name</em>과 CR과 LF 문자가 제거된 <em>value</em>를 전달하여 헤더 객체로 변환됩니다. 헤더 객체의 접기는 현재 정책으로 <code class="docutils literal notranslate"><span class="pre">fold</span></code> 메서드를 호출하여 수행됩니다.</p>
<p>소스값은 <a class="reference internal" href="stdtypes.html#str.splitlines" title="str.splitlines"><code class="xref py py-meth docutils literal notranslate"><span class="pre">splitlines()</span></code></a>를 사용하여 줄로 분할됩니다. 값을 다시 접지 않으면, 정책의 <code class="docutils literal notranslate"><span class="pre">linesep</span></code>을 사용하여 줄을 다시 이어붙인 후에 반환합니다. ASCII가 아닌 바이너리 데이터가 포함된 줄은 예외입니다. 이 경우 <code class="docutils literal notranslate"><span class="pre">refold_source</span></code> 설정과 관계없이 값이 다시 접히는데, <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> 문자 집합을 사용하여 바이너리 데이터가 CTE로 인코딩됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.fold_binary">
<code class="sig-name descname">fold_binary</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.fold_binary" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#email.policy.Policy.cte_type" title="email.policy.Policy.cte_type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cte_type</span></code></a>이 <code class="docutils literal notranslate"><span class="pre">7bit</span></code>이면, 반환된 값이 바이트열인 것을 제외하고 <a class="reference internal" href="#email.policy.EmailPolicy.fold" title="email.policy.EmailPolicy.fold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold()</span></code></a>와 같습니다.</p>
<p><a class="reference internal" href="#email.policy.Policy.cte_type" title="email.policy.Policy.cte_type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cte_type</span></code></a>이 <code class="docutils literal notranslate"><span class="pre">8bit</span></code>이면, ASCII가 아닌 바이너리 데이터는 다시 바이트열로 변환됩니다. 바이너리 데이터가 단일 바이트 문자와 멀티 바이트 문자 중 어는 것으로 구성되어 있는지 알 방법이 없어서, <code class="docutils literal notranslate"><span class="pre">refold_header</span></code> 설정과 관계없이 바이너리 데이터가 있는 헤더는 다시 접히지 않습니다.</p>
</dd></dl>

</dd></dl>

<p>다음 <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a> 인스턴스는 특정 응용 프로그램 도메인에 적합한 기본값을 제공합니다. 향후 이러한 인스턴스들(특히 <code class="docutils literal notranslate"><span class="pre">HTTP</span></code> 인스턴스)의 동작은 그 들의 도메인과 관련된 RFC에 훨씬 더 가깝게 조정될 수 있음에 유의하십시오.</p>
<dl class="data">
<dt id="email.policy.default">
<code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">default</code><a class="headerlink" href="#email.policy.default" title="정의 주소">¶</a></dt>
<dd><p>모든 기본값이 변경되지 않은 <code class="docutils literal notranslate"><span class="pre">EmailPolicy</span></code> 인스턴스. 이 정책은 RFC 올바른 <code class="docutils literal notranslate"><span class="pre">\r\n</span></code>이 아닌 표준 파이썬 <code class="docutils literal notranslate"><span class="pre">\n</span></code> 줄 종료를 사용합니다.</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.SMTP">
<code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">SMTP</code><a class="headerlink" href="#email.policy.SMTP" title="정의 주소">¶</a></dt>
<dd><p>전자 우편 RFC를 준수하도록 메시지를 직렬화하는 데 적합합니다. <code class="docutils literal notranslate"><span class="pre">default</span></code>와 유사하지만, <code class="docutils literal notranslate"><span class="pre">linesep</span></code>이 <code class="docutils literal notranslate"><span class="pre">\r\n</span></code>으로 설정되어 RFC를 준수합니다.</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.SMTPUTF8">
<code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">SMTPUTF8</code><a class="headerlink" href="#email.policy.SMTPUTF8" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>라는 점을 제외하고, <code class="docutils literal notranslate"><span class="pre">SMTP</span></code>와 같습니다. 헤더에 인코딩된 단어를 사용하지 않고 메시지를 메시지 저장소로 직렬화하는 데 유용합니다. SMTP 전송에는 발신자나 수신자 주소에 ASCII가 아닌 문자가 있을 때만 사용해야 합니다 (<a class="reference internal" href="smtplib.html#smtplib.SMTP.send_message" title="smtplib.SMTP.send_message"><code class="xref py py-meth docutils literal notranslate"><span class="pre">smtplib.SMTP.send_message()</span></code></a> 메서드는 이를 자동으로 처리합니다).</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.HTTP">
<code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">HTTP</code><a class="headerlink" href="#email.policy.HTTP" title="정의 주소">¶</a></dt>
<dd><p>HTTP 트래픽에 사용하기 위해 헤더를 직렬화하는 데 적합합니다. <code class="docutils literal notranslate"><span class="pre">max_line_length</span></code>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>(무제한)으로 설정된 것을 제외하고, <code class="docutils literal notranslate"><span class="pre">SMTP</span></code>와 유사합니다.</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.strict">
<code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">strict</code><a class="headerlink" href="#email.policy.strict" title="정의 주소">¶</a></dt>
<dd><p>편의 인스턴스. <code class="docutils literal notranslate"><span class="pre">raise_on_defect</span></code>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정된 것을 제외하고, <code class="docutils literal notranslate"><span class="pre">default</span></code>와 같습니다. 다음과 같이 작성하여 모든 정책을 엄격하게 만들 수 있도록 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">somepolicy</span> <span class="o">+</span> <span class="n">policy</span><span class="o">.</span><span class="n">strict</span>
</pre></div>
</div>
</dd></dl>

<p>이러한 모든 <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a>를 통해, email 패키지의 효과적인 API가 다음과 같은 방식으로 파이썬 3.2 API에서 변경됩니다:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>에서 헤더를 설정하면 해당 헤더가 구문 분석되고 헤더 객체가 만들어집니다.</p></li>
<li><p><a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>에서 헤더 값을 가져오면 해당 헤더가 구문 분석되고 헤더 객체가 만들어져 반환됩니다.</p></li>
<li><p>모든 헤더 객체나 정책 설정으로 인해 다시 접힌 모든 헤더는 인코딩된 단어가 필요한 위치와 허용되는 위치를 포함하여 RFC 접기 알고리즘을 완전히 구현하는 알고리즘을 사용하여 접힙니다.</p></li>
</ul>
</div></blockquote>
<p>응용 프로그램의 시각에서, 이것은 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>를 통해 얻은 모든 헤더가 추가 어트리뷰트가 있는 헤더 객체이며, 그것의 문자열 값은 헤더의 완전히 디코딩된 유니코드 값이 됨을 뜻합니다. 마찬가지로, 유니코드 문자열을 사용하여 헤더에 새 값이나 새로 만들어진 헤더를 대입할 수 있으며, 정책은 유니코드 문자열을 올바른 RFC 인코딩 형식으로 변환합니다.</p>
<p>헤더 객체와 그들의 어트리뷰트는 <a class="reference internal" href="email.headerregistry.html#module-email.headerregistry" title="email.headerregistry: Automatic Parsing of headers based on the field name"><code class="xref py py-mod docutils literal notranslate"><span class="pre">headerregistry</span></code></a>에 설명되어 있습니다.</p>
<dl class="class">
<dt id="email.policy.Compat32">
<em class="property">class </em><code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">Compat32</code><span class="sig-paren">(</span><em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32" title="정의 주소">¶</a></dt>
<dd><p>이 구상 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a>는 과거 호환성 정책입니다. 파이썬 3.2에 있는 email 패키지의 동작을 흉내 냅니다. <a class="reference internal" href="#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 모듈은 이 클래스의 인스턴스 <a class="reference internal" href="#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-const docutils literal notranslate"><span class="pre">compat32</span></code></a>도 정의하고, 기본 정책으로 사용합니다. 따라서 email 패키지의 기본 동작은 파이썬 3.2와의 호환성을 유지하는 것입니다.</p>
<p>다음 어트리뷰트는 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 기본값과 다른 값을 갖습니다:</p>
<dl class="attribute">
<dt id="email.policy.Compat32.mangle_from_">
<code class="sig-name descname">mangle_from_</code><a class="headerlink" href="#email.policy.Compat32.mangle_from_" title="정의 주소">¶</a></dt>
<dd><p>기본값은 <code class="docutils literal notranslate"><span class="pre">True</span></code>입니다.</p>
</dd></dl>

<p>이 클래스는 다음과 같은 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a>의 추상 메서드의 구상 구현을 제공합니다:</p>
<dl class="method">
<dt id="email.policy.Compat32.header_source_parse">
<code class="sig-name descname">header_source_parse</code><span class="sig-paren">(</span><em class="sig-param">sourcelines</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.header_source_parse" title="정의 주소">¶</a></dt>
<dd><p>이름은 '<code class="docutils literal notranslate"><span class="pre">:</span></code>'까지의 모든 것으로 구문 분석되고 수정되지 않은 상태로 반환됩니다. 값은 첫 번째 줄의 나머지 부분에서 선행 공백을 제거한 후에 모든 후속 줄을 이어붙이고 후행 캐리지 리턴이나 줄 바꿈 문자를 제거하여 결정됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.header_store_parse">
<code class="sig-name descname">header_store_parse</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.header_store_parse" title="정의 주소">¶</a></dt>
<dd><p>이름과 값은 수정되지 않은 상태로 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.header_fetch_parse">
<code class="sig-name descname">header_fetch_parse</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.header_fetch_parse" title="정의 주소">¶</a></dt>
<dd><p>값에 바이너리 데이터가 포함되어 있으면, <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> 문자 집합을 사용하여 <a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> 객체로 변환됩니다. 그렇지 않으면 수정되지 않은 상태로 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.fold">
<code class="sig-name descname">fold</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.fold" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> 접기 알고리즘을 사용하여 헤더를 접습니다. 이 알고리즘은 값의 기존 줄 바꿈을 유지하고, 각 결과 줄을 <code class="docutils literal notranslate"><span class="pre">max_line_length</span></code>로 줄 넘김 합니다. ASCII가 아닌 바이너리 데이터는 <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> 문자 집합을 사용하여 CTE 인코딩됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.fold_binary">
<code class="sig-name descname">fold_binary</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.fold_binary" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> 접기 알고리즘을 사용하여 헤더를 접습니다. 이 알고리즘은 값의 기존 줄 바꿈을 유지하고, 각 결과 줄을 <code class="docutils literal notranslate"><span class="pre">max_line_length</span></code>로 줄 넘김 합니다. <code class="docutils literal notranslate"><span class="pre">cte_type</span></code>이 <code class="docutils literal notranslate"><span class="pre">7bit</span></code>이면, ASCII가 아닌 바이너리 데이터는 <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> 문자 집합을 사용하여 CTE 인코딩됩니다. 그렇지 않으면 원본 소스 헤더가 사용되는데, 기존 줄 바꿈과 임의의 (RFC 유효하지 않은) 바이너리 데이터가 포함될 수 있습니다.</p>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="email.policy.compat32">
<code class="sig-prename descclassname">email.policy.</code><code class="sig-name descname">compat32</code><a class="headerlink" href="#email.policy.compat32" title="정의 주소">¶</a></dt>
<dd><p>파이썬 3.2 email 패키지 동작과의 호환성을 제공하는 <a class="reference internal" href="#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compat32</span></code></a>의 인스턴스.</p>
</dd></dl>

<p class="rubric">각주</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>원래 3.3에 <a class="reference internal" href="../glossary.html#term-provisional-package"><span class="xref std std-term">잠정적 기능</span></a>으로 추가되었습니다.</p>
</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>이전 항목</h4>
  <p class="topless"><a href="email.generator.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.generator</span></code>: MIME 문서 생성</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="email.errors.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.errors</span></code>: 예외와 결함 클래스</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="email.errors.html" title="email.errors: 예외와 결함 클래스"
             >다음</a> |</li>
        <li class="right" >
          <a href="email.generator.html" title="email.generator: MIME 문서 생성"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >인터넷 데이터 처리</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 전자 메일과 MIME 처리 패키지</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>