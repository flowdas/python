
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>email.policy: 정책 객체 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="email.errors: 예외와 결함 클래스" href="email.errors.html" />
    <link rel="prev" title="email.generator: Generating MIME documents" href="email.generator.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/email.policy.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="email.errors.html" title="email.errors: 예외와 결함 클래스"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="email.generator.html" title="email.generator: Generating MIME documents"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >인터넷 데이터 처리</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 전자 메일과 MIME 처리 패키지</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-email.policy">
<span id="email-policy-policy-objects"></span><h1><a class="reference internal" href="#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.policy</span></code></a>: 정책 객체<a class="headerlink" href="#module-email.policy" title="제목 주소">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/email/policy.py">Lib/email/policy.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 패키지의 주요 초점은 다양한 전자 우편과 MIME RFC에 설명된 대로 전자 우편 메시지를 처리하는 것입니다. 그러나 전자 우편 메시지의 일반적인 형식(각각 이름, 콜론, 값 순으로 구성된 헤더 필드의 블록, 빈 줄과 임의의 '본문' 이 뒤따르는 전체 블록)은 전자 우편 영역 밖에서도 용도가 발견되는 형식입니다. 이러한 용도 중 일부는 메인 전자 우편 RFC와 상당히 유사하지만 일부는 그렇지 않습니다. 전자 우편으로 작업 할 때에도, RFC의 엄격한 준수를 위반하는 것이 바람직할 때가 있습니다. 가령 표준을 따르지 않는 전자 우편 서버와 상호 운영되거나 표준을 위반하는 방식으로 사용하기 원하는 확장을 구현하는 전자 우편을 생상하는 경우가 그렇습니다.</p>
<p>정책 객체는 email 패키지에 이러한 개별 사용 사례를 모두 처리 할 수 있는 유연성을 제공합니다.</p>
<p><a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 객체는 사용 중에 email 패키지의 다양한 구성 요소 동작을 제어하는 일련의 어트리뷰트와 메서드를 캡슐화합니다. <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 인스턴스는 email 패키지의 다양한 클래스와 메서드로 전달되어 기본 동작을 변경할 수 있습니다. 설정 가능한 값과 기본값은 아래에 설명되어 있습니다.</p>
<p>email 패키지의 모든 클래스에서 사용되는 기본 정책이 있습니다. 모든 <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a> 클래스와 관련 편의 함수 및 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 클래스의 경우, 이것은 사전 정의된 인스턴스 <a class="reference internal" href="#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-const docutils literal notranslate"><span class="pre">compat32</span></code></a>를 통한 <a class="reference internal" href="#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compat32</span></code></a> 정책입니다. 이 정책은 파이썬 3.3 이전 버전의 email 패키지와 완전한 과거 호환성(어떤 경우에는, 버그 호환성을 포함합니다)을 제공합니다.</p>
<p><a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>에 대한 <em>policy</em> 키워드의 기본값은 사전 정의된 인스턴스 <a class="reference internal" href="#email.policy.default" title="email.policy.default"><code class="xref py py-data docutils literal notranslate"><span class="pre">default</span></code></a>를 통한 <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a> 정책입니다.</p>
<p><a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>나 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 객체가 만들어질 때, 정책을 획득합니다. 메시지가 <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a>로 만들어지면, 구문 분석기에 전달된 정책이 만들어지는 메시지가 사용하는 정책이됩니다. 프로그램이 메시지를 만들면, 만들 때 정책을 지정할 수 있습니다. 메시지가 <a class="reference internal" href="email.generator.html#module-email.generator" title="email.generator: Generate flat text email messages from a message structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">generator</span></code></a>에 전달될 때, 제너레이터는 기본적으로 메시지의 정책을 사용하지만, 특정 정책을 제너레이터에 전달하여 메시지 객체에 저장된 정책을 재정의 할 수도 있습니다.</p>
<p><a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code></a> 클래스와 구문 분석기 편의 함수에 대한 <em>policy</em> 키워드의 기본값은 이후 버전의 파이썬에서 <strong>변경 될 예정</strong> 입니다. 따라서 <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a> 모듈에서 설명된 클래스와 함수를 호출할 때는 <strong>항상 사용할 정책을 명시적으로 지정</strong>해야 합니다.</p>
<p>이 설명서의 첫 부분은 <a class="reference internal" href="#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-const docutils literal notranslate"><span class="pre">compat32</span></code></a>를 포함한 모든 정책 객체에 공통적인 기능을 정의하는 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">추상 베이스 클래스</span></a> 인 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a>의 기능을 다룹니다. 여기에는 email 패키지에 의해 내부적으로 호출되는 특정 훅 메서드가 포함되며, 사용자 정의 정책은 다른 동작을 얻기 위해 재정의할 수 있습니다. 두 번째 부분에서는 표준 동작과 이전 버전과 호환되는 동작과 기능을 각각 제공하는 훅을 구현하는 구상 클래스 <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a>와 <a class="reference internal" href="#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compat32</span></code></a>를 설명합니다.</p>
<p><a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 인스턴스는 불변이지만, 복제할 수 있는데, 클래스 생성자와 같은 키워드 인자를 받아들이고 원본의 사본이지만 지정된 어트리뷰트 값이 변경된 새 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 인스턴스를 반환합니다.</p>
<p>예를 들어, 다음 코드를 사용하여 디스크의 파일에서 전자 우편 메시지를 읽고 유닉스 시스템의 시스템 <code class="docutils literal notranslate"><span class="pre">sendmail</span></code> 프로그램으로 전달할 수 있습니다:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email</span> <span class="k">import</span> <span class="n">message_from_binary_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email.generator</span> <span class="k">import</span> <span class="n">BytesGenerator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email</span> <span class="k">import</span> <span class="n">policy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">subprocess</span> <span class="k">import</span> <span class="n">Popen</span><span class="p">,</span> <span class="n">PIPE</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;mymsg.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">msg</span> <span class="o">=</span> <span class="n">message_from_binary_file</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">policy</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;sendmail&#39;</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;To&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">addresses</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">stdin</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">BytesGenerator</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">stdin</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>여기서 우리는 <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a>에게 <code class="docutils literal notranslate"><span class="pre">sendmail</span></code>의 <code class="docutils literal notranslate"><span class="pre">stdin</span></code>으로 공급할 바이너리 문자열을 만들 때 RFC 올바른 줄 구분자 문자를 사용하도록 지시합니다. 기본 정책은 <code class="docutils literal notranslate"><span class="pre">\n</span></code> 줄 구분자를 사용합니다.</p>
<p>일부 email 패키지 메서드는 <em>policy</em> 키워드 인자를 받아들여, 해당 메서드에 대한 정책을 대체 할 수 있도록 합니다. 예를 들어, 다음 코드는 이전 예제의 <em>msg</em> 객체의 <a class="reference internal" href="email.compat32-message.html#email.message.Message.as_bytes" title="email.message.Message.as_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_bytes()</span></code></a> 메서드를 사용하고 실행중인 플랫폼의 기본 줄 구분자를 사용하여 메시지를 파일에 씁니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;converted.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">as_bytes</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)))</span>
<span class="go">17</span>
</pre></div>
</div>
<p>더하기 연산자를 사용하여 정책 객체를 결합하여, 기본값이 아닌 설정이 합쳐진 조합으로 설정된 정책 객체를 생성할 수도 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">compat_SMTP</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compat_strict</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">raise_on_defect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compat_strict_SMTP</span> <span class="o">=</span> <span class="n">compat_SMTP</span> <span class="o">+</span> <span class="n">compat_strict</span>
</pre></div>
</div>
<p>이 연산은 교환적(commutative)이지 않습니다; 즉, 객체가 더해지는 순서가 중요합니다. 예시하면 이렇습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">policy100</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">max_line_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">policy80</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">max_line_length</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span> <span class="o">=</span> <span class="n">policy100</span> <span class="o">+</span> <span class="n">policy80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span><span class="o">.</span><span class="n">max_line_length</span>
<span class="go">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span> <span class="o">=</span> <span class="n">policy80</span> <span class="o">+</span> <span class="n">policy100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span><span class="o">.</span><span class="n">max_line_length</span>
<span class="go">100</span>
</pre></div>
</div>
<dl class="class">
<dt id="email.policy.Policy">
<em class="property">class </em><code class="descclassname">email.policy.</code><code class="descname">Policy</code><span class="sig-paren">(</span><em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy" title="정의 주소">¶</a></dt>
<dd><p>모든 정책 클래스의 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">추상 베이스 클래스</span></a>입니다. 불변 속성, <a class="reference internal" href="#email.policy.Policy.clone" title="email.policy.Policy.clone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clone()</span></code></a> 메서드 및 생성자 시맨틱의 구현뿐만 아니라 몇 가지 간단한 메서드에 대한 기본 구현을 제공합니다.</p>
<p>정책 클래스의 생성자에는 다양한 키워드 인자가 전달 될 수 있습니다. 지정할 수 있는 인자는 이 클래스의 메서드 이외의 프로퍼티, 그리고 구상 클래스의 메서드 이외의 프로퍼티입니다. 생성자에 지정된 값은 해당 어트리뷰트의 기본값을 재정의합니다.</p>
<p>이 클래스는 다음 프로퍼티를 정의합니다. 따라서, 모든 정책 클래스의 생성자에 다음에 대한 값이 전달 될 수 있습니다:</p>
<dl class="attribute">
<dt id="email.policy.Policy.max_line_length">
<code class="descname">max_line_length</code><a class="headerlink" href="#email.policy.Policy.max_line_length" title="정의 주소">¶</a></dt>
<dd><p>줄 종료 문자를 포함하지 않고, 직렬화 된 출력에서 줄의 최대 길이. <span class="target" id="index-12"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>에 따라 기본값은 78입니다. <code class="docutils literal notranslate"><span class="pre">0</span></code>이나 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 값은 줄 바꿈을 전혀 수행하지 않아야 함을 나타냅니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.linesep">
<code class="descname">linesep</code><a class="headerlink" href="#email.policy.Policy.linesep" title="정의 주소">¶</a></dt>
<dd><p>직렬화 된 출력에서 줄을 종료하는 데 사용되는 문자열입니다. RFC는 <code class="docutils literal notranslate"><span class="pre">\r\n</span></code>을 요구하지만, 기본값은 파이썬에서 사용하는 내부 줄 종료 규칙을 따라 <code class="docutils literal notranslate"><span class="pre">\n</span></code>입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.cte_type">
<code class="descname">cte_type</code><a class="headerlink" href="#email.policy.Policy.cte_type" title="정의 주소">¶</a></dt>
<dd><p>사용해야하는 콘텐츠 전송 인코딩(Content Transfer Encoding) 유형을 제어합니다. 가능한 값은 다음과 같습니다:</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">7bit</span></code></p></td>
<td><p>모든 데이터는 &quot;7 비트 클린&quot; (ASCII 전용) 이어야합니다. 즉, 필요하면 quoted-printable이나 base64 인코딩을 사용하여 데이터를 인코딩합니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">8bit</span></code></p></td>
<td><p>데이터는 7 비트 클린으로 제한되지 않습니다. 헤더의 데이터는 여전히 ASCII 전용 이어야하므로 인코딩되자만 (예외는 아래 <a class="reference internal" href="#email.policy.Policy.fold_binary" title="email.policy.Policy.fold_binary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold_binary()</span></code></a>와 <a class="reference internal" href="#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a>를 참조하십시오), 본문 부분은 <code class="docutils literal notranslate"><span class="pre">8bit</span></code> CTE를 사용할 수 있습니다.</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">8bit</span></code> <code class="docutils literal notranslate"><span class="pre">cte_type</span></code> 값은 문자열이 바이너리 데이터를 포함할 수 없으므로 <code class="docutils literal notranslate"><span class="pre">Generator</span></code>가 아닌 <code class="docutils literal notranslate"><span class="pre">BytesGenerator</span></code>에서만 작동합니다. <code class="docutils literal notranslate"><span class="pre">Generator</span></code>가 <code class="docutils literal notranslate"><span class="pre">cte_type=8bit</span></code>를 지정하는 정책에 따라 작동하면, <code class="docutils literal notranslate"><span class="pre">cte_type</span></code>가 <code class="docutils literal notranslate"><span class="pre">7bit</span></code> 인 것처럼 동작합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.raise_on_defect">
<code class="descname">raise_on_defect</code><a class="headerlink" href="#email.policy.Policy.raise_on_defect" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>이면, 만나는 모든 결함을 에러로 발생시킵니다. <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>(기본값)이면, 결함은 <a class="reference internal" href="#email.policy.Policy.register_defect" title="email.policy.Policy.register_defect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_defect()</span></code></a> 메서드로 전달됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.mangle_from_">
<code class="descname">mangle_from_</code><a class="headerlink" href="#email.policy.Policy.mangle_from_" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>이면, 본문에서 <em>&quot;From &quot;</em>으로 시작하는 줄은 <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>를 앞에 배치하여 이스케이프됩니다. 이 매개 변수는 제너레이터가 메시지를 직렬화할 때 사용됩니다. 기본값: <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가: </span><em>mangle_from_</em> 매개 변수.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.message_factory">
<code class="descname">message_factory</code><a class="headerlink" href="#email.policy.Policy.message_factory" title="정의 주소">¶</a></dt>
<dd><p>새로운 빈 메시지 객체를 생성하기위한 팩토리 함수. 메시지를 구축할 때 구분 분석기가 사용합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>이며, 이 때 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>가 사용됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<p>다음 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 메서드는 email 라이브러리를 사용하여 사용자 정의 설정으로 정책 인스턴스를 만드는 코드가 호출하기위한 것입니다:</p>
<dl class="method">
<dt id="email.policy.Policy.clone">
<code class="descname">clone</code><span class="sig-paren">(</span><em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.clone" title="정의 주소">¶</a></dt>
<dd><p>키워드 인자로 새로운 값이 부여되는 어트리뷰트를 제외하고, 어트리뷰트가 현재 인스턴스와 같은 값을 갖는 새로운 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 인스턴스를 반환합니다.</p>
</dd></dl>

<p>나머지 <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> 메서드는 email 패키지 코드에 의해 호출되며, email 패키지를 사용하는 응용 프로그램에 의해 호출되는 용도가 아닙니다. 사용자 정의 정책은 이 모든 메서드를 구현해야합니다.</p>
<dl class="method">
<dt id="email.policy.Policy.handle_defect">
<code class="descname">handle_defect</code><span class="sig-paren">(</span><em>obj</em>, <em>defect</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.handle_defect" title="정의 주소">¶</a></dt>
<dd><p><em>obj</em>에서 찾은 <em>defect</em>를 처리합니다. email 패키지가 이 메서드를 호출할 때, <em>defect</em>는 항상 <code class="xref py py-class docutils literal notranslate"><span class="pre">Defect</span></code>의 서브 클래스입니다.</p>
<p>기본 구현은 <a class="reference internal" href="#email.policy.Policy.raise_on_defect" title="email.policy.Policy.raise_on_defect"><code class="xref py py-attr docutils literal notranslate"><span class="pre">raise_on_defect</span></code></a> 플래그를 확인합니다. <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, <em>defect</em>가 예외로 발생합니다. <code class="docutils literal notranslate"><span class="pre">False</span></code>(기본값)이면 <em>obj</em>와 <em>defect</em>가 <a class="reference internal" href="#email.policy.Policy.register_defect" title="email.policy.Policy.register_defect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_defect()</span></code></a>로 전달됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.register_defect">
<code class="descname">register_defect</code><span class="sig-paren">(</span><em>obj</em>, <em>defect</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.register_defect" title="정의 주소">¶</a></dt>
<dd><p><em>obj</em>에 <em>defect</em>를 등록합니다. email 패키지에서, <em>defect</em>는 항상 <code class="xref py py-class docutils literal notranslate"><span class="pre">Defect</span></code>의 서브 클래스입니다.</p>
<p>기본 구현은 <em>obj</em>의 <code class="docutils literal notranslate"><span class="pre">defects</span></code> 어트리뷰트의 <code class="docutils literal notranslate"><span class="pre">append</span></code> 메서드를 호출합니다. email 패키지가 <a class="reference internal" href="#email.policy.Policy.handle_defect" title="email.policy.Policy.handle_defect"><code class="xref py py-attr docutils literal notranslate"><span class="pre">handle_defect</span></code></a>를 호출할 때, <em>obj</em>는 일반적으로 <code class="docutils literal notranslate"><span class="pre">append</span></code> 메서드가 있는 <code class="docutils literal notranslate"><span class="pre">defects</span></code> 어트리뷰트가 있습니다. email 패키지와 함께 사용되는 사용자 정의 객체 형(예를 들어, 사용자 정의 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 객체)도 이러한 어트리뷰트를 제공해야합니다, 그렇지 않으면 구문 분석된 메시지의 결함이 예기치 않은 에러를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_max_count">
<code class="descname">header_max_count</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_max_count" title="정의 주소">¶</a></dt>
<dd><p><em>name</em>이라는 헤더의 최대 허용 개수를 반환합니다.</p>
<p>헤더가 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>나 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 객체에 추가될 때 호출됩니다. 반환값이 <code class="docutils literal notranslate"><span class="pre">0</span></code>이나 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니고, 반환값보다 크거나 같은 수의 이름이 <em>name</em>인 헤더가 이미 있으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">Message.__setitem__</span></code>의 기본 동작은 값을 헤더 리스트에 추가하는 것이므로, 깨닫지 못하는 사이에 중복 헤더를 만들기 쉽습니다. 이 메서드는 특정 헤더를 <code class="docutils literal notranslate"><span class="pre">Message</span></code>에 프로그래밍 방식으로 추가할 수 있는 인스턴스의 수를 제한할 수 있도록 합니다. (이 제약은 구문 분석기가 보지 않습니다, 구문 분석기는 구문 분석중인 메시지에 존재하는 수 만큼 헤더를 충실하게 생성합니다.)</p>
<p>기본 구현은 모든 헤더 이름에 대해 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_source_parse">
<code class="descname">header_source_parse</code><span class="sig-paren">(</span><em>sourcelines</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_source_parse" title="정의 주소">¶</a></dt>
<dd><p>email 패키지는 문자열 리스트로 이 메서드를 호출하며, 각 문자열은 구문 분석중인 소스에서 발견된 줄 구분 문자로 끝납니다. 첫 번째 줄에는 필드 헤더 이름과 구분자가 포함됩니다. 소스의 모든 공백이 유지됩니다. 이 메서드는 구문 분석된 헤더를 나타내기 위해 <code class="docutils literal notranslate"><span class="pre">Message</span></code>에 저장될 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> 튜플을 반환해야합니다.</p>
<p>구현이 기존 email 패키지 정책과의 호환성을 유지하기 원한다면, <em>name</em>은 대소 문자를 유지한 이름( '<code class="docutils literal notranslate"><span class="pre">:</span></code>' 구분자까지의 모든 문자)이어야하는 반면, <em>value</em>는 선행 공백이 제거되고 펼쳐진(unfolded) 값(모든 줄 구분자 문자는 제거하지만 공백은 그대로 유지한)이어야합니다.</p>
<p><em>sourcelines</em>는 서로게이트 이스케이프된 바이너리 데이터를 포함할 수 있습니다.</p>
<p>기본 구현이 없습니다</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_store_parse">
<code class="descname">header_store_parse</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_store_parse" title="정의 주소">¶</a></dt>
<dd><p>email 패키지는 (구문 분석기가 만든 <code class="docutils literal notranslate"><span class="pre">Message</span></code>가 아니라) 응용 프로그램이 <code class="docutils literal notranslate"><span class="pre">Message</span></code>를 프로그래밍 방식으로 수정할 때, 응용 프로그램이 제공한 name과 value로 이 메서드를 호출합니다. 이 메서드는 헤더를 나타내기 위해 <code class="docutils literal notranslate"><span class="pre">Message</span></code>에 저장될 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> 튜플을 반환해야합니다.</p>
<p>구현이 기존 email 패키지 정책과의 호환성을 유지하기 원한다면, <em>name</em>과 <em>value</em>는 전달된 인자의 내용을 변경하지 않는 문자열이나 문자열의 서브 클래스여야 합니다.</p>
<p>기본 구현이 없습니다</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_fetch_parse">
<code class="descname">header_fetch_parse</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_fetch_parse" title="정의 주소">¶</a></dt>
<dd><p>email 패키지는 응용 프로그램이 해당 헤더를 요청할 때 <code class="docutils literal notranslate"><span class="pre">Message</span></code>에 현재 저장된 <em>name</em>과 <em>value</em>로 이 메서드를 호출하며, 메서드가 반환하는 것은 꺼내는 헤더의 값으로 응용 프로그램에 다시 전달됩니다. <code class="docutils literal notranslate"><span class="pre">Message</span></code>에 같은 이름을 가진 헤더가 두 개 이상 있을 수 있음에 유의하십시오; 이 메서드로는 응용 프로그램으로 반환될 헤더의 특정 이름과 값이 전달됩니다.</p>
<p><em>value</em>는 서로게이트 이스케이프된 바이너리 데이터를 포함할 수 있습니다. 이 메서드가 반환하는 값에는 서로게이트 이스케이프된 바이너리 데이터가 없어야 합니다.</p>
<p>기본 구현이 없습니다</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.fold">
<code class="descname">fold</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.fold" title="정의 주소">¶</a></dt>
<dd><p>email 패키지는 지정된 헤더에 대해 <code class="docutils literal notranslate"><span class="pre">Message</span></code>에 현재 저장된 <em>name</em>과 <em>value</em>로 이 메서드를 호출합니다. 이 메서드는 <em>name</em>을 <em>value</em>과 합치고 적절한 위치에 <a class="reference internal" href="#email.policy.Policy.linesep" title="email.policy.Policy.linesep"><code class="xref py py-attr docutils literal notranslate"><span class="pre">linesep</span></code></a> 문자를 삽입하여 (정책 설정에 따라) 올바르게 &quot;접힌(folded)&quot; 헤더를 나타내는 문자열을 반환해여 합니다. 전자 우편 헤더 접기 규칙에 대한 설명은 <span class="target" id="index-13"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>를 참조하십시오.</p>
<p><em>value</em>는 서로게이트 이스케이프된 바이너리 데이터를 포함할 수 있습니다. 메서드가 반환한 문자열에는 서로게이트 이스케이프된 바이너리 데이터가 없어야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.fold_binary">
<code class="descname">fold_binary</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.fold_binary" title="정의 주소">¶</a></dt>
<dd><p>반환값이 문자열이 아니라 바이트열 객체여야 한다는 점을 제외하고는 <a class="reference internal" href="#email.policy.Policy.fold" title="email.policy.Policy.fold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold()</span></code></a>와 같습니다.</p>
<p><em>value</em>는 서로게이트 이스케이프된 바이너리 데이터를 포함할 수 있습니다. 이들은 반환된 바이트열 객체에서 바이너리 데이터로 다시 변환될 수 있습니다.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="email.policy.EmailPolicy">
<em class="property">class </em><code class="descclassname">email.policy.</code><code class="descname">EmailPolicy</code><span class="sig-paren">(</span><em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy" title="정의 주소">¶</a></dt>
<dd><p>This concrete <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> provides behavior that is intended to be fully
compliant with the current email RFCs.  These include (but are not limited
to) <span class="target" id="index-2"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>, <span class="target" id="index-3"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html"><strong>RFC 2047</strong></a>, and the current MIME RFCs.</p>
<p>This policy adds new header parsing and folding algorithms.  Instead of
simple strings, headers are <code class="docutils literal notranslate"><span class="pre">str</span></code> subclasses with attributes that depend
on the type of the field.  The parsing and folding algorithm fully implement
<span class="target" id="index-4"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html"><strong>RFC 2047</strong></a> and <span class="target" id="index-5"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>.</p>
<p>The default value for the <a class="reference internal" href="#email.policy.Policy.message_factory" title="email.policy.Policy.message_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">message_factory</span></code></a>
attribute is <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>.</p>
<p>In addition to the settable attributes listed above that apply to all
policies, this policy adds the following additional attributes:</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가: </span><a class="footnote-reference brackets" href="#id2" id="id1">1</a></p>
</div>
<dl class="attribute">
<dt id="email.policy.EmailPolicy.utf8">
<code class="descname">utf8</code><a class="headerlink" href="#email.policy.EmailPolicy.utf8" title="정의 주소">¶</a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">False</span></code>, follow <span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>, supporting non-ASCII characters in
headers by encoding them as &quot;encoded words&quot;.  If <code class="docutils literal notranslate"><span class="pre">True</span></code>, follow
<span class="target" id="index-7"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6532.html"><strong>RFC 6532</strong></a> and use <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> encoding for headers.  Messages
formatted in this way may be passed to SMTP servers that support
the <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> extension (<span class="target" id="index-8"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6531.html"><strong>RFC 6531</strong></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.EmailPolicy.refold_source">
<code class="descname">refold_source</code><a class="headerlink" href="#email.policy.EmailPolicy.refold_source" title="정의 주소">¶</a></dt>
<dd><p>If the value for a header in the <code class="docutils literal notranslate"><span class="pre">Message</span></code> object originated from a
<a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a> (as opposed to being set by a program), this
attribute indicates whether or not a generator should refold that value
when transforming the message back into serialized form.  The possible
values are:</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 11%" />
<col style="width: 89%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">none</span></code></p></td>
<td><p>all source values use original folding</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">long</span></code></p></td>
<td><p>source values that have any line that is longer than
<code class="docutils literal notranslate"><span class="pre">max_line_length</span></code> will be refolded</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">all</span></code></p></td>
<td><p>all values are refolded.</p></td>
</tr>
</tbody>
</table>
<p>The default is <code class="docutils literal notranslate"><span class="pre">long</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.EmailPolicy.header_factory">
<code class="descname">header_factory</code><a class="headerlink" href="#email.policy.EmailPolicy.header_factory" title="정의 주소">¶</a></dt>
<dd><p>A callable that takes two arguments, <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">value</span></code>, where
<code class="docutils literal notranslate"><span class="pre">name</span></code> is a header field name and <code class="docutils literal notranslate"><span class="pre">value</span></code> is an unfolded header field
value, and returns a string subclass that represents that header.  A
default <code class="docutils literal notranslate"><span class="pre">header_factory</span></code> (see <a class="reference internal" href="email.headerregistry.html#module-email.headerregistry" title="email.headerregistry: Automatic Parsing of headers based on the field name"><code class="xref py py-mod docutils literal notranslate"><span class="pre">headerregistry</span></code></a>) is provided
that supports custom parsing for the various address and date <span class="target" id="index-9"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>
header field types, and the major MIME header field stypes.  Support for
additional custom parsing will be added in the future.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.EmailPolicy.content_manager">
<code class="descname">content_manager</code><a class="headerlink" href="#email.policy.EmailPolicy.content_manager" title="정의 주소">¶</a></dt>
<dd><p>An object with at least two methods: get_content and set_content.  When
the <a class="reference internal" href="email.message.html#email.message.EmailMessage.get_content" title="email.message.EmailMessage.get_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content()</span></code></a> or
<a class="reference internal" href="email.message.html#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> method of an
<a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> object is called, it calls the
corresponding method of this object, passing it the message object as its
first argument, and any arguments or keywords that were passed to it as
additional arguments.  By default <code class="docutils literal notranslate"><span class="pre">content_manager</span></code> is set to
<a class="reference internal" href="email.contentmanager.html#email.contentmanager.raw_data_manager" title="email.contentmanager.raw_data_manager"><code class="xref py py-data docutils literal notranslate"><span class="pre">raw_data_manager</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<p>The class provides the following concrete implementations of the abstract
methods of <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a>:</p>
<dl class="method">
<dt id="email.policy.EmailPolicy.header_max_count">
<code class="descname">header_max_count</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_max_count" title="정의 주소">¶</a></dt>
<dd><p>Returns the value of the
<a class="reference internal" href="email.headerregistry.html#email.headerregistry.BaseHeader.max_count" title="email.headerregistry.BaseHeader.max_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_count</span></code></a> attribute of the
specialized class used to represent the header with the given name.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.header_source_parse">
<code class="descname">header_source_parse</code><span class="sig-paren">(</span><em>sourcelines</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_source_parse" title="정의 주소">¶</a></dt>
<dd><p>The name is parsed as everything up to the '<code class="docutils literal notranslate"><span class="pre">:</span></code>' and returned
unmodified.  The value is determined by stripping leading whitespace off
the remainder of the first line, joining all subsequent lines together,
and stripping any trailing carriage return or linefeed characters.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.header_store_parse">
<code class="descname">header_store_parse</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_store_parse" title="정의 주소">¶</a></dt>
<dd><p>The name is returned unchanged.  If the input value has a <code class="docutils literal notranslate"><span class="pre">name</span></code>
attribute and it matches <em>name</em> ignoring case, the value is returned
unchanged.  Otherwise the <em>name</em> and <em>value</em> are passed to
<code class="docutils literal notranslate"><span class="pre">header_factory</span></code>, and the resulting header object is returned as
the value.  In this case a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> is raised if the input value
contains CR or LF characters.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.header_fetch_parse">
<code class="descname">header_fetch_parse</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_fetch_parse" title="정의 주소">¶</a></dt>
<dd><p>If the value has a <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute, it is returned to unmodified.
Otherwise the <em>name</em>, and the <em>value</em> with any CR or LF characters
removed, are passed to the <code class="docutils literal notranslate"><span class="pre">header_factory</span></code>, and the resulting
header object is returned.  Any surrogateescaped bytes get turned into
the unicode unknown-character glyph.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.fold">
<code class="descname">fold</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.fold" title="정의 주소">¶</a></dt>
<dd><p>Header folding is controlled by the <a class="reference internal" href="#email.policy.EmailPolicy.refold_source" title="email.policy.EmailPolicy.refold_source"><code class="xref py py-attr docutils literal notranslate"><span class="pre">refold_source</span></code></a> policy setting.
A value is considered to be a 'source value' if and only if it does not
have a <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute (having a <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute means it is a
header object of some sort).  If a source value needs to be refolded
according to the policy, it is converted into a header object by
passing the <em>name</em> and the <em>value</em> with any CR and LF characters removed
to the <code class="docutils literal notranslate"><span class="pre">header_factory</span></code>.  Folding of a header object is done by
calling its <code class="docutils literal notranslate"><span class="pre">fold</span></code> method with the current policy.</p>
<p>Source values are split into lines using <a class="reference internal" href="stdtypes.html#str.splitlines" title="str.splitlines"><code class="xref py py-meth docutils literal notranslate"><span class="pre">splitlines()</span></code></a>.  If
the value is not to be refolded, the lines are rejoined using the
<code class="docutils literal notranslate"><span class="pre">linesep</span></code> from the policy and returned.  The exception is lines
containing non-ascii binary data.  In that case the value is refolded
regardless of the <code class="docutils literal notranslate"><span class="pre">refold_source</span></code> setting, which causes the binary data
to be CTE encoded using the <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> charset.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.fold_binary">
<code class="descname">fold_binary</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.fold_binary" title="정의 주소">¶</a></dt>
<dd><p>The same as <a class="reference internal" href="#email.policy.EmailPolicy.fold" title="email.policy.EmailPolicy.fold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold()</span></code></a> if <a class="reference internal" href="#email.policy.Policy.cte_type" title="email.policy.Policy.cte_type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cte_type</span></code></a> is <code class="docutils literal notranslate"><span class="pre">7bit</span></code>, except
that the returned value is bytes.</p>
<p>If <a class="reference internal" href="#email.policy.Policy.cte_type" title="email.policy.Policy.cte_type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cte_type</span></code></a> is <code class="docutils literal notranslate"><span class="pre">8bit</span></code>, non-ASCII binary data is
converted back
into bytes.  Headers with binary data are not refolded, regardless of the
<code class="docutils literal notranslate"><span class="pre">refold_header</span></code> setting, since there is no way to know whether the
binary data consists of single byte characters or multibyte characters.</p>
</dd></dl>

</dd></dl>

<p>The following instances of <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicy</span></code></a> provide defaults suitable for
specific application domains.  Note that in the future the behavior of these
instances (in particular the <code class="docutils literal notranslate"><span class="pre">HTTP</span></code> instance) may be adjusted to conform even
more closely to the RFCs relevant to their domains.</p>
<dl class="data">
<dt id="email.policy.default">
<code class="descclassname">email.policy.</code><code class="descname">default</code><a class="headerlink" href="#email.policy.default" title="정의 주소">¶</a></dt>
<dd><p>An instance of <code class="docutils literal notranslate"><span class="pre">EmailPolicy</span></code> with all defaults unchanged.  This policy
uses the standard Python <code class="docutils literal notranslate"><span class="pre">\n</span></code> line endings rather than the RFC-correct
<code class="docutils literal notranslate"><span class="pre">\r\n</span></code>.</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.SMTP">
<code class="descclassname">email.policy.</code><code class="descname">SMTP</code><a class="headerlink" href="#email.policy.SMTP" title="정의 주소">¶</a></dt>
<dd><p>Suitable for serializing messages in conformance with the email RFCs.
Like <code class="docutils literal notranslate"><span class="pre">default</span></code>, but with <code class="docutils literal notranslate"><span class="pre">linesep</span></code> set to <code class="docutils literal notranslate"><span class="pre">\r\n</span></code>, which is RFC
compliant.</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.SMTPUTF8">
<code class="descclassname">email.policy.</code><code class="descname">SMTPUTF8</code><a class="headerlink" href="#email.policy.SMTPUTF8" title="정의 주소">¶</a></dt>
<dd><p>The same as <code class="docutils literal notranslate"><span class="pre">SMTP</span></code> except that <a class="reference internal" href="#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.
Useful for serializing messages to a message store without using encoded
words in the headers.  Should only be used for SMTP transmission if the
sender or recipient addresses have non-ASCII characters (the
<a class="reference internal" href="smtplib.html#smtplib.SMTP.send_message" title="smtplib.SMTP.send_message"><code class="xref py py-meth docutils literal notranslate"><span class="pre">smtplib.SMTP.send_message()</span></code></a> method handles this automatically).</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.HTTP">
<code class="descclassname">email.policy.</code><code class="descname">HTTP</code><a class="headerlink" href="#email.policy.HTTP" title="정의 주소">¶</a></dt>
<dd><p>Suitable for serializing headers with for use in HTTP traffic.  Like
<code class="docutils literal notranslate"><span class="pre">SMTP</span></code> except that <code class="docutils literal notranslate"><span class="pre">max_line_length</span></code> is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (unlimited).</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.strict">
<code class="descclassname">email.policy.</code><code class="descname">strict</code><a class="headerlink" href="#email.policy.strict" title="정의 주소">¶</a></dt>
<dd><p>Convenience instance.  The same as <code class="docutils literal notranslate"><span class="pre">default</span></code> except that
<code class="docutils literal notranslate"><span class="pre">raise_on_defect</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>.  This allows any policy to be made
strict by writing:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">somepolicy</span> <span class="o">+</span> <span class="n">policy</span><span class="o">.</span><span class="n">strict</span>
</pre></div>
</div>
</dd></dl>

<p>With all of these <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailPolicies</span></code></a>, the effective API of
the email package is changed from the Python 3.2 API in the following ways:</p>
<blockquote>
<div><ul class="simple">
<li><p>Setting a header on a <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> results in that
header being parsed and a header object created.</p></li>
<li><p>Fetching a header value from a <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> results
in that header being parsed and a header object created and
returned.</p></li>
<li><p>Any header object, or any header that is refolded due to the
policy settings, is folded using an algorithm that fully implements the
RFC folding algorithms, including knowing where encoded words are required
and allowed.</p></li>
</ul>
</div></blockquote>
<p>From the application view, this means that any header obtained through the
<a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> is a header object with extra
attributes, whose string value is the fully decoded unicode value of the
header.  Likewise, a header may be assigned a new value, or a new header
created, using a unicode string, and the policy will take care of converting
the unicode string into the correct RFC encoded form.</p>
<p>The header objects and their attributes are described in
<a class="reference internal" href="email.headerregistry.html#module-email.headerregistry" title="email.headerregistry: Automatic Parsing of headers based on the field name"><code class="xref py py-mod docutils literal notranslate"><span class="pre">headerregistry</span></code></a>.</p>
<dl class="class">
<dt id="email.policy.Compat32">
<em class="property">class </em><code class="descclassname">email.policy.</code><code class="descname">Compat32</code><span class="sig-paren">(</span><em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32" title="정의 주소">¶</a></dt>
<dd><p>This concrete <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> is the backward compatibility policy.  It
replicates the behavior of the email package in Python 3.2.  The
<a class="reference internal" href="#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> module also defines an instance of this class,
<a class="reference internal" href="#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-const docutils literal notranslate"><span class="pre">compat32</span></code></a>, that is used as the default policy.  Thus the default
behavior of the email package is to maintain compatibility with Python 3.2.</p>
<p>The following attributes have values that are different from the
<a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> default:</p>
<dl class="attribute">
<dt id="email.policy.Compat32.mangle_from_">
<code class="descname">mangle_from_</code><a class="headerlink" href="#email.policy.Compat32.mangle_from_" title="정의 주소">¶</a></dt>
<dd><p>The default is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd></dl>

<p>The class provides the following concrete implementations of the
abstract methods of <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a>:</p>
<dl class="method">
<dt id="email.policy.Compat32.header_source_parse">
<code class="descname">header_source_parse</code><span class="sig-paren">(</span><em>sourcelines</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.header_source_parse" title="정의 주소">¶</a></dt>
<dd><p>The name is parsed as everything up to the '<code class="docutils literal notranslate"><span class="pre">:</span></code>' and returned
unmodified.  The value is determined by stripping leading whitespace off
the remainder of the first line, joining all subsequent lines together,
and stripping any trailing carriage return or linefeed characters.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.header_store_parse">
<code class="descname">header_store_parse</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.header_store_parse" title="정의 주소">¶</a></dt>
<dd><p>The name and value are returned unmodified.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.header_fetch_parse">
<code class="descname">header_fetch_parse</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.header_fetch_parse" title="정의 주소">¶</a></dt>
<dd><p>If the value contains binary data, it is converted into a
<a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> object using the <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> charset.
Otherwise it is returned unmodified.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.fold">
<code class="descname">fold</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.fold" title="정의 주소">¶</a></dt>
<dd><p>Headers are folded using the <a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> folding
algorithm, which preserves existing line breaks in the value, and wraps
each resulting line to the <code class="docutils literal notranslate"><span class="pre">max_line_length</span></code>.  Non-ASCII binary data are
CTE encoded using the <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> charset.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.fold_binary">
<code class="descname">fold_binary</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Compat32.fold_binary" title="정의 주소">¶</a></dt>
<dd><p>Headers are folded using the <a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> folding
algorithm, which preserves existing line breaks in the value, and wraps
each resulting line to the <code class="docutils literal notranslate"><span class="pre">max_line_length</span></code>.  If <code class="docutils literal notranslate"><span class="pre">cte_type</span></code> is
<code class="docutils literal notranslate"><span class="pre">7bit</span></code>, non-ascii binary data is CTE encoded using the <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code>
charset.  Otherwise the original source header is used, with its existing
line breaks and any (RFC invalid) binary data it may contain.</p>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="email.policy.compat32">
<code class="descclassname">email.policy.</code><code class="descname">compat32</code><a class="headerlink" href="#email.policy.compat32" title="정의 주소">¶</a></dt>
<dd><p>An instance of <a class="reference internal" href="#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">Compat32</span></code></a>, providing  backward compatibility with the
behavior of the email package in Python 3.2.</p>
</dd></dl>

<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Originally added in 3.3 as a <a class="reference internal" href="../glossary.html#term-provisional-package"><span class="xref std std-term">provisional feature</span></a>.</p>
</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>이전 항목</h4>
  <p class="topless"><a href="email.generator.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.generator</span></code>: Generating MIME documents</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="email.errors.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.errors</span></code>: 예외와 결함 클래스</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="email.errors.html" title="email.errors: 예외와 결함 클래스"
             >다음</a> |</li>
        <li class="right" >
          <a href="email.generator.html" title="email.generator: Generating MIME documents"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >인터넷 데이터 처리</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 전자 메일과 MIME 처리 패키지</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>