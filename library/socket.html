
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>socket --- 저수준 네트워킹 인터페이스 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="ssl --- 소켓 객체용 TLS/SSL 래퍼" href="ssl.html" />
    <link rel="prev" title="asyncio로 개발하기" href="asyncio-dev.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/socket.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="ssl.html" title="ssl --- 소켓 객체용 TLS/SSL 래퍼"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="asyncio-dev.html" title="asyncio로 개발하기"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" accesskey="U">네트워킹과 프로세스 간 통신</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-socket">
<span id="socket-low-level-networking-interface"></span><h1><a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> --- 저수준 네트워킹 인터페이스<a class="headerlink" href="#module-socket" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/socket.py">Lib/socket.py</a></p>
<hr class="docutils" />
<p>이 모듈은 BSD <em>socket</em> 인터페이스에 대한 액세스를 제공합니다. 모든 현대 유닉스 시스템, 윈도우, MacOS, 그리고 아마 추가 플랫폼에서 사용할 수 있습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>호출이 운영 체제 소켓 API로 이루어지기 때문에, 일부 동작은 플랫폼에 따라 다를 수 있습니다.</p>
</div>
<p id="index-0">파이썬 인터페이스는 유닉스 시스템 호출과 소켓을 위한 라이브러리 인터페이스를 파이썬의 객체 지향 스타일로 직역한 것입니다: <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code></a> 함수는 <em class="dfn">소켓 객체 (socket object)</em>를 반환하고, 이것의 메서드는 다양한 소켓 시스템 호출을 구현합니다. 매개 변수 형은 C 인터페이스보다 다소 고수준입니다: 파이썬 파일에 대한 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> 와 <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> 연산처럼, 수신 연산의 버퍼 할당은 자동이고 전송 연산에서 버퍼 길이는 묵시적입니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt>모듈 <a class="reference internal" href="socketserver.html#module-socketserver" title="socketserver: A framework for network servers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socketserver</span></code></a></dt><dd><p>네트워크 서버 작성을 단순화하는 클래스.</p>
</dd>
<dt>모듈 <a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a></dt><dd><p>소켓 객체용 TLS/SSL 래퍼.</p>
</dd>
</dl>
</div>
<div class="section" id="socket-families">
<h2>소켓 패밀리<a class="headerlink" href="#socket-families" title="제목 주소">¶</a></h2>
<p>시스템과 빌드 옵션에 따라, 다양한 소켓 패밀리가 이 모듈에서 지원됩니다.</p>
<p>특정 소켓 객체가 요구하는 주소 형식은 소켓 객체를 만들 때 지정된 주소 패밀리에 따라 자동으로 선택됩니다. 소켓 주소는 다음과 같이 표현됩니다:</p>
<ul>
<li><p>파일 시스템 노드에 바인드 된 <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> 소켓의 주소는 파일 시스템 인코딩과 <code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code> 에러 처리기(<span class="target" id="index-29"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a>을 참조하세요)를 사용하는 문자열로 표현됩니다. 리눅스의 추상 이름 공간(abstract namespace)에 있는 주소는 처음에 널 바이트가 있는 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>로 반환됩니다; 이 이름 공간의 소켓은 일반 파일 시스템 소켓과 통신 할 수 있으므로, 리눅스에서 실행하려는 프로그램은 두 가지 유형의 주소를 모두 다뤄야 할 수도 있습니다. 문자열이나 바이트열류 객체는 인자로 전달할 때 두 가지 유형의 주소에 모두 사용할 수 있습니다.</p>
<blockquote>
<div><div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>이전에는, <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> 소켓 경로가 UTF-8 인코딩을 사용한다고 가정했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이제 쓰기 가능한 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>를 받아들입니다.</p>
</div>
</div></blockquote>
</li>
</ul>
<ul id="host-port">
<li><p>쌍 <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code>가 <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a> 주소 패밀리에 사용됩니다. 여기서 <em>host</em>는 <code class="docutils literal notranslate"><span class="pre">'daring.cwi.nl'</span></code>과 같은 인터넷 도메인 표기법의 호스트 명이나 <code class="docutils literal notranslate"><span class="pre">'100.50.200.5'</span></code>와 같은 IPv4 주소를 나타내는 문자열이고, <em>port</em>는 정수입니다.</p>
<ul class="simple">
<li><p>IPv4 주소의 경우, 호스트 주소 대신 두 개의 특수 형식이 허용됩니다: <code class="docutils literal notranslate"><span class="pre">''</span></code>는 모든 인터페이스에 바인딩하는 데 사용되는 <code class="xref py py-const docutils literal notranslate"><span class="pre">INADDR_ANY</span></code>를 나타내며 <code class="docutils literal notranslate"><span class="pre">'&lt;broadcast&gt;'</span></code> 문자열은 <code class="xref py py-const docutils literal notranslate"><span class="pre">INADDR_BROADCAST</span></code>를 나타냅니다. 이 동작은 IPv6와 호환되지 않으므로, 여러분의 파이썬 프로그램에서 IPv6를 지원하려는 경우에는 이것들을 사용하지 않을 수 있습니다.</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> 주소 패밀리의 경우, 4-튜플 <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port,</span> <span class="pre">flowinfo,</span> <span class="pre">scopeid)</span></code>가 사용됩니다. 여기서 <em>flowinfo</em> 와 <em>scopeid</em>는 C에서 <code class="xref py py-const docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr_in6</span></code>의 <code class="docutils literal notranslate"><span class="pre">sin6_flowinfo</span></code> 와 <code class="docutils literal notranslate"><span class="pre">sin6_scope_id</span></code> 멤버를 나타냅니다. <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 모듈 메서드의 경우, <em>flowinfo</em> 와 <em>scopeid</em>는 이전 버전과의 호환성을 위해 생략할 수 있습니다. 그러나, <em>scopeid</em>를 생략하면 스코프가 지정된(scoped) IPv6 주소를 조작하는 데 문제가 발생할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>멀티캐스트 주소(의미 있는 <em>scopeid</em>를 가진)의 경우, <em>address</em>에는 <code class="docutils literal notranslate"><span class="pre">%scope</span></code> (또는 <code class="docutils literal notranslate"><span class="pre">zone</span> <span class="pre">id</span></code>) 부분이 포함될 수 없습니다. 이 정보는 불필요하므로 안전하게 생략할 수 있습니다 (권장 사항).</p>
</div>
</li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_NETLINK</span></code> 소켓은 <code class="docutils literal notranslate"><span class="pre">(pid,</span> <span class="pre">groups)</span></code> 쌍으로 표현됩니다.</p></li>
<li><p>TIPC에 대한 리눅스 전용 지원은 <code class="xref py py-const docutils literal notranslate"><span class="pre">AF_TIPC</span></code> 주소 패밀리를 사용하여 사용할 수 있습니다. TIPC는 클러스터 된 컴퓨터 환경에서 사용하도록 설계된 개방형 비 IP 기반 네트워크 프로토콜입니다. 주소는 튜플로 표현되며 필드는 주소 유형에 따라 다릅니다. 일반적인 튜플 형식은 <code class="docutils literal notranslate"><span class="pre">(addr_type,</span> <span class="pre">v1,</span> <span class="pre">v2,</span> <span class="pre">v3</span> <span class="pre">[,</span> <span class="pre">scope])</span></code>입니다. 이때:</p>
<ul>
<li><p><em>addr_type</em>은 <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_ADDR_NAMESEQ</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_ADDR_NAME</span></code> 또는 <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_ADDR_ID</span></code> 중 하나입니다.</p></li>
<li><p><em>scope</em>는 <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_ZONE_SCOPE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_CLUSTER_SCOPE</span></code> 또는 <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_NODE_SCOPE</span></code> 중 하나입니다.</p></li>
<li><p><em>addr_type</em>이 <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_ADDR_NAME</span></code>이면, <em>v1</em>은 서버 유형이고, <em>v2</em>는 포트 식별자이며, <em>v3</em>은 0이어야 합니다.</p>
<p><em>addr_type</em>이 <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_ADDR_NAMESEQ</span></code>면, <em>v1</em>은 서버 유형이고, <em>v2</em>는 하위 포트 번호이며, <em>v3</em>는 상위 포트 번호입니다.</p>
<p><em>addr_type</em>이 <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_ADDR_ID</span></code>면, <em>v1</em>은 노드이고, <em>v2</em>는 참조이며, <em>v3</em>는 0으로 설정되어야 합니다.</p>
</li>
</ul>
</li>
<li><p>튜플 <code class="docutils literal notranslate"><span class="pre">(interface,</span> <span class="pre">)</span></code>가 <a class="reference internal" href="#socket.AF_CAN" title="socket.AF_CAN"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_CAN</span></code></a> 주소 패밀리에 사용됩니다. 여기서 <em>interface</em>는 <code class="docutils literal notranslate"><span class="pre">'can0'</span></code>과 같은 네트워크 인터페이스 이름을 나타내는 문자열입니다. 네트워크 인터페이스 이름 <code class="docutils literal notranslate"><span class="pre">''</span></code>는 이 패밀리의 모든 네트워크 인터페이스에서 패킷을 수신하는 데 사용할 수 있습니다.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#socket.CAN_ISOTP" title="socket.CAN_ISOTP"><code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_ISOTP</span></code></a> 프로토콜은 튜플 <code class="docutils literal notranslate"><span class="pre">(interface,</span> <span class="pre">rx_addr,</span> <span class="pre">tx_addr)</span></code>를 요구하는데, 두 개의 추가 매개 변수는 모두 CAN 식별자(표준 또는 확장)를 나타내는 부호 없는 long 정수입니다.</p></li>
</ul>
</li>
<li><p>문자열이나 튜플 <code class="docutils literal notranslate"><span class="pre">(id,</span> <span class="pre">unit)</span></code>는 <code class="xref py py-const docutils literal notranslate"><span class="pre">PF_SYSTEM</span></code> 패밀리의 <code class="xref py py-const docutils literal notranslate"><span class="pre">SYSPROTO_CONTROL</span></code> 프로토콜에 사용됩니다. 문자열은 동적으로 할당된 ID를 사용하는 커널 컨트롤의 이름입니다. 튜플은 커널 컨트롤의 ID와 유닛 번호가 알려져 있거나 등록된 ID가 사용될 때 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_BLUETOOTH</span></code>는 다음 프로토콜 및 주소 형식을 지원합니다:</p>
<ul>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">BTPROTO_L2CAP</span></code>는 <code class="docutils literal notranslate"><span class="pre">(bdaddr,</span> <span class="pre">psm)</span></code>를 받아들입니다. 여기서 <code class="docutils literal notranslate"><span class="pre">bdaddr</span></code>은 문자열 블루투스 주소이고 <code class="docutils literal notranslate"><span class="pre">psm</span></code>은 정수입니다.</p></li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">BTPROTO_RFCOMM</span></code>은 <code class="docutils literal notranslate"><span class="pre">(bdaddr,</span> <span class="pre">channel)</span></code>를 받아들입니다. 여기서 <code class="docutils literal notranslate"><span class="pre">bdaddr</span></code>은 문자열 블루투스 주소이고 <code class="docutils literal notranslate"><span class="pre">channel</span></code>은 정수입니다.</p></li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">BTPROTO_HCI</span></code>는 <code class="docutils literal notranslate"><span class="pre">(device_id,)</span></code>를 받아들입니다. 여기서 <code class="docutils literal notranslate"><span class="pre">device_id</span></code>는 정수나 인터페이스의 블루투스 주소인 문자열입니다. (이것은 여러분의 OS에 따라 다릅니다; NetBSD와 FreeBSD는 블루투스 주소를 기대하지만 다른 모든 것은 정수를 기대합니다.)</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>NetBSD 및 DragonFlyBSD 지원이 추가되었습니다.</p>
</div>
</li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">BTPROTO_SCO</span></code>는 <code class="docutils literal notranslate"><span class="pre">bdaddr</span></code>를 받아들입니다. 여기서 <code class="docutils literal notranslate"><span class="pre">bdaddr</span></code>는 블루투스 주소의 문자열 형식이 포함된 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체입니다. (예, <code class="docutils literal notranslate"><span class="pre">b'12:23:34:45:56:67'</span></code>) 이 프로토콜은 FreeBSD에서 지원되지 않습니다.</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#socket.AF_ALG" title="socket.AF_ALG"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_ALG</span></code></a>는 커널 암호 인터페이스에 기반한 리눅스 전용 소켓입니다. 알고리즘 소켓은 2~4개의 요소를 갖는 <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">name</span> <span class="pre">[,</span> <span class="pre">feat</span> <span class="pre">[,</span> <span class="pre">mask]])</span></code> 튜플로 구성됩니다. 여기서:</p>
<ul class="simple">
<li><p><em>type</em>은 문자열의 알고리즘 유형입니다, 예를 들어, <code class="docutils literal notranslate"><span class="pre">aead</span></code>, <code class="docutils literal notranslate"><span class="pre">hash</span></code>, <code class="docutils literal notranslate"><span class="pre">skcipher</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">rng</span></code>.</p></li>
<li><p><em>name</em>은 알고리즘 이름과 연산 모드 문자열입니다, 예를 들어, <code class="docutils literal notranslate"><span class="pre">sha256</span></code>, <code class="docutils literal notranslate"><span class="pre">hmac(sha256)</span></code>, <code class="docutils literal notranslate"><span class="pre">cbc(aes)</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">drbg_nopr_ctr_aes256</span></code>.</p></li>
<li><p><em>feat</em> 과 <em>mask</em>는 부호 없는 32비트 정수입니다.</p></li>
</ul>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux 2.6.38, some algorithm types require more recent Kernels.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</li>
<li><p><a class="reference internal" href="#socket.AF_VSOCK" title="socket.AF_VSOCK"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_VSOCK</span></code></a>은 가상 기계와 호스트가 통신할 수 있게 합니다. 소켓은 <code class="docutils literal notranslate"><span class="pre">(CID,</span> <span class="pre">port)</span></code> 튜플로 표현되는데, 컨텍스트 ID 또는 CID와 port는 정수입니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 4.8 QEMU &gt;= 2.8 ESX &gt;= 4.0 ESX Workstation &gt;= 6.5.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</li>
<li><p><a class="reference internal" href="#socket.AF_PACKET" title="socket.AF_PACKET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_PACKET</span></code></a>은 네트워크 장치에 직접 연결된 저수준 인터페이스입니다. 패킷은 튜플 <code class="docutils literal notranslate"><span class="pre">(ifname,</span> <span class="pre">proto[,</span> <span class="pre">pkttype[,</span> <span class="pre">hatype[,</span> <span class="pre">addr]]])</span></code>로 표현됩니다. 여기서:</p>
<ul class="simple">
<li><p><em>ifname</em> - 장치 이름을 지정하는 문자열</p></li>
<li><p><em>proto</em> - 이더넷 프로토콜 번호를 지정하는 네트워크 바이트 순서 정수.</p></li>
<li><p><em>pkttype</em> - 패킷 유형을 지정하는 선택적 정수.:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">PACKET_HOST</span></code> (기본값) - 로컬 호스트로 향하는 패킷.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PACKET_BROADCAST</span></code> - 물리 계층 브로드캐스트 패킷.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PACKET_MULTIHOST</span></code> - 물리 계층 멀티캐스트 주소로 전송된 패킷.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PACKET_OTHERHOST</span></code> - 무차별 모드의 장치 관리자에 의해 포착된 다른 호스트로 향하는 패킷.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PACKET_OUTGOING</span></code> - 패킷 소켓으로 루프 백 된 로컬 호스트에서 시작된 패킷.</p></li>
</ul>
</li>
<li><p><em>hatype</em> - ARP 하드웨어 주소 유형을 지정하는 선택적 정수.</p></li>
<li><p><em>addr</em> - 하드웨어 물리 주소를 지정하는 선택적 바이트열류 객체, 해석은 장치에 따라 다릅니다.</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#socket.AF_QIPCRTR" title="socket.AF_QIPCRTR"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_QIPCRTR</span></code></a>는 Qualcomm 플랫폼의 코 프로세서에서 실행되는 서비스와 통신하기 위한 리눅스 전용 소켓 기반 인터페이스입니다. 주소 패밀리는 <code class="docutils literal notranslate"><span class="pre">(node,</span> <span class="pre">port)</span></code> 튜플로 표현되는데, <em>node</em>와 <em>port</em>는 음수가 아닌 정수입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</li>
</ul>
<p>IPv4/v6 소켓 주소의 <em>host</em> 부분에 호스트 명을 사용하면, 파이썬이 DNS 결정에서 반환된 첫 번째 주소를 사용하기 때문에, 프로그램은 비결정적인 동작을 보일 수 있습니다. 소켓 주소는 DNS 결정 결과 및/또는 호스트 구성에 따라 실제 IPv4/v6 주소로 다르게 결정됩니다. 결정론적 동작을 위해서는 <em>host</em> 부분에 숫자 주소를 사용하십시오.</p>
<p>모든 에러는 예외를 발생시킵니다. 잘못된 인자 형과 메모리 부족 조건에 대한 일반적인 예외가 발생할 수 있습니다. 파이썬 3.3부터, 소켓이나 주소 의미와 관련된 에러는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 나 그 서브 클래스 중 하나를 발생시킵니다 (예전에는 <a class="reference internal" href="#socket.error" title="socket.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.error</span></code></a>를 발생시켰습니다).</p>
<p>비 블로킹 모드는 <a class="reference internal" href="#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setblocking()</span></code></a>을 통해 지원됩니다. 시간제한을 기반으로 하는 일반화는 <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a>을 통해 지원됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>여기에서 일반화란, <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a> 으로 시간제한을 0으로 줄 때,
비 블로킹 소켓으로 전환한다는 뜻입니다.</p>
</div>
</div>
<div class="section" id="module-contents">
<h2>모듈 내용<a class="headerlink" href="#module-contents" title="제목 주소">¶</a></h2>
<p>모듈 <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a>은 다음 요소를 노출합니다.</p>
<div class="section" id="exceptions">
<h3>예외<a class="headerlink" href="#exceptions" title="제목 주소">¶</a></h3>
<dl class="exception">
<dt id="socket.error">
<em class="property">exception </em><code class="descclassname">socket.</code><code class="descname">error</code><a class="headerlink" href="#socket.error" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 폐지된 별칭.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><span class="target" id="index-30"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3151"><strong>PEP 3151</strong></a>을 따라, 이 클래스는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 별칭이 되었습니다.</p>
</div>
</dd></dl>

<dl class="exception">
<dt id="socket.herror">
<em class="property">exception </em><code class="descclassname">socket.</code><code class="descname">herror</code><a class="headerlink" href="#socket.herror" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 서브 클래스, 이 예외는 주소 관련 에러에서 발생합니다. 즉 <a class="reference internal" href="#socket.gethostbyname_ex" title="socket.gethostbyname_ex"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyname_ex()</span></code></a>와 <a class="reference internal" href="#socket.gethostbyaddr" title="socket.gethostbyaddr"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyaddr()</span></code></a>를 포함하는 POSIX C API의 <em>h_errno</em>를 사용하는 함수들. 수반되는 값은 라이브러리 호출이 반환한 에러를 나타내는 <code class="docutils literal notranslate"><span class="pre">(h_errno,</span> <span class="pre">string)</span></code> 쌍입니다. <em>h_errno</em>는 숫자 값이고, <em>string</em>은 <code class="xref c c-func docutils literal notranslate"><span class="pre">hstrerror()</span></code> C 함수에 의해 반환된 <em>h_errno</em>의 설명을 나타냅니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>이 클래스는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 서브 클래스가 되었습니다.</p>
</div>
</dd></dl>

<dl class="exception">
<dt id="socket.gaierror">
<em class="property">exception </em><code class="descclassname">socket.</code><code class="descname">gaierror</code><a class="headerlink" href="#socket.gaierror" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 서브 클래스, 이 예외는 <a class="reference internal" href="#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> 와 <a class="reference internal" href="#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getnameinfo()</span></code></a>에 의한 주소 관련 에러에서 발생합니다. 수반되는 값은 라이브러리 호출이 반환한 에러를 나타내는 <code class="docutils literal notranslate"><span class="pre">(error,</span> <span class="pre">string)</span></code> 쌍입니다. <em>string</em>은 <code class="xref c c-func docutils literal notranslate"><span class="pre">gai_strerror()</span></code> C 함수가 반환한 <em>error</em>의 설명을 나타냅니다. 숫자 <em>error</em> 값은 이 모듈에 정의된 <code class="xref py py-const docutils literal notranslate"><span class="pre">EAI_*</span></code> 상수 중 하나와 일치합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>이 클래스는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 서브 클래스가 되었습니다.</p>
</div>
</dd></dl>

<dl class="exception">
<dt id="socket.timeout">
<em class="property">exception </em><code class="descclassname">socket.</code><code class="descname">timeout</code><a class="headerlink" href="#socket.timeout" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 서브 클래스, 이 예외는 앞서 <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a> 호출을 통해 (또는 묵시적으로 <a class="reference internal" href="#socket.setdefaulttimeout" title="socket.setdefaulttimeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">setdefaulttimeout()</span></code></a>를 통해) 시간제한이 활성화된 소켓에서 시간 초과가 일어날 때 발생합니다. 수반되는 값은 현재는 항상 &quot;timed out&quot; 값을 갖는 문자열입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>이 클래스는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 서브 클래스가 되었습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="constants">
<h3>상수<a class="headerlink" href="#constants" title="제목 주소">¶</a></h3>
<blockquote>
<div><p>AF_* 와 SOCK_* 상수는 이제 <code class="xref py py-class docutils literal notranslate"><span class="pre">AddressFamily</span></code> 와 <code class="xref py py-class docutils literal notranslate"><span class="pre">SocketKind</span></code> <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntEnum</span></code></a> 컬렉션입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</div></blockquote>
<dl class="data">
<dt id="socket.AF_UNIX">
<code class="descclassname">socket.</code><code class="descname">AF_UNIX</code><a class="headerlink" href="#socket.AF_UNIX" title="정의 주소">¶</a></dt>
<dt id="socket.AF_INET">
<code class="descclassname">socket.</code><code class="descname">AF_INET</code><a class="headerlink" href="#socket.AF_INET" title="정의 주소">¶</a></dt>
<dt id="socket.AF_INET6">
<code class="descclassname">socket.</code><code class="descname">AF_INET6</code><a class="headerlink" href="#socket.AF_INET6" title="정의 주소">¶</a></dt>
<dd><p>이 상수는 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code></a>의 첫 번째 인자에 사용되는 주소 (및 프로토콜) 패밀리를 나타냅니다. <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> 상수가 정의되지 않으면 이 프로토콜은 지원되지 않습니다. 시스템에 따라 더 많은 상수를 사용할 수 있습니다.</p>
</dd></dl>

<dl class="data">
<dt id="socket.SOCK_STREAM">
<code class="descclassname">socket.</code><code class="descname">SOCK_STREAM</code><a class="headerlink" href="#socket.SOCK_STREAM" title="정의 주소">¶</a></dt>
<dt id="socket.SOCK_DGRAM">
<code class="descclassname">socket.</code><code class="descname">SOCK_DGRAM</code><a class="headerlink" href="#socket.SOCK_DGRAM" title="정의 주소">¶</a></dt>
<dt id="socket.SOCK_RAW">
<code class="descclassname">socket.</code><code class="descname">SOCK_RAW</code><a class="headerlink" href="#socket.SOCK_RAW" title="정의 주소">¶</a></dt>
<dt id="socket.SOCK_RDM">
<code class="descclassname">socket.</code><code class="descname">SOCK_RDM</code><a class="headerlink" href="#socket.SOCK_RDM" title="정의 주소">¶</a></dt>
<dt id="socket.SOCK_SEQPACKET">
<code class="descclassname">socket.</code><code class="descname">SOCK_SEQPACKET</code><a class="headerlink" href="#socket.SOCK_SEQPACKET" title="정의 주소">¶</a></dt>
<dd><p>이 상수는 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code></a>의 두 번째 인자에 사용되는 소켓 유형을 나타냅니다. 시스템에 따라 더 많은 상수를 사용할 수 있습니다. (<a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>과 <a class="reference internal" href="#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code></a> 만 일반적으로 유용합니다.)</p>
</dd></dl>

<dl class="data">
<dt id="socket.SOCK_CLOEXEC">
<code class="descclassname">socket.</code><code class="descname">SOCK_CLOEXEC</code><a class="headerlink" href="#socket.SOCK_CLOEXEC" title="정의 주소">¶</a></dt>
<dt id="socket.SOCK_NONBLOCK">
<code class="descclassname">socket.</code><code class="descname">SOCK_NONBLOCK</code><a class="headerlink" href="#socket.SOCK_NONBLOCK" title="정의 주소">¶</a></dt>
<dd><p>이 두 상수는, 정의되었다면, 소켓 유형과 결합하여 일부 플래그를 원자 적으로 설정할 수 있도록 합니다 (따라서 경쟁 조건의 가능성과 별도 호출의 필요성을 피할 수 있습니다).</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>좀 더 철저한 설명은 <a class="reference external" href="http://udrepper.livejournal.com/20407.html">Secure File Descriptor Handling</a>.</p>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 리눅스 &gt;= 2.6.27.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt>
<code class="descname">SO_*</code></dt>
<dt id="socket.SOMAXCONN">
<code class="descclassname">socket.</code><code class="descname">SOMAXCONN</code><a class="headerlink" href="#socket.SOMAXCONN" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">MSG_*</code></dt>
<dt>
<code class="descname">SOL_*</code></dt>
<dt>
<code class="descname">SCM_*</code></dt>
<dt>
<code class="descname">IPPROTO_*</code></dt>
<dt>
<code class="descname">IPPORT_*</code></dt>
<dt>
<code class="descname">INADDR_*</code></dt>
<dt>
<code class="descname">IP_*</code></dt>
<dt>
<code class="descname">IPV6_*</code></dt>
<dt>
<code class="descname">EAI_*</code></dt>
<dt>
<code class="descname">AI_*</code></dt>
<dt>
<code class="descname">NI_*</code></dt>
<dt>
<code class="descname">TCP_*</code></dt>
<dd><p>소켓 및/또는 IP 프로토콜에 대한 유닉스 설명서에서 설명된 이 형식의 많은 상수는 소켓 모듈에도 정의되어 있습니다. 일반적으로 소켓 객체의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code> 와 <code class="xref py py-meth docutils literal notranslate"><span class="pre">getsockopt()</span></code> 메서드 인자에 사용됩니다. 대부분 유닉스 헤더 파일에 정의된 기호만 정의됩니다; 몇 가지 기호는 기본값이 제공됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="docutils literal notranslate"><span class="pre">SO_DOMAIN</span></code>, <code class="docutils literal notranslate"><span class="pre">SO_PROTOCOL</span></code>, <code class="docutils literal notranslate"><span class="pre">SO_PEERSEC</span></code>, <code class="docutils literal notranslate"><span class="pre">SO_PASSSEC</span></code>, <code class="docutils literal notranslate"><span class="pre">TCP_USER_TIMEOUT</span></code>, <code class="docutils literal notranslate"><span class="pre">TCP_CONGESTION</span></code>가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6.5에서 변경: </span>윈도우에서, 런타임 윈도우가 지원하면 <code class="docutils literal notranslate"><span class="pre">TCP_FASTOPEN</span></code>, <code class="docutils literal notranslate"><span class="pre">TCP_KEEPCNT</span></code>가 나타납니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><code class="docutils literal notranslate"><span class="pre">TCP_NOTSENT_LOWAT</span></code>가 추가되었습니다.</p>
<p>윈도우에서, 런타임 윈도우가 지원하면 <code class="docutils literal notranslate"><span class="pre">TCP_KEEPIDLE</span></code>, <code class="docutils literal notranslate"><span class="pre">TCP_KEEPINTVL</span></code>가 나타납니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="socket.AF_CAN">
<code class="descclassname">socket.</code><code class="descname">AF_CAN</code><a class="headerlink" href="#socket.AF_CAN" title="정의 주소">¶</a></dt>
<dt id="socket.PF_CAN">
<code class="descclassname">socket.</code><code class="descname">PF_CAN</code><a class="headerlink" href="#socket.PF_CAN" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">SOL_CAN_*</code></dt>
<dt>
<code class="descname">CAN_*</code></dt>
<dd><p>리눅스 설명서에 설명되어있는 이 형식의 많은 상수는 소켓 모듈에도 정의되어 있습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a> : 리눅스 &gt;= 2.6.25.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="socket.CAN_BCM">
<code class="descclassname">socket.</code><code class="descname">CAN_BCM</code><a class="headerlink" href="#socket.CAN_BCM" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">CAN_BCM_*</code></dt>
<dd><p>CAN 프로토콜 패밀리에서 CAN_BCM은 브로드캐스트 관리자 (Broadcast Manager, BCM) 프로토콜입니다. 리눅스 설명서에서 설명된 브로드캐스트 관리자 상수도 소켓 모듈에 정의되어 있습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a> : 리눅스 &gt;= 2.6.25.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>The <code class="xref py py-data docutils literal notranslate"><span class="pre">CAN_BCM_CAN_FD_FRAME</span></code> flag is only available on Linux &gt;= 4.8.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="socket.CAN_RAW_FD_FRAMES">
<code class="descclassname">socket.</code><code class="descname">CAN_RAW_FD_FRAMES</code><a class="headerlink" href="#socket.CAN_RAW_FD_FRAMES" title="정의 주소">¶</a></dt>
<dd><p>CAN_RAW 소켓에서 CAN FD 지원을 활성화합니다. 기본적으로 비활성화되어 있습니다. 여러분의 응용 프로그램이 CAN과 CAN FD 프레임을 모두 보낼 수 있도록 합니다; 그러나 소켓에서 읽을 때 CAN과 CAN FD 프레임을 모두 받아들여야 합니다.</p>
<p>이 상수는 리눅스 설명서에 설명되어 있습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a> : 리눅스 &gt;= 3.6.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="socket.CAN_ISOTP">
<code class="descclassname">socket.</code><code class="descname">CAN_ISOTP</code><a class="headerlink" href="#socket.CAN_ISOTP" title="정의 주소">¶</a></dt>
<dd><p>CAN 프로토콜 패밀리의 CAN_ISOTP는 ISO-TP (ISO 15765-2) 프로토콜입니다. ISO-TP 상수는 리눅스 설명서에 설명되어 있습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a> : 리눅스 &gt;= 2.6.25.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="socket.AF_PACKET">
<code class="descclassname">socket.</code><code class="descname">AF_PACKET</code><a class="headerlink" href="#socket.AF_PACKET" title="정의 주소">¶</a></dt>
<dt id="socket.PF_PACKET">
<code class="descclassname">socket.</code><code class="descname">PF_PACKET</code><a class="headerlink" href="#socket.PF_PACKET" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">PACKET_*</code></dt>
<dd><p>리눅스 설명서에 설명되어있는 이 형식의 많은 상수는 소켓 모듈에도 정의되어 있습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a> : 리눅스 &gt;= 2.2.</p>
</dd></dl>

<dl class="data">
<dt id="socket.AF_RDS">
<code class="descclassname">socket.</code><code class="descname">AF_RDS</code><a class="headerlink" href="#socket.AF_RDS" title="정의 주소">¶</a></dt>
<dt id="socket.PF_RDS">
<code class="descclassname">socket.</code><code class="descname">PF_RDS</code><a class="headerlink" href="#socket.PF_RDS" title="정의 주소">¶</a></dt>
<dt id="socket.SOL_RDS">
<code class="descclassname">socket.</code><code class="descname">SOL_RDS</code><a class="headerlink" href="#socket.SOL_RDS" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">RDS_*</code></dt>
<dd><p>리눅스 설명서에 설명되어있는 이 형식의 많은 상수는 소켓 모듈에도 정의되어 있습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a> : 리눅스 &gt;= 2.6.30.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="socket.SIO_RCVALL">
<code class="descclassname">socket.</code><code class="descname">SIO_RCVALL</code><a class="headerlink" href="#socket.SIO_RCVALL" title="정의 주소">¶</a></dt>
<dt id="socket.SIO_KEEPALIVE_VALS">
<code class="descclassname">socket.</code><code class="descname">SIO_KEEPALIVE_VALS</code><a class="headerlink" href="#socket.SIO_KEEPALIVE_VALS" title="정의 주소">¶</a></dt>
<dt id="socket.SIO_LOOPBACK_FAST_PATH">
<code class="descclassname">socket.</code><code class="descname">SIO_LOOPBACK_FAST_PATH</code><a class="headerlink" href="#socket.SIO_LOOPBACK_FAST_PATH" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">RCVALL_*</code></dt>
<dd><p>윈도우 WSAIoctl()용 상수. 이 상수는 소켓 객체의 <a class="reference internal" href="#socket.socket.ioctl" title="socket.socket.ioctl"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ioctl()</span></code></a> 메서드에 대한 인자로 사용됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="docutils literal notranslate"><span class="pre">SIO_LOOPBACK_FAST_PATH</span></code>가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt>
<code class="descname">TIPC_*</code></dt>
<dd><p>TIPC 관련 상수. C 소켓 API에서 내보낸 것과 일치합니다. 자세한 정보는 TIPC 설명서를 참조하십시오.</p>
</dd></dl>

<dl class="data">
<dt id="socket.AF_ALG">
<code class="descclassname">socket.</code><code class="descname">AF_ALG</code><a class="headerlink" href="#socket.AF_ALG" title="정의 주소">¶</a></dt>
<dt id="socket.SOL_ALG">
<code class="descclassname">socket.</code><code class="descname">SOL_ALG</code><a class="headerlink" href="#socket.SOL_ALG" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">ALG_*</code></dt>
<dd><p>리눅스 커널 암호화용 상수.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a> : 리눅스 &gt;= 2.6.38.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="socket.AF_VSOCK">
<code class="descclassname">socket.</code><code class="descname">AF_VSOCK</code><a class="headerlink" href="#socket.AF_VSOCK" title="정의 주소">¶</a></dt>
<dt id="socket.IOCTL_VM_SOCKETS_GET_LOCAL_CID">
<code class="descclassname">socket.</code><code class="descname">IOCTL_VM_SOCKETS_GET_LOCAL_CID</code><a class="headerlink" href="#socket.IOCTL_VM_SOCKETS_GET_LOCAL_CID" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">VMADDR*</code></dt>
<dt>
<code class="descname">SO_VM*</code></dt>
<dd><p>리눅스 호스트/게스트 통신용 상수.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a> : 리눅스 &gt;= 4.8.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="socket.AF_LINK">
<code class="descclassname">socket.</code><code class="descname">AF_LINK</code><a class="headerlink" href="#socket.AF_LINK" title="정의 주소">¶</a></dt>
<dd><p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a> : BSD, OSX.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="socket.has_ipv6">
<code class="descclassname">socket.</code><code class="descname">has_ipv6</code><a class="headerlink" href="#socket.has_ipv6" title="정의 주소">¶</a></dt>
<dd><p>이 상수는 이 플랫폼에서 IPv6가 지원되는지를 나타내는 논릿값을 포함합니다.</p>
</dd></dl>

<dl class="data">
<dt id="socket.BDADDR_ANY">
<code class="descclassname">socket.</code><code class="descname">BDADDR_ANY</code><a class="headerlink" href="#socket.BDADDR_ANY" title="정의 주소">¶</a></dt>
<dt id="socket.BDADDR_LOCAL">
<code class="descclassname">socket.</code><code class="descname">BDADDR_LOCAL</code><a class="headerlink" href="#socket.BDADDR_LOCAL" title="정의 주소">¶</a></dt>
<dd><p>이들은 특수한 의미를 지닌 블루투스 주소를 포함하는 문자열 상수입니다. 예를 들어, <a class="reference internal" href="#socket.BDADDR_ANY" title="socket.BDADDR_ANY"><code class="xref py py-const docutils literal notranslate"><span class="pre">BDADDR_ANY</span></code></a>는 바인딩 소켓을 <code class="xref py py-const docutils literal notranslate"><span class="pre">BTPROTO_RFCOMM</span></code>로 지정할 때 임의의(any) 주소를 나타내는 데 사용할 수 있습니다.</p>
</dd></dl>

<dl class="data">
<dt id="socket.HCI_FILTER">
<code class="descclassname">socket.</code><code class="descname">HCI_FILTER</code><a class="headerlink" href="#socket.HCI_FILTER" title="정의 주소">¶</a></dt>
<dt id="socket.HCI_TIME_STAMP">
<code class="descclassname">socket.</code><code class="descname">HCI_TIME_STAMP</code><a class="headerlink" href="#socket.HCI_TIME_STAMP" title="정의 주소">¶</a></dt>
<dt id="socket.HCI_DATA_DIR">
<code class="descclassname">socket.</code><code class="descname">HCI_DATA_DIR</code><a class="headerlink" href="#socket.HCI_DATA_DIR" title="정의 주소">¶</a></dt>
<dd><p><code class="xref py py-const docutils literal notranslate"><span class="pre">BTPROTO_HCI</span></code>와 함께 사용하십시오. NetBSD 나 DragonFlyBSD에서는 <a class="reference internal" href="#socket.HCI_FILTER" title="socket.HCI_FILTER"><code class="xref py py-const docutils literal notranslate"><span class="pre">HCI_FILTER</span></code></a>를 사용할 수 없습니다. <a class="reference internal" href="#socket.HCI_TIME_STAMP" title="socket.HCI_TIME_STAMP"><code class="xref py py-const docutils literal notranslate"><span class="pre">HCI_TIME_STAMP</span></code></a>와 <a class="reference internal" href="#socket.HCI_DATA_DIR" title="socket.HCI_DATA_DIR"><code class="xref py py-const docutils literal notranslate"><span class="pre">HCI_DATA_DIR</span></code></a>는 FreeBSD, NetBSD 또는 DragonFlyBSD에서 사용할 수 없습니다.</p>
</dd></dl>

<dl class="data">
<dt id="socket.AF_QIPCRTR">
<code class="descclassname">socket.</code><code class="descname">AF_QIPCRTR</code><a class="headerlink" href="#socket.AF_QIPCRTR" title="정의 주소">¶</a></dt>
<dd><p>원격 프로세서를 제공하는 서비스와 통신하는 데 사용되는 Qualcomm의 IPC 라우터 프로토콜용 상수.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 리눅스 &gt;= 4.7.</p>
</dd></dl>

</div>
<div class="section" id="functions">
<h3>함수<a class="headerlink" href="#functions" title="제목 주소">¶</a></h3>
<div class="section" id="creating-sockets">
<h4>소켓 만들기<a class="headerlink" href="#creating-sockets" title="제목 주소">¶</a></h4>
<p>다음 함수는 모두 <a class="reference internal" href="#socket-objects"><span class="std std-ref">소켓 객체</span></a>를 만듭니다.</p>
<dl class="function">
<dt id="socket.socket">
<code class="descclassname">socket.</code><code class="descname">socket</code><span class="sig-paren">(</span><em>family=AF_INET</em>, <em>type=SOCK_STREAM</em>, <em>proto=0</em>, <em>fileno=None</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket" title="정의 주소">¶</a></dt>
<dd><p>지정된 주소 패밀리, 소켓 유형, 및 프로토콜 번호를 사용하여 새로운 소켓을 만듭니다. 주소 패밀리는 <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a> (기본값), <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>, <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>, <a class="reference internal" href="#socket.AF_CAN" title="socket.AF_CAN"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_CAN</span></code></a>, <a class="reference internal" href="#socket.AF_PACKET" title="socket.AF_PACKET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_PACKET</span></code></a> 또는 <a class="reference internal" href="#socket.AF_RDS" title="socket.AF_RDS"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_RDS</span></code></a> 여야 합니다. 소켓 유형은 <a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a> (기본값), <a class="reference internal" href="#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code></a>, <a class="reference internal" href="#socket.SOCK_RAW" title="socket.SOCK_RAW"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_RAW</span></code></a> 또는 기타 <code class="docutils literal notranslate"><span class="pre">SOCK_</span></code> 상수 중 하나여야 합니다. 프로토콜 번호는 일반적으로 0이며 생략될 수도 있고, 주소 패밀리가 <a class="reference internal" href="#socket.AF_CAN" title="socket.AF_CAN"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_CAN</span></code></a> 일 때 프로토콜은 <code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_RAW</span></code>, <a class="reference internal" href="#socket.CAN_BCM" title="socket.CAN_BCM"><code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_BCM</span></code></a> 또는 <a class="reference internal" href="#socket.CAN_ISOTP" title="socket.CAN_ISOTP"><code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_ISOTP</span></code></a> 중 하나여야 합니다.</p>
<p><em>fileno</em>를 지정하면, <em>family</em>, <em>type</em> 및 <em>proto</em> 값이 지정된 파일 기술자에서 자동 감지됩니다. 명시적 <em>family</em>, <em>type</em> 또는 <em>proto</em> 인자를 사용하여 함수를 호출하면 자동 감지가 무효화 될 수 있습니다. 이는 파이썬이 <a class="reference internal" href="#socket.socket.getpeername" title="socket.socket.getpeername"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getpeername()</span></code></a>의 반환 값을 나타내는 방식에 영향을 미치지만, 실제 OS 자원에는 영향을 주지 않습니다. <a class="reference internal" href="#socket.fromfd" title="socket.fromfd"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.fromfd()</span></code></a>와는 달리, <em>fileno</em>는 복제본이 아니라 같은 소켓을 반환합니다. 이렇게 하면 <a class="reference internal" href="#socket.close" title="socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.close()</span></code></a>를 사용하여 분리된 소켓을 닫을 수 있습니다.</p>
<p>새로 만들어진 소켓은 <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">상속 불가능</span></a>합니다.</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">family</span></code>, <code class="docutils literal notranslate"><span class="pre">type</span></code>, <code class="docutils literal notranslate"><span class="pre">protocol</span></code>를 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.__new__</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>AF_CAN 패밀리가 추가되었습니다. AF_RDS 패밀리가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>CAN_BCM 프로토콜이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>반환된 소켓은 이제 상속 불가능합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>CAN_ISOTP 프로토콜이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="#socket.SOCK_NONBLOCK" title="socket.SOCK_NONBLOCK"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_NONBLOCK</span></code></a> 이나 <a class="reference internal" href="#socket.SOCK_CLOEXEC" title="socket.SOCK_CLOEXEC"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_CLOEXEC</span></code></a> 비트 플래그가 <em>type</em>에 적용되면, 이것들은 지워지고, <a class="reference internal" href="#socket.socket.type" title="socket.socket.type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">socket.type</span></code></a>는 이를 반영하지 않습니다. 이것들은 여전히 하부 시스템 <cite>socket()</cite> 호출로 전달됩니다. 따라서:</p>
<blockquote>
<div><dl class="simple">
<dt>sock = socket.socket(</dt><dd><p>socket.AF_INET,
socket.SOCK_STREAM | socket.SOCK_NONBLOCK)</p>
</dd>
</dl>
</div></blockquote>
<p>는 여전히 <code class="docutils literal notranslate"><span class="pre">SOCK_NONBLOCK</span></code>를 지원하는 OS에서 비 블로킹 소켓을 만들지만, <code class="docutils literal notranslate"><span class="pre">sock.type</span></code>은 <code class="docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code>로 설정됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.socketpair">
<code class="descclassname">socket.</code><code class="descname">socketpair</code><span class="sig-paren">(</span><span class="optional">[</span><em>family</em><span class="optional">[</span>, <em>type</em><span class="optional">[</span>, <em>proto</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socketpair" title="정의 주소">¶</a></dt>
<dd><p>제공된 주소 패밀리, 소켓 유형 및 프로토콜 번호를 사용하여 연결된 소켓 객체 쌍을 만듭니다. 주소 패밀리, 소켓 유형 및 프로토콜 번호는 위의 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code></a> 함수와 같습니다. 플랫폼에서 정의되어 있으면 기본 패밀리는 <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>입니다; 그렇지 않으면 기본값은 <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a>입니다.</p>
<p>새로 만들어진 소켓은 <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">상속 불가능</span></a>합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>반환된 소켓 객체는 이제 부분 집합이 아닌 전체 소켓 API를 지원합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>반환된 소켓은 이제 상속 불가능합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>윈도우 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.create_connection">
<code class="descclassname">socket.</code><code class="descname">create_connection</code><span class="sig-paren">(</span><em>address</em><span class="optional">[</span>, <em>timeout</em><span class="optional">[</span>, <em>source_address</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.create_connection" title="정의 주소">¶</a></dt>
<dd><p>인터넷 <em>address</em>(2-튜플 <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code>)에서 리스닝하는 TCP 서비스에 연결하고 소켓 객체를 반환합니다. 이것은 <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code></a> 보다 고수준 함수입니다: <em>host</em>가 숫자가 아닌 호스트 명이면, <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET</span></code></a>과 <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> 모두로 결정하려고 시도한 다음, 연결이 성공할 때까지 차례대로 모든 가능한 주소로 연결을 시도합니다. 이것은 IPv4 및 IPv6 모두에 호환되는 클라이언트를 쉽게 작성할 수 있도록 합니다.</p>
<p>선택적 <em>timeout</em> 매개 변수를 전달하면 연결을 시도하기 전에 소켓 인스턴스의 시간제한을 설정합니다. <em>timeout</em>이 제공되지 않으면, <a class="reference internal" href="#socket.getdefaulttimeout" title="socket.getdefaulttimeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">getdefaulttimeout()</span></code></a>에 의해 반환된 전역 기본 시간제한 설정이 사용됩니다.</p>
<p>제공되면, <em>source_address</em>는 연결하기 전에 소켓이 소스 주소로 바인드 할 2-튜플 <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code> 여야 합니다. 호스트나 포트가 각각 '' 나 0이면 OS 기본 동작이 사용됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>source_address</em>가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.create_server">
<code class="descclassname">socket.</code><code class="descname">create_server</code><span class="sig-paren">(</span><em>address</em>, <em>*</em>, <em>family=AF_INET</em>, <em>backlog=None</em>, <em>reuse_port=False</em>, <em>dualstack_ipv6=False</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.create_server" title="정의 주소">¶</a></dt>
<dd><p><em>address</em>(2-튜플 <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code>)에 바인드 된 TCP 소켓을 만들고 소켓 객체를 반환하는 편리 함수.</p>
<p><em>family</em>는 <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET</span></code></a>이나 <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>여야 합니다. <em>backlog</em>는 <a class="reference internal" href="#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.listen()</span></code></a>에 전달된 대기열 크기입니다; <code class="docutils literal notranslate"><span class="pre">0</span></code>이면 기본값으로 합리적인 값이 선택됩니다. <em>reuse_port</em>는 <code class="xref py py-data docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code> 소켓 옵션을 설정할지를 나타냅니다.</p>
<p><em>dualstack_ipv6</em>가 참이고 플랫폼이 이를 지원하면, 소켓은 IPv4와 IPv6 연결을 모두 받아들일 수 있습니다, 그렇지 않으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 대부분의 POSIX 플랫폼과 윈도우는 이 기능을 지원한다고 여겨집니다. 이 기능이 활성화되면, IPv4 연결이 이루어질 때 <a class="reference internal" href="#socket.socket.getpeername" title="socket.socket.getpeername"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getpeername()</span></code></a>이 반환하는 주소는 IPv4-매핑된 IPv6 주소로 표현된 IPv6 주소가 됩니다. <em>dualstack_ipv6</em>가 거짓이면, 기본적으로 이 기능을 활성화하는 플랫폼에서 (예를 들어, 리눅스), 이 기능을 명시적으로 비활성화합니다. 이 매개 변수는 <a class="reference internal" href="#socket.has_dualstack_ipv6" title="socket.has_dualstack_ipv6"><code class="xref py py-func docutils literal notranslate"><span class="pre">has_dualstack_ipv6()</span></code></a>와 함께 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>

<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">)</span>  <span class="c1"># 모든 인터페이스, 포트 8080</span>
<span class="k">if</span> <span class="n">socket</span><span class="o">.</span><span class="n">has_dualstack_ipv6</span><span class="p">():</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET6</span><span class="p">,</span> <span class="n">dualstack_ipv6</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>POSIX 플랫폼에서 <code class="xref py py-data docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> 소켓 옵션은 같은 <em>address</em>에 바인드 되었고 TIME_WAIT 상태로 남아 있던 이전 소켓을 즉시 재사용하기 위해 설정됩니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.has_dualstack_ipv6">
<code class="descclassname">socket.</code><code class="descname">has_dualstack_ipv6</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.has_dualstack_ipv6" title="정의 주소">¶</a></dt>
<dd><p>플랫폼이 IPv4와 IPv6 연결을 모두 처리할 수 있는 TCP 소켓을 만드는 것을 지원하면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.fromfd">
<code class="descclassname">socket.</code><code class="descname">fromfd</code><span class="sig-paren">(</span><em>fd</em>, <em>family</em>, <em>type</em>, <em>proto=0</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.fromfd" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em>(파일 객체의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code> 메서드에서 반환된 정수)를 복제하고 결과로 소켓 객체를 만듭니다. 주소 패밀리, 소켓 유형 및 프로토콜 번호는 위의 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code></a> 함수와 같습니다. 파일 기술자는 소켓을 참조해야 하지만, 검사하지는 않습니다 --- 파일 기술자가 유효하지 않으면 객체에 대한 후속 연산이 실패할 수 있습니다. 이 함수는 거의 필요하지 않지만, 프로그램에 표준 입력이나 출력으로 프로그램에 전달된 (가령 유닉스 inet 데몬으로 시작한 서버) 소켓의 소켓 옵션을 가져오거나 설정하는 데 사용할 수 있습니다. 소켓은 블로킹 모드로 간주합니다.</p>
<p>새로 만들어진 소켓은 <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">상속 불가능</span></a>합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>반환된 소켓은 이제 상속 불가능합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.fromshare">
<code class="descclassname">socket.</code><code class="descname">fromshare</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.fromshare" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#socket.socket.share" title="socket.socket.share"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.share()</span></code></a> 메서드에서 얻은 데이터로 소켓의 인스턴스를 만듭니다. 소켓은 블로킹 모드로 간주합니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 윈도우.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="socket.SocketType">
<code class="descclassname">socket.</code><code class="descname">SocketType</code><a class="headerlink" href="#socket.SocketType" title="정의 주소">¶</a></dt>
<dd><p>이것은 소켓 객체 형을 나타내는 파이썬 형 객체입니다. <code class="docutils literal notranslate"><span class="pre">type(socket(...))</span></code>과 같습니다.</p>
</dd></dl>

</div>
<div class="section" id="other-functions">
<h4>기타 함수<a class="headerlink" href="#other-functions" title="제목 주소">¶</a></h4>
<p><a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 모듈은 또한 다양한 네트워크 관련 서비스를 제공합니다:</p>
<dl class="function">
<dt id="socket.close">
<code class="descclassname">socket.</code><code class="descname">close</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.close" title="정의 주소">¶</a></dt>
<dd><p>소켓 파일 기술자를 닫습니다. 이것은 <a class="reference internal" href="os.html#os.close" title="os.close"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.close()</span></code></a>와 비슷하지만, 소켓 용입니다. 일부 플랫폼(가장 눈에 띄는 것은 윈도우)에서는 <a class="reference internal" href="os.html#os.close" title="os.close"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.close()</span></code></a>가 소켓 파일 기술자에 대해 작동하지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.getaddrinfo">
<code class="descclassname">socket.</code><code class="descname">getaddrinfo</code><span class="sig-paren">(</span><em>host</em>, <em>port</em>, <em>family=0</em>, <em>type=0</em>, <em>proto=0</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.getaddrinfo" title="정의 주소">¶</a></dt>
<dd><p><em>host</em>/<em>port</em> 인자를 해당 서비스에 연결된 소켓을 만드는 데 필요한 모든 인자가 들어있는 5-튜플의 시퀀스로 변환합니다. <em>host</em>는 도메인 이름, IPv4/v6 주소의 문자열 표현 또는 <code class="docutils literal notranslate"><span class="pre">None``입니다.</span> <span class="pre">*port*\는</span> <span class="pre">``'http'</span></code>와 같은 문자열 서비스 이름, 숫자 포트 번호 또는 <code class="docutils literal notranslate"><span class="pre">None``입니다.</span> <span class="pre">``None</span></code>을 <em>host</em> 와 <em>port</em>의 값으로 전달해서, <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 하부 C API에 전달할 수 있습니다.</p>
<p><em>family</em>, <em>type</em> 및 <em>proto</em> 인자는 선택적으로 지정되어 반환된 주소 목록을 축소합니다. 이 인자 각각에 대한 값으로 0을 전달하면 전체 결과 범위가 선택됩니다. <em>flags</em> 인자는 <code class="docutils literal notranslate"><span class="pre">AI_*</span></code> 상수 중 하나 또는 여러 개일 수 있으며, 결과가 계산되고 반환되는 방식에 영향을 줍니다. 예를 들어, <code class="xref py py-const docutils literal notranslate"><span class="pre">AI_NUMERICHOST</span></code>는 도메인 이름 결정을 비활성화하고, <em>host</em>가 도메인 이름이면 에러를 발생시킵니다.</p>
<p>이 함수는 다음과 같은 구조의 5-튜플의 리스트를 반환합니다:</p>
<p><code class="docutils literal notranslate"><span class="pre">(family,</span> <span class="pre">type,</span> <span class="pre">proto,</span> <span class="pre">canonname,</span> <span class="pre">sockaddr)</span></code></p>
<p>이 튜플에서, <em>family</em>, <em>type</em>, <em>proto</em>는 모두 정수이며 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code></a> 함수로 전달됩니다. <em>canonname</em>은 <code class="xref py py-const docutils literal notranslate"><span class="pre">AI_CANONNAME</span></code>가 <em>flags</em> 인자의 일부일 때 <em>host</em>의 규범적(canonical) 이름을 나타내는 문자열입니다; 그렇지 않으면 <em>canonname</em>가 비어 있습니다. <em>sockaddr</em>은 반환된 <em>family</em>에 따라 형식이 달라지는, 소켓 주소를 설명하는 튜플이며 (<a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a>이면 <code class="docutils literal notranslate"><span class="pre">(address,</span> <span class="pre">port)</span></code> 2-튜플, <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>이면 <code class="docutils literal notranslate"><span class="pre">(address,</span> <span class="pre">port,</span> <span class="pre">flow</span> <span class="pre">info,</span> <span class="pre">scope</span> <span class="pre">id)</span></code> 4-튜플), <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code></a> 메서드로 전달됩니다.</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">host</span></code>, <code class="docutils literal notranslate"><span class="pre">port</span></code>, <code class="docutils literal notranslate"><span class="pre">family</span></code>, <code class="docutils literal notranslate"><span class="pre">type</span></code>, <code class="docutils literal notranslate"><span class="pre">protocol</span></code>을 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.getaddrinfo</span></code>를 발생시킵니다.</p>
<p>다음 예제는 <code class="docutils literal notranslate"><span class="pre">example.org</span></code>의 포트 80으로 가는 가상의 TCP 연결에 대한 주소 정보를 가져옵니다 (IPv6가 활성화되지 않았으면 여러분의 시스템에서는 결과가 다를 수 있습니다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="s2">&quot;example.org&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="n">proto</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_TCP</span><span class="p">)</span>
<span class="go">[(&lt;AddressFamily.AF_INET6: 10&gt;, &lt;SocketType.SOCK_STREAM: 1&gt;,</span>
<span class="go"> 6, &#39;&#39;, (&#39;2606:2800:220:1:248:1893:25c8:1946&#39;, 80, 0, 0)),</span>
<span class="go"> (&lt;AddressFamily.AF_INET: 2&gt;, &lt;SocketType.SOCK_STREAM: 1&gt;,</span>
<span class="go"> 6, &#39;&#39;, (&#39;93.184.216.34&#39;, 80))]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>매개 변수는 이제 키워드 인자를 사용하여 전달할 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>IPv6 멀티캐스트 주소의 경우, 주소를 나타내는 문자열에는 <code class="docutils literal notranslate"><span class="pre">%scope</span></code> 부분이 포함되지 않습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.getfqdn">
<code class="descclassname">socket.</code><code class="descname">getfqdn</code><span class="sig-paren">(</span><span class="optional">[</span><em>name</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.getfqdn" title="정의 주소">¶</a></dt>
<dd><p><em>name</em>의 완전히 정규화된 도메인 이름을 반환합니다. <em>name</em>이 생략되거나 비어 있으면, 지역 호스트로 해석됩니다. 완전히 정규화된 이름을 찾기 위해, <a class="reference internal" href="#socket.gethostbyaddr" title="socket.gethostbyaddr"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyaddr()</span></code></a>에 의해 반환된 호스트 이름이 검사되고, 있다면 그 호스트의 별칭이 뒤따릅니다. 마침표가 포함된 첫 번째 이름이 선택됩니다. 완전히 정규화된 도메인 이름이 없으면, <a class="reference internal" href="#socket.gethostname" title="socket.gethostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostname()</span></code></a>에서 반환된 호스트 이름이 반환됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="socket.gethostbyname">
<code class="descclassname">socket.</code><code class="descname">gethostbyname</code><span class="sig-paren">(</span><em>hostname</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.gethostbyname" title="정의 주소">¶</a></dt>
<dd><p>호스트 이름을 IPv4 주소 형식으로 변환합니다. IPv4 주소는 <code class="docutils literal notranslate"><span class="pre">'100.50.200.5'</span></code>와 같은 문자열로 반환됩니다. 호스트 이름이 IPv4 주소면 변경되지 않고 반환됩니다. 더욱 완전한 인터페이스는 <a class="reference internal" href="#socket.gethostbyname_ex" title="socket.gethostbyname_ex"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyname_ex()</span></code></a>를 참조하십시오. <a class="reference internal" href="#socket.gethostbyname" title="socket.gethostbyname"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyname()</span></code></a>는 IPv6 이름 결정을 지원하지 않으며, IPv4/v6 이중 스택 지원을 위해서는 대신 <a class="reference internal" href="#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>를 사용해야 합니다.</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">hostname</span></code>을 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.gethostbyname</span></code>을 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="socket.gethostbyname_ex">
<code class="descclassname">socket.</code><code class="descname">gethostbyname_ex</code><span class="sig-paren">(</span><em>hostname</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.gethostbyname_ex" title="정의 주소">¶</a></dt>
<dd><p>호스트 이름을 IPv4 주소 형식으로 변환합니다, 확장 인터페이스. 트리플 <code class="docutils literal notranslate"><span class="pre">(hostname,</span> <span class="pre">aliaslist,</span> <span class="pre">ipaddrlist)</span></code>를 반환합니다. 여기서 <em>hostname</em>은 지정된 <em>ip_address</em>에 응답하는 기본 호스트 이름이고, <em>aliaslist</em>는 같은 주소에 대한 대안 호스트 이름의 리스트(비어있을 수 있습니다)이며, <em>ipaddrlist</em>는 같은 호스트의 같은 인터페이스에 대한 IPv4 주소 리스트입니다 (항상 그렇지는 않지만, 종종 단일 주소). <a class="reference internal" href="#socket.gethostbyname_ex" title="socket.gethostbyname_ex"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyname_ex()</span></code></a>는 IPv6 이름 결정을 지원하지 않으며, IPv4/v6 이중 스택 지원을 위해서는 대신 <a class="reference internal" href="#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>를 사용해야 합니다.</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">hostname</span></code>을 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.gethostbyname</span></code>을 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="socket.gethostname">
<code class="descclassname">socket.</code><code class="descname">gethostname</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.gethostname" title="정의 주소">¶</a></dt>
<dd><p>파이썬 인터프리터가 현재 실행 중인 기계의 호스트 명을 포함한 문자열을 반환합니다.</p>
<p class="audit-hook">인자 없이 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.gethostname</span></code>을 발생시킵니다.</p>
<p>참고: <a class="reference internal" href="#socket.gethostname" title="socket.gethostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostname()</span></code></a>은 항상 완전히 정규화된 도메인 이름을 반환하지는 않습니다; 원한다면 <a class="reference internal" href="#socket.getfqdn" title="socket.getfqdn"><code class="xref py py-func docutils literal notranslate"><span class="pre">getfqdn()</span></code></a>을 사용하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="socket.gethostbyaddr">
<code class="descclassname">socket.</code><code class="descname">gethostbyaddr</code><span class="sig-paren">(</span><em>ip_address</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.gethostbyaddr" title="정의 주소">¶</a></dt>
<dd><p>트리플 <code class="docutils literal notranslate"><span class="pre">(hostname,</span> <span class="pre">aliaslist,</span> <span class="pre">ipaddrlist)</span></code>를 반환합니다. 여기서 <em>hostname</em>는 지정된 <em>ip_address</em>에 응답하는 기본 호스트 이름이고, <em>aliaslist</em>는 같은 주소에 대한 대체 호스트 이름의 (비어있을 수 있는) 리스트이며, <em>ipaddrlist</em>는 같은 호스트의 같은 인터페이스에 대한 IPv4/v6 주소 리스트입니다 (대개 단일 주소만 포함합니다). 완전히 정규화된 도메인 이름을 찾으려면, <a class="reference internal" href="#socket.getfqdn" title="socket.getfqdn"><code class="xref py py-func docutils literal notranslate"><span class="pre">getfqdn()</span></code></a> 함수를 사용하십시오. <a class="reference internal" href="#socket.gethostbyaddr" title="socket.gethostbyaddr"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyaddr()</span></code></a>는 IPv4와 IPv6를 모두 지원합니다.</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">ip_address</span></code>를 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.gethostbyaddr</span></code>을 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="socket.getnameinfo">
<code class="descclassname">socket.</code><code class="descname">getnameinfo</code><span class="sig-paren">(</span><em>sockaddr</em>, <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.getnameinfo" title="정의 주소">¶</a></dt>
<dd><p>소켓 주소 <em>sockaddr</em>를 2-튜플 <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code>로 변환합니다. <em>flags</em>의 설정에 따라, 결과의 <em>host</em>에 완전히 정규화된 도메인 이름이나 숫자 주소 표현이 포함될 수 있습니다. 마찬가지로, <em>port</em>에는 문자열 포트 이름이나 숫자 포트 번호가 포함될 수 있습니다.</p>
<p>IPv6 주소의 경우, <em>sockaddr</em>에 의미 있는 <em>scopeid</em>가 있으면 <code class="docutils literal notranslate"><span class="pre">%scope</span></code>를 host 부분에 덧붙입니다. 보통 이것은 멀티캐스트 주소에서 일어납니다.</p>
<p><em>flags</em>에 대한 자세한 내용은 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/getnameinfo(3)">getnameinfo(3)</a></em>을 참조하십시오.</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">sockaddr</span></code>을 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.getnameinfo</span></code>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="socket.getprotobyname">
<code class="descclassname">socket.</code><code class="descname">getprotobyname</code><span class="sig-paren">(</span><em>protocolname</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.getprotobyname" title="정의 주소">¶</a></dt>
<dd><p>인터넷 프로토콜 이름(예를 들어, <code class="docutils literal notranslate"><span class="pre">'icmp'</span></code>)을 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code></a> 함수의 (선택적인) 세 번째 인자로 전달하기에 적합한 상수로 변환합니다. 이것은 일반적으로 &quot;원시&quot; 모드(<a class="reference internal" href="#socket.SOCK_RAW" title="socket.SOCK_RAW"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_RAW</span></code></a>)로 열린 소켓에만 필요합니다; 일반 소켓 모드에서는, 프로토콜이 생략되거나 0이면 올바른 프로토콜이 자동으로 선택됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="socket.getservbyname">
<code class="descclassname">socket.</code><code class="descname">getservbyname</code><span class="sig-paren">(</span><em>servicename</em><span class="optional">[</span>, <em>protocolname</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.getservbyname" title="정의 주소">¶</a></dt>
<dd><p>인터넷 서비스 이름과 프로토콜 이름을 해당 서비스의 포트 번호로 변환합니다. 선택적 프로토콜 이름은, 주어진다면, <code class="docutils literal notranslate"><span class="pre">'tcp'</span></code> 나 <code class="docutils literal notranslate"><span class="pre">'udp'</span></code> 여야 합니다, 그렇지 않으면 모든 프로토콜과 일치합니다.</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">servicename</span></code>, <code class="docutils literal notranslate"><span class="pre">protocolname</span></code>을 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.getservbyname</span></code>을 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="socket.getservbyport">
<code class="descclassname">socket.</code><code class="descname">getservbyport</code><span class="sig-paren">(</span><em>port</em><span class="optional">[</span>, <em>protocolname</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.getservbyport" title="정의 주소">¶</a></dt>
<dd><p>인터넷 포트 번호와 프로토콜 이름을 해당 서비스의 서비스 이름으로 변환합니다. 선택적 프로토콜 이름은, 주어진다면, <code class="docutils literal notranslate"><span class="pre">'tcp'</span></code> 나 <code class="docutils literal notranslate"><span class="pre">'udp'</span></code> 여야 합니다, 그렇지 않으면 모든 프로토콜과 일치합니다.</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">port</span></code>, <code class="docutils literal notranslate"><span class="pre">protocolname</span></code>을 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.getservbyport</span></code>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="socket.ntohl">
<code class="descclassname">socket.</code><code class="descname">ntohl</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.ntohl" title="정의 주소">¶</a></dt>
<dd><p>32비트 양의 정수를 네트워크 바이트 순서에서 호스트 바이트 순서로 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 같은 시스템에서, 이것은 아무 일도 하지 않습니다; 그렇지 않으면, 4바이트 스와프 연산을 수행합니다.</p>
</dd></dl>

<dl class="function">
<dt id="socket.ntohs">
<code class="descclassname">socket.</code><code class="descname">ntohs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.ntohs" title="정의 주소">¶</a></dt>
<dd><p>16비트 양의 정수를 네트워크 바이트 순서에서 호스트 바이트 순서로 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 같은 시스템에서, 이것은 아무 일도 하지 않습니다; 그렇지 않으면, 2바이트 스와프 연산을 수행합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.7부터 폐지: </span><em>x</em>가 16비트 부호 없는 정수에 맞지 않지만, 양의 C int에 맞으면, 16비트 부호 없는 정수로 자동 절단됩니다. 이 자동 절단 기능은 폐지되었으며, 미래 버전의 파이썬에서는 예외가 발생할 것입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.htonl">
<code class="descclassname">socket.</code><code class="descname">htonl</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.htonl" title="정의 주소">¶</a></dt>
<dd><p>32비트 양의 정수를 호스트 바이트 순서에서 네트워크 바이트 순서로 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 같은 시스템에서, 이것은 아무 일도 하지 않습니다; 그렇지 않으면, 4바이트 스와프 연산을 수행합니다.</p>
</dd></dl>

<dl class="function">
<dt id="socket.htons">
<code class="descclassname">socket.</code><code class="descname">htons</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.htons" title="정의 주소">¶</a></dt>
<dd><p>16비트 양의 정수를 호스트 바이트 순서에서 네트워크 바이트 순서로 변환합니다. 호스트 바이트 순서가 네트워크 바이트 순서와 같은 시스템에서, 이것은 아무 일도 하지 않습니다; 그렇지 않으면, 2바이트 스와프 연산을 수행합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.7부터 폐지: </span><em>x</em>가 16비트 부호 없는 정수에 맞지 않지만, 양의 C int에 맞으면, 16비트 부호 없는 정수로 자동 절단됩니다. 이 자동 절단 기능은 폐지되었으며, 미래 버전의 파이썬에서는 예외가 발생할 것입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.inet_aton">
<code class="descclassname">socket.</code><code class="descname">inet_aton</code><span class="sig-paren">(</span><em>ip_string</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.inet_aton" title="정의 주소">¶</a></dt>
<dd><p>IPv4 주소를 점 분리 쿼드 문자열 형식(예를 들어, '123.45.67.89')에서 길이가 4자인 바이트열 객체로 32비트 압축 바이너리 형식으로 변환합니다. 이 함수는 표준 C 라이브러리를 사용하고 <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">in_addr</span></code> 형(이 함수가 반환하는 32비트 압축 바이너리의 C형입니다)의 객체를 요구하는 프로그램과 대화할 때 유용합니다.</p>
<p><a class="reference internal" href="#socket.inet_aton" title="socket.inet_aton"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_aton()</span></code></a>는 3점 미만의 문자열도 허용합니다; 자세한 내용은 유닉스 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/inet(3)">inet(3)</a></em>을 참조하십시오.</p>
<p>이 함수에 전달된 IPv4 주소 문자열이 유효하지 않으면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다. 정확히 무엇이 유효한지는 <code class="xref c c-func docutils literal notranslate"><span class="pre">inet_aton()</span></code>의 하부 C 구현에 따라 달라짐에 유의하십시오.</p>
<p><a class="reference internal" href="#socket.inet_aton" title="socket.inet_aton"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_aton()</span></code></a>은 IPv6를 지원하지 않으며, IPv4/v6 이중 스택 지원을 위해서는 대신 <a class="reference internal" href="#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_pton()</span></code></a>를 사용해야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="socket.inet_ntoa">
<code class="descclassname">socket.</code><code class="descname">inet_ntoa</code><span class="sig-paren">(</span><em>packed_ip</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.inet_ntoa" title="정의 주소">¶</a></dt>
<dd><p>32비트 압축 IPv4 주소(길이가 4바이트인 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열 객체</span></a>)를 표준 점선 분리 쿼드 문자열 표현(예를 들어, '123.45.67.89')으로 변환합니다. 이 함수는 표준 C 라이브러리를 사용하고 <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">in_addr</span></code> 형(이 함수가 인자로 받아들이는 32비트 압축 바이너리 데이터의 C형입니다)의 객체를 요구하는 프로그램과 대화할 때 유용합니다.</p>
<p>이 함수에 전달된 바이트 시퀀스가 정확히 4바이트 길이가 아니면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다. <a class="reference internal" href="#socket.inet_ntoa" title="socket.inet_ntoa"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_ntoa()</span></code></a>는 IPv6를 지원하지 않으며, IPv4/v6 이중 스택 지원을 위해서는 대신 <a class="reference internal" href="#socket.inet_ntop" title="socket.inet_ntop"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_ntop()</span></code></a>를 사용해야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이제 쓰기 가능한 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.inet_pton">
<code class="descclassname">socket.</code><code class="descname">inet_pton</code><span class="sig-paren">(</span><em>address_family</em>, <em>ip_string</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.inet_pton" title="정의 주소">¶</a></dt>
<dd><p>패밀리 특정 문자열 형식의 IP 주소를 압축 바이너리 형식으로 변환합니다. <a class="reference internal" href="#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_pton()</span></code></a>는 라이브러리나 네트워크 프로토콜이 <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">in_addr</span></code> 형(<a class="reference internal" href="#socket.inet_aton" title="socket.inet_aton"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_aton()</span></code></a>과 유사)이나 <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">in6_addr</span></code> 형의 객체로 호출할 때 유용합니다.</p>
<p><em>address_family</em>에 대해 지원되는 값은 현재 <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a>과 <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>입니다. IP 주소 문자열 <em>ip_string</em>가 유효하지 않으면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다. 정확히 무엇이 유효한지는 <em>address_family</em>의 값과 <code class="xref c c-func docutils literal notranslate"><span class="pre">inet_pton()</span></code>의 하부 구현에 따라 달라집니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스(모든 플랫폼이 아닐 수도 있음), 윈도우.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>윈도우 지원이 추가되었습니다</p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.inet_ntop">
<code class="descclassname">socket.</code><code class="descname">inet_ntop</code><span class="sig-paren">(</span><em>address_family</em>, <em>packed_ip</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.inet_ntop" title="정의 주소">¶</a></dt>
<dd><p>압축 IP 주소(일정 길이의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열 객체</span></a>)를 그것의 표준 패밀리 특정 문자열 표현(예를 들어, <code class="docutils literal notranslate"><span class="pre">'7.10.0.5'</span></code> 나 <code class="docutils literal notranslate"><span class="pre">'5aef:2b::8'</span></code>)으로 변환합니다. <a class="reference internal" href="#socket.inet_ntop" title="socket.inet_ntop"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_ntop()</span></code></a>는 라이브러리나 네트워크 프로토콜이 <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">in_addr</span></code> 형(<a class="reference internal" href="#socket.inet_ntoa" title="socket.inet_ntoa"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_ntoa()</span></code></a>와 유사)이나 <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">in6_addr</span></code> 형의 객체를 반환할 때 유용합니다.</p>
<p><em>address_family</em>에 대해 지원되는 값은 현재 <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a>과 <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>입니다. 바이트열 객체 <em>packed_ip</em>가 지정된 주소 패밀리의 올바른 길이가 아니면, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. <a class="reference internal" href="#socket.inet_ntop" title="socket.inet_ntop"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_ntop()</span></code></a> 호출로 인한 에러에는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스(모든 플랫폼이 아닐 수도 있음), 윈도우.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>윈도우 지원이 추가되었습니다</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이제 쓰기 가능한 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.CMSG_LEN">
<code class="descclassname">socket.</code><code class="descname">CMSG_LEN</code><span class="sig-paren">(</span><em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.CMSG_LEN" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>length</em>의 연관된 데이터가 있는 보조(ancillary) 데이터 항목의 (후행 패딩을 제외한) 총 길이를 반환합니다. 이 값은 <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a>가 보조 데이터의 단일 항목을 수신하기 위한 버퍼 크기로 종종 사용될 수 있지만, <span class="target" id="index-31"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3542.html"><strong>RFC 3542</strong></a>는 이식성 있는 응용 프로그램에서 <a class="reference internal" href="#socket.CMSG_SPACE" title="socket.CMSG_SPACE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CMSG_SPACE()</span></code></a>를 사용하도록 요구하는데, 항목이 버퍼의 마지막 부분일 때도 패딩을 위한 공간을 포함합니다. <em>length</em>가 허용되는 값 범위를 벗어나면 <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>를 발생시킵니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 대부분 유닉스 플랫폼, 다른 것들도 가능합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.CMSG_SPACE">
<code class="descclassname">socket.</code><code class="descname">CMSG_SPACE</code><span class="sig-paren">(</span><em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.CMSG_SPACE" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>length</em>의 연관된 데이터가 있는 보조(ancillary) 데이터 항목을 수신하기 위해 <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a>에 필요한 버퍼 크기를 반환하는데, 후행 패딩을 포함합니다. 여러 항목을 수신하는 데 필요한 버퍼 공간은 연관된 데이터 길이에 대한 <a class="reference internal" href="#socket.CMSG_SPACE" title="socket.CMSG_SPACE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CMSG_SPACE()</span></code></a> 값의 합입니다. <em>length</em>가 허용되는 값 범위를 벗어나면 <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>를 발생시킵니다.</p>
<p>일부 시스템에서는 이 함수를 제공하지 않으면서 보조(ancillary) 데이터를 지원할 수 있음에 유의하십시오. 또한, 이 함수의 결과를 사용하여 버퍼 크기를 설정하면 수신할 수 있는 보조 데이터의 양이 정확하게 제한되지 않을 수 있음에도 유의하십시오. 추가 데이터가 패딩 영역에 들어갈 수 있기 때문입니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 대부분 유닉스 플랫폼, 다른 것들도 가능합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.getdefaulttimeout">
<code class="descclassname">socket.</code><code class="descname">getdefaulttimeout</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.getdefaulttimeout" title="정의 주소">¶</a></dt>
<dd><p>새로운 소켓 객체의 기본 시간제한을 초 단위로 (float) 반환합니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> 값은 새 소켓 객체가 시간제한이 없음을 나타냅니다. 소켓 모듈을 처음 임포트 할 때 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다.</p>
</dd></dl>

<dl class="function">
<dt id="socket.setdefaulttimeout">
<code class="descclassname">socket.</code><code class="descname">setdefaulttimeout</code><span class="sig-paren">(</span><em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.setdefaulttimeout" title="정의 주소">¶</a></dt>
<dd><p>새 소켓 객체의 기본 시간제한을 초 단위로 (float) 설정합니다. 소켓 모듈을 처음 임포트 할 때 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. 가능한 값과 해당 의미는 <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a>을 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="socket.sethostname">
<code class="descclassname">socket.</code><code class="descname">sethostname</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.sethostname" title="정의 주소">¶</a></dt>
<dd><p>기계의 호스트 명을 <em>name</em>으로 설정합니다. 충분한 권한이 없으면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다.</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">name</span></code>을 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.sethostname</span></code>을 발생시킵니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.if_nameindex">
<code class="descclassname">socket.</code><code class="descname">if_nameindex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.if_nameindex" title="정의 주소">¶</a></dt>
<dd><p>네트워크 인터페이스 정보 (인덱스 정수, 이름 문자열) 튜플의 리스트를 반환합니다. 시스템 호출이 실패하면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스, 윈도우.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>윈도우 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.if_nametoindex">
<code class="descclassname">socket.</code><code class="descname">if_nametoindex</code><span class="sig-paren">(</span><em>if_name</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.if_nametoindex" title="정의 주소">¶</a></dt>
<dd><p>인터페이스 이름에 대응하는 네트워크 인터페이스 인덱스 번호를 반환합니다. 주어진 이름을 가진 인터페이스가 없으면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스, 윈도우.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>윈도우 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="socket.if_indextoname">
<code class="descclassname">socket.</code><code class="descname">if_indextoname</code><span class="sig-paren">(</span><em>if_index</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.if_indextoname" title="정의 주소">¶</a></dt>
<dd><p>인터페이스 인덱스 번호에 해당하는 네트워크 인터페이스 이름을 반환합니다. 지정된 인덱스의 인터페이스가 없으면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스, 윈도우.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>윈도우 지원이 추가되었습니다.</p>
</div>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="socket-objects">
<span id="id1"></span><h2>소켓 객체<a class="headerlink" href="#socket-objects" title="제목 주소">¶</a></h2>
<p>소켓 객체에는 다음과 같은 메서드가 있습니다. <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a>를 제외하고, 이것들은 소켓에 적용할 수 있는 유닉스 시스템 호출에 해당합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">컨텍스트 관리자</span></a> 프로토콜 지원이 추가되었습니다. 컨텍스트 관리자를 빠져나가는 것은 <a class="reference internal" href="#socket.close" title="socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>를 호출하는 것과 동등합니다.</p>
</div>
<dl class="method">
<dt id="socket.socket.accept">
<code class="descclassname">socket.</code><code class="descname">accept</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.accept" title="정의 주소">¶</a></dt>
<dd><p>연결을 받아들입니다. 소켓은 주소에 바인드되어 연결을 리스닝하고 있어야 합니다. 반환 값은 <code class="docutils literal notranslate"><span class="pre">(conn,</span> <span class="pre">address)</span></code> 쌍입니다. 여기서 <em>conn</em>는 연결에서 데이터를 보내고 받을 수 있는 <em>새로운</em> 소켓 객체이고, <em>address</em>는 연결의 다른 끝에 있는 소켓에 바인드 된 주소입니다.</p>
<p>새로 만들어진 소켓은 <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">상속 불가능</span></a>합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>소켓은 이제 상속 불가능합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 메서드는 이제 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 예외를 발생시키는 대신 시스템 호출을 재시도합니다 (이유는 <span class="target" id="index-32"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하십시오).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.bind">
<code class="descclassname">socket.</code><code class="descname">bind</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.bind" title="정의 주소">¶</a></dt>
<dd><p>소켓을 <em>address</em>에 바인드 합니다. 소켓은 이미 바인드 되어 있으면 안 됩니다. (<em>address</em>의 형식은 주소 패밀리에 따라 다릅니다 --- 위를 보십시오.)</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">address</span></code>을 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.bind</span></code>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.close">
<code class="descclassname">socket.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.close" title="정의 주소">¶</a></dt>
<dd><p>소켓을 닫힌 상태로 표시합니다. 하부 시스템 자원(예를 들어, 파일 기술자)도 <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a>로 만든 모든 파일 객체가 닫힐 때 닫힙니다. 일단 닫히면, 소켓 객체에 대한 이후의 모든 연산이 실패합니다. 원격 끝은 더는 데이터를 수신하지 않게 됩니다 (계류 중인 데이터가 플러시 된 후에).</p>
<p>소켓은 가비지 수집될 때 자동으로 닫히지만, 명시적으로 <a class="reference internal" href="#socket.close" title="socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>하거나 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문을 사용하는 것이 좋습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>하부 <code class="xref c c-func docutils literal notranslate"><span class="pre">close()</span></code> 호출이 수행될 때 에러가 발생하면 이제 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#socket.close" title="socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>는 연결과 관련된 자원을 해제하지만, 반드시 연결을 즉시 닫을 필요는 없습니다. 적시에 연결을 닫으려면, <a class="reference internal" href="#socket.close" title="socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 전에 <a class="reference internal" href="#socket.socket.shutdown" title="socket.socket.shutdown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code></a>을 호출하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.connect">
<code class="descclassname">socket.</code><code class="descname">connect</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.connect" title="정의 주소">¶</a></dt>
<dd><p><em>address</em>에 있는 원격 소켓에 연결합니다. (<em>address</em>의 형식은 주소 패밀리에 따라 다릅니다 --- 위를 보십시오.)</p>
<p>시그널로 연결이 인터럽트 되면, 메서드는 연결이 완료될 때까지 대기하거나, 시그널 처리기가 예외를 발생시키지 않고 소켓이 블로킹하거나 시간제한이 있으면 <a class="reference internal" href="#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.timeout</span></code></a>을 발생시킵니다. 비 블로킹 소켓의 경우, 이 메서드는 시그널로 연결이 인터럽트 되면 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 예외(또는 시그널 처리기에서 발생한 예외)를 발생시킵니다.</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">address</span></code>를 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.connect</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>연결이 시그널에 의해 인터럽트 되고, 시그널 처리기가 예외를 발생시키지 않고, 소켓이 블로킹하거나 시간제한을 가지면, 이 메서드는 이제 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 예외를 발생시키는 대신 연결이 완료될 때까지 대기합니다 (이유는 <span class="target" id="index-33"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하십시오).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.connect_ex">
<code class="descclassname">socket.</code><code class="descname">connect_ex</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.connect_ex" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">connect(address)</span></code>와 비슷하지만, C 수준의 <code class="xref c c-func docutils literal notranslate"><span class="pre">connect()</span></code> 호출로 반환된 에러에 대한 예외를 발생시키는 대신 에러 표시기를 반환합니다 (&quot;호스트를 찾을 수 없음&quot;과 같은 다른 문제는 여전히 예외를 발생시킬 수 있습니다). 연산이 성공하면 에러 표시기는 <code class="docutils literal notranslate"><span class="pre">0</span></code>이고, 그렇지 않으면 <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code> 변수의 값입니다. 예를 들어 비동기 연결을 지원하는 데 유용합니다.</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">address</span></code>를 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.connect</span></code>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.detach">
<code class="descclassname">socket.</code><code class="descname">detach</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.detach" title="정의 주소">¶</a></dt>
<dd><p>하부 파일 기술자를 실제로 닫지 않으면서 소켓 객체를 닫힌 상태로 만듭니다. 파일 기술자가 반환되고, 다른 용도로 재사용 될 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.dup">
<code class="descclassname">socket.</code><code class="descname">dup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.dup" title="정의 주소">¶</a></dt>
<dd><p>소켓을 복제합니다.</p>
<p>새로 만들어진 소켓은 <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">상속 불가능</span></a>합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>소켓은 이제 상속 불가능합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.fileno">
<code class="descclassname">socket.</code><code class="descname">fileno</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.fileno" title="정의 주소">¶</a></dt>
<dd><p>소켓의 파일 기술자(작은 정수)를 반환하거나, 실패하면 -1을 반환합니다. 이것은 <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select.select()</span></code></a>에서 유용합니다.</p>
<p>윈도우에서, 이 메서드가 돌려주는 작은 정수는 파일 기술자를 사용할 수 있는 곳(가령 <a class="reference internal" href="os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fdopen()</span></code></a>)에 사용할 수 없습니다. 유닉스에는 이러한 제한이 없습니다.</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.get_inheritable">
<code class="descclassname">socket.</code><code class="descname">get_inheritable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.get_inheritable" title="정의 주소">¶</a></dt>
<dd><p>소켓의 파일 기술자나 소켓 핸들의 <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">상속 가능 플래그</span></a>를 가져옵니다: 소켓이 자식 프로세스에서 상속될 수 있으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.getpeername">
<code class="descclassname">socket.</code><code class="descname">getpeername</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.getpeername" title="정의 주소">¶</a></dt>
<dd><p>소켓이 연결된 원격 주소를 반환합니다. 이것은 예를 들어, 원격 IPv4/v6 소켓의 포트 번호를 찾는 데 유용합니다. (반환되는 주소의 형식은 주소 패밀리에 따라 다릅니다 --- 위를 보십시오.) 일부 시스템에서는 이 함수가 지원되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.getsockname">
<code class="descclassname">socket.</code><code class="descname">getsockname</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.getsockname" title="정의 주소">¶</a></dt>
<dd><p>소켓 자신의 주소를 반환합니다. 이것은 예를 들어 IPv4/v6 소켓의 포트 번호를 찾는 데 유용합니다. (반환되는 주소의 형식은 주소 패밀리에 따라 다릅니다 --- 위를 보십시오.)</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.getsockopt">
<code class="descclassname">socket.</code><code class="descname">getsockopt</code><span class="sig-paren">(</span><em>level</em>, <em>optname</em><span class="optional">[</span>, <em>buflen</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.getsockopt" title="정의 주소">¶</a></dt>
<dd><p>주어진 소켓 옵션의 값을 반환합니다 (유닉스 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/getsockopt(2)">getsockopt(2)</a></em>를 보십시오). 필요한 기호 상수(<code class="xref py py-const docutils literal notranslate"><span class="pre">SO_*</span></code> 등)는 이 모듈에서 정의됩니다. <em>buflen</em>이 없으면, 정수 옵션을 가정하고 해당 정숫값이 함수에서 반환됩니다. <em>buflen</em>이 있으면, 옵션을 수신하는 데 사용되는 버퍼의 최대 길이를 지정하고, 이 버퍼가 바이트열 객체로 반환됩니다. 버퍼의 내용을 디코딩하는 것은 호출자의 책임입니다 (바이트열로 인코딩된 C 구조체를 디코딩하는 방법은 선택적 내장 모듈 <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a>를 참조하십시오).</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.getblocking">
<code class="descclassname">socket.</code><code class="descname">getblocking</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.getblocking" title="정의 주소">¶</a></dt>
<dd><p>소켓이 블로킹 모드면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환하고, 비 블로킹이면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
<p>이것은 <code class="docutils literal notranslate"><span class="pre">socket.gettimeout()</span> <span class="pre">==</span> <span class="pre">0</span></code>를 검사하는 것과 동등합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.gettimeout">
<code class="descclassname">socket.</code><code class="descname">gettimeout</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.gettimeout" title="정의 주소">¶</a></dt>
<dd><p>소켓 연산에 관련한 시간제한을 초(float)로 돌려줍니다. 시간제한이 설정되어 있지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>를 돌려줍니다. 이것은 <a class="reference internal" href="#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setblocking()</span></code></a> 이나 <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a>에 대한 마지막 호출을 반영합니다.</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.ioctl">
<code class="descclassname">socket.</code><code class="descname">ioctl</code><span class="sig-paren">(</span><em>control</em>, <em>option</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.ioctl" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">플랫폼</dt>
<dd class="field-odd"><p>윈도우</p>
</dd>
</dl>
<p><a class="reference internal" href="#socket.socket.ioctl" title="socket.socket.ioctl"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ioctl()</span></code></a> 메서드는 WSAIoctl 시스템 인터페이스에 대한 제한된 인터페이스입니다. 자세한 내용은 <a class="reference external" href="https://msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx">Win32 설명서</a>를 참조하십시오.</p>
<p>다른 플랫폼에서는, 범용 <a class="reference internal" href="fcntl.html#fcntl.fcntl" title="fcntl.fcntl"><code class="xref py py-func docutils literal notranslate"><span class="pre">fcntl.fcntl()</span></code></a> 과 <a class="reference internal" href="fcntl.html#fcntl.ioctl" title="fcntl.ioctl"><code class="xref py py-func docutils literal notranslate"><span class="pre">fcntl.ioctl()</span></code></a> 함수를 사용할 수 있습니다; 첫 번째 인자로 소켓 객체를 받아들입니다.</p>
<p>현재 다음 제어 코드만 지원됩니다: <code class="docutils literal notranslate"><span class="pre">SIO_RCVALL</span></code>, <code class="docutils literal notranslate"><span class="pre">SIO_KEEPALIVE_VALS</span></code> 및 <code class="docutils literal notranslate"><span class="pre">SIO_LOOPBACK_FAST_PATH</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="docutils literal notranslate"><span class="pre">SIO_LOOPBACK_FAST_PATH</span></code>가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.listen">
<code class="descclassname">socket.</code><code class="descname">listen</code><span class="sig-paren">(</span><span class="optional">[</span><em>backlog</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.listen" title="정의 주소">¶</a></dt>
<dd><p>서버가 연결을 수락하도록 합니다. <em>backlog</em>가 지정되면, 0 이상이어야 합니다 (더 낮으면 0으로 설정됩니다); 새로운 연결을 거부하기 전에 시스템이 허락할 수락되지 않은 연결 수를 지정합니다. 지정하지 않으면, 기본값으로 적당한 값이 선택됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이제 <em>backlog</em> 매개 변수가 선택적입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.makefile">
<code class="descclassname">socket.</code><code class="descname">makefile</code><span class="sig-paren">(</span><em>mode='r'</em>, <em>buffering=None</em>, <em>*</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.makefile" title="정의 주소">¶</a></dt>
<dd><p id="index-6">소켓과 결합한 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a>를 돌려줍니다. 정확한 반환형은 <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a>에 주어진 인자에 따라 다릅니다. 이 인자는 내장 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 함수와 같은 방식으로 해석됩니다. 단, 지원되는 <em>mode</em> 값은 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> (기본값), <code class="docutils literal notranslate"><span class="pre">'w'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'b'</span></code> 뿐입니다.</p>
<p>소켓은 블로킹 모드 여야 합니다; 시간제한을 가질 수 있지만, 시간 초과가 발생하면 파일 객체의 내부 버퍼가 일관성없는 상태로 끝날 수 있습니다.</p>
<p><a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a>에 의해 반환된 파일 객체를 닫는 것은, 다른 모든 파일 객체가 닫혔고 소켓 객체에서 <a class="reference internal" href="#socket.close" title="socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.close()</span></code></a>가 호출되었지 않은 한 원래 소켓을 닫지는 않습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>윈도우에서, <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a>로 만든 파일류 객체는 파일 기술자가 있는 파일 객체가 필요한 곳에서는 사용할 수 없습니다, 가령 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess.Popen()</span></code></a>의 stream 인자.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.recv">
<code class="descclassname">socket.</code><code class="descname">recv</code><span class="sig-paren">(</span><em>bufsize</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recv" title="정의 주소">¶</a></dt>
<dd><p>소켓에서 데이터를 수신합니다. 반환 값은 수신된 데이터를 나타내는 바이트열 객체입니다. 한 번에 수신할 수 있는 최대 데이터양은 <em>bufsize</em>에 의해 지정됩니다. 선택적 인자 <em>flags</em>의 의미는 유닉스 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/recv(2)">recv(2)</a></em>를 보십시오; 기본값은 0입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>하드웨어와 네트워크 현실과 가장 잘 일치하려면, <em>bufsize</em>의 값은 2의 비교적 작은 거듭제곱이어야 합니다, 예를 들어 4096.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 메서드는 이제 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 예외를 발생시키는 대신 시스템 호출을 재시도합니다 (이유는 <span class="target" id="index-34"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하십시오).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.recvfrom">
<code class="descclassname">socket.</code><code class="descname">recvfrom</code><span class="sig-paren">(</span><em>bufsize</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recvfrom" title="정의 주소">¶</a></dt>
<dd><p>소켓에서 데이터를 수신합니다. 반환 값은 <code class="docutils literal notranslate"><span class="pre">(bytes,</span> <span class="pre">address)</span></code> 쌍입니다. 여기서 <em>bytes</em>는 수신한 데이터를 나타내는 바이트열 객체이고, <em>address</em>는 데이터를 보내는 소켓의 주소입니다. 선택적 인자 <em>flags</em>의 의미는 유닉스 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/recv(2)">recv(2)</a></em>를 보십시오; 기본값은 0입니다. (<em>address</em>의 형식은 주소 패밀리에 따라 다릅니다 --- 위를 보십시오.)</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 메서드는 이제 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 예외를 발생시키는 대신 시스템 호출을 재시도합니다 (이유는 <span class="target" id="index-35"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하십시오).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>멀티캐스트 IPv6 주소의 경우, <em>address</em>의 첫 번째 항목에는 <code class="docutils literal notranslate"><span class="pre">%scope</span></code> 부분이 더는 포함되지 않습니다. 전체 IPv6 주소를 얻으려면 <a class="reference internal" href="#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getnameinfo()</span></code></a>를 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.recvmsg">
<code class="descclassname">socket.</code><code class="descname">recvmsg</code><span class="sig-paren">(</span><em>bufsize</em><span class="optional">[</span>, <em>ancbufsize</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recvmsg" title="정의 주소">¶</a></dt>
<dd><p>일반 데이터(최대 <em>bufsize</em> 바이트)와 보조(ancillary) 데이터를 소켓에서 수신합니다. <em>ancbufsize</em> 인자는 보조 데이터 수신에 사용되는 내부 버퍼의 크기를 바이트 단위로 설정합니다; 기본값은 0이며 보조 데이터가 수신되지 않는다는 뜻입니다. 보조 데이터를 위한 적절한 버퍼 크기는 <a class="reference internal" href="#socket.CMSG_SPACE" title="socket.CMSG_SPACE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CMSG_SPACE()</span></code></a> 나 <a class="reference internal" href="#socket.CMSG_LEN" title="socket.CMSG_LEN"><code class="xref py py-func docutils literal notranslate"><span class="pre">CMSG_LEN()</span></code></a>를 사용하여 계산할 수 있으며, 버퍼에 들어가지 않는 항목은 잘리거나 삭제될 수 있습니다. <em>flags</em> 인자의 기본값은 0이고 <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a>와 같은 의미입니다.</p>
<p>반환 값은 4-튜플입니다: <code class="docutils literal notranslate"><span class="pre">(data,</span> <span class="pre">ancdata,</span> <span class="pre">msg_flags,</span> <span class="pre">address)</span></code>. <em>data</em> 항목은 일반 데이터를 담은 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체입니다. <em>ancdata</em> 항목은 수신된 보조 데이터(제어 메시지)를 나타내는 0개 이상의 튜플 <code class="docutils literal notranslate"><span class="pre">(cmsg_level,</span> <span class="pre">cmsg_type,</span> <span class="pre">cmsg_data)</span></code>의 리스트입니다: <em>cmsg_level</em> 와 <em>cmsg_type</em>는 각각 프로토콜 수준과 프로토콜 특정 형을 지정하는 정수이고, <em>cmsg_data</em>는 연결된 데이터를 담은 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체입니다. <em>msg_flags</em> 항목은 수신된 메시지의 조건을 나타내는 다양한 플래그의 비트별 OR입니다; 자세한 내용은 시스템 설명서를 참조하십시오. 수신 소켓이 연결되어있지 않으면, <em>address</em>는 송신 소켓의 주소입니다, (사용 가능하다면); 그렇지 않으면 값은 지정되지 않습니다.</p>
<p>일부 시스템에서는, <a class="reference internal" href="#socket.socket.sendmsg" title="socket.socket.sendmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmsg()</span></code></a>와 <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a>를 사용하여 <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> 소켓을 통해 프로세스 간에 파일 기술자를 전달할 수 있습니다. 이 기능을 사용하면 (<a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a> 소켓으로 제한되는 경우가 많습니다), <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a>는 보조 데이터에서 <code class="docutils literal notranslate"><span class="pre">(socket.SOL_SOCKET,</span> <span class="pre">socket.SCM_RIGHTS,</span> <span class="pre">fds)</span></code> 형식의 항목을 반환합니다. 여기서 <em>fds</em>는 새 파일 기술자를 네이티브 C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> 형의 바이너리 배열로 나타내는 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체입니다. <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a>가 시스템 호출이 반환된 후에 예외를 발생시키면, 먼저 이 메커니즘을 통해 수신된 모든 파일 기술자를 닫으려고 시도합니다.</p>
<p>일부 시스템은 부분적으로만 수신된 보조 데이터 항목의 절단 길이를 나타내지 않습니다. 항목이 버퍼의 끝을 넘어 확장된 것처럼 보이면, <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a>는 <a class="reference internal" href="exceptions.html#RuntimeWarning" title="RuntimeWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeWarning</span></code></a>를 발생시키고, 관련 데이터의 시작 전에 절단되지 않은 버퍼 내에 있는 부분을 반환합니다.</p>
<p><code class="xref py py-const docutils literal notranslate"><span class="pre">SCM_RIGHTS</span></code> 메커니즘을 지원하는 시스템에서, 다음 함수는 최대 <em>maxfds</em> 파일 기술자를 수신하여, 메시지 데이터와 기술자를 담은 리스트를 반환합니다 (관련 없는 수신되는 제어 메시지와 같은 예기치 않은 조건은 무시하면서). <a class="reference internal" href="#socket.socket.sendmsg" title="socket.socket.sendmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmsg()</span></code></a>를 참조하십시오.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">array</span>

<span class="k">def</span> <span class="nf">recv_fds</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msglen</span><span class="p">,</span> <span class="n">maxfds</span><span class="p">):</span>
    <span class="n">fds</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>   <span class="c1"># int의 배열</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">ancdata</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recvmsg</span><span class="p">(</span><span class="n">msglen</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">CMSG_LEN</span><span class="p">(</span><span class="n">maxfds</span> <span class="o">*</span> <span class="n">fds</span><span class="o">.</span><span class="n">itemsize</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">cmsg_level</span><span class="p">,</span> <span class="n">cmsg_type</span><span class="p">,</span> <span class="n">cmsg_data</span> <span class="ow">in</span> <span class="n">ancdata</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cmsg_level</span> <span class="o">==</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span> <span class="ow">and</span> <span class="n">cmsg_type</span> <span class="o">==</span> <span class="n">socket</span><span class="o">.</span><span class="n">SCM_RIGHTS</span><span class="p">):</span>
            <span class="c1"># 마지막에 잘린 정수를 무시하면서, 데이터를 추가합니다.</span>
            <span class="n">fds</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">cmsg_data</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">cmsg_data</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cmsg_data</span><span class="p">)</span> <span class="o">%</span> <span class="n">fds</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">msg</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span>
</pre></div>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 대부분 유닉스 플랫폼, 다른 것들도 가능합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 메서드는 이제 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 예외를 발생시키는 대신 시스템 호출을 재시도합니다 (이유는 <span class="target" id="index-36"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하십시오).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.recvmsg_into">
<code class="descclassname">socket.</code><code class="descname">recvmsg_into</code><span class="sig-paren">(</span><em>buffers</em><span class="optional">[</span>, <em>ancbufsize</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recvmsg_into" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a>처럼 동작해서, 일반 데이터와 보조 데이터를 소켓에서 수신하지만, 새로운 바이트열 객체를 반환하는 대신 일반 데이터를 일련의 버퍼로 분산시킵니다. <em>buffers</em> 인자는 쓰기 가능한 버퍼(예를 들어, <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 객체)를 내보내는 객체의 이터러블이어야 합니다; 이것들은 모두 기록되었거나 버퍼가 더는 없을 때까지 일반 데이터의 연속적인 덩어리로 채워질 것입니다. 운영 체제는 사용할 수 있는 버퍼 수에 제한(<a class="reference internal" href="os.html#os.sysconf" title="os.sysconf"><code class="xref py py-func docutils literal notranslate"><span class="pre">sysconf()</span></code></a> 값 <code class="docutils literal notranslate"><span class="pre">SC_IOV_MAX</span></code>)을 설정할 수 있습니다. <em>ancbufsize</em> 와 <em>flags</em> 인자는 <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a>와 같은 의미가 있습니다.</p>
<p>반환 값은 4-튜플입니다: <code class="docutils literal notranslate"><span class="pre">(nbytes,</span> <span class="pre">ancdata,</span> <span class="pre">msg_flags,</span> <span class="pre">address)</span></code>. 여기서 <em>nbytes</em>는 버퍼에 기록된 일반 데이터의 총 바이트 수이며, <em>ancdata</em>, <em>msg_flags</em> 및 <em>address</em>는 <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a>와 같습니다.</p>
<p>예제:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">socket</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socketpair</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;----&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;0123456789&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b3</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;--------------&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Mary had a little lamb&#39;</span><span class="p">)</span>
<span class="go">22</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span><span class="o">.</span><span class="n">recvmsg_into</span><span class="p">([</span><span class="n">b1</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b2</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">9</span><span class="p">],</span> <span class="n">b3</span><span class="p">])</span>
<span class="go">(22, [], 0, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">]</span>
<span class="go">[bytearray(b&#39;Mary&#39;), bytearray(b&#39;01 had a 9&#39;), bytearray(b&#39;little lamb---&#39;)]</span>
</pre></div>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 대부분 유닉스 플랫폼, 다른 것들도 가능합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.recvfrom_into">
<code class="descclassname">socket.</code><code class="descname">recvfrom_into</code><span class="sig-paren">(</span><em>buffer</em><span class="optional">[</span>, <em>nbytes</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recvfrom_into" title="정의 주소">¶</a></dt>
<dd><p>소켓에서 데이터를 수신하는데, 새로운 바이트열을 만드는 대신 <em>buffer</em>에 씁니다. 반환 값은 쌍 <code class="docutils literal notranslate"><span class="pre">(nbytes,</span> <span class="pre">address)</span></code>입니다. 여기서 <em>nbytes</em>는 수신 된 바이트 수이고, <em>address</em>는 데이터를 보내는 소켓의 주소입니다. 선택적 인자 <em>flags</em>의 의미에 대해서는 유닉스 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/recv(2)">recv(2)</a></em>를 보십시오; 기본값은 0입니다. (<em>address</em>의 형식은 주소 패밀리에 따라 다릅니다 --- 위를 보십시오.)</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.recv_into">
<code class="descclassname">socket.</code><code class="descname">recv_into</code><span class="sig-paren">(</span><em>buffer</em><span class="optional">[</span>, <em>nbytes</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recv_into" title="정의 주소">¶</a></dt>
<dd><p>소켓에서 최대 <em>nbytes</em> 바이트까지 수신하는데, 새 바이트열을 만드는 대신 데이터를 버퍼에 저장합니다. <em>nbytes</em>가 지정되지 않으면 (또는 0), 지정된 버퍼에서 사용 가능한 크기까지 수신합니다. 수신 한 바이트 수를 반환합니다. 선택적 인자 <em>flags</em>의 의미에 대해서는 유닉스 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/recv(2)">recv(2)</a></em>를 보십시오; 기본값은 0입니다.</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.send">
<code class="descclassname">socket.</code><code class="descname">send</code><span class="sig-paren">(</span><em>bytes</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.send" title="정의 주소">¶</a></dt>
<dd><p>소켓에 데이터를 보냅니다. 소켓은 원격 소켓에 연결되어야 합니다. 선택적 <em>flags</em> 인자는 위의 <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a>와 같은 의미입니다. 전송된 바이트 수를 반환합니다. 응용 프로그램은 모든 데이터가 전송되었는지 확인해야 합니다; 일부 데이터만 전송되었으면, 응용 프로그램은 나머지 데이터의 전달을 시도해야 합니다. 이 주제에 대한 자세한 정보는, <a class="reference internal" href="../howto/sockets.html#socket-howto"><span class="std std-ref">소켓 프로그래밍 HOWTO</span></a>를 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 메서드는 이제 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 예외를 발생시키는 대신 시스템 호출을 재시도합니다 (이유는 <span class="target" id="index-37"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하십시오).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.sendall">
<code class="descclassname">socket.</code><code class="descname">sendall</code><span class="sig-paren">(</span><em>bytes</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.sendall" title="정의 주소">¶</a></dt>
<dd><p>소켓에 데이터를 보냅니다. 소켓은 원격 소켓에 연결되어야 합니다. 선택적 <em>flags</em> 인자는 위의 <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a>와 같은 의미입니다. <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>와 달리, 이 메서드는 모든 데이터가 전송되거나 에러가 발생할 때까지 <em>bytes</em>의 데이터를 계속 전송합니다. 성공하면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다. 에러가 발생하면, 예외가 발생하는데, 성공적으로 전송된 데이터양을 (있기는 하다면) 확인하는 방법은 없습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>소켓 시간제한은 데이터가 성공적으로 전송될 때마다 더는 재설정되지 않습니다. 소켓 시간제한은 이제 모든 데이터를 전송할 수 있는 최대 총 지속 시간입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 메서드는 이제 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 예외를 발생시키는 대신 시스템 호출을 재시도합니다 (이유는 <span class="target" id="index-38"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하십시오).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.sendto">
<code class="descclassname">socket.</code><code class="descname">sendto</code><span class="sig-paren">(</span><em>bytes</em>, <em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.sendto" title="정의 주소">¶</a></dt>
<dt>
<code class="descclassname">socket.</code><code class="descname">sendto</code><span class="sig-paren">(</span><em>bytes</em>, <em>flags</em>, <em>address</em><span class="sig-paren">)</span></dt>
<dd><p>소켓에 데이터를 보냅니다. 대상 소켓이 <em>address</em>로 지정되므로, 소켓은 원격 소켓에 연결되지 않아야 합니다. 선택적 <em>flags</em> 인자는 위의 <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a>와 같은 의미가 있습니다. 전송된 바이트 수를 반환합니다. (<em>address</em>의 형식은 주소 패밀리에 따라 다릅니다 --- 위를 보십시오.)</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">address</span></code>를 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.sendto</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 메서드는 이제 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 예외를 발생시키는 대신 시스템 호출을 재시도합니다 (이유는 <span class="target" id="index-39"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하십시오).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.sendmsg">
<code class="descclassname">socket.</code><code class="descname">sendmsg</code><span class="sig-paren">(</span><em>buffers</em><span class="optional">[</span>, <em>ancdata</em><span class="optional">[</span>, <em>flags</em><span class="optional">[</span>, <em>address</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.sendmsg" title="정의 주소">¶</a></dt>
<dd><p>소켓에 일반과 보조 데이터를 보는데, 일련의 버퍼에서 일반 데이터를 모아서 단일 메시지로 연결합니다. <em>buffers</em> 인자는 일반 데이터를 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>의 이터러블로 지정합니다 (예를 들어, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체); 운영 체제는 사용할 수 있는 버퍼 수에 제한(<a class="reference internal" href="os.html#os.sysconf" title="os.sysconf"><code class="xref py py-func docutils literal notranslate"><span class="pre">sysconf()</span></code></a> 값 <code class="docutils literal notranslate"><span class="pre">SC_IOV_MAX</span></code>)을 설정할 수 있습니다. <em>ancdata</em> 인자는 보조 데이터 (제어 메시지)를 0개 이상의 튜플 <code class="docutils literal notranslate"><span class="pre">(cmsg_level,</span> <span class="pre">cmsg_type,</span> <span class="pre">cmsg_data)</span></code>의 이터러블로 지정합니다. 여기서 <em>cmsg_level</em> 와 <em>cmsg_type</em>는 각각 프로토콜 수준과 프로토콜 특정 형을 지정하는 정수이고, <em>cmsg_data</em>는 연결된 데이터를 담은 바이트열류 객체입니다. 일부 시스템(특히, <a class="reference internal" href="#socket.CMSG_SPACE" title="socket.CMSG_SPACE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CMSG_SPACE()</span></code></a>가 없는 시스템)은 호출 당 하나의 제어 메시지를 송신하는 것만 지원할 수 있습니다. <em>flags</em> 인자의 기본값은 0이고 <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>와 같은 의미입니다. <em>address</em>가 제공되고 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면, 메시지의 대상 주소를 설정합니다. 반환 값은 전송된 일반 데이터의 바이트 수입니다.</p>
<p>다음 함수는 <code class="xref py py-const docutils literal notranslate"><span class="pre">SCM_RIGHTS</span></code> 메커니즘을 지원하는 시스템에서, <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> 소켓을 통해 파일 기술자 리스트 <em>fds</em>를 보냅니다. <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a>도 참조하세요.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">array</span>

<span class="k">def</span> <span class="nf">send_fds</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">fds</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sock</span><span class="o">.</span><span class="n">sendmsg</span><span class="p">([</span><span class="n">msg</span><span class="p">],</span> <span class="p">[(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SCM_RIGHTS</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">fds</span><span class="p">))])</span>
</pre></div>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 대부분 유닉스 플랫폼, 다른 것들도 가능합니다.</p>
<p class="audit-hook"><code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">address</span></code>를 인자로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">socket.sendmsg</span></code>를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 메서드는 이제 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 예외를 발생시키는 대신 시스템 호출을 재시도합니다 (이유는 <span class="target" id="index-40"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하십시오).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.sendmsg_afalg">
<code class="descclassname">socket.</code><code class="descname">sendmsg_afalg</code><span class="sig-paren">(</span><span class="optional">[</span><em>msg</em>, <span class="optional">]</span><em>*</em>, <em>op</em><span class="optional">[</span>, <em>iv</em><span class="optional">[</span>, <em>assoclen</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.sendmsg_afalg" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#socket.AF_ALG" title="socket.AF_ALG"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_ALG</span></code></a> 소켓용, <a class="reference internal" href="#socket.socket.sendmsg" title="socket.socket.sendmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmsg()</span></code></a>의 특수한 버전. <a class="reference internal" href="#socket.AF_ALG" title="socket.AF_ALG"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_ALG</span></code></a> 소켓에 대한 모드, IV, AEAD 관련 데이터 길이 및 플래그를 설정합니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a> : 리눅스 &gt;= 2.6.38.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.sendfile">
<code class="descclassname">socket.</code><code class="descname">sendfile</code><span class="sig-paren">(</span><em>file</em>, <em>offset=0</em>, <em>count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.sendfile" title="정의 주소">¶</a></dt>
<dd><p>고성능 <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a>을 사용하여 EOF에 도달할 때까지 파일을 보내고, 보낸 총 바이트 수를 반환합니다. <em>file</em>은 바이너리 모드로 열린 일반 파일 객체여야 합니다. <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a>을 사용할 수 없거나 (예를 들어, 윈도우) <em>file</em>가 일반 파일이 아니면, <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>가 대신 사용됩니다. <em>offset</em>은 파일 읽기 시작할 위치를 알려줍니다. 지정되면, <em>count</em>는 EOF에 도달할 때까지 파일을 전송하는 대신 전송할 총 바이트 수입니다. 파일 위치는 반환하거나 에러가 발생했을 때 갱신됩니다. 이때 <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a>을 사용하여 전송된 바이트 수를 계산할 수 있습니다. 소켓은 <a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a> 유형이어야 합니다. 비 블로킹 소켓은 지원되지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.set_inheritable">
<code class="descclassname">socket.</code><code class="descname">set_inheritable</code><span class="sig-paren">(</span><em>inheritable</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.set_inheritable" title="정의 주소">¶</a></dt>
<dd><p>소켓의 파일 기술자나 소켓 핸들의 <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">상속 가능 플래그</span></a>를 설정합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.setblocking">
<code class="descclassname">socket.</code><code class="descname">setblocking</code><span class="sig-paren">(</span><em>flag</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.setblocking" title="정의 주소">¶</a></dt>
<dd><p>소켓의 블로킹이나 비 블로킹 모드를 설정합니다. <em>flag</em>가 거짓이면, 소켓은 비 블로킹으로 설정되고, 그렇지 않으면 블로킹 모드로 설정됩니다.</p>
<p>이 메서드는 특정 <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a> 호출의 줄인 표현입니다:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sock.setblocking(True)</span></code>는 <code class="docutils literal notranslate"><span class="pre">sock.settimeout(None)</span></code>와 동등합니다</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sock.setblocking(False)</span></code>는 <code class="docutils literal notranslate"><span class="pre">sock.settimeout(0.0)</span></code>와 동등합니다</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이 메서드는 더는 <a class="reference internal" href="#socket.socket.type" title="socket.socket.type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">socket.type</span></code></a>에 <a class="reference internal" href="#socket.SOCK_NONBLOCK" title="socket.SOCK_NONBLOCK"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_NONBLOCK</span></code></a> 플래그를 적용하지 않습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.settimeout">
<code class="descclassname">socket.</code><code class="descname">settimeout</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.settimeout" title="정의 주소">¶</a></dt>
<dd><p>블로킹 소켓 연산에 시간제한을 설정합니다. <em>value</em> 인자는 초로 표현된 음수가 아닌 부동 소수점 수나 <code class="docutils literal notranslate"><span class="pre">None</span></code> 일 수 있습니다. 0이 아닌 값을 주면, 후속 소켓 연산에서, 연산이 완료되기 전에 시간제한 기간 <em>value</em>가 지나면 <a class="reference internal" href="#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal notranslate"><span class="pre">timeout</span></code></a> 예외를 발생시킵니다. 0을 지정하면, 소켓은 비 블로킹 모드가 됩니다. <code class="docutils literal notranslate"><span class="pre">None</span></code>이 주어지면, 소켓은 블로킹 모드가 됩니다.</p>
<p>자세한 내용은, <a class="reference internal" href="#socket-timeouts"><span class="std std-ref">소켓 시간제한에 대한 참고 사항</span></a>을 보십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이 메서드는 더는 <a class="reference internal" href="#socket.socket.type" title="socket.socket.type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">socket.type</span></code></a>의 <a class="reference internal" href="#socket.SOCK_NONBLOCK" title="socket.SOCK_NONBLOCK"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_NONBLOCK</span></code></a> 플래그를 토글하지 않습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.setsockopt">
<code class="descclassname">socket.</code><code class="descname">setsockopt</code><span class="sig-paren">(</span><em>level</em>, <em>optname</em>, <em>value: int</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.setsockopt" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descclassname">socket.</code><code class="descname">setsockopt</code><span class="sig-paren">(</span><em>level</em>, <em>optname</em>, <em>value: buffer</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descclassname">socket.</code><code class="descname">setsockopt</code><span class="sig-paren">(</span><em>level</em>, <em>optname</em>, <em>None</em>, <em>optlen: int</em><span class="sig-paren">)</span></dt>
<dd><p id="index-14">주어진 소켓 옵션의 값을 설정합니다 (유닉스 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/setsockopt(2)">setsockopt(2)</a></em>를 보십시오). 필요한 기호 상수는 <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 모듈에 정의되어 있습니다 (<code class="xref py py-const docutils literal notranslate"><span class="pre">SO_*</span></code> 등). 값은 정수, <code class="docutils literal notranslate"><span class="pre">None</span></code> 또는 버퍼를 나타내는 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a> 일 수 있습니다. 후자의 경우, 호출자는 바이트열에 적절한 비트가 들어 있는지 확인해야 합니다 (C 구조체를 바이트열로 인코딩하는 방법에 대해서는 선택적 내장 모듈 <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a>를 참조하십시오). value를 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정하면, optlen 인자가 필요합니다. optval=NULL과 optlen=optlen 으로 setsockopt C 함수를 호출하는 것과 동등합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이제 쓰기 가능한 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>를 받아들입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>setsockopt(level, optname, None, optlen: int) 형식이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="socket.socket.shutdown">
<code class="descclassname">socket.</code><code class="descname">shutdown</code><span class="sig-paren">(</span><em>how</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.shutdown" title="정의 주소">¶</a></dt>
<dd><p>연결의 한쪽 또는 양쪽 절반을 닫습니다. <em>how</em>가 <code class="xref py py-const docutils literal notranslate"><span class="pre">SHUT_RD</span></code>면, 추가 수신이 허용되지 않습니다. <em>how</em>가 <code class="xref py py-const docutils literal notranslate"><span class="pre">SHUT_WR</span></code>이면, 추가 전송이 허용되지 않습니다. <em>how</em>가 <code class="xref py py-const docutils literal notranslate"><span class="pre">SHUT_RDWR</span></code>이면, 추가 송수신이 허용되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="socket.socket.share">
<code class="descclassname">socket.</code><code class="descname">share</code><span class="sig-paren">(</span><em>process_id</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.share" title="정의 주소">¶</a></dt>
<dd><p>소켓을 복제하고 대상 프로세스와 공유할 수 있도록 준비합니다. 대상 프로세스는 <em>process_id</em>로 제공되어야 합니다. 결과 바이트열 객체는 어떤 프로세스 간 통신의 형태를 사용하여 대상 프로세스로 전달될 수 있으며 그곳에서 <a class="reference internal" href="#socket.fromshare" title="socket.fromshare"><code class="xref py py-func docutils literal notranslate"><span class="pre">fromshare()</span></code></a>를 사용하여 소켓을 다시 만들 수 있습니다. 일단, 이 메서드가 호출되면, 운영 체제가 이미 대상 프로세스를 위해 이를 복제 했으므로 소켓을 닫아도 안전합니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 윈도우.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<p>메서드 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> 나 <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>가 없다는 점에 유의하십시오; 대신 <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a> 와 <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>를 <em>flags</em> 인자 없이 사용하십시오.</p>
<p>소켓 객체는 또한 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> 생성자에 지정된 값에 대응하는 다음과 같은 (읽기 전용) 어트리뷰트를 가집니다.</p>
<dl class="attribute">
<dt id="socket.socket.family">
<code class="descclassname">socket.</code><code class="descname">family</code><a class="headerlink" href="#socket.socket.family" title="정의 주소">¶</a></dt>
<dd><p>소켓 패밀리.</p>
</dd></dl>

<dl class="attribute">
<dt id="socket.socket.type">
<code class="descclassname">socket.</code><code class="descname">type</code><a class="headerlink" href="#socket.socket.type" title="정의 주소">¶</a></dt>
<dd><p>소켓 유형.</p>
</dd></dl>

<dl class="attribute">
<dt id="socket.socket.proto">
<code class="descclassname">socket.</code><code class="descname">proto</code><a class="headerlink" href="#socket.socket.proto" title="정의 주소">¶</a></dt>
<dd><p>소켓 프로토콜.</p>
</dd></dl>

</div>
<div class="section" id="notes-on-socket-timeouts">
<span id="socket-timeouts"></span><h2>소켓 시간제한에 대한 참고 사항<a class="headerlink" href="#notes-on-socket-timeouts" title="제목 주소">¶</a></h2>
<p>소켓 객체는 세 가지 모드 중 하나일 수 있습니다: 블로킹, 비 블로킹, 또는 시간제한. 소켓은 기본적으로 항상 블로킹 모드로 생성되지만, 이는 <a class="reference internal" href="#socket.setdefaulttimeout" title="socket.setdefaulttimeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">setdefaulttimeout()</span></code></a>를 호출하여 변경할 수 있습니다.</p>
<ul class="simple">
<li><p><em>블로킹 모드</em>에서, 연산은 완료되거나 시스템에서 에러(가령 연결 시간 초과)를 반환할 때까지 블록합니다.</p></li>
<li><p><em>비 블로킹 모드</em>에서, 연산은 즉시 완료할 수 없으면 실패합니다 (불행히도 시스템 종속적인 에러로): <a class="reference internal" href="select.html#module-select" title="select: Wait for I/O completion on multiple streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">select</span></code></a>의 함수를 사용하여 소켓이 읽기나 쓰기가 가능한 시기를 알 수 있습니다.</p></li>
<li><p><em>시간제한 모드</em>에서, 연산은 소켓에 대해 지정된 제한 시간 내에 완료할 수 없거나 (<a class="reference internal" href="#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal notranslate"><span class="pre">timeout</span></code></a> 예외 발생), 시스템이 에러를 반환하면 실패합니다.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>운영 체제 수준에서, <em>시간제한 모드</em>의 소켓은 내부적으로 비 블로킹 모드로 설정됩니다. 또한, 블로킹과 시간제한 모드는 같은 네트워크 끝점을 가리키는 파일 기술자와 소켓 객체 간에 공유됩니다. 이 구현 세부 사항은 가시적인 결과를 가져올 수 있습니다, 예를 들어, 소켓의 <a class="reference internal" href="#socket.socket.fileno" title="socket.socket.fileno"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code></a>를 사용하기로 한 경우가 그렇습니다.</p>
</div>
<div class="section" id="timeouts-and-the-connect-method">
<h3>시간제한과 <code class="docutils literal notranslate"><span class="pre">connect</span></code> 메서드<a class="headerlink" href="#timeouts-and-the-connect-method" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> 연산도 시간제한 설정의 영향을 받으며, 일반적으로 <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a>를 호출하기 전에 <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a>를 호출하거나 <a class="reference internal" href="#socket.create_connection" title="socket.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_connection()</span></code></a>에 timeout 매개 변수를 전달하는 것이 좋습니다. 그러나, 시스템 네트워크 스택은 파이썬 소켓 시간제한 설정과 관계없이 자체의 연결 시간제한 에러를 반환할 수 있습니다.</p>
</div>
<div class="section" id="timeouts-and-the-accept-method">
<h3>시간제한과 <code class="docutils literal notranslate"><span class="pre">accept</span></code> 메서드<a class="headerlink" href="#timeouts-and-the-accept-method" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#socket.getdefaulttimeout" title="socket.getdefaulttimeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">getdefaulttimeout()</span></code></a>가 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>이 아니면, <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> 메서드에서 반환된 소켓은 그 시간제한을 상속합니다. 그렇지 않으면, 동작은 리스닝 소켓의 설정에 따라 다릅니다:</p>
<ul class="simple">
<li><p>리스닝 소켓이 <em>블로킹 모드</em> 나 <em>시간제한 모드</em>에 있으면, <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a>에 의해 반환된 소켓은 <em>블로킹 모드</em>에 있습니다.</p></li>
<li><p>리스닝 소켓이 <em>비 블로킹 모드</em>에 있으면, <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a>에 의해 반환된 소켓이 블로킹 모드인지 비 블로킹 모드인지는 운영 체제에 따라 다릅니다. 플랫폼 간 동작을 보장하려면, 이 설정을 직접 재정의하는 것이 좋습니다.</p></li>
</ul>
</div>
</div>
<div class="section" id="example">
<span id="socket-example"></span><h2>예제<a class="headerlink" href="#example" title="제목 주소">¶</a></h2>
<p>다음은 TCP/IP 프로토콜을 사용하는 4가지 최소 예제 프로그램입니다: (하나의 클라이언트만 서비스하는) 수신한 모든 데이터를 반향하는 서버와, 이를 사용하는 클라이언트. 서버는 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code></a>, <a class="reference internal" href="#socket.socket.bind" title="socket.socket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind()</span></code></a>, <a class="reference internal" href="#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a>, <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> (두 개 이상의 클라이언트에 서비스를 제공하기 위해 <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a>를 반복할 수 있습니다) 절차를 수행해야 하지만, 클라이언트는 <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code></a>, <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> 절차만 요구함에 유의하십시오. 또한, 서버는 수신 대기 중인 소켓이 아니라 <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a>가 반환한 새 소켓에 대해서 <a class="reference internal" href="#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendall()</span></code></a>/<a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a>를 한다는 것에도 유의하십시오.</p>
<p>처음 두 예제는 IPv4만 지원합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 메아리 서버 프로그램</span>
<span class="kn">import</span> <span class="nn">socket</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>                 <span class="c1"># 사용 가능한 모든 인터페이스를 의미하는 기호적인 이름</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># 임의의 비특권 포트</span>
<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
    <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">conn</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Connected by&#39;</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span> <span class="k">break</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 메아리 클라이언트 프로그램</span>
<span class="kn">import</span> <span class="nn">socket</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s1">&#39;daring.cwi.nl&#39;</span>    <span class="c1"># 원격 호스트</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># 서버가 사용하는 것과 같은 포트</span>
<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
    <span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello, world&#39;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Received&#39;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</pre></div>
</div>
<p>다음 두 예제는 위의 두 예제와 같지만, IPv4와 IPv6를 모두 지원합니다. 서버 측은 사용 가능한 첫 번째 주소 패밀리를 리슨합니다 (대신 두 주소를 모두 리슨 해야 합니다). 대부분 IPv6 지원 시스템에서, IPv6가 우선하며 서버가 IPv4 트래픽을 허용하지 않을 수 있습니다. 클라이언트 측은 이름 결정의 결과로 반환된 모든 주소에 연결을 시도하고 성공적으로 연결된 첫 번째 주소로 트래픽을 보냅니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 메아리 서버 프로그램</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="kc">None</span>               <span class="c1"># 사용 가능한 모든 인터페이스를 의미하는 기호적인 이름</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># 임의의 비특권 포트</span>
<span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_UNSPEC</span><span class="p">,</span>
                              <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">AI_PASSIVE</span><span class="p">):</span>
    <span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">canonname</span><span class="p">,</span> <span class="n">sa</span> <span class="o">=</span> <span class="n">res</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">sa</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">break</span>
<span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;could not open socket&#39;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
<span class="k">with</span> <span class="n">conn</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Connected by&#39;</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span> <span class="k">break</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 메아리 클라이언트 프로그램</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s1">&#39;daring.cwi.nl&#39;</span>    <span class="c1"># 원격 호스트</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># 서버가 사용하는 것과 같은 포트</span>
<span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_UNSPEC</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">):</span>
    <span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">canonname</span><span class="p">,</span> <span class="n">sa</span> <span class="o">=</span> <span class="n">res</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">sa</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">break</span>
<span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;could not open socket&#39;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">with</span> <span class="n">s</span><span class="p">:</span>
    <span class="n">s</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello, world&#39;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Received&#39;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</pre></div>
</div>
<p>다음 예제는 윈도우에서 원시(raw) 소켓으로 매우 간단한 네트워크 스니퍼를 작성하는 방법을 보여줍니다. 이 예제는 인터페이스를 수정하기 위해 관리자 권한이 필요합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>

<span class="c1"># 공개 네트워크 인터페이스</span>
<span class="n">HOST</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">gethostbyname</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">())</span>

<span class="c1"># 원시(raw) 소켓을 만들고, 공개 인터페이스에 바인드합니다</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_RAW</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_IP</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># IP 헤더를 포함합니다</span>
<span class="n">s</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_IP</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">IP_HDRINCL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># 모든 꾸러미를 받습니다</span>
<span class="n">s</span><span class="o">.</span><span class="n">ioctl</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SIO_RCVALL</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">RCVALL_ON</span><span class="p">)</span>

<span class="c1"># 꾸러미를 받습니다</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">65565</span><span class="p">))</span>

<span class="c1"># 무차별 모드를 비활성화합니다</span>
<span class="n">s</span><span class="o">.</span><span class="n">ioctl</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SIO_RCVALL</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">RCVALL_OFF</span><span class="p">)</span>
</pre></div>
</div>
<p>다음 예제는 원시(raw) 소켓 프로토콜을 사용하여, 소켓 인터페이스를 사용하여 CAN 네트워크와 통신하는 방법을 보여줍니다. 대신 브로드캐스트 관리자 프로토콜로 CAN을 사용하려면, 소켓을 이렇게 여십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_CAN</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">CAN_BCM</span><span class="p">)</span>
</pre></div>
</div>
<p>소켓을 바인드(<code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_RAW</span></code>)하거나 연결(<a class="reference internal" href="#socket.CAN_BCM" title="socket.CAN_BCM"><code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_BCM</span></code></a>)한 후, <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.send()</span></code></a> 와 <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv()</span></code></a> 연산(과 대응 연산)을 소켓 객체에 평소와 같이 사용할 수 있습니다.</p>
<p>이 마지막 예제는 특별한 권한이 필요할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">struct</span>


<span class="c1"># CAN 프레임 패킹/언 패킹 (&lt;linux/can.h&gt;의 &#39;struct can_frame&#39;을 참조하십시오)</span>

<span class="n">can_frame_fmt</span> <span class="o">=</span> <span class="s2">&quot;=IB3x8s&quot;</span>
<span class="n">can_frame_size</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="n">can_frame_fmt</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">build_can_frame</span><span class="p">(</span><span class="n">can_id</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">can_dlc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">can_frame_fmt</span><span class="p">,</span> <span class="n">can_id</span><span class="p">,</span> <span class="n">can_dlc</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dissect_can_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
    <span class="n">can_id</span><span class="p">,</span> <span class="n">can_dlc</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">can_frame_fmt</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">can_id</span><span class="p">,</span> <span class="n">can_dlc</span><span class="p">,</span> <span class="n">data</span><span class="p">[:</span><span class="n">can_dlc</span><span class="p">])</span>


<span class="c1"># 원시(raw) 소켓을 만들고 &#39;vcan0&#39; 인터페이스에 바인드합니다</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_CAN</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_RAW</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">CAN_RAW</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;vcan0&#39;</span><span class="p">,))</span>

<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">cf</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="n">can_frame_size</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Received: can_id=</span><span class="si">%x</span><span class="s1">, can_dlc=</span><span class="si">%x</span><span class="s1">, data=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">dissect_can_frame</span><span class="p">(</span><span class="n">cf</span><span class="p">))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">cf</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error sending CAN frame&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">build_can_frame</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x02\x03</span><span class="s1">&#39;</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error sending CAN frame&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>실행 간격이 너무 짧게 여러 번 예제를 실행하면 이 에러가 발생할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ne">OSError</span><span class="p">:</span> <span class="p">[</span><span class="n">Errno</span> <span class="mi">98</span><span class="p">]</span> <span class="n">Address</span> <span class="n">already</span> <span class="ow">in</span> <span class="n">use</span>
</pre></div>
</div>
<p>이것은 이전 실행이 소켓을 <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code> 상태로 남겨 두었고, 즉시 재사용할 수 없기 때문입니다.</p>
<p>이것을 방지하기 위해서 설정할 수 있는 <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 플래그 <code class="xref py py-data docutils literal notranslate"><span class="pre">socket.SO_REUSEADDR</span></code>가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="xref py py-data docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> 플래그는 자연스러운 시간제한이 만료되기를 기다리지 않고 <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code> 상태의 지역 소켓을 재사용하도록 커널에 알립니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>(C로 하는) 소켓 프로그래밍에 대한 소개는 다음 논문을 참조하십시오:</p>
<ul class="simple">
<li><p><em>An Introductory 4.3BSD Interprocess Communication Tutorial</em>, Stuart Sechrest 저</p></li>
<li><p><em>An Advanced 4.3BSD Interprocess Communication Tutorial</em>, Samuel J. Leffler 외 저,</p></li>
</ul>
<p>둘 다 유닉스 프로그래머 매뉴얼, 보충 문서 1 (섹션 PS1:7과 PS1:8)에 있습니다. 다양한 소켓 관련 시스템 호출에 대한 플랫폼별 레퍼런스 자료는 소켓 의미의 세부 정보에 대한 중요한 소스입니다. 유닉스에서는 매뉴얼 페이지를 참조하십시오; 윈도우에서는, WinSock (또는 Winsock 2) 명세를 참조하십시오. IPv6 지원 API의 경우, 독자는 Basic Socket Interface Extensions for IPv6라는 제목의 <span class="target" id="index-41"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3493.html"><strong>RFC 3493</strong></a>를 참조하고 싶을 겁니다.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code> --- 저수준 네트워킹 인터페이스</a><ul>
<li><a class="reference internal" href="#socket-families">소켓 패밀리</a></li>
<li><a class="reference internal" href="#module-contents">모듈 내용</a><ul>
<li><a class="reference internal" href="#exceptions">예외</a></li>
<li><a class="reference internal" href="#constants">상수</a></li>
<li><a class="reference internal" href="#functions">함수</a><ul>
<li><a class="reference internal" href="#creating-sockets">소켓 만들기</a></li>
<li><a class="reference internal" href="#other-functions">기타 함수</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#socket-objects">소켓 객체</a></li>
<li><a class="reference internal" href="#notes-on-socket-timeouts">소켓 시간제한에 대한 참고 사항</a><ul>
<li><a class="reference internal" href="#timeouts-and-the-connect-method">시간제한과 <code class="docutils literal notranslate"><span class="pre">connect</span></code> 메서드</a></li>
<li><a class="reference internal" href="#timeouts-and-the-accept-method">시간제한과 <code class="docutils literal notranslate"><span class="pre">accept</span></code> 메서드</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example">예제</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="asyncio-dev.html"
                        title="이전 장">asyncio로 개발하기</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="ssl.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code> --- 소켓 객체용 TLS/SSL 래퍼</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="ssl.html" title="ssl --- 소켓 객체용 TLS/SSL 래퍼"
             >다음</a> |</li>
        <li class="right" >
          <a href="asyncio-dev.html" title="asyncio로 개발하기"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>