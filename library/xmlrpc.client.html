
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>xmlrpc.client --- XML-RPC 클라이언트 액세스 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="xmlrpc.server --- 기본 XML-RPC 서버" href="xmlrpc.server.html" />
    <link rel="prev" title="xmlrpc --- XMLRPC 서버와 클라이언트 모듈" href="xmlrpc.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/xmlrpc.client.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="xmlrpc.server.html" title="xmlrpc.server --- 기본 XML-RPC 서버"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="xmlrpc.html" title="xmlrpc --- XMLRPC 서버와 클라이언트 모듈"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-xmlrpc.client">
<span id="xmlrpc-client-xml-rpc-client-access"></span><h1><a class="reference internal" href="#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc.client</span></code></a> --- XML-RPC 클라이언트 액세스<a class="headerlink" href="#module-xmlrpc.client" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/xmlrpc/client.py">Lib/xmlrpc/client.py</a></p>
<hr class="docutils" />
<p>XML-RPC는 HTTP(S)를 통해 전달된 XML을 트랜스포트로 사용하는 원격 프로시저 호출(Remote Procedure Call) 방법입니다. 이를 통해, 클라이언트는 원격 서버에서 매개 변수를 사용하여 메서드를 호출하고 (서버는 URI로 이름이 지정됩니다) 구조화된 데이터를 돌려받을 수 있습니다. 이 모듈은 XML-RPC 클라이언트 코드 작성을 지원합니다; 적합한 파이썬 객체와 전송 회선 상의 XML 간 변환의 모든 세부 사항을 처리합니다.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p><a class="reference internal" href="#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc.client</span></code></a> 모듈은 악의적으로 구성된 데이터로부터 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 데이터를 구문 분석해야 하면 <a class="reference internal" href="xml.html#xml-vulnerabilities"><span class="std std-ref">XML 취약점</span></a>을 참조하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>HTTPS URI의 경우, <a class="reference internal" href="#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc.client</span></code></a>는 이제 기본적으로 필요한 모든 인증서와 호스트명 확인을 수행합니다.</p>
</div>
<dl class="class">
<dt id="xmlrpc.client.ServerProxy">
<em class="property">class </em><code class="sig-prename descclassname">xmlrpc.client.</code><code class="sig-name descname">ServerProxy</code><span class="sig-paren">(</span><em class="sig-param">uri</em>, <em class="sig-param">transport=None</em>, <em class="sig-param">encoding=None</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">allow_none=False</em>, <em class="sig-param">use_datetime=False</em>, <em class="sig-param">use_builtin_types=False</em>, <em class="sig-param">*</em>, <em class="sig-param">headers=()</em>, <em class="sig-param">context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xmlrpc.client.ServerProxy" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#xmlrpc.client.ServerProxy" title="xmlrpc.client.ServerProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ServerProxy</span></code></a> 인스턴스는 원격 XML-RPC 서버와의 통신을 관리하는 객체입니다. 필수적인 첫 번째 인자는 URI(Uniform Resource Indicator)이며 일반적으로 서버의 URL입니다. 선택적인 두 번째 인자는 트랜스포트 팩토리 인스턴스입니다; 기본적으로 https: URL의 경우는 내부 <code class="xref py py-class docutils literal notranslate"><span class="pre">SafeTransport</span></code> 인스턴스이고 그렇지 않으면 내부 HTTP <code class="xref py py-class docutils literal notranslate"><span class="pre">Transport</span></code> 인스턴스입니다. 선택적 세 번째 인자는 인코딩이며, 기본적으로 UTF-8입니다. 선택적 네 번째 인자는 디버깅 플래그입니다.</p>
<p>그 뒤에 오는 매개 변수들은 반환된 프락시 인스턴스 사용을 제어합니다. <em>allow_none</em>이 참이면, 파이썬 상수 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 XML로 변환됩니다; 기본 동작은 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시키는 것입니다. 이것은 XML-RPC 명세에 일반적으로 사용되는 확장이지만, 모든 클라이언트와 서버에서 지원되는 것은 아닙니다; 설명은 <a class="reference external" href="https://web.archive.org/web/20130120074804/http://ontosys.com/xml-rpc/extensions.php">http://ontosys.com/xml-rpc/extensions.php</a>를 참조하십시오. <em>use_builtin_types</em> 플래그를 사용하여 날짜/시간 값을 <a class="reference internal" href="datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a> 객체로 표현하고 바이너리 데이터를 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체로 표현할 수 있습니다; 이 플래그는 기본적으로 거짓입니다. <a class="reference internal" href="datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 및 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 객체는 호출로 전달될 수 있습니다. <em>headers</em> 매개 변수는 각 요청과 함께 보낼 선택적 HTTP 헤더의 시퀀스이며, 헤더 이름과 값을 나타내는 2-튜플의 시퀀스로 표현됩니다. (예를 들어 <cite>[('Header-Name', 'value')]</cite>). 사용되지 않는 <em>use_datetime</em> 플래그는 <em>use_builtin_types</em>와 유사하지만, 날짜/시간 값에만 적용됩니다.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><em>use_builtin_types</em> 플래그가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><em>headers</em> 매개 변수가 추가되었습니다.</p>
<p>HTTP와 HTTPS 트랜스포트는 모두 HTTP 기본 인증(Basic Authentication)을 위한 URL 구문 확장을 지원합니다: <code class="docutils literal notranslate"><span class="pre">http://user:pass&#64;host:port/path</span></code>. <code class="docutils literal notranslate"><span class="pre">user:pass</span></code> 부분은 HTTP 'Authorization' 헤더로 base64 인코딩되고, XML-RPC 메서드를 호출할 때 연결 프로세스의 일부로 원격 서버로 전송됩니다. 원격 서버가 기본 인증 사용자와 비밀번호를 요구할 때만 이를 사용해야 합니다. HTTPS URL이 제공되면, <em>context</em>는 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 일 수 있고 하부 HTTPS 연결의 SSL 설정을 구성합니다.</p>
<p>반환된 인스턴스는 원격 서버에서 해당 RPC 호출을 호출하는 데 사용할 수 있는 메서드가 있는 프락시 객체입니다. 원격 서버가 인트로스펙션(introspection) API를 지원하면, 프락시를 사용하여 원격 서버에서 지원하는 메서드를 조회하고 (서비스 검색, service discovery) 다른 서버 관련 메타 데이터를 가져올 수 있습니다.</p>
<p>적합한 형(예를 들어 XML을 통해 마샬링 할 수 있는 형)에는 다음이 포함됩니다 (별도로 표시된 경우를 제외하고는 같은 파이썬 형으로 역마샬링 됩니다):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>XML-RPC 형</p></th>
<th class="head"><p>파이썬 형</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">boolean</span></code></p></td>
<td><p><a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">i1</span></code>, <code class="docutils literal notranslate"><span class="pre">i2</span></code>, <code class="docutils literal notranslate"><span class="pre">i4</span></code>, <code class="docutils literal notranslate"><span class="pre">i8</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">biginteger</span></code></p></td>
<td><p>-2147483648에서 2147483647 범위의 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>. 값은 <code class="docutils literal notranslate"><span class="pre">&lt;int&gt;</span></code> 태그를 얻습니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">double</span></code>이나 <code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p><a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>. 값은 <code class="docutils literal notranslate"><span class="pre">&lt;double&gt;</span></code> 태그를 얻습니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">string</span></code></p></td>
<td><p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">array</span></code></p></td>
<td><p>적합한 요소를 포함하는 <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>나 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>. 배열은 <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">리스트</span></code></a>로 반환됩니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">struct</span></code></p></td>
<td><p><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. 키는 문자열이어야 하며, 값은 적합한 형일 수 있습니다. 사용자 정의 클래스의 객체를 전달할 수 있습니다; <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 어트리뷰트만 전송됩니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">dateTime.iso8601</span></code></p></td>
<td><p><a class="reference internal" href="#xmlrpc.client.DateTime" title="xmlrpc.client.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a>이나 <a class="reference internal" href="datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a>. 반환되는 형은 <em>use_builtin_types</em>와 <em>use_datetime</em> 플래그 값에 따라 다릅니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">base64</span></code></p></td>
<td><p><a class="reference internal" href="#xmlrpc.client.Binary" title="xmlrpc.client.Binary"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binary</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 또는 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>. 반환되는 형은 <em>use_builtin_types</em> 플래그의 값에 따라 다릅니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">nil</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">None</span></code> 상수. <em>allow_none</em>이 참일 때만 전달이 허용됩니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">bigdecimal</span></code></p></td>
<td><p><a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a>. 반환되는 형 전용.</p></td>
</tr>
</tbody>
</table>
<p>이것이 XML-RPC가 지원하는 데이터형의 전체 집합입니다. 메서드 호출은 XML-RPC 서버 에러를 알리는 데 사용되는 특수 <a class="reference internal" href="#xmlrpc.client.Fault" title="xmlrpc.client.Fault"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Fault</span></code></a> 인스턴스나 HTTP/HTTPS 전송 계층의 에러를 알리는 데 사용되는 <a class="reference internal" href="#xmlrpc.client.ProtocolError" title="xmlrpc.client.ProtocolError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ProtocolError</span></code></a>를 발생시킬 수도 있습니다. <a class="reference internal" href="#xmlrpc.client.Fault" title="xmlrpc.client.Fault"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Fault</span></code></a>와 <a class="reference internal" href="#xmlrpc.client.ProtocolError" title="xmlrpc.client.ProtocolError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ProtocolError</span></code></a>는 모두 <code class="xref py py-exc docutils literal notranslate"><span class="pre">Error</span></code>라는 베이스 클래스에서 파생됩니다. xmlrpc 클라이언트 모듈은 현재 내장형의 서브 클래스 인스턴스를 마샬링 하지 않음에 유의하십시오.</p>
<p>문자열을 전달할 때, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 및 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>와 같은 XML에 특수한 문자는 자동으로 이스케이프 됩니다. 그러나, 0에서 31 사이의 ASCII 값을 가진 제어 문자(물론 탭, 줄 넘김 및 캐리지 리턴은 제외하고)와 같이 문자열에 XML에서 허용되지 않는 문자가 없도록 확인하는 것은 호출자의 책임입니다; 이렇게 하지 않으면 XML 형식이 잘못된 XML-RPC 요청이 발생합니다. XML-RPC를 통해 임의의 바이트열을 전달해야 하면, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>나 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 클래스 또는 아래 설명된 <a class="reference internal" href="#xmlrpc.client.Binary" title="xmlrpc.client.Binary"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binary</span></code></a> 래퍼 클래스를 사용하십시오.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code>는 이전 버전과의 호환성을 위해 <a class="reference internal" href="#xmlrpc.client.ServerProxy" title="xmlrpc.client.ServerProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ServerProxy</span></code></a>의 별칭으로 유지됩니다. 새 코드는 <a class="reference internal" href="#xmlrpc.client.ServerProxy" title="xmlrpc.client.ServerProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ServerProxy</span></code></a>를 사용해야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><em>context</em> 인자를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>접두사가 있는 형 태그 지원이 추가되었습니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">ex:nil</span></code>). 숫자를 위해 Apache XML-RPC 구현이 사용하는 추가 형의 역마샬링 지원이 추가되었습니다: <code class="docutils literal notranslate"><span class="pre">i1</span></code>, <code class="docutils literal notranslate"><span class="pre">i2</span></code>, <code class="docutils literal notranslate"><span class="pre">i8</span></code>, <code class="docutils literal notranslate"><span class="pre">biginteger</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code> 및 <code class="docutils literal notranslate"><span class="pre">bigdecimal</span></code>. 설명은 <a class="reference external" href="http://ws.apache.org/xmlrpc/types.html">http://ws.apache.org/xmlrpc/types.html</a> 을 참조하십시오.</p>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><a class="reference external" href="http://www.tldp.org/HOWTO/XML-RPC-HOWTO/index.html">XML-RPC HOWTO</a></dt><dd><p>여러 언어로 된 XML-RPC 연산과 클라이언트 소프트웨어에 대한 훌륭한 설명. XML-RPC 클라이언트 개발자가 알아야 할 거의 모든 것이 포함되어 있습니다.</p>
</dd>
<dt><a class="reference external" href="http://xmlrpc-c.sourceforge.net/introspection.html">XML-RPC Introspection</a></dt><dd><p>인트로스펙션을 위한 XML-RPC 프로토콜 확장을 설명합니다.</p>
</dd>
<dt><a class="reference external" href="http://xmlrpc.scripting.com/spec.html">XML-RPC Specification</a></dt><dd><p>공식 명세.</p>
</dd>
<dt><a class="reference external" href="http://effbot.org/zone/xmlrpc-errata.htm">Unofficial XML-RPC Errata</a></dt><dd><p>Fredrik Lundh의 &quot;비공식 정오표, XML-RPC 명세의 특정 세부 사항을 명확하게 설명할 뿐만 아니라 여러분 자신의 XML-RPC 구현을 설계할 때 사용할 '모범 사례'에 대한 힌트를 제공하기 위한 것입니다.&quot;</p>
</dd>
</dl>
</div>
<div class="section" id="serverproxy-objects">
<span id="id1"></span><h2>ServerProxy 객체<a class="headerlink" href="#serverproxy-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#xmlrpc.client.ServerProxy" title="xmlrpc.client.ServerProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ServerProxy</span></code></a> 인스턴스에는 XML-RPC 서버가 받아들이는 각 원격 프로시저 호출에 해당하는 메서드가 있습니다. 메서드를 호출하면 RPC를 수행하는데, 이름과 인자 서명 모두로 디스패치 됩니다 (예를 들어 같은 메서드 이름이 여러 인자 서명으로 오버로드 될 수 있습니다). RPC는 값을 반환하여 완료되는데, 값은 적합한 형으로 반환된 데이터이거나 에러를 나타내는 <a class="reference internal" href="#xmlrpc.client.Fault" title="xmlrpc.client.Fault"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fault</span></code></a>나 <a class="reference internal" href="#xmlrpc.client.ProtocolError" title="xmlrpc.client.ProtocolError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProtocolError</span></code></a> 객체일 수 있습니다.</p>
<p>XML 인트로스팩션 API를 지원하는 서버는 예약된 <code class="xref py py-attr docutils literal notranslate"><span class="pre">system</span></code> 어트리뷰트 밑에 그룹화된 몇 가지 공통 메서드를 지원합니다:</p>
<dl class="method">
<dt id="xmlrpc.client.ServerProxy.system.listMethods">
<code class="sig-prename descclassname">ServerProxy.system.</code><code class="sig-name descname">listMethods</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xmlrpc.client.ServerProxy.system.listMethods" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 문자열 리스트를 반환하는데, XML-RPC 서버가 지원하는 각 (system이 아닌) 메서드마다 하나씩 제공됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="xmlrpc.client.ServerProxy.system.methodSignature">
<code class="sig-prename descclassname">ServerProxy.system.</code><code class="sig-name descname">methodSignature</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#xmlrpc.client.ServerProxy.system.methodSignature" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 하나의 매개 변수를 취하는데, XML-RPC 서버에 의해 구현된 메서드의 이름입니다. 이 메서드에 대해 가능한 서명의 배열을 반환합니다. 서명은 형의 배열입니다. 이 형 중 첫 번째는 메서드의 반환형이고 나머지는 매개 변수입니다.</p>
<p>다중 서명(즉 오버로딩)이 허용되므로, 이 메서드는 하나가 아닌 서명의 리스트를 반환합니다.</p>
<p>서명 자체는 메서드가 기대하는 최상위 매개 변수로 제한됩니다. 예를 들어, 메서드가 구조체 배열 하나를 매개 변수로 기대하고, 문자열을 반환하면, 서명은 단순히 &quot;string, array&quot;입니다. 세 개의 정수를 기대하고 문자열을 반환하면, 서명은 &quot;string, int, int, int&quot;입니다.</p>
<p>메서드에 서명이 정의되지 않으면, 배열이 아닌 값이 반환됩니다. 파이썬에서 이것은 반환된 값의 형이 리스트 이외의 어떤 것이 됨을 의미합니다.</p>
</dd></dl>

<dl class="method">
<dt id="xmlrpc.client.ServerProxy.system.methodHelp">
<code class="sig-prename descclassname">ServerProxy.system.</code><code class="sig-name descname">methodHelp</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#xmlrpc.client.ServerProxy.system.methodHelp" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 하나의 매개 변수를 취하는데, XML-RPC 서버에 의해 구현된 메서드의 이름입니다. 해당 메서드의 사용법을 기술하는 설명서 문자열을 반환합니다. 이러한 문자열이 없으면, 빈 문자열이 반환됩니다. 설명서 문자열에 HTML 마크업이 포함될 수 있습니다.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><a class="reference internal" href="#xmlrpc.client.ServerProxy" title="xmlrpc.client.ServerProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">ServerProxy</span></code></a> 인스턴스는 하부 트랜스포트를 닫기 위한 <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">컨텍스트 관리자</span></a> 프로토콜을 지원합니다.</p>
</div>
<p>다음은 실제 예입니다. 서버 코드:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="k">import</span> <span class="n">SimpleXMLRPCServer</span>

<span class="k">def</span> <span class="nf">is_even</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">SimpleXMLRPCServer</span><span class="p">((</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Listening on port 8000...&quot;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">is_even</span><span class="p">,</span> <span class="s2">&quot;is_even&quot;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>이전 서버에 대한 클라이언트 코드:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="k">with</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ServerProxy</span><span class="p">(</span><span class="s2">&quot;http://localhost:8000/&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">proxy</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;3 is even: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">proxy</span><span class="o">.</span><span class="n">is_even</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;100 is even: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">proxy</span><span class="o">.</span><span class="n">is_even</span><span class="p">(</span><span class="mi">100</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="section" id="datetime-objects">
<span id="id2"></span><h2>DateTime 객체<a class="headerlink" href="#datetime-objects" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="xmlrpc.client.DateTime">
<em class="property">class </em><code class="sig-prename descclassname">xmlrpc.client.</code><code class="sig-name descname">DateTime</code><a class="headerlink" href="#xmlrpc.client.DateTime" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 에포크(epoch) 이후의 초, 시간 튜플, ISO 8601 시간/날짜 문자열 또는 <a class="reference internal" href="datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a>으로 초기화될 수 있습니다. 주로 마샬링/역마샬링 코드 내부에서 사용하기 위해 지원되는, 다음과 같은 메서드가 있습니다:</p>
<dl class="method">
<dt id="xmlrpc.client.DateTime.decode">
<code class="sig-name descname">decode</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="sig-paren">)</span><a class="headerlink" href="#xmlrpc.client.DateTime.decode" title="정의 주소">¶</a></dt>
<dd><p>인스턴스의 새 시간 값으로 문자열을 받아들입니다.</p>
</dd></dl>

<dl class="method">
<dt id="xmlrpc.client.DateTime.encode">
<code class="sig-name descname">encode</code><span class="sig-paren">(</span><em class="sig-param">out</em><span class="sig-paren">)</span><a class="headerlink" href="#xmlrpc.client.DateTime.encode" title="정의 주소">¶</a></dt>
<dd><p>이 <a class="reference internal" href="#xmlrpc.client.DateTime" title="xmlrpc.client.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a> 항목의 XML-RPC 인코딩을 <em>out</em> 스트림 객체에 씁니다.</p>
</dd></dl>

<p>풍부한 비교와 <a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 메서드를 통해 특정 파이썬 내장 연산자도 지원합니다.</p>
</dd></dl>

<p>다음은 실제 예입니다. 서버 코드:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="k">import</span> <span class="n">SimpleXMLRPCServer</span>
<span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="k">def</span> <span class="nf">today</span><span class="p">():</span>
    <span class="n">today</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">DateTime</span><span class="p">(</span><span class="n">today</span><span class="p">)</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">SimpleXMLRPCServer</span><span class="p">((</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Listening on port 8000...&quot;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">today</span><span class="p">,</span> <span class="s2">&quot;today&quot;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>이전 서버에 대한 클라이언트 코드:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xmlrpc.client</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="n">proxy</span> <span class="o">=</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ServerProxy</span><span class="p">(</span><span class="s2">&quot;http://localhost:8000/&quot;</span><span class="p">)</span>

<span class="n">today</span> <span class="o">=</span> <span class="n">proxy</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>
<span class="c1"># ISO8601 문자열을 datetime 객체로 변환합니다</span>
<span class="n">converted</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">today</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">T%H:%M:%S&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Today: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">converted</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">.%m.%Y, %H:%M&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="binary-objects">
<span id="id3"></span><h2>Binary 객체<a class="headerlink" href="#binary-objects" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="xmlrpc.client.Binary">
<em class="property">class </em><code class="sig-prename descclassname">xmlrpc.client.</code><code class="sig-name descname">Binary</code><a class="headerlink" href="#xmlrpc.client.Binary" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 바이트열 데이터(NUL을 포함할 수 있습니다)로 초기화될 수 있습니다. <a class="reference internal" href="#xmlrpc.client.Binary" title="xmlrpc.client.Binary"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binary</span></code></a> 객체의 내용에 대한 기본 액세스는 어트리뷰트에 의해 제공됩니다:</p>
<dl class="attribute">
<dt id="xmlrpc.client.Binary.data">
<code class="sig-name descname">data</code><a class="headerlink" href="#xmlrpc.client.Binary.data" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#xmlrpc.client.Binary" title="xmlrpc.client.Binary"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binary</span></code></a> 인스턴스로 캡슐화된 바이너리 데이터. 데이터는 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체로 제공됩니다.</p>
</dd></dl>

<p><a class="reference internal" href="#xmlrpc.client.Binary" title="xmlrpc.client.Binary"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binary</span></code></a> 객체에는 주로 마샬링/역마샬링 코드 내부에서 사용하기 위해 지원되는 다음과 같은 메서드가 있습니다:</p>
<dl class="method">
<dt id="xmlrpc.client.Binary.decode">
<code class="sig-name descname">decode</code><span class="sig-paren">(</span><em class="sig-param">bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#xmlrpc.client.Binary.decode" title="정의 주소">¶</a></dt>
<dd><p>base64 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체를 받아들이고 인스턴스의 새 데이터로 디코딩합니다.</p>
</dd></dl>

<dl class="method">
<dt id="xmlrpc.client.Binary.encode">
<code class="sig-name descname">encode</code><span class="sig-paren">(</span><em class="sig-param">out</em><span class="sig-paren">)</span><a class="headerlink" href="#xmlrpc.client.Binary.encode" title="정의 주소">¶</a></dt>
<dd><p>이 바이너리 항목의 XML-RPC base64 인코딩을 <em>out</em> 스트림 객체에 씁니다.</p>
<p>인코딩된 데이터에는 <span class="target" id="index-2"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html#section-6.8"><strong>RFC 2045 섹션 6.8</strong></a>에 따라 76문자마다 줄 바꿈이 있는데, 이는 XML-RPC 명세가 작성될 때 사실상 표준 base64 명세였습니다.</p>
</dd></dl>

<p><a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>와 <a class="reference internal" href="../reference/datamodel.html#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> 메서드를 통해 특정 파이썬 내장 연산자도 지원합니다.</p>
</dd></dl>

<p>바이너리 객체의 사용 예. XMLRPC를 통해 이미지를 전송할 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="k">import</span> <span class="n">SimpleXMLRPCServer</span>
<span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="k">def</span> <span class="nf">python_logo</span><span class="p">():</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;python_logo.jpg&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">Binary</span><span class="p">(</span><span class="n">handle</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">SimpleXMLRPCServer</span><span class="p">((</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Listening on port 8000...&quot;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">python_logo</span><span class="p">,</span> <span class="s1">&#39;python_logo&#39;</span><span class="p">)</span>

<span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>클라이언트는 이미지를 가져와서 파일에 저장합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="n">proxy</span> <span class="o">=</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ServerProxy</span><span class="p">(</span><span class="s2">&quot;http://localhost:8000/&quot;</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;fetched_python_logo.jpg&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
    <span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">proxy</span><span class="o">.</span><span class="n">python_logo</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="fault-objects">
<span id="id4"></span><h2>Fault 객체<a class="headerlink" href="#fault-objects" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="xmlrpc.client.Fault">
<em class="property">class </em><code class="sig-prename descclassname">xmlrpc.client.</code><code class="sig-name descname">Fault</code><a class="headerlink" href="#xmlrpc.client.Fault" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#xmlrpc.client.Fault" title="xmlrpc.client.Fault"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fault</span></code></a> 객체는 XML-RPC 결함 태그의 내용을 캡슐화합니다. Fault 객체에는 다음과 같은 어트리뷰트가 있습니다:</p>
<dl class="attribute">
<dt id="xmlrpc.client.Fault.faultCode">
<code class="sig-name descname">faultCode</code><a class="headerlink" href="#xmlrpc.client.Fault.faultCode" title="정의 주소">¶</a></dt>
<dd><p>결함 형을 나타내는 문자열.</p>
</dd></dl>

<dl class="attribute">
<dt id="xmlrpc.client.Fault.faultString">
<code class="sig-name descname">faultString</code><a class="headerlink" href="#xmlrpc.client.Fault.faultString" title="정의 주소">¶</a></dt>
<dd><p>결함과 연관된 진단 메시지가 포함된 문자열.</p>
</dd></dl>

</dd></dl>

<p>다음 예제에서는 복소수 형의 객체를 반환하여 의도적으로 <a class="reference internal" href="#xmlrpc.client.Fault" title="xmlrpc.client.Fault"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Fault</span></code></a>를 발생시킵니다. 서버 코드:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="k">import</span> <span class="n">SimpleXMLRPCServer</span>

<span class="c1"># 복소수를 반환하기 때문에 마샬링 에러가 발생합니다</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">SimpleXMLRPCServer</span><span class="p">((</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Listening on port 8000...&quot;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">)</span>

<span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>이전 서버에 대한 클라이언트 코드:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="n">proxy</span> <span class="o">=</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ServerProxy</span><span class="p">(</span><span class="s2">&quot;http://localhost:8000/&quot;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">proxy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="k">except</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">Fault</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A fault occurred&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fault code: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="o">.</span><span class="n">faultCode</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fault string: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="o">.</span><span class="n">faultString</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="protocolerror-objects">
<span id="protocol-error-objects"></span><h2>ProtocolError 객체<a class="headerlink" href="#protocolerror-objects" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="xmlrpc.client.ProtocolError">
<em class="property">class </em><code class="sig-prename descclassname">xmlrpc.client.</code><code class="sig-name descname">ProtocolError</code><a class="headerlink" href="#xmlrpc.client.ProtocolError" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#xmlrpc.client.ProtocolError" title="xmlrpc.client.ProtocolError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProtocolError</span></code></a> 객체는 하부 전송 계층에서의 프로토콜 에러를 기술합니다 (가령 URI로 명명된 서버가 없을 때 404 'not found' 에러). 다음과 같은 어트리뷰트가 있습니다:</p>
<dl class="attribute">
<dt id="xmlrpc.client.ProtocolError.url">
<code class="sig-name descname">url</code><a class="headerlink" href="#xmlrpc.client.ProtocolError.url" title="정의 주소">¶</a></dt>
<dd><p>에러를 일으킨 URI나 URL.</p>
</dd></dl>

<dl class="attribute">
<dt id="xmlrpc.client.ProtocolError.errcode">
<code class="sig-name descname">errcode</code><a class="headerlink" href="#xmlrpc.client.ProtocolError.errcode" title="정의 주소">¶</a></dt>
<dd><p>에러 코드.</p>
</dd></dl>

<dl class="attribute">
<dt id="xmlrpc.client.ProtocolError.errmsg">
<code class="sig-name descname">errmsg</code><a class="headerlink" href="#xmlrpc.client.ProtocolError.errmsg" title="정의 주소">¶</a></dt>
<dd><p>에러 메시지나 진단 문자열.</p>
</dd></dl>

<dl class="attribute">
<dt id="xmlrpc.client.ProtocolError.headers">
<code class="sig-name descname">headers</code><a class="headerlink" href="#xmlrpc.client.ProtocolError.headers" title="정의 주소">¶</a></dt>
<dd><p>에러를 일으킨 HTTP/HTTPS 요청의 헤더를 포함하는 딕셔너리.</p>
</dd></dl>

</dd></dl>

<p>다음 예에서는 잘못된 URI를 제공하여 의도적으로 <a class="reference internal" href="#xmlrpc.client.ProtocolError" title="xmlrpc.client.ProtocolError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ProtocolError</span></code></a>를 발생시킵니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="c1"># XMLRPC 요청에 응답하지 않는 URI로 ServerProxy를 만듭니다</span>
<span class="n">proxy</span> <span class="o">=</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ServerProxy</span><span class="p">(</span><span class="s2">&quot;http://google.com/&quot;</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">proxy</span><span class="o">.</span><span class="n">some_method</span><span class="p">()</span>
<span class="k">except</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ProtocolError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A protocol error occurred&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;URL: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;HTTP/HTTPS headers: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="o">.</span><span class="n">headers</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error code: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="o">.</span><span class="n">errcode</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error message: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="o">.</span><span class="n">errmsg</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="multicall-objects">
<h2>MultiCall 객체<a class="headerlink" href="#multicall-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#xmlrpc.client.MultiCall" title="xmlrpc.client.MultiCall"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiCall</span></code></a> 객체는 원격 서버에 대한 여러 호출을 단일 요청으로 캡슐화하는 방법을 제공합니다 <a class="footnote-reference brackets" href="#id6" id="id5">1</a>.</p>
<dl class="class">
<dt id="xmlrpc.client.MultiCall">
<em class="property">class </em><code class="sig-prename descclassname">xmlrpc.client.</code><code class="sig-name descname">MultiCall</code><span class="sig-paren">(</span><em class="sig-param">server</em><span class="sig-paren">)</span><a class="headerlink" href="#xmlrpc.client.MultiCall" title="정의 주소">¶</a></dt>
<dd><p>boxcar 메서드 호출에 사용되는 객체를 만듭니다. <em>server</em>는 최종 호출 대상입니다. 결과 객체를 호출할 수 있지만, 즉시 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환하고, 호출 이름과 매개 변수를 <a class="reference internal" href="#xmlrpc.client.MultiCall" title="xmlrpc.client.MultiCall"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiCall</span></code></a> 객체에 저장하기만 합니다. 객체 자체를 호출하면 저장된 모든 호출이 단일 <code class="docutils literal notranslate"><span class="pre">system.multicall</span></code> 요청으로 전송됩니다. 이 호출의 결과는 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a>입니다; 이 제너레이터를 이터레이트 하면 개별 결과를 산출합니다.</p>
</dd></dl>

<p>이 클래스의 사용 예는 다음과 같습니다. 서버 코드:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xmlrpc.server</span> <span class="k">import</span> <span class="n">SimpleXMLRPCServer</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">//</span> <span class="n">y</span>

<span class="c1"># 간단한 산술 함수들이 있는 간단한 서버</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">SimpleXMLRPCServer</span><span class="p">((</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Listening on port 8000...&quot;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_multicall_functions</span><span class="p">()</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">subtract</span><span class="p">,</span> <span class="s1">&#39;subtract&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">multiply</span><span class="p">,</span> <span class="s1">&#39;multiply&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">register_function</span><span class="p">(</span><span class="n">divide</span><span class="p">,</span> <span class="s1">&#39;divide&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>이전 서버에 대한 클라이언트 코드:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="n">proxy</span> <span class="o">=</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ServerProxy</span><span class="p">(</span><span class="s2">&quot;http://localhost:8000/&quot;</span><span class="p">)</span>
<span class="n">multicall</span> <span class="o">=</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">MultiCall</span><span class="p">(</span><span class="n">proxy</span><span class="p">)</span>
<span class="n">multicall</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">multicall</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">multicall</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">multicall</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">multicall</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;7+3=</span><span class="si">%d</span><span class="s2">, 7-3=</span><span class="si">%d</span><span class="s2">, 7*3=</span><span class="si">%d</span><span class="s2">, 7//3=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="convenience-functions">
<h2>편의 함수<a class="headerlink" href="#convenience-functions" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="xmlrpc.client.dumps">
<code class="sig-prename descclassname">xmlrpc.client.</code><code class="sig-name descname">dumps</code><span class="sig-paren">(</span><em class="sig-param">params</em>, <em class="sig-param">methodname=None</em>, <em class="sig-param">methodresponse=None</em>, <em class="sig-param">encoding=None</em>, <em class="sig-param">allow_none=False</em><span class="sig-paren">)</span><a class="headerlink" href="#xmlrpc.client.dumps" title="정의 주소">¶</a></dt>
<dd><p><em>params</em>를 XML-RPC 요청으로, 또는 <em>methodresponse</em>가 참이면 응답으로 변환합니다. <em>params</em>는 인자의 튜플이거나 <a class="reference internal" href="#xmlrpc.client.Fault" title="xmlrpc.client.Fault"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Fault</span></code></a> 예외 클래스의 인스턴스일 수 있습니다. <em>methodresponse</em>가 참이면, 단일 값만 반환될 수 있는데, <em>params</em>의 길이가 1이어야 한다는 뜻입니다. 제공되면, <em>encoding</em>은 생성된 XML에서 사용할 인코딩입니다; 기본값은 UTF-8입니다. 파이썬의 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 값은 표준 XML-RPC에서 사용할 수 없습니다; 확장을 통해 이를 사용하려면 <em>allow_none</em>에 참값을 제공하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="xmlrpc.client.loads">
<code class="sig-prename descclassname">xmlrpc.client.</code><code class="sig-name descname">loads</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">use_datetime=False</em>, <em class="sig-param">use_builtin_types=False</em><span class="sig-paren">)</span><a class="headerlink" href="#xmlrpc.client.loads" title="정의 주소">¶</a></dt>
<dd><p>XML-RPC 요청이나 응답을 파이썬 객체 <code class="docutils literal notranslate"><span class="pre">(params,</span> <span class="pre">methodname)</span></code>로 변환합니다. <em>params</em>는 인자의 튜플입니다; <em>methodname</em>은 문자열이거나 패킷에 메서드 이름이 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. XML-RPC 패킷이 결함 조건을 나타내면, 이 함수는 <a class="reference internal" href="#xmlrpc.client.Fault" title="xmlrpc.client.Fault"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Fault</span></code></a> 예외를 발생시킵니다. <em>use_builtin_types</em> 플래그를 사용하여 날짜/시간 값을 <a class="reference internal" href="datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a> 객체로 표현하고 바이너리 데이터를 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체로 표현할 수 있습니다; 이 플래그는 기본적으로 거짓입니다.</p>
<p>사용되지 않는 <em>use_datetime</em> 플래그는 <em>use_builtin_types</em>와 유사하지만, 날짜/시간 값에만 적용됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><em>use_builtin_types</em> 플래그가 추가되었습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="example-of-client-usage">
<span id="xmlrpc-client-example"></span><h2>클라이언트 사용 예<a class="headerlink" href="#example-of-client-usage" title="제목 주소">¶</a></h2>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 간단한 테스트 프로그램 (XML-RPC 명세에서 인용)</span>
<span class="kn">from</span> <span class="nn">xmlrpc.client</span> <span class="k">import</span> <span class="n">ServerProxy</span><span class="p">,</span> <span class="n">Error</span>

<span class="c1"># server = ServerProxy(&quot;http://localhost:8000&quot;) # 로컬 서버</span>
<span class="k">with</span> <span class="n">ServerProxy</span><span class="p">(</span><span class="s2">&quot;http://betty.userland.com&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">proxy</span><span class="p">:</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">proxy</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">proxy</span><span class="o">.</span><span class="n">examples</span><span class="o">.</span><span class="n">getStateName</span><span class="p">(</span><span class="mi">41</span><span class="p">))</span>
    <span class="k">except</span> <span class="n">Error</span> <span class="k">as</span> <span class="n">v</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ERROR&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>HTTP 프락시를 통해 XML-RPC 서버에 액세스하려면, 사용자 정의 트랜스포트를 정의해야 합니다. 다음 예제는 방법을 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">http.client</span>
<span class="kn">import</span> <span class="nn">xmlrpc.client</span>

<span class="k">class</span> <span class="nc">ProxiedTransport</span><span class="p">(</span><span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">Transport</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">set_proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proxy</span> <span class="o">=</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proxy_headers</span> <span class="o">=</span> <span class="n">headers</span>

    <span class="k">def</span> <span class="nf">make_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">):</span>
        <span class="n">connection</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">HTTPConnection</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">proxy</span><span class="p">)</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">set_tunnel</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">proxy_headers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">host</span><span class="p">,</span> <span class="n">connection</span>
        <span class="k">return</span> <span class="n">connection</span>

<span class="n">transport</span> <span class="o">=</span> <span class="n">ProxiedTransport</span><span class="p">()</span>
<span class="n">transport</span><span class="o">.</span><span class="n">set_proxy</span><span class="p">(</span><span class="s1">&#39;proxy-server&#39;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">)</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">xmlrpc</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">ServerProxy</span><span class="p">(</span><span class="s1">&#39;http://betty.userland.com&#39;</span><span class="p">,</span> <span class="n">transport</span><span class="o">=</span><span class="n">transport</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">server</span><span class="o">.</span><span class="n">examples</span><span class="o">.</span><span class="n">getStateName</span><span class="p">(</span><span class="mi">41</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="example-of-client-and-server-usage">
<h2>클라이언트와 서버 사용 예<a class="headerlink" href="#example-of-client-and-server-usage" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="xmlrpc.server.html#simplexmlrpcserver-example"><span class="std std-ref">SimpleXMLRPCServer 예제</span></a>를 참조하십시오.</p>
<p class="rubric">각주</p>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id5">1</a></span></dt>
<dd><p>이 접근법은 <a class="reference external" href="https://web.archive.org/web/20060624230303/http://www.xmlrpc.com/discuss/msgReader$1208?mode=topic">xmlrpc.com에서의 토론</a>에서 처음 제시되었습니다.</p>
</dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc.client</span></code> --- XML-RPC 클라이언트 액세스</a><ul>
<li><a class="reference internal" href="#serverproxy-objects">ServerProxy 객체</a></li>
<li><a class="reference internal" href="#datetime-objects">DateTime 객체</a></li>
<li><a class="reference internal" href="#binary-objects">Binary 객체</a></li>
<li><a class="reference internal" href="#fault-objects">Fault 객체</a></li>
<li><a class="reference internal" href="#protocolerror-objects">ProtocolError 객체</a></li>
<li><a class="reference internal" href="#multicall-objects">MultiCall 객체</a></li>
<li><a class="reference internal" href="#convenience-functions">편의 함수</a></li>
<li><a class="reference internal" href="#example-of-client-usage">클라이언트 사용 예</a></li>
<li><a class="reference internal" href="#example-of-client-and-server-usage">클라이언트와 서버 사용 예</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="xmlrpc.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc</span></code> --- XMLRPC 서버와 클라이언트 모듈</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="xmlrpc.server.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc.server</span></code> --- 기본 XML-RPC 서버</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="xmlrpc.server.html" title="xmlrpc.server --- 기본 XML-RPC 서버"
             >다음</a> |</li>
        <li class="right" >
          <a href="xmlrpc.html" title="xmlrpc --- XMLRPC 서버와 클라이언트 모듈"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>