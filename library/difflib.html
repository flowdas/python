
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>difflib --- 델타 계산을 위한 도우미 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="textwrap --- 텍스트 래핑과 채우기" href="textwrap.html" />
    <link rel="prev" title="re --- 정규식 연산" href="re.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/difflib.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="textwrap.html" title="textwrap --- 텍스트 래핑과 채우기"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="re.html" title="re --- 정규식 연산"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="text.html" accesskey="U">텍스트 처리 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-difflib">
<span id="difflib-helpers-for-computing-deltas"></span><h1><a class="reference internal" href="#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code></a> --- 델타 계산을 위한 도우미<a class="headerlink" href="#module-difflib" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/difflib.py">Lib/difflib.py</a></p>
<hr class="docutils" />
<p>이 모듈은 시퀀스 비교를 위한 클래스와 함수를 제공합니다. 예를 들어 파일을 비교하는 데 사용할 수 있으며, HTML 및 문맥(context)과 통합(unified) diff를 비롯한 다양한 형식의 차이 정보를 생성할 수 있습니다. 디렉터리와 파일을 비교하려면, <a class="reference internal" href="filecmp.html#module-filecmp" title="filecmp: Compare files efficiently."><code class="xref py py-mod docutils literal notranslate"><span class="pre">filecmp</span></code></a> 모듈을 참조하십시오.</p>
<dl class="class">
<dt id="difflib.SequenceMatcher">
<em class="property">class </em><code class="descclassname">difflib.</code><code class="descname">SequenceMatcher</code><a class="headerlink" href="#difflib.SequenceMatcher" title="정의 주소">¶</a></dt>
<dd><p>이것은 시퀀스 요소가 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a>이기만 하다면, 모든 형의 시퀀스 쌍을 비교할 수 있는 유연한 클래스입니다. 기본 알고리즘은 1980년대 후반에 Ratcliff와 Obershelp가 '게슈탈트 패턴 매칭(gestalt pattern matching)'이라는 과장된 이름으로 발표한 알고리즘까지 거슬러 올라가는데, 그보다는 약간 더 공을 들였습니다. 아이디어는 &quot;정크&quot; 요소가 없는 가장 긴 연속적으로 일치하는 서브 시퀀스를 찾는 것입니다; 이러한 &quot;정크&quot; 요소는 빈 줄이나 공백과 같은 어떤 의미에서는 흥미롭지 않은 요소들입니다. (정크 처리는 Ratcliff와 Obershelp 알고리즘의 확장입니다.) 그런 다음 같은 아이디어를 일치하는 서브 시퀀스의 왼쪽과 오른쪽에 있는 시퀀스 조각에 재귀적으로 적용합니다. 이것이 최소 편집 시퀀스를 산출하지는 않지만, 사람들에게 &quot;그럴듯해 보이는&quot; 일치를 산출하는 경향이 있습니다.</p>
<p><strong>타이밍:</strong> 기본 Ratcliff-Obershelp 알고리즘은 최악의 상황(worst case)에 세제곱 시간이고, 평균적으로(expected case) 제곱 시간입니다. <a class="reference internal" href="#difflib.SequenceMatcher" title="difflib.SequenceMatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></a>는 최악의 상황에 제곱 시간이며, 평균적인 동작은 시퀀스에 공통으로 포함된 요소의 수에 따라 복잡한 방식으로 달라집니다; 최상의 경우(best cast)는 선형 시간입니다.</p>
<p><strong>자동 정크 휴리스틱:</strong> <a class="reference internal" href="#difflib.SequenceMatcher" title="difflib.SequenceMatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></a>는 특정 시퀀스 항목을 자동으로 정크로 처리하는 경험적 방법을 지원합니다. 경험적 방법은 개별 항목이 시퀀스에 나타나는 횟수를 계산합니다. (첫 번째 항목 이후의) 중복된 항목이 시퀀스의 1% 이상을 차지하고 시퀀스의 길이가 최소 200항목 이상이면, 이 항목은 &quot;흔한&quot; 것으로 표시되고 시퀀스 일치를 위해 정크로 처리됩니다. 이 경험적 방법은 <a class="reference internal" href="#difflib.SequenceMatcher" title="difflib.SequenceMatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></a>를 만들 때 <code class="docutils literal notranslate"><span class="pre">autojunk</span></code> 인자를 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 설정하여 끌 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가: </span><em>autojunk</em> 매개 변수.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="difflib.Differ">
<em class="property">class </em><code class="descclassname">difflib.</code><code class="descname">Differ</code><a class="headerlink" href="#difflib.Differ" title="정의 주소">¶</a></dt>
<dd><p>이것은 텍스트 줄의 시퀀스를 비교하고, 사람이 읽을 수 있는 차이 또는 델타를 생성하는 클래스입니다. Differ는 줄의 시퀀스를 비교하고, 유사한 (거의 일치하는) 줄 내의 문자 시퀀스를 비교하는데 <a class="reference internal" href="#difflib.SequenceMatcher" title="difflib.SequenceMatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></a>를 사용합니다.</p>
<p><a class="reference internal" href="#difflib.Differ" title="difflib.Differ"><code class="xref py py-class docutils literal notranslate"><span class="pre">Differ</span></code></a> 델타의 각 줄은 2자 코드로 시작합니다:</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 19%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>코드</p></th>
<th class="head"><p>뜻</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'-</span> <span class="pre">'</span></code></p></td>
<td><p>시퀀스 1에만 있는 줄</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'+</span> <span class="pre">'</span></code></p></td>
<td><p>시퀀스 2에만 있는 줄</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'</span>&#160; <span class="pre">'</span></code></p></td>
<td><p>두 시퀀스에 공통인 줄</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'?</span> <span class="pre">'</span></code></p></td>
<td><p>두 입력 시퀀스에 없는 줄</p></td>
</tr>
</tbody>
</table>
<p>'<code class="docutils literal notranslate"><span class="pre">?</span></code>'로 시작하는 줄은, 시선을 줄 내의 차이로 유도하려고 시도하며, 두 입력 시퀀스 어디에도 나타나지 않습니다. 이 줄은 시퀀스에 탭 문자가 포함되면 혼동을 줄 수 있습니다.</p>
</dd></dl>

<dl class="class">
<dt id="difflib.HtmlDiff">
<em class="property">class </em><code class="descclassname">difflib.</code><code class="descname">HtmlDiff</code><a class="headerlink" href="#difflib.HtmlDiff" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 HTML 표를 (또는 표를 포함하는 완전한 HTML 파일을) 만드는 데 사용할 수 있습니다. 이 HTML은 줄 간과 줄 내의 변경을 강조하면서, 텍스트를 나란히 줄 단위로 비교하여 보여줍니다. 표는 전체 또는 문맥 차이 모드로 생성될 수 있습니다.</p>
<p>이 클래스의 생성자는 다음과 같습니다:</p>
<dl class="method">
<dt id="difflib.HtmlDiff.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>tabsize=8</em>, <em>wrapcolumn=None</em>, <em>linejunk=None</em>, <em>charjunk=IS_CHARACTER_JUNK</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.HtmlDiff.__init__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#difflib.HtmlDiff" title="difflib.HtmlDiff"><code class="xref py py-class docutils literal notranslate"><span class="pre">HtmlDiff</span></code></a>의 인스턴스를 초기화합니다.</p>
<p><em>tabsize</em>는 탭 간격을 지정하는 선택적 키워드 인자이며 기본값은 <code class="docutils literal notranslate"><span class="pre">8</span></code>입니다.</p>
<p><em>wrapcolumn</em>는 줄이 자동 줄 넘김 되는 열 번호를 지정하는 선택적 키워드로, 줄을 자동 줄 넘김 하지 않는 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 기본값입니다.</p>
<p><em>linejunk</em> 와 <em>charjunk</em>는 <a class="reference internal" href="#difflib.ndiff" title="difflib.ndiff"><code class="xref py py-func docutils literal notranslate"><span class="pre">ndiff()</span></code></a>(<a class="reference internal" href="#difflib.HtmlDiff" title="difflib.HtmlDiff"><code class="xref py py-class docutils literal notranslate"><span class="pre">HtmlDiff</span></code></a>가 나란히 배치된 HTML 차이를 만드는 데 사용됩니다)로 전달되는 선택적 키워드 인자입니다. 인자 기본값과 설명은 <a class="reference internal" href="#difflib.ndiff" title="difflib.ndiff"><code class="xref py py-func docutils literal notranslate"><span class="pre">ndiff()</span></code></a> 설명서를 참조하십시오.</p>
</dd></dl>

<p>다음과 같은 메서드가 공개됩니다:</p>
<dl class="method">
<dt id="difflib.HtmlDiff.make_file">
<code class="descname">make_file</code><span class="sig-paren">(</span><em>fromlines</em>, <em>tolines</em>, <em>fromdesc=''</em>, <em>todesc=''</em>, <em>context=False</em>, <em>numlines=5</em>, <em>*</em>, <em>charset='utf-8'</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.HtmlDiff.make_file" title="정의 주소">¶</a></dt>
<dd><p><em>fromlines</em> 와 <em>tolines</em>(문자열의 리스트)를 비교하고, 줄 간 및 줄 내부의 변경을 강조하면서, 줄 단위로 차이를 보여주는 표를 포함하는 완전한 HTML 파일을 문자열로 반환합니다.</p>
<p><em>fromdesc</em> 와 <em>todesc</em>는 from/to 파일 열 헤더 문자열을 지정하는 선택적 키워드 인자입니다 (기본값은 모두 빈 문자열입니다).</p>
<p><em>context</em> 와 <em>numlines</em>는 모두 선택적 키워드 인자입니다. 문맥 차이를 표시하려면 <em>context</em>를 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정하십시오, 그렇지 않으면 기본값은 전체 파일을 표시하는 <code class="docutils literal notranslate"><span class="pre">False</span></code>입니다. <em>numlines</em>의 기본값은 <code class="docutils literal notranslate"><span class="pre">5</span></code>입니다. <em>context</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code> 일 때, <em>numlines</em>는 차이 하이라이트를 둘러싸는 문맥 줄의 수를 제어합니다. <em>context</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>면 <em>numlines</em>는 &quot;next&quot; 하이퍼 링크를 사용할 때 차이 하이라이트 앞에 표시되는 줄 수를 제어합니다 (0으로 설정하면 &quot;next&quot; 하이퍼 링크가 다음 차이 하이라이트를 아무런 선행 문맥 줄 없이 브라우저의 맨 위에 놓도록 합니다).</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>&quot;next&quot; 하이퍼 링크는 만들어진 HTML 의 첫번째 열에 &quot;n&quot; (처음은 &quot;f&quot;) 로 표시되는 링크를 뜻합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><em>charset</em> 키워드 전용 인자가 추가되었습니다. HTML 문서의 기본 문자 집합이 <code class="docutils literal notranslate"><span class="pre">'ISO-8859-1'</span></code>에서 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>로 변경되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="difflib.HtmlDiff.make_table">
<code class="descname">make_table</code><span class="sig-paren">(</span><em>fromlines</em>, <em>tolines</em>, <em>fromdesc=''</em>, <em>todesc=''</em>, <em>context=False</em>, <em>numlines=5</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.HtmlDiff.make_table" title="정의 주소">¶</a></dt>
<dd><p><em>fromlines</em> 와 <em>tolines</em>(문자열의 리스트)를 비교하고, 줄 간 및 줄 내부의 변경을 강조하면서, 줄 단위로 차이를 보여주는 완전한 HTML 표를 문자열로 반환합니다.</p>
<p>이 메서드의 인자는 <a class="reference internal" href="#difflib.HtmlDiff.make_file" title="difflib.HtmlDiff.make_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_file()</span></code></a> 메서드의 인자와 같습니다.</p>
</dd></dl>

<p><code class="file docutils literal notranslate"><span class="pre">Tools/scripts/diff.py</span></code>는 이 클래스의 명령 줄 프런트엔드며, 좋은 사용 예를 담고 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="difflib.context_diff">
<code class="descclassname">difflib.</code><code class="descname">context_diff</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>fromfile=''</em>, <em>tofile=''</em>, <em>fromfiledate=''</em>, <em>tofiledate=''</em>, <em>n=3</em>, <em>lineterm='\n'</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.context_diff" title="정의 주소">¶</a></dt>
<dd><p><em>a</em>와 <em>b</em>(문자열의 리스트)를 비교합니다; 델타(델타 줄을 생성하는 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a>)를 문맥 diff 형식으로 반환합니다.</p>
<p>문맥 diff는 단지 변경된 줄과 몇 줄의 문맥만을 더해서 표시하는 간결한 방법입니다. 변경 사항은 이전/이후 스타일로 표시됩니다. 문맥 줄의 수는 <em>n</em>에 의해 설정되며 기본값은 3입니다.</p>
<p>기본적으로, diff 제어 줄(<code class="docutils literal notranslate"><span class="pre">***</span></code>나 <code class="docutils literal notranslate"><span class="pre">---</span></code>가 포함된 것)은 끝에 줄 넘김을 붙여 만들어집니다. 이것은 <a class="reference internal" href="io.html#io.IOBase.readlines" title="io.IOBase.readlines"><code class="xref py py-func docutils literal notranslate"><span class="pre">io.IOBase.readlines()</span></code></a>로 만들어진 입력이 <a class="reference internal" href="io.html#io.IOBase.writelines" title="io.IOBase.writelines"><code class="xref py py-func docutils literal notranslate"><span class="pre">io.IOBase.writelines()</span></code></a>와 함께 사용하기에 적합한 diff를 생성하도록 하는 데 유용합니다. 왜냐하면, 입력과 출력 모두 끝에 줄 넘김이 있기 때문입니다.</p>
<p>끝에 줄 넘김이 없는 입력이면, <em>lineterm</em> 인자를 <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>로 설정해서 출력에 일관되게 줄 넘김이 포함되지 않게 하십시오.</p>
<p>문맥 diff 형식에는 일반적으로 파일명과 수정 시간에 대한 헤더가 있습니다. 이들 중 일부 또는 전부는 <em>fromfile</em>, <em>tofile</em>, <em>fromfiledate</em> 및 <em>tofiledate</em>에 문자열을 사용하여 지정될 수 있습니다. 수정 시간은 일반적으로 ISO 8601 형식으로 표현됩니다. 지정하지 않으면, 문자열들의 기본값은 빈 문자열입니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bacon</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;eggs</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;ham</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;guido</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;python</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;eggy</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;hamster</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;guido</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">context_diff</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">fromfile</span><span class="o">=</span><span class="s1">&#39;before.py&#39;</span><span class="p">,</span> <span class="n">tofile</span><span class="o">=</span><span class="s1">&#39;after.py&#39;</span><span class="p">))</span>
<span class="go">*** before.py</span>
<span class="go">--- after.py</span>
<span class="go">***************</span>
<span class="go">*** 1,4 ****</span>
<span class="go">! bacon</span>
<span class="go">! eggs</span>
<span class="go">! ham</span>
<span class="go">  guido</span>
<span class="go">--- 1,4 ----</span>
<span class="go">! python</span>
<span class="go">! eggy</span>
<span class="go">! hamster</span>
<span class="go">  guido</span>
</pre></div>
</div>
<p>더욱 자세한 예제는 <a class="reference internal" href="#difflib-interface"><span class="std std-ref">difflib의 명령 줄 인터페이스</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="difflib.get_close_matches">
<code class="descclassname">difflib.</code><code class="descname">get_close_matches</code><span class="sig-paren">(</span><em>word</em>, <em>possibilities</em>, <em>n=3</em>, <em>cutoff=0.6</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.get_close_matches" title="정의 주소">¶</a></dt>
<dd><p>최상의 &quot;충분히 좋은&quot; 일치의 리스트를 반환합니다. <em>word</em>는 근접 일치가 목표로 하는 시퀀스(일반적으로 문자열)며, <em>possibilities</em>는 <em>word</em>와 일치시킬 시퀀스의 리스트입니다 (일반적으로 문자열의 리스트).</p>
<p>선택적 인자 <em>n</em>(기본값 <code class="docutils literal notranslate"><span class="pre">3</span></code>)은 반환할 근접 일치의 최대 개수입니다; <em>n</em>는 <code class="docutils literal notranslate"><span class="pre">0</span></code>보다 커야 합니다.</p>
<p>선택적 인자 <em>cutoff</em>(기본값 <code class="docutils literal notranslate"><span class="pre">0.6</span></code>)는 [0, 1] 범위의 float입니다. <em>word</em>와의 유사성 점수가 이 값보다 적은 possibilities는 무시됩니다.</p>
<p>possibilities 중에서 가장 좋은 (최대 <em>n</em> 개의) 일치가 리스트로 반환되는데, 유사성 점수로 정렬되어 있고 가장 유사한 것이 먼저 나옵니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">get_close_matches</span><span class="p">(</span><span class="s1">&#39;appel&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;ape&#39;</span><span class="p">,</span> <span class="s1">&#39;apple&#39;</span><span class="p">,</span> <span class="s1">&#39;peach&#39;</span><span class="p">,</span> <span class="s1">&#39;puppy&#39;</span><span class="p">])</span>
<span class="go">[&#39;apple&#39;, &#39;ape&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">keyword</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_close_matches</span><span class="p">(</span><span class="s1">&#39;wheel&#39;</span><span class="p">,</span> <span class="n">keyword</span><span class="o">.</span><span class="n">kwlist</span><span class="p">)</span>
<span class="go">[&#39;while&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_close_matches</span><span class="p">(</span><span class="s1">&#39;pineapple&#39;</span><span class="p">,</span> <span class="n">keyword</span><span class="o">.</span><span class="n">kwlist</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_close_matches</span><span class="p">(</span><span class="s1">&#39;accept&#39;</span><span class="p">,</span> <span class="n">keyword</span><span class="o">.</span><span class="n">kwlist</span><span class="p">)</span>
<span class="go">[&#39;except&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="difflib.ndiff">
<code class="descclassname">difflib.</code><code class="descname">ndiff</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>linejunk=None</em>, <em>charjunk=IS_CHARACTER_JUNK</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.ndiff" title="정의 주소">¶</a></dt>
<dd><p><em>a</em>와 <em>b</em>(문자열의 리스트)를 비교합니다; <a class="reference internal" href="#difflib.Differ" title="difflib.Differ"><code class="xref py py-class docutils literal notranslate"><span class="pre">Differ</span></code></a>-스타일 델타(델타 줄을 생성하는 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a>)를 반환합니다.</p>
<p>선택적 키워드 매개 변수 <em>linejunk</em> 와 <em>charjunk</em>는 필터링 함수(또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>)입니다:</p>
<p><em>linejunk</em>: 단일 문자열 인자를 받아들이고 문자열이 정크면 참을 반환하고, 그렇지 않으면 거짓을 반환하는 함수입니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. 모듈 수준의 함수 <a class="reference internal" href="#difflib.IS_LINE_JUNK" title="difflib.IS_LINE_JUNK"><code class="xref py py-func docutils literal notranslate"><span class="pre">IS_LINE_JUNK()</span></code></a>도 있는데, 최대로 한 개의 파운드 문자(<code class="docutils literal notranslate"><span class="pre">'#'</span></code>)를 제외하고 눈에 보이는 문자가 없는 줄을 걸러냅니다 -- 하지만 하부 <a class="reference internal" href="#difflib.SequenceMatcher" title="difflib.SequenceMatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></a> 클래스는 어떤 줄이 잡음으로 볼만큼 자주 등장하는지 동적으로 분석하고, 이것이 보통 이 함수를 사용하는 것보다 효과적입니다.</p>
<p><em>charjunk</em>: 문자(길이 1의 문자열)를 받아들이고, 문자가 정크면 참을 반환하고, 그렇지 않으면 거짓을 반환하는 함수입니다. 기본값은 모듈 수준의 함수 <a class="reference internal" href="#difflib.IS_CHARACTER_JUNK" title="difflib.IS_CHARACTER_JUNK"><code class="xref py py-func docutils literal notranslate"><span class="pre">IS_CHARACTER_JUNK()</span></code></a>인데, 공백 문자(스페이스나 탭; 줄 넘김 문자를 포함하는 것은 좋은 생각이 아닙니다)를 걸러냅니다.</p>
<p><code class="file docutils literal notranslate"><span class="pre">Tools/scripts/ndiff.py</span></code>는 이 함수에 대한 명령 줄 프런트엔드 입니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span> <span class="o">=</span> <span class="n">ndiff</span><span class="p">(</span><span class="s1">&#39;one</span><span class="se">\n</span><span class="s1">two</span><span class="se">\n</span><span class="s1">three</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
<span class="gp">... </span>             <span class="s1">&#39;ore</span><span class="se">\n</span><span class="s1">tree</span><span class="se">\n</span><span class="s1">emu</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">diff</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="go">- one</span>
<span class="go">?  ^</span>
<span class="go">+ ore</span>
<span class="go">?  ^</span>
<span class="go">- two</span>
<span class="go">- three</span>
<span class="go">?  -</span>
<span class="go">+ tree</span>
<span class="go">+ emu</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="difflib.restore">
<code class="descclassname">difflib.</code><code class="descname">restore</code><span class="sig-paren">(</span><em>sequence</em>, <em>which</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.restore" title="정의 주소">¶</a></dt>
<dd><p>델타를 만든 두 시퀀스 중 하나를 반환합니다.</p>
<p><a class="reference internal" href="#difflib.Differ.compare" title="difflib.Differ.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Differ.compare()</span></code></a> 나 <a class="reference internal" href="#difflib.ndiff" title="difflib.ndiff"><code class="xref py py-func docutils literal notranslate"><span class="pre">ndiff()</span></code></a>로 만들어진 <em>sequence</em>가 주어지면, 파일 1이나 2(매개 변수 <em>which</em>)에서 원래 제공되었던 줄을 추출하고, 줄 접두어를 제거합니다.</p>
<p>예:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span> <span class="o">=</span> <span class="n">ndiff</span><span class="p">(</span><span class="s1">&#39;one</span><span class="se">\n</span><span class="s1">two</span><span class="se">\n</span><span class="s1">three</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
<span class="gp">... </span>             <span class="s1">&#39;ore</span><span class="se">\n</span><span class="s1">tree</span><span class="se">\n</span><span class="s1">emu</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="c1"># 생성된 델타를 리스트로 구체화합니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">restore</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="go">one</span>
<span class="go">two</span>
<span class="go">three</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">restore</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="go">ore</span>
<span class="go">tree</span>
<span class="go">emu</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="difflib.unified_diff">
<code class="descclassname">difflib.</code><code class="descname">unified_diff</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>fromfile=''</em>, <em>tofile=''</em>, <em>fromfiledate=''</em>, <em>tofiledate=''</em>, <em>n=3</em>, <em>lineterm='\n'</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.unified_diff" title="정의 주소">¶</a></dt>
<dd><p><em>a</em>와 <em>b</em>(문자열의 리스트)를 비교합니다; 델타(델타 줄을 생성하는 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a>)를 통합 diff 형식으로 반환합니다.</p>
<p>통합(unified) diff는 단지 변경된 줄과 몇 줄의 문맥만을 더해서 표시하는 간결한 방법입니다. 변경 사항은 (별도의 이전/이후 블록 대신) 인라인 스타일로 표시됩니다. 문맥 줄의 수는 <em>n</em>에 의해 설정되며 기본값은 3입니다.</p>
<p>기본적으로, diff 제어 줄(<code class="docutils literal notranslate"><span class="pre">---</span></code>, <code class="docutils literal notranslate"><span class="pre">+++</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>가 포함된 것)은 끝에 줄 넘김을 붙여 만들어집니다. 이것은 <a class="reference internal" href="io.html#io.IOBase.readlines" title="io.IOBase.readlines"><code class="xref py py-func docutils literal notranslate"><span class="pre">io.IOBase.readlines()</span></code></a>로 만들어진 입력이 <a class="reference internal" href="io.html#io.IOBase.writelines" title="io.IOBase.writelines"><code class="xref py py-func docutils literal notranslate"><span class="pre">io.IOBase.writelines()</span></code></a>와 함께 사용하기에 적합한 diff를 생성하도록 하는 데 유용합니다. 왜냐하면, 입력과 출력 모두 끝에 줄 넘김이 있기 때문입니다.</p>
<p>끝에 줄 넘김이 없는 입력이면, <em>lineterm</em> 인자를 <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>로 설정해서 출력에 일관되게 줄 넘김이 포함되지 않게 하십시오.</p>
<p>문맥 diff 형식에는 일반적으로 파일명과 수정 시간에 대한 헤더가 있습니다. 이들 중 일부 또는 전부는 <em>fromfile</em>, <em>tofile</em>, <em>fromfiledate</em> 및 <em>tofiledate</em>에 문자열을 사용하여 지정될 수 있습니다. 수정 시간은 일반적으로 ISO 8601 형식으로 표현됩니다. 지정하지 않으면, 문자열들의 기본값은 빈 문자열입니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bacon</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;eggs</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;ham</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;guido</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;python</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;eggy</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;hamster</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;guido</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">unified_diff</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">fromfile</span><span class="o">=</span><span class="s1">&#39;before.py&#39;</span><span class="p">,</span> <span class="n">tofile</span><span class="o">=</span><span class="s1">&#39;after.py&#39;</span><span class="p">))</span>
<span class="go">--- before.py</span>
<span class="go">+++ after.py</span>
<span class="go">@@ -1,4 +1,4 @@</span>
<span class="go">-bacon</span>
<span class="go">-eggs</span>
<span class="go">-ham</span>
<span class="go">+python</span>
<span class="go">+eggy</span>
<span class="go">+hamster</span>
<span class="go"> guido</span>
</pre></div>
</div>
<p>더욱 자세한 예제는 <a class="reference internal" href="#difflib-interface"><span class="std std-ref">difflib의 명령 줄 인터페이스</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="difflib.diff_bytes">
<code class="descclassname">difflib.</code><code class="descname">diff_bytes</code><span class="sig-paren">(</span><em>dfunc</em>, <em>a</em>, <em>b</em>, <em>fromfile=b''</em>, <em>tofile=b''</em>, <em>fromfiledate=b''</em>, <em>tofiledate=b''</em>, <em>n=3</em>, <em>lineterm=b'\n'</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.diff_bytes" title="정의 주소">¶</a></dt>
<dd><p><em>a</em>와 <em>b</em>(바이트열 객체의 리스트)를 <em>dfunc</em>를 사용하여 비교합니다; <em>dfunc</em>가 반환하는 형식으로 델타 줄(역시 바이트열)의 시퀀스를 산출합니다. <em>dfunc</em>는 콜러블이어야하며, 보통 <a class="reference internal" href="#difflib.unified_diff" title="difflib.unified_diff"><code class="xref py py-func docutils literal notranslate"><span class="pre">unified_diff()</span></code></a> 나 <a class="reference internal" href="#difflib.context_diff" title="difflib.context_diff"><code class="xref py py-func docutils literal notranslate"><span class="pre">context_diff()</span></code></a>입니다.</p>
<p>알 수 없거나 일관성 없는 인코딩의 데이터를 비교할 수 있게 합니다. <em>n</em>를 제외한 모든 입력은 바이트열 객체여야 합니다, str이 아닙니다. 모든 입력(<em>n</em> 제외)을 str로 무손실 변환하고, <code class="docutils literal notranslate"><span class="pre">dfunc(a,</span> <span class="pre">b,</span> <span class="pre">fromfile,</span> <span class="pre">tofile,</span> <span class="pre">fromfiledate,</span> <span class="pre">tofiledate,</span> <span class="pre">n,</span> <span class="pre">lineterm)</span></code>를 호출하는 방식으로 작동합니다. <em>dfunc</em>의 출력은 다시 바이트로 변환되므로, 여러분이 얻는 델타 줄은 <em>a</em>와 <em>b</em> 처럼 알 수 없고/일관성 없는 인코딩을 갖습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="difflib.IS_LINE_JUNK">
<code class="descclassname">difflib.</code><code class="descname">IS_LINE_JUNK</code><span class="sig-paren">(</span><em>line</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.IS_LINE_JUNK" title="정의 주소">¶</a></dt>
<dd><p>무시할 수 있는 줄이면 참을 반환합니다. <em>line</em>이 빈 줄이거나 하나의 <code class="docutils literal notranslate"><span class="pre">'#'</span></code>를 포함하면, 줄 <em>line</em>은 무시할 수 있습니다, 그렇지 않으면 무시할 수 없습니다. 이전 버전의 <a class="reference internal" href="#difflib.ndiff" title="difflib.ndiff"><code class="xref py py-func docutils literal notranslate"><span class="pre">ndiff()</span></code></a>에서 매개 변수 <em>linejunk</em>의 기본값으로 사용되었습니다.</p>
</dd></dl>

<dl class="function">
<dt id="difflib.IS_CHARACTER_JUNK">
<code class="descclassname">difflib.</code><code class="descname">IS_CHARACTER_JUNK</code><span class="sig-paren">(</span><em>ch</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.IS_CHARACTER_JUNK" title="정의 주소">¶</a></dt>
<dd><p>무시할 수 있는 문자면 참을 반환합니다. <em>ch</em>가 스페이스나 탭이면 문자 <em>ch</em>는 무시할 수 있습니다, 그렇지 않으면 무시할 수 없습니다. <a class="reference internal" href="#difflib.ndiff" title="difflib.ndiff"><code class="xref py py-func docutils literal notranslate"><span class="pre">ndiff()</span></code></a>에서 매개 변수 <em>charjunk</em>의 기본값으로 사용됩니다.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><a class="reference external" href="http://www.drdobbs.com/database/pattern-matching-the-gestalt-approach/184407970">Pattern Matching: The Gestalt Approach</a></dt><dd><p>John W. Ratcliff와 D. E. Metzener의 비슷한 알고리즘에 관한 토론. 이것은 1988년 7월 <a class="reference external" href="http://www.drdobbs.com/">Dr. Dobb's Journal</a>에 출판되었습니다.</p>
</dd>
</dl>
</div>
<div class="section" id="sequencematcher-objects">
<span id="sequence-matcher"></span><h2>SequenceMatcher 객체<a class="headerlink" href="#sequencematcher-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#difflib.SequenceMatcher" title="difflib.SequenceMatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></a> 클래스는 다음과 같은 생성자를 갖습니다:</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">difflib.</code><code class="descname">SequenceMatcher</code><span class="sig-paren">(</span><em>isjunk=None</em>, <em>a=''</em>, <em>b=''</em>, <em>autojunk=True</em><span class="sig-paren">)</span></dt>
<dd><p>선택 인자 <em>isjunk</em>는 <code class="docutils literal notranslate"><span class="pre">None</span></code>(기본값)이거나, 시퀀스 요소를 받아서 요소가 &quot;정크&quot; 이고, 무시되어야 하는 경우에만 참을 반환하는 하나의 인자 함수여야 합니다. <em>isjunk</em>에 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 전달하는 것은, <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">0</span></code>를 전달하는 것과 같습니다; 즉, 아무 요소도 무시하지 않습니다. 예를 들어,:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="s2">&quot; </span><span class="se">\t</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>줄을 문자의 시퀀스로 비교하고, 스페이스와 탭을 무시하고 싶으면, 위와 같은 것을 전달하면 됩니다.</p>
<p>선택적 인자 <em>a</em> 와 <em>b</em>는 비교할 시퀀스입니다; 둘 다 빈 문자열이 기본값입니다. 두 시퀀스의 요소는 모두 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a>해야 합니다.</p>
<p>선택적 인자 <em>autojunk</em>는 자동 정크 휴리스틱을 비활성화하는 데 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가: </span><em>autojunk</em> 매개 변수.</p>
</div>
<p>SequenceMatcher 객체는 세 개의 데이터 어트리뷰트를 갖습니다: <em>bjunk</em>는 <em>isjunk</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code> 인 <em>b</em> 요소의 집합입니다; <em>bpopular</em>는 휴리스틱(비활성화하지 않았다면)에서 흔하다고 판단되는 정크가 아닌 요소의 집합입니다; <em>b2j</em>는 <em>b</em>의 나머지 요소를 그들이 나타난 위치의 리스트로 매핑하는 dict입니다. <em>b</em>가 <a class="reference internal" href="#difflib.SequenceMatcher.set_seqs" title="difflib.SequenceMatcher.set_seqs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_seqs()</span></code></a> 나 <a class="reference internal" href="#difflib.SequenceMatcher.set_seq2" title="difflib.SequenceMatcher.set_seq2"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_seq2()</span></code></a>로 재설정 될 때마다 세 개 모두 재설정됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가: </span><em>bjunk</em> 및 <em>bpopular</em> 어트리뷰트</p>
</div>
<p><a class="reference internal" href="#difflib.SequenceMatcher" title="difflib.SequenceMatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></a> 객체에는 다음과 같은 메서드가 있습니다:</p>
<dl class="method">
<dt id="difflib.SequenceMatcher.set_seqs">
<code class="descname">set_seqs</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.SequenceMatcher.set_seqs" title="정의 주소">¶</a></dt>
<dd><p>비교할 두 시퀀스를 설정합니다.</p>
</dd></dl>

<p><a class="reference internal" href="#difflib.SequenceMatcher" title="difflib.SequenceMatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></a>는 두 번째 시퀀스에 대한 자세한 정보를 계산하고 캐시 하므로, 많은 시퀀스에 대해 하나의 시퀀스를 비교하려면, <a class="reference internal" href="#difflib.SequenceMatcher.set_seq2" title="difflib.SequenceMatcher.set_seq2"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_seq2()</span></code></a>를 사용하여 자주 사용되는 시퀀스를 한 번 설정하고, <a class="reference internal" href="#difflib.SequenceMatcher.set_seq1" title="difflib.SequenceMatcher.set_seq1"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_seq1()</span></code></a>를 다른 시퀀스 각각에 대해 한 번 반복적으로 호출하십시오.</p>
<dl class="method">
<dt id="difflib.SequenceMatcher.set_seq1">
<code class="descname">set_seq1</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.SequenceMatcher.set_seq1" title="정의 주소">¶</a></dt>
<dd><p>비교할 첫 번째 시퀀스를 설정합니다. 비교할 두 번째 시퀀스는 변경되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="difflib.SequenceMatcher.set_seq2">
<code class="descname">set_seq2</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.SequenceMatcher.set_seq2" title="정의 주소">¶</a></dt>
<dd><p>비교할 두 번째 시퀀스를 설정합니다. 비교할 첫 번째 시퀀스는 변경되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="difflib.SequenceMatcher.find_longest_match">
<code class="descname">find_longest_match</code><span class="sig-paren">(</span><em>alo</em>, <em>ahi</em>, <em>blo</em>, <em>bhi</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.SequenceMatcher.find_longest_match" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">a[alo:ahi]</span></code> 와 <code class="docutils literal notranslate"><span class="pre">b[blo:bhi]</span></code>에서 가장 긴 일치 블록을 찾습니다.</p>
<p><em>isjunk</em>가 생략되거나 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, <a class="reference internal" href="#difflib.SequenceMatcher.find_longest_match" title="difflib.SequenceMatcher.find_longest_match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_longest_match()</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">a[i:i+k]</span></code>가 <code class="docutils literal notranslate"><span class="pre">b[j:j+k]</span></code>와 같은 <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j,</span> <span class="pre">k)</span></code>를 반환하는데, 여기서 <code class="docutils literal notranslate"><span class="pre">alo</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">i+k</span> <span class="pre">&lt;=</span> <span class="pre">ahi</span></code> 이고 <code class="docutils literal notranslate"><span class="pre">blo</span> <span class="pre">&lt;=</span> <span class="pre">j</span> <span class="pre">&lt;=</span> <span class="pre">j+k</span> <span class="pre">&lt;=</span> <span class="pre">bhi</span></code> 입니다. 이 조건을 만족시키는 모든 <code class="docutils literal notranslate"><span class="pre">(i',</span> <span class="pre">j',</span> <span class="pre">k')</span></code>에 대해, 추가 조건 <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;=</span> <span class="pre">k'</span></code>, <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">i'</span></code> 와 <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">i'</span></code> 면 <code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">&lt;=</span> <span class="pre">j'</span></code> 도 만족합니다. 즉, 모든 최대 일치 블록 중에서 <em>a</em>에서 가장 먼저 시작하는 블록을 반환하고, <em>a</em>에서 가장 먼저 시작하는 모든 최대 일치 블록 중에서 <em>b</em>에서 가장 먼저 시작하는 블록을 반환합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot; abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;abcd abcd&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">find_longest_match</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="go">Match(a=0, b=4, size=5)</span>
</pre></div>
</div>
<p><em>isjunk</em>가 제공되면, 먼저 가장 긴 일치 블록이 상기와 같이 결정되지만, 정크 요소가 블록에 나타나지 않아야 한다는 추가 제약이 있습니다. 그런 다음 그 블록의 좌우에서 정크 요소만 일치시켜 가능한 한 최대로 확장합니다. 그래서 결과 블록은 흥미로운 일치와 인접하게 같은 정크가 등장할 때를 제외하고는, 정크와 일치하지 않습니다.</p>
<p>여기에 이전과 같은 예가 있지만, 스페이스를 정크로 간주합니다. 이렇게 하면 <code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">abcd'</span></code>가 두 번째 시퀀스의 끝에 있는 <code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">abcd'</span></code>와 직접 일치하지 않게 됩니다. 대신 <code class="docutils literal notranslate"><span class="pre">'abcd'</span></code> 만 일치 할 수 있으며, 두 번째 시퀀스에서 가장 왼쪽의 <code class="docutils literal notranslate"><span class="pre">'abcd'</span></code>와 일치합니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">==</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot; abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;abcd abcd&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">find_longest_match</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="go">Match(a=1, b=0, size=4)</span>
</pre></div>
</div>
<p>일치하는 블록이 없으면 <code class="docutils literal notranslate"><span class="pre">(alo,</span> <span class="pre">blo,</span> <span class="pre">0)</span></code>를 반환합니다.</p>
<p>이 메서드는 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> <code class="docutils literal notranslate"><span class="pre">Match(a,</span> <span class="pre">b,</span> <span class="pre">size)</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="difflib.SequenceMatcher.get_matching_blocks">
<code class="descname">get_matching_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#difflib.SequenceMatcher.get_matching_blocks" title="정의 주소">¶</a></dt>
<dd><p>중첩하지 않는 일치하는 서브 시퀀스를 기술하는 3-튜플의 리스트를 반환합니다. 각 3-튜플은 <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j,</span> <span class="pre">n)</span></code> 형식이며, <code class="docutils literal notranslate"><span class="pre">a[i:i+n]</span> <span class="pre">==</span> <span class="pre">b[j:j+n]</span></code>를 뜻합니다. 3-튜플은 <em>i</em>와 <em>j</em>에 대해 단조 증가합니다.</p>
<p>마지막 3-튜플은 더미이며, <code class="docutils literal notranslate"><span class="pre">(len(a),</span> <span class="pre">len(b),</span> <span class="pre">0)</span></code> 값을 가집니다. <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">0</span></code> 인 유일한 3-튜플입니다. <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j,</span> <span class="pre">n)</span></code>와 <code class="docutils literal notranslate"><span class="pre">(i',</span> <span class="pre">j',</span> <span class="pre">n')</span></code>가 리스트에서 인접한 3-튜플이고, 두 번째가 리스트의 마지막 3-튜플이 아니면 <code class="docutils literal notranslate"><span class="pre">i+n</span> <span class="pre">&lt;</span> <span class="pre">i'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">j+n</span> <span class="pre">&lt;</span> <span class="pre">j'</span></code>입니다; 즉, 인접 3-튜플은 항상 인접하지 않은 같은 블록을 나타냅니다.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;abxcd&quot;</span><span class="p">,</span> <span class="s2">&quot;abcd&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_matching_blocks</span><span class="p">()</span>
<span class="go">[Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="difflib.SequenceMatcher.get_opcodes">
<code class="descname">get_opcodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#difflib.SequenceMatcher.get_opcodes" title="정의 주소">¶</a></dt>
<dd><p><em>a</em>를 <em>b</em>로 변환하는 방법을 설명하는 5-튜플의 리스트를 반환합니다. 각 튜플은 <code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">i1,</span> <span class="pre">i2,</span> <span class="pre">j1,</span> <span class="pre">j2)</span></code> 형식입니다. 첫 번째 튜플은 <code class="docutils literal notranslate"><span class="pre">i1</span> <span class="pre">==</span> <span class="pre">j1</span> <span class="pre">==</span> <span class="pre">0</span></code> 이고, 나머지 튜플에서는 <em>i1</em>이 이전 튜플의 <em>i2</em>와 같고, 마찬가지로 <em>j1</em>은 이전 <em>j2</em>와 같습니다.</p>
<p><em>tag</em> 값은 문자열이고, 이런 의미입니다:</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>값</p></th>
<th class="head"><p>뜻</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'replace'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a[i1:i2]</span></code>를 <code class="docutils literal notranslate"><span class="pre">b[j1:j2]</span></code>로 치환해야 합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'delete'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a[i1:i2]</span></code>를 삭제해야 합니다. 이때 <code class="docutils literal notranslate"><span class="pre">j1</span> <span class="pre">==</span> <span class="pre">j2</span></code> 임을 유의하십시오.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'insert'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">b[j1:j2]</span></code>을 <code class="docutils literal notranslate"><span class="pre">a[i1:i1]</span></code>에 삽입해야 합니다. 이때 <code class="docutils literal notranslate"><span class="pre">i1</span> <span class="pre">==</span> <span class="pre">i2</span></code> 임을 유의하십시오.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'equal'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a[i1:i2]</span> <span class="pre">==</span> <span class="pre">b[j1:j2]</span></code> (서브 시퀀스가 같습니다).</p></td>
</tr>
</tbody>
</table>
<p>예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;qabxcd&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;abycdf&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">j1</span><span class="p">,</span> <span class="n">j2</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">get_opcodes</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:7}</span><span class="s1">   a[</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">] --&gt; b[</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">] </span><span class="si">{!r:&gt;8}</span><span class="s1"> --&gt; </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">tag</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">j1</span><span class="p">,</span> <span class="n">j2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">j1</span><span class="p">:</span><span class="n">j2</span><span class="p">]))</span>
<span class="go">delete    a[0:1] --&gt; b[0:0]      &#39;q&#39; --&gt; &#39;&#39;</span>
<span class="go">equal     a[1:3] --&gt; b[0:2]     &#39;ab&#39; --&gt; &#39;ab&#39;</span>
<span class="go">replace   a[3:4] --&gt; b[2:3]      &#39;x&#39; --&gt; &#39;y&#39;</span>
<span class="go">equal     a[4:6] --&gt; b[3:5]     &#39;cd&#39; --&gt; &#39;cd&#39;</span>
<span class="go">insert    a[6:6] --&gt; b[5:6]       &#39;&#39; --&gt; &#39;f&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="difflib.SequenceMatcher.get_grouped_opcodes">
<code class="descname">get_grouped_opcodes</code><span class="sig-paren">(</span><em>n=3</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.SequenceMatcher.get_grouped_opcodes" title="정의 주소">¶</a></dt>
<dd><p>최대 <em>n</em> 줄의 문맥을 갖는 그룹의 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a>를 반환합니다.</p>
<p><a class="reference internal" href="#difflib.SequenceMatcher.get_opcodes" title="difflib.SequenceMatcher.get_opcodes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_opcodes()</span></code></a>에서 반환된 그룹으로 출발해서, 이 메서드는 더 작은 변경 클러스터로 나누고, 변경 사항이 없는 중간 범위를 제거합니다.</p>
<p>그룹은 <a class="reference internal" href="#difflib.SequenceMatcher.get_opcodes" title="difflib.SequenceMatcher.get_opcodes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_opcodes()</span></code></a>와 같은 형식으로 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="difflib.SequenceMatcher.ratio">
<code class="descname">ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#difflib.SequenceMatcher.ratio" title="정의 주소">¶</a></dt>
<dd><p>[0, 1]의 범위의 float로 시퀀스 유사성 척도를 돌려줍니다.</p>
<p>T가 두 시퀀스의 요소의 총 개수이고, M은 일치 개수일 때, 척도는 2.0*M / T입니다. 시퀀스가 같으면 <code class="docutils literal notranslate"><span class="pre">1.0</span></code>이고, 공통 요소가 없으면 <code class="docutils literal notranslate"><span class="pre">0.0</span></code>입니다.</p>
<p><a class="reference internal" href="#difflib.SequenceMatcher.get_matching_blocks" title="difflib.SequenceMatcher.get_matching_blocks"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_matching_blocks()</span></code></a> 나 <a class="reference internal" href="#difflib.SequenceMatcher.get_opcodes" title="difflib.SequenceMatcher.get_opcodes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_opcodes()</span></code></a>가 아직 호출되지 않았으면, 계산하는 데 비용이 많이 듭니다. 이럴 때, <a class="reference internal" href="#difflib.SequenceMatcher.quick_ratio" title="difflib.SequenceMatcher.quick_ratio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quick_ratio()</span></code></a> 나 <a class="reference internal" href="#difflib.SequenceMatcher.real_quick_ratio" title="difflib.SequenceMatcher.real_quick_ratio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">real_quick_ratio()</span></code></a>를 먼저 시도하여 상한값을 얻을 수 있습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>Caution: The result of a <a class="reference internal" href="#difflib.SequenceMatcher.ratio" title="difflib.SequenceMatcher.ratio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ratio()</span></code></a> call may depend on the order of
the arguments. For instance:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;tide&#39;</span><span class="p">,</span> <span class="s1">&#39;diet&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ratio</span><span class="p">()</span>
<span class="go">0.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;diet&#39;</span><span class="p">,</span> <span class="s1">&#39;tide&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ratio</span><span class="p">()</span>
<span class="go">0.5</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="difflib.SequenceMatcher.quick_ratio">
<code class="descname">quick_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#difflib.SequenceMatcher.quick_ratio" title="정의 주소">¶</a></dt>
<dd><p>비교적 빨리 <a class="reference internal" href="#difflib.SequenceMatcher.ratio" title="difflib.SequenceMatcher.ratio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ratio()</span></code></a>의 상한을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="difflib.SequenceMatcher.real_quick_ratio">
<code class="descname">real_quick_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#difflib.SequenceMatcher.real_quick_ratio" title="정의 주소">¶</a></dt>
<dd><p>아주 빨리 <a class="reference internal" href="#difflib.SequenceMatcher.ratio" title="difflib.SequenceMatcher.ratio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ratio()</span></code></a>의 상한을 반환합니다.</p>
</dd></dl>

</dd></dl>

<p>총 문자 수에 대한 일치 비율을 반환하는 세 가지 메서드는 서로 다른 수준의 근삿값 때문에 다른 결과를 줄 수 있습니다. 하지만 <code class="xref py py-meth docutils literal notranslate"><span class="pre">quick_ratio()</span></code> 와 <code class="xref py py-meth docutils literal notranslate"><span class="pre">real_quick_ratio()</span></code>는 항상 최소한 <code class="xref py py-meth docutils literal notranslate"><span class="pre">ratio()</span></code>만큼 큰 값을 줍니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;bcde&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">ratio</span><span class="p">()</span>
<span class="go">0.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">quick_ratio</span><span class="p">()</span>
<span class="go">0.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">real_quick_ratio</span><span class="p">()</span>
<span class="go">1.0</span>
</pre></div>
</div>
</div>
<div class="section" id="sequencematcher-examples">
<span id="id1"></span><h2>SequenceMatcher 예제<a class="headerlink" href="#sequencematcher-examples" title="제목 주소">¶</a></h2>
<p>이 예제에서는 공백을 &quot;정크&quot;로 간주하여, 두 문자열을 비교합니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="s2">&quot; &quot;</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="s2">&quot;private Thread currentThread;&quot;</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="s2">&quot;private volatile Thread currentThread;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">ratio()</span></code>는 [0, 1] 범위의 float를 반환하여, 시퀀스의 유사성을 측정합니다. 경험적으로, <code class="xref py py-meth docutils literal notranslate"><span class="pre">ratio()</span></code> 값이 0.6 이상이면 시퀀스가 근접하게 일치함을 뜻합니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ratio</span><span class="p">(),</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">0.866</span>
</pre></div>
</div>
<p>시퀀스가 일치하는 부분에만 관심이 있다면, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_matching_blocks()</span></code>가 유용합니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">get_matching_blocks</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;a[</span><span class="si">%d</span><span class="s2">] and b[</span><span class="si">%d</span><span class="s2">] match for </span><span class="si">%d</span><span class="s2"> elements&quot;</span> <span class="o">%</span> <span class="n">block</span><span class="p">)</span>
<span class="go">a[0] and b[0] match for 8 elements</span>
<span class="go">a[8] and b[17] match for 21 elements</span>
<span class="go">a[29] and b[38] match for 0 elements</span>
</pre></div>
</div>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_matching_blocks()</span></code>에 의해 반환된 마지막 튜플은 항상 더미인 <code class="docutils literal notranslate"><span class="pre">(len(a),</span> <span class="pre">len(b),</span> <span class="pre">0)</span></code>이며, 이는 마지막 튜플 요소(일치하는 요소의 수)가 <code class="docutils literal notranslate"><span class="pre">0</span></code> 인 유일한 경우입니다.</p>
<p>첫 번째 시퀀스를 두 번째 시퀀스로 변경하는 방법을 알고 싶다면, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_opcodes()</span></code>를 사용하십시오:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">opcode</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">get_opcodes</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6s</span><span class="s2"> a[</span><span class="si">%d</span><span class="s2">:</span><span class="si">%d</span><span class="s2">] b[</span><span class="si">%d</span><span class="s2">:</span><span class="si">%d</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="n">opcode</span><span class="p">)</span>
<span class="go"> equal a[0:8] b[0:8]</span>
<span class="go">insert a[8:8] b[8:17]</span>
<span class="go"> equal a[8:29] b[17:38]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<ul class="simple">
<li><p>이 모듈의 <a class="reference internal" href="#difflib.get_close_matches" title="difflib.get_close_matches"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_close_matches()</span></code></a> 함수는 <a class="reference internal" href="#difflib.SequenceMatcher" title="difflib.SequenceMatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></a>를 사용한 간단한 코드 작성을 통해 유용한 작업을 수행하는 방법을 보여줍니다.</p></li>
<li><p><a class="reference internal" href="#difflib.SequenceMatcher" title="difflib.SequenceMatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></a>로 만들어진 작은 응용 프로그램을 위한 <a class="reference external" href="https://code.activestate.com/recipes/576729/">간단한 버전 관리 조리법</a>.</p></li>
</ul>
</div>
</div>
<div class="section" id="differ-objects">
<span id="id2"></span><h2>Differ 객체<a class="headerlink" href="#differ-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#difflib.Differ" title="difflib.Differ"><code class="xref py py-class docutils literal notranslate"><span class="pre">Differ</span></code></a>가 만든 델타는 <strong>최소</strong> diff라고 주장하지 않음에 유의하십시오. 반대로, 최소 diff는 종종 반 직관적인데, 가능한 모든 곳에서 일치를 취하기 때문입니다. 때로 우발적으로 100페이지가 떨어진 곳에서 일치시키기도 합니다. 동기화 지점을 인접한 일치로 제한하면 가끔 더 긴 diff를 만드는 대신 일종의 지역성을 보존합니다.</p>
<p><a class="reference internal" href="#difflib.Differ" title="difflib.Differ"><code class="xref py py-class docutils literal notranslate"><span class="pre">Differ</span></code></a> 클래스에는 다음과 같은 생성자가 있습니다:</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">difflib.</code><code class="descname">Differ</code><span class="sig-paren">(</span><em>linejunk=None</em>, <em>charjunk=None</em><span class="sig-paren">)</span></dt>
<dd><p>선택적 키워드 매개 변수 <em>linejunk</em> 와 <em>charjunk</em>는 필터 함수(또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>)를 위한 것입니다:</p>
<p><em>linejunk</em>: 단일 문자열 인자를 받아들이고 문자열이 정크면 참을 반환하는 함수입니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>이며, 이는 어떤 줄도 정크로 간주하지 않음을 의미합니다.</p>
<p><em>charjunk</em>: 문자(길이 1의 문자열)를 받아들이고, 문자가 정크면 참을 반환하는 함수입니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>이며, 이는 어떤 문자도 정크로 간주하지 않음을 의미합니다.</p>
<p>이러한 정크 필터링 함수는 차이점을 찾기 위한 일치 속도를 높이고 차이가 나는 줄이나 문자를 무시하지 않습니다. 설명이 필요하면 <a class="reference internal" href="#difflib.SequenceMatcher.find_longest_match" title="difflib.SequenceMatcher.find_longest_match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_longest_match()</span></code></a> 메서드의 <em>isjunk</em> 매개 변수에 대한 설명을 읽으십시오.</p>
<p><a class="reference internal" href="#difflib.Differ" title="difflib.Differ"><code class="xref py py-class docutils literal notranslate"><span class="pre">Differ</span></code></a> 객체는 단일 메서드를 통해 사용됩니다 (델타가 만들어집니다):</p>
<dl class="method">
<dt id="difflib.Differ.compare">
<code class="descname">compare</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#difflib.Differ.compare" title="정의 주소">¶</a></dt>
<dd><p>줄의 시퀀스 두 개를 비교하고, 델타(줄의 시퀀스)를 만듭니다.</p>
<p>각 시퀀스는 줄 넘김으로 끝나는 개별 단일 줄 문자열을 포함해야 합니다. 이러한 시퀀스는 파일류 객체의 <a class="reference internal" href="io.html#io.IOBase.readlines" title="io.IOBase.readlines"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readlines()</span></code></a> 메서드로 얻을 수 있습니다. 생성된 델타 역시 파일류 객체의 <a class="reference internal" href="io.html#io.IOBase.writelines" title="io.IOBase.writelines"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writelines()</span></code></a> 메서드를 통해 그대로 인쇄될 수 있도록 줄 넘김으로 끝나는 문자열로 구성됩니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="differ-example">
<span id="differ-examples"></span><h2>Differ 예제<a class="headerlink" href="#differ-example" title="제목 주소">¶</a></h2>
<p>이 예제는 두 개의 텍스트를 비교합니다. 먼저 텍스트를 설정하는데, 줄 넘김 문자로 끝나는 개별 단일 줄 문자열의 시퀀스입니다 (이러한 시퀀스는 파일류 객체의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">readlines()</span></code> 메서드로도 얻을 수 있습니다):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text1</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;  1. Beautiful is better than ugly.</span>
<span class="gp">... </span><span class="s1">  2. Explicit is better than implicit.</span>
<span class="gp">... </span><span class="s1">  3. Simple is better than complex.</span>
<span class="gp">... </span><span class="s1">  4. Complex is better than complicated.</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">text1</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text2</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;  1. Beautiful is better than ugly.</span>
<span class="gp">... </span><span class="s1">  3.   Simple is better than complex.</span>
<span class="gp">... </span><span class="s1">  4. Complicated is better than complex.</span>
<span class="gp">... </span><span class="s1">  5. Flat is better than nested.</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>다음으로 Differ 객체의 인스턴스를 만듭니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Differ</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="#difflib.Differ" title="difflib.Differ"><code class="xref py py-class docutils literal notranslate"><span class="pre">Differ</span></code></a> 객체의 인스턴스를 만들 때, 줄과 문자 &quot;정크&quot;를 필터링하는 함수를 전달할 수 있음에 유의하십시오. 자세한 내용은 <a class="reference internal" href="#difflib.Differ" title="difflib.Differ"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Differ()</span></code></a> 생성자를 참조하십시오.</p>
<p>마지막으로, 두 개를 비교합니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">result</span></code>는 문자열의 리스트이므로, 예쁜 인쇄를 해봅시다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pprint</span> <span class="k">import</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">[&#39;    1. Beautiful is better than ugly.\n&#39;,</span>
<span class="go"> &#39;-   2. Explicit is better than implicit.\n&#39;,</span>
<span class="go"> &#39;-   3. Simple is better than complex.\n&#39;,</span>
<span class="go"> &#39;+   3.   Simple is better than complex.\n&#39;,</span>
<span class="go"> &#39;?     ++\n&#39;,</span>
<span class="go"> &#39;-   4. Complex is better than complicated.\n&#39;,</span>
<span class="go"> &#39;?            ^                     ---- ^\n&#39;,</span>
<span class="go"> &#39;+   4. Complicated is better than complex.\n&#39;,</span>
<span class="go"> &#39;?           ++++ ^                      ^\n&#39;,</span>
<span class="go"> &#39;+   5. Flat is better than nested.\n&#39;]</span>
</pre></div>
</div>
<p>여러 줄이 포함된 하나의 문자열로 만들면 이렇게 보입니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">    1. Beautiful is better than ugly.</span>
<span class="go">-   2. Explicit is better than implicit.</span>
<span class="go">-   3. Simple is better than complex.</span>
<span class="go">+   3.   Simple is better than complex.</span>
<span class="go">?     ++</span>
<span class="go">-   4. Complex is better than complicated.</span>
<span class="go">?            ^                     ---- ^</span>
<span class="go">+   4. Complicated is better than complex.</span>
<span class="go">?           ++++ ^                      ^</span>
<span class="go">+   5. Flat is better than nested.</span>
</pre></div>
</div>
</div>
<div class="section" id="a-command-line-interface-to-difflib">
<span id="difflib-interface"></span><h2>difflib의 명령 줄 인터페이스<a class="headerlink" href="#a-command-line-interface-to-difflib" title="제목 주소">¶</a></h2>
<p>이 예제는 difflib를 사용하여 <code class="docutils literal notranslate"><span class="pre">diff</span></code>와 유사한 유틸리티를 만드는 방법을 보여줍니다. 이것은 파이썬 소스 배포판에 <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/diff.py</span></code>로 포함되어 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="sd">&quot;&quot;&quot; Command line interface to difflib.py providing diffs in four formats:</span>

<span class="sd">* ndiff:    lists every line and highlights interline changes.</span>
<span class="sd">* context:  highlights clusters of changes in a before/after format.</span>
<span class="sd">* unified:  highlights clusters of changes in an inline format.</span>
<span class="sd">* html:     generates side by side comparison with change highlights.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">difflib</span><span class="o">,</span> <span class="nn">argparse</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timezone</span>

<span class="k">def</span> <span class="nf">file_mtime</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">fromtimestamp</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">st_mtime</span><span class="p">,</span>
                               <span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">astimezone</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-c&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Produce a context format diff (default)&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-u&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Produce a unified format diff&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-m&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Produce HTML side by side diff &#39;</span>
                             <span class="s1">&#39;(can use -c and -l in conjunction)&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-n&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Produce a ndiff format diff&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-l&#39;</span><span class="p">,</span> <span class="s1">&#39;--lines&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Set number of context lines (default 3)&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;fromfile&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;tofile&#39;</span><span class="p">)</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">lines</span>
    <span class="n">fromfile</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">fromfile</span>
    <span class="n">tofile</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">tofile</span>

    <span class="n">fromdate</span> <span class="o">=</span> <span class="n">file_mtime</span><span class="p">(</span><span class="n">fromfile</span><span class="p">)</span>
    <span class="n">todate</span> <span class="o">=</span> <span class="n">file_mtime</span><span class="p">(</span><span class="n">tofile</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fromfile</span><span class="p">)</span> <span class="k">as</span> <span class="n">ff</span><span class="p">:</span>
        <span class="n">fromlines</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tofile</span><span class="p">)</span> <span class="k">as</span> <span class="n">tf</span><span class="p">:</span>
        <span class="n">tolines</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">u</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">difflib</span><span class="o">.</span><span class="n">unified_diff</span><span class="p">(</span><span class="n">fromlines</span><span class="p">,</span> <span class="n">tolines</span><span class="p">,</span> <span class="n">fromfile</span><span class="p">,</span> <span class="n">tofile</span><span class="p">,</span> <span class="n">fromdate</span><span class="p">,</span> <span class="n">todate</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">options</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">difflib</span><span class="o">.</span><span class="n">ndiff</span><span class="p">(</span><span class="n">fromlines</span><span class="p">,</span> <span class="n">tolines</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">options</span><span class="o">.</span><span class="n">m</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">difflib</span><span class="o">.</span><span class="n">HtmlDiff</span><span class="p">()</span><span class="o">.</span><span class="n">make_file</span><span class="p">(</span><span class="n">fromlines</span><span class="p">,</span><span class="n">tolines</span><span class="p">,</span><span class="n">fromfile</span><span class="p">,</span><span class="n">tofile</span><span class="p">,</span><span class="n">context</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">c</span><span class="p">,</span><span class="n">numlines</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">difflib</span><span class="o">.</span><span class="n">context_diff</span><span class="p">(</span><span class="n">fromlines</span><span class="p">,</span> <span class="n">tolines</span><span class="p">,</span> <span class="n">fromfile</span><span class="p">,</span> <span class="n">tofile</span><span class="p">,</span> <span class="n">fromdate</span><span class="p">,</span> <span class="n">todate</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code> --- 델타 계산을 위한 도우미</a><ul>
<li><a class="reference internal" href="#sequencematcher-objects">SequenceMatcher 객체</a></li>
<li><a class="reference internal" href="#sequencematcher-examples">SequenceMatcher 예제</a></li>
<li><a class="reference internal" href="#differ-objects">Differ 객체</a></li>
<li><a class="reference internal" href="#differ-example">Differ 예제</a></li>
<li><a class="reference internal" href="#a-command-line-interface-to-difflib">difflib의 명령 줄 인터페이스</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="re.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> --- 정규식 연산</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="textwrap.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">textwrap</span></code> --- 텍스트 래핑과 채우기</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="textwrap.html" title="textwrap --- 텍스트 래핑과 채우기"
             >다음</a> |</li>
        <li class="right" >
          <a href="re.html" title="re --- 정규식 연산"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="text.html" >텍스트 처리 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>