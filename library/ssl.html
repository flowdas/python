
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ssl --- 소켓 객체용 TLS/SSL 래퍼 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="select --- Waiting for I/O completion" href="select.html" />
    <link rel="prev" title="socket --- 저수준 네트워킹 인터페이스" href="socket.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/library/ssl.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="select.html" title="select --- Waiting for I/O completion"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="socket.html" title="socket --- 저수준 네트워킹 인터페이스"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" accesskey="U">네트워킹과 프로세스 간 통신</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-ssl">
<span id="ssl-tls-ssl-wrapper-for-socket-objects"></span><h1><a class="reference internal" href="#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> --- 소켓 객체용 TLS/SSL 래퍼<a class="headerlink" href="#module-ssl" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/ssl.py">Lib/ssl.py</a></p>
<span class="target" id="index-0"></span><hr class="docutils" id="index-1" />
<p>이 모듈은 클라이언트 쪽과 서버 쪽 네트워크 소켓에 대한 전송 계층 보안(Transport Layer Security) (&quot;보안 소켓 계층(Secure Sockets Layer)&quot; 이라고도 함) 암호화와 피어 인증 기능에 대한 액세스를 제공합니다. 이 모듈은 OpenSSL 라이브러리를 사용합니다. OpenSSL이 해당 플랫폼에 설치되어있는 한, 모든 최신 유닉스 시스템, 윈도우, 맥 OS X 및 추가 플랫폼에서 사용할 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">운영 체제 소켓 API를 호출하기 때문에, 일부 동작은 플랫폼에 따라 다를 수 있습니다. 설치된 OpenSSL 버전도 동작을 바꿀 수 있습니다. 예를 들어, TLSv1.1 과 TLSv1.2는 openssl 버전 1.0.1과 함께 제공됩니다.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">경고</p>
<p class="last"><a class="reference internal" href="#ssl-security"><span class="std std-ref">보안 고려 사항</span></a>을 읽지 않고 이 모듈을 사용하지 마십시오. 그렇게하면 ssl 모듈의 기본 설정이 반드시 여러분의 응용 프로그램에 적합하지는 않으므로 잘못된 보안 인식으로 이어질 수 있습니다.</p>
</div>
<p>이 절에서는 <code class="docutils literal notranslate"><span class="pre">ssl</span></code> 모듈의 객체와 함수를 설명합니다; TLS, SSL 및 인증서에 대한보다 일반적인 정보는, 하단의 &quot;더 보기&quot; 절에 있는 문서를 참조하십시오.</p>
<p>이 모듈은 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> 형에서 파생된 <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> 클래스를 제공하며, SSL을 사용하여 소켓을 통해 전달되는 데이터를 암호화하고 복호화하는 소켓 형 래퍼를 제공합니다. 또한 추가 메서드를 지원하는데, 가령 연결의 다른 쪽 인증서를 조회하는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code>와 보안 연결에 사용되는 사이퍼(cipher)를 조회하는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">cipher()</span></code>가 있습니다.</p>
<p>보다 정교한 응용 프로그램의 경우, <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 클래스는 설정과 인증서를 관리하는 데 도움이되며, <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> 메서드를 통해 만들어진 SSL 소켓이 상속 할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5.3으로 변경: </span>OpenSSL 1.1.0과의 링크를 지원하도록 갱신되었습니다</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>OpenSSL 0.9.8, 1.0.0 및 1.0.1은 폐지되었으며 더는 지원되지 않습니다. 미래에는 ssl 모듈이 최소한 OpenSSL 1.0.2 나 1.1.0을 요구할 것입니다.</p>
</div>
<div class="section" id="functions-constants-and-exceptions">
<h2>함수, 상수 및 예외<a class="headerlink" href="#functions-constants-and-exceptions" title="제목 주소">¶</a></h2>
<div class="section" id="socket-creation">
<h3>소켓 생성<a class="headerlink" href="#socket-creation" title="제목 주소">¶</a></h3>
<p>파이썬 3.2와 2.7.9 이후로, <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> 객체로 소켓을 포장하기 위해 <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 인스턴스의 <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>를 사용하는 것이 좋습니다. 도우미 함수 <a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a>는 보안 기본 설정을 갖는 새 컨텍스트를 반환합니다. 오래된 <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> 함수는 비효율적이고 서버 이름 표시(SNI)와 호스트명 일치를 지원하지 않기 때문에 폐지되었습니다.</p>
<p>기본 컨텍스트와 IPv4/IPv6 이중 스택을 사용하는 클라이언트 소켓 예제:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">ssl</span>

<span class="n">hostname</span> <span class="o">=</span> <span class="s1">&#39;www.python.org&#39;</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>

<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">create_connection</span><span class="p">((</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span> <span class="k">as</span> <span class="n">sock</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="n">hostname</span><span class="p">)</span> <span class="k">as</span> <span class="n">ssock</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ssock</span><span class="o">.</span><span class="n">version</span><span class="p">())</span>
</pre></div>
</div>
<p>사용자 정의 컨텍스트와 IPv4를 사용하는 클라이언트 소켓 예제:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">hostname</span> <span class="o">=</span> <span class="s1">&#39;www.python.org&#39;</span>
<span class="c1"># PROTOCOL_TLS_CLIENT는 유효한 인증서 체인과 호스트 명을 요구합니다</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_CLIENT</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_verify_locations</span><span class="p">(</span><span class="s1">&#39;path/to/cabundle.pem&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="n">sock</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="n">hostname</span><span class="p">)</span> <span class="k">as</span> <span class="n">ssock</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ssock</span><span class="o">.</span><span class="n">version</span><span class="p">())</span>
</pre></div>
</div>
<p>localhost IPv4 에서 리스닝하는 서버 소켓 예제:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_SERVER</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_cert_chain</span><span class="p">(</span><span class="s1">&#39;/path/to/certchain.pem&#39;</span><span class="p">,</span> <span class="s1">&#39;/path/to/private.key&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="n">sock</span><span class="p">:</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8443</span><span class="p">))</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">server_side</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">ssock</span><span class="p">:</span>
        <span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">ssock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="context-creation">
<h3>컨텍스트 생성<a class="headerlink" href="#context-creation" title="제목 주소">¶</a></h3>
<p>편의 함수는 공통 목적을 위한 <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 객체를 만드는데 도움이됩니다.</p>
<dl class="function">
<dt id="ssl.create_default_context">
<code class="descclassname">ssl.</code><code class="descname">create_default_context</code><span class="sig-paren">(</span><em>purpose=Purpose.SERVER_AUTH</em>, <em>cafile=None</em>, <em>capath=None</em>, <em>cadata=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.create_default_context" title="정의 주소">¶</a></dt>
<dd><p>지정된 <em>purpose</em>를 위한 기본 설정으로 새 <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 객체를 반환합니다. 설정은 <a class="reference internal" href="#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 모듈에 의해 선택되며, 일반적으로 <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 생성자를 직접 호출 할 때 보다 높은 보안 수준을 나타냅니다.</p>
<p><em>cafile</em>, <em>capath</em>, <em>cadata</em>는, <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a>에서와 같이, 인증서 확인을 위해 신뢰할 수 있는 선택적 CA 인증서를 나타냅니다. 세 개 모두가 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>이면, 이 함수는 대신 시스템의 기본 CA 인증서를 신뢰하도록 선택할 수 있습니다.</p>
<p>설정은: <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>, <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a> 및 <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a>이며, RC4가 없는 높은 암호화 사이퍼 스위트가 포함되고, 인증되지 않은 사이퍼 스위트는 포함되지 않습니다. <a class="reference internal" href="#ssl.Purpose.SERVER_AUTH" title="ssl.Purpose.SERVER_AUTH"><code class="xref py py-data docutils literal notranslate"><span class="pre">SERVER_AUTH</span></code></a>를 <em>purpose</em>로 전달하면 <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-data docutils literal notranslate"><span class="pre">verify_mode</span></code></a>가 <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>로 설정되고 CA 인증서가 로드되거나 (<em>cafile</em>, <em>capath</em> 또는 <em>cadata</em> 중 하나 이상이 제공 될 때), <a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a>를 사용하여 기본 CA 인증서를 로드합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p>프로토콜, 옵션, 사이퍼 및 기타 설정은 사전 폐지 없이 언제든지 보다 제한적인 값으로 변경 될 수 있습니다. 이 값은 호환성과 보안 간의 적절한 균형을 나타냅니다.</p>
<p class="last">응용 프로그램에 특정 설정이 필요하면, <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>를 만들어 설정을 직접 적용해야합니다.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p>특정 이전 클라이언트나 서버가 이 함수로 만든 <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>로 연결을 시도 할 때 &quot;Protocol or cipher suite mismatch&quot; 라는 에러가 발생하면, 이 함수가 <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a>를 사용해서 제외하는 SSL3.0 만 지원하는 것일 수 있습니다. SSL3.0은 <a class="reference external" href="https://en.wikipedia.org/wiki/POODLE">완전히 망가진</a>것으로 널리 인식되고 있습니다. 이 함수를 계속 사용하면서 SSL 3.0 연결을 계속 허용하려면 다음과 같이 다시 활성화 할 수 있습니다:</p>
<div class="last highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">(</span><span class="n">Purpose</span><span class="o">.</span><span class="n">CLIENT_AUTH</span><span class="p">)</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ssl</span><span class="o">.</span><span class="n">OP_NO_SSLv3</span>
</pre></div>
</div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4.4으로 변경: </span>RC4는 기본 사이퍼 문자열에서 삭제되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>ChaCha20/Poly1305가 기본 사이퍼 문자열에 추가되었습니다.</p>
<p>3DES가 기본 사이퍼 문자열에서 삭제되었습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="exceptions">
<h3>예외<a class="headerlink" href="#exceptions" title="제목 주소">¶</a></h3>
<dl class="exception">
<dt id="ssl.SSLError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLError</code><a class="headerlink" href="#ssl.SSLError" title="정의 주소">¶</a></dt>
<dd><p>하부 SSL 구현(현재 OpenSSL 라이브러리에서 제공)으로 부터의 에러를 알리기 위해 발생합니다. 이는 하부 네트워크 연결에 겹쳐진 상위 수준의 암호화와 인증 계층에서 문제가 있음을 나타냅니다. 이 에러는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 서브 형입니다. <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> 인스턴스의 에러 코드와 메시지는 OpenSSL 라이브러리에 의해 제공됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>는 <a class="reference internal" href="socket.html#socket.error" title="socket.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.error</span></code></a>의 서브 형이었습니다.</p>
</div>
<dl class="attribute">
<dt id="ssl.SSLError.library">
<code class="descname">library</code><a class="headerlink" href="#ssl.SSLError.library" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">SSL</span></code>, <code class="docutils literal notranslate"><span class="pre">PEM</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">X509</span></code>와 같이, 에러가 발생한 OpenSSL 하위 모듈을 지정하는 문자열 기호입니다. 가능한 값의 범위는 OpenSSL 버전에 따라 다릅니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLError.reason">
<code class="descname">reason</code><a class="headerlink" href="#ssl.SSLError.reason" title="정의 주소">¶</a></dt>
<dd><p>이 에러가 발생한 이유를 나타내는 문자열 기호, 예를 들어, <code class="docutils literal notranslate"><span class="pre">CERTIFICATE_VERIFY_FAILED</span></code>. 가능한 값의 범위는 OpenSSL 버전에 따라 다릅니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="ssl.SSLZeroReturnError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLZeroReturnError</code><a class="headerlink" href="#ssl.SSLZeroReturnError" title="정의 주소">¶</a></dt>
<dd><p>읽기나 쓰기를 시도하고 SSL 연결이 정상적으로 닫혔을 때 발생하는 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>의 서브 클래스. 이것이 하부 트랜스포트(TCP 읽기)가 닫혔음을 뜻하지는 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLWantReadError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLWantReadError</code><a class="headerlink" href="#ssl.SSLWantReadError" title="정의 주소">¶</a></dt>
<dd><p>데이터를 읽거나 쓰려고 하지만, 요청을 만족하려면 하부 TCP 트랜스포트에서 데이터를 더 수신해야할 때, <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">비 블로킹 SSL 소켓</span></a>에 의해 발생하는 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>의 서브 클래스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLWantWriteError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLWantWriteError</code><a class="headerlink" href="#ssl.SSLWantWriteError" title="정의 주소">¶</a></dt>
<dd><p>데이터를 읽거나 쓰려고 하지만, 요청을 만족하려면 하부 TCP 트랜스포트로 데이터를 더 보내야할 때, <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">비 블로킹 SSL 소켓</span></a>에 의해 발생하는 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>의 서브 클래스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLSyscallError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLSyscallError</code><a class="headerlink" href="#ssl.SSLSyscallError" title="정의 주소">¶</a></dt>
<dd><p>SSL 소켓에서 작업을 수행하는 동안 시스템 에러를 만났을 때 발생하는 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>의 서브 클래스. 불행히도 원래의 errno 번호를 검사하는 쉬운 방법은 없습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLEOFError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLEOFError</code><a class="headerlink" href="#ssl.SSLEOFError" title="정의 주소">¶</a></dt>
<dd><p>SSL 연결이 갑자기 종료되었을 때 발생하는 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>의 서브 클래스. 일반적으로, 이 에러가 발생하면 하부 트랜스포트를 다시 사용하지 않아야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLCertVerificationError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLCertVerificationError</code><a class="headerlink" href="#ssl.SSLCertVerificationError" title="정의 주소">¶</a></dt>
<dd><p>인증서 유효성 검사가 실패했을 때 발생하는 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>의 서브 클래스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
<dl class="attribute">
<dt id="ssl.SSLCertVerificationError.verify_code">
<code class="descname">verify_code</code><a class="headerlink" href="#ssl.SSLCertVerificationError.verify_code" title="정의 주소">¶</a></dt>
<dd><p>유효성 검사 에러를 나타내는 숫자 에러 번호.</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLCertVerificationError.verify_message">
<code class="descname">verify_message</code><a class="headerlink" href="#ssl.SSLCertVerificationError.verify_message" title="정의 주소">¶</a></dt>
<dd><p>사람이 읽을 수 있는 유효성 검사 에러 문자열.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="ssl.CertificateError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">CertificateError</code><a class="headerlink" href="#ssl.CertificateError" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLCertVerificationError" title="ssl.SSLCertVerificationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLCertVerificationError</span></code></a>의 별칭.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>예외는 이제 <a class="reference internal" href="#ssl.SSLCertVerificationError" title="ssl.SSLCertVerificationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLCertVerificationError</span></code></a>의 별칭입니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="random-generation">
<h3>난수 생성<a class="headerlink" href="#random-generation" title="제목 주소">¶</a></h3>
<dl class="function">
<dt id="ssl.RAND_bytes">
<code class="descclassname">ssl.</code><code class="descname">RAND_bytes</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_bytes" title="정의 주소">¶</a></dt>
<dd><p>길이 <em>num</em>의 암호학적으로 강한 의사 난수 바이트열을 반환합니다. PRNG에 충분한 데이터가 시드(seed)되지 않았거나 현재 RAND 메서드에서 지원되지 않는 연산이면 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a>를 발생시킵니다. <a class="reference internal" href="#ssl.RAND_status" title="ssl.RAND_status"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_status()</span></code></a>를 PRNG의 상태를 확인하는 데 사용할 수 있으며 <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_add()</span></code></a>는 PRNG를 시드하는 데 사용할 수 있습니다.</p>
<p>거의 모든 응용 프로그램에서 <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a>을 선호합니다.</p>
<p>암호학적 생성기의 요구 사항을 얻으려면 위키피디아 기사 <a class="reference external" href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">Cryptographically secure pseudorandom number generator (CSPRNG)</a>를 읽으십시오.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_pseudo_bytes">
<code class="descclassname">ssl.</code><code class="descname">RAND_pseudo_bytes</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_pseudo_bytes" title="정의 주소">¶</a></dt>
<dd><p>(bytes, is_cryptographic) 을 반환합니다: bytes는 <em>num</em> 길이의 의사 난수 바이트열이며, 생성된 bytes가 암호학적으로 강하면 is_cryptographic은 <code class="docutils literal notranslate"><span class="pre">True</span></code>입니다. 현재 RAND 메서드에서 지원되지 않는 연산이면 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a>를 발생시킵니다.</p>
<p>생성된 의사 난수 바이트 시퀀스는 충분한 길이일 때 고유하지만, 예측할 수 없는 것은 아닙니다. 이것들은 비 암호화 목적이나 암호화 프로토콜에서의 특정 목적을 위해 사용될 수 있지만, 보통 키 생성 등을 위해 사용되지는 않습니다.</p>
<p>거의 모든 응용 프로그램에서 <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a>을 선호합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.6 폐지: </span>OpenSSL은 <a class="reference internal" href="#ssl.RAND_pseudo_bytes" title="ssl.RAND_pseudo_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_pseudo_bytes()</span></code></a>를 폐지했습니다. 대신 <a class="reference internal" href="#ssl.RAND_bytes" title="ssl.RAND_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_bytes()</span></code></a>를 사용하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_status">
<code class="descclassname">ssl.</code><code class="descname">RAND_status</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_status" title="정의 주소">¶</a></dt>
<dd><p>SSL 의사 난수 생성기에 '충분한' 임의성이 시드되었으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환하고, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다. <a class="reference internal" href="#ssl.RAND_egd" title="ssl.RAND_egd"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_egd()</span></code></a> 과 <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_add()</span></code></a>를 사용하여 의사 난수 생성기의 임의성을 높일 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_egd">
<code class="descclassname">ssl.</code><code class="descname">RAND_egd</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_egd" title="정의 주소">¶</a></dt>
<dd><p>어딘가에 엔트로피 수집 데몬(EGD - entropy-gathering daemon)을 실행 중이고, <em>path</em>가 그 곳으로 열려있는 소켓 연결의 경로명이면, 그 소켓에서 256 바이트의 임의성을 읽고, 생성 된 비밀 키의 보안을 강화하기위해 이를 SSL 의사 난수 생성기에 추가합니다. 이것은 일반적으로 더 나은 임의성 소스가 없는 시스템에서만 필요합니다.</p>
<p>엔트로피 수집 데몬의 소스에 대해서는 <a class="reference external" href="http://egd.sourceforge.net/">http://egd.sourceforge.net/</a> 나 <a class="reference external" href="http://prngd.sourceforge.net/">http://prngd.sourceforge.net/</a> 을 참조하십시오.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: LibreSSL 과 OpenSSL &gt; 1.1.0 에서는 사용할 수 없습니다.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_add">
<code class="descclassname">ssl.</code><code class="descname">RAND_add</code><span class="sig-paren">(</span><em>bytes</em>, <em>entropy</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_add" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>bytes</em>를 SSL 의사 난수 생성기에 섞습니다. 매개 변수 <em>entropy</em>(float)는 문자열에 포함된 엔트로피의 하한값이므로 항상 <code class="xref py py-const docutils literal notranslate"><span class="pre">0.0</span></code>를 사용할 수 있습니다. 엔트로피 소스에 대한 추가 정보는 <span class="target" id="index-39"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1750.html"><strong>RFC 1750</strong></a>를 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>이제 쓰기 가능한 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="certificate-handling">
<h3>인증서 처리<a class="headerlink" href="#certificate-handling" title="제목 주소">¶</a></h3>
<dl class="function">
<dt id="ssl.match_hostname">
<code class="descclassname">ssl.</code><code class="descname">match_hostname</code><span class="sig-paren">(</span><em>cert</em>, <em>hostname</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.match_hostname" title="정의 주소">¶</a></dt>
<dd><p><em>cert</em>(<a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a>에서 반환된 디코딩된 형식)가 지정된 <em>hostname</em>과 일치하는지 확인합니다. 적용되는 규칙은 <span class="target" id="index-40"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2818.html"><strong>RFC 2818</strong></a>, <span class="target" id="index-41"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5280.html"><strong>RFC 5280</strong></a> 및 <span class="target" id="index-42"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6125.html"><strong>RFC 6125</strong></a>에 설명 된대로 HTTPS 서버의 아이덴티티(identity)를 확인하기위한 것입니다. HTTPS 외에도, 이 함수는 FTPS, IMAPS, POPS 및 그 밖의 다양한 SSL 기반 프로토콜에서 서버의 아이덴티티를 확인하는 데 적합합니다.</p>
<p>실패하면 <a class="reference internal" href="#ssl.CertificateError" title="ssl.CertificateError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CertificateError</span></code></a>가 발생합니다. 성공하면, 함수는 아무 것도 반환하지 않습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cert</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span> <span class="s1">&#39;example.com&#39;</span><span class="p">),),)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">cert</span><span class="p">,</span> <span class="s2">&quot;example.com&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">cert</span><span class="p">,</span> <span class="s2">&quot;example.org&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;/home/py3k/Lib/ssl.py&quot;</span>, line <span class="m">130</span>, in <span class="n">match_hostname</span>
<span class="gr">ssl.CertificateError</span>: <span class="n">hostname &#39;example.org&#39; doesn&#39;t match &#39;example.com&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3.3으로 변경: </span>이 함수는 이제 <span class="target" id="index-43"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6125.html"><strong>RFC 6125</strong></a>, 6.4.3절을 따르며 다중 와일드 카드(예를 들어, <code class="docutils literal notranslate"><span class="pre">*.*.com</span></code> 나 <code class="docutils literal notranslate"><span class="pre">*a*.example.org</span></code>)나 국제화된 도메인 이름(IDN) 내부의 와일드 카드와 일치하지 않습니다. <code class="docutils literal notranslate"><span class="pre">www*.xn--pthon-kva.org</span></code>과 같은 IDN A-레이블은 계속 지원되지만, <code class="docutils literal notranslate"><span class="pre">x*.python.org</span></code>는 더는 <code class="docutils literal notranslate"><span class="pre">xn--tda.python.org</span></code>와 일치하지 않습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>인증서의 subjectAltName 필드에 있을 때, IP 주소의 일치는 이제 지원됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>이 함수는 더는 TLS 연결에 사용되지 않습니다. 이제 호스트명 일치는 OpenSSL에 의해 수행됩니다.</p>
<p>와일드 카드가 가장 왼쪽에 있고 그 세그먼트의 유일한 문자일 때 와일드 카드를 허용합니다. <code class="docutils literal notranslate"><span class="pre">www*.example.com</span></code>와 같은 부분적인 와일드 카드는 더는 지원되지 않습니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.7 폐지.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.cert_time_to_seconds">
<code class="descclassname">ssl.</code><code class="descname">cert_time_to_seconds</code><span class="sig-paren">(</span><em>cert_time</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.cert_time_to_seconds" title="정의 주소">¶</a></dt>
<dd><p>인증서의 &quot;notBefore&quot; 나 &quot;notAfter&quot; 날짜를 나타내는 <code class="docutils literal notranslate"><span class="pre">&quot;%b</span> <span class="pre">%d</span> <span class="pre">%H:%M:%S</span> <span class="pre">%Y</span> <span class="pre">%Z&quot;</span></code> strptime 형식(C 로케일)의 <code class="docutils literal notranslate"><span class="pre">cert_time</span></code> 문자열이 지정하는 시간을 Epoch 이후 초 단위로 반환합니다.</p>
<p>여기 예제가 있습니다:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">cert_time_to_seconds</span><span class="p">(</span><span class="s2">&quot;Jan  5 09:34:43 2018 GMT&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span>  
<span class="go">1515144883</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span><span class="n">timestamp</span><span class="p">))</span>  
<span class="go">2018-01-05 09:34:43</span>
</pre></div>
</div>
<p>&quot;notBefore&quot; 나 &quot;notAfter&quot; 날짜는 GMT(<span class="target" id="index-44"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5280.html"><strong>RFC 5280</strong></a>)를 사용해야합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>입력된 시간을 입력 문자열의 'GMT' 시간대로 지정된 UTC 시간으로 해석합니다. 이전에는 지역 시간대가 사용되었습니다. 정수를 반환합니다 (입력 형식에는 부분 초가 없습니다).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.get_server_certificate">
<code class="descclassname">ssl.</code><code class="descname">get_server_certificate</code><span class="sig-paren">(</span><em>addr</em>, <em>ssl_version=PROTOCOL_TLS</em>, <em>ca_certs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.get_server_certificate" title="정의 주소">¶</a></dt>
<dd><p>주어진 SSL로 보호된 서버의 주소 <code class="docutils literal notranslate"><span class="pre">addr</span></code>((<em>hostname</em>, <em>port-number</em>) 쌍)에 대해, 서버 인증서를 가져 와서 PEM-인코딩된 문자열로 반환합니다. <code class="docutils literal notranslate"><span class="pre">ssl_version</span></code>이 지정되면, 해당 버전의 SSL 프로토콜을 사용하여 서버에 연결을 시도합니다. <code class="docutils literal notranslate"><span class="pre">ca_certs</span></code>가 지정되면, 루트 인증서 목록을 포함하는 파일이어야하는데, <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>에서 같은 매개 변수에 사용 된 것과 같은 형식입니다. 호출은 해당 루트 인증서 집합에 대해 서버 인증서의 유효성을 검사하려고 시도하며, 유효성 검사 시도가 실패하면 실패합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>이 함수는 이제 IPv6와 호환됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>최신 서버와의 호환성을 최대화하기 위해 기본 <em>ssl_version</em>이 <a class="reference internal" href="#ssl.PROTOCOL_SSLv3" title="ssl.PROTOCOL_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_SSLv3</span></code></a>에서 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>로 변경되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.DER_cert_to_PEM_cert">
<code class="descclassname">ssl.</code><code class="descname">DER_cert_to_PEM_cert</code><span class="sig-paren">(</span><em>DER_cert_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.DER_cert_to_PEM_cert" title="정의 주소">¶</a></dt>
<dd><p>인증서가 DER-인코딩된 바이트열로 주어지면, 같은 인증서의 PEM-인코딩된 문자열 버전을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.PEM_cert_to_DER_cert">
<code class="descclassname">ssl.</code><code class="descname">PEM_cert_to_DER_cert</code><span class="sig-paren">(</span><em>PEM_cert_string</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.PEM_cert_to_DER_cert" title="정의 주소">¶</a></dt>
<dd><p>인증서가 ASCII PEM 문자열로 주어지면, 같은 인증서의 DER-인코딩된 바이트열 시퀀스를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.get_default_verify_paths">
<code class="descclassname">ssl.</code><code class="descname">get_default_verify_paths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.get_default_verify_paths" title="정의 주소">¶</a></dt>
<dd><p>OpenSSL의 기본 cafile 및 capath에 대한 경로가있는 네임드 튜플을 반환합니다. 경로는 <a class="reference internal" href="#ssl.SSLContext.set_default_verify_paths" title="ssl.SSLContext.set_default_verify_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_default_verify_paths()</span></code></a>에서 사용하는 경로와 같습니다. 반환 값은 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> <code class="docutils literal notranslate"><span class="pre">DefaultVerifyPaths</span></code>입니다.:</p>
<ul class="simple">
<li><code class="xref py py-attr docutils literal notranslate"><span class="pre">cafile</span></code> - cafile에 대한 확인된 경로나 파일이 존재하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>,</li>
<li><code class="xref py py-attr docutils literal notranslate"><span class="pre">capath</span></code> - capath에 대한 확인된 경로나 디렉터리가 존재하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>,</li>
<li><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_cafile_env</span></code> - cafile을 가리키는 OpenSSL의 환경 키,</li>
<li><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_cafile</span></code> - cafile에 대한 하드 코딩된 경로,</li>
<li><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_capath_env</span></code> - capath를 가리키는 OpenSSL의 환경 키,</li>
<li><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_capath</span></code> - capath 디렉터리에 대한 하드 코딩된 경로</li>
</ul>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: LibreSSL은 환경 변수 <code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_cafile_env</span></code> 와 <code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_capath_env</span></code>를 무시합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.enum_certificates">
<code class="descclassname">ssl.</code><code class="descname">enum_certificates</code><span class="sig-paren">(</span><em>store_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.enum_certificates" title="정의 주소">¶</a></dt>
<dd><p>윈도우의 시스템 인증서 저장소에서 인증서를 꺼냅니다. <em>store_name</em>은 <code class="docutils literal notranslate"><span class="pre">CA</span></code>, <code class="docutils literal notranslate"><span class="pre">ROOT</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">MY</span></code> 중 하나 일 수 있습니다. 윈도우가 추가 인증서 저장소를 제공 할 수도 있습니다.</p>
<p>이 함수는 (cert_bytes, encoding_type, trust) 튜플의 리스트를 반환합니다. encoding_type은 cert_bytes의 인코딩을 지정합니다. X.509 ASN.1 데이터를 위한 <code class="xref py py-const docutils literal notranslate"><span class="pre">x509_asn</span></code>이거나 PKCS#7 ASN.1 데이터를 위한 <code class="xref py py-const docutils literal notranslate"><span class="pre">pkcs_7_asn</span></code>입니다. Trust는 인증서의 목적을 OIDS 집합으로 지정하거나, 인증서가 모든 목적에 대해 신뢰할 수 있으면 정확히 <code class="docutils literal notranslate"><span class="pre">True</span></code>입니다.</p>
<p>예제:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">enum_certificates</span><span class="p">(</span><span class="s2">&quot;CA&quot;</span><span class="p">)</span>
<span class="go">[(b&#39;data...&#39;, &#39;x509_asn&#39;, {&#39;1.3.6.1.5.5.7.3.1&#39;, &#39;1.3.6.1.5.5.7.3.2&#39;}),</span>
<span class="go"> (b&#39;data...&#39;, &#39;x509_asn&#39;, True)]</span>
</pre></div>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 윈도우.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.enum_crls">
<code class="descclassname">ssl.</code><code class="descname">enum_crls</code><span class="sig-paren">(</span><em>store_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.enum_crls" title="정의 주소">¶</a></dt>
<dd><p>윈도우의 시스템 인증서 저장소에서 CRL을 꺼냅니다. <em>store_name</em>는 <code class="docutils literal notranslate"><span class="pre">CA</span></code>, <code class="docutils literal notranslate"><span class="pre">ROOT</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">MY</span></code> 중 하나 일 수 있습니다. 윈도우가 추가 인증서 저장소를 제공 할 수도 있습니다.</p>
<p>이 함수는 (cert_bytes, encoding_type, trust) 튜플의 리스트를 반환합니다. encoding_type은 cert_bytes의 인코딩을 지정합니다. X.509 ASN.1 데이터를 위한 <code class="xref py py-const docutils literal notranslate"><span class="pre">x509_asn</span></code>이거나 PKCS#7 ASN.1 데이터를 위한 <code class="xref py py-const docutils literal notranslate"><span class="pre">pkcs_7_asn</span></code>입니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 윈도우.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.wrap_socket">
<code class="descclassname">ssl.</code><code class="descname">wrap_socket</code><span class="sig-paren">(</span><em>sock</em>, <em>keyfile=None</em>, <em>certfile=None</em>, <em>server_side=False</em>, <em>cert_reqs=CERT_NONE</em>, <em>ssl_version=PROTOCOL_TLS</em>, <em>ca_certs=None</em>, <em>do_handshake_on_connect=True</em>, <em>suppress_ragged_eofs=True</em>, <em>ciphers=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.wrap_socket" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>의 인스턴스 <code class="docutils literal notranslate"><span class="pre">sock</span></code>을 취해서, SSL 컨텍스트에 하부 소켓을 감싸는 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>의 서브 형인 <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> 인스턴스를 반환합니다. <code class="docutils literal notranslate"><span class="pre">sock</span></code>은 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a> 소켓이어야합니다; 다른 소켓 유형은 지원되지 않습니다.</p>
<p>내부적으로, 함수는 프로토콜이 <em>ssl_version</em> 이고 <a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.options</span></code></a>이 <em>cert_reqs</em>로 설정된 <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>를 만듭니다. 매개 변수 <em>keyfile</em>, <em>certfile</em>, <em>ca_certs</em> 또는 <em>ciphers</em>가 설정되면, 값은 <a class="reference internal" href="#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_cert_chain()</span></code></a>, <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a> 및 <a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a>로 전달됩니다.</p>
<p>인자 <em>server_side</em>, <em>do_handshake_on_connect</em> 및 <em>suppress_ragged_eofs</em>는 <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>와 같은 의미를 갖습니다.</p>
<div class="deprecated">
<p><span class="versionmodified">버전 3.7 폐지: </span>파이썬 3.2 와 2.7.9부터, <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> 대신 <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>를 사용하는 것이 좋습니다. 최상위 함수는 제한적이고 서버 이름 표시나 호스트명 일치가 없는 안전하지 않은 클라이언트 소켓을 만듭니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="constants">
<h3>상수<a class="headerlink" href="#constants" title="제목 주소">¶</a></h3>
<blockquote>
<div><p>모든 상수는 이제 <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> 이나 <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> 컬렉션입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</div></blockquote>
<dl class="data">
<dt id="ssl.CERT_NONE">
<code class="descclassname">ssl.</code><code class="descname">CERT_NONE</code><a class="headerlink" href="#ssl.CERT_NONE" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a>나 <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">cert_reqs</span></code> 매개 변수의 가능한 값. <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a>를 제외하고는, 기본 모드입니다. 클라이언트 측 소켓에서는, 모든 인증서가 허용됩니다. 신뢰할 수 없거나 만료 된 인증서와 같은 유효성 검사 에러는 무시되며 TLS/SSL 핸드 셰이크를 중단하지 않습니다.</p>
<p>서버 모드에서는, 클라이언트에서 인증서를 요청하지 않으므로 클라이언트는 클라이언트 인증서 인증을 위해 인증서를 보내지 않습니다.</p>
<p>아래의 <a class="reference internal" href="#ssl-security"><span class="std std-ref">보안 고려 사항</span></a>의 논의를 참조하십시오.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_OPTIONAL">
<code class="descclassname">ssl.</code><code class="descname">CERT_OPTIONAL</code><a class="headerlink" href="#ssl.CERT_OPTIONAL" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a>나 <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">cert_reqs</span></code> 매개 변수의 가능한 값. 클라이언트 모드에서, <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a>는 <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>와 같은 의미를 갖습니다. 클라이언트 측 소켓에서는 대신 <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>를 사용하는 것이 좋습니다.</p>
<p>서버 모드에서는, 클라이언트 인증서 요청이 클라이언트로 전송됩니다. 클라이언트는 요청을 무시하거나 TLS 클라이언트 인증서 인증을 수행하기 위해 인증서를 보낼 수 있습니다. 클라이언트가 인증서를 보내기로 선택하면, 인증서가 유효성 검사됩니다. 모든 유효성 검사 에러는 TLS 핸드 셰이크를 즉시 중단합니다.</p>
<p>이 설정을 사용하려면 유효한 CA 인증서 집합을 <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a> 나 <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">ca_certs</span></code> 매개 변수 값으로 전달해야합니다.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_REQUIRED">
<code class="descclassname">ssl.</code><code class="descname">CERT_REQUIRED</code><a class="headerlink" href="#ssl.CERT_REQUIRED" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a>나 <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">cert_reqs</span></code> 매개 변수의 가능한 값. 이 모드에서는, 소켓 연결의 다른 쪽에서 인증서를 요구합니다; 인증서가 제공되지 않거나 유효성 검사에 실패하면 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a>가 발생합니다. 이 모드는 호스트명 일치를 수행하지 않기 때문에 클라이언트 모드에서 인증서를 유효성 검사하기에 충분하지 <strong>않습니다</strong>. 인증서의 진위를 검사하기위해 <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a>도 활성화해야 합니다. <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a>는 기본적으로 <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>를 사용하고 <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a>을 활성화합니다.</p>
<p>서버 소켓에서, 이 모드는 필수 TLS 클라이언트 인증서 인증을 제공합니다. 클라이언트 인증서 요청이 클라이언트에 보내지고 클라이언트는 유효하고 신뢰할 수 있는 인증서를 제공해야합니다.</p>
<p>이 설정을 사용하려면 유효한 CA 인증서 집합을 <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a> 나 <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">ca_certs</span></code> 매개 변수 값으로 전달해야합니다.</p>
</dd></dl>

<dl class="class">
<dt id="ssl.VerifyMode">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">VerifyMode</code><a class="headerlink" href="#ssl.VerifyMode" title="정의 주소">¶</a></dt>
<dd><p>CERT_* 상수의 <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> 컬렉션.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_DEFAULT">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_DEFAULT</code><a class="headerlink" href="#ssl.VERIFY_DEFAULT" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a>의 가능한 값. 이 모드에서는 인증서 해지 목록(CRL)을 검사하지 않습니다. 기본적으로 OpenSSL은 CRL을 요구하지도 검사하지도 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_CRL_CHECK_LEAF">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_CRL_CHECK_LEAF</code><a class="headerlink" href="#ssl.VERIFY_CRL_CHECK_LEAF" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a>의 가능한 값. 이 모드에서는, 피어 인증서만 확인할뿐 중간 CA 인증서는 확인하지 않습니다. 이 모드는 피어 인증서의 발급자(그 것의 직계 조상 CA)가 서명한 유효한 CRL을 요구합니다. <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations</span></code></a>가 적절히 로드하지 않으면 유효성 검사가 실패합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_CRL_CHECK_CHAIN">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_CRL_CHECK_CHAIN</code><a class="headerlink" href="#ssl.VERIFY_CRL_CHECK_CHAIN" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a>의 가능한 값. 이 모드에서는, 피어 인증서 체인의 모든 인증서에 대한 CRL이 확인됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_X509_STRICT">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_X509_STRICT</code><a class="headerlink" href="#ssl.VERIFY_X509_STRICT" title="정의 주소">¶</a></dt>
<dd><p>망가진 X.509 인증서에 대한 우회를 사용하지 못하도록 하는 <a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a>의 가능한 값.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.VERIFY_X509_TRUSTED_FIRST">
<code class="descclassname">ssl.</code><code class="descname">VERIFY_X509_TRUSTED_FIRST</code><a class="headerlink" href="#ssl.VERIFY_X509_TRUSTED_FIRST" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a>의 가능한 값. OpenSSL이 인증서의 유효성을 검사하기 위해 트러스트 체인을 구축 할 때 신뢰할 수 있는 인증서를 선호하도록 지시합니다. 이 플래그는 기본적으로 활성화됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="ssl.VerifyFlags">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">VerifyFlags</code><a class="headerlink" href="#ssl.VerifyFlags" title="정의 주소">¶</a></dt>
<dd><p>VERIFY_* 상수의 <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> 컬렉션.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLS">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLS</code><a class="headerlink" href="#ssl.PROTOCOL_TLS" title="정의 주소">¶</a></dt>
<dd><p>클라이언트와 서버가 모두 지원하는 가장 높은 프로토콜 버전을 선택합니다. 이름에도 불구하고, 이 옵션은 &quot;SSL&quot; 과 &quot;TLS&quot; 프로토콜을 모두 선택할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLS_CLIENT">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLS_CLIENT</code><a class="headerlink" href="#ssl.PROTOCOL_TLS_CLIENT" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>처럼 가장 높은 프로토콜 버전을 자동 협상하지만, 클라이언트 측 <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> 연결 만 지원합니다. 이 프로토콜은 기본적으로 <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> 와 <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a>을 활성화합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLS_SERVER">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLS_SERVER</code><a class="headerlink" href="#ssl.PROTOCOL_TLS_SERVER" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>처럼 가장 높은 프로토콜 버전을 자동 협상하지만, 서버 측 <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> 연결 만 지원합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv23">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv23</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv23" title="정의 주소">¶</a></dt>
<dd><p>data:<cite>PROTOCOL_TLS</cite>의 별칭.</p>
<div class="deprecated">
<p><span class="versionmodified">버전 3.6 폐지: </span>대신 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>를 사용하십시오.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv2">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv2</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv2" title="정의 주소">¶</a></dt>
<dd><p>채널 암호화 프로토콜로 SSL 버전 2를 선택합니다.</p>
<p>OpenSSL이 <code class="docutils literal notranslate"><span class="pre">OPENSSL_NO_SSL2</span></code> 플래그로 컴파일 되었으면 이 프로토콜을 사용할 수 없습니다.</p>
<div class="admonition warning">
<p class="first admonition-title">경고</p>
<p class="last">SSL 버전 2는 안전하지 않습니다. 사용하지 말도록 강력히 권고합니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.6 폐지: </span>OpenSSL은 SSLv2에 대한 지원을 제거했습니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv3">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv3</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv3" title="정의 주소">¶</a></dt>
<dd><p>채널 암호화 프로토콜로 SSL 버전 3을 선택합니다.</p>
<p>OpenSSL이 <code class="docutils literal notranslate"><span class="pre">OPENSSL_NO_SSLv3</span></code> 플래그로 컴파일 되었으면 이 프로토콜을 사용할 수 없습니다.</p>
<div class="admonition warning">
<p class="first admonition-title">경고</p>
<p class="last">SSL 버전 3은 안전하지 않습니다. 사용하지 말도록 강력히 권고합니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.6 폐지: </span>OpenSSL은 모든 버전 특정 프로토콜을 폐지했습니다. 대신 <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a>와 같은 플래그와 함께 기본 프로토콜 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>를 사용하십시오.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLSv1">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLSv1</code><a class="headerlink" href="#ssl.PROTOCOL_TLSv1" title="정의 주소">¶</a></dt>
<dd><p>채널 암호화 프로토콜로 TLS 버전 1.0을 선택합니다.</p>
<div class="deprecated">
<p><span class="versionmodified">버전 3.6 폐지: </span>OpenSSL은 모든 버전 특정 프로토콜을 폐지했습니다. 대신 <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a>와 같은 플래그와 함께 기본 프로토콜 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>를 사용하십시오.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLSv1_1">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLSv1_1</code><a class="headerlink" href="#ssl.PROTOCOL_TLSv1_1" title="정의 주소">¶</a></dt>
<dd><p>채널 암호화 프로토콜로 TLS 버전 1.1을 선택합니다. openssl 버전 1.0.1+ 에서만 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.6 폐지: </span>OpenSSL은 모든 버전 특정 프로토콜을 폐지했습니다. 대신 <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a>와 같은 플래그와 함께 기본 프로토콜 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>를 사용하십시오.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLSv1_2">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLSv1_2</code><a class="headerlink" href="#ssl.PROTOCOL_TLSv1_2" title="정의 주소">¶</a></dt>
<dd><p>채널 암호화 프로토콜로 TLS 버전 1.2를 선택합니다. 이것은 가장 현대적인 버전이며, 양측이 모두 가능하다면 최대한의 보호를 위해 아마도 최선의 선택입니다. openssl 버전 1.0.1+ 에서만 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.6 폐지: </span>OpenSSL은 모든 버전 특정 프로토콜을 폐지했습니다. 대신 <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a>와 같은 플래그와 함께 기본 프로토콜 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>를 사용하십시오.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_ALL">
<code class="descclassname">ssl.</code><code class="descname">OP_ALL</code><a class="headerlink" href="#ssl.OP_ALL" title="정의 주소">¶</a></dt>
<dd><p>다른 SSL 구현에있는 다양한 버그에 대한 해결 방법을 활성화합니다. 이 옵션은 기본적으로 설정됩니다. 반드시 OpenSSL의 <code class="docutils literal notranslate"><span class="pre">SSL_OP_ALL</span></code> 상수와 같은 플래그를 설정할 필요는 없습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_SSLv2">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_SSLv2</code><a class="headerlink" href="#ssl.OP_NO_SSLv2" title="정의 주소">¶</a></dt>
<dd><p>SSLv2 연결을 방지합니다. 이 옵션은 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>와 결합해서만 적용 할 수 있습니다. 피어가 SSLv2를 프로토콜 버전으로 선택하지 못하도록합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.6 폐지: </span>SSLv2는 폐지되었습니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_SSLv3">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_SSLv3</code><a class="headerlink" href="#ssl.OP_NO_SSLv3" title="정의 주소">¶</a></dt>
<dd><p>SSLv3 연결을 방지합니다. 이 옵션은 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>와 결합해서만 적용 할 수 있습니다. 피어가 프로토콜 버전으로 SSLv3을 선택하지 못하게합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.6 폐지: </span>SSLv3은 폐지되었습니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TLSv1">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_TLSv1</code><a class="headerlink" href="#ssl.OP_NO_TLSv1" title="정의 주소">¶</a></dt>
<dd><p>TLSv1 연결을 금지합니다. 이 옵션은 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>와 결합해서만 적용 할 수 있습니다. 피어가 TLSv1을 프로토콜 버전으로 선택하지 못하게합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.7 폐지: </span>이 옵션은 OpenSSL 1.1.0부터 폐지되었습니다, 새로운 <a class="reference internal" href="#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.minimum_version</span></code></a> 과 <a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a>를 대신 사용하십시오.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TLSv1_1">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_TLSv1_1</code><a class="headerlink" href="#ssl.OP_NO_TLSv1_1" title="정의 주소">¶</a></dt>
<dd><p>TLSv1.1 연결을 금지합니다. 이 옵션은 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>와 결합해서만 적용 할 수 있습니다. 피어가 TLSv1.1을 프로토콜 버전으로 선택하지 못하게합니다. openssl 버전 1.0.1+ 에서만 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.7 폐지: </span>이 옵션은 OpenSSL 1.1.0부터 폐지되었습니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TLSv1_2">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_TLSv1_2</code><a class="headerlink" href="#ssl.OP_NO_TLSv1_2" title="정의 주소">¶</a></dt>
<dd><p>TLSv1.2 연결을 방지합니다. 이 옵션은 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>와 결합해서만 적용 할 수 있습니다. 피어가 프로토콜 버전으로 TLSv1.2를 선택하지 못하게합니다. openssl 버전 1.0.1+ 에서만 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.7 폐지: </span>이 옵션은 OpenSSL 1.1.0부터 폐지되었습니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TLSv1_3">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_TLSv1_3</code><a class="headerlink" href="#ssl.OP_NO_TLSv1_3" title="정의 주소">¶</a></dt>
<dd><p>TLSv1.3 연결을 방지합니다. 이 옵션은 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>와 결합해서만 적용 할 수 있습니다. 피어가 프로토콜 버전으로 TLSv1.3을 선택하지 못하게합니다. TLS 1.3은 OpenSSL 1.1.1 이상에서 사용할 수 있습니다. 파이썬이 OpenSSL의 이전 버전에 대해 컴파일되면, 플래그의 기본값은 <em>0</em>입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.7 폐지: </span>이 옵션은 OpenSSL 1.1.0부터 폐지되었습니다. OpenSSL 1.0.2와의 하위 호환성을 위해 2.7.15, 3.6.3 및 3.7.0에 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_RENEGOTIATION">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_RENEGOTIATION</code><a class="headerlink" href="#ssl.OP_NO_RENEGOTIATION" title="정의 주소">¶</a></dt>
<dd><p>TLSv1.2 와 그 이전 버전에서 모든 재협상을 비활성화합니다. HelloRequest 메시지를 보내지 않고, ClientHello를 통한 재협상 요청을 무시합니다.</p>
<p>이 옵션은 OpenSSL 1.1.0h 이상에서만 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_CIPHER_SERVER_PREFERENCE">
<code class="descclassname">ssl.</code><code class="descname">OP_CIPHER_SERVER_PREFERENCE</code><a class="headerlink" href="#ssl.OP_CIPHER_SERVER_PREFERENCE" title="정의 주소">¶</a></dt>
<dd><p>클라이언트 보다는 서버의 사이퍼 순서 선호를 사용합니다. 이 옵션은 클라이언트 소켓과 SSLv2 서버 소켓에는 영향을 미치지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_SINGLE_DH_USE">
<code class="descclassname">ssl.</code><code class="descname">OP_SINGLE_DH_USE</code><a class="headerlink" href="#ssl.OP_SINGLE_DH_USE" title="정의 주소">¶</a></dt>
<dd><p>서로 다른 SSL 세션에 대해 같은 DH 키 재사용을 방지합니다. 이렇게하면 FS(forward secrecy)는 향상되지만 더 많은 계산 자원을 요구합니다. 이 옵션은 서버 소켓에만 적용됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_SINGLE_ECDH_USE">
<code class="descclassname">ssl.</code><code class="descname">OP_SINGLE_ECDH_USE</code><a class="headerlink" href="#ssl.OP_SINGLE_ECDH_USE" title="정의 주소">¶</a></dt>
<dd><p>서로 다른 SSL 세션에 대해 같은 ECDH 키 재사용을 방지합니다. 이렇게하면 FS(forward secrecy)은 향상되지만 더 많은 계산 자원을 요구합니다. 이 옵션은 서버 소켓에만 적용됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_ENABLE_MIDDLEBOX_COMPAT">
<code class="descclassname">ssl.</code><code class="descname">OP_ENABLE_MIDDLEBOX_COMPAT</code><a class="headerlink" href="#ssl.OP_ENABLE_MIDDLEBOX_COMPAT" title="정의 주소">¶</a></dt>
<dd><p>TLS 1.3 연결을 더 TLS 1.2 연결처럼 보이게하기위해 TLS 1.3 핸드 셰이크에서 더미 암호 변경 사양(CCS - Change Cipher Spec) 메시지를 보냅니다.</p>
<p>이 옵션은 OpenSSL 1.1.1 이상에서만 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_COMPRESSION">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_COMPRESSION</code><a class="headerlink" href="#ssl.OP_NO_COMPRESSION" title="정의 주소">¶</a></dt>
<dd><p>SSL 채널에서 압축을 사용하지 않습니다. 응용 프로그램 프로토콜이 자체 압축 방법을 지원할 때 유용합니다.</p>
<p>이 옵션은 OpenSSL 1.0.0 이상에서만 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="ssl.Options">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">Options</code><a class="headerlink" href="#ssl.Options" title="정의 주소">¶</a></dt>
<dd><p>OP_* 상수의 <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> 컬렉션.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TICKET">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_TICKET</code><a class="headerlink" href="#ssl.OP_NO_TICKET" title="정의 주소">¶</a></dt>
<dd><p>클라이언트 측에서 세션 티켓을 요청하지 못하게합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_ALPN">
<code class="descclassname">ssl.</code><code class="descname">HAS_ALPN</code><a class="headerlink" href="#ssl.HAS_ALPN" title="정의 주소">¶</a></dt>
<dd><p>OpenSSL 라이브러리가 <span class="target" id="index-45"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7301.html"><strong>RFC 7301</strong></a>에서 설명한대로 <em>응용 계층 프로토콜 협상(Application-Layer Protocol Negotiation)</em> TLS 확장에 대한 지원을 기본 제공하는지 여부</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_NEVER_CHECK_COMMON_NAME">
<code class="descclassname">ssl.</code><code class="descname">HAS_NEVER_CHECK_COMMON_NAME</code><a class="headerlink" href="#ssl.HAS_NEVER_CHECK_COMMON_NAME" title="정의 주소">¶</a></dt>
<dd><p>OpenSSL 라이브러리가 SCN(subject common name)을 검사하지않는 지원을 기본 제공하고 <a class="reference internal" href="#ssl.SSLContext.hostname_checks_common_name" title="ssl.SSLContext.hostname_checks_common_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.hostname_checks_common_name</span></code></a>가 쓰기 가능한지 여부.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_ECDH">
<code class="descclassname">ssl.</code><code class="descname">HAS_ECDH</code><a class="headerlink" href="#ssl.HAS_ECDH" title="정의 주소">¶</a></dt>
<dd><p>OpenSSL 라이브러리가 타원 곡선(Elliptic Curve) 기반 Diffie-Hellman 키 교환 지원을 기본 제공하는지 여부. 기능이 배포자에 의해 명시적으로 비활성화되어 있지 않는 한 참이어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_SNI">
<code class="descclassname">ssl.</code><code class="descname">HAS_SNI</code><a class="headerlink" href="#ssl.HAS_SNI" title="정의 주소">¶</a></dt>
<dd><p>OpenSSL 라이브러리가 <em>서버 이름 표시(Server Name Indication)</em> 확장(<span class="target" id="index-46"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6066.html"><strong>RFC 6066</strong></a>에 정의 된대로)에 대한 지원을 기본 제공하는지 여부.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_NPN">
<code class="descclassname">ssl.</code><code class="descname">HAS_NPN</code><a class="headerlink" href="#ssl.HAS_NPN" title="정의 주소">¶</a></dt>
<dd><p>OpenSSL 라이브러리가 <a class="reference external" href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation">Application Layer Protocol Negotiation</a>에 설명 된대로 <em>NPN(Next Protocol Negotiation)</em>에 대한 지원을 기본 제공하는지 여부. 참이면 <a class="reference internal" href="#ssl.SSLContext.set_npn_protocols" title="ssl.SSLContext.set_npn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_npn_protocols()</span></code></a> 메서드를 사용하여 지원할 프로토콜을 알릴 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_SSLv2">
<code class="descclassname">ssl.</code><code class="descname">HAS_SSLv2</code><a class="headerlink" href="#ssl.HAS_SSLv2" title="정의 주소">¶</a></dt>
<dd><p>OpenSSL 라이브러리가 SSL 2.0 프로토콜 지원을 기본 제공하는지 여부</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_SSLv3">
<code class="descclassname">ssl.</code><code class="descname">HAS_SSLv3</code><a class="headerlink" href="#ssl.HAS_SSLv3" title="정의 주소">¶</a></dt>
<dd><p>OpenSSL 라이브러리가 SSL 3.0 프로토콜 지원을 기본 제공하는지 여부</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_TLSv1">
<code class="descclassname">ssl.</code><code class="descname">HAS_TLSv1</code><a class="headerlink" href="#ssl.HAS_TLSv1" title="정의 주소">¶</a></dt>
<dd><p>OpenSSL 라이브러리가 TLS 1.0 프로토콜 지원을 기본 제공하는지 여부</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_TLSv1_1">
<code class="descclassname">ssl.</code><code class="descname">HAS_TLSv1_1</code><a class="headerlink" href="#ssl.HAS_TLSv1_1" title="정의 주소">¶</a></dt>
<dd><p>OpenSSL 라이브러리가 TLS 1.1 프로토콜 지원을 기본 제공하는지 여부</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_TLSv1_2">
<code class="descclassname">ssl.</code><code class="descname">HAS_TLSv1_2</code><a class="headerlink" href="#ssl.HAS_TLSv1_2" title="정의 주소">¶</a></dt>
<dd><p>OpenSSL 라이브러리가 TLS 1.2 프로토콜 지원을 기본 제공하는지 여부</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_TLSv1_3">
<code class="descclassname">ssl.</code><code class="descname">HAS_TLSv1_3</code><a class="headerlink" href="#ssl.HAS_TLSv1_3" title="정의 주소">¶</a></dt>
<dd><p>OpenSSL 라이브러리가 TLS 1.3 프로토콜 지원을 기본 제공하는지 여부</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.CHANNEL_BINDING_TYPES">
<code class="descclassname">ssl.</code><code class="descname">CHANNEL_BINDING_TYPES</code><a class="headerlink" href="#ssl.CHANNEL_BINDING_TYPES" title="정의 주소">¶</a></dt>
<dd><p>지원되는 TLS 채널 바인딩 유형의 리스트. 이 리스트의 문자열은 <a class="reference internal" href="#ssl.SSLSocket.get_channel_binding" title="ssl.SSLSocket.get_channel_binding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.get_channel_binding()</span></code></a>에 대한 인자로 사용될 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION">
<code class="descclassname">ssl.</code><code class="descname">OPENSSL_VERSION</code><a class="headerlink" href="#ssl.OPENSSL_VERSION" title="정의 주소">¶</a></dt>
<dd><p>인터프리터에 의해 로드된 OpenSSL 라이브러리의 버전 문자열:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION</span>
<span class="go">&#39;OpenSSL 1.0.2k  26 Jan 2017&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION_INFO">
<code class="descclassname">ssl.</code><code class="descname">OPENSSL_VERSION_INFO</code><a class="headerlink" href="#ssl.OPENSSL_VERSION_INFO" title="정의 주소">¶</a></dt>
<dd><p>OpenSSL 라이브러리에 대한 버전 정보를 나타내는 5 개의 정수 튜플:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_INFO</span>
<span class="go">(1, 0, 2, 11, 15)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION_NUMBER">
<code class="descclassname">ssl.</code><code class="descname">OPENSSL_VERSION_NUMBER</code><a class="headerlink" href="#ssl.OPENSSL_VERSION_NUMBER" title="정의 주소">¶</a></dt>
<dd><p>단일 정수로 표현되는, OpenSSL 라이브러리의 원시 버전 번호:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span>
<span class="go">268443839</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span><span class="p">)</span>
<span class="go">&#39;0x100020bf&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE">
<code class="descclassname">ssl.</code><code class="descname">ALERT_DESCRIPTION_HANDSHAKE_FAILURE</code><a class="headerlink" href="#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE" title="정의 주소">¶</a></dt>
<dt id="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR">
<code class="descclassname">ssl.</code><code class="descname">ALERT_DESCRIPTION_INTERNAL_ERROR</code><a class="headerlink" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">ALERT_DESCRIPTION_*</code></dt>
<dd><p><span class="target" id="index-47"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5246.html"><strong>RFC 5246</strong></a> 및 기타의 경고 설명. <a class="reference external" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-6">IANA TLS Alert Registry</a>에는 이 목록과 그 의미가 정의된 RFC에 대한 참조가 들어 있습니다.</p>
<p><a class="reference internal" href="#ssl.SSLContext.set_servername_callback" title="ssl.SSLContext.set_servername_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_servername_callback()</span></code></a>에서 콜백 함수의 반환 값으로 사용됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="ssl.AlertDescription">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">AlertDescription</code><a class="headerlink" href="#ssl.AlertDescription" title="정의 주소">¶</a></dt>
<dd><p>ALERT_DESCRIPTION_* 상수의 <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> 컬렉션.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.Purpose.SERVER_AUTH">
<code class="descclassname">Purpose.</code><code class="descname">SERVER_AUTH</code><a class="headerlink" href="#ssl.Purpose.SERVER_AUTH" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> 와 <a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a> 옵션. 이 값은 컨텍스트가 웹 서버를 인증하는 데 사용될 수 있음을 나타냅니다 (따라서 클라이언트 측 소켓을 만드는 데 사용됩니다).</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.Purpose.CLIENT_AUTH">
<code class="descclassname">Purpose.</code><code class="descname">CLIENT_AUTH</code><a class="headerlink" href="#ssl.Purpose.CLIENT_AUTH" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> 와 <a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a> 옵션. 이 값은 컨텍스트가 웹 클라이언트를 인증하는 데 사용될 수 있음을 나타냅니다 (따라서 서버 측 소켓을 만드는 데 사용됩니다).</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="ssl.SSLErrorNumber">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">SSLErrorNumber</code><a class="headerlink" href="#ssl.SSLErrorNumber" title="정의 주소">¶</a></dt>
<dd><p>SSL_ERROR_* 상수의 <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> 컬렉션.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="ssl.TLSVersion">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">TLSVersion</code><a class="headerlink" href="#ssl.TLSVersion" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a> 과 <a class="reference internal" href="#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.minimum_version</span></code></a> 용 SSL 과 TLS 버전의 <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> 컬렉션.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.TLSVersion.MINIMUM_SUPPORTED">
<code class="descclassname">TLSVersion.</code><code class="descname">MINIMUM_SUPPORTED</code><a class="headerlink" href="#ssl.TLSVersion.MINIMUM_SUPPORTED" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.TLSVersion.MAXIMUM_SUPPORTED">
<code class="descclassname">TLSVersion.</code><code class="descname">MAXIMUM_SUPPORTED</code><a class="headerlink" href="#ssl.TLSVersion.MAXIMUM_SUPPORTED" title="정의 주소">¶</a></dt>
<dd><p>지원되는 SSL 또는 TLS 버전의 최소 또는 최대. 이것들은 마법 상수(magic constant)입니다. 이들의 값은 사용 가능한 가장 낮거나 높은 TLS/SSL 버전을 반영하지 않습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.TLSVersion.SSLv3">
<code class="descclassname">TLSVersion.</code><code class="descname">SSLv3</code><a class="headerlink" href="#ssl.TLSVersion.SSLv3" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.TLSVersion.TLSv1">
<code class="descclassname">TLSVersion.</code><code class="descname">TLSv1</code><a class="headerlink" href="#ssl.TLSVersion.TLSv1" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.TLSVersion.TLSv1_1">
<code class="descclassname">TLSVersion.</code><code class="descname">TLSv1_1</code><a class="headerlink" href="#ssl.TLSVersion.TLSv1_1" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.TLSVersion.TLSv1_2">
<code class="descclassname">TLSVersion.</code><code class="descname">TLSv1_2</code><a class="headerlink" href="#ssl.TLSVersion.TLSv1_2" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.TLSVersion.TLSv1_3">
<code class="descclassname">TLSVersion.</code><code class="descname">TLSv1_3</code><a class="headerlink" href="#ssl.TLSVersion.TLSv1_3" title="정의 주소">¶</a></dt>
<dd><p>SSL 3.0 에서 TLS 1.3.</p>
</dd></dl>

</div>
</div>
<div class="section" id="ssl-sockets">
<h2>SSL 소켓<a class="headerlink" href="#ssl-sockets" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="ssl.SSLSocket">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">SSLSocket</code><span class="sig-paren">(</span><em>socket.socket</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket" title="정의 주소">¶</a></dt>
<dd><p>SSL 소켓은 다음과 같은 <a class="reference internal" href="socket.html#socket-objects"><span class="std std-ref">소켓 객체</span></a> 메서드를 제공합니다:</p>
<ul class="simple">
<li><a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.bind" title="socket.socket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.detach" title="socket.socket.detach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">detach()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.fileno" title="socket.socket.fileno"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.getpeername" title="socket.socket.getpeername"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeername()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.getsockname" title="socket.socket.getsockname"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getsockname()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.getsockopt" title="socket.socket.getsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getsockopt()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.setsockopt" title="socket.socket.setsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.gettimeout" title="socket.socket.gettimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gettimeout()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a>,
<a class="reference internal" href="socket.html#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setblocking()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv_into()</span></code></a> (그러나 0이 아닌 <code class="docutils literal notranslate"><span class="pre">flags</span></code> 인자를 전달하는 것은 허용되지 않습니다)</li>
<li><a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendall()</span></code></a> (같은 제한 있음)</li>
<li><a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendfile()</span></code></a> (그러나 <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a>는 평문 소켓에만 사용되며, 그렇지 않으면 <a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>가 사용됩니다)</li>
<li><a class="reference internal" href="socket.html#socket.socket.shutdown" title="socket.socket.shutdown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code></a></li>
</ul>
<p>그러나 SSL (및 TLS) 프로토콜은 TCP 위에 자체 프레임을 가지고 있기 때문에, SSL 소켓 추상화는 특정 측면에서 정상적인 OS 수준 소켓의 사양에서 벗어날 수 있습니다. 특히 <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">비 블로킹 소켓에 대한 참고 사항</span></a>을 보십시오.</p>
<p><a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>의 인스턴스는 <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> 메서드를 사용하여 민들어야합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendfile()</span></code> 메서드가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span><code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code>은 바이트가 수신되거나 전송될 때마다 소켓 시간제한을 재설정하지 않습니다. 소켓 시간제한은 이제 shutdown의 최대 총 지속 시간입니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.6 폐지: </span><a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> 인스턴스를 직접 만드는 것은 폐지되었습니다, <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>를 사용하여 소켓을 감싸십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> 인스턴스는 <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>로 만들어야합니다. 이전 버전에서는 직접 인스턴스를 만들 수 있었습니다. 이것은 문서로 만들어지거나 공식적으로 지원된 적이 없습니다.</p>
</div>
</dd></dl>

<p>SSL 소켓에는 다음과 같은 추가 메서드와 어트리뷰트도도 있습니다:</p>
<dl class="method">
<dt id="ssl.SSLSocket.read">
<code class="descclassname">SSLSocket.</code><code class="descname">read</code><span class="sig-paren">(</span><em>len=1024</em>, <em>buffer=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.read" title="정의 주소">¶</a></dt>
<dd><p>SSL 소켓에서 최대 <em>len</em> 바이트의 데이터를 읽고 그 결과를 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 인스턴스로 반환합니다. <em>buffer</em>가 지정되면, 대신 버퍼로 읽어 들이고, 읽은 바이트 수를 반환합니다.</p>
<p>소켓이 <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">비 블로킹</span></a>이고 읽기가 블록되려고 하면 <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> 나 <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a>를 발생시킵니다.</p>
<p>언제나 재협상이 가능하기 때문에, <a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>를 호출해도 쓰기 연산이 발생할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>소켓 시간제한은 바이트가 수신되거나 전송 될 때마다 재설정되지 않습니다. 소켓 시간제한은 이제 최대 <em>len</em> 바이트까지 읽을 때 까지의 최대 총 지속 시간입니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.6 폐지: </span><a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> 대신 <code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code>를 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.write">
<code class="descclassname">SSLSocket.</code><code class="descname">write</code><span class="sig-paren">(</span><em>buf</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.write" title="정의 주소">¶</a></dt>
<dd><p>SSL 소켓에 <em>buf</em>를 기록하고, 기록한 바이트 수를 돌려줍니다. <em>buf</em> 인자는 버퍼 인터페이스를 지원하는 객체여야 합니다.</p>
<p>소켓이 <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">비 블로킹</span></a>이고 쓰기가 블록하려고 하면 <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> 나 <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a>를 발생시킵니다.</p>
<p>언제나 재협상이 가능하기 때문에, <a class="reference internal" href="#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a>를 호출해도 읽기 연산이 발생할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>소켓 시간제한은 바이트가 수신되거나 전송 될 때마다 재설정되지 않습니다. 소켓 시간제한은 이제 <em>buf</em>를 쓰는 최대 총 지속 시간입니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.6 폐지: </span><a class="reference internal" href="#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> 대신 <code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code>를 사용하십시오.</p>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">주석</p>
<p><a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> 과 <a class="reference internal" href="#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> 메서드는 암호화되지 않은 응용 프로그램 수준 데이터를 읽고 쓰고 그 것을 암호화되고 와이어수준 데이터로 복호화/암호화하는 저수준 메서드입니다. 이 메서드는 활성화된 SSL 연결, 즉, 핸드 셰이크가 완료되고, <a class="reference internal" href="#ssl.SSLSocket.unwrap" title="ssl.SSLSocket.unwrap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.unwrap()</span></code></a>가 호출되지 않은 것이 필요합니다.</p>
<p class="last">일반적으로 이러한 메서드 대신 <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a> 와 <a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>와 같은 소켓 API 메서드를 사용해야합니다.</p>
</div>
<dl class="method">
<dt id="ssl.SSLSocket.do_handshake">
<code class="descclassname">SSLSocket.</code><code class="descname">do_handshake</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.do_handshake" title="정의 주소">¶</a></dt>
<dd><p>SSL 설정 핸드 셰이크를 수행합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>핸드 셰이크 메서드는 소켓의 <a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">context</span></code></a>의 <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> 어트리뷰트가 참일 때 <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a>도 수행합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>소켓 시간제한은 바이트가 수신되거나 전송 될 때마다 재설정되지 않습니다. 소켓 시간제한은 이제 핸드 셰이크의 최대 지속 시간입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>호스트명 이나 IP 주소는 핸드 셰이크 중 OpenSSL에서 일치합니다. 함수 <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a>는 더는 사용되지 않습니다. OpenSSL이 호스트명이나 IP 주소를 거절 할 경우, 핸드 쉐이크가 일찍 중단되고 TLS 경고 메시지가 상대방에게 전송됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.getpeercert">
<code class="descclassname">SSLSocket.</code><code class="descname">getpeercert</code><span class="sig-paren">(</span><em>binary_form=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.getpeercert" title="정의 주소">¶</a></dt>
<dd><p>연결의 다른 끝의 피어에 대한 인증서가 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>를 반환합니다. SSL 핸드 셰이크가 아직 수행되지 않았으면, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">binary_form</span></code> 매개 변수가 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>이고, 피어에서 인증서를 받았으면, 이 메서드는 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 인스턴스를 반환합니다. 인증서의 유효성을 검사하지 않았으면, dict은 비어 있습니다. 인증서의 유효성을 검사했으면 <code class="docutils literal notranslate"><span class="pre">subject</span></code>(인증서가 발행된 주체)와 <code class="docutils literal notranslate"><span class="pre">issuer</span></code>(인증서를 발급한 주체)와 같은 몇 가지 키가 있는 dict를 반환합니다. 인증서가 <em>SAN(Subject Alternative Name)</em> 확장(<span class="target" id="index-48"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3280.html"><strong>RFC 3280</strong></a> 참조)의 인스턴스를 포함하면 딕셔너리에 <code class="docutils literal notranslate"><span class="pre">subjectAltName</span></code> 키도 있습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">subject</span></code> 와 <code class="docutils literal notranslate"><span class="pre">issuer</span></code> 필드는 각 필드에 대한 인증서의 데이터 구조에 제공된 RDN(relative distinguished name)의 시퀀스를 포함하는 튜플이며, 각 RDN은 이름-값 쌍의 시퀀스입니다. 실제 예를 들어 보겠습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;issuer&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;countryName&#39;</span><span class="p">,</span> <span class="s1">&#39;IL&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s1">&#39;StartCom Ltd.&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;organizationalUnitName&#39;</span><span class="p">,</span>
              <span class="s1">&#39;Secure Digital Certificate Signing&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span>
              <span class="s1">&#39;StartCom Class 2 Primary Intermediate Server CA&#39;</span><span class="p">),)),</span>
 <span class="s1">&#39;notAfter&#39;</span><span class="p">:</span> <span class="s1">&#39;Nov 22 08:15:19 2013 GMT&#39;</span><span class="p">,</span>
 <span class="s1">&#39;notBefore&#39;</span><span class="p">:</span> <span class="s1">&#39;Nov 21 03:09:52 2011 GMT&#39;</span><span class="p">,</span>
 <span class="s1">&#39;serialNumber&#39;</span><span class="p">:</span> <span class="s1">&#39;95F0&#39;</span><span class="p">,</span>
 <span class="s1">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="s1">&#39;571208-SLe257oHY9fVQ07Z&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;countryName&#39;</span><span class="p">,</span> <span class="s1">&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;stateOrProvinceName&#39;</span><span class="p">,</span> <span class="s1">&#39;California&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;localityName&#39;</span><span class="p">,</span> <span class="s1">&#39;San Francisco&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s1">&#39;Electronic Frontier Foundation, Inc.&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span> <span class="s1">&#39;*.eff.org&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;emailAddress&#39;</span><span class="p">,</span> <span class="s1">&#39;hostmaster@eff.org&#39;</span><span class="p">),)),</span>
 <span class="s1">&#39;subjectAltName&#39;</span><span class="p">:</span> <span class="p">((</span><span class="s1">&#39;DNS&#39;</span><span class="p">,</span> <span class="s1">&#39;*.eff.org&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;DNS&#39;</span><span class="p">,</span> <span class="s1">&#39;eff.org&#39;</span><span class="p">)),</span>
 <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">특정 서비스를 위해 인증서를 유효성 검사하려면, <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a> 함수를 사용할 수 있습니다.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">binary_form</span></code> 매개 변수가 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>이고, 인증서가 제공되었으면, 이 메서드는 전체 인증서의 DER-인코딩 형식을 바이트 시퀀스로 반환하고, 피어가 인증서를 제공하지 않았으면 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환합니다. 피어가 인증서를 제공하는지는 SSL 소켓의 역할에 따라 다릅니다:</p>
<ul class="simple">
<li>클라이언트 SSL 소켓의 경우, 서버는 유효성 검사가 필요한지에 관계없이 항상 인증서를 제공합니다.</li>
<li>서버 SSL 소켓의 경우, 클라이언트는 서버가 요청할 때만 인증서를 제공합니다; 따라서 <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>(<a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> 나 <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> 대신)를 사용하면 <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code></a>는 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환합니다.</li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>반환된 딕셔너리에는 <code class="docutils literal notranslate"><span class="pre">issuer</span></code> 와 <code class="docutils literal notranslate"><span class="pre">notBefore</span></code>와 같은 추가 항목이 포함됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>핸드 셰이크가 완료되지 않았으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 반환된 딕셔너리에는 <code class="docutils literal notranslate"><span class="pre">crlDistributionPoints</span></code>, <code class="docutils literal notranslate"><span class="pre">caIssuers</span></code> 및 <code class="docutils literal notranslate"><span class="pre">OCSP</span></code> URI와 같은 추가 X509v3 확장 항목이 포함됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.cipher">
<code class="descclassname">SSLSocket.</code><code class="descname">cipher</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.cipher" title="정의 주소">¶</a></dt>
<dd><p>사용되는 사이퍼의 이름, 그 것의 사용을 정의하는 SSL 프로토콜의 버전 및 사용되는 비밀 비트의 수를 포함하는 3-튜플을 반환합니다. 연결이 이루어지지 않았으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.shared_ciphers">
<code class="descclassname">SSLSocket.</code><code class="descname">shared_ciphers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.shared_ciphers" title="정의 주소">¶</a></dt>
<dd><p>핸드 쉐이크 중에 클라이언트에 의해 공유되는 사이퍼의 리스트를 돌려줍니다. 반환된 리스트의 각 항목은 사이퍼의 이름, 그 것의 사용을 정의하는 SSL 프로토콜의 버전 및 사이퍼가 사용하는 비밀 비트의 수를 포함하는 3-튜플입니다. 연결이 이루어지지 않았거나 소켓이 클라이언트 소켓이면 <a class="reference internal" href="#ssl.SSLSocket.shared_ciphers" title="ssl.SSLSocket.shared_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shared_ciphers()</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.compression">
<code class="descclassname">SSLSocket.</code><code class="descname">compression</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.compression" title="정의 주소">¶</a></dt>
<dd><p>사용되는 압축 알고리즘을 문자열로 반환하거나, 연결이 압축되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<p>상위-수준 프로토콜이 자체 압축 메커니즘을 지원하면, <a class="reference internal" href="#ssl.OP_NO_COMPRESSION" title="ssl.OP_NO_COMPRESSION"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_COMPRESSION</span></code></a>을 사용하여 SSL-수준 압축을 비활성화할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.get_channel_binding">
<code class="descclassname">SSLSocket.</code><code class="descname">get_channel_binding</code><span class="sig-paren">(</span><em>cb_type=&quot;tls-unique&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.get_channel_binding" title="정의 주소">¶</a></dt>
<dd><p>현재 연결에 대한 채널 바인딩 데이터를 바이트열 객체로 가져옵니다. 연결되어 있지 않거나 핸드 쉐이크가 완료되지 않았으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<p><em>cb_type</em> 매개 변수를 사용하여 원하는 채널 바인딩 유형을 선택할 수 있습니다. 유효한 채널 바인딩 유형은 <a class="reference internal" href="#ssl.CHANNEL_BINDING_TYPES" title="ssl.CHANNEL_BINDING_TYPES"><code class="xref py py-data docutils literal notranslate"><span class="pre">CHANNEL_BINDING_TYPES</span></code></a> 리스트에 나열됩니다. 현재는 <span class="target" id="index-49"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5929.html"><strong>RFC 5929</strong></a>가 정의한 'tls-unique' 채널 바인딩만 지원됩니다. 지원되지 않는 채널 바인딩 유형이 요청되면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.selected_alpn_protocol">
<code class="descclassname">SSLSocket.</code><code class="descname">selected_alpn_protocol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.selected_alpn_protocol" title="정의 주소">¶</a></dt>
<dd><p>TLS 핸드 셰이크 중에 선택된 프로토콜을 반환합니다. <a class="reference internal" href="#ssl.SSLContext.set_alpn_protocols" title="ssl.SSLContext.set_alpn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_alpn_protocols()</span></code></a>가 호출되지 않았거나, 상대방이 ALPN을 지원하지 않거나, 이 소켓이 클라이언트가 제안한 프로토콜중 어떤 것도 지원하지 않거나, 핸드 셰이크가 아직 발생하지 않았으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.selected_npn_protocol">
<code class="descclassname">SSLSocket.</code><code class="descname">selected_npn_protocol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.selected_npn_protocol" title="정의 주소">¶</a></dt>
<dd><p>TLS/SSL 핸드 셰이크 중에 선택된 상위-수준의 프로토콜을 반환합니다. <a class="reference internal" href="#ssl.SSLContext.set_npn_protocols" title="ssl.SSLContext.set_npn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_npn_protocols()</span></code></a>가 호출되지 않았거나, 상대방이 NPN을 지원하지 않거나, 핸드 셰이크가 아직 발생하지 않았으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.unwrap">
<code class="descclassname">SSLSocket.</code><code class="descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.unwrap" title="정의 주소">¶</a></dt>
<dd><p>SSL 종료 핸드 셰이크를 수행해서 하부 소켓에서 TLS 계층을 제거하고, 하부 소켓 객체를 반환합니다. 이 것은 연결을 통한 암호화된 연산에서 암호화되지 않은 것으로 이동하는 데 사용할 수 있습니다. 원래 소켓이 아닌 반환된 소켓을 연결의 다른 쪽과 계속 통신하기 위해 항상 사용해야합니다.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.verify_client_post_handshake">
<code class="descclassname">SSLSocket.</code><code class="descname">verify_client_post_handshake</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.verify_client_post_handshake" title="정의 주소">¶</a></dt>
<dd><p>TLS 1.3 클라이언트로부터 PHA(post-handshake authentication)를 요청합니다. PHA는 양쪽에서 PHA가 활성화 된 초기 TLS 핸드 셰이크후에 서버 측 소켓에서 TLS 1.3 연결에 대해서만 시작할 수 있습니다, <a class="reference internal" href="#ssl.SSLContext.post_handshake_auth" title="ssl.SSLContext.post_handshake_auth"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.post_handshake_auth</span></code></a>를 참조하세요.</p>
<p>이 메서드는 즉시 인증서 교환을 수행하지 않습니다. 서버 측은 다음 쓰기 이벤트 중에 CertificateRequest를 보내고 클라이언트가 다음 읽기 이벤트에서 인증서로 응답할 것으로 기대합니다.</p>
<p>사전 조건이 모두 충족되지 않으면 (예를 들어, TLS 1.3이 아니거나 PHA가 활성화되지 않았을 때), <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7.1에 추가.</span></p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">OpenSSL 1.1.1 과 TLS 1.3이 활성화된 경우에만 사용할 수 있습니다. TLS 1.3 지원이 없으면, 이 메서드는 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.version">
<code class="descclassname">SSLSocket.</code><code class="descname">version</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.version" title="정의 주소">¶</a></dt>
<dd><p>연결에 의해 협상된 실제 SSL 프로토콜 버전을 문자열로 반환하거나, 보안 연결이 이루어지지 않았으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 이 글을 쓰는 시점에서, 가능한 반환 값은 <code class="docutils literal notranslate"><span class="pre">&quot;SSLv2&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;SSLv3&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;TLSv1&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;TLSv1.1&quot;</span></code> 및 <code class="docutils literal notranslate"><span class="pre">&quot;TLSv1.2&quot;</span></code>입니다. 최근의 OpenSSL 버전은 보다 많은 반환 값을 정의 할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.pending">
<code class="descclassname">SSLSocket.</code><code class="descname">pending</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.pending" title="정의 주소">¶</a></dt>
<dd><p>접속에 계류중인, 읽기 용으로 이미 복호화된 바이트의 수를 돌려줍니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSocket.context">
<code class="descclassname">SSLSocket.</code><code class="descname">context</code><a class="headerlink" href="#ssl.SSLSocket.context" title="정의 주소">¶</a></dt>
<dd><p>이 SSL 소켓이 연결된 <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 객체. SSL 소켓이 폐지된 <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> 함수(<a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>가 아니라)를 사용하여 만들어졌으면, 이 것은 이 SSL 소켓에 대해 만든 사용자 정의 컨텍스트 객체입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSocket.server_side">
<code class="descclassname">SSLSocket.</code><code class="descname">server_side</code><a class="headerlink" href="#ssl.SSLSocket.server_side" title="정의 주소">¶</a></dt>
<dd><p>서버 측 소켓에서는 <code class="docutils literal notranslate"><span class="pre">True</span></code>이고 클라이언트 측 소켓에서는 <code class="docutils literal notranslate"><span class="pre">False</span></code> 인 논릿값.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSocket.server_hostname">
<code class="descclassname">SSLSocket.</code><code class="descname">server_hostname</code><a class="headerlink" href="#ssl.SSLSocket.server_hostname" title="정의 주소">¶</a></dt>
<dd><p>서버의 호스트명: <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 형, 또는 서버 측 소켓이거나 호스트명이 생성자에 지정되지 않았으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>어트리뷰트는 이제 항상 ASCII 텍스트입니다. <code class="docutils literal notranslate"><span class="pre">server_hostname</span></code>이 국제화 된 도메인 이름(IDN)일 때, 이 어트리뷰트는 이제 U-레이블 형식(<code class="docutils literal notranslate"><span class="pre">&quot;pythön.org&quot;</span></code>)대신 A-레이블 형식(<code class="docutils literal notranslate"><span class="pre">&quot;xn--pythn-mua.org&quot;</span></code>)을 저장합니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSocket.session">
<code class="descclassname">SSLSocket.</code><code class="descname">session</code><a class="headerlink" href="#ssl.SSLSocket.session" title="정의 주소">¶</a></dt>
<dd><p>이 SSL 연결을 위한 <a class="reference internal" href="#ssl.SSLSession" title="ssl.SSLSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSession</span></code></a>. 이 세션은 TLS 핸드 셰이크가 수행 된 후 클라이언트와 서버 측 소켓에서 사용할 수 있습니다. 클라이언트 소켓의 경우 세션을 다시 사용하기 위해 <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a>가 호출되기 전에 세션을 설정할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSocket.session_reused">
<code class="descclassname">SSLSocket.</code><code class="descname">session_reused</code><a class="headerlink" href="#ssl.SSLSocket.session_reused" title="정의 주소">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="ssl-contexts">
<h2>SSL 컨텍스트<a class="headerlink" href="#ssl-contexts" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
<p>SSL 컨텍스트는 SSL 구성 옵션, 인증서 및 개인 키와 같이 단일 SSL 연결보다 수명이 긴 다양한 데이터를 보관합니다. 또한 같은 클라이언트의 반복된 연결 속도를 높이기 위해 서버 측 소켓에 대한 SSL 세션 캐시를 관리합니다.</p>
<dl class="class">
<dt id="ssl.SSLContext">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">SSLContext</code><span class="sig-paren">(</span><em>protocol=PROTOCOL_TLS</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext" title="정의 주소">¶</a></dt>
<dd><p>새 SSL 컨텍스트를 만듭니다. <em>protocol</em>를 전달할 수 있는데, 이 모듈에 정의된 <code class="docutils literal notranslate"><span class="pre">PROTOCOL_*</span></code> 상수 중 하나 여야합니다. 매개 변수는 사용할 SSL 프로토콜의 버전을 지정합니다. 일반적으로 서버는 특정 프로토콜 버전을 선택하고, 클라이언트는 서버의 선택에 적응해야합니다. 대부분의 버전은 다른 버전과 상호 운용 할 수 없습니다. 지정하지 않으면, 기본값은 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>입니다; 다른 버전과의 호환성이 가장 뛰어납니다.</p>
<p>다음은 클라이언트의 어느 버전(행)이 서버의 어떤 버전(열)에 연결할 수 있는지 보여주는 표입니다:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="13%" />
<col width="13%" />
<col width="14%" />
<col width="10%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><em>클라이언트</em> / <strong>서버</strong></td>
<td><strong>SSLv2</strong></td>
<td><strong>SSLv3</strong></td>
<td><strong>TLS</strong> <a class="footnote-reference" href="#id9" id="id1">[3]</a></td>
<td><strong>TLSv1</strong></td>
<td><strong>TLSv1.1</strong></td>
<td><strong>TLSv1.2</strong></td>
</tr>
<tr class="row-even"><td><em>SSLv2</em></td>
<td>yes</td>
<td>no</td>
<td>no <a class="footnote-reference" href="#id7" id="id2">[1]</a></td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr class="row-odd"><td><em>SSLv3</em></td>
<td>no</td>
<td>yes</td>
<td>no <a class="footnote-reference" href="#id8" id="id3">[2]</a></td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr class="row-even"><td><em>TLS</em> (<em>SSLv23</em>) <a class="footnote-reference" href="#id9" id="id4">[3]</a></td>
<td>no <a class="footnote-reference" href="#id7" id="id5">[1]</a></td>
<td>no <a class="footnote-reference" href="#id8" id="id6">[2]</a></td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr class="row-odd"><td><em>TLSv1</em></td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr class="row-even"><td><em>TLSv1.1</em></td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr class="row-odd"><td><em>TLSv1.2</em></td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p class="rubric">각주</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>는 기본적으로 <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a>로 SSLv2를 비활성화합니다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>는 기본적으로 <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a>로 SSLv3을 비활성화합니다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> TLS 1.3 프로토콜은 OpenSSL &gt;= 1.1.1에서 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>로 사용할 수 있습니다. TLS 1.3만을 위한 전용 PROTOCOL 상수는 없습니다.</td></tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a>는 <a class="reference internal" href="#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 모듈이 주어진 목적을 위한 보안 설정을 선택할 수 있게 합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>컨텍스트는 안전한 기본값으로 생성됩니다. <a class="reference internal" href="#ssl.OP_NO_COMPRESSION" title="ssl.OP_NO_COMPRESSION"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_COMPRESSION</span></code></a>, <a class="reference internal" href="#ssl.OP_CIPHER_SERVER_PREFERENCE" title="ssl.OP_CIPHER_SERVER_PREFERENCE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_CIPHER_SERVER_PREFERENCE</span></code></a>, <a class="reference internal" href="#ssl.OP_SINGLE_DH_USE" title="ssl.OP_SINGLE_DH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_DH_USE</span></code></a>, <a class="reference internal" href="#ssl.OP_SINGLE_ECDH_USE" title="ssl.OP_SINGLE_ECDH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_ECDH_USE</span></code></a>, <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a> (<a class="reference internal" href="#ssl.PROTOCOL_SSLv2" title="ssl.PROTOCOL_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_SSLv2</span></code></a> 제외) 및 <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> (<a class="reference internal" href="#ssl.PROTOCOL_SSLv3" title="ssl.PROTOCOL_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_SSLv3</span></code></a> 제외) 옵션은 기본적으로 설정됩니다. 초기 사이퍼 스위트 리스트에는 <code class="docutils literal notranslate"><span class="pre">HIGH</span></code> 사이퍼만 포함되고 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 사이퍼나 <code class="docutils literal notranslate"><span class="pre">MD5</span></code> 사이퍼는 포함되지 않습니다 (<a class="reference internal" href="#ssl.PROTOCOL_SSLv2" title="ssl.PROTOCOL_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_SSLv2</span></code></a> 제외).</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 객체에는 다음과 같은 메서드와 어트리뷰트가 있습니다:</p>
<dl class="method">
<dt id="ssl.SSLContext.cert_store_stats">
<code class="descclassname">SSLContext.</code><code class="descname">cert_store_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.cert_store_stats" title="정의 주소">¶</a></dt>
<dd><p>로드 된 X.509 인증서 수량, CA 인증서로 표시된 X.509 인증서 및 인증서 취소 목록(CRL)의 수에 대한 통계를 딕셔너리로 가져옵니다.</p>
<p>하나의 CA 인증서와 다른 인증서 하나를 가진 컨텍스트 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">cert_store_stats</span><span class="p">()</span>
<span class="go">{&#39;crl&#39;: 0, &#39;x509_ca&#39;: 1, &#39;x509&#39;: 2}</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_cert_chain">
<code class="descclassname">SSLContext.</code><code class="descname">load_cert_chain</code><span class="sig-paren">(</span><em>certfile</em>, <em>keyfile=None</em>, <em>password=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_cert_chain" title="정의 주소">¶</a></dt>
<dd><p>개인 키와 해당 인증서를 로드합니다. <em>certfile</em> 문자열은 인증서뿐만 아니라 인증서의 신뢰성을 확보하는 데 필요한 여러 CA 인증서가 포함된 PEM 형식의 단일 파일 경로여야합니다. <em>keyfile</em> 문자열이 있으면 개인 키가 들어있는 파일을 가리켜야 합니다. 그렇지 않으면 개인키도 <em>certfile</em>에서 가져옵니다. 인증서가 <em>certfile</em>에 저장되는 방법에 대한 자세한 내용은 <a class="reference internal" href="#ssl-certificates"><span class="std std-ref">인증서</span></a>의 논의를 참조하십시오.</p>
<p><em>password</em> 인자는 개인 키의 복호화를 위한 암호를 얻기 위해 호출하는 함수가 될 수 있습니다. 개인 키가 암호화되어있고 암호가 필요한 경우에만 호출됩니다. 인자없이 호출되며, 문자열, 바이트열 또는 bytearray를 반환해야합니다. 반환 값이 문자열이면 키를 해독하기 전에 UTF-8로 인코딩됩니다. 또는 문자열, 바이트열 또는 bytearray 값을 <em>password</em> 인자로 직접 제공 할 수 있습니다. 개인 키가 암호화되지 않고 암호가 필요없으면 무시됩니다.</p>
<p><em>password</em> 인자가 지정되지 않고 암호가 필요하면, OpenSSL의 기본 암호 프롬프트 메커니즘을 사용하여 대화식으로 사용자에게 암호를 묻습니다.</p>
<p>개인 키가 인증서와 일치하지 않으면 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a>가 발생합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>새로운 선택적 인자 <em>password</em>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_default_certs">
<code class="descclassname">SSLContext.</code><code class="descname">load_default_certs</code><span class="sig-paren">(</span><em>purpose=Purpose.SERVER_AUTH</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_default_certs" title="정의 주소">¶</a></dt>
<dd><p>기본 위치에서 기본 &quot;인증 기관&quot;(CA) 인증서 집합을 로드합니다. 윈도우에서는 <code class="docutils literal notranslate"><span class="pre">CA</span></code> 와 <code class="docutils literal notranslate"><span class="pre">ROOT</span></code> 시스템 저장소에서 CA 인증서를 로드합니다. 다른 시스템에서는 <a class="reference internal" href="#ssl.SSLContext.set_default_verify_paths" title="ssl.SSLContext.set_default_verify_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_default_verify_paths()</span></code></a>를 호출합니다. 장래에 이 메서드는 다른 위치에서도 CA 인증서를 로드할 수 있습니다.</p>
<p><em>purpose</em> 플래그는 로드되는 CA 인증서의 종류를 지정합니다. 기본 설정인 <a class="reference internal" href="#ssl.Purpose.SERVER_AUTH" title="ssl.Purpose.SERVER_AUTH"><code class="xref py py-data docutils literal notranslate"><span class="pre">Purpose.SERVER_AUTH</span></code></a>는 TLS 웹 서버 인증 (클라이언트 측 소켓)용으로 표시되고 신뢰되는 인증서를 로드합니다. <a class="reference internal" href="#ssl.Purpose.CLIENT_AUTH" title="ssl.Purpose.CLIENT_AUTH"><code class="xref py py-data docutils literal notranslate"><span class="pre">Purpose.CLIENT_AUTH</span></code></a>는 서버 측에서 클라이언트 인증서 확인을 위한 CA 인증서를 로드합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_verify_locations">
<code class="descclassname">SSLContext.</code><code class="descname">load_verify_locations</code><span class="sig-paren">(</span><em>cafile=None</em>, <em>capath=None</em>, <em>cadata=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_verify_locations" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-data docutils literal notranslate"><span class="pre">verify_mode</span></code></a>가 <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>가 아닐 때, 다른 피어의 인증서를 확인하는 데 사용되는 &quot;인증 기관&quot; (CA) 인증서 집합을 로드합니다. <em>cafile</em> 나 <em>capath</em> 중 적어도 하나는 지정해야합니다.</p>
<p>이 메서드는 PEM 이나 DER 형식으로 인증서 해지 목록(CRL)을 로드할 수도 있습니다. CRL을 사용하려면 <a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a>를 올바르게 구성해야합니다.</p>
<p><em>cafile</em> 문자열이 있으면 이어붙인 PEM 형식의 CA 인증서 파일 경로입니다. 이 파일에 인증서를 정렬하는 방법에 대한 자세한 내용은 <a class="reference internal" href="#ssl-certificates"><span class="std std-ref">인증서</span></a>의 논의를 참조하십시오.</p>
<p><em>capath</em> 문자열이 있으면, <a class="reference external" href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html">OpenSSL 특정 배치</a>를 따르는 PEM 형식의 여러 CA 인증서를 포함하는 디렉터리에 대한 경로입니다.</p>
<p><em>cadata</em> 객체가 있으면, 하나 이상의 PEM-인코딩된 인증서의 ASCII 문자열이거나 DER-인코딩된 인증서의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>입니다. <em>capath</em>와 마찬가지로 PEM-인코딩된 인증서 주위의 추가 줄은 무시되지만 적어도 하나의 인증서가 있어야합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>새로운 선택적 인자 <em>cadata</em></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.get_ca_certs">
<code class="descclassname">SSLContext.</code><code class="descname">get_ca_certs</code><span class="sig-paren">(</span><em>binary_form=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.get_ca_certs" title="정의 주소">¶</a></dt>
<dd><p>로드 된 &quot;인증 기관&quot; (CA) 인증서 목록을 가져옵니다. <code class="docutils literal notranslate"><span class="pre">binary_form</span></code> 매개 변수가 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>면 각 리스트 항목은 <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a>의 출력과 같은 딕셔너리입니다. 그렇지 않으면, 이 메서드는 DER-인코딩된 인증서의 리스트를 반환합니다. 반환된 리스트에는 인증서가 SSL 연결에 의해 요청되고 로드되지 않는 한 <em>capath</em>의 인증서가 포함되어 있지 않습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">capath 디렉터리의 인증서는 적어도 한 번 이상 사용하지 않으면 로드되지 않습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.get_ciphers">
<code class="descclassname">SSLContext.</code><code class="descname">get_ciphers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.get_ciphers" title="정의 주소">¶</a></dt>
<dd><p>활성화된 사이퍼의 리스트를 가져옵니다. 리스트는 사이퍼 우선 순위 순입니다. <a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a>를 참조하십시오.</p>
<p>예제:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_SSLv23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">set_ciphers</span><span class="p">(</span><span class="s1">&#39;ECDHE+AESGCM:!ECDSA&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">get_ciphers</span><span class="p">()</span>  <span class="c1"># OpenSSL 1.0.x</span>
<span class="go">[{&#39;alg_bits&#39;: 256,</span>
<span class="go">  &#39;description&#39;: &#39;ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  &#39;</span>
<span class="go">                 &#39;Enc=AESGCM(256) Mac=AEAD&#39;,</span>
<span class="go">  &#39;id&#39;: 50380848,</span>
<span class="go">  &#39;name&#39;: &#39;ECDHE-RSA-AES256-GCM-SHA384&#39;,</span>
<span class="go">  &#39;protocol&#39;: &#39;TLSv1/SSLv3&#39;,</span>
<span class="go">  &#39;strength_bits&#39;: 256},</span>
<span class="go"> {&#39;alg_bits&#39;: 128,</span>
<span class="go">  &#39;description&#39;: &#39;ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  &#39;</span>
<span class="go">                 &#39;Enc=AESGCM(128) Mac=AEAD&#39;,</span>
<span class="go">  &#39;id&#39;: 50380847,</span>
<span class="go">  &#39;name&#39;: &#39;ECDHE-RSA-AES128-GCM-SHA256&#39;,</span>
<span class="go">  &#39;protocol&#39;: &#39;TLSv1/SSLv3&#39;,</span>
<span class="go">  &#39;strength_bits&#39;: 128}]</span>
</pre></div>
</div>
<p>OpenSSL 1.1 이상에서 사이퍼 딕셔너리에는 다음과 같은 추가 필드가 포함됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">get_ciphers</span><span class="p">()</span>  <span class="c1"># OpenSSL 1.1+</span>
<span class="go">[{&#39;aead&#39;: True,</span>
<span class="go">  &#39;alg_bits&#39;: 256,</span>
<span class="go">  &#39;auth&#39;: &#39;auth-rsa&#39;,</span>
<span class="go">  &#39;description&#39;: &#39;ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  &#39;</span>
<span class="go">                 &#39;Enc=AESGCM(256) Mac=AEAD&#39;,</span>
<span class="go">  &#39;digest&#39;: None,</span>
<span class="go">  &#39;id&#39;: 50380848,</span>
<span class="go">  &#39;kea&#39;: &#39;kx-ecdhe&#39;,</span>
<span class="go">  &#39;name&#39;: &#39;ECDHE-RSA-AES256-GCM-SHA384&#39;,</span>
<span class="go">  &#39;protocol&#39;: &#39;TLSv1.2&#39;,</span>
<span class="go">  &#39;strength_bits&#39;: 256,</span>
<span class="go">  &#39;symmetric&#39;: &#39;aes-256-gcm&#39;},</span>
<span class="go"> {&#39;aead&#39;: True,</span>
<span class="go">  &#39;alg_bits&#39;: 128,</span>
<span class="go">  &#39;auth&#39;: &#39;auth-rsa&#39;,</span>
<span class="go">  &#39;description&#39;: &#39;ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  &#39;</span>
<span class="go">                 &#39;Enc=AESGCM(128) Mac=AEAD&#39;,</span>
<span class="go">  &#39;digest&#39;: None,</span>
<span class="go">  &#39;id&#39;: 50380847,</span>
<span class="go">  &#39;kea&#39;: &#39;kx-ecdhe&#39;,</span>
<span class="go">  &#39;name&#39;: &#39;ECDHE-RSA-AES128-GCM-SHA256&#39;,</span>
<span class="go">  &#39;protocol&#39;: &#39;TLSv1.2&#39;,</span>
<span class="go">  &#39;strength_bits&#39;: 128,</span>
<span class="go">  &#39;symmetric&#39;: &#39;aes-128-gcm&#39;}]</span>
</pre></div>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: OpenSSL 1.0.2+.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_default_verify_paths">
<code class="descclassname">SSLContext.</code><code class="descname">set_default_verify_paths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_default_verify_paths" title="정의 주소">¶</a></dt>
<dd><p>OpenSSL 라이브러리를 빌드할 때 정의된 파일 시스템 경로에서 기본 &quot;인증 기관&quot; (CA) 인증서 집합을 로드합니다. 불행히도, 이 메서드가 성공하는지를 쉽게 알 수 있는 방법이 없습니다: 인증서를 찾을 수 없어도 에러가 반환되지 않습니다. 하지만 OpenSSL 라이브러리가 운영 체제의 일부로 제공되면 올바르게 구성되었을 가능성이 높습니다.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_ciphers">
<code class="descclassname">SSLContext.</code><code class="descname">set_ciphers</code><span class="sig-paren">(</span><em>ciphers</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_ciphers" title="정의 주소">¶</a></dt>
<dd><p>이 컨텍스트로 만들어진 소켓에 사용할 수 있는 사이퍼를 설정합니다. <a class="reference external" href="https://www.openssl.org/docs/manmaster/man1/ciphers.html">OpenSSL 사이퍼 리스트 형식</a>의 문자열이어야합니다. 사이퍼를 아무 것도 선택할 수 없으면 (컴파일 시간 옵션이나 다른 구성이 지정된 모든 사이퍼의 사용을 금지하기 때문에), <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a>가 발생합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p>연결될 때, SSL 소켓의 <a class="reference internal" href="#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.cipher()</span></code></a> 메서드가 현재 선택된 사이퍼를 제공합니다.</p>
<p class="last">OpenSSL 1.1.1에는 기본적으로 활성화 된 TLS 1.3 사이퍼 스위트가 있습니다. 이 스위트는 <a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_ciphers()</span></code></a>로 비활성화 할 수 없습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_alpn_protocols">
<code class="descclassname">SSLContext.</code><code class="descname">set_alpn_protocols</code><span class="sig-paren">(</span><em>protocols</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_alpn_protocols" title="정의 주소">¶</a></dt>
<dd><p>SSL/TLS 핸드 셰이크 중에 소켓이 알려야하는 프로토콜을 지정합니다. 우선 순위에 따라 정렬된 <code class="docutils literal notranslate"><span class="pre">['http/1.1',</span> <span class="pre">'spdy/2']</span></code>와 같은 ASCII 문자열 리스트여야합니다. 프로토콜 선택은 핸드 셰이크 중에 발생하며, <span class="target" id="index-50"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7301.html"><strong>RFC 7301</strong></a>에 따라 처리됩니다. 성공적인 핸드 셰이크가 끝나면, <a class="reference internal" href="#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_alpn_protocol()</span></code></a> 메서드는 합의된 프로토콜을 반환합니다.</p>
<p><a class="reference internal" href="#ssl.HAS_ALPN" title="ssl.HAS_ALPN"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_ALPN</span></code></a>이 False면, 이 메서드는 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시킵니다.</p>
<p>OpenSSL 1.1.0에서 1.1.0e는 양측이 ALPN을 지원하지만 프로토콜에 합의할 수 없으면 핸드 셰이크를 중지하고 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>를 발생시킵니다. 1.1.0f+는 1.0.2처럼 동작합니다, <a class="reference internal" href="#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_alpn_protocol()</span></code></a>는 None을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_npn_protocols">
<code class="descclassname">SSLContext.</code><code class="descname">set_npn_protocols</code><span class="sig-paren">(</span><em>protocols</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_npn_protocols" title="정의 주소">¶</a></dt>
<dd><p>SSL/TLS 핸드 셰이크 중에 소켓이 알려야하는 프로토콜을 지정합니다. 우선 순위에 따라 정렬된 <code class="docutils literal notranslate"><span class="pre">['http/1.1',</span> <span class="pre">'spdy/2']</span></code>와 같은 문자열 리스트여야합니다. 프로토콜 선택은 핸드 셰이크 중에 발생하며, <a class="reference external" href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation">Application Layer Protocol Negotiation</a>에 따라 처리됩니다. 성공적인 핸드 셰이크가 끝나면, <a class="reference internal" href="#ssl.SSLSocket.selected_npn_protocol" title="ssl.SSLSocket.selected_npn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_npn_protocol()</span></code></a> 메서드는 합의된 프로토콜을 반환합니다.</p>
<p><a class="reference internal" href="#ssl.HAS_NPN" title="ssl.HAS_NPN"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_NPN</span></code></a>이 False면, 이 메서드는 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.sni_callback">
<code class="descclassname">SSLContext.</code><code class="descname">sni_callback</code><a class="headerlink" href="#ssl.SSLContext.sni_callback" title="정의 주소">¶</a></dt>
<dd><p>TLS 클라이언트가 서버 이름 표시를 지정할 때 SSL/TLS 서버에서 TLS 클라이언트 Hello 핸드 셰이크 메시지를 받은 후 호출될 콜백 함수를 등록합니다. 서버 이름 표시 메커니즘은 <span class="target" id="index-51"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6066.html"><strong>RFC 6066</strong></a> section 3 - Server Name Indication 에서 지정됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">SSLContext</span></code> 당 하나의 콜백 만 설정할 수 있습니다. <em>sni_callback</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정되면 콜백이 비활성화됩니다. 이 함수를 호출하면 이전에 등록된 콜백이 비활성화됩니다.</p>
<p>콜백 함수는 세 개의 인자로 호출됩니다. 첫 번째는 <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a>이고, 두 번째는 클라이언트가 통신하려는 서버 이름을 나타내는 문자열(또는 TLS 클라이언트 Hello에 서버 이름이 없으면 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>)이며, 세 번째 인자는 원래 <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>입니다. 서버 이름 인자는 텍스트입니다. 국제화된 도메인 이름의 경우, 서버 이름은 IDN A-레이블(<code class="docutils literal notranslate"><span class="pre">&quot;xn--pythn-mua.org&quot;</span></code>)입니다.</p>
<p>이 콜백은 일반적으로 <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a>의 <a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLSocket.context</span></code></a> 어트리뷰트를 서버 이름과 일치하는 인증서 체인을 나타내는 <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 형의 새 객체로 변경하는 데 사용됩니다.</p>
<p>TLS 연결의 초기 협상 단계로 인해, <a class="reference internal" href="#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_alpn_protocol()</span></code></a> 과 <a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLSocket.context</span></code></a>와 같은 제한된 메서드와 어트리뷰트만 사용할 수 있습니다. <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a>, <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a>, <a class="reference internal" href="#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.cipher()</span></code></a> 및 <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.compress()</span></code> 메서드는 TLS 연결이 TLS 클라이언트 Hello 이상으로 진행되었을 것을 요구하므로, 의미있는 값을 반환하거나 안전하게 호출할 수 없습니다.</p>
<p>TLS 협상을 계속하려면 <em>sni_callback</em> 함수가 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환해야합니다. TLS 실패가 필요하면, 상수 <a class="reference internal" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_*</span></code></a>를 반환 할 수 있습니다. 다른 반환 값은 <a class="reference internal" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_INTERNAL_ERROR</span></code></a>로 TLS 치명적인 에러를 발생시킵니다.</p>
<p><em>sni_callback</em> 함수에서 예외가 발생하면, TLS 연결이 치명적인 TLS 경고 메시지 <a class="reference internal" href="#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE" title="ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_HANDSHAKE_FAILURE</span></code></a>로 종료됩니다.</p>
<p>이 메서드는 OpenSSL 라이브러리가 빌드될 때 OPENSSL_NO_TLSEXT가 정의되었으면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.set_servername_callback">
<code class="descclassname">SSLContext.</code><code class="descname">set_servername_callback</code><span class="sig-paren">(</span><em>server_name_callback</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_servername_callback" title="정의 주소">¶</a></dt>
<dd><p>이전 버전과의 호환성을 위해 유지되는 레거시 API입니다. 가능하면, 대신 <a class="reference internal" href="#ssl.SSLContext.sni_callback" title="ssl.SSLContext.sni_callback"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sni_callback</span></code></a>을 사용해야합니다. 주어진 <em>server_name_callback</em>은 <em>sni_callback</em>과 비슷하지만, 서버 호스트명이 IDN-인코딩된 국제화된 도메인 이름 일 때 <em>server_name_callback</em>는 디코딩 된 U-레이블(<code class="docutils literal notranslate"><span class="pre">&quot;pythön.org&quot;</span></code>)을 받습니다.</p>
<p>서버 이름에 디코딩 에러가 있으면, TLS 연결이 클라이언트로 <a class="reference internal" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_INTERNAL_ERROR</span></code></a> 치명적인 TLS 경고 메시지를 주면서 종료됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_dh_params">
<code class="descclassname">SSLContext.</code><code class="descname">load_dh_params</code><span class="sig-paren">(</span><em>dhfile</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_dh_params" title="정의 주소">¶</a></dt>
<dd><p>Diffie-Hellman (DH) 키 교환을 위한 키 생성 매개 변수를 로드합니다. DH 키 교환을 사용하면 계산 자원(서버 및 클라이언트 모두)을 희생하여 FH(forward secrecy)를 향상시킵니다. <em>dhfile</em> 매개 변수는 PEM 형식의 DH 매개 변수를 포함하는 파일의 경로여야 합니다.</p>
<p>이 설정은 클라이언트 소켓에는 적용되지 않습니다. <a class="reference internal" href="#ssl.OP_SINGLE_DH_USE" title="ssl.OP_SINGLE_DH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_DH_USE</span></code></a> 옵션을 사용하여 보안을 더 향상시킬 수도 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_ecdh_curve">
<code class="descclassname">SSLContext.</code><code class="descname">set_ecdh_curve</code><span class="sig-paren">(</span><em>curve_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_ecdh_curve" title="정의 주소">¶</a></dt>
<dd><p>타원 곡선(Elliptic Curve) 기반 Diffie-Hellman (ECDH) 키 교환을 위한 곡선 이름을 설정합니다. 보안성에 대한 논란의 여지는 있지만 ECDH는 일반 DH보다 상당히 빠릅니다. <em>curve_name</em> 매개 변수는 잘 알려진 타원 곡선을 설명하는 문자열이어야합니다, 예를 들어, 널리 지원되는 곡선인 <code class="docutils literal notranslate"><span class="pre">prime256v1</span></code>.</p>
<p>이 설정은 클라이언트 소켓에는 적용되지 않습니다. <a class="reference internal" href="#ssl.OP_SINGLE_ECDH_USE" title="ssl.OP_SINGLE_ECDH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_ECDH_USE</span></code></a> 옵션을 사용하여 보안을 더 향상시킬 수도 있습니다.</p>
<p><a class="reference internal" href="#ssl.HAS_ECDH" title="ssl.HAS_ECDH"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_ECDH</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>면 이 메서드를 사용할 수 없습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<dl class="last docutils">
<dt><a class="reference external" href="https://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy">SSL/TLS &amp; Perfect Forward Secrecy</a></dt>
<dd>Vincent Bernat.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.wrap_socket">
<code class="descclassname">SSLContext.</code><code class="descname">wrap_socket</code><span class="sig-paren">(</span><em>sock</em>, <em>server_side=False</em>, <em>do_handshake_on_connect=True</em>, <em>suppress_ragged_eofs=True</em>, <em>server_hostname=None</em>, <em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.wrap_socket" title="정의 주소">¶</a></dt>
<dd><p>기존 파이썬 소켓 <em>sock</em>을 감싸고 <a class="reference internal" href="#ssl.SSLContext.sslsocket_class" title="ssl.SSLContext.sslsocket_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslsocket_class</span></code></a>(기본값 <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>)의 인스턴스를 반환합니다. 반환 된 SSL 소켓은 컨텍스트, 설정 및 인증서에 연결됩니다. <em>sock</em>은 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a> 소켓이어야합니다; 다른 소켓 유형은 지원되지 않습니다.</p>
<p>매개 변수 <code class="docutils literal notranslate"><span class="pre">server_side</span></code>는 서버 측과 클라이언트 측 동작 중 어느 것이 소켓에서 필요한지를 식별하는 논릿값입니다.</p>
<p>클라이언트 측 소켓의 경우, 컨텍스트 구성이 지연됩니다; 하부 소켓이 아직 연결되어 있지 않으면, <code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code>가 소켓에서 호출 된 후 컨텍스트 생성이 수행됩니다. 서버 측 소켓의 경우, 소켓에 원격 피어가 없으면, 리스닝 소켓이라고 가정하고, 서버 측 SSL 감싸기는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code> 메서드를 통해 받아들인 클라이언트 연결에 대해 자동으로 수행됩니다. 메서드는 <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>를 발생시킬 수 있습니다.</p>
<p>클라이언트 연결에서, 선택적 매개 변수 <em>server_hostname</em>는 연결하려는 서비스의 호스트명을 지정합니다. 이를 통해 단일 서버는 HTTP 가상 호스트와 매우 흡사하게 서로 다른 인증서로 여러 SSL 기반 서비스를 호스팅 할 수 있습니다. <em>server_side</em>가 참일 때 <em>server_hostname</em>를 지정하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p>매개 변수 <code class="docutils literal notranslate"><span class="pre">do_handshake_on_connect</span></code>는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code>를 수행 한 후 SSL 핸드 셰이크를 자동으로 수행할지, 또는 응용 프로그램이 <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a> 메서드를 호출하여 명시적으로 호출할지를 지정합니다. <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a>를 명시적으로 호출하면, 핸드 셰이크에 수반되는 소켓 I/O의 블로킹 동작을 프로그램에서 제어할 수 있습니다.</p>
<p>매개 변수 <code class="docutils literal notranslate"><span class="pre">suppress_ragged_eofs</span></code>는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.recv()</span></code> 메서드가 연결의 다른 끝으로부터의 예기치 않은 EOF를 알리는 방법을 지정합니다. <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>(기본값)로 지정되면, 하부 소켓에서 발생한 예기치 않은 EOF 에러에 대한 응답으로 정상 EOF(빈 바이트열 객체)를 반환합니다. <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>면 예외를 호출자에게 다시 발생시킵니다.</p>
<p><em>session</em>, <a class="reference internal" href="#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session</span></code></a>을 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>OpenSSL에 SNI가 없더라도 항상 server_hostname을 전달할 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><em>session</em> 인자가 추가되었습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>이 메서드는 하드 코드된 <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> 대신 <a class="reference internal" href="#ssl.SSLContext.sslsocket_class" title="ssl.SSLContext.sslsocket_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslsocket_class</span></code></a> 인스턴스를 반환합니다.</p>
</div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.sslsocket_class">
<code class="descclassname">SSLContext.</code><code class="descname">sslsocket_class</code><a class="headerlink" href="#ssl.SSLContext.sslsocket_class" title="정의 주소">¶</a></dt>
<dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_sockets()</span></code>의 반환 형, 기본값은 <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>입니다. 이 어트리뷰트는 <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>의 사용자 정의 서브 클래스를 반환하기 위해 클래스의 인스턴스에서 재정의 될 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.wrap_bio">
<code class="descclassname">SSLContext.</code><code class="descname">wrap_bio</code><span class="sig-paren">(</span><em>incoming</em>, <em>outgoing</em>, <em>server_side=False</em>, <em>server_hostname=None</em>, <em>session=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.wrap_bio" title="정의 주소">¶</a></dt>
<dd><p>BIO 객체 <em>incoming</em> 과 <em>outgoing</em>을 감싸고 attr:<cite>SSLContext.sslobject_class</cite>(기본 값 <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>)의 인스턴스를 반환합니다. SSL 루틴은 incoming BIO에서 입력 데이터를 읽고 outgoing BIO에 데이터를 씁니다.</p>
<p><em>server_side</em>, <em>server_hostname</em> 및 <em>session</em> 매개 변수는 <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>에서와 같은 의미입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><em>session</em> 인자가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>이 메서드는 하드 코드된 <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> 대신 <a class="reference internal" href="#ssl.SSLContext.sslobject_class" title="ssl.SSLContext.sslobject_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslobject_class</span></code></a> 인스턴스를 반환합니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.sslobject_class">
<code class="descclassname">SSLContext.</code><code class="descname">sslobject_class</code><a class="headerlink" href="#ssl.SSLContext.sslobject_class" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.wrap_bio" title="ssl.SSLContext.wrap_bio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_bio()</span></code></a>의 반환 형, 기본값은 <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>입니다. 이 어트리뷰트는 <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>의 사용자 정의 서브 클래스를 반환하기 위해 클래스의 인스턴스에서 재정의 될 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.session_stats">
<code class="descclassname">SSLContext.</code><code class="descname">session_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.session_stats" title="정의 주소">¶</a></dt>
<dd><p>이 컨텍스트에 의해 생성되거나 관리된 SSL 세션에 대한 통계를 가져옵니다. 각 <a class="reference external" href="https://www.openssl.org/docs/man1.1.0/ssl/SSL_CTX_sess_number.html">정보 조각</a>의 이름을 숫자 값에 매핑하는 딕셔너리가 반환됩니다. 예를 들어, 다음은 컨텍스트가 생성 된 이후 세션 캐시의 총 적중 횟수 및 누락 횟수입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">session_stats</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;hits&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;misses&#39;</span><span class="p">]</span>
<span class="go">(0, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.check_hostname">
<code class="descclassname">SSLContext.</code><code class="descname">check_hostname</code><a class="headerlink" href="#ssl.SSLContext.check_hostname" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a>에서 피어 인증서의 호스트명을 <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a>로 일치 시킬지 여부. 컨텍스트의 <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a>는 <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a>나 <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>로 설정되어야하며, 호스트명을 일치 시키려면 <em>server_hostname</em>를 <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>로 전달해야합니다. 호스트명 확인을 활성화하면 <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a>가 <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>에서 <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>로 자동 설정됩니다. 호스트 이름 검사가 활성화되어 있으면 <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>로 다시 설정할 수 없습니다.</p>
<p>예제:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">()</span>
<span class="n">context</span><span class="o">.</span><span class="n">verify_mode</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span>
<span class="n">context</span><span class="o">.</span><span class="n">check_hostname</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_default_certs</span><span class="p">()</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">ssl_sock</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="s1">&#39;www.verisign.com&#39;</span><span class="p">)</span>
<span class="n">ssl_sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;www.verisign.com&#39;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>호스트명 검사가 활성화되고 <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a>가 <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>이면 이제 <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a>가 <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>로 자동 변경됩니다. 이전에는 같은 작업이 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>로 실패했을 것입니다.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 기능을 사용하려면 OpenSSL 0.9.8f 이상이 필요합니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.maximum_version">
<code class="descclassname">SSLContext.</code><code class="descname">maximum_version</code><a class="headerlink" href="#ssl.SSLContext.maximum_version" title="정의 주소">¶</a></dt>
<dd><p>지원되는 가장 높은 TLS 버전을 나타내는 <a class="reference internal" href="#ssl.TLSVersion" title="ssl.TLSVersion"><code class="xref py py-class docutils literal notranslate"><span class="pre">TLSVersion</span></code></a> 열거형 멤버. 기본값은 <a class="reference internal" href="#ssl.TLSVersion.MAXIMUM_SUPPORTED" title="ssl.TLSVersion.MAXIMUM_SUPPORTED"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.MAXIMUM_SUPPORTED</span></code></a>입니다. 어트리뷰트는 <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>, <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> 및 <a class="reference internal" href="#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a> 이외의 프로토콜에 대해 읽기 전용입니다.</p>
<p>어트리뷰트 <a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">maximum_version</span></code></a>, <a class="reference internal" href="#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">minimum_version</span></code></a> 및 <a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.options</span></code></a>는 모두 컨텍스트의 지원되는 SSL 과 TLS 버전에 영향을 줍니다. 구현은 부적합한 조합을 방지하지 못합니다. 예를 들어, <a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">options</span></code></a>에 <a class="reference internal" href="#ssl.OP_NO_TLSv1_2" title="ssl.OP_NO_TLSv1_2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">OP_NO_TLSv1_2</span></code></a>가 있고 <a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">maximum_version</span></code></a>이 <a class="reference internal" href="#ssl.TLSVersion.TLSv1_2" title="ssl.TLSVersion.TLSv1_2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.TLSv1_2</span></code></a>로 설정된 컨텍스트는 TLS 1.2 연결을 이룰 수 없습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">ssl 모듈을 OpenSSL 1.1.0g 이상으로 컴파일하지 않으면 이 어트리뷰트를 사용할 수 없습니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.minimum_version">
<code class="descclassname">SSLContext.</code><code class="descname">minimum_version</code><a class="headerlink" href="#ssl.SSLContext.minimum_version" title="정의 주소">¶</a></dt>
<dd><p>가장 낮은 지원 버전 또는 <a class="reference internal" href="#ssl.TLSVersion.MINIMUM_SUPPORTED" title="ssl.TLSVersion.MINIMUM_SUPPORTED"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.MINIMUM_SUPPORTED</span></code></a>이라는 것만 제외하면 <a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a>과 같습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">ssl 모듈을 OpenSSL 1.1.0g 이상으로 컴파일하지 않으면 이 어트리뷰트를 사용할 수 없습니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.options">
<code class="descclassname">SSLContext.</code><code class="descname">options</code><a class="headerlink" href="#ssl.SSLContext.options" title="정의 주소">¶</a></dt>
<dd><p>이 컨텍스트에서 활성화 된 SSL 옵션 집합을 나타내는 정수. 기본값은 <a class="reference internal" href="#ssl.OP_ALL" title="ssl.OP_ALL"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_ALL</span></code></a>이지만, <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a>와 같은 다른 옵션을 함께 OR로 연결하여 지정할 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">0.9.8m보다 오래된 OpenSSL 버전에서는, 옵션을 지우지는 못하고 설정만 할 수 있습니다. (해당 비트를 재설정하여) 옵션을 지우려고하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.options</span></code></a>는 <a class="reference internal" href="#ssl.Options" title="ssl.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">Options</span></code></a> 플래그를 반환합니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span><span class="o">.</span><span class="n">options</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">&lt;Options.OP_ALL|OP_NO_SSLv3|OP_NO_SSLv2|OP_NO_COMPRESSION: 2197947391&gt;</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.post_handshake_auth">
<code class="descclassname">SSLContext.</code><code class="descname">post_handshake_auth</code><a class="headerlink" href="#ssl.SSLContext.post_handshake_auth" title="정의 주소">¶</a></dt>
<dd><p>TLS 1.3 포스트 핸드 셰이크 클라이언트 인증을 사용합니다. 포스트 핸드 셰이크 인증은 기본적으로 사용되지 않으며 서버는 초기 핸드 셰이크 중에 TLS 클라이언트 인증서 만 요청할 수 있습니다. 활성화되면, 서버는 핸드 셰이크 후에 언제든지 TLS 클라이언트 인증서를 요청할 수 있습니다.</p>
<p>클라이언트 측 소켓에서 활성화될 때, 클라이언트는 포스트 핸드 셰이크 인증을 지원하는 서버에 신호를 보냅니다.</p>
<p>서버 측 소켓에서 활성화될 때, <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a>도 <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a>이나 <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>로 설정해야합니다. 실제 클라이언트 인증서 교환은 <a class="reference internal" href="#ssl.SSLSocket.verify_client_post_handshake" title="ssl.SSLSocket.verify_client_post_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.verify_client_post_handshake()</span></code></a>가 호출되고 일부 I/O가 수행 될 때까지 지연됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7.1에 추가.</span></p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">OpenSSL 1.1.1 과 TLS 1.3이 활성화될 때만 사용할 수 있습니다. TLS 1.3을 지원없이는, 프로퍼티 값이 None이며 수정할 수 없습니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.protocol">
<code class="descclassname">SSLContext.</code><code class="descname">protocol</code><a class="headerlink" href="#ssl.SSLContext.protocol" title="정의 주소">¶</a></dt>
<dd><p>컨텍스트를 구성 할 때 선택한 프로토콜 버전. 이 어트리뷰트는 읽기 전용입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.hostname_checks_common_name">
<code class="descclassname">SSLContext.</code><code class="descname">hostname_checks_common_name</code><a class="headerlink" href="#ssl.SSLContext.hostname_checks_common_name" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a>가 SAN(subject alternative name) 확장이 없을 때 인증서의 SCN(subject common name)을 유효성 검사하는 것으로 폴백할지 여부 (기본값: 참)</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">OpenSSL 1.1.0 이상에서만 쓰기 가능합니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.verify_flags">
<code class="descclassname">SSLContext.</code><code class="descname">verify_flags</code><a class="headerlink" href="#ssl.SSLContext.verify_flags" title="정의 주소">¶</a></dt>
<dd><p>인증서 유효성 검사 연산을 위한 플래그. <a class="reference internal" href="#ssl.VERIFY_CRL_CHECK_LEAF" title="ssl.VERIFY_CRL_CHECK_LEAF"><code class="xref py py-data docutils literal notranslate"><span class="pre">VERIFY_CRL_CHECK_LEAF</span></code></a>와 같은 플래그를 함께 OR로 연결하여 설정할 수 있습니다. 기본적으로 OpenSSL은 인증서 해지 목록(CRL)을 요구하지도 확인하지도 않습니다. openssl 버전 0.9.8+ 에서만 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a>는 <a class="reference internal" href="#ssl.VerifyFlags" title="ssl.VerifyFlags"><code class="xref py py-class docutils literal notranslate"><span class="pre">VerifyFlags</span></code></a> 플래그를 반환합니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span><span class="o">.</span><span class="n">verify_flags</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">&lt;VerifyFlags.VERIFY_X509_TRUSTED_FIRST: 32768&gt;</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.verify_mode">
<code class="descclassname">SSLContext.</code><code class="descname">verify_mode</code><a class="headerlink" href="#ssl.SSLContext.verify_mode" title="정의 주소">¶</a></dt>
<dd><p>다른 피어의 인증서를 확인할지 여부와 확인이 실패 할 때 어떻게해야 하는지를 나타냅니다. 이 어트리뷰트는 <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>, <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> 또는 <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> 중 하나 여야합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a>는 <a class="reference internal" href="#ssl.VerifyMode" title="ssl.VerifyMode"><code class="xref py py-class docutils literal notranslate"><span class="pre">VerifyMode</span></code></a> 열거 형을 반환합니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span><span class="o">.</span><span class="n">verify_mode</span>
<span class="go">&lt;VerifyMode.CERT_REQUIRED: 2&gt;</span>
</pre></div>
</div>
</div>
</dd></dl>

<span class="target" id="index-15"></span></div>
<div class="section" id="certificates">
<span id="ssl-certificates"></span><span id="index-16"></span><h2>인증서<a class="headerlink" href="#certificates" title="제목 주소">¶</a></h2>
<p>인증서는 일반적으로 공개 키/개인 키 시스템의 일부입니다. 이 시스템에서, 각 <em>주체(principal)</em>(시스템, 사람 또는 조직 일 수 있습니다)에게는 고유한 두 부분으로 된 암호화 키가 지정됩니다. 열쇠의 한 부분은 공개(public)며, <em>공개 키(public key)</em>라고 불립니다; 다른 부분은 비밀로 유지되며, <em>개인 키(private key)</em>라고 합니다. 두 부분은 관련이 있습니다. 두 부분 중 하나를 사용하여 메시지를 암호화하면, 다른 부분으로 해독 할 수 있고, <strong>오직</strong> 다른 부분으로 만 해독 할 수 있습니다.</p>
<p>인증서에는 두 주체에 대한 정보가 들어 있습니다. <em>주체(subject)</em>의 이름과 주체의 공개 키가 들어 있습니다. 또한 <em>발행자(issuer)</em>라는 두 번째 주체의 진술을 포함하는데, 해당 주체(subject)는 자신이 주장하는 존재며, 실제로 공개 키 또한 주체(subject)의  것이 맞다는 내용입니다. 발행자의 진술은 발행자만이 알고 있는 발행자의 개인 키로 서명됩니다. 그러나 누구든지 발행자의 공개 키를 찾고 이를 사용하여 진술을 해독하고 인증서의 다른 정보와 비교함으로써 발행자의 진술을 확인할 수 있습니다. 또한 인증서에는 유효 기간에 대한 정보가 들어 있습니다. 이것은 &quot;notBefore&quot; 와 &quot;notAfter&quot; 라고하는 두 개의 필드로 표현됩니다.</p>
<p>In the Python use of certificates, a client or server can use a certificate to
prove who they are.  The other side of a network connection can also be required
to produce a certificate, and that certificate can be validated to the
satisfaction of the client or server that requires such validation.  The
connection attempt can be set to raise an exception if the validation fails.
Validation is done automatically, by the underlying OpenSSL framework; the
application need not concern itself with its mechanics.  But the application
does usually need to provide sets of certificates to allow this process to take
place.</p>
<p>Python uses files to contain certificates.  They should be formatted as &quot;PEM&quot;
(see <span class="target" id="index-17"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1422.html"><strong>RFC 1422</strong></a>), which is a base-64 encoded form wrapped with a header line
and a footer line:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
<div class="section" id="certificate-chains">
<h3>Certificate chains<a class="headerlink" href="#certificate-chains" title="제목 주소">¶</a></h3>
<p>The Python files which contain certificates can contain a sequence of
certificates, sometimes called a <em>certificate chain</em>.  This chain should start
with the specific certificate for the principal who &quot;is&quot; the client or server,
and then the certificate for the issuer of that certificate, and then the
certificate for the issuer of <em>that</em> certificate, and so on up the chain till
you get to a certificate which is <em>self-signed</em>, that is, a certificate which
has the same subject and issuer, sometimes called a <em>root certificate</em>.  The
certificates should just be concatenated together in the certificate file.  For
example, suppose we had a three certificate chain, from our server certificate
to the certificate of the certification authority that signed our server
certificate, to the root certificate of the agency which issued the
certification authority's certificate:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="k">for</span> <span class="n">your</span> <span class="n">server</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">root</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="s1">&#39;s issuer)...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
</div>
<div class="section" id="ca-certificates">
<h3>CA certificates<a class="headerlink" href="#ca-certificates" title="제목 주소">¶</a></h3>
<p>If you are going to require validation of the other side of the connection's
certificate, you need to provide a &quot;CA certs&quot; file, filled with the certificate
chains for each issuer you are willing to trust.  Again, this file just contains
these chains concatenated together.  For validation, Python will use the first
chain it finds in the file which matches.  The platform's certificates file can
be used by calling <a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a>, this is done
automatically with <a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a>.</p>
</div>
<div class="section" id="combined-key-and-certificate">
<h3>Combined key and certificate<a class="headerlink" href="#combined-key-and-certificate" title="제목 주소">¶</a></h3>
<p>Often the private key is stored in the same file as the certificate; in this
case, only the <code class="docutils literal notranslate"><span class="pre">certfile</span></code> parameter to <a class="reference internal" href="#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_cert_chain()</span></code></a>
and <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> needs to be passed.  If the private key is stored
with the certificate, it should come before the first certificate in
the certificate chain:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">private</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
</div>
<div class="section" id="self-signed-certificates">
<h3>Self-signed certificates<a class="headerlink" href="#self-signed-certificates" title="제목 주소">¶</a></h3>
<p>If you are going to create a server that provides SSL-encrypted connection
services, you will need to acquire a certificate for that service.  There are
many ways of acquiring appropriate certificates, such as buying one from a
certification authority.  Another common practice is to generate a self-signed
certificate.  The simplest way to do this is with the OpenSSL package, using
something like the following:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">openssl</span> <span class="n">req</span> <span class="o">-</span><span class="n">new</span> <span class="o">-</span><span class="n">x509</span> <span class="o">-</span><span class="n">days</span> <span class="mi">365</span> <span class="o">-</span><span class="n">nodes</span> <span class="o">-</span><span class="n">out</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span> <span class="o">-</span><span class="n">keyout</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span>
<span class="n">Generating</span> <span class="n">a</span> <span class="mi">1024</span> <span class="n">bit</span> <span class="n">RSA</span> <span class="n">private</span> <span class="n">key</span>
<span class="o">.......++++++</span>
<span class="o">.............................++++++</span>
<span class="n">writing</span> <span class="n">new</span> <span class="n">private</span> <span class="n">key</span> <span class="n">to</span> <span class="s1">&#39;cert.pem&#39;</span>
<span class="o">-----</span>
<span class="n">You</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">be</span> <span class="n">asked</span> <span class="n">to</span> <span class="n">enter</span> <span class="n">information</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">incorporated</span>
<span class="n">into</span> <span class="n">your</span> <span class="n">certificate</span> <span class="n">request</span><span class="o">.</span>
<span class="n">What</span> <span class="n">you</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">enter</span> <span class="ow">is</span> <span class="n">what</span> <span class="ow">is</span> <span class="n">called</span> <span class="n">a</span> <span class="n">Distinguished</span> <span class="n">Name</span> <span class="ow">or</span> <span class="n">a</span> <span class="n">DN</span><span class="o">.</span>
<span class="n">There</span> <span class="n">are</span> <span class="n">quite</span> <span class="n">a</span> <span class="n">few</span> <span class="n">fields</span> <span class="n">but</span> <span class="n">you</span> <span class="n">can</span> <span class="n">leave</span> <span class="n">some</span> <span class="n">blank</span>
<span class="n">For</span> <span class="n">some</span> <span class="n">fields</span> <span class="n">there</span> <span class="n">will</span> <span class="n">be</span> <span class="n">a</span> <span class="n">default</span> <span class="n">value</span><span class="p">,</span>
<span class="n">If</span> <span class="n">you</span> <span class="n">enter</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">the</span> <span class="n">field</span> <span class="n">will</span> <span class="n">be</span> <span class="n">left</span> <span class="n">blank</span><span class="o">.</span>
<span class="o">-----</span>
<span class="n">Country</span> <span class="n">Name</span> <span class="p">(</span><span class="mi">2</span> <span class="n">letter</span> <span class="n">code</span><span class="p">)</span> <span class="p">[</span><span class="n">AU</span><span class="p">]:</span><span class="n">US</span>
<span class="n">State</span> <span class="ow">or</span> <span class="n">Province</span> <span class="n">Name</span> <span class="p">(</span><span class="n">full</span> <span class="n">name</span><span class="p">)</span> <span class="p">[</span><span class="n">Some</span><span class="o">-</span><span class="n">State</span><span class="p">]:</span><span class="n">MyState</span>
<span class="n">Locality</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">city</span><span class="p">)</span> <span class="p">[]:</span><span class="n">Some</span> <span class="n">City</span>
<span class="n">Organization</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">company</span><span class="p">)</span> <span class="p">[</span><span class="n">Internet</span> <span class="n">Widgits</span> <span class="n">Pty</span> <span class="n">Ltd</span><span class="p">]:</span><span class="n">My</span> <span class="n">Organization</span><span class="p">,</span> <span class="n">Inc</span><span class="o">.</span>
<span class="n">Organizational</span> <span class="n">Unit</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">section</span><span class="p">)</span> <span class="p">[]:</span><span class="n">My</span> <span class="n">Group</span>
<span class="n">Common</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">YOUR</span> <span class="n">name</span><span class="p">)</span> <span class="p">[]:</span><span class="n">myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="n">Email</span> <span class="n">Address</span> <span class="p">[]:</span><span class="n">ops</span><span class="nd">@myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="o">%</span>
</pre></div>
</div>
<p>The disadvantage of a self-signed certificate is that it is its own root
certificate, and no one else will have it in their cache of known (and trusted)
root certificates.</p>
</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="제목 주소">¶</a></h2>
<div class="section" id="testing-for-ssl-support">
<h3>Testing for SSL support<a class="headerlink" href="#testing-for-ssl-support" title="제목 주소">¶</a></h3>
<p>To test for the presence of SSL support in a Python installation, user code
should use the following idiom:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">ssl</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">else</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># do something that requires SSL support</span>
</pre></div>
</div>
</div>
<div class="section" id="client-side-operation">
<h3>Client-side operation<a class="headerlink" href="#client-side-operation" title="제목 주소">¶</a></h3>
<p>This example creates a SSL context with the recommended security settings
for client sockets, including automatic certificate verification:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>
</pre></div>
</div>
<p>If you prefer to tune security settings yourself, you might create
a context from scratch (but beware that you might not get the settings
right):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">verify_mode</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">check_hostname</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">load_verify_locations</span><span class="p">(</span><span class="s2">&quot;/etc/ssl/certs/ca-bundle.crt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>(this snippet assumes your operating system places a bundle of all CA
certificates in <code class="docutils literal notranslate"><span class="pre">/etc/ssl/certs/ca-bundle.crt</span></code>; if not, you'll get an
error and have to adjust the location)</p>
<p>When you use the context to connect to a server, <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>
validates the server certificate: it ensures that the server certificate
was signed with one of the CA certificates, and checks the signature for
correctness:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">),</span>
<span class="gp">... </span>                           <span class="n">server_hostname</span><span class="o">=</span><span class="s2">&quot;www.python.org&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s2">&quot;www.python.org&quot;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>
</pre></div>
</div>
<p>You may then fetch the certificate:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cert</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">getpeercert</span><span class="p">()</span>
</pre></div>
</div>
<p>Visual inspection shows that the certificate does identify the desired service
(that is, the HTTPS host <code class="docutils literal notranslate"><span class="pre">www.python.org</span></code>):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">cert</span><span class="p">)</span>
<span class="go">{&#39;OCSP&#39;: (&#39;http://ocsp.digicert.com&#39;,),</span>
<span class="go"> &#39;caIssuers&#39;: (&#39;http://cacerts.digicert.com/DigiCertSHA2ExtendedValidationServerCA.crt&#39;,),</span>
<span class="go"> &#39;crlDistributionPoints&#39;: (&#39;http://crl3.digicert.com/sha2-ev-server-g1.crl&#39;,</span>
<span class="go">                           &#39;http://crl4.digicert.com/sha2-ev-server-g1.crl&#39;),</span>
<span class="go"> &#39;issuer&#39;: (((&#39;countryName&#39;, &#39;US&#39;),),</span>
<span class="go">            ((&#39;organizationName&#39;, &#39;DigiCert Inc&#39;),),</span>
<span class="go">            ((&#39;organizationalUnitName&#39;, &#39;www.digicert.com&#39;),),</span>
<span class="go">            ((&#39;commonName&#39;, &#39;DigiCert SHA2 Extended Validation Server CA&#39;),)),</span>
<span class="go"> &#39;notAfter&#39;: &#39;Sep  9 12:00:00 2016 GMT&#39;,</span>
<span class="go"> &#39;notBefore&#39;: &#39;Sep  5 00:00:00 2014 GMT&#39;,</span>
<span class="go"> &#39;serialNumber&#39;: &#39;01BB6F00122B177F36CAB49CEA8B6B26&#39;,</span>
<span class="go"> &#39;subject&#39;: (((&#39;businessCategory&#39;, &#39;Private Organization&#39;),),</span>
<span class="go">             ((&#39;1.3.6.1.4.1.311.60.2.1.3&#39;, &#39;US&#39;),),</span>
<span class="go">             ((&#39;1.3.6.1.4.1.311.60.2.1.2&#39;, &#39;Delaware&#39;),),</span>
<span class="go">             ((&#39;serialNumber&#39;, &#39;3359300&#39;),),</span>
<span class="go">             ((&#39;streetAddress&#39;, &#39;16 Allen Rd&#39;),),</span>
<span class="go">             ((&#39;postalCode&#39;, &#39;03894-4801&#39;),),</span>
<span class="go">             ((&#39;countryName&#39;, &#39;US&#39;),),</span>
<span class="go">             ((&#39;stateOrProvinceName&#39;, &#39;NH&#39;),),</span>
<span class="go">             ((&#39;localityName&#39;, &#39;Wolfeboro,&#39;),),</span>
<span class="go">             ((&#39;organizationName&#39;, &#39;Python Software Foundation&#39;),),</span>
<span class="go">             ((&#39;commonName&#39;, &#39;www.python.org&#39;),)),</span>
<span class="go"> &#39;subjectAltName&#39;: ((&#39;DNS&#39;, &#39;www.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;pypi.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;docs.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;testpypi.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;bugs.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;wiki.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;hg.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;mail.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;packaging.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;www.pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;test.pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;us.pycon.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;id.python.org&#39;)),</span>
<span class="go"> &#39;version&#39;: 3}</span>
</pre></div>
</div>
<p>Now the SSL channel is established and the certificate verified, you can
proceed to talk with the server:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;HEAD / HTTP/1.0</span><span class="se">\r\n</span><span class="s2">Host: linuxfr.org</span><span class="se">\r\n\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">))</span>
<span class="go">[b&#39;HTTP/1.1 200 OK&#39;,</span>
<span class="go"> b&#39;Date: Sat, 18 Oct 2014 18:27:20 GMT&#39;,</span>
<span class="go"> b&#39;Server: nginx&#39;,</span>
<span class="go"> b&#39;Content-Type: text/html; charset=utf-8&#39;,</span>
<span class="go"> b&#39;X-Frame-Options: SAMEORIGIN&#39;,</span>
<span class="go"> b&#39;Content-Length: 45679&#39;,</span>
<span class="go"> b&#39;Accept-Ranges: bytes&#39;,</span>
<span class="go"> b&#39;Via: 1.1 varnish&#39;,</span>
<span class="go"> b&#39;Age: 2188&#39;,</span>
<span class="go"> b&#39;X-Served-By: cache-lcy1134-LCY&#39;,</span>
<span class="go"> b&#39;X-Cache: HIT&#39;,</span>
<span class="go"> b&#39;X-Cache-Hits: 11&#39;,</span>
<span class="go"> b&#39;Vary: Cookie&#39;,</span>
<span class="go"> b&#39;Strict-Transport-Security: max-age=63072000; includeSubDomains&#39;,</span>
<span class="go"> b&#39;Connection: close&#39;,</span>
<span class="go"> b&#39;&#39;,</span>
<span class="go"> b&#39;&#39;]</span>
</pre></div>
</div>
<p>아래의 <a class="reference internal" href="#ssl-security"><span class="std std-ref">보안 고려 사항</span></a>의 논의를 참조하십시오.</p>
</div>
<div class="section" id="server-side-operation">
<h3>Server-side operation<a class="headerlink" href="#server-side-operation" title="제목 주소">¶</a></h3>
<p>For server operation, typically you'll need to have a server certificate, and
private key, each in a file.  You'll first create a context holding the key
and the certificate, so that clients can check your authenticity.  Then
you'll open a socket, bind it to a port, call <code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code> on it, and start
waiting for clients to connect:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">Purpose</span><span class="o">.</span><span class="n">CLIENT_AUTH</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_cert_chain</span><span class="p">(</span><span class="n">certfile</span><span class="o">=</span><span class="s2">&quot;mycertfile&quot;</span><span class="p">,</span> <span class="n">keyfile</span><span class="o">=</span><span class="s2">&quot;mykeyfile&quot;</span><span class="p">)</span>

<span class="n">bindsocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;myaddr.mydomain.com&#39;</span><span class="p">,</span> <span class="mi">10023</span><span class="p">))</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>When a client connects, you'll call <code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code> on the socket to get the
new socket from the other end, and use the context's <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>
method to create a server-side SSL socket for the connection:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">newsocket</span><span class="p">,</span> <span class="n">fromaddr</span> <span class="o">=</span> <span class="n">bindsocket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="n">connstream</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">newsocket</span><span class="p">,</span> <span class="n">server_side</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SHUT_RDWR</span><span class="p">)</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Then you'll read data from the <code class="docutils literal notranslate"><span class="pre">connstream</span></code> and do something with it till you
are finished with the client (or the client is finished with you):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="c1"># empty data means the client is finished with us</span>
    <span class="k">while</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_something</span><span class="p">(</span><span class="n">connstream</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="c1"># we&#39;ll assume do_something returns False</span>
            <span class="c1"># when we&#39;re finished with client</span>
            <span class="k">break</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="c1"># finished with client</span>
</pre></div>
</div>
<p>And go back to listening for new client connections (of course, a real server
would probably handle each client connection in a separate thread, or put
the sockets in <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">non-blocking mode</span></a> and use an event loop).</p>
</div>
</div>
<div class="section" id="notes-on-non-blocking-sockets">
<span id="ssl-nonblocking"></span><h2>비 블로킹 소켓에 대한 참고 사항<a class="headerlink" href="#notes-on-non-blocking-sockets" title="제목 주소">¶</a></h2>
<p>SSL sockets behave slightly different than regular sockets in
non-blocking mode. When working with non-blocking sockets, there are
thus several things you need to be aware of:</p>
<ul>
<li><p class="first">Most <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> methods will raise either
<a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> or <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> instead of
<a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a> if an I/O operation would
block. <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> will be raised if a read operation on
the underlying socket is necessary, and <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> for
a write operation on the underlying socket. Note that attempts to
<em>write</em> to an SSL socket may require <em>reading</em> from the underlying
socket first, and attempts to <em>read</em> from the SSL socket may require
a prior <em>write</em> to the underlying socket.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>In earlier Python versions, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.send()</span></code> method
returned zero instead of raising <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> or
<a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a>.</p>
</div>
</li>
<li><p class="first">Calling <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> tells you that the OS-level socket can be
read from (or written to), but it does not imply that there is sufficient
data at the upper SSL layer.  For example, only part of an SSL frame might
have arrived.  Therefore, you must be ready to handle <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.recv()</span></code>
and <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.send()</span></code> failures, and retry after another call to
<a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>.</p>
</li>
<li><p class="first">Conversely, since the SSL layer has its own framing, a SSL socket may
still have data available for reading without <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>
being aware of it.  Therefore, you should first call
<code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.recv()</span></code> to drain any potentially available data, and then
only block on a <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> call if still necessary.</p>
<p>(of course, similar provisions apply when using other primitives such as
<a class="reference internal" href="select.html#select.poll" title="select.poll"><code class="xref py py-func docutils literal notranslate"><span class="pre">poll()</span></code></a>, or those in the <a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a> module)</p>
</li>
<li><p class="first">The SSL handshake itself will be non-blocking: the
<a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a> method has to be retried until it returns
successfully.  Here is a synopsis using <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> to wait for
the socket's readiness:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">do_handshake</span><span class="p">()</span>
        <span class="k">break</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLWantReadError</span><span class="p">:</span>
        <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">sock</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[])</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLWantWriteError</span><span class="p">:</span>
        <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([],</span> <span class="p">[</span><span class="n">sock</span><span class="p">],</span> <span class="p">[])</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last">The <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> module supports <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">non-blocking SSL sockets</span></a> and provides a
higher level API. It polls for events using the <a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a> module and
handles <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a>, <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> and
<a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a> exceptions. It runs the SSL handshake asynchronously
as well.</p>
</div>
</div>
<div class="section" id="memory-bio-support">
<h2>Memory BIO Support<a class="headerlink" href="#memory-bio-support" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
<p>Ever since the SSL module was introduced in Python 2.6, the <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>
class has provided two related but distinct areas of functionality:</p>
<ul class="simple">
<li>SSL protocol handling</li>
<li>Network IO</li>
</ul>
<p>The network IO API is identical to that provided by <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>,
from which <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> also inherits. This allows an SSL socket to be
used as a drop-in replacement for a regular socket, making it very easy to add
SSL support to an existing application.</p>
<p>Combining SSL protocol handling and network IO usually works well, but there
are some cases where it doesn't. An example is async IO frameworks that want to
use a different IO multiplexing model than the &quot;select/poll on a file
descriptor&quot; (readiness based) model that is assumed by <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>
and by the internal OpenSSL socket IO routines. This is mostly relevant for
platforms like Windows where this model is not efficient. For this purpose, a
reduced scope variant of <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> called <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> is
provided.</p>
<dl class="class">
<dt id="ssl.SSLObject">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">SSLObject</code><a class="headerlink" href="#ssl.SSLObject" title="정의 주소">¶</a></dt>
<dd><p>A reduced-scope variant of <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> representing an SSL protocol
instance that does not contain any network IO methods. This class is
typically used by framework authors that want to implement asynchronous IO
for SSL through memory buffers.</p>
<p>This class implements an interface on top of a low-level SSL object as
implemented by OpenSSL. This object captures the state of an SSL connection
but does not provide any network IO itself. IO needs to be performed through
separate &quot;BIO&quot; objects which are OpenSSL's IO abstraction layer.</p>
<p>This class has no public constructor.  An <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> instance
must be created using the <a class="reference internal" href="#ssl.SSLContext.wrap_bio" title="ssl.SSLContext.wrap_bio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_bio()</span></code></a> method. This
method will create the <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> instance and bind it to a
pair of BIOs. The <em>incoming</em> BIO is used to pass data from Python to the
SSL protocol instance, while the <em>outgoing</em> BIO is used to pass data the
other way around.</p>
<p>The following methods are available:</p>
<ul class="simple">
<li><a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">context</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.server_side" title="ssl.SSLSocket.server_side"><code class="xref py py-attr docutils literal notranslate"><span class="pre">server_side</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.server_hostname" title="ssl.SSLSocket.server_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">server_hostname</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.session_reused" title="ssl.SSLSocket.session_reused"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session_reused</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.selected_npn_protocol" title="ssl.SSLSocket.selected_npn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">selected_npn_protocol()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cipher()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.shared_ciphers" title="ssl.SSLSocket.shared_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shared_ciphers()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.compression" title="ssl.SSLSocket.compression"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compression()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.pending" title="ssl.SSLSocket.pending"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pending()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.unwrap" title="ssl.SSLSocket.unwrap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unwrap()</span></code></a></li>
<li><a class="reference internal" href="#ssl.SSLSocket.get_channel_binding" title="ssl.SSLSocket.get_channel_binding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_channel_binding()</span></code></a></li>
</ul>
<p>When compared to <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>, this object lacks the following
features:</p>
<ul class="simple">
<li>Any form of network IO; <code class="docutils literal notranslate"><span class="pre">recv()</span></code> and <code class="docutils literal notranslate"><span class="pre">send()</span></code> read and write only to
the underlying <a class="reference internal" href="#ssl.MemoryBIO" title="ssl.MemoryBIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryBIO</span></code></a> buffers.</li>
<li>There is no <em>do_handshake_on_connect</em> machinery. You must always manually
call <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a> to start the handshake.</li>
<li>There is no handling of <em>suppress_ragged_eofs</em>. All end-of-file conditions
that are in violation of the protocol are reported via the
<a class="reference internal" href="#ssl.SSLEOFError" title="ssl.SSLEOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLEOFError</span></code></a> exception.</li>
<li>The method <a class="reference internal" href="#ssl.SSLSocket.unwrap" title="ssl.SSLSocket.unwrap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unwrap()</span></code></a> call does not return anything,
unlike for an SSL socket where it returns the underlying socket.</li>
<li>The <em>server_name_callback</em> callback passed to
<a class="reference internal" href="#ssl.SSLContext.set_servername_callback" title="ssl.SSLContext.set_servername_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_servername_callback()</span></code></a> will get an <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>
instance instead of a <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> instance as its first parameter.</li>
</ul>
<p>Some notes related to the use of <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>:</p>
<ul class="simple">
<li>All IO on an <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> is <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">non-blocking</span></a>.
This means that for example <a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> will raise an
<a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> if it needs more data than the incoming BIO has
available.</li>
<li>There is no module-level <code class="docutils literal notranslate"><span class="pre">wrap_bio()</span></code> call like there is for
<a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>. An <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> is always created
via an <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>.</li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> instances must to created with
<a class="reference internal" href="#ssl.SSLContext.wrap_bio" title="ssl.SSLContext.wrap_bio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_bio()</span></code></a>. In earlier versions, it was possible to
create instances directly. This was never documented or officially
supported.</p>
</div>
</dd></dl>

<p>An SSLObject communicates with the outside world using memory buffers. The
class <a class="reference internal" href="#ssl.MemoryBIO" title="ssl.MemoryBIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryBIO</span></code></a> provides a memory buffer that can be used for this
purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:</p>
<dl class="class">
<dt id="ssl.MemoryBIO">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">MemoryBIO</code><a class="headerlink" href="#ssl.MemoryBIO" title="정의 주소">¶</a></dt>
<dd><p>A memory buffer that can be used to pass data between Python and an SSL
protocol instance.</p>
<dl class="attribute">
<dt id="ssl.MemoryBIO.pending">
<code class="descname">pending</code><a class="headerlink" href="#ssl.MemoryBIO.pending" title="정의 주소">¶</a></dt>
<dd><p>Return the number of bytes currently in the memory buffer.</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.MemoryBIO.eof">
<code class="descname">eof</code><a class="headerlink" href="#ssl.MemoryBIO.eof" title="정의 주소">¶</a></dt>
<dd><p>A boolean indicating whether the memory BIO is current at the end-of-file
position.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.MemoryBIO.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>n=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.MemoryBIO.read" title="정의 주소">¶</a></dt>
<dd><p>Read up to <em>n</em> bytes from the memory buffer. If <em>n</em> is not specified or
negative, all bytes are returned.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.MemoryBIO.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>buf</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.MemoryBIO.write" title="정의 주소">¶</a></dt>
<dd><p>Write the bytes from <em>buf</em> to the memory BIO. The <em>buf</em> argument must be an
object supporting the buffer protocol.</p>
<p>The return value is the number of bytes written, which is always equal to
the length of <em>buf</em>.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.MemoryBIO.write_eof">
<code class="descname">write_eof</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.MemoryBIO.write_eof" title="정의 주소">¶</a></dt>
<dd><p>Write an EOF marker to the memory BIO. After this method has been called, it
is illegal to call <a class="reference internal" href="#ssl.MemoryBIO.write" title="ssl.MemoryBIO.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a>. The attribute <a class="reference internal" href="#ssl.MemoryBIO.eof" title="ssl.MemoryBIO.eof"><code class="xref py py-attr docutils literal notranslate"><span class="pre">eof</span></code></a> will
become true after all data currently in the buffer has been read.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ssl-session">
<h2>SSL session<a class="headerlink" href="#ssl-session" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
<dl class="class">
<dt id="ssl.SSLSession">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">SSLSession</code><a class="headerlink" href="#ssl.SSLSession" title="정의 주소">¶</a></dt>
<dd><p>Session object used by <a class="reference internal" href="#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session</span></code></a>.</p>
<dl class="attribute">
<dt id="ssl.SSLSession.id">
<code class="descname">id</code><a class="headerlink" href="#ssl.SSLSession.id" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSession.time">
<code class="descname">time</code><a class="headerlink" href="#ssl.SSLSession.time" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSession.timeout">
<code class="descname">timeout</code><a class="headerlink" href="#ssl.SSLSession.timeout" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSession.ticket_lifetime_hint">
<code class="descname">ticket_lifetime_hint</code><a class="headerlink" href="#ssl.SSLSession.ticket_lifetime_hint" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSession.has_ticket">
<code class="descname">has_ticket</code><a class="headerlink" href="#ssl.SSLSession.has_ticket" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="security-considerations">
<span id="ssl-security"></span><h2>보안 고려 사항<a class="headerlink" href="#security-considerations" title="제목 주소">¶</a></h2>
<div class="section" id="best-defaults">
<h3>Best defaults<a class="headerlink" href="#best-defaults" title="제목 주소">¶</a></h3>
<p>For <strong>client use</strong>, if you don't have any special requirements for your
security policy, it is highly recommended that you use the
<a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> function to create your SSL context.
It will load the system's trusted CA certificates, enable certificate
validation and hostname checking, and try to choose reasonably secure
protocol and cipher settings.</p>
<p>For example, here is how you would use the <a class="reference internal" href="smtplib.html#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">smtplib.SMTP</span></code></a> class to
create a trusted, secure connection to a SMTP server:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span><span class="o">,</span> <span class="nn">smtplib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smtp</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s2">&quot;mail.python.org&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">587</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smtp</span><span class="o">.</span><span class="n">starttls</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
<span class="go">(220, b&#39;2.0.0 Ready to start TLS&#39;)</span>
</pre></div>
</div>
<p>If a client certificate is needed for the connection, it can be added with
<a class="reference internal" href="#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_cert_chain()</span></code></a>.</p>
<p>By contrast, if you create the SSL context by calling the <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>
constructor yourself, it will not have certificate validation nor hostname
checking enabled by default.  If you do so, please read the paragraphs below
to achieve a good security level.</p>
</div>
<div class="section" id="manual-settings">
<h3>Manual settings<a class="headerlink" href="#manual-settings" title="제목 주소">¶</a></h3>
<div class="section" id="verifying-certificates">
<h4>Verifying certificates<a class="headerlink" href="#verifying-certificates" title="제목 주소">¶</a></h4>
<p>When calling the <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> constructor directly,
<a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> is the default.  Since it does not authenticate the other
peer, it can be insecure, especially in client mode where most of time you
would like to ensure the authenticity of the server you're talking to.
Therefore, when in client mode, it is highly recommended to use
<a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>.  However, it is in itself not sufficient; you also
have to check that the server certificate, which can be obtained by calling
<a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a>, matches the desired service.  For many
protocols and applications, the service can be identified by the hostname;
in this case, the <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a> function can be used.  This common
check is automatically performed when <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.check_hostname</span></code></a> is
enabled.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>Hostname matchings is now performed by OpenSSL. Python no longer uses
<a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a>.</p>
</div>
<p>In server mode, if you want to authenticate your clients using the SSL layer
(rather than using a higher-level authentication mechanism), you'll also have
to specify <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> and similarly check the client certificate.</p>
</div>
<div class="section" id="protocol-versions">
<h4>Protocol versions<a class="headerlink" href="#protocol-versions" title="제목 주소">¶</a></h4>
<p>SSL versions 2 and 3 are considered insecure and are therefore dangerous to
use.  If you want maximum compatibility between clients and servers, it is
recommended to use <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> or
<a class="reference internal" href="#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a> as the protocol version. SSLv2 and SSLv3 are
disabled by default.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client_context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_CLIENT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client_context</span><span class="o">.</span><span class="n">options</span> <span class="o">|=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">OP_NO_TLSv1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client_context</span><span class="o">.</span><span class="n">options</span> <span class="o">|=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">OP_NO_TLSv1_1</span>
</pre></div>
</div>
<p>The SSL context created above will only allow TLSv1.2 and later (if
supported by your system) connections to a server. <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a>
implies certificate validation and hostname checks by default. You have to
load certificates into the context.</p>
</div>
<div class="section" id="cipher-selection">
<h4>Cipher selection<a class="headerlink" href="#cipher-selection" title="제목 주소">¶</a></h4>
<p>If you have advanced security requirements, fine-tuning of the ciphers
enabled when negotiating a SSL session is possible through the
<a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a> method.  Starting from Python 3.2.3, the
ssl module disables certain weak ciphers by default, but you may want
to further restrict the cipher choice. Be sure to read OpenSSL's documentation
about the <a class="reference external" href="https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-FORMAT">cipher list format</a>.
If you want to check which ciphers are enabled by a given cipher list, use
<a class="reference internal" href="#ssl.SSLContext.get_ciphers" title="ssl.SSLContext.get_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.get_ciphers()</span></code></a> or the <code class="docutils literal notranslate"><span class="pre">openssl</span> <span class="pre">ciphers</span></code> command on your
system.</p>
</div>
</div>
<div class="section" id="multi-processing">
<h3>Multi-processing<a class="headerlink" href="#multi-processing" title="제목 주소">¶</a></h3>
<p>If using this module as part of a multi-processed application (using,
for example the <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> or <a class="reference internal" href="concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">concurrent.futures</span></code></a> modules),
be aware that OpenSSL's internal random number generator does not properly
handle forked processes.  Applications must change the PRNG state of the
parent process if they use any SSL feature with <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a>.  Any
successful call of <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_add()</span></code></a>, <a class="reference internal" href="#ssl.RAND_bytes" title="ssl.RAND_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_bytes()</span></code></a> or
<a class="reference internal" href="#ssl.RAND_pseudo_bytes" title="ssl.RAND_pseudo_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_pseudo_bytes()</span></code></a> is sufficient.</p>
</div>
</div>
<div class="section" id="tls-1-3">
<span id="ssl-tlsv1-3"></span><h2>TLS 1.3<a class="headerlink" href="#tls-1-3" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
<p>Python has provisional and experimental support for TLS 1.3 with OpenSSL
1.1.1.  The new protocol behaves slightly differently than previous version
of TLS/SSL.  Some new TLS 1.3 features are not yet available.</p>
<ul class="simple">
<li>TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and
ChaCha20 cipher suites are enabled by default.  The method
<a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a> cannot enable or disable any TLS 1.3
ciphers yet, but <a class="reference internal" href="#ssl.SSLContext.get_ciphers" title="ssl.SSLContext.get_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.get_ciphers()</span></code></a> returns them.</li>
<li>Session tickets are no longer sent as part of the initial handshake and
are handled differently.  <a class="reference internal" href="#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLSocket.session</span></code></a> and <a class="reference internal" href="#ssl.SSLSession" title="ssl.SSLSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSession</span></code></a>
are not compatible with TLS 1.3.</li>
<li>Client-side certificates are also no longer verified during the initial
handshake.  A server can request a certificate at any time.  Clients
process certificate requests while they send or receive application data
from the server.</li>
<li>TLS 1.3 features like early data, deferred TLS client cert request,
signature algorithm configuration, and rekeying are not supported yet.</li>
</ul>
</div>
<div class="section" id="libressl-support">
<span id="ssl-libressl"></span><h2>LibreSSL support<a class="headerlink" href="#libressl-support" title="제목 주소">¶</a></h2>
<p>LibreSSL is a fork of OpenSSL 1.0.1. The ssl module has limited support for
LibreSSL. Some features are not available when the ssl module is compiled
with LibreSSL.</p>
<ul class="simple">
<li>LibreSSL &gt;= 2.6.1 no longer supports NPN. The methods
<a class="reference internal" href="#ssl.SSLContext.set_npn_protocols" title="ssl.SSLContext.set_npn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_npn_protocols()</span></code></a> and
<a class="reference internal" href="#ssl.SSLSocket.selected_npn_protocol" title="ssl.SSLSocket.selected_npn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_npn_protocol()</span></code></a> are not available.</li>
<li><a class="reference internal" href="#ssl.SSLContext.set_default_verify_paths" title="ssl.SSLContext.set_default_verify_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_default_verify_paths()</span></code></a> ignores the env vars
<span class="target" id="index-18"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">SSL_CERT_FILE</span></code> and <span class="target" id="index-19"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">SSL_CERT_PATH</span></code> although
<a class="reference internal" href="#ssl.get_default_verify_paths" title="ssl.get_default_verify_paths"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_default_verify_paths()</span></code></a> still reports them.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<dl class="last docutils">
<dt>Class <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a></dt>
<dd>Documentation of underlying <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> class</dd>
<dt><a class="reference external" href="https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html">SSL/TLS Strong Encryption: An Introduction</a></dt>
<dd>Intro from the Apache HTTP Server documentation</dd>
<dt><span class="target" id="index-20"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1422.html"><strong>RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management</strong></a></dt>
<dd>Steve Kent</dd>
<dt><span class="target" id="index-21"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4086.html"><strong>RFC 4086: Randomness Requirements for Security</strong></a></dt>
<dd>Donald E., Jeffrey I. Schiller</dd>
<dt><span class="target" id="index-22"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5280.html"><strong>RFC 5280: Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</strong></a></dt>
<dd>D. Cooper</dd>
<dt><span class="target" id="index-23"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5246.html"><strong>RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2</strong></a></dt>
<dd>T. Dierks et. al.</dd>
<dt><span class="target" id="index-24"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6066.html"><strong>RFC 6066: Transport Layer Security (TLS) Extensions</strong></a></dt>
<dd>D. Eastlake</dd>
<dt><a class="reference external" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml">IANA TLS: Transport Layer Security (TLS) Parameters</a></dt>
<dd>IANA</dd>
<dt><span class="target" id="index-25"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7525.html"><strong>RFC 7525: Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</strong></a></dt>
<dd>IETF</dd>
<dt><a class="reference external" href="https://wiki.mozilla.org/Security/Server_Side_TLS">Mozilla's Server Side TLS recommendations</a></dt>
<dd>Mozilla</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">ssl</span></code> --- 소켓 객체용 TLS/SSL 래퍼</a><ul>
<li><a class="reference internal" href="#functions-constants-and-exceptions">함수, 상수 및 예외</a><ul>
<li><a class="reference internal" href="#socket-creation">소켓 생성</a></li>
<li><a class="reference internal" href="#context-creation">컨텍스트 생성</a></li>
<li><a class="reference internal" href="#exceptions">예외</a></li>
<li><a class="reference internal" href="#random-generation">난수 생성</a></li>
<li><a class="reference internal" href="#certificate-handling">인증서 처리</a></li>
<li><a class="reference internal" href="#constants">상수</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ssl-sockets">SSL 소켓</a></li>
<li><a class="reference internal" href="#ssl-contexts">SSL 컨텍스트</a></li>
<li><a class="reference internal" href="#certificates">인증서</a><ul>
<li><a class="reference internal" href="#certificate-chains">Certificate chains</a></li>
<li><a class="reference internal" href="#ca-certificates">CA certificates</a></li>
<li><a class="reference internal" href="#combined-key-and-certificate">Combined key and certificate</a></li>
<li><a class="reference internal" href="#self-signed-certificates">Self-signed certificates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#testing-for-ssl-support">Testing for SSL support</a></li>
<li><a class="reference internal" href="#client-side-operation">Client-side operation</a></li>
<li><a class="reference internal" href="#server-side-operation">Server-side operation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#notes-on-non-blocking-sockets">비 블로킹 소켓에 대한 참고 사항</a></li>
<li><a class="reference internal" href="#memory-bio-support">Memory BIO Support</a></li>
<li><a class="reference internal" href="#ssl-session">SSL session</a></li>
<li><a class="reference internal" href="#security-considerations">보안 고려 사항</a><ul>
<li><a class="reference internal" href="#best-defaults">Best defaults</a></li>
<li><a class="reference internal" href="#manual-settings">Manual settings</a><ul>
<li><a class="reference internal" href="#verifying-certificates">Verifying certificates</a></li>
<li><a class="reference internal" href="#protocol-versions">Protocol versions</a></li>
<li><a class="reference internal" href="#cipher-selection">Cipher selection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multi-processing">Multi-processing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tls-1-3">TLS 1.3</a></li>
<li><a class="reference internal" href="#libressl-support">LibreSSL support</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="socket.html"
                        title="이전 장"><code class="docutils literal notranslate"><span class="pre">socket</span></code> --- 저수준 네트워킹 인터페이스</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="select.html"
                        title="다음 장"><code class="docutils literal notranslate"><span class="pre">select</span></code> --- Waiting for I/O completion</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="select.html" title="select --- Waiting for I/O completion"
             >다음</a> |</li>
        <li class="right" >
          <a href="socket.html" title="socket --- 저수준 네트워킹 인터페이스"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1 를 사용해서 만들었습니다.
    </div>

  </body>
</html>