
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>16.1. os --- 기타 운영 체제 인터페이스 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="16.2. io --- Core tools for working with streams" href="io.html" />
    <link rel="prev" title="16. 일반 운영 체제 서비스" href="allos.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/library/os.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="io.html" title="16.2. io --- Core tools for working with streams"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="allos.html" title="16. 일반 운영 체제 서비스"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">16. 일반 운영 체제 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-os">
<span id="os-miscellaneous-operating-system-interfaces"></span><h1>16.1. <a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> --- 기타 운영 체제 인터페이스<a class="headerlink" href="#module-os" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/os.py">Lib/os.py</a></p>
<hr class="docutils" />
<p>이 모듈은 운영 체제 종속 기능을 사용하는 이식성 있는 방법을 제공합니다. 파일을 읽거나 쓰고 싶으면 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>을 보세요, 경로를 조작하려면 <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a> 모듈을 보시고, 명령 줄에서 주어진 모든 파일의 모든 줄을 읽으려면 <a class="reference internal" href="fileinput.html#module-fileinput" title="fileinput: Loop over standard input or a list of files."><code class="xref py py-mod docutils literal"><span class="pre">fileinput</span></code></a> 모듈을 보십시오. 임시 파일과 디렉터리를 만들려면 <a class="reference internal" href="tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal"><span class="pre">tempfile</span></code></a> 모듈을 보시고, 고수준의 파일과 디렉터리 처리는 <a class="reference internal" href="shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal"><span class="pre">shutil</span></code></a> 모듈을 보십시오.</p>
<p>이러한 기능의 가용성에 대한 참고 사항:</p>
<ul class="simple">
<li>내장된 모든 운영 체제 종속적인 파이썬 모듈의 설계는, 같은 기능을 사용할 수 있는 한, 같은 인터페이스를 사용합니다; 예를 들어, 함수 <code class="docutils literal"><span class="pre">os.stat(path)</span></code>는 <em>path</em> 에 대한 stat 정보를 같은 (POSIX 인터페이스에서 기원한) 형식으로 반환합니다.</li>
<li>특정 운영 체제에 고유한 확장도 <a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> 모듈을 통해서 사용할 수 있지만, 이러한 기능을 사용하는 것은 물론 이식성에 대한 위협입니다.</li>
<li>경로 또는 파일명을 받아들이는 모든 함수는 바이트열과 문자열 객체를 모두 허용하며, 경로나 파일명이 반환되면 같은 형의 객체를 반환합니다.</li>
<li>&quot;가용성: 유닉스&quot; 참고 사항은 이 기능이 유닉스 시스템에서 일반적으로 발견된다는 것을 뜻합니다. 특정 운영 체제에 이 기능이 존재하는지에 관한 어떠한 주장도 하지 않습니다.</li>
<li>별도로 언급되지 않은 경우, &quot;가용성: 유닉스&quot;를 주장하는 모든 기능은 유닉스 코어를 기반으로 하는 맥 OS X에서 지원됩니다.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 모듈의 모든 함수는, 올바르지 않거나 액세스할 수 없는 파일명과 경로일 때, 또는 올바른 형의 인자이지만, 운영 체제에서 허용하지 않으면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
</div>
<dl class="exception">
<dt id="os.error">
<em class="property">exception </em><code class="descclassname">os.</code><code class="descname">error</code><a class="headerlink" href="#os.error" title="정의 주소">¶</a></dt>
<dd><p>내장 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> 예외의 별칭.</p>
</dd></dl>

<dl class="data">
<dt id="os.name">
<code class="descclassname">os.</code><code class="descname">name</code><a class="headerlink" href="#os.name" title="정의 주소">¶</a></dt>
<dd><p>임포트 된 운영 체제 종속 모듈의 이름. 다음과 같은 이름이 현재 등록되어있습니다: <code class="docutils literal"><span class="pre">'posix'</span></code>, <code class="docutils literal"><span class="pre">'nt'</span></code>, <code class="docutils literal"><span class="pre">'java'</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p><a class="reference internal" href="sys.html#sys.platform" title="sys.platform"><code class="xref py py-attr docutils literal"><span class="pre">sys.platform</span></code></a>는 더 세분되어 있습니다. <a class="reference internal" href="#os.uname" title="os.uname"><code class="xref py py-func docutils literal"><span class="pre">os.uname()</span></code></a>은 시스템 종속 버전 정보를 제공합니다.</p>
<p class="last"><a class="reference internal" href="platform.html#module-platform" title="platform: Retrieves as much platform identifying data as possible."><code class="xref py py-mod docutils literal"><span class="pre">platform</span></code></a> 모듈은 시스템의 아이덴티티에 대한 자세한 검사를 제공합니다.</p>
</div>
</dd></dl>

<div class="section" id="file-names-command-line-arguments-and-environment-variables">
<span id="filesystem-encoding"></span><span id="os-filenames"></span><h2>16.1.1. 파일명, 명령 줄 인자 및 환경 변수<a class="headerlink" href="#file-names-command-line-arguments-and-environment-variables" title="제목 주소">¶</a></h2>
<p>파이썬에서는, 파일명, 명령 줄 인자 및 환경 변수가 문자열형을 사용하여 표시됩니다. 일부 시스템에서는, 운영 체제에 전달하기 전에 이러한 문자열을 바이트열로 인코딩하는 것이 필요합니다. 파이썬은 파일 시스템 인코딩을 사용하여 이 변환을 수행합니다 (<a class="reference internal" href="sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal"><span class="pre">sys.getfilesystemencoding()</span></code></a>을 참조하세요).</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.1으로 변경: </span>일부 시스템에서는, 파일 시스템 인코딩을 사용한 변환이 실패할 수 있습니다. 이때, 파이썬은 <a class="reference internal" href="codecs.html#surrogateescape"><span class="std std-ref">surrogateescape 인코딩 에러 처리기</span></a>를 사용하는데, 디코딩할 때 디코딩 할 수 없는 바이트가 유니코드 문자 U+DCxx로 치환되고, 다시 인코딩할 때 원래 바이트로 변환됩니다.</p>
</div>
<p>파일 시스템 인코딩은 128보다 작은 모든 바이트를 성공적으로 디코딩함을 보장해야 합니다. 파일 시스템 인코딩이 이 보장을 제공하지 못하면, API 함수가 UnicodeError를 발생시킬 수 있습니다.</p>
</div>
<div class="section" id="process-parameters">
<span id="os-procinfo"></span><h2>16.1.2. 프로세스 매개 변수<a class="headerlink" href="#process-parameters" title="제목 주소">¶</a></h2>
<p>이 함수들과 데이터 항목은 현재 프로세스와 사용자에 관한 정보와 관련 연산을 제공합니다.</p>
<dl class="function">
<dt id="os.ctermid">
<code class="descclassname">os.</code><code class="descname">ctermid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.ctermid" title="정의 주소">¶</a></dt>
<dd><p>프로세스의 제어 터미널에 해당하는 파일명을 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.environ">
<code class="descclassname">os.</code><code class="descname">environ</code><a class="headerlink" href="#os.environ" title="정의 주소">¶</a></dt>
<dd><p>문자열 환경을 나타내는 <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">매핑</span></a> 객체입니다. 예를 들어, <code class="docutils literal"><span class="pre">environ['HOME']</span></code>은 홈 디렉터리의 경로명이며 (일부 플랫폼에서), C의 <code class="docutils literal"><span class="pre">getenv(&quot;HOME&quot;)</span></code>과 같습니다.</p>
<p>이 매핑은 <a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> 모듈을 처음으로 임포트 할 때, 일반적으로 파이썬을 시작할 때 <code class="file docutils literal"><span class="pre">site.py</span></code>를 처리하는 과정에서, 캡처됩니다. 이 시각 이후 변경된 환경은 <code class="docutils literal"><span class="pre">os.environ</span></code>을 직접 수정하여 변경한 경우를 제외하고는 <code class="docutils literal"><span class="pre">os.environ</span></code>에 반영되지 않습니다.</p>
<p>플랫폼이 <a class="reference internal" href="#os.putenv" title="os.putenv"><code class="xref py py-func docutils literal"><span class="pre">putenv()</span></code></a> 함수를 지원하면, 이 매핑은 환경을 조회하는 것뿐 아니라 환경을 수정하는 데도 사용될 수 있습니다. 매핑이 수정될 때 <a class="reference internal" href="#os.putenv" title="os.putenv"><code class="xref py py-func docutils literal"><span class="pre">putenv()</span></code></a>가 자동으로 호출됩니다.</p>
<p>유닉스에서, 키와 값은 <a class="reference internal" href="sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal"><span class="pre">sys.getfilesystemencoding()</span></code></a> 과 <code class="docutils literal"><span class="pre">'surrogateescape'</span></code> 에러 처리기를 사용합니다. 다른 인코딩을 사용하려면 <a class="reference internal" href="#os.environb" title="os.environb"><code class="xref py py-data docutils literal"><span class="pre">environb</span></code></a>를 사용하십시오.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><a class="reference internal" href="#os.putenv" title="os.putenv"><code class="xref py py-func docutils literal"><span class="pre">putenv()</span></code></a>를 직접 호출해도 <code class="docutils literal"><span class="pre">os.environ</span></code>은 변경되지 않으므로, <code class="docutils literal"><span class="pre">os.environ</span></code>을 수정하는 것이 좋습니다.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">FreeBSD 및 맥 OS X를 포함한 일부 플랫폼에서, <code class="docutils literal"><span class="pre">environ</span></code>을 설정하면 메모리 누수가 발생할 수 있습니다. <code class="xref c c-func docutils literal"><span class="pre">putenv()</span></code>에 대한 시스템 설명서를 참조하십시오.</p>
</div>
<p><a class="reference internal" href="#os.putenv" title="os.putenv"><code class="xref py py-func docutils literal"><span class="pre">putenv()</span></code></a>가 제공되지 않으면, 이 매핑의 수정된 복사본을 적절한 프로세스 생성 함수에 전달하여 자식 프로세스가 수정된 환경을 사용하게 할 수 있습니다.</p>
<p>플랫폼이 <a class="reference internal" href="#os.unsetenv" title="os.unsetenv"><code class="xref py py-func docutils literal"><span class="pre">unsetenv()</span></code></a> 기능을 지원하면, 이 매핑의 항목을 삭제하여 환경 변수를 삭제할 수 있습니다. 항목이 <code class="docutils literal"><span class="pre">os.environ</span></code>에서 삭제되거나, <code class="xref py py-meth docutils literal"><span class="pre">pop()</span></code> 또는 <code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code> 메서드 중 하나가 호출되면 <a class="reference internal" href="#os.unsetenv" title="os.unsetenv"><code class="xref py py-func docutils literal"><span class="pre">unsetenv()</span></code></a>가 자동으로 호출됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.environb">
<code class="descclassname">os.</code><code class="descname">environb</code><a class="headerlink" href="#os.environb" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.environ" title="os.environ"><code class="xref py py-data docutils literal"><span class="pre">environ</span></code></a>의 바이트열 버전: 환경을 바이트열로 나타내는 <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">매핑</span></a> 객체입니다. <a class="reference internal" href="#os.environ" title="os.environ"><code class="xref py py-data docutils literal"><span class="pre">environ</span></code></a>와 <a class="reference internal" href="#os.environb" title="os.environb"><code class="xref py py-data docutils literal"><span class="pre">environb</span></code></a>는 동기화됩니다 (<a class="reference internal" href="#os.environb" title="os.environb"><code class="xref py py-data docutils literal"><span class="pre">environb</span></code></a>를 수정하면 <a class="reference internal" href="#os.environ" title="os.environ"><code class="xref py py-data docutils literal"><span class="pre">environ</span></code></a>이 갱신되고, 그 반대도 마찬가지입니다).</p>
<p><a class="reference internal" href="#os.environb" title="os.environb"><code class="xref py py-data docutils literal"><span class="pre">environb</span></code></a>는 <a class="reference internal" href="#os.supports_bytes_environ" title="os.supports_bytes_environ"><code class="xref py py-data docutils literal"><span class="pre">supports_bytes_environ</span></code></a>이 True인 경우에만 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">os.</code><code class="descname">chdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span></dt>
<dt>
<code class="descclassname">os.</code><code class="descname">fchdir</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></dt>
<dt>
<code class="descclassname">os.</code><code class="descname">getcwd</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>이 함수는 <a class="reference internal" href="#os-file-dir"><span class="std std-ref">파일과 디렉터리</span></a>에 설명되어 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.fsencode">
<code class="descclassname">os.</code><code class="descname">fsencode</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#os.fsencode" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">'surrogateescape'</span></code> 에러 처리기를, 또는 윈도우에서는 <code class="docutils literal"><span class="pre">'strict'</span></code>를, 사용하여 파일 시스템 인코딩으로 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류</span></a> <em>filename</em> 을 인코딩합니다; <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>를 변경하지 않고 반환합니다.</p>
<p><a class="reference internal" href="#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal"><span class="pre">fsdecode()</span></code></a>는 역 함수입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal"><span class="pre">os.PathLike</span></code></a> 인터페이스를 구현하는 객체를 받아들이도록 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.fsdecode">
<code class="descclassname">os.</code><code class="descname">fsdecode</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#os.fsdecode" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">'surrogateescape'</span></code> 에러 처리기를, 또는 윈도우에서는 <code class="docutils literal"><span class="pre">'strict'</span></code>를, 사용하여 파일 시스템 인코딩으로 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류</span></a> <em>filename</em> 을 디코딩합니다; <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>을 변경하지 않고 반환합니다.</p>
<p><a class="reference internal" href="#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal"><span class="pre">fsencode()</span></code></a>는 역 함수입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal"><span class="pre">os.PathLike</span></code></a> 인터페이스를 구현하는 객체를 받아들이도록 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.fspath">
<code class="descclassname">os.</code><code class="descname">fspath</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#os.fspath" title="정의 주소">¶</a></dt>
<dd><p>경로의 파일 시스템 표현을 돌려줍니다.</p>
<p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>이나 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>가 전달되면, 변경되지 않은 상태로 반환됩니다. 그렇지 않으면 <a class="reference internal" href="#os.PathLike.__fspath__" title="os.PathLike.__fspath__"><code class="xref py py-meth docutils literal"><span class="pre">__fspath__()</span></code></a>가 호출되고, 해당 값이 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>이나 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체인 한 그 값이 반환됩니다. 다른 모든 경우에는 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="os.PathLike">
<em class="property">class </em><code class="descclassname">os.</code><code class="descname">PathLike</code><a class="headerlink" href="#os.PathLike" title="정의 주소">¶</a></dt>
<dd><p>파일 시스템 경로를 나타내는 객체(예를 들어 <a class="reference internal" href="pathlib.html#pathlib.PurePath" title="pathlib.PurePath"><code class="xref py py-class docutils literal"><span class="pre">pathlib.PurePath</span></code></a>)의 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">추상 베이스 클래스</span></a>입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
<dl class="method">
<dt id="os.PathLike.__fspath__">
<em class="property">abstractmethod </em><code class="descname">__fspath__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.PathLike.__fspath__" title="정의 주소">¶</a></dt>
<dd><p>객체의 파일 시스템 경로 표현을 돌려줍니다.</p>
<p>이 메서드는 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>이나 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체만 반환해야 하며, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>을 선호합니다.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="os.getenv">
<code class="descclassname">os.</code><code class="descname">getenv</code><span class="sig-paren">(</span><em>key</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.getenv" title="정의 주소">¶</a></dt>
<dd><p>존재하면 환경 변수 <em>key</em> 의 값을 반환하고, 그렇지 않으면 <em>default</em> 를 반환합니다. <em>key</em>, <em>default</em> 및 결과는 str입니다.</p>
<p>유닉스에서, 키와 값은 <a class="reference internal" href="sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal"><span class="pre">sys.getfilesystemencoding()</span></code></a> 과 <code class="docutils literal"><span class="pre">'surrogateescape'</span></code> 에러 처리기로 디코딩됩니다. 다른 인코딩을 사용하려면 <a class="reference internal" href="#os.getenvb" title="os.getenvb"><code class="xref py py-func docutils literal"><span class="pre">os.getenvb()</span></code></a>를 사용하십시오.</p>
<p>가용성: 대부분의 유닉스, 윈도우.</p>
</dd></dl>

<dl class="function">
<dt id="os.getenvb">
<code class="descclassname">os.</code><code class="descname">getenvb</code><span class="sig-paren">(</span><em>key</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.getenvb" title="정의 주소">¶</a></dt>
<dd><p>존재하면 환경 변수 <em>key</em> 의 값을 반환하고, 그렇지 않으면 <em>default</em> 를 반환합니다. <em>key</em>, <em>default</em> 및 결과는 bytes입니다.</p>
<p><a class="reference internal" href="#os.getenvb" title="os.getenvb"><code class="xref py py-func docutils literal"><span class="pre">getenvb()</span></code></a>는 <a class="reference internal" href="#os.supports_bytes_environ" title="os.supports_bytes_environ"><code class="xref py py-data docutils literal"><span class="pre">supports_bytes_environ</span></code></a>이 True인 경우에만 사용할 수 있습니다.</p>
<p>가용성: 대부분의 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.get_exec_path">
<code class="descclassname">os.</code><code class="descname">get_exec_path</code><span class="sig-paren">(</span><em>env=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.get_exec_path" title="정의 주소">¶</a></dt>
<dd><p>셸과 비슷하게, 프로세스를 시작할 때 지정된 이름의 실행 파일을 검색할 디렉터리 리스트를 반환합니다. (지정된다면) <em>env</em> 는 PATH를 조회할 환경 변수 딕셔너리 여야 합니다. 기본적으로, <em>env</em> 가 <code class="docutils literal"><span class="pre">None</span></code>이면, <a class="reference internal" href="#os.environ" title="os.environ"><code class="xref py py-data docutils literal"><span class="pre">environ</span></code></a>이 사용됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.getegid">
<code class="descclassname">os.</code><code class="descname">getegid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.getegid" title="정의 주소">¶</a></dt>
<dd><p>현재 프로세스의 유효(effective) 그룹 ID를 반환합니다. 이것은 현재 프로세스에서 실행 중인 파일의 &quot;set id&quot; 비트에 해당합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.geteuid">
<code class="descclassname">os.</code><code class="descname">geteuid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.geteuid" title="정의 주소">¶</a></dt>
<dd><p id="index-0">현재 프로세스의 유효(effective) 사용자 ID를 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.getgid">
<code class="descclassname">os.</code><code class="descname">getgid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.getgid" title="정의 주소">¶</a></dt>
<dd><p id="index-1">현재 프로세스의 실제(real) 그룹 ID를 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.getgrouplist">
<code class="descclassname">os.</code><code class="descname">getgrouplist</code><span class="sig-paren">(</span><em>user</em>, <em>group</em><span class="sig-paren">)</span><a class="headerlink" href="#os.getgrouplist" title="정의 주소">¶</a></dt>
<dd><p><em>user</em>가 속한 그룹 ID의 목록을 돌려줍니다. <em>group</em> 이 목록에 없으면 포함됩니다; 일반적으로 <em>group</em> 은 <em>user</em> 의 암호 레코드에서 그룹 ID 필드로 지정됩니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.getgroups">
<code class="descclassname">os.</code><code class="descname">getgroups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.getgroups" title="정의 주소">¶</a></dt>
<dd><p>현재 프로세스와 관련된 보충(supplemental) 그룹 ID 목록을 반환합니다.</p>
<p>가용성: 유닉스.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">맥 OS X에서, <a class="reference internal" href="#os.getgroups" title="os.getgroups"><code class="xref py py-func docutils literal"><span class="pre">getgroups()</span></code></a> 동작은 다른 유닉스 플랫폼과 약간 다릅니다. 파이썬 인터프리터가 <code class="xref py py-const docutils literal"><span class="pre">10.5</span></code> 또는 이전 버전의 배포 대상으로 빌드되면, <a class="reference internal" href="#os.getgroups" title="os.getgroups"><code class="xref py py-func docutils literal"><span class="pre">getgroups()</span></code></a>는 현재 사용자 프로세스와 관련된 유효 그룹 ID 목록을 반환합니다; 이 목록은 시스템 정의된 항목 수(일반적으로 16)로 제한되며, 적절하게 권한이 부여된 경우 <a class="reference internal" href="#os.setgroups" title="os.setgroups"><code class="xref py py-func docutils literal"><span class="pre">setgroups()</span></code></a>를 호출하여 수정할 수 있습니다. <code class="xref py py-const docutils literal"><span class="pre">10.5</span></code>보다 큰 배포 대상으로 빌드되면, <a class="reference internal" href="#os.getgroups" title="os.getgroups"><code class="xref py py-func docutils literal"><span class="pre">getgroups()</span></code></a>는 프로세스의 유효 사용자 ID와 연관된 사용자에 대한 현재 그룹 액세스 목록을 반환합니다; 그룹 액세스 목록은 프로세스 수명 동안 변경될 수 있으며, <a class="reference internal" href="#os.setgroups" title="os.setgroups"><code class="xref py py-func docutils literal"><span class="pre">setgroups()</span></code></a> 호출의 영향을 받지 않고, 길이도 16개로 제한되지 않습니다. 배포 대상 값(<code class="xref py py-const docutils literal"><span class="pre">MACOSX_DEPLOYMENT_TARGET</span></code>)은 <a class="reference internal" href="sysconfig.html#sysconfig.get_config_var" title="sysconfig.get_config_var"><code class="xref py py-func docutils literal"><span class="pre">sysconfig.get_config_var()</span></code></a>를 통해 얻을 수 있습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.getlogin">
<code class="descclassname">os.</code><code class="descname">getlogin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.getlogin" title="정의 주소">¶</a></dt>
<dd><p>프로세스의 제어 터미널에 로그인한 사용자의 이름을 반환합니다. 대부분 목적에서, <a class="reference internal" href="getpass.html#getpass.getuser" title="getpass.getuser"><code class="xref py py-func docutils literal"><span class="pre">getpass.getuser()</span></code></a>를 사용하는 것이 더 유용한데, 이 함수는 환경 변수 <span class="target" id="index-51"></span><code class="xref std std-envvar docutils literal"><span class="pre">LOGNAME</span></code> 이나 <span class="target" id="index-52"></span><code class="xref std std-envvar docutils literal"><span class="pre">USERNAME</span></code>을 검사하여 사용자가 누구인지 알아내고, 현재 실제 사용자 ID의 로그인 이름을 얻기 위해 <code class="docutils literal"><span class="pre">pwd.getpwuid(os.getuid())[0]</span></code>로 폴백 하기 때문입니다.</p>
<p>가용성: 유닉스, 윈도우.</p>
</dd></dl>

<dl class="function">
<dt id="os.getpgid">
<code class="descclassname">os.</code><code class="descname">getpgid</code><span class="sig-paren">(</span><em>pid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.getpgid" title="정의 주소">¶</a></dt>
<dd><p>프로세스 ID <em>pid</em> 를 갖는 프로세스의 프로세스 그룹 ID를 반환합니다. <em>pid</em> 가 0이면, 현재 프로세스의 프로세스 그룹 id가 반환됩니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.getpgrp">
<code class="descclassname">os.</code><code class="descname">getpgrp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.getpgrp" title="정의 주소">¶</a></dt>
<dd><p id="index-4">현재 프로세스 그룹의 ID를 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.getpid">
<code class="descclassname">os.</code><code class="descname">getpid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.getpid" title="정의 주소">¶</a></dt>
<dd><p id="index-5">현재의 프로세스 ID를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.getppid">
<code class="descclassname">os.</code><code class="descname">getppid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.getppid" title="정의 주소">¶</a></dt>
<dd><p id="index-6">부모의 프로세스 ID를 반환합니다. 부모 프로세스가 종료했으면, 유닉스에서 반환된 id는 init 프로세스 (1) 중 하나이며, 윈도우에서는 여전히 같은 id인데, 다른 프로세스에서 이미 재사용했을 수 있습니다.</p>
<p>가용성: 유닉스, 윈도우.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>윈도우에 대한 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.getpriority">
<code class="descclassname">os.</code><code class="descname">getpriority</code><span class="sig-paren">(</span><em>which</em>, <em>who</em><span class="sig-paren">)</span><a class="headerlink" href="#os.getpriority" title="정의 주소">¶</a></dt>
<dd><p id="index-7">프로그램 스케줄 우선순위를 얻습니다. <em>which</em> 값은 <a class="reference internal" href="#os.PRIO_PROCESS" title="os.PRIO_PROCESS"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PROCESS</span></code></a>, <a class="reference internal" href="#os.PRIO_PGRP" title="os.PRIO_PGRP"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PGRP</span></code></a> 또는 <a class="reference internal" href="#os.PRIO_USER" title="os.PRIO_USER"><code class="xref py py-const docutils literal"><span class="pre">PRIO_USER</span></code></a> 중 하나이고, <em>who</em>는 <em>which</em> 에 상대적으로 해석됩니다 (<a class="reference internal" href="#os.PRIO_PROCESS" title="os.PRIO_PROCESS"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PROCESS</span></code></a> 면 프로세스 식별자, <a class="reference internal" href="#os.PRIO_PGRP" title="os.PRIO_PGRP"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PGRP</span></code></a> 면 프로세스 그룹 식별자, <a class="reference internal" href="#os.PRIO_USER" title="os.PRIO_USER"><code class="xref py py-const docutils literal"><span class="pre">PRIO_USER</span></code></a> 면 사용자 ID). 0 값의 <em>who</em>는 (각각) 호출하는 프로세스, 호출하는 프로세스의 프로세스 그룹, 호출하는 프로세스의 실제 사용자 ID를 나타냅니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.PRIO_PROCESS">
<code class="descclassname">os.</code><code class="descname">PRIO_PROCESS</code><a class="headerlink" href="#os.PRIO_PROCESS" title="정의 주소">¶</a></dt>
<dt id="os.PRIO_PGRP">
<code class="descclassname">os.</code><code class="descname">PRIO_PGRP</code><a class="headerlink" href="#os.PRIO_PGRP" title="정의 주소">¶</a></dt>
<dt id="os.PRIO_USER">
<code class="descclassname">os.</code><code class="descname">PRIO_USER</code><a class="headerlink" href="#os.PRIO_USER" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.getpriority" title="os.getpriority"><code class="xref py py-func docutils literal"><span class="pre">getpriority()</span></code></a> 와 <a class="reference internal" href="#os.setpriority" title="os.setpriority"><code class="xref py py-func docutils literal"><span class="pre">setpriority()</span></code></a> 함수의 매개 변숫값</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.getresuid">
<code class="descclassname">os.</code><code class="descname">getresuid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.getresuid" title="정의 주소">¶</a></dt>
<dd><p>현재 프로세스의 실제(real), 유효(effective) 및 저장된(saved) 사용자 ID를 나타내는 튜플 (ruid, euid, suid)를 반환합니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.getresgid">
<code class="descclassname">os.</code><code class="descname">getresgid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.getresgid" title="정의 주소">¶</a></dt>
<dd><p>현재 프로세스의 실제(real), 유효(effective) 및 저장된(saved) 그룹 ID를 나타내는 튜플 (rgid, egid, sgid)를 반환합니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.getuid">
<code class="descclassname">os.</code><code class="descname">getuid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.getuid" title="정의 주소">¶</a></dt>
<dd><p id="index-8">현재 프로세스의 실제(real) 사용자 ID를 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.initgroups">
<code class="descclassname">os.</code><code class="descname">initgroups</code><span class="sig-paren">(</span><em>username</em>, <em>gid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.initgroups" title="정의 주소">¶</a></dt>
<dd><p>지정된 사용자 이름이 구성원인 모든 그룹과 지정된 그룹 ID로 구성된 그룹 액세스 목록을 초기화하기 위해 시스템 initgroups()를 호출합니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.putenv">
<code class="descclassname">os.</code><code class="descname">putenv</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#os.putenv" title="정의 주소">¶</a></dt>
<dd><p id="index-9"><em>key</em> 라는 환경 변수를 문자열 <em>value</em> 로 설정합니다. 이러한 환경의 변화는 <a class="reference internal" href="#os.system" title="os.system"><code class="xref py py-func docutils literal"><span class="pre">os.system()</span></code></a>, <a class="reference internal" href="#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">popen()</span></code></a> 또는 <a class="reference internal" href="#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">fork()</span></code></a> 및 <a class="reference internal" href="#os.execv" title="os.execv"><code class="xref py py-func docutils literal"><span class="pre">execv()</span></code></a>로 시작된 자식 프로세스에 영향을 줍니다.</p>
<p>가용성: 대부분의 유닉스, 윈도우.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">FreeBSD 및 맥 OS X를 포함한 일부 플랫폼에서, <code class="docutils literal"><span class="pre">environ</span></code>를 설정하면 메모리 누수가 발생할 수 있습니다. putenv에 관한 시스템 설명서를 참조하십시오.</p>
</div>
<p><a class="reference internal" href="#os.putenv" title="os.putenv"><code class="xref py py-func docutils literal"><span class="pre">putenv()</span></code></a>가 지원되면, <code class="docutils literal"><span class="pre">os.environ</span></code>의 항목에 대한 대입이 <a class="reference internal" href="#os.putenv" title="os.putenv"><code class="xref py py-func docutils literal"><span class="pre">putenv()</span></code></a>에 대한 해당 호출로 자동 변환됩니다. 그러나, <a class="reference internal" href="#os.putenv" title="os.putenv"><code class="xref py py-func docutils literal"><span class="pre">putenv()</span></code></a>에 대한 호출은 <code class="docutils literal"><span class="pre">os.environ</span></code>을 갱신하지 않으므로, 실제로는 <code class="docutils literal"><span class="pre">os.environ</span></code> 항목에 대입하는 것이 좋습니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.setegid">
<code class="descclassname">os.</code><code class="descname">setegid</code><span class="sig-paren">(</span><em>egid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.setegid" title="정의 주소">¶</a></dt>
<dd><p>현재 프로세스의 유효 그룹 ID를 설정합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.seteuid">
<code class="descclassname">os.</code><code class="descname">seteuid</code><span class="sig-paren">(</span><em>euid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.seteuid" title="정의 주소">¶</a></dt>
<dd><p>현재 프로세스의 유효 사용자 ID를 설정합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.setgid">
<code class="descclassname">os.</code><code class="descname">setgid</code><span class="sig-paren">(</span><em>gid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.setgid" title="정의 주소">¶</a></dt>
<dd><p>현재 프로세스의 그룹 ID를 설정합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.setgroups">
<code class="descclassname">os.</code><code class="descname">setgroups</code><span class="sig-paren">(</span><em>groups</em><span class="sig-paren">)</span><a class="headerlink" href="#os.setgroups" title="정의 주소">¶</a></dt>
<dd><p>현재 프로세스와 연관된 보충(supplemental) 그룹 ID의 목록을 <em>groups</em>로 설정합니다. <em>groups</em> 는 시퀀스 여야 하며, 각 요소는 그룹을 식별하는 정수여야 합니다. 이 연산은 대개 슈퍼 유저만 사용할 수 있습니다.</p>
<p>가용성: 유닉스.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">맥 OS X에서 <em>groups</em> 의 길이는 시스템이 정의한 최대 유효 그룹 ID 수(일반적으로 16)를 초과할 수 없습니다. setgroups()를 호출해서 설정한 것과 같은 그룹 목록을 반환하지 않을 때에 관해서는 <a class="reference internal" href="#os.getgroups" title="os.getgroups"><code class="xref py py-func docutils literal"><span class="pre">getgroups()</span></code></a> 설명서를 참조하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.setpgrp">
<code class="descclassname">os.</code><code class="descname">setpgrp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.setpgrp" title="정의 주소">¶</a></dt>
<dd><p>구현된 (있기는 하다면) 버전에 따라 시스템 호출 <code class="xref c c-func docutils literal"><span class="pre">setpgrp()</span></code> 나 <code class="docutils literal"><span class="pre">setpgrp(0,</span> <span class="pre">0)</span></code>을 호출합니다. 의미에 대해서는 유닉스 매뉴얼을 참조하십시오.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.setpgid">
<code class="descclassname">os.</code><code class="descname">setpgid</code><span class="sig-paren">(</span><em>pid</em>, <em>pgrp</em><span class="sig-paren">)</span><a class="headerlink" href="#os.setpgid" title="정의 주소">¶</a></dt>
<dd><p>프로세스 ID가 <em>pid</em> 인 프로세스의 프로세스 그룹 ID를 <em>pgrp</em> 로 설정하기 위해 시스템 호출 <code class="xref c c-func docutils literal"><span class="pre">setpgid()</span></code>를 호출합니다. 의미에 대해서는 유닉스 매뉴얼을 참조하십시오.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.setpriority">
<code class="descclassname">os.</code><code class="descname">setpriority</code><span class="sig-paren">(</span><em>which</em>, <em>who</em>, <em>priority</em><span class="sig-paren">)</span><a class="headerlink" href="#os.setpriority" title="정의 주소">¶</a></dt>
<dd><p id="index-10">프로그램 스케줄 우선순위를 설정합니다. <em>which</em> 값은 <a class="reference internal" href="#os.PRIO_PROCESS" title="os.PRIO_PROCESS"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PROCESS</span></code></a>, <a class="reference internal" href="#os.PRIO_PGRP" title="os.PRIO_PGRP"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PGRP</span></code></a> 또는 <a class="reference internal" href="#os.PRIO_USER" title="os.PRIO_USER"><code class="xref py py-const docutils literal"><span class="pre">PRIO_USER</span></code></a> 중 하나이고, <em>who</em>는 <em>which</em> 에 상대적으로 해석됩니다 (<a class="reference internal" href="#os.PRIO_PROCESS" title="os.PRIO_PROCESS"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PROCESS</span></code></a> 면 프로세스 식별자, <a class="reference internal" href="#os.PRIO_PGRP" title="os.PRIO_PGRP"><code class="xref py py-const docutils literal"><span class="pre">PRIO_PGRP</span></code></a> 면 프로세스 그룹 식별자, <a class="reference internal" href="#os.PRIO_USER" title="os.PRIO_USER"><code class="xref py py-const docutils literal"><span class="pre">PRIO_USER</span></code></a> 면 사용자 ID). 0 값의 <em>who</em>는 (각각) 호출하는 프로세스, 호출하는 프로세스의 프로세스 그룹, 호출하는 프로세스의 실제 사용자 ID를 나타냅니다. <em>priority</em> 는 -20에서 19 사이의 값입니다. 기본 우선순위는 0입니다; 우선순위가 낮으면 더 유리하게 스케줄 됩니다.</p>
<p>가용성: 유닉스</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.setregid">
<code class="descclassname">os.</code><code class="descname">setregid</code><span class="sig-paren">(</span><em>rgid</em>, <em>egid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.setregid" title="정의 주소">¶</a></dt>
<dd><p>현재 프로세스의 실제(real) 및 유효한(effective) 그룹 ID를 설정합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.setresgid">
<code class="descclassname">os.</code><code class="descname">setresgid</code><span class="sig-paren">(</span><em>rgid</em>, <em>egid</em>, <em>sgid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.setresgid" title="정의 주소">¶</a></dt>
<dd><p>현재 프로세스의 실제(real), 유효(effective) 및 저장된(saved) 그룹 ID를 설정합니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.setresuid">
<code class="descclassname">os.</code><code class="descname">setresuid</code><span class="sig-paren">(</span><em>ruid</em>, <em>euid</em>, <em>suid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.setresuid" title="정의 주소">¶</a></dt>
<dd><p>현재 프로세스의 실제(real), 유효(effective) 및 저장된(saved) 사용자 ID를 설정합니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.setreuid">
<code class="descclassname">os.</code><code class="descname">setreuid</code><span class="sig-paren">(</span><em>ruid</em>, <em>euid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.setreuid" title="정의 주소">¶</a></dt>
<dd><p>현재 프로세스의 실제(real) 및 유효(effective) 사용자 ID를 설정합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.getsid">
<code class="descclassname">os.</code><code class="descname">getsid</code><span class="sig-paren">(</span><em>pid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.getsid" title="정의 주소">¶</a></dt>
<dd><p>시스템 호출 <code class="xref c c-func docutils literal"><span class="pre">getsid()</span></code>를 호출합니다. 의미에 대해서는 유닉스 매뉴얼을 참조하십시오.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.setsid">
<code class="descclassname">os.</code><code class="descname">setsid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.setsid" title="정의 주소">¶</a></dt>
<dd><p>시스템 호출 <code class="xref c c-func docutils literal"><span class="pre">setsid()</span></code>를 호출합니다. 의미에 대해서는 유닉스 매뉴얼을 참조하십시오.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.setuid">
<code class="descclassname">os.</code><code class="descname">setuid</code><span class="sig-paren">(</span><em>uid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.setuid" title="정의 주소">¶</a></dt>
<dd><p id="index-11">현재 프로세스의 사용자 ID를 설정합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.strerror">
<code class="descclassname">os.</code><code class="descname">strerror</code><span class="sig-paren">(</span><em>code</em><span class="sig-paren">)</span><a class="headerlink" href="#os.strerror" title="정의 주소">¶</a></dt>
<dd><p>에러 코드 <em>code</em>에 해당하는 에러 메시지를 반환합니다. 알 수 없는 에러 코드가 주어질 때 <code class="xref c c-func docutils literal"><span class="pre">strerror()</span></code>가 <code class="docutils literal"><span class="pre">NULL</span></code>을 반환하는 플랫폼에서, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.supports_bytes_environ">
<code class="descclassname">os.</code><code class="descname">supports_bytes_environ</code><a class="headerlink" href="#os.supports_bytes_environ" title="정의 주소">¶</a></dt>
<dd><p>환경의 원시 OS 형이 바이트열이면 <code class="docutils literal"><span class="pre">True</span></code> (예를 들어, 윈도우에서는 <code class="docutils literal"><span class="pre">False</span></code>).</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.umask">
<code class="descclassname">os.</code><code class="descname">umask</code><span class="sig-paren">(</span><em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#os.umask" title="정의 주소">¶</a></dt>
<dd><p>현재 숫자 umask를 설정하고 이전 umask를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.uname">
<code class="descclassname">os.</code><code class="descname">uname</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.uname" title="정의 주소">¶</a></dt>
<dd><p id="index-12">현재 운영 체제를 식별하는 정보를 반환합니다. 반환 값은 5가지 어트리뷰트를 가진 객체입니다:</p>
<ul class="simple">
<li><code class="xref py py-attr docutils literal"><span class="pre">sysname</span></code> - 운영 체제 이름</li>
<li><code class="xref py py-attr docutils literal"><span class="pre">nodename</span></code> - 네트워크상의 기계 이름 (구현이 정의)</li>
<li><code class="xref py py-attr docutils literal"><span class="pre">release</span></code> - 운영 체제 릴리스</li>
<li><code class="xref py py-attr docutils literal"><span class="pre">version</span></code> - 운영 체제 버전</li>
<li><code class="xref py py-attr docutils literal"><span class="pre">machine</span></code> - 하드웨어 식별자</li>
</ul>
<p>하위 호환성을 위해, 이 객체는 이터러블이기도 해서, <code class="xref py py-attr docutils literal"><span class="pre">sysname</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">nodename</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">release</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">version</span></code> 및 <code class="xref py py-attr docutils literal"><span class="pre">machine</span></code>이 이 순서로 포함된 5-튜플처럼 작동합니다.</p>
<p>일부 시스템에서는 <code class="xref py py-attr docutils literal"><span class="pre">nodename</span></code>을 8자나 선행 구성 요소로 자릅니다; 호스트 이름을 얻는 더 좋은 방법은 <a class="reference internal" href="socket.html#socket.gethostname" title="socket.gethostname"><code class="xref py py-func docutils literal"><span class="pre">socket.gethostname()</span></code></a> 또는 더 나아가 <code class="docutils literal"><span class="pre">socket.gethostbyaddr(socket.gethostname())</span></code>입니다.</p>
<p>가용성: 최근 유닉스.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>반환형이 튜플에서 이름이 지정된 어트리뷰트를 가진 튜플류 객체로 변경되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.unsetenv">
<code class="descclassname">os.</code><code class="descname">unsetenv</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#os.unsetenv" title="정의 주소">¶</a></dt>
<dd><p id="index-13"><em>key</em> 라는 이름의 환경 변수를 삭제합니다. 이러한 환경 변화는 <a class="reference internal" href="#os.system" title="os.system"><code class="xref py py-func docutils literal"><span class="pre">os.system()</span></code></a>, <a class="reference internal" href="#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">popen()</span></code></a> 또는 <a class="reference internal" href="#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">fork()</span></code></a> 및 <a class="reference internal" href="#os.execv" title="os.execv"><code class="xref py py-func docutils literal"><span class="pre">execv()</span></code></a>로 시작된 자식 프로세스에 영향을 줍니다.</p>
<p><a class="reference internal" href="#os.unsetenv" title="os.unsetenv"><code class="xref py py-func docutils literal"><span class="pre">unsetenv()</span></code></a>가 지원되면, <code class="docutils literal"><span class="pre">os.environ</span></code>의 항목 삭제가 자동으로 <a class="reference internal" href="#os.unsetenv" title="os.unsetenv"><code class="xref py py-func docutils literal"><span class="pre">unsetenv()</span></code></a>에 대한 해당 호출로 변환됩니다. 그러나 <a class="reference internal" href="#os.unsetenv" title="os.unsetenv"><code class="xref py py-func docutils literal"><span class="pre">unsetenv()</span></code></a>에 대한 호출은 <code class="docutils literal"><span class="pre">os.environ</span></code>을 갱신하지 않으므로, 실제로는 <code class="docutils literal"><span class="pre">os.environ</span></code> 항목을 삭제하는 것이 좋습니다.</p>
<p>가용성: 대부분의 유닉스, 윈도우.</p>
</dd></dl>

</div>
<div class="section" id="file-object-creation">
<span id="os-newstreams"></span><h2>16.1.3. 파일 객체 생성<a class="headerlink" href="#file-object-creation" title="제목 주소">¶</a></h2>
<p>이 함수는 새로운 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a>를 만듭니다. (파일 기술자를 여는 것에 관해서는 <a class="reference internal" href="#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>를 참조하십시오.)</p>
<dl class="function">
<dt id="os.fdopen">
<code class="descclassname">os.</code><code class="descname">fdopen</code><span class="sig-paren">(</span><em>fd</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#os.fdopen" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd에</em> 연결된 열린 파일 객체를 반환합니다. 이것은 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> 내장 함수의 별칭이며 같은 인자를 받아들입니다. 유일한 차이점은 <a class="reference internal" href="#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">fdopen()</span></code></a>의 첫 번째 인자는 항상 정수 여야 한다는 것입니다.</p>
</dd></dl>

</div>
<div class="section" id="file-descriptor-operations">
<span id="os-fd-ops"></span><h2>16.1.4. 파일 기술자 연산<a class="headerlink" href="#file-descriptor-operations" title="제목 주소">¶</a></h2>
<p>이 함수들은 파일 기술자를 사용하여 참조된 I/O 스트림에 작용합니다.</p>
<p>파일 기술자는 현재 프로세스에 의해 열린 파일에 대응하는 작은 정수입니다. 예를 들어, 표준 입력은 보통 파일 기술자 0이고, 표준 출력은 1이며, 표준 에러는 2입니다. 프로세스에 의해 열린 추가 파일은 3, 4, 5 등으로 지정됩니다. &quot;파일 기술자&quot;라는 이름은 약간 기만적입니다; 유닉스 플랫폼에서, 소켓과 파이프도 파일 기술자에 의해 참조됩니다.</p>
<p><a class="reference internal" href="io.html#io.IOBase.fileno" title="io.IOBase.fileno"><code class="xref py py-meth docutils literal"><span class="pre">fileno()</span></code></a> 메서드는 필요할 때 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a>와 연관된 파일 기술자를 얻는 데 사용될 수 있습니다. 파일 기술자를 직접 사용하면 파일 객체 메서드를 거치지 않아서, 데이터의 내부 버퍼링과 같은 측면을 무시하게 되는 것에 유의하십시오.</p>
<dl class="function">
<dt id="os.close">
<code class="descclassname">os.</code><code class="descname">close</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#os.close" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em>를 닫습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 함수는 저수준 I/O를 위한 것이며, <a class="reference internal" href="#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a> 또는 <a class="reference internal" href="#os.pipe" title="os.pipe"><code class="xref py py-func docutils literal"><span class="pre">pipe()</span></code></a>에 의해 반환된 파일 기술자에 적용되어야 합니다. 내장 함수 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> 나 <a class="reference internal" href="#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">popen()</span></code></a> 또는 <a class="reference internal" href="#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">fdopen()</span></code></a>에 의해 반환된 &quot;파일 객체&quot;를 닫으려면, <a class="reference internal" href="io.html#io.IOBase.close" title="io.IOBase.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> 메서드를 사용하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.closerange">
<code class="descclassname">os.</code><code class="descname">closerange</code><span class="sig-paren">(</span><em>fd_low</em>, <em>fd_high</em><span class="sig-paren">)</span><a class="headerlink" href="#os.closerange" title="정의 주소">¶</a></dt>
<dd><p>에러는 무시하면서, <em>fd_low</em>(포함)부터 <em>fd_high</em>(제외)까지 모든 파일 기술자를 닫습니다. 다음과 동등합니다 (하지만 훨씬 빠릅니다):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fd_low</span><span class="p">,</span> <span class="n">fd_high</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="os.device_encoding">
<code class="descclassname">os.</code><code class="descname">device_encoding</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#os.device_encoding" title="정의 주소">¶</a></dt>
<dd><p><em>fd</em> 와 연관된 장치가 터미널에 연결되어 있을 때 인코딩을 설명하는 문자열을 반환합니다; 그렇지 않으면 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.dup">
<code class="descclassname">os.</code><code class="descname">dup</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#os.dup" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em> 의 복사본을 반환합니다. 새 파일 기술자는 <a class="reference internal" href="#fd-inheritance"><span class="std std-ref">상속 불가능</span></a>합니다.</p>
<p>윈도우에서는, 표준 스트림(0: stdin, 1: stdout, 2: stderr)을 복제할 때, 새 파일 기술자가 <a class="reference internal" href="#fd-inheritance"><span class="std std-ref">상속 가능</span></a>합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>새로운 파일 기술자는 이제 상속 불가능합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.dup2">
<code class="descclassname">os.</code><code class="descname">dup2</code><span class="sig-paren">(</span><em>fd</em>, <em>fd2</em>, <em>inheritable=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.dup2" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em> 를 <em>fd2</em>에 복제하고, 필요하면 먼저 후자를 닫습니다. <em>fd2</em>를 반환합니다. 새로운 파일 기술자는 기본적으로 <a class="reference internal" href="#fd-inheritance"><span class="std std-ref">상속 가능</span></a>하고, <em>inheritable</em> 이 <code class="docutils literal"><span class="pre">False</span></code>면 상속 불가능합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>선택적 <em>inheritable</em> 매개 변수를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>성공하면 <em>fd2</em> 를 반환합니다. 이전에는 항상 <code class="docutils literal"><span class="pre">None</span></code>을 반환했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.fchmod">
<code class="descclassname">os.</code><code class="descname">fchmod</code><span class="sig-paren">(</span><em>fd</em>, <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#os.fchmod" title="정의 주소">¶</a></dt>
<dd><p><em>fd</em> 에 의해 주어진 파일의 모드를 숫자 <em>mode</em> 로 변경합니다. <em>mode</em>의 가능한 값은 <a class="reference internal" href="#os.chmod" title="os.chmod"><code class="xref py py-func docutils literal"><span class="pre">chmod()</span></code></a> 문서를 참조하십시오. 파이썬 3.3부터는, <code class="docutils literal"><span class="pre">os.chmod(fd,</span> <span class="pre">mode)</span></code>와 같습니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.fchown">
<code class="descclassname">os.</code><code class="descname">fchown</code><span class="sig-paren">(</span><em>fd</em>, <em>uid</em>, <em>gid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.fchown" title="정의 주소">¶</a></dt>
<dd><p><em>fd</em> 에 의해 주어진 파일의 소유자와 그룹 id를 숫자 <em>uid</em> 와 <em>gid</em>로 변경합니다. ID 중 하나를 변경하지 않으려면, 그것을 -1로 설정하십시오. <a class="reference internal" href="#os.chown" title="os.chown"><code class="xref py py-func docutils literal"><span class="pre">chown()</span></code></a>를 참조하십시오. 파이썬 3.3부터는, <code class="docutils literal"><span class="pre">os.chown(fd,</span> <span class="pre">uid,</span> <span class="pre">gid)</span></code>와 같습니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.fdatasync">
<code class="descclassname">os.</code><code class="descname">fdatasync</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#os.fdatasync" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em> 로 주어진 파일을 디스크에 쓰도록 강제합니다. 메타 데이터를 갱신하도록 강제하지 않습니다.</p>
<p>가용성: 유닉스.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 함수는 MacOS에서는 사용할 수 없습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.fpathconf">
<code class="descclassname">os.</code><code class="descname">fpathconf</code><span class="sig-paren">(</span><em>fd</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#os.fpathconf" title="정의 주소">¶</a></dt>
<dd><p>열린 파일과 관련된 시스템 구성 정보를 반환합니다. <em>name</em> 은 조회할 구성 값을 지정합니다; 정의된 시스템 값의 이름인 문자열일 수 있습니다; 이 이름은 여러 표준(POSIX.1, 유닉스 95, 유닉스 98 및 기타)에서 지정됩니다. 일부 플랫폼은 추가 이름도 정의합니다. 호스트 운영 체제에 알려진 이름은 <code class="docutils literal"><span class="pre">pathconf_names</span></code> 딕셔너리에서 제공됩니다. 이 매핑에 포함되지 않은 구성 변수의 경우, <em>name</em>에 정수를 전달하는 것도 허용됩니다.</p>
<p><em>name</em> 이 문자열이고 알 수 없으면, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>가 발생합니다. <em>name</em>에 대한 특정 값이 호스트 시스템에서 지원되지 않으면, <code class="docutils literal"><span class="pre">pathconf_names</span></code>에 포함되어 있어도, 에러 번호가 <a class="reference internal" href="errno.html#errno.EINVAL" title="errno.EINVAL"><code class="xref py py-const docutils literal"><span class="pre">errno.EINVAL</span></code></a>인 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>가 발생합니다.</p>
<p>파이썬 3.3부터, <code class="docutils literal"><span class="pre">os.pathconf(fd,</span> <span class="pre">name)</span></code>과 같습니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.fstat">
<code class="descclassname">os.</code><code class="descname">fstat</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#os.fstat" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em> 의 상태를 가져옵니다. <a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a> 객체를 반환합니다.</p>
<p>파이썬 3.3부터는, <code class="docutils literal"><span class="pre">os.stat(fd)</span></code>와 같습니다.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a> 함수.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.fstatvfs">
<code class="descclassname">os.</code><code class="descname">fstatvfs</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#os.fstatvfs" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.statvfs" title="os.statvfs"><code class="xref py py-func docutils literal"><span class="pre">statvfs()</span></code></a> 처럼, 파일 기술자 <em>fd</em> 와 연관된 파일을 포함하는 파일 시스템에 대한 정보를 반환합니다. 파이썬 3.3부터는, <code class="docutils literal"><span class="pre">os.statvfs(fd)</span></code>와 같습니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.fsync">
<code class="descclassname">os.</code><code class="descname">fsync</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#os.fsync" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em> 의 파일을 디스크에 쓰도록 강제합니다. 유닉스에서는, 네이티브 <code class="xref c c-func docutils literal"><span class="pre">fsync()</span></code> 함수를 호출합니다; 윈도우에서는, MS <code class="xref c c-func docutils literal"><span class="pre">_commit()</span></code> 함수.</p>
<p>버퍼링 된 파이썬 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a> <em>f</em>로 시작하는 경우, <em>f</em> 와 연관된 모든 내부 버퍼가 디스크에 기록되게 하기 위해, 먼저 <code class="docutils literal"><span class="pre">f.flush()</span></code>를 수행한 다음 <code class="docutils literal"><span class="pre">os.fsync(f.fileno())</span></code>를 하십시오.</p>
<p>가용성: 유닉스, 윈도우.</p>
</dd></dl>

<dl class="function">
<dt id="os.ftruncate">
<code class="descclassname">os.</code><code class="descname">ftruncate</code><span class="sig-paren">(</span><em>fd</em>, <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#os.ftruncate" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em>에 해당하는 파일을 잘라내어 최대 <em>length</em> 바이트가 되도록 만듭니다. 파이썬 3.3부터는, <code class="docutils literal"><span class="pre">os.truncate(fd,</span> <span class="pre">length)</span></code>와 같습니다.</p>
<p>가용성: 유닉스, 윈도우.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>윈도우 지원 추가</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.get_blocking">
<code class="descclassname">os.</code><code class="descname">get_blocking</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#os.get_blocking" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자의 블로킹 모드를 얻어옵니다: <a class="reference internal" href="#os.O_NONBLOCK" title="os.O_NONBLOCK"><code class="xref py py-data docutils literal"><span class="pre">O_NONBLOCK</span></code></a> 플래그가 설정되었으면 <code class="docutils literal"><span class="pre">False</span></code>, 플래그가 지워졌으면 <code class="docutils literal"><span class="pre">True</span></code>.</p>
<p><a class="reference internal" href="#os.set_blocking" title="os.set_blocking"><code class="xref py py-func docutils literal"><span class="pre">set_blocking()</span></code></a> 및 <a class="reference internal" href="socket.html#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.setblocking()</span></code></a>도 참조하십시오.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.isatty">
<code class="descclassname">os.</code><code class="descname">isatty</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#os.isatty" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em> 가 열려 있고 tty(류의) 장치에 연결되어 있으면 <code class="docutils literal"><span class="pre">True</span></code>를 반환하고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.lockf">
<code class="descclassname">os.</code><code class="descname">lockf</code><span class="sig-paren">(</span><em>fd</em>, <em>cmd</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#os.lockf" title="정의 주소">¶</a></dt>
<dd><p>열린 파일 기술자에 POSIX 록을 적용, 검사 또는 제거합니다. <em>fd</em> 는 열린 파일 기술자입니다. <em>cmd</em> 는 사용할 명령을 지정합니다 - <a class="reference internal" href="#os.F_LOCK" title="os.F_LOCK"><code class="xref py py-data docutils literal"><span class="pre">F_LOCK</span></code></a>, <a class="reference internal" href="#os.F_TLOCK" title="os.F_TLOCK"><code class="xref py py-data docutils literal"><span class="pre">F_TLOCK</span></code></a>, <a class="reference internal" href="#os.F_ULOCK" title="os.F_ULOCK"><code class="xref py py-data docutils literal"><span class="pre">F_ULOCK</span></code></a> 또는 <a class="reference internal" href="#os.F_TEST" title="os.F_TEST"><code class="xref py py-data docutils literal"><span class="pre">F_TEST</span></code></a> 중 하나. <em>len</em> 은 잠글 파일의 영역을 지정합니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.F_LOCK">
<code class="descclassname">os.</code><code class="descname">F_LOCK</code><a class="headerlink" href="#os.F_LOCK" title="정의 주소">¶</a></dt>
<dt id="os.F_TLOCK">
<code class="descclassname">os.</code><code class="descname">F_TLOCK</code><a class="headerlink" href="#os.F_TLOCK" title="정의 주소">¶</a></dt>
<dt id="os.F_ULOCK">
<code class="descclassname">os.</code><code class="descname">F_ULOCK</code><a class="headerlink" href="#os.F_ULOCK" title="정의 주소">¶</a></dt>
<dt id="os.F_TEST">
<code class="descclassname">os.</code><code class="descname">F_TEST</code><a class="headerlink" href="#os.F_TEST" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.lockf" title="os.lockf"><code class="xref py py-func docutils literal"><span class="pre">lockf()</span></code></a>가 취할 조치를 지정하는 플래그.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.lseek">
<code class="descclassname">os.</code><code class="descname">lseek</code><span class="sig-paren">(</span><em>fd</em>, <em>pos</em>, <em>how</em><span class="sig-paren">)</span><a class="headerlink" href="#os.lseek" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em> 의 현재 위치를 <em>how</em> 에 따라 달리 해석되는 위치 <em>pos</em>로 설정합니다: <a class="reference internal" href="#os.SEEK_SET" title="os.SEEK_SET"><code class="xref py py-const docutils literal"><span class="pre">SEEK_SET</span></code></a> 이나 <code class="docutils literal"><span class="pre">0</span></code> 이면 파일의 시작 부분을 기준으로 위치를 설정합니다; <a class="reference internal" href="#os.SEEK_CUR" title="os.SEEK_CUR"><code class="xref py py-const docutils literal"><span class="pre">SEEK_CUR</span></code></a>이나 <code class="docutils literal"><span class="pre">1</span></code> 이면 현재 위치를 기준으로 설정합니다; <a class="reference internal" href="#os.SEEK_END" title="os.SEEK_END"><code class="xref py py-const docutils literal"><span class="pre">SEEK_END</span></code></a> 나 <code class="docutils literal"><span class="pre">2</span></code> 면 파일의 끝을 기준으로 설정합니다. 새 커서 위치를 파일의 시작에서 따진 바이트로 반환합니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.SEEK_SET">
<code class="descclassname">os.</code><code class="descname">SEEK_SET</code><a class="headerlink" href="#os.SEEK_SET" title="정의 주소">¶</a></dt>
<dt id="os.SEEK_CUR">
<code class="descclassname">os.</code><code class="descname">SEEK_CUR</code><a class="headerlink" href="#os.SEEK_CUR" title="정의 주소">¶</a></dt>
<dt id="os.SEEK_END">
<code class="descclassname">os.</code><code class="descname">SEEK_END</code><a class="headerlink" href="#os.SEEK_END" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.lseek" title="os.lseek"><code class="xref py py-func docutils literal"><span class="pre">lseek()</span></code></a> 함수의 매개 변수. 값은 각각 0, 1, 2입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span>일부 운영 체제는 <code class="xref py py-data docutils literal"><span class="pre">os.SEEK_HOLE</span></code> 이나 <code class="xref py py-data docutils literal"><span class="pre">os.SEEK_DATA</span></code>와 같은 추가 값을 지원할 수 있습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.open">
<code class="descclassname">os.</code><code class="descname">open</code><span class="sig-paren">(</span><em>path</em>, <em>flags</em>, <em>mode=0o777</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.open" title="정의 주소">¶</a></dt>
<dd><p>파일 <em>path</em>를 열고 <em>flags</em> 에 따른 다양한 플래그와 때로 <em>mode</em> 따른 모드를 설정합니다. <em>mode</em>를 계산할 때, 현재 umask 값으로 먼저 마스킹합니다. 새롭게 열린 파일의 파일 기술자를 돌려줍니다. 새 파일 기술자는 <a class="reference internal" href="#fd-inheritance"><span class="std std-ref">상속 불가능</span></a>합니다.</p>
<p>플래그와 모드 값에 대한 설명은, C 런타임 설명서를 참조하십시오; 플래그 상수(<a class="reference internal" href="#os.O_RDONLY" title="os.O_RDONLY"><code class="xref py py-const docutils literal"><span class="pre">O_RDONLY</span></code></a> 와 <a class="reference internal" href="#os.O_WRONLY" title="os.O_WRONLY"><code class="xref py py-const docutils literal"><span class="pre">O_WRONLY</span></code></a>와 같은)는 <a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> 모듈에 정의되어 있습니다. 특히, 윈도우에서 바이너리 모드로 파일을 열려면 <a class="reference internal" href="#os.O_BINARY" title="os.O_BINARY"><code class="xref py py-const docutils literal"><span class="pre">O_BINARY</span></code></a>를 추가해야 합니다.</p>
<p>이 함수는 <em>dir_fd</em> 매개 변수로 <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a>를 지원할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>새로운 파일 기술자는 이제 상속 불가능합니다.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 함수는 저수준 I/O를 위한 것입니다. 일반적인 사용을 위해서는 내장 함수 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>을 사용하십시오, 이 함수는 <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code> 및 <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code> 메서드(와 더 많은 메서드)가있는 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a>를 반환합니다. 파일 기술자를 파일 객체로 싸려면, <a class="reference internal" href="#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">fdopen()</span></code></a>을 사용하십시오.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>dir_fd</em> 인자</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 함수는 이제 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> 예외를 일으키는 대신 시스템 호출을 재시도합니다 (이유는 <span class="target" id="index-53"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하세요).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<p>다음 상수는 <a class="reference internal" href="#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> 함수에 대한 <em>flags</em> 매개 변수의 옵션입니다. 비트별 OR 연산자 <code class="docutils literal"><span class="pre">|</span></code>를 사용하여 결합할 수 있습니다. 일부는 모든 플랫폼에서 사용할 수는 없습니다. 가용성과 사용에 대한 설명은 유닉스의 <em class="manpage">open(2)</em> 매뉴얼 페이지 또는 윈도우의 <a class="reference external" href="https://msdn.microsoft.com/en-us/library/z0kc8e3z.aspx">MSDN</a>을 참조하십시오.</p>
<dl class="data">
<dt id="os.O_RDONLY">
<code class="descclassname">os.</code><code class="descname">O_RDONLY</code><a class="headerlink" href="#os.O_RDONLY" title="정의 주소">¶</a></dt>
<dt id="os.O_WRONLY">
<code class="descclassname">os.</code><code class="descname">O_WRONLY</code><a class="headerlink" href="#os.O_WRONLY" title="정의 주소">¶</a></dt>
<dt id="os.O_RDWR">
<code class="descclassname">os.</code><code class="descname">O_RDWR</code><a class="headerlink" href="#os.O_RDWR" title="정의 주소">¶</a></dt>
<dt id="os.O_APPEND">
<code class="descclassname">os.</code><code class="descname">O_APPEND</code><a class="headerlink" href="#os.O_APPEND" title="정의 주소">¶</a></dt>
<dt id="os.O_CREAT">
<code class="descclassname">os.</code><code class="descname">O_CREAT</code><a class="headerlink" href="#os.O_CREAT" title="정의 주소">¶</a></dt>
<dt id="os.O_EXCL">
<code class="descclassname">os.</code><code class="descname">O_EXCL</code><a class="headerlink" href="#os.O_EXCL" title="정의 주소">¶</a></dt>
<dt id="os.O_TRUNC">
<code class="descclassname">os.</code><code class="descname">O_TRUNC</code><a class="headerlink" href="#os.O_TRUNC" title="정의 주소">¶</a></dt>
<dd><p>위의 상수는 유닉스 및 윈도우에서 사용할 수 있습니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.O_DSYNC">
<code class="descclassname">os.</code><code class="descname">O_DSYNC</code><a class="headerlink" href="#os.O_DSYNC" title="정의 주소">¶</a></dt>
<dt id="os.O_RSYNC">
<code class="descclassname">os.</code><code class="descname">O_RSYNC</code><a class="headerlink" href="#os.O_RSYNC" title="정의 주소">¶</a></dt>
<dt id="os.O_SYNC">
<code class="descclassname">os.</code><code class="descname">O_SYNC</code><a class="headerlink" href="#os.O_SYNC" title="정의 주소">¶</a></dt>
<dt id="os.O_NDELAY">
<code class="descclassname">os.</code><code class="descname">O_NDELAY</code><a class="headerlink" href="#os.O_NDELAY" title="정의 주소">¶</a></dt>
<dt id="os.O_NONBLOCK">
<code class="descclassname">os.</code><code class="descname">O_NONBLOCK</code><a class="headerlink" href="#os.O_NONBLOCK" title="정의 주소">¶</a></dt>
<dt id="os.O_NOCTTY">
<code class="descclassname">os.</code><code class="descname">O_NOCTTY</code><a class="headerlink" href="#os.O_NOCTTY" title="정의 주소">¶</a></dt>
<dt id="os.O_CLOEXEC">
<code class="descclassname">os.</code><code class="descname">O_CLOEXEC</code><a class="headerlink" href="#os.O_CLOEXEC" title="정의 주소">¶</a></dt>
<dd><p>위의 상수는 유닉스에서만 사용할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><a class="reference internal" href="#os.O_CLOEXEC" title="os.O_CLOEXEC"><code class="xref py py-data docutils literal"><span class="pre">O_CLOEXEC</span></code></a> 상수를 추가합니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.O_BINARY">
<code class="descclassname">os.</code><code class="descname">O_BINARY</code><a class="headerlink" href="#os.O_BINARY" title="정의 주소">¶</a></dt>
<dt id="os.O_NOINHERIT">
<code class="descclassname">os.</code><code class="descname">O_NOINHERIT</code><a class="headerlink" href="#os.O_NOINHERIT" title="정의 주소">¶</a></dt>
<dt id="os.O_SHORT_LIVED">
<code class="descclassname">os.</code><code class="descname">O_SHORT_LIVED</code><a class="headerlink" href="#os.O_SHORT_LIVED" title="정의 주소">¶</a></dt>
<dt id="os.O_TEMPORARY">
<code class="descclassname">os.</code><code class="descname">O_TEMPORARY</code><a class="headerlink" href="#os.O_TEMPORARY" title="정의 주소">¶</a></dt>
<dt id="os.O_RANDOM">
<code class="descclassname">os.</code><code class="descname">O_RANDOM</code><a class="headerlink" href="#os.O_RANDOM" title="정의 주소">¶</a></dt>
<dt id="os.O_SEQUENTIAL">
<code class="descclassname">os.</code><code class="descname">O_SEQUENTIAL</code><a class="headerlink" href="#os.O_SEQUENTIAL" title="정의 주소">¶</a></dt>
<dt id="os.O_TEXT">
<code class="descclassname">os.</code><code class="descname">O_TEXT</code><a class="headerlink" href="#os.O_TEXT" title="정의 주소">¶</a></dt>
<dd><p>위의 상수는 윈도우에서만 사용할 수 있습니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.O_ASYNC">
<code class="descclassname">os.</code><code class="descname">O_ASYNC</code><a class="headerlink" href="#os.O_ASYNC" title="정의 주소">¶</a></dt>
<dt id="os.O_DIRECT">
<code class="descclassname">os.</code><code class="descname">O_DIRECT</code><a class="headerlink" href="#os.O_DIRECT" title="정의 주소">¶</a></dt>
<dt id="os.O_DIRECTORY">
<code class="descclassname">os.</code><code class="descname">O_DIRECTORY</code><a class="headerlink" href="#os.O_DIRECTORY" title="정의 주소">¶</a></dt>
<dt id="os.O_NOFOLLOW">
<code class="descclassname">os.</code><code class="descname">O_NOFOLLOW</code><a class="headerlink" href="#os.O_NOFOLLOW" title="정의 주소">¶</a></dt>
<dt id="os.O_NOATIME">
<code class="descclassname">os.</code><code class="descname">O_NOATIME</code><a class="headerlink" href="#os.O_NOATIME" title="정의 주소">¶</a></dt>
<dt id="os.O_PATH">
<code class="descclassname">os.</code><code class="descname">O_PATH</code><a class="headerlink" href="#os.O_PATH" title="정의 주소">¶</a></dt>
<dt id="os.O_TMPFILE">
<code class="descclassname">os.</code><code class="descname">O_TMPFILE</code><a class="headerlink" href="#os.O_TMPFILE" title="정의 주소">¶</a></dt>
<dt id="os.O_SHLOCK">
<code class="descclassname">os.</code><code class="descname">O_SHLOCK</code><a class="headerlink" href="#os.O_SHLOCK" title="정의 주소">¶</a></dt>
<dt id="os.O_EXLOCK">
<code class="descclassname">os.</code><code class="descname">O_EXLOCK</code><a class="headerlink" href="#os.O_EXLOCK" title="정의 주소">¶</a></dt>
<dd><p>위의 상수는 확장이며 C 라이브러리에서 정의하지 않으면 존재하지 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>지원하는 시스템에 <a class="reference internal" href="#os.O_PATH" title="os.O_PATH"><code class="xref py py-data docutils literal"><span class="pre">O_PATH</span></code></a>를 추가합니다. 리눅스 커널 3.11 이상에서만 사용 가능한 <a class="reference internal" href="#os.O_TMPFILE" title="os.O_TMPFILE"><code class="xref py py-data docutils literal"><span class="pre">O_TMPFILE</span></code></a>를 추가합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.openpty">
<code class="descclassname">os.</code><code class="descname">openpty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.openpty" title="정의 주소">¶</a></dt>
<dd><p id="index-15">새로운 가상 터미널 쌍을 엽니다. 파일 기술자의 쌍 <code class="docutils literal"><span class="pre">(master,</span> <span class="pre">slave)</span></code> 를 반환하는데, 각각 pty와 tty 입니다. 새 파일 기술자는 <a class="reference internal" href="#fd-inheritance"><span class="std std-ref">상속 불가능</span></a>합니다. (약간) 더 이식성 있는 접근 방식을 사용하려면, <a class="reference internal" href="pty.html#module-pty" title="pty: Pseudo-Terminal Handling for Linux. (Linux)"><code class="xref py py-mod docutils literal"><span class="pre">pty</span></code></a> 모듈을 사용하십시오.</p>
<p>가용성: 일부 유닉스.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>새로운 파일 기술자는 이제 상속 불가능합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.pipe">
<code class="descclassname">os.</code><code class="descname">pipe</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.pipe" title="정의 주소">¶</a></dt>
<dd><p>파이프를 만듭니다. 파일 기술자 쌍 <code class="docutils literal"><span class="pre">(r,</span> <span class="pre">w)</span></code> 를 반환하는데, 각각 읽기와 쓰기에 사용할 수 있습니다. 새 파일 기술자는 <a class="reference internal" href="#fd-inheritance"><span class="std std-ref">상속 불가능</span></a>합니다.</p>
<p>가용성: 유닉스, 윈도우.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>새로운 파일 기술자는 이제 상속 불가능합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.pipe2">
<code class="descclassname">os.</code><code class="descname">pipe2</code><span class="sig-paren">(</span><em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#os.pipe2" title="정의 주소">¶</a></dt>
<dd><p><em>flags</em> 가 원자적으로 설정된 파이프를 만듭니다. <em>flags</em> 는 다음과 같은 값들을 하나 이상 OR 해서 만들 수 있습니다: <a class="reference internal" href="#os.O_NONBLOCK" title="os.O_NONBLOCK"><code class="xref py py-data docutils literal"><span class="pre">O_NONBLOCK</span></code></a>, <a class="reference internal" href="#os.O_CLOEXEC" title="os.O_CLOEXEC"><code class="xref py py-data docutils literal"><span class="pre">O_CLOEXEC</span></code></a>. 파일 기술자 쌍 <code class="docutils literal"><span class="pre">(r,</span> <span class="pre">w)</span></code> 를 반환하는데, 각각 읽기와 쓰기에 사용할 수 있습니다.</p>
<p>가용성: 일부 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.posix_fallocate">
<code class="descclassname">os.</code><code class="descname">posix_fallocate</code><span class="sig-paren">(</span><em>fd</em>, <em>offset</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#os.posix_fallocate" title="정의 주소">¶</a></dt>
<dd><p><em>fd</em>로 지정된 파일이 <em>offset</em> 에서 시작하여 <em>len</em> 바이트 동안 계속되도록 충분한 디스크 공간을 할당합니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.posix_fadvise">
<code class="descclassname">os.</code><code class="descname">posix_fadvise</code><span class="sig-paren">(</span><em>fd</em>, <em>offset</em>, <em>len</em>, <em>advice</em><span class="sig-paren">)</span><a class="headerlink" href="#os.posix_fadvise" title="정의 주소">¶</a></dt>
<dd><p>특정 패턴으로 데이터에 액세스하려는 의도를 알려 커널이 최적화할 수 있도록 합니다. 조언(advice)은 <em>fd에</em> 의해 지정된 파일의 <em>offset</em> 에서 시작하여 <em>len</em> 바이트 동안 계속되는 영역에 적용됩니다. <em>advice</em>는 <a class="reference internal" href="#os.POSIX_FADV_NORMAL" title="os.POSIX_FADV_NORMAL"><code class="xref py py-data docutils literal"><span class="pre">POSIX_FADV_NORMAL</span></code></a>, <a class="reference internal" href="#os.POSIX_FADV_SEQUENTIAL" title="os.POSIX_FADV_SEQUENTIAL"><code class="xref py py-data docutils literal"><span class="pre">POSIX_FADV_SEQUENTIAL</span></code></a>, <a class="reference internal" href="#os.POSIX_FADV_RANDOM" title="os.POSIX_FADV_RANDOM"><code class="xref py py-data docutils literal"><span class="pre">POSIX_FADV_RANDOM</span></code></a>, <a class="reference internal" href="#os.POSIX_FADV_NOREUSE" title="os.POSIX_FADV_NOREUSE"><code class="xref py py-data docutils literal"><span class="pre">POSIX_FADV_NOREUSE</span></code></a>, <a class="reference internal" href="#os.POSIX_FADV_WILLNEED" title="os.POSIX_FADV_WILLNEED"><code class="xref py py-data docutils literal"><span class="pre">POSIX_FADV_WILLNEED</span></code></a> 또는 <a class="reference internal" href="#os.POSIX_FADV_DONTNEED" title="os.POSIX_FADV_DONTNEED"><code class="xref py py-data docutils literal"><span class="pre">POSIX_FADV_DONTNEED</span></code></a> 중 하나입니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.POSIX_FADV_NORMAL">
<code class="descclassname">os.</code><code class="descname">POSIX_FADV_NORMAL</code><a class="headerlink" href="#os.POSIX_FADV_NORMAL" title="정의 주소">¶</a></dt>
<dt id="os.POSIX_FADV_SEQUENTIAL">
<code class="descclassname">os.</code><code class="descname">POSIX_FADV_SEQUENTIAL</code><a class="headerlink" href="#os.POSIX_FADV_SEQUENTIAL" title="정의 주소">¶</a></dt>
<dt id="os.POSIX_FADV_RANDOM">
<code class="descclassname">os.</code><code class="descname">POSIX_FADV_RANDOM</code><a class="headerlink" href="#os.POSIX_FADV_RANDOM" title="정의 주소">¶</a></dt>
<dt id="os.POSIX_FADV_NOREUSE">
<code class="descclassname">os.</code><code class="descname">POSIX_FADV_NOREUSE</code><a class="headerlink" href="#os.POSIX_FADV_NOREUSE" title="정의 주소">¶</a></dt>
<dt id="os.POSIX_FADV_WILLNEED">
<code class="descclassname">os.</code><code class="descname">POSIX_FADV_WILLNEED</code><a class="headerlink" href="#os.POSIX_FADV_WILLNEED" title="정의 주소">¶</a></dt>
<dt id="os.POSIX_FADV_DONTNEED">
<code class="descclassname">os.</code><code class="descname">POSIX_FADV_DONTNEED</code><a class="headerlink" href="#os.POSIX_FADV_DONTNEED" title="정의 주소">¶</a></dt>
<dd><p>사용 가능성이 큰 액세스 패턴을 지정하는 <a class="reference internal" href="#os.posix_fadvise" title="os.posix_fadvise"><code class="xref py py-func docutils literal"><span class="pre">posix_fadvise()</span></code></a>의 <em>advice</em> 에 사용될 수 있는 플래그.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.pread">
<code class="descclassname">os.</code><code class="descname">pread</code><span class="sig-paren">(</span><em>fd</em>, <em>n</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#os.pread" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em>에서 <em>offset</em> 의 위치부터 최대 <em>n</em> 바이트를 읽어 들이고, 파일 오프셋은 변경되지 않은 채로 남겨 둡니다.</p>
<p>읽어 들인 바이트를 포함하는 바이트열을 돌려줍니다. <em>fd</em> 에 의해 참조된 파일의 끝에 도달하면, 빈 바이트열 객체가 반환됩니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.preadv">
<code class="descclassname">os.</code><code class="descname">preadv</code><span class="sig-paren">(</span><em>fd</em>, <em>buffers</em>, <em>offset</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#os.preadv" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em>에서 <em>offset</em> 위치부터 가변 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체들</span></a> <em>buffers</em> 로 읽어 들이고, 파일 오프셋은 변경되지 않은 채로 남겨 둡니다. 데이터가 가득 찰 때까지 각 버퍼로 데이터를 전송한 다음 나머지 데이터를 보관하기 위해 시퀀스의 다음 버퍼로 이동합니다.</p>
<p>flags 인자는 다음 플래그 중 0개 이상의 비트별 OR를 포함합니다:</p>
<ul class="simple">
<li><a class="reference internal" href="#os.RWF_HIPRI" title="os.RWF_HIPRI"><code class="xref py py-data docutils literal"><span class="pre">RWF_HIPRI</span></code></a></li>
<li><a class="reference internal" href="#os.RWF_NOWAIT" title="os.RWF_NOWAIT"><code class="xref py py-data docutils literal"><span class="pre">RWF_NOWAIT</span></code></a></li>
</ul>
<p>실제로 읽힌 총 바이트 수를 반환합니다. 이 값은 모든 객체의 총 용량보다 작을 수 있습니다.</p>
<p>운영 체제는 사용할 수 있는 버퍼 수에 한계(<a class="reference internal" href="#os.sysconf" title="os.sysconf"><code class="xref py py-func docutils literal"><span class="pre">sysconf()</span></code></a> 값 <code class="docutils literal"><span class="pre">'SC_IOV_MAX'</span></code>)를 설정할 수 있습니다.</p>
<p><a class="reference internal" href="#os.readv" title="os.readv"><code class="xref py py-func docutils literal"><span class="pre">os.readv()</span></code></a> 와 <a class="reference internal" href="#os.pread" title="os.pread"><code class="xref py py-func docutils literal"><span class="pre">os.pread()</span></code></a>의 기능을 결합합니다.</p>
<p>가용성: 리눅스 2.6.30 이상, FreeBSD 6.0 이상, OpenBSD 2.7 이상. flags를 사용하려면 리눅스 4.6 이상이 필요합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.RWF_NOWAIT">
<code class="descclassname">os.</code><code class="descname">RWF_NOWAIT</code><a class="headerlink" href="#os.RWF_NOWAIT" title="정의 주소">¶</a></dt>
<dd><p>즉시 사용할 수 없는 데이터를 기다리지 않습니다. 이 플래그를 지정하면, 하부 저장 장치에서 데이터를 읽어야 하거나 록을 기다려야 할 때 즉시 시스템 호출이 반환됩니다.</p>
<p>일부 데이터가 성공적으로 읽히면, 읽은 바이트 수를 반환합니다. 읽은 바이트가 없으면, <code class="docutils literal"><span class="pre">-1</span></code>을 반환하고 errno를 <a class="reference internal" href="errno.html#errno.EAGAIN" title="errno.EAGAIN"><code class="xref py py-data docutils literal"><span class="pre">errno.EAGAIN</span></code></a>로 설정합니다.</p>
<p>가용성: 리눅스 4.14 이상.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.RWF_HIPRI">
<code class="descclassname">os.</code><code class="descname">RWF_HIPRI</code><a class="headerlink" href="#os.RWF_HIPRI" title="정의 주소">¶</a></dt>
<dd><p>우선순위가 높은 읽기/쓰기. 블록 기반 파일 시스템이 장치의 폴링을 사용할 수 있게 하여, 지연은 짧아 지지만, 추가 자원을 사용할 수 있습니다.</p>
<p>현재, 리눅스에서, 이 기능은 <a class="reference internal" href="#os.O_DIRECT" title="os.O_DIRECT"><code class="xref py py-data docutils literal"><span class="pre">O_DIRECT</span></code></a> 플래그를 사용하여 열린 파일 기술자에서만 사용할 수 있습니다.</p>
<p>가용성: 리눅스 4.6 이상.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.pwrite">
<code class="descclassname">os.</code><code class="descname">pwrite</code><span class="sig-paren">(</span><em>fd</em>, <em>str</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#os.pwrite" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em>의 <em>offset</em> 위치에 <em>str</em> 바이트열을 쓰고, 파일 오프셋은 변경되지 않은 채로 남겨 둡니다.</p>
<p>실제로 쓴 바이트 수를 반환합니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.pwritev">
<code class="descclassname">os.</code><code class="descname">pwritev</code><span class="sig-paren">(</span><em>fd</em>, <em>buffers</em>, <em>offset</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#os.pwritev" title="정의 주소">¶</a></dt>
<dd><p><em>buffers</em> 내용을 파일 기술자 <em>fd</em>의 오프셋 <em>offset</em> 에 쓰고, 파일 오프셋은 변경되지 않은 채로 남겨 둡니다. <em>buffers</em> 는 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>의 시퀀스 여야 합니다. 버퍼는 배열 순서로 처리됩니다. 첫 번째 버퍼의 전체 내용은 두 번째 버퍼로 진행하기 전에 기록되고, 같은 식으로 계속 진행합니다.</p>
<p>flags 인자는 다음 플래그 중 0개 이상의 비트별 OR를 포함합니다:</p>
<ul class="simple">
<li><a class="reference internal" href="#os.RWF_DSYNC" title="os.RWF_DSYNC"><code class="xref py py-data docutils literal"><span class="pre">RWF_DSYNC</span></code></a></li>
<li><a class="reference internal" href="#os.RWF_SYNC" title="os.RWF_SYNC"><code class="xref py py-data docutils literal"><span class="pre">RWF_SYNC</span></code></a></li>
</ul>
<p>실제로 쓴 총 바이트 수를 반환합니다.</p>
<p>운영 체제는 사용할 수 있는 버퍼 수에 한계(<a class="reference internal" href="#os.sysconf" title="os.sysconf"><code class="xref py py-func docutils literal"><span class="pre">sysconf()</span></code></a> 값 <code class="docutils literal"><span class="pre">'SC_IOV_MAX'</span></code>)를 설정할 수 있습니다.</p>
<p><a class="reference internal" href="#os.writev" title="os.writev"><code class="xref py py-func docutils literal"><span class="pre">os.writev()</span></code></a> 와 <a class="reference internal" href="#os.pwrite" title="os.pwrite"><code class="xref py py-func docutils literal"><span class="pre">os.pwrite()</span></code></a>의 기능을 결합합니다.</p>
<p>가용성: 리눅스 2.6.30 이상, FreeBSD 6.0 이상, OpenBSD 2.7 이상. flags를 사용하려면 리눅스 4.7 이상이 필요합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.RWF_DSYNC">
<code class="descclassname">os.</code><code class="descname">RWF_DSYNC</code><a class="headerlink" href="#os.RWF_DSYNC" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.O_DSYNC" title="os.O_DSYNC"><code class="xref py py-data docutils literal"><span class="pre">O_DSYNC</span></code></a> <code class="docutils literal"><span class="pre">open(2)</span></code> 플래그의 쓰기마다 지정할 수 있는 버전을 제공합니다. 이 플래그 효과는 시스템 호출로 기록된 데이터 범위에만 적용됩니다.</p>
<p>가용성: 리눅스 4.7 이상.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.RWF_SYNC">
<code class="descclassname">os.</code><code class="descname">RWF_SYNC</code><a class="headerlink" href="#os.RWF_SYNC" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.O_SYNC" title="os.O_SYNC"><code class="xref py py-data docutils literal"><span class="pre">O_SYNC</span></code></a> <code class="docutils literal"><span class="pre">open(2)</span></code> 플래그의 쓰기별 버전을 제공합니다. 이 플래그 효과는 시스템 호출에 의해 쓰여진 데이터 범위에만 적용됩니다.</p>
<p>가용성: 리눅스 4.7 이상.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.read">
<code class="descclassname">os.</code><code class="descname">read</code><span class="sig-paren">(</span><em>fd</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#os.read" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em>에서 최대 <em>n</em> 바이트를 읽습니다.</p>
<p>읽어 들인 바이트를 포함하는 바이트열을 돌려줍니다. <em>fd</em> 에 의해 참조된 파일의 끝에 도달하면, 빈 바이트열 객체가 반환됩니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 함수는 저수준 I/O를 위한 것이며 <a class="reference internal" href="#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a> 이나 <a class="reference internal" href="#os.pipe" title="os.pipe"><code class="xref py py-func docutils literal"><span class="pre">pipe()</span></code></a>에 의해 반환된 파일 기술자에 적용되어야 합니다. 내장 함수 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> 이나 <a class="reference internal" href="#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">popen()</span></code></a> 또는 <a class="reference internal" href="#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">fdopen()</span></code></a>에 의해 반환된 &quot;파일 객체&quot;나 <a class="reference internal" href="sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal"><span class="pre">sys.stdin</span></code></a>을 읽으려면, 그것의 <code class="xref py py-meth docutils literal"><span class="pre">read()</span></code> 나 <code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code> 메서드를 사용하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 함수는 이제 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> 예외를 일으키는 대신 시스템 호출을 재시도합니다 (이유는 <span class="target" id="index-54"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하세요).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.sendfile">
<code class="descclassname">os.</code><code class="descname">sendfile</code><span class="sig-paren">(</span><em>out</em>, <em>in</em>, <em>offset</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#os.sendfile" title="정의 주소">¶</a></dt>
<dt>
<code class="descclassname">os.</code><code class="descname">sendfile</code><span class="sig-paren">(</span><em>out</em>, <em>in</em>, <em>offset</em>, <em>count</em>, <span class="optional">[</span><em>headers</em>, <span class="optional">]</span><span class="optional">[</span><em>trailers</em>, <span class="optional">]</span><em>flags=0</em><span class="sig-paren">)</span></dt>
<dd><p>파일 기술자 <em>in</em>에서 파일 기술자 <em>out</em> 으로 <em>offset</em>에서 시작하여 <em>count</em> 바이트를 복사합니다. 전송된 바이트 수를 반환합니다. EOF에 도달하면 0을 반환합니다.</p>
<p>첫 번째 함수 서명은 <a class="reference internal" href="#os.sendfile" title="os.sendfile"><code class="xref py py-func docutils literal"><span class="pre">sendfile()</span></code></a>를 정의하는 모든 플랫폼에서 지원됩니다.</p>
<p>리눅스에서, <em>offset</em>이 <code class="docutils literal"><span class="pre">None</span></code>으로 주어지면, <em>in</em>의 현재 위치에서 바이트를 읽고 <em>in</em>의 위치가 갱신됩니다.</p>
<p>두 번째 경우는 맥 OS X와 FreeBSD에 사용될 수 있는데, <em>headers</em> 와 <em>trailers</em> 는 <em>in</em> 의 데이터가 기록되는 전후에 기록되는 버퍼의 임의의 시퀀스입니다. 첫 번째 경우와 같은 결과를 반환합니다.</p>
<p>맥 OS X 및 FreeBSD에서, <em>count</em> 의 값 0은 <em>in</em> 의 끝에 도달할 때까지 보내도록 지정합니다.</p>
<p>모든 플랫폼은 <em>out</em> 파일 기술자로 소켓을 지원하고, 일부 플랫폼은 다른 유형(예를 들어 일반 파일, 파이프)들도 허락합니다.</p>
<p>이기종 플랫폼 응용 프로그램은 <em>headers</em>, <em>trailers</em> 및 <em>flags</em> 인자를 사용해서는 안 됩니다.</p>
<p>가용성: 유닉스.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><a class="reference internal" href="#os.sendfile" title="os.sendfile"><code class="xref py py-func docutils literal"><span class="pre">sendfile()</span></code></a>의 고수준 래퍼는, <a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.sendfile()</span></code></a>을 보십시오.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.set_blocking">
<code class="descclassname">os.</code><code class="descname">set_blocking</code><span class="sig-paren">(</span><em>fd</em>, <em>blocking</em><span class="sig-paren">)</span><a class="headerlink" href="#os.set_blocking" title="정의 주소">¶</a></dt>
<dd><p>지정된 파일 기술자의 블로킹 모드를 설정합니다. blocking이 <code class="docutils literal"><span class="pre">False</span></code>면 <a class="reference internal" href="#os.O_NONBLOCK" title="os.O_NONBLOCK"><code class="xref py py-data docutils literal"><span class="pre">O_NONBLOCK</span></code></a> 플래그를 설정하고, 그렇지 않으면 플래그를 지웁니다.</p>
<p><a class="reference internal" href="#os.get_blocking" title="os.get_blocking"><code class="xref py py-func docutils literal"><span class="pre">get_blocking()</span></code></a>과 <a class="reference internal" href="socket.html#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal"><span class="pre">socket.socket.setblocking()</span></code></a>도 참조하십시오.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.SF_NODISKIO">
<code class="descclassname">os.</code><code class="descname">SF_NODISKIO</code><a class="headerlink" href="#os.SF_NODISKIO" title="정의 주소">¶</a></dt>
<dt id="os.SF_MNOWAIT">
<code class="descclassname">os.</code><code class="descname">SF_MNOWAIT</code><a class="headerlink" href="#os.SF_MNOWAIT" title="정의 주소">¶</a></dt>
<dt id="os.SF_SYNC">
<code class="descclassname">os.</code><code class="descname">SF_SYNC</code><a class="headerlink" href="#os.SF_SYNC" title="정의 주소">¶</a></dt>
<dd><p>구현이 지원하는 경우, <a class="reference internal" href="#os.sendfile" title="os.sendfile"><code class="xref py py-func docutils literal"><span class="pre">sendfile()</span></code></a> 함수에 대한 매개 변수입니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.readv">
<code class="descclassname">os.</code><code class="descname">readv</code><span class="sig-paren">(</span><em>fd</em>, <em>buffers</em><span class="sig-paren">)</span><a class="headerlink" href="#os.readv" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em>에서 여러 가변 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a> <em>buffers</em>로 읽어 들입니다. 데이터가 가득 찰 때까지 각 버퍼로 데이터를 전송한 다음 나머지 데이터를 보관하기 위해 시퀀스의 다음 버퍼로 이동합니다.</p>
<p>실제로 읽힌 총 바이트 수를 반환합니다. 이 값은 모든 객체의 총 용량보다 작을 수 있습니다.</p>
<p>운영 체제는 사용할 수 있는 버퍼 수에 한계(<a class="reference internal" href="#os.sysconf" title="os.sysconf"><code class="xref py py-func docutils literal"><span class="pre">sysconf()</span></code></a> 값 <code class="docutils literal"><span class="pre">'SC_IOV_MAX'</span></code>)를 설정할 수 있습니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.tcgetpgrp">
<code class="descclassname">os.</code><code class="descname">tcgetpgrp</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#os.tcgetpgrp" title="정의 주소">¶</a></dt>
<dd><p><em>fd</em>(<a class="reference internal" href="#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a>에 의해 반환된 것과 같은 열린 파일 기술자)에 의해 주어진 터미널과 관련된 프로세스 그룹을 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.tcsetpgrp">
<code class="descclassname">os.</code><code class="descname">tcsetpgrp</code><span class="sig-paren">(</span><em>fd</em>, <em>pg</em><span class="sig-paren">)</span><a class="headerlink" href="#os.tcsetpgrp" title="정의 주소">¶</a></dt>
<dd><p><em>fd</em>(<a class="reference internal" href="#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a>에 의해 반환된 것과 같은 열린 파일 기술자)에 의해 주어진 터미널과 관련된 프로세스 그룹을 <em>pg</em>로 설정합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.ttyname">
<code class="descclassname">os.</code><code class="descname">ttyname</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#os.ttyname" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>fd</em>와 관련된 터미널 장치를 나타내는 문자열을 돌려줍니다. <em>fd</em> 가 터미널 장치와 연관되어 있지 않으면, 예외가 발생합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.write">
<code class="descclassname">os.</code><code class="descname">write</code><span class="sig-paren">(</span><em>fd</em>, <em>str</em><span class="sig-paren">)</span><a class="headerlink" href="#os.write" title="정의 주소">¶</a></dt>
<dd><p><em>str</em> 바이트열을 파일 기술자 <em>fd</em> 에 씁니다.</p>
<p>실제로 쓴 바이트 수를 반환합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 함수는 저수준 I/O를 위한 것이며 <a class="reference internal" href="#os.open" title="os.open"><code class="xref py py-func docutils literal"><span class="pre">os.open()</span></code></a> 이나 <a class="reference internal" href="#os.pipe" title="os.pipe"><code class="xref py py-func docutils literal"><span class="pre">pipe()</span></code></a>에 의해 반환된 파일 기술자에 적용되어야 합니다. 내장 함수 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> 이나 <a class="reference internal" href="#os.popen" title="os.popen"><code class="xref py py-func docutils literal"><span class="pre">popen()</span></code></a> 또는 <a class="reference internal" href="#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal"><span class="pre">fdopen()</span></code></a>에 의해 반환된 &quot;파일 객체&quot;나 <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a> 또는 <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></code></a>에 쓰려면, 그것의 <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code> 메서드를 사용하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 함수는 이제 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> 예외를 일으키는 대신 시스템 호출을 재시도합니다 (이유는 <span class="target" id="index-55"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하세요).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.writev">
<code class="descclassname">os.</code><code class="descname">writev</code><span class="sig-paren">(</span><em>fd</em>, <em>buffers</em><span class="sig-paren">)</span><a class="headerlink" href="#os.writev" title="정의 주소">¶</a></dt>
<dd><p><em>buffers</em> 내용을 파일 기술자 <em>fd</em>에 씁니다. <em>buffers</em> 는 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>의 시퀀스 여야 합니다. 버퍼는 배열 순서로 처리됩니다. 첫 번째 버퍼의 전체 내용은 두 번째 버퍼로 진행하기 전에 기록되고, 같은 식으로 계속 진행합니다.</p>
<p>실제로 쓴 총 바이트 수를 반환합니다.</p>
<p>운영 체제는 사용할 수 있는 버퍼 수에 한계(<a class="reference internal" href="#os.sysconf" title="os.sysconf"><code class="xref py py-func docutils literal"><span class="pre">sysconf()</span></code></a> 값 <code class="docutils literal"><span class="pre">'SC_IOV_MAX'</span></code>)를 설정할 수 있습니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<div class="section" id="querying-the-size-of-a-terminal">
<span id="terminal-size"></span><h3>16.1.4.1. 터미널의 크기 조회하기<a class="headerlink" href="#querying-the-size-of-a-terminal" title="제목 주소">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
<dl class="function">
<dt id="os.get_terminal_size">
<code class="descclassname">os.</code><code class="descname">get_terminal_size</code><span class="sig-paren">(</span><em>fd=STDOUT_FILENO</em><span class="sig-paren">)</span><a class="headerlink" href="#os.get_terminal_size" title="정의 주소">¶</a></dt>
<dd><p>터미널 창의 크기를 <code class="docutils literal"><span class="pre">(columns,</span> <span class="pre">lines)</span></code> 로 반환하는데, <a class="reference internal" href="#os.terminal_size" title="os.terminal_size"><code class="xref py py-class docutils literal"><span class="pre">terminal_size</span></code></a> 형의 튜플입니다.</p>
<p>선택적 인자 <code class="docutils literal"><span class="pre">fd</span></code>(기본값 <code class="docutils literal"><span class="pre">STDOUT_FILENO</span></code>, 즉 표준 출력)는 조회할 파일 기술자를 지정합니다.</p>
<p>파일 기술자가 터미널에 연결되어 있지 않으면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>가 발생합니다.</p>
<p><a class="reference internal" href="shutil.html#shutil.get_terminal_size" title="shutil.get_terminal_size"><code class="xref py py-func docutils literal"><span class="pre">shutil.get_terminal_size()</span></code></a>가 일반적으로 사용해야 하는 고수준 함수이며, <code class="docutils literal"><span class="pre">os.get_terminal_size</span></code>는 저수준 구현입니다.</p>
<p>가용성: 유닉스, 윈도우.</p>
</dd></dl>

<dl class="class">
<dt id="os.terminal_size">
<em class="property">class </em><code class="descclassname">os.</code><code class="descname">terminal_size</code><a class="headerlink" href="#os.terminal_size" title="정의 주소">¶</a></dt>
<dd><p>터미널 창 크기 <code class="docutils literal"><span class="pre">(columns,</span> <span class="pre">lines)</span></code>를 저장하는 튜플의 서브 클래스.</p>
<dl class="attribute">
<dt id="os.terminal_size.columns">
<code class="descname">columns</code><a class="headerlink" href="#os.terminal_size.columns" title="정의 주소">¶</a></dt>
<dd><p>문자 단위의 터미널 창의 너비.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.terminal_size.lines">
<code class="descname">lines</code><a class="headerlink" href="#os.terminal_size.lines" title="정의 주소">¶</a></dt>
<dd><p>문자 단위의 터미널 창의 높이.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="inheritance-of-file-descriptors">
<span id="fd-inheritance"></span><h3>16.1.4.2. 파일 기술자의 상속<a class="headerlink" href="#inheritance-of-file-descriptors" title="제목 주소">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
<p>파일 기술자는 자식 프로세스가 파일 기술자를 상속받을 수 있는지를 나타내는 &quot;상속 가능&quot; 플래그를 가지고 있습니다. 파이썬 3.4부터, 파이썬에 의해 생성된 파일 기술자는 기본적으로 상속 불가능합니다.</p>
<p>유닉스에서는, 상속 불가능한 파일 기술자는 새 프로그램 실행 시 자식 프로세스에서 닫히고, 다른 파일 기술자는 상속됩니다.</p>
<p>윈도우에서는, 항상 상속되는 표준 스트림(파일 기술자 0, 1, 2: stdin, stdout, stderr)을 제외하고, 상속 불가능한 핸들 및 파일 기술자는 자식 프로세스에서 닫힙니다. <a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*</span></code></a> 함수를 사용하면, 상속 가능한 모든 핸들과 상속 가능한 모든 파일 기술자가 상속됩니다. <a class="reference internal" href="subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a> 모듈을 사용하면, 표준 스트림을 제외한 모든 파일 기술자가 닫히고, 상속 가능한 핸들은 <em>close_fds</em> 매개 변수가 <code class="docutils literal"><span class="pre">False</span></code> 일 때만 상속됩니다.</p>
<dl class="function">
<dt id="os.get_inheritable">
<code class="descclassname">os.</code><code class="descname">get_inheritable</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#os.get_inheritable" title="정의 주소">¶</a></dt>
<dd><p>지정된 파일 기술자의 &quot;상속 가능&quot; 플래그를 가져옵니다 (논릿값).</p>
</dd></dl>

<dl class="function">
<dt id="os.set_inheritable">
<code class="descclassname">os.</code><code class="descname">set_inheritable</code><span class="sig-paren">(</span><em>fd</em>, <em>inheritable</em><span class="sig-paren">)</span><a class="headerlink" href="#os.set_inheritable" title="정의 주소">¶</a></dt>
<dd><p>지정된 파일 기술자의 &quot;상속 가능(inheritable)&quot; 플래그를 설정합니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.get_handle_inheritable">
<code class="descclassname">os.</code><code class="descname">get_handle_inheritable</code><span class="sig-paren">(</span><em>handle</em><span class="sig-paren">)</span><a class="headerlink" href="#os.get_handle_inheritable" title="정의 주소">¶</a></dt>
<dd><p>지정된 핸들의 &quot;상속 가능&quot; 플래그를 가져옵니다 (논릿값).</p>
<p>가용성: 윈도우.</p>
</dd></dl>

<dl class="function">
<dt id="os.set_handle_inheritable">
<code class="descclassname">os.</code><code class="descname">set_handle_inheritable</code><span class="sig-paren">(</span><em>handle</em>, <em>inheritable</em><span class="sig-paren">)</span><a class="headerlink" href="#os.set_handle_inheritable" title="정의 주소">¶</a></dt>
<dd><p>지정된 핸들의 &quot;상속 가능(inheritable)&quot; 플래그를 설정합니다.</p>
<p>가용성: 윈도우.</p>
</dd></dl>

</div>
</div>
<div class="section" id="files-and-directories">
<span id="os-file-dir"></span><h2>16.1.5. 파일과 디렉터리<a class="headerlink" href="#files-and-directories" title="제목 주소">¶</a></h2>
<p>일부 유닉스 플랫폼에서, 이 함수 중 많은 것들이 다음 기능 중 하나 이상을 지원합니다:</p>
<ul id="path-fd">
<li><p class="first"><strong>파일 기술자 지정:</strong> 일부 함수의 경우, <em>path</em> 인자는 경로명을 제공하는 문자열뿐만 아니라 파일 기술자일 수도 있습니다. 그러면 그 함수는 기술자가 참조하는 파일에서 작동합니다. (POSIX 시스템에서, 파이썬은 함수의 <code class="docutils literal"><span class="pre">f...</span></code> 버전을 호출합니다.)</p>
<p><a class="reference internal" href="#os.supports_fd" title="os.supports_fd"><code class="xref py py-data docutils literal"><span class="pre">os.supports_fd</span></code></a>를 사용하여, 플랫폼에서 파일 기술자로 <em>path</em>를 지정할 수 있는지를 확인할 수 있습니다. 사용할 수 없을 때, 사용하면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>를 발생시킵니다.</p>
<p>함수가 <em>dir_fd</em> 나 <em>follow_symlinks</em> 인자도 지원하면, <em>path</em> 에 파일 기술자를 제공할 때, 이 중 하나를 지정하는 것은 에러입니다.</p>
</li>
</ul>
<ul id="dir-fd">
<li><p class="first"><strong>디렉터리 기술자에 상대적인 경로:</strong> <em>dir_fd</em> 가 <code class="docutils literal"><span class="pre">None</span></code>이 아니면, 디렉터리를 가리키는 파일 기술자여야 하며, 대상 경로는 상대 경로여야 합니다; 그러면 경로는 그 디렉터리에 상대적입니다. 절대 경로이면, <em>dir_fd</em> 는 무시됩니다. (POSIX 시스템에서, 파이썬은 함수의 <code class="docutils literal"><span class="pre">...at</span></code> 또는 <code class="docutils literal"><span class="pre">f...at</span></code> 버전을 호출합니다.)</p>
<p><a class="reference internal" href="#os.supports_dir_fd" title="os.supports_dir_fd"><code class="xref py py-data docutils literal"><span class="pre">os.supports_dir_fd</span></code></a>를 사용하여, 플랫폼에서 <em>dir_fd</em>가 지원되는지를 확인할 수 있습니다. 사용할 수 없을 때, 사용하면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>를 발생시킵니다.</p>
</li>
</ul>
<ul id="follow-symlinks">
<li><p class="first"><strong>심볼릭 링크를 따르지 않음:</strong> <em>follow_symlinks</em> 가 <code class="docutils literal"><span class="pre">False</span></code>고, 대상 경로의 마지막 요소가 심볼릭 링크면, 함수는 링크가 가리키는 파일 대신 심볼릭 링크 자체에 대해 작동합니다. (POSIX 시스템에서, 파이썬은 함수의 <code class="docutils literal"><span class="pre">l...</span></code> 버전을 호출합니다.)</p>
<p><a class="reference internal" href="#os.supports_follow_symlinks" title="os.supports_follow_symlinks"><code class="xref py py-data docutils literal"><span class="pre">os.supports_follow_symlinks</span></code></a>를 사용하여, 플랫폼에서 <em>follow_symlinks</em>가 지원되는지를 확인할 수 있습니다. 사용할 수 없을 때, 사용하면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>를 발생시킵니다.</p>
</li>
</ul>
<dl class="function">
<dt id="os.access">
<code class="descclassname">os.</code><code class="descname">access</code><span class="sig-paren">(</span><em>path</em>, <em>mode</em>, <em>*</em>, <em>dir_fd=None</em>, <em>effective_ids=False</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.access" title="정의 주소">¶</a></dt>
<dd><p>실제(real) uid/gid를 사용해서 <em>path</em>를 액세스할 수 있는지 검사합니다. 대부분의 연산은 유효한(effective) uid/gid를 사용할 것이므로, 이 함수는 suid/sgid 환경에서 호출하는 사용자가 지정된 <em>path</em> 에 대한 액세스 권한이 있는지 검사하는데 사용할 수 있습니다. <em>path</em>가 존재하는지를 검사하려면 <em>mode</em> 는 <a class="reference internal" href="#os.F_OK" title="os.F_OK"><code class="xref py py-const docutils literal"><span class="pre">F_OK</span></code></a> 여야 하며, 권한을 검사하려면 하나 이상의 <a class="reference internal" href="#os.R_OK" title="os.R_OK"><code class="xref py py-const docutils literal"><span class="pre">R_OK</span></code></a>, <a class="reference internal" href="#os.W_OK" title="os.W_OK"><code class="xref py py-const docutils literal"><span class="pre">W_OK</span></code></a> 및 <a class="reference internal" href="#os.X_OK" title="os.X_OK"><code class="xref py py-const docutils literal"><span class="pre">X_OK</span></code></a>를 OR 값일 수 있습니다. 액세스가 허용되면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>를 반환합니다. 더 자세한 정보는 유닉스 매뉴얼 페이지 <em class="manpage">access(2)</em>를 참조하십시오.</p>
<p>이 함수는 <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a> 와 <a class="reference internal" href="#follow-symlinks"><span class="std std-ref">심볼릭 링크를 따르지 않음</span></a>을 지원할 수 있습니다.</p>
<p><em>effective_ids</em> 가 <code class="docutils literal"><span class="pre">True</span></code>면, <a class="reference internal" href="#os.access" title="os.access"><code class="xref py py-func docutils literal"><span class="pre">access()</span></code></a>는 실제(real) uid/gid 대신 유효한(effective) uid/gid를 사용하여 액세스 검사를 수행합니다. <em>effective_ids</em> 는 플랫폼에서 지원되지 않을 수 있습니다; <a class="reference internal" href="#os.supports_effective_ids" title="os.supports_effective_ids"><code class="xref py py-data docutils literal"><span class="pre">os.supports_effective_ids</span></code></a>를 사용하여, 사용할 수 있는지를 확인할 수 있습니다. 사용할 수 없을 때, 사용하면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>를 발생시킵니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p>예를 들어, 실제로 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a>를 사용하여 파일을 열기 전에, <a class="reference internal" href="#os.access" title="os.access"><code class="xref py py-func docutils literal"><span class="pre">access()</span></code></a>를 사용하여 파일을 여는 권한이 있는지 확인하는 것은 보안 구멍을 만듭니다. 사용자가 파일을 확인하고 조작을 위해 열기 사이의 짧은 시간 간격을 악용할 수 있기 때문입니다. <a class="reference internal" href="../glossary.html#term-eafp"><span class="xref std std-term">EAFP</span></a> 기법을 사용하는 것이 좋습니다. 예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="s2">&quot;myfile&quot;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">R_OK</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;myfile&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="k">return</span> <span class="s2">&quot;some default data&quot;</span>
</pre></div>
</div>
<p>는 다음과 같이 쓰는 것이 더 좋습니다:</p>
<div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;myfile&quot;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">PermissionError</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">&quot;some default data&quot;</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">fp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><a class="reference internal" href="#os.access" title="os.access"><code class="xref py py-func docutils literal"><span class="pre">access()</span></code></a>가 성공할 것임을 알릴 때도, I/O 연산이 실패할 수 있습니다. 특히 일반적인 POSIX 권한 비트 모델을 넘어서는 권한 의미가 있을 수 있는 네트워크 파일 시스템에 대한 연산에서 그럴 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><em>dir_fd</em>, <em>effective_ids</em> 및 <em>follow_symlinks</em> 매개 변수를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.F_OK">
<code class="descclassname">os.</code><code class="descname">F_OK</code><a class="headerlink" href="#os.F_OK" title="정의 주소">¶</a></dt>
<dt id="os.R_OK">
<code class="descclassname">os.</code><code class="descname">R_OK</code><a class="headerlink" href="#os.R_OK" title="정의 주소">¶</a></dt>
<dt id="os.W_OK">
<code class="descclassname">os.</code><code class="descname">W_OK</code><a class="headerlink" href="#os.W_OK" title="정의 주소">¶</a></dt>
<dt id="os.X_OK">
<code class="descclassname">os.</code><code class="descname">X_OK</code><a class="headerlink" href="#os.X_OK" title="정의 주소">¶</a></dt>
<dd><p><em>path</em> 의 존재 여부, 읽기 가능성, 쓰기 가능성 및 실행 가능성을 검사하기 위해, <a class="reference internal" href="#os.access" title="os.access"><code class="xref py py-func docutils literal"><span class="pre">access()</span></code></a>의 <em>mode</em> 매개 변수로 전달할 값입니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.chdir">
<code class="descclassname">os.</code><code class="descname">chdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#os.chdir" title="정의 주소">¶</a></dt>
<dd><p id="index-18">현재 작업 디렉터리를 <em>path</em>로 변경합니다.</p>
<p>이 함수는 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자 지정</span></a>을 지원할 수 있습니다. 기술자는 열려있는 파일이 아니라, 열려있는 디렉터리를 참조해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span>일부 플랫폼에서 <em>path</em> 를 파일 기술자로 지정하는 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.chflags">
<code class="descclassname">os.</code><code class="descname">chflags</code><span class="sig-paren">(</span><em>path</em>, <em>flags</em>, <em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.chflags" title="정의 주소">¶</a></dt>
<dd><p><em>path</em> 의 플래그를 숫자 <em>flags</em>로 설정합니다. <em>flags</em>는 다음 값들(<a class="reference internal" href="stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal"><span class="pre">stat</span></code></a> 모듈에 정의 된 대로)의 조합(비트별 OR)을 취할 수 있습니다:</p>
<ul class="simple">
<li><a class="reference internal" href="stat.html#stat.UF_NODUMP" title="stat.UF_NODUMP"><code class="xref py py-data docutils literal"><span class="pre">stat.UF_NODUMP</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.UF_IMMUTABLE" title="stat.UF_IMMUTABLE"><code class="xref py py-data docutils literal"><span class="pre">stat.UF_IMMUTABLE</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.UF_APPEND" title="stat.UF_APPEND"><code class="xref py py-data docutils literal"><span class="pre">stat.UF_APPEND</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.UF_OPAQUE" title="stat.UF_OPAQUE"><code class="xref py py-data docutils literal"><span class="pre">stat.UF_OPAQUE</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.UF_NOUNLINK" title="stat.UF_NOUNLINK"><code class="xref py py-data docutils literal"><span class="pre">stat.UF_NOUNLINK</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.UF_COMPRESSED" title="stat.UF_COMPRESSED"><code class="xref py py-data docutils literal"><span class="pre">stat.UF_COMPRESSED</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.UF_HIDDEN" title="stat.UF_HIDDEN"><code class="xref py py-data docutils literal"><span class="pre">stat.UF_HIDDEN</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.SF_ARCHIVED" title="stat.SF_ARCHIVED"><code class="xref py py-data docutils literal"><span class="pre">stat.SF_ARCHIVED</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.SF_IMMUTABLE" title="stat.SF_IMMUTABLE"><code class="xref py py-data docutils literal"><span class="pre">stat.SF_IMMUTABLE</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.SF_APPEND" title="stat.SF_APPEND"><code class="xref py py-data docutils literal"><span class="pre">stat.SF_APPEND</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.SF_NOUNLINK" title="stat.SF_NOUNLINK"><code class="xref py py-data docutils literal"><span class="pre">stat.SF_NOUNLINK</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.SF_SNAPSHOT" title="stat.SF_SNAPSHOT"><code class="xref py py-data docutils literal"><span class="pre">stat.SF_SNAPSHOT</span></code></a></li>
</ul>
<p>이 함수는 <a class="reference internal" href="#follow-symlinks"><span class="std std-ref">심볼릭 링크를 따르지 않음</span></a>을 지원할 수 있습니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>follow_symlinks</em> 인자.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.chmod">
<code class="descclassname">os.</code><code class="descname">chmod</code><span class="sig-paren">(</span><em>path</em>, <em>mode</em>, <em>*</em>, <em>dir_fd=None</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.chmod" title="정의 주소">¶</a></dt>
<dd><p><em>path</em>의 모드를 숫자 <em>mode</em>로 변경합니다. <em>mode</em> 는 다음 값들(<a class="reference internal" href="stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal"><span class="pre">stat</span></code></a> 모듈에 정의 된 대로)이나 이들의 비트별 OR 조합을 취할 수 있습니다:</p>
<ul class="simple">
<li><a class="reference internal" href="stat.html#stat.S_ISUID" title="stat.S_ISUID"><code class="xref py py-data docutils literal"><span class="pre">stat.S_ISUID</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_ISGID" title="stat.S_ISGID"><code class="xref py py-data docutils literal"><span class="pre">stat.S_ISGID</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_ENFMT" title="stat.S_ENFMT"><code class="xref py py-data docutils literal"><span class="pre">stat.S_ENFMT</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_ISVTX" title="stat.S_ISVTX"><code class="xref py py-data docutils literal"><span class="pre">stat.S_ISVTX</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IREAD" title="stat.S_IREAD"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IREAD</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IWRITE" title="stat.S_IWRITE"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IWRITE</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IEXEC" title="stat.S_IEXEC"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IEXEC</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IRWXU" title="stat.S_IRWXU"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IRWXU</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IRUSR" title="stat.S_IRUSR"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IRUSR</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IWUSR" title="stat.S_IWUSR"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IWUSR</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IXUSR" title="stat.S_IXUSR"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IXUSR</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IRWXG" title="stat.S_IRWXG"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IRWXG</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IRGRP" title="stat.S_IRGRP"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IRGRP</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IWGRP" title="stat.S_IWGRP"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IWGRP</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IXGRP" title="stat.S_IXGRP"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IXGRP</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IRWXO" title="stat.S_IRWXO"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IRWXO</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IROTH" title="stat.S_IROTH"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IROTH</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IWOTH" title="stat.S_IWOTH"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IWOTH</span></code></a></li>
<li><a class="reference internal" href="stat.html#stat.S_IXOTH" title="stat.S_IXOTH"><code class="xref py py-data docutils literal"><span class="pre">stat.S_IXOTH</span></code></a></li>
</ul>
<p>이 함수는 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자 지정</span></a>, <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a> 및 <a class="reference internal" href="#follow-symlinks"><span class="std std-ref">심볼릭 링크를 따르지 않음</span></a>을 지원할 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">윈도우가 <a class="reference internal" href="#os.chmod" title="os.chmod"><code class="xref py py-func docutils literal"><span class="pre">chmod()</span></code></a>를 지원하더라도, (<code class="docutils literal"><span class="pre">stat.S_IWRITE</span></code> 와 <code class="docutils literal"><span class="pre">stat.S_IREAD</span></code> 상수나 해당 정숫값을 통해) 파일의 읽기 전용 플래그만 설정할 수 있습니다. 다른 모든 비트는 무시됩니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>path</em>를 열린 파일 기술자로 지정하는 지원과 <em>dir_fd</em> 및 <em>follow_symlinks</em> 인자가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.chown">
<code class="descclassname">os.</code><code class="descname">chown</code><span class="sig-paren">(</span><em>path</em>, <em>uid</em>, <em>gid</em>, <em>*</em>, <em>dir_fd=None</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.chown" title="정의 주소">¶</a></dt>
<dd><p><em>path</em> 의 소유자와 그룹 ID를 숫자 <em>uid</em> 와 <em>gid</em>로 변경합니다. ID 중 하나를 변경하지 않으려면, 그것을 -1로 설정하십시오.</p>
<p>이 함수는 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자 지정</span></a>, <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a> 및 <a class="reference internal" href="#follow-symlinks"><span class="std std-ref">심볼릭 링크를 따르지 않음</span></a>을 지원할 수 있습니다.</p>
<p>숫자 ID 이외에 이름을 허용하는 고수준 함수는 <a class="reference internal" href="shutil.html#shutil.chown" title="shutil.chown"><code class="xref py py-func docutils literal"><span class="pre">shutil.chown()</span></code></a>를 참조하십시오.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>path</em> 에 열린 파일 기술자를 지정하는 것과 <em>dir_fd</em> 및 <em>follow_symlinks</em> 인자에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 지원합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.chroot">
<code class="descclassname">os.</code><code class="descname">chroot</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#os.chroot" title="정의 주소">¶</a></dt>
<dd><p>현재 프로세스의 루트 디렉터리를 <em>path</em>로 변경합니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.fchdir">
<code class="descclassname">os.</code><code class="descname">fchdir</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#os.fchdir" title="정의 주소">¶</a></dt>
<dd><p>현재 작업 디렉터리를 파일 기술자 <em>fd</em>가 나타내는 디렉터리로 변경합니다. 기술자는 열려있는 파일이 아니라 열려있는 디렉터리를 참조해야 합니다. 파이썬 3.3부터는, <code class="docutils literal"><span class="pre">os.chdir(fd)</span></code>와 같습니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.getcwd">
<code class="descclassname">os.</code><code class="descname">getcwd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.getcwd" title="정의 주소">¶</a></dt>
<dd><p>현재 작업 디렉터리를 나타내는 문자열을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.getcwdb">
<code class="descclassname">os.</code><code class="descname">getcwdb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.getcwdb" title="정의 주소">¶</a></dt>
<dd><p>현재 작업 디렉터리를 나타내는 바이트열을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.lchflags">
<code class="descclassname">os.</code><code class="descname">lchflags</code><span class="sig-paren">(</span><em>path</em>, <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#os.lchflags" title="정의 주소">¶</a></dt>
<dd><p><em>path</em> 의 플래그를, <a class="reference internal" href="#os.chflags" title="os.chflags"><code class="xref py py-func docutils literal"><span class="pre">chflags()</span></code></a> 처럼, 숫자 <em>flags</em>로 설정하지만, 심볼릭 링크를 따르지 않습니다. 파이썬 3.3부터는, <code class="docutils literal"><span class="pre">os.chflags(path,</span> <span class="pre">flags,</span> <span class="pre">follow_symlinks=False)</span></code>와 같습니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.lchmod">
<code class="descclassname">os.</code><code class="descname">lchmod</code><span class="sig-paren">(</span><em>path</em>, <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#os.lchmod" title="정의 주소">¶</a></dt>
<dd><p><em>path</em> 모드를 숫자 <em>mode</em>로 변경합니다. path가 심볼릭 링크면, 이 함수는 타깃이 아닌 심볼릭 링크에 영향을 미칩니다. <em>mode</em>의 가능한 값은 <a class="reference internal" href="#os.chmod" title="os.chmod"><code class="xref py py-func docutils literal"><span class="pre">chmod()</span></code></a> 문서를 참조하십시오. 파이썬 3.3부터는, <code class="docutils literal"><span class="pre">os.chmod(path,</span> <span class="pre">mode,</span> <span class="pre">follow_symlinks=False)</span></code>와 같습니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.lchown">
<code class="descclassname">os.</code><code class="descname">lchown</code><span class="sig-paren">(</span><em>path</em>, <em>uid</em>, <em>gid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.lchown" title="정의 주소">¶</a></dt>
<dd><p><em>path</em> 의 소유자와 그룹 ID를 숫자 <em>uid</em> 와 <em>gid</em>로 변경합니다. 이 함수는 심볼릭 링크를 따르지 않습니다. 파이썬 3.3부터는, <code class="docutils literal"><span class="pre">os.chown(path,</span> <span class="pre">uid,</span> <span class="pre">gid,</span> <span class="pre">follow_symlinks=False)</span></code>와 같습니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.link">
<code class="descclassname">os.</code><code class="descname">link</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em>, <em>*</em>, <em>src_dir_fd=None</em>, <em>dst_dir_fd=None</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.link" title="정의 주소">¶</a></dt>
<dd><p><em>src</em>를 가리키는 <em>dst</em> 라는 이름의 하드 링크를 만듭니다.</p>
<p>이 함수는 <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a>를 제공하기 위해 <em>src_dir_fd</em> 와/나 <em>dst_dir_fd</em> 를 지정하는 것과, <a class="reference internal" href="#follow-symlinks"><span class="std std-ref">심볼릭 링크를 따르지 않음</span></a>을 지원할 수 있습니다.</p>
<p>가용성: 유닉스, 윈도우.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>윈도우 지원이 추가되었습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>src_dir_fd</em> , <em>dst_dir_fd</em> 및 <em>follow_symlinks</em> 인자를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><em>src</em> 및 <em>dst</em>로 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.listdir">
<code class="descclassname">os.</code><code class="descname">listdir</code><span class="sig-paren">(</span><em>path='.'</em><span class="sig-paren">)</span><a class="headerlink" href="#os.listdir" title="정의 주소">¶</a></dt>
<dd><p><em>path</em>에 의해 주어진 디렉터리에 있는 항목들의 이름을 담고 있는 리스트를 반환합니다. 리스트는 임의의 순서로 나열되며, 디렉터리에 존재하더라도 특수 항목 <code class="docutils literal"><span class="pre">'.'</span></code> 과 <code class="docutils literal"><span class="pre">'..'</span></code>는 포함하지 않습니다.</p>
<p><em>path</em>는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a> 일 수 있습니다. <em>path</em> 가 <code class="docutils literal"><span class="pre">bytes</span></code> 형이면 (직접 또는 <a class="reference internal" href="#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal"><span class="pre">PathLike</span></code></a> 인터페이스를 통해 간접적으로), 반환되는 파일명도 <code class="docutils literal"><span class="pre">bytes</span></code> 형입니다; 다른 모든 상황에서는 형 <code class="docutils literal"><span class="pre">str</span></code>이 됩니다.</p>
<p>이 함수는 또한 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자 지정</span></a>을 지원할 수 있습니다; 파일 기술자는 디렉터리를 참조해야 합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><code class="docutils literal"><span class="pre">str</span></code> 파일명을 <code class="docutils literal"><span class="pre">bytes</span></code>로 인코딩하려면, <a class="reference internal" href="#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal"><span class="pre">fsencode()</span></code></a>를 사용하십시오.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> 함수는 파일 어트리뷰트 정보와 함께 디렉터리 항목을 반환하므로, 많은 일반적인 사용 사례에서 더 나은 성능을 제공합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><em>path</em> 매개 변수는 선택 사항이 되었습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>path</em>에 열린 파일 기술자를 지정하는 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.lstat">
<code class="descclassname">os.</code><code class="descname">lstat</code><span class="sig-paren">(</span><em>path</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.lstat" title="정의 주소">¶</a></dt>
<dd><p>주어진 경로에 대해 <code class="xref c c-func docutils literal"><span class="pre">lstat()</span></code> 시스템 호출과 동등한 작업을 수행합니다. <a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a>와 유사하지만, 심볼릭 링크를 따르지 않습니다. <a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a> 객체를 반환합니다.</p>
<p>심볼릭 링크를 지원하지 않는 플랫폼에서, 이 함수는 <a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a>의 별칭입니다.</p>
<p>파이썬 3.3부터는, <code class="docutils literal"><span class="pre">os.stat(path,</span> <span class="pre">dir_fd=dir_fd,</span> <span class="pre">follow_symlinks=False)</span></code>와 같습니다.</p>
<p>이 기능은 <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a>도 지원할 수 있습니다.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a> 함수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>윈도우 6.0 (Vista) 심볼릭 링크에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><em>dir_fd</em> 매개 변수가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><em>src</em> 및 <em>dst</em>로 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.mkdir">
<code class="descclassname">os.</code><code class="descname">mkdir</code><span class="sig-paren">(</span><em>path</em>, <em>mode=0o777</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.mkdir" title="정의 주소">¶</a></dt>
<dd><p>숫자 모드 <em>mode</em>로 <em>path</em> 라는 디렉터리를 만듭니다.</p>
<p>디렉터리가 이미 존재하면, <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal"><span class="pre">FileExistsError</span></code></a>가 발생합니다.</p>
<p id="mkdir-modebits">일부 시스템에서는, <em>mode</em>가 무시됩니다. 모드가 사용될 때, 현재 umask 값으로 먼저 마스킹합니다. 마지막 9 비트 (즉, <em>mode</em> 의 8진 표현의 마지막 3자리 수) 이외의 비트가 설정되면, 그 의미는 플랫폼에 따라 다릅니다. 일부 플랫폼에서는, 이것들이 무시되며, 설정하려면 명시적으로 <a class="reference internal" href="#os.chmod" title="os.chmod"><code class="xref py py-func docutils literal"><span class="pre">chmod()</span></code></a>를 호출해야 합니다.</p>
<p>이 기능은 <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a>도 지원할 수 있습니다.</p>
<p>임시 디렉터리를 만들 수도 있습니다; <a class="reference internal" href="tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal"><span class="pre">tempfile</span></code></a> 모듈의 <a class="reference internal" href="tempfile.html#tempfile.mkdtemp" title="tempfile.mkdtemp"><code class="xref py py-func docutils literal"><span class="pre">tempfile.mkdtemp()</span></code></a> 함수를 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>dir_fd</em> 인자</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.makedirs">
<code class="descclassname">os.</code><code class="descname">makedirs</code><span class="sig-paren">(</span><em>name</em>, <em>mode=0o777</em>, <em>exist_ok=False</em><span class="sig-paren">)</span><a class="headerlink" href="#os.makedirs" title="정의 주소">¶</a></dt>
<dd><p id="index-19">재귀적 디렉터리 생성 함수. <a class="reference internal" href="#os.mkdir" title="os.mkdir"><code class="xref py py-func docutils literal"><span class="pre">mkdir()</span></code></a>와 비슷하지만, 말단 디렉터리를 포함하는 데 필요한 모든 중간 수준 디렉터리들을 만듭니다.</p>
<p><em>mode</em> 매개 변수는 말단 디렉터리를 만들기 위해 <a class="reference internal" href="#os.mkdir" title="os.mkdir"><code class="xref py py-func docutils literal"><span class="pre">mkdir()</span></code></a>로 전달됩니다; 이것이 어떻게 해석되는지는 <a class="reference internal" href="#mkdir-modebits"><span class="std std-ref">mkdir() 설명</span></a>을 보십시오. 새로 만들어지는 부모 디렉터리들의 파일 권한 비트를 설정하려면, <a class="reference internal" href="#os.makedirs" title="os.makedirs"><code class="xref py py-func docutils literal"><span class="pre">makedirs()</span></code></a>를 호출하기 전에 umask를 설정할 수 있습니다. 이미 존재하는 부모 디렉터리의 파일 권한 비트는 변경되지 않습니다.</p>
<p><em>exist_ok</em> 가 <code class="docutils literal"><span class="pre">False</span></code>(기본값)면, 대상 디렉터리가 이미 있을 때 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>가 발생합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><a class="reference internal" href="#os.makedirs" title="os.makedirs"><code class="xref py py-func docutils literal"><span class="pre">makedirs()</span></code></a>는 생성할 경로 요소에 <a class="reference internal" href="#os.pardir" title="os.pardir"><code class="xref py py-data docutils literal"><span class="pre">pardir</span></code></a>(예를 들어, 유닉스 시스템의 경우 &quot;..&quot;)이 포함되어 있으면 혼란해할 수 있습니다.</p>
</div>
<p>이 함수는 UNC 경로를 올바르게 처리합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span><em>exist_ok</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4.1으로 변경: </span>파이썬 3.4.1 이전에는, <em>exist_ok</em> 가 <code class="docutils literal"><span class="pre">True</span></code>이고 디렉터리가 존재한다면, <em>mode</em> 가 기존 디렉터리의 모드와 일치하지 않을 때, <a class="reference internal" href="#os.makedirs" title="os.makedirs"><code class="xref py py-func docutils literal"><span class="pre">makedirs()</span></code></a>는 여전히 에러를 발생시킵니다. 이 동작은 안전하게 구현할 수 없으므로, 파이썬 3.4.1에서 제거되었습니다. <a class="reference external" href="https://bugs.python.org/issue21082">bpo-21082</a>를 참조하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>mode</em> 인자는 더는 새로 만들어지는 중간 수준 디렉터리의 파일 권한 비트에 영향을 주지 않습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.mkfifo">
<code class="descclassname">os.</code><code class="descname">mkfifo</code><span class="sig-paren">(</span><em>path</em>, <em>mode=0o666</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.mkfifo" title="정의 주소">¶</a></dt>
<dd><p>숫자 모드 <em>mode</em>로 <em>path</em> 라는 이름의 FIFO(이름있는 파이프)를 만듭니다. 현재 umask 값으로 먼저 모드를 마스킹합니다.</p>
<p>이 기능은 <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a>도 지원할 수 있습니다.</p>
<p>FIFO는 일반 파일처럼 액세스할 수 있는 파이프입니다. FIFO는 삭제 될 때까지 존재합니다 (예를 들어 <a class="reference internal" href="#os.unlink" title="os.unlink"><code class="xref py py-func docutils literal"><span class="pre">os.unlink()</span></code></a>로). 일반적으로, FIFO는 &quot;클라이언트&quot;와 &quot;서버&quot; 유형 프로세스 사이에서 랑데부로 사용됩니다: 서버는 FIFO를 읽기 용으로로 열고, 클라이언트는 쓰기 용으로 엽니다. <a class="reference internal" href="#os.mkfifo" title="os.mkfifo"><code class="xref py py-func docutils literal"><span class="pre">mkfifo()</span></code></a>가 FIFO를 열지는 않는다는 점에 유의하십시오 --- 단지 랑데부 포인트를 생성합니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>dir_fd</em> 인자</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.mknod">
<code class="descclassname">os.</code><code class="descname">mknod</code><span class="sig-paren">(</span><em>path</em>, <em>mode=0o600</em>, <em>device=0</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.mknod" title="정의 주소">¶</a></dt>
<dd><p><em>path</em> 라는 이름의 파일 시스템 노드(파일, 장치 특수 파일 또는 이름있는 파이프)를 만듭니다. <em>mode</em> 는 사용 권한과 생성 될 노드의 유형을 모두 지정하며, <code class="docutils literal"><span class="pre">stat.S_IFREG</span></code>, <code class="docutils literal"><span class="pre">stat.S_IFCHR</span></code>, <code class="docutils literal"><span class="pre">stat.S_IFBLK</span></code> 및 <code class="docutils literal"><span class="pre">stat.S_IFIFO</span></code> 중 하나와 결합(비트별 OR)됩니다 (이 상수들은 <a class="reference internal" href="stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal"><span class="pre">stat</span></code></a>에 있습니다). <code class="docutils literal"><span class="pre">stat.S_IFCHR</span></code>와 <code class="docutils literal"><span class="pre">stat.S_IFBLK</span></code>의 경우, <em>device</em> 는 새로 만들어지는 장치 특수 파일(아마도 <a class="reference internal" href="#os.makedev" title="os.makedev"><code class="xref py py-func docutils literal"><span class="pre">os.makedev()</span></code></a>를 사용해서)을 정의합니다, 그렇지 않으면 무시됩니다.</p>
<p>이 기능은 <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a>도 지원할 수 있습니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>dir_fd</em> 인자</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.major">
<code class="descclassname">os.</code><code class="descname">major</code><span class="sig-paren">(</span><em>device</em><span class="sig-paren">)</span><a class="headerlink" href="#os.major" title="정의 주소">¶</a></dt>
<dd><p>원시 장치 번호(보통 <code class="xref c c-type docutils literal"><span class="pre">stat</span></code>의 <code class="xref py py-attr docutils literal"><span class="pre">st_dev</span></code> 이나 <code class="xref py py-attr docutils literal"><span class="pre">st_rdev</span></code> 어트리뷰트)에서 장치 주 번호를 추출합니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.minor">
<code class="descclassname">os.</code><code class="descname">minor</code><span class="sig-paren">(</span><em>device</em><span class="sig-paren">)</span><a class="headerlink" href="#os.minor" title="정의 주소">¶</a></dt>
<dd><p>원시 장치 번호(보통 <code class="xref c c-type docutils literal"><span class="pre">stat</span></code>의 <code class="xref py py-attr docutils literal"><span class="pre">st_dev</span></code> 이나 <code class="xref py py-attr docutils literal"><span class="pre">st_rdev</span></code> 어트리뷰트)에서 장치 부 번호를 추출합니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.makedev">
<code class="descclassname">os.</code><code class="descname">makedev</code><span class="sig-paren">(</span><em>major</em>, <em>minor</em><span class="sig-paren">)</span><a class="headerlink" href="#os.makedev" title="정의 주소">¶</a></dt>
<dd><p>주 장치 번호와 부 장치 번호로 원시 장치 번호를 조립합니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.pathconf">
<code class="descclassname">os.</code><code class="descname">pathconf</code><span class="sig-paren">(</span><em>path</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#os.pathconf" title="정의 주소">¶</a></dt>
<dd><p>이름있는 파일과 관련된 시스템 구성 정보를 반환합니다. <em>name</em> 은 조회할 구성 값을 지정합니다; 정의된 시스템 값의 이름인 문자열일 수 있습니다; 이 이름은 여러 표준(POSIX.1, 유닉스 95, 유닉스 98 및 기타)에서 지정됩니다. 일부 플랫폼은 추가적인 이름도 정의합니다. 호스트 운영 체제에 알려진 이름은 <code class="docutils literal"><span class="pre">pathconf_names</span></code> 딕셔너리에서 제공됩니다. 이 매핑에 포함되지 않은 구성 변수를 위해, <em>name</em>에 정수를 전달하는 것도 허용됩니다.</p>
<p><em>name</em> 이 문자열이고 알 수 없으면, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>가 발생합니다. <em>name</em>에 대한 특정 값이 호스트 시스템에서 지원되지 않으면, <code class="docutils literal"><span class="pre">pathconf_names</span></code>에 포함되어 있어도, 에러 번호가 <a class="reference internal" href="errno.html#errno.EINVAL" title="errno.EINVAL"><code class="xref py py-const docutils literal"><span class="pre">errno.EINVAL</span></code></a>인 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>가 발생합니다.</p>
<p>이 함수는 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자 지정</span></a>을 지원할 수 있습니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.pathconf_names">
<code class="descclassname">os.</code><code class="descname">pathconf_names</code><a class="headerlink" href="#os.pathconf_names" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.pathconf" title="os.pathconf"><code class="xref py py-func docutils literal"><span class="pre">pathconf()</span></code></a> 와 <a class="reference internal" href="#os.fpathconf" title="os.fpathconf"><code class="xref py py-func docutils literal"><span class="pre">fpathconf()</span></code></a>가 받아들이는 이름을 호스트 운영 체제에서 해당 이름에 대해 정의 된 정수 값으로 매핑하는 딕셔너리. 이것은 시스템에 알려진 이름 집합을 판별하는 데 사용될 수 있습니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.readlink">
<code class="descclassname">os.</code><code class="descname">readlink</code><span class="sig-paren">(</span><em>path</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.readlink" title="정의 주소">¶</a></dt>
<dd><p>심볼릭 링크가 가리키는 경로를 나타내는 문자열을 반환합니다. 결과는 절대 또는 상대 경로명 일 수 있습니다; 상대 경로이면 <code class="docutils literal"><span class="pre">os.path.join(os.path.dirname(path),</span> <span class="pre">result)</span></code>를 사용하여 절대 경로명으로 변환할 수 있습니다.</p>
<p><em>path</em> 가 (직접적으로 또는 <a class="reference internal" href="#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal"><span class="pre">PathLike</span></code></a> 인터페이스를 통해 간접적으로) 문자열 객체면, 결과도 문자열 객체가되고, 호출은 UnicodeDecodeError를 발생시킬 수 있습니다. <em>path</em> 가 (직접 또는 간접적으로) 바이트열 객체면, 결과는 바이트열 객체가됩니다.</p>
<p>이 기능은 <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a>도 지원할 수 있습니다.</p>
<p>가용성: 유닉스, 윈도우</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>윈도우 6.0 (Vista) 심볼릭 링크에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>dir_fd</em> 인자</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.remove">
<code class="descclassname">os.</code><code class="descname">remove</code><span class="sig-paren">(</span><em>path</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.remove" title="정의 주소">¶</a></dt>
<dd><p>파일 <em>path</em>를 제거(삭제)합니다. <em>path</em> 가 디렉터리면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>가 발생합니다. 디렉터리를 제거하려면 <a class="reference internal" href="#os.rmdir" title="os.rmdir"><code class="xref py py-func docutils literal"><span class="pre">rmdir()</span></code></a>를 사용하십시오.</p>
<p>이 함수는 <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a>를 지원할 수 있습니다.</p>
<p>윈도우에서, 사용중인 파일을 제거하려고 시도하면 예외가 발생합니다; 유닉스에서는 디렉터리 항목이 제거되지만 원본 파일이 더 이상 사용되지 않을 때까지 파일에 할당된 저장 공간을 사용할 수 없습니다.</p>
<p>이 함수는 의미 적으로 <a class="reference internal" href="#os.unlink" title="os.unlink"><code class="xref py py-func docutils literal"><span class="pre">unlink()</span></code></a>와 같습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>dir_fd</em> 인자</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.removedirs">
<code class="descclassname">os.</code><code class="descname">removedirs</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#os.removedirs" title="정의 주소">¶</a></dt>
<dd><p id="index-20">재귀적으로 디렉터리를 제거합니다. <a class="reference internal" href="#os.rmdir" title="os.rmdir"><code class="xref py py-func docutils literal"><span class="pre">rmdir()</span></code></a> 처럼 동작하는데 다음과 같은 차이가 있습니다. 말단 디렉터리가 성공적으로 제거되면, <a class="reference internal" href="#os.removedirs" title="os.removedirs"><code class="xref py py-func docutils literal"><span class="pre">removedirs()</span></code></a>는 에러가 발생할 때까지 <em>path</em>에 언급된 모든 상위 디렉터리를 연속적으로 제거하려고합니다 (에러는 무시되는데, 이는 일반적으로 부모 디렉터리가 비어 있음을 뜻하기 때문입니다). 예를 들어, <code class="docutils literal"><span class="pre">os.removedirs('foo/bar/baz')</span></code>는 먼저 <code class="docutils literal"><span class="pre">'foo/bar/baz'</span></code> 디렉터리를 제거한 다음, <code class="docutils literal"><span class="pre">'foo/bar'</span></code> 및 <code class="docutils literal"><span class="pre">'foo'</span></code>가 비어 있으면 제거합니다. 말단 디렉터리를 성공적으로 제거 할 수 없으면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.rename">
<code class="descclassname">os.</code><code class="descname">rename</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em>, <em>*</em>, <em>src_dir_fd=None</em>, <em>dst_dir_fd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.rename" title="정의 주소">¶</a></dt>
<dd><p>파일 또는 디렉터리 <em>src</em>의 이름을 <em>dst</em>로 바꿉니다. <em>dst</em> 가 디렉터리면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>가 발생합니다. 유닉스에서는, <em>dst</em> 가 존재하고 파일이면, 사용자에게 권한이 있을 때 자동으로 대체됩니다. <em>src</em> 와 <em>dst</em> 가 다른 파일 시스템에 있을 때, 일부 유닉스 환경에서 작업이 실패 할 수 있습니다. 성공하면, 이름 바꾸기는 원자적 연산이됩니다 (이것은 POSIX 요구 사항입니다). 윈도우에서 <em>dst</em>가 이미 존재하면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>는 파일일 때도 발생합니다.</p>
<p>이 함수는 <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a>를 제공하도록 <em>src_dir_fd</em> 와/나 <em>dst_dir_fd</em> 를 지정하는 것을 지원할 수 있습니다.</p>
<p>플랫폼에 무관하게 대상을 덮어 쓰길 원하면, <a class="reference internal" href="#os.replace" title="os.replace"><code class="xref py py-func docutils literal"><span class="pre">replace()</span></code></a>를 사용하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>src_dir_fd</em> 및 <em>dst_dir_fd</em> 인자</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><em>src</em> 및 <em>dst</em>로 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.renames">
<code class="descclassname">os.</code><code class="descname">renames</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="sig-paren">)</span><a class="headerlink" href="#os.renames" title="정의 주소">¶</a></dt>
<dd><p>재귀적 디렉터리 또는 파일 이름 바꾸기 함수. <a class="reference internal" href="#os.rename" title="os.rename"><code class="xref py py-func docutils literal"><span class="pre">rename()</span></code></a> 처럼 작동하지만, 새 경로명이 유효하도록 만들기 위해 먼저 필요한 중간 디렉터리를 만드는 점이 다릅니다. 이름을 변경한 후에는, 이전 이름의 가장 오른쪽 경로 세그먼트에 해당하는 디렉터리를 <a class="reference internal" href="#os.removedirs" title="os.removedirs"><code class="xref py py-func docutils literal"><span class="pre">removedirs()</span></code></a>를 사용하여 제거합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 함수는 말단 디렉터리나 파일을 제거하는 데 필요한 권한이 없을 때, 새 디렉터리 구조를 만든 상태에서 실패 할 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><em>old</em> 와 <em>new</em> 에 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.replace">
<code class="descclassname">os.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em>, <em>*</em>, <em>src_dir_fd=None</em>, <em>dst_dir_fd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.replace" title="정의 주소">¶</a></dt>
<dd><p>파일 또는 디렉터리 <em>src</em>의 이름을 <em>dst</em>로 바꿉니다. <em>dst</em> 가 디렉터리면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>가 발생합니다. <em>dst</em> 가 존재하고 파일이면, 사용자에게 권한이 있을 때 자동으로 대체됩니다. <em>src</em> 와 <em>dst</em> 가 다른 파일 시스템에 있으면, 작업이 실패 할 수 있습니다. 성공하면, 이름 바꾸기는 원자적 연산이 됩니다 (이것은 POSIX 요구 사항입니다).</p>
<p>이 함수는 <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a>를 제공하도록 <em>src_dir_fd</em> 와/나 <em>dst_dir_fd</em> 를 지정하는 것을 지원할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><em>src</em> 및 <em>dst</em>로 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.rmdir">
<code class="descclassname">os.</code><code class="descname">rmdir</code><span class="sig-paren">(</span><em>path</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.rmdir" title="정의 주소">¶</a></dt>
<dd><p>디렉터리 <em>path</em>를 제거(삭제)합니다. 디렉터리가 비어있을 때만 작동하고, 그렇지 않으면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>가 발생합니다. 전체 디렉터리 트리를 제거하려면, <a class="reference internal" href="shutil.html#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal"><span class="pre">shutil.rmtree()</span></code></a>를 사용할 수 있습니다.</p>
<p>이 함수는 <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a>를 지원할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>dir_fd</em> 매개 변수</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.scandir">
<code class="descclassname">os.</code><code class="descname">scandir</code><span class="sig-paren">(</span><em>path='.'</em><span class="sig-paren">)</span><a class="headerlink" href="#os.scandir" title="정의 주소">¶</a></dt>
<dd><p><em>path</em>로 지정된 디렉터리 내의 항목에 대응하는 <a class="reference internal" href="#os.DirEntry" title="os.DirEntry"><code class="xref py py-class docutils literal"><span class="pre">os.DirEntry</span></code></a> 객체의 이터레이터를 돌려줍니다. 항목은 임의의 순서로 제공되며, 특수 항목 <code class="docutils literal"><span class="pre">'.'</span></code> 및 <code class="docutils literal"><span class="pre">'..'</span></code>는 포함되지 않습니다.</p>
<p><a class="reference internal" href="#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal"><span class="pre">listdir()</span></code></a> 대신 <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a>를 사용하면, 디렉터리를 검색 할 때 운영 체제가 제공한다면 <a class="reference internal" href="#os.DirEntry" title="os.DirEntry"><code class="xref py py-class docutils literal"><span class="pre">os.DirEntry</span></code></a> 객체가 파일 유형과 파일 어트리뷰트 정보를 제공하기 때문에, 이 것들이 필요한 코드의 성능을 크게 향상시킬 수 있습니다. 모든 <a class="reference internal" href="#os.DirEntry" title="os.DirEntry"><code class="xref py py-class docutils literal"><span class="pre">os.DirEntry</span></code></a> 메서드가 시스템 호출을 수행 할 수 있지만, 일반적으로 <a class="reference internal" href="#os.DirEntry.is_dir" title="os.DirEntry.is_dir"><code class="xref py py-func docutils literal"><span class="pre">is_dir()</span></code></a> 및 <a class="reference internal" href="#os.DirEntry.is_file" title="os.DirEntry.is_file"><code class="xref py py-func docutils literal"><span class="pre">is_file()</span></code></a>는 심볼릭 링크에 대해서만 시스템 호출을 필요로합니다; <a class="reference internal" href="#os.DirEntry.stat" title="os.DirEntry.stat"><code class="xref py py-func docutils literal"><span class="pre">os.DirEntry.stat()</span></code></a>는 유닉스에서 항상 시스템 호출을 요구하지만 윈도우에서는 심볼릭 링크에 대해서만 시스템 호출을 요구합니다.</p>
<p><em>path</em> 는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a> 일 수 있습니다. <em>path</em> 가 (직접적으로 또는 <a class="reference internal" href="#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal"><span class="pre">PathLike</span></code></a> 인터페이스를 통해 간접적으로) <code class="docutils literal"><span class="pre">bytes</span></code> 형이면, 각 <a class="reference internal" href="#os.DirEntry" title="os.DirEntry"><code class="xref py py-class docutils literal"><span class="pre">os.DirEntry</span></code></a>의 <a class="reference internal" href="#os.DirEntry.name" title="os.DirEntry.name"><code class="xref py py-attr docutils literal"><span class="pre">name</span></code></a> 및 <a class="reference internal" href="#os.DirEntry.path" title="os.DirEntry.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a> 어트리뷰트의 형은 <code class="docutils literal"><span class="pre">bytes</span></code>입니다. 다른 모든 상황에서는 형 <code class="docutils literal"><span class="pre">str</span></code>이 됩니다.</p>
<p>이 함수는 또한 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자 지정</span></a>을 지원할 수 있습니다; 파일 기술자는 디렉터리를 참조해야 합니다.</p>
<p><a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> 이터레이터는 <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">컨텍스트 관리자</span></a> 프로토콜을 지원하고 다음과 같은 메서드를 제공합니다:</p>
<dl class="method">
<dt id="os.scandir.close">
<code class="descclassname">scandir.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.scandir.close" title="정의 주소">¶</a></dt>
<dd><p>이터레이터를 닫고 확보한 자원을 반납합니다.</p>
<p>이터레이터가 소진되거나 가비지 수집될 때 또는 이터레이션 중에 에러가 발생하면 자동으로 호출됩니다. 하지만 명시적으로 호출하거나 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 문을 사용하는 것이 좋습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<p>다음 예제는 주어진 <em>path</em>의 <code class="docutils literal"><span class="pre">'.'</span></code>로 시작하지 않는 모든 파일(디렉터리 제외)을 표시하기위한 <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a>의 간단한 사용을 보여줍니다. <code class="docutils literal"><span class="pre">entry.is_file()</span></code> 호출은 일반적으로 추가 시스템 호출을 하지 않습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">os</span><span class="o">.</span><span class="n">scandir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">it</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">entry</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">entry</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">유닉스 기반 시스템에서, <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a>은 시스템의 <a class="reference external" href="http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html">opendir()</a> 과 <a class="reference external" href="http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html">readdir()</a> 함수를 사용합니다. 윈도우에서는, Win32 <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418(v=vs.85).aspx">FindFirstFileW</a> 와 <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364428(v=vs.85).aspx">FindNextFileW</a> 함수를 사용합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가: </span><a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">컨텍스트 관리자</span></a> 프로토콜과 <a class="reference internal" href="#os.scandir.close" title="os.scandir.close"><code class="xref py py-func docutils literal"><span class="pre">close()</span></code></a> 메서드 대한 지원이 추가되었습니다. <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> 이터레이터가 모두 소진되거나 명시적으로 닫히지 않으면 <a class="reference internal" href="exceptions.html#ResourceWarning" title="ResourceWarning"><code class="xref py py-exc docutils literal"><span class="pre">ResourceWarning</span></code></a>가 파괴자에서 방출됩니다.</p>
<p>이 함수는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>유닉스에서 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자</span></a>에 대한 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="os.DirEntry">
<em class="property">class </em><code class="descclassname">os.</code><code class="descname">DirEntry</code><a class="headerlink" href="#os.DirEntry" title="정의 주소">¶</a></dt>
<dd><p>디렉터리 항목의 파일 경로와 다른 파일 어트리뷰트를 노출하기 위해 <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a>에 의해 산출되는 객체.</p>
<p><a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a>는 추가 시스템 호출 없이 가능한 많은 정보를 제공합니다. <code class="docutils literal"><span class="pre">stat()</span></code> 또는 <code class="docutils literal"><span class="pre">lstat()</span></code> 시스템 호출이 이루어지면, <code class="docutils literal"><span class="pre">os.DirEntry</span></code> 객체는 결과를 캐시합니다.</p>
<p><code class="docutils literal"><span class="pre">os.DirEntry</span></code> 인스턴스는 수명이 긴 데이터 구조에 저장하는 용도가 아닙니다; 파일 메타 데이터가 변경되었거나 <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a>를 호출 한 후 오랜 시간이 경과했음을 안다면, <code class="docutils literal"><span class="pre">os.stat(entry.path)</span></code>를 호출하여 최신 정보를 가져오십시오.</p>
<p><code class="docutils literal"><span class="pre">os.DirEntry</span></code> 메서드는 운영 체제 시스템 호출을 할 수 있기 때문에, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>를 일으킬 수도 있습니다. 에러에 대해 매우 세부적인 제어가 필요하면, <code class="docutils literal"><span class="pre">os.DirEntry</span></code> 메서드 중 하나를 호출할 때 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>를 잡은 후 적절하게 처리할 수 있습니다.</p>
<p><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>로 직접 사용할 수 있도록, <code class="docutils literal"><span class="pre">os.DirEntry</span></code>는 <a class="reference internal" href="#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal"><span class="pre">PathLike</span></code></a> 인터페이스를 구현합니다.</p>
<p><code class="docutils literal"><span class="pre">os.DirEntry</span></code> 인스턴스의 어트리뷰트 및 메서드는 다음과 같습니다:</p>
<dl class="attribute">
<dt id="os.DirEntry.name">
<code class="descname">name</code><a class="headerlink" href="#os.DirEntry.name" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> <em>path</em> 인자에 상대적인, 항목의 기본(base) 파일명.</p>
<p><a class="reference internal" href="#os.name" title="os.name"><code class="xref py py-attr docutils literal"><span class="pre">name</span></code></a> 어트리뷰트는 <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> <em>path</em> 인자가 <code class="docutils literal"><span class="pre">bytes</span></code> 형이면 <code class="docutils literal"><span class="pre">bytes</span></code> 고, 그렇지 않으면 <code class="docutils literal"><span class="pre">str</span></code> 입니다. 바이트열 파일명을 디코딩하려면 <a class="reference internal" href="#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal"><span class="pre">fsdecode()</span></code></a>를 사용하십시오.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.DirEntry.path">
<code class="descname">path</code><a class="headerlink" href="#os.DirEntry.path" title="정의 주소">¶</a></dt>
<dd><p>항목의 전체 경로명: <code class="docutils literal"><span class="pre">os.path.join(scandir_path,</span> <span class="pre">entry.name)</span></code>과 동일합니다. 여기서 <em>scandir_path</em> 는 <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> <em>path</em> 인자입니다. 경로는 <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> <em>path</em> 인자가 절대 걍로일 때만 절대 경로입니다. <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> <em>path</em> 인자가 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자</span></a>면, <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a> 어트리뷰트는 <a class="reference internal" href="#os.name" title="os.name"><code class="xref py py-attr docutils literal"><span class="pre">name</span></code></a> 어트리뷰트와 같습니다.</p>
<p><a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a> 어트리뷰트는 <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> <em>path</em> 인자가 <code class="docutils literal"><span class="pre">bytes</span></code> 형이면 <code class="docutils literal"><span class="pre">bytes</span></code>고, 그렇지 않으면 <code class="docutils literal"><span class="pre">str</span></code> 입니다. 바이트열 파일명을 디코딩하려면 <a class="reference internal" href="#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal"><span class="pre">fsdecode()</span></code></a>를 사용하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="os.DirEntry.inode">
<code class="descname">inode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.DirEntry.inode" title="정의 주소">¶</a></dt>
<dd><p>항목의 아이노드(inode) 번호를 반환합니다.</p>
<p>결과는 <code class="docutils literal"><span class="pre">os.DirEntry</span></code> 객체에 캐시됩니다. 최신 정보를 가져오려면 <code class="docutils literal"><span class="pre">os.stat(entry.path,</span> <span class="pre">follow_symlinks=False).st_ino</span></code>를 사용하십시오.</p>
<p>최초의 캐시되지 않은 호출에서, 윈도우 에서는 시스템 호출이 필요하지만 유닉스에서는 그렇지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="os.DirEntry.is_dir">
<code class="descname">is_dir</code><span class="sig-paren">(</span><em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.DirEntry.is_dir" title="정의 주소">¶</a></dt>
<dd><p>이 항목이 디렉터리 또는 디렉터리를 가리키는 심볼릭 링크면 <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 항목이 다른 종류의 파일이거나 다른 종류의 파일을 가리키면, 또는 더는 존재하지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
<p><em>follow_symlinks</em> 가 <code class="docutils literal"><span class="pre">False</span></code>면, 이 항목이 디렉터리 일 때만 (심볼릭 링크를 따르지 않고) <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 항목이 다른 종류의 파일이거나 더는 존재하지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
<p>결과는 <em>follow_symlinks</em> 가 <code class="docutils literal"><span class="pre">True</span></code> 및 <code class="docutils literal"><span class="pre">False</span></code>일 때에 대해 별도로 <code class="docutils literal"><span class="pre">os.DirEntry</span></code> 객체에 캐시됩니다. 최신 정보를 가져오려면, <a class="reference internal" href="stat.html#stat.S_ISDIR" title="stat.S_ISDIR"><code class="xref py py-func docutils literal"><span class="pre">stat.S_ISDIR()</span></code></a>로 <a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>을 호출하십시오.</p>
<p>최초의 캐시되지 않은 호출에서, 대부분 시스템 호출이 필요하지 않습니다. 특히, 심볼릭 링크가 아니면, 윈도우나 유닉스 모두 시스템 호출이 필요하지 않은데, 네트워크 파일 시스템과 같이 <code class="docutils literal"><span class="pre">dirent.d_type</span> <span class="pre">==</span> <span class="pre">DT_UNKNOWN</span></code>를 반환하는 특정 유닉스 파일 시스템은 예외입니다. 항목이 심볼릭 링크면, <em>follow_symlinks</em> 가 <code class="docutils literal"><span class="pre">False</span></code>가 아닌 이상, 심볼릭 링크를 따르기 위해 시스템 호출이 필요합니다.</p>
<p>이 메서드는, <a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal"><span class="pre">PermissionError</span></code></a>와 같은, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>를 발생시킬 수 있지만, <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal"><span class="pre">FileNotFoundError</span></code></a>는 잡혀서 발생하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="os.DirEntry.is_file">
<code class="descname">is_file</code><span class="sig-paren">(</span><em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.DirEntry.is_file" title="정의 주소">¶</a></dt>
<dd><p>이 항목이 파일이나 파일을 가리키는 심볼릭 링크면 <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 항목이 디렉터리 또는 다른 비 파일 항목이거나, 그런 것을 가리키거나, 더는 존재하지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
<p><em>follow_symlinks</em> 가 <code class="docutils literal"><span class="pre">False</span></code>면, 이 항목이 파일 일 때만 (심볼릭 링크를 따르지 않고) <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 항목이 디렉터리 나 다른 비 파일 항목이거나 더는 존재하지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
<p>결과는 <code class="docutils literal"><span class="pre">os.DirEntry</span></code> 객체에 캐시됩니다. 캐싱, 시스템 호출, 예외 발생은 <a class="reference internal" href="#os.DirEntry.is_dir" title="os.DirEntry.is_dir"><code class="xref py py-func docutils literal"><span class="pre">is_dir()</span></code></a>과 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="os.DirEntry.is_symlink">
<code class="descname">is_symlink</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.DirEntry.is_symlink" title="정의 주소">¶</a></dt>
<dd><p>이 항목이 심볼릭 링크면 (망가졌다 하더라도) <code class="docutils literal"><span class="pre">True</span></code>를 반환합니다; 항목이 디렉터리 나 어떤 종류의 파일이거나 더는 존재하지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
<p>결과는 <code class="docutils literal"><span class="pre">os.DirEntry</span></code> 객체에 캐시됩니다. 최신 정보를 가져 오려면 <a class="reference internal" href="os.path.html#os.path.islink" title="os.path.islink"><code class="xref py py-func docutils literal"><span class="pre">os.path.islink()</span></code></a>를 호출하십시오.</p>
<p>첫 번째, 캐시되지 않은 호출에서는 시스템 호출이 필요하지 않습니다. 특히 윈도우 나 유닉스는 <code class="docutils literal"><span class="pre">dirent.d_type</span> <span class="pre">==</span> <span class="pre">DT_UNKNOWN</span></code>를 반환하는 특정 유닉스 파일 시스템 (예 : 네트워크 파일 시스템)을 제외하고는 시스템 호출이 필요하지 않습니다.</p>
<p>이 메서드는, <a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal"><span class="pre">PermissionError</span></code></a>와 같은, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>를 발생시킬 수 있지만, <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal"><span class="pre">FileNotFoundError</span></code></a>는 잡혀서 발생하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="os.DirEntry.stat">
<code class="descname">stat</code><span class="sig-paren">(</span><em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.DirEntry.stat" title="정의 주소">¶</a></dt>
<dd><p>이 항목의 <a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a> 객체를 돌려줍니다. 이 메서드는 기본적으로 심볼릭 링크를 따릅니다; 심볼릭 링크를 stat하려면, <code class="docutils literal"><span class="pre">follow_symlinks=False</span></code> 인자를 추가하십시오.</p>
<p>유닉스에서, 이 메서드는 항상 시스템 호출을 요구합니다. 윈도우에서, <em>follow_symlinks</em> 가 <code class="docutils literal"><span class="pre">True</span></code>이고 항목이 심볼릭 링크일 때만 시스템 호출이 필요합니다.</p>
<p>윈도우에서, <a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a>의 <code class="docutils literal"><span class="pre">st_ino</span></code>, <code class="docutils literal"><span class="pre">st_dev</span></code> 및 <code class="docutils literal"><span class="pre">st_nlink</span></code> 어트리뷰트는 항상 0으로 설정됩니다. 이러한 어트리뷰트를 얻으려면 <a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>을 호출하십시오.</p>
<p>결과는 <em>follow_symlinks</em> 가 <code class="docutils literal"><span class="pre">True</span></code> 및 <code class="docutils literal"><span class="pre">False</span></code>일 때에 대해 별도로 <code class="docutils literal"><span class="pre">os.DirEntry</span></code> 객체에 캐시됩니다. 최신 정보를 가져오려면, <a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>을 호출하십시오.</p>
</dd></dl>

<p><code class="docutils literal"><span class="pre">os.DirEntry</span></code>와 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal"><span class="pre">pathlib.Path</span></code></a>의 여러 어트리뷰트와 메서드 사이에는 좋은 일치가 있음에 유의하십시오. 특히, <code class="docutils literal"><span class="pre">name</span></code> 어트리뷰트는 <code class="docutils literal"><span class="pre">is_dir()</span></code>, <code class="docutils literal"><span class="pre">is_file()</span></code>, <code class="docutils literal"><span class="pre">is_symlink()</span></code> 및 <code class="docutils literal"><span class="pre">stat()</span></code> 메서드처럼 같은 의미를 갖습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal"><span class="pre">PathLike</span></code></a> 인터페이스에 대한 지원이 추가되었습니다. 윈도우에서 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 경로에 대한 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.stat">
<code class="descclassname">os.</code><code class="descname">stat</code><span class="sig-paren">(</span><em>path</em>, <em>*</em>, <em>dir_fd=None</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.stat" title="정의 주소">¶</a></dt>
<dd><p>파일 또는 파일 기술자의 상태를 가져옵니다. 주어진 경로에 대해 <code class="xref c c-func docutils literal"><span class="pre">stat()</span></code> 시스템 호출과 같은 작업을 수행합니다. <em>path</em> 는 문자열이나 바이트열 -- 직접적으로 또는 <a class="reference internal" href="#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal"><span class="pre">PathLike</span></code></a> 인터페이스를 통해 간접적으로 -- 또는 열린 파일 기술자로 지정 될 수 있습니다. <a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a> 객체를 반환합니다.</p>
<p>이 함수는 일반적으로 심볼릭 링크를 따릅니다; 심볼릭 링크를 stat하려면, 인자 <code class="docutils literal"><span class="pre">follow_symlinks=False</span></code>를 추가하거나 <a class="reference internal" href="#os.lstat" title="os.lstat"><code class="xref py py-func docutils literal"><span class="pre">lstat()</span></code></a>를 사용하십시오.</p>
<p>이 함수는 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자 지정</span></a> 및 <a class="reference internal" href="#follow-symlinks"><span class="std std-ref">심볼릭 링크를 따르지 않음</span></a>을 지원할 수 있습니다.</p>
<p id="index-21">예:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">statinfo</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="s1">&#39;somefile.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">statinfo</span>
<span class="go">os.stat_result(st_mode=33188, st_ino=7876932, st_dev=234881026,</span>
<span class="go">st_nlink=1, st_uid=501, st_gid=501, st_size=264, st_atime=1297230295,</span>
<span class="go">st_mtime=1297230027, st_ctime=1297230027)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">statinfo</span><span class="o">.</span><span class="n">st_size</span>
<span class="go">264</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="#os.fstat" title="os.fstat"><code class="xref py py-func docutils literal"><span class="pre">fstat()</span></code></a> 및 <a class="reference internal" href="#os.lstat" title="os.lstat"><code class="xref py py-func docutils literal"><span class="pre">lstat()</span></code></a> 함수.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>dir_fd</em> 및 <em>follow_symlinks</em> 인자와 경로 대신 파일 기술자를 지정하는 것을 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="os.stat_result">
<em class="property">class </em><code class="descclassname">os.</code><code class="descname">stat_result</code><a class="headerlink" href="#os.stat_result" title="정의 주소">¶</a></dt>
<dd><p>어트리뷰트가 <code class="xref c c-type docutils literal"><span class="pre">stat</span></code> 구조체의 멤버와 대략 일치하는 객체. <a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>, <a class="reference internal" href="#os.fstat" title="os.fstat"><code class="xref py py-func docutils literal"><span class="pre">os.fstat()</span></code></a> 및 <a class="reference internal" href="#os.lstat" title="os.lstat"><code class="xref py py-func docutils literal"><span class="pre">os.lstat()</span></code></a>의 결과로 사용됩니다.</p>
<p>어트리뷰트:</p>
<dl class="attribute">
<dt id="os.stat_result.st_mode">
<code class="descname">st_mode</code><a class="headerlink" href="#os.stat_result.st_mode" title="정의 주소">¶</a></dt>
<dd><p>파일 모드: 파일 유형 및 파일 모드 비트 (사용 권한).</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_ino">
<code class="descname">st_ino</code><a class="headerlink" href="#os.stat_result.st_ino" title="정의 주소">¶</a></dt>
<dd><p>플랫폼에 따라 다르지만, 0이 아니면, 지정된 값의 <code class="docutils literal"><span class="pre">st_dev</span></code>은 파일을 고유하게 식별합니다. 일반적으로:</p>
<ul class="simple">
<li>유닉스의 아이노드 번호,</li>
<li>윈도우의 <a class="reference external" href="https://msdn.microsoft.com/en-us/library/aa363788">파일 인덱스</a></li>
</ul>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_dev">
<code class="descname">st_dev</code><a class="headerlink" href="#os.stat_result.st_dev" title="정의 주소">¶</a></dt>
<dd><p>이 파일이 있는 장치의 식별자.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_nlink">
<code class="descname">st_nlink</code><a class="headerlink" href="#os.stat_result.st_nlink" title="정의 주소">¶</a></dt>
<dd><p>하드 링크 수.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_uid">
<code class="descname">st_uid</code><a class="headerlink" href="#os.stat_result.st_uid" title="정의 주소">¶</a></dt>
<dd><p>파일 소유자의 사용자 식별자.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_gid">
<code class="descname">st_gid</code><a class="headerlink" href="#os.stat_result.st_gid" title="정의 주소">¶</a></dt>
<dd><p>파일 소유자의 그룹 식별자.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_size">
<code class="descname">st_size</code><a class="headerlink" href="#os.stat_result.st_size" title="정의 주소">¶</a></dt>
<dd><p>일반 파일 또는 심볼릭 링크면, 바이트 단위의 파일의 크기. 심볼릭 링크의 크기는 포함하고 있는 경로명의 길이이며, 끝나는 널 바이트는 포함하지 않습니다.</p>
</dd></dl>

<p>타임 스탬프:</p>
<dl class="attribute">
<dt id="os.stat_result.st_atime">
<code class="descname">st_atime</code><a class="headerlink" href="#os.stat_result.st_atime" title="정의 주소">¶</a></dt>
<dd><p>초 단위의 가장 최근의 액세스 시간.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_mtime">
<code class="descname">st_mtime</code><a class="headerlink" href="#os.stat_result.st_mtime" title="정의 주소">¶</a></dt>
<dd><p>초 단위의 가장 최근의 내용 수정 시간.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_ctime">
<code class="descname">st_ctime</code><a class="headerlink" href="#os.stat_result.st_ctime" title="정의 주소">¶</a></dt>
<dd><p>플랫폼에 따라 다릅니다:</p>
<ul class="simple">
<li>유닉스에서 가장 최근의 메타 데이터 변경 시간,</li>
<li>윈도우에서 생성 시간, 단위는 초.</li>
</ul>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_atime_ns">
<code class="descname">st_atime_ns</code><a class="headerlink" href="#os.stat_result.st_atime_ns" title="정의 주소">¶</a></dt>
<dd><p>나노초 정수 단위의 가장 최근의 액세스 시간.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_mtime_ns">
<code class="descname">st_mtime_ns</code><a class="headerlink" href="#os.stat_result.st_mtime_ns" title="정의 주소">¶</a></dt>
<dd><p>나노초 정수 단위의 가장 최근의 내용 수정 시간.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_ctime_ns">
<code class="descname">st_ctime_ns</code><a class="headerlink" href="#os.stat_result.st_ctime_ns" title="정의 주소">¶</a></dt>
<dd><p>플랫폼에 따라 다릅니다:</p>
<ul class="simple">
<li>유닉스에서 가장 최근의 메타 데이터 변경 시간,</li>
<li>윈도우에서 생성 시간, 단위는 나노초 정수.</li>
</ul>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">주석</p>
<p><a class="reference internal" href="#os.stat_result.st_atime" title="os.stat_result.st_atime"><code class="xref py py-attr docutils literal"><span class="pre">st_atime</span></code></a>, <a class="reference internal" href="#os.stat_result.st_mtime" title="os.stat_result.st_mtime"><code class="xref py py-attr docutils literal"><span class="pre">st_mtime</span></code></a> 및 <a class="reference internal" href="#os.stat_result.st_ctime" title="os.stat_result.st_ctime"><code class="xref py py-attr docutils literal"><span class="pre">st_ctime</span></code></a> 어트리뷰트의 정확한 의미와 해상도는 운영 체제와 파일 시스템에 따라 다릅니다. 예를 들어, FAT 또는 FAT32 파일 시스템을 사용하는 윈도우 시스템에서, <a class="reference internal" href="#os.stat_result.st_mtime" title="os.stat_result.st_mtime"><code class="xref py py-attr docutils literal"><span class="pre">st_mtime</span></code></a>은 2초 해상도를, <a class="reference internal" href="#os.stat_result.st_atime" title="os.stat_result.st_atime"><code class="xref py py-attr docutils literal"><span class="pre">st_atime</span></code></a>는 단지 1일 해상도를 갖습니다. 자세한 내용은 운영 체제 설명서를 참조하십시오.</p>
<p class="last">마찬가지로, <a class="reference internal" href="#os.stat_result.st_atime_ns" title="os.stat_result.st_atime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_atime_ns</span></code></a>, <a class="reference internal" href="#os.stat_result.st_mtime_ns" title="os.stat_result.st_mtime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_mtime_ns</span></code></a> 및 <a class="reference internal" href="#os.stat_result.st_ctime_ns" title="os.stat_result.st_ctime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_ctime_ns</span></code></a>가 항상 나노초 단위로 표시되지만, 많은 시스템은 나노초 정밀도를 제공하지 않습니다. 나노초 정밀도를 제공하는 시스템에서, <a class="reference internal" href="#os.stat_result.st_atime" title="os.stat_result.st_atime"><code class="xref py py-attr docutils literal"><span class="pre">st_atime</span></code></a>, <a class="reference internal" href="#os.stat_result.st_mtime" title="os.stat_result.st_mtime"><code class="xref py py-attr docutils literal"><span class="pre">st_mtime</span></code></a> 및 <a class="reference internal" href="#os.stat_result.st_ctime" title="os.stat_result.st_ctime"><code class="xref py py-attr docutils literal"><span class="pre">st_ctime</span></code></a>를 저장하는 데 사용되는 부동 소수점 객체는, 이 값을 모두 보존 할 수 없으므로, 약간 부정확합니다. 정확한 타임 스탬프가 필요하면, 항상 <a class="reference internal" href="#os.stat_result.st_atime_ns" title="os.stat_result.st_atime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_atime_ns</span></code></a>, <a class="reference internal" href="#os.stat_result.st_mtime_ns" title="os.stat_result.st_mtime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_mtime_ns</span></code></a> 및 <a class="reference internal" href="#os.stat_result.st_ctime_ns" title="os.stat_result.st_ctime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_ctime_ns</span></code></a>를 사용해야합니다.</p>
</div>
<p>(리눅스와 같은) 일부 유닉스 시스템에서는, 다음 어트리뷰트도 사용할 수 있습니다:</p>
<dl class="attribute">
<dt id="os.stat_result.st_blocks">
<code class="descname">st_blocks</code><a class="headerlink" href="#os.stat_result.st_blocks" title="정의 주소">¶</a></dt>
<dd><p>파일에 할당 된 512-바이트 블록 수. 파일에 구멍이 있으면 <a class="reference internal" href="#os.stat_result.st_size" title="os.stat_result.st_size"><code class="xref py py-attr docutils literal"><span class="pre">st_size</span></code></a>/512 보다 작을 수 있습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_blksize">
<code class="descname">st_blksize</code><a class="headerlink" href="#os.stat_result.st_blksize" title="정의 주소">¶</a></dt>
<dd><p>효율적인 파일 시스템 I/O를 위해 &quot;선호되는&quot; 블록 크기. 더 작은 크기로 파일에 기록하면 비효율적인 읽기-수정-다시 쓰기가 발생할 수 있습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_rdev">
<code class="descname">st_rdev</code><a class="headerlink" href="#os.stat_result.st_rdev" title="정의 주소">¶</a></dt>
<dd><p>아이노드 장치면 장치 유형.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_flags">
<code class="descname">st_flags</code><a class="headerlink" href="#os.stat_result.st_flags" title="정의 주소">¶</a></dt>
<dd><p>파일에 대한 사용자 정의 플래그.</p>
</dd></dl>

<p>(FreeBSD와 같은) 다른 유닉스 시스템에서는, 다음 어트리뷰트를 사용할 수 있습니다 (그러나 root가 사용하려고 할 때만 채워질 수 있습니다):</p>
<dl class="attribute">
<dt id="os.stat_result.st_gen">
<code class="descname">st_gen</code><a class="headerlink" href="#os.stat_result.st_gen" title="정의 주소">¶</a></dt>
<dd><p>파일 생성 번호.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_birthtime">
<code class="descname">st_birthtime</code><a class="headerlink" href="#os.stat_result.st_birthtime" title="정의 주소">¶</a></dt>
<dd><p>파일 생성 시간.</p>
</dd></dl>

<p>Solaris 및 파생 상품에서, 다음 어트리뷰트도 사용할 수 있습니다:</p>
<dl class="attribute">
<dt id="os.stat_result.st_fstype">
<code class="descname">st_fstype</code><a class="headerlink" href="#os.stat_result.st_fstype" title="정의 주소">¶</a></dt>
<dd><p>파일을 포함하는 파일 시스템의 유형을 고유하게 식별하는 문자열.</p>
</dd></dl>

<p>맥 OS 시스템에서는, 다음 어트리뷰트도 사용할 수 있습니다:</p>
<dl class="attribute">
<dt id="os.stat_result.st_rsize">
<code class="descname">st_rsize</code><a class="headerlink" href="#os.stat_result.st_rsize" title="정의 주소">¶</a></dt>
<dd><p>파일의 실제 크기.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_creator">
<code class="descname">st_creator</code><a class="headerlink" href="#os.stat_result.st_creator" title="정의 주소">¶</a></dt>
<dd><p>파일의 생성자.</p>
</dd></dl>

<dl class="attribute">
<dt id="os.stat_result.st_type">
<code class="descname">st_type</code><a class="headerlink" href="#os.stat_result.st_type" title="정의 주소">¶</a></dt>
<dd><p>파일 유형.</p>
</dd></dl>

<p>윈도우 시스템에서는, 다음 어트리뷰트도 사용할 수도 있습니다:</p>
<dl class="attribute">
<dt id="os.stat_result.st_file_attributes">
<code class="descname">st_file_attributes</code><a class="headerlink" href="#os.stat_result.st_file_attributes" title="정의 주소">¶</a></dt>
<dd><p>윈도우 파일 어트리뷰트: <code class="xref c c-func docutils literal"><span class="pre">GetFileInformationByHandle()</span></code>에 의해 반환 된 <code class="docutils literal"><span class="pre">BY_HANDLE_FILE_INFORMATION</span></code> 구조체의 <code class="docutils literal"><span class="pre">dwFileAttributes</span></code> 멤버. <a class="reference internal" href="stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal"><span class="pre">stat</span></code></a> 모듈의 <code class="docutils literal"><span class="pre">FILE_ATTRIBUTE_*</span></code> 상수를 참조하십시오.</p>
</dd></dl>

<p>표준 모듈 <a class="reference internal" href="stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal"><span class="pre">stat</span></code></a>는 <code class="xref c c-type docutils literal"><span class="pre">stat</span></code> 구조체에서 정보를 추출하는 데 유용한 함수와 상수를 정의합니다. (윈도우에서는, 일부 항목에 더미 값이 채워집니다.)</p>
<p>이전 버전과의 호환성을 위해, <a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a> 인스턴스는 <code class="xref c c-type docutils literal"><span class="pre">stat</span></code> 구조체의 가장 중요한 (그리고 이식성있는) 멤버를 제공하는 최소 10 개의 정수로 구성된 튜플로 액세스할 수도 있는데, <a class="reference internal" href="#os.stat_result.st_mode" title="os.stat_result.st_mode"><code class="xref py py-attr docutils literal"><span class="pre">st_mode</span></code></a>, <a class="reference internal" href="#os.stat_result.st_ino" title="os.stat_result.st_ino"><code class="xref py py-attr docutils literal"><span class="pre">st_ino</span></code></a>, <a class="reference internal" href="#os.stat_result.st_dev" title="os.stat_result.st_dev"><code class="xref py py-attr docutils literal"><span class="pre">st_dev</span></code></a>, <a class="reference internal" href="#os.stat_result.st_nlink" title="os.stat_result.st_nlink"><code class="xref py py-attr docutils literal"><span class="pre">st_nlink</span></code></a>, <a class="reference internal" href="#os.stat_result.st_uid" title="os.stat_result.st_uid"><code class="xref py py-attr docutils literal"><span class="pre">st_uid</span></code></a>, <a class="reference internal" href="#os.stat_result.st_gid" title="os.stat_result.st_gid"><code class="xref py py-attr docutils literal"><span class="pre">st_gid</span></code></a>, <a class="reference internal" href="#os.stat_result.st_size" title="os.stat_result.st_size"><code class="xref py py-attr docutils literal"><span class="pre">st_size</span></code></a>, <a class="reference internal" href="#os.stat_result.st_atime" title="os.stat_result.st_atime"><code class="xref py py-attr docutils literal"><span class="pre">st_atime</span></code></a>, <a class="reference internal" href="#os.stat_result.st_mtime" title="os.stat_result.st_mtime"><code class="xref py py-attr docutils literal"><span class="pre">st_mtime</span></code></a>, <a class="reference internal" href="#os.stat_result.st_ctime" title="os.stat_result.st_ctime"><code class="xref py py-attr docutils literal"><span class="pre">st_ctime</span></code></a> 순서입니다. 일부 구현에서는 끝에 더 많은 항목을 추가 할 수 있습니다. 이전 버전의 파이썬과의 호환성을 위해, <a class="reference internal" href="#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal"><span class="pre">stat_result</span></code></a>에 튜플로 액세스하면 항상 정수가 반환됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><a class="reference internal" href="#os.stat_result.st_atime_ns" title="os.stat_result.st_atime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_atime_ns</span></code></a>, <a class="reference internal" href="#os.stat_result.st_mtime_ns" title="os.stat_result.st_mtime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_mtime_ns</span></code></a> 및 <a class="reference internal" href="#os.stat_result.st_ctime_ns" title="os.stat_result.st_ctime_ns"><code class="xref py py-attr docutils literal"><span class="pre">st_ctime_ns</span></code></a> 멤버가 추가되었습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가: </span>윈도우에서 <a class="reference internal" href="#os.stat_result.st_file_attributes" title="os.stat_result.st_file_attributes"><code class="xref py py-attr docutils literal"><span class="pre">st_file_attributes</span></code></a> 멤버를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>윈도우는 이제 사용 가능할 때 파일 인덱스를 <a class="reference internal" href="#os.stat_result.st_ino" title="os.stat_result.st_ino"><code class="xref py py-attr docutils literal"><span class="pre">st_ino</span></code></a>로 반환합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span>Solaris/파생 제품에 <a class="reference internal" href="#os.stat_result.st_fstype" title="os.stat_result.st_fstype"><code class="xref py py-attr docutils literal"><span class="pre">st_fstype</span></code></a> 멤버를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.statvfs">
<code class="descclassname">os.</code><code class="descname">statvfs</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#os.statvfs" title="정의 주소">¶</a></dt>
<dd><p>주어진 경로에대해 <code class="xref c c-func docutils literal"><span class="pre">statvfs()</span></code> 시스템 호출을 수행합니다. 반환 값은 주어진 경로의 파일 시스템을 설명하는 객체인데, 어트리뷰트가 <code class="xref c c-type docutils literal"><span class="pre">statvfs</span></code> 구조체의 멤버 인 <code class="xref py py-attr docutils literal"><span class="pre">f_bsize</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_frsize</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_blocks</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_bfree</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_bavail</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_files</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_ffree</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_favail</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_flag</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_namemax</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">f_fsid</span></code>에 해당합니다.</p>
<p><code class="xref py py-attr docutils literal"><span class="pre">f_flag</span></code> 어트리뷰트의 비트 플래그에 대해 두 개의 모듈 수준 상수가 정의됩니다: <code class="xref py py-const docutils literal"><span class="pre">ST_RDONLY</span></code>가 설정되면, 파일 시스템은 읽기 전용으로 마운트되었고, <code class="xref py py-const docutils literal"><span class="pre">ST_NOSUID</span></code>가 설정되면, setuid/setgid 비트의 의미가 비활성화되었거나 지원되지 않습니다.</p>
<p>추가적인 모듈 수준 상수가 GNU/glibc 기반 시스템에 대해 정의됩니다. 이들은 <code class="xref py py-const docutils literal"><span class="pre">ST_NODEV</span></code> (장치 특수 파일에 대한 액세스 금지), <code class="xref py py-const docutils literal"><span class="pre">ST_NOEXEC</span></code> (프로그램 실행 금지), <code class="xref py py-const docutils literal"><span class="pre">ST_SYNCHRONOUS</span></code> (한 번에 쓰기 동기화), <code class="xref py py-const docutils literal"><span class="pre">ST_MANDLOCK</span></code> (FS에 필수 잠금 허용), <code class="xref py py-const docutils literal"><span class="pre">ST_WRITE</span></code> (파일/디렉터리/심볼릭 링크 쓰기), <code class="xref py py-const docutils literal"><span class="pre">ST_APPEND</span></code> (덧붙이기 전용 파일), <code class="xref py py-const docutils literal"><span class="pre">ST_IMMUTABLE</span></code> (불변 파일), <code class="xref py py-const docutils literal"><span class="pre">ST_NOATIME</span></code> (액세스 시간을 갱신하지 않음), <code class="xref py py-const docutils literal"><span class="pre">ST_NODIRATIME</span></code> (디렉터리 액세스 시간을 갱신하지 않음), <code class="xref py py-const docutils literal"><span class="pre">ST_RELATIME</span></code> (mtime/ctime에 상대적으로 atime을 갱신).</p>
<p>이 함수는 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자 지정</span></a>을 지원할 수 있습니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><code class="xref py py-const docutils literal"><span class="pre">ST_RDONLY</span></code> 및 <code class="xref py py-const docutils literal"><span class="pre">ST_NOSUID</span></code> 상수가 추가되었습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>path</em>에 열린 파일 기술자를 지정하는 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span><code class="xref py py-const docutils literal"><span class="pre">ST_NODEV</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_NOEXEC</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_SYNCHRONOUS</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_MANDLOCK</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_WRITE</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_APPEND</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_IMMUTABLE</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_NOATIME</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ST_NODIRATIME</span></code> 및 <code class="xref py py-const docutils literal"><span class="pre">ST_RELATIME</span></code> 상수가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><code class="xref py py-attr docutils literal"><span class="pre">f_fsid</span></code> 추가.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.supports_dir_fd">
<code class="descclassname">os.</code><code class="descname">supports_dir_fd</code><a class="headerlink" href="#os.supports_dir_fd" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> 모듈의 어떤 함수가 <em>dir_fd</em> 매개 변수의 사용을 허용하는지를 나타내는 <a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal"><span class="pre">Set</span></code></a> 객체입니다. 플랫폼마다 다른 기능을 제공하며, 한 플랫폼에서 작동 할 수 있는 옵션은 다른 플랫폼에서 지원되지 않을 수 있습니다. 일관성을 위해, <em>dir_fd</em> 를 지원하는 함수는 항상 매개 변수를 지정할 수 있도록하지만, 기능을 실제로 사용할 수 없으면 예외를 발생시킵니다.</p>
<p>특정 함수가 <em>dir_fd</em> 매개 변수의 사용을 허용하는지를 확인하려면, <code class="docutils literal"><span class="pre">supports_dir_fd</span></code>에 <code class="docutils literal"><span class="pre">in</span></code> 연산자를 사용하십시오. 예를 들어, 이 표현식은 <a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>의 <em>dir_fd</em> 매개 변수가 로컬에서 사용 가능한지를 판별합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">os</span><span class="o">.</span><span class="n">stat</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">supports_dir_fd</span>
</pre></div>
</div>
<p>현재 <em>dir_fd</em> 매개 변수는 유닉스 플랫폼에서만 작동합니다; 어느 것도 윈도우에서 작동하지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.supports_effective_ids">
<code class="descclassname">os.</code><code class="descname">supports_effective_ids</code><a class="headerlink" href="#os.supports_effective_ids" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> 모듈의 어떤 함수가 <a class="reference internal" href="#os.access" title="os.access"><code class="xref py py-func docutils literal"><span class="pre">os.access()</span></code></a>의 <em>effective_ids</em> 매개 변수의 사용을 허용하지를 나타내는 <a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal"><span class="pre">Set</span></code></a> 객체입니다. 로컬 플랫폼이 지원하면, 컬렉션에 <a class="reference internal" href="#os.access" title="os.access"><code class="xref py py-func docutils literal"><span class="pre">os.access()</span></code></a>가 포함되고, 그렇지 않으면 비어있게됩니다.</p>
<p><a class="reference internal" href="#os.access" title="os.access"><code class="xref py py-func docutils literal"><span class="pre">os.access()</span></code></a>에 <em>effective_ids</em> 매개 변수를 사용할 수 있는지 확인하려면, <code class="docutils literal"><span class="pre">supports_effective_ids</span></code>에 <code class="docutils literal"><span class="pre">in</span></code> 연산자를 사용하십시오. 예를 들면 다음과 같습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">os</span><span class="o">.</span><span class="n">access</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">supports_effective_ids</span>
</pre></div>
</div>
<p>현재 <em>effective_ids</em> 는 유닉스 플랫폼에서만 작동합니다; 윈도우에서는 작동하지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.supports_fd">
<code class="descclassname">os.</code><code class="descname">supports_fd</code><a class="headerlink" href="#os.supports_fd" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> 모듈의 어떤 함수가 자신의 <em>path</em> 매개 변수에 열린 파일 기술자를 지정하는 것을 허용하는지를 나타내는 <a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal"><span class="pre">Set</span></code></a> 객체입니다. 플랫폼마다 다른 기능을 제공하며, 한 플랫폼에서 작동 할 수 있는 옵션은 다른 플랫폼에서 지원되지 않을 수 있습니다. 일관성을 위해, <em>fd</em> 를 지원하는 함수는 항상 매개 변수를 지정할 수 있도록하지만, 기능을 실제로 사용할 수 없으면 예외를 발생시킵니다.</p>
<p>특정 함수가 <em>path</em> 매개 변수에 열린 파일 기술자를 지정할 수 있도록 허용하는지를 확인하려면, <code class="docutils literal"><span class="pre">supports_fd</span></code>에 <code class="docutils literal"><span class="pre">in</span></code> 연산자를 사용하십시오. 예를 들어, 이 표현식은 로컬 플랫폼에서 <a class="reference internal" href="#os.chdir" title="os.chdir"><code class="xref py py-func docutils literal"><span class="pre">os.chdir()</span></code></a>가 호출 될 때 열린 파일 기술자를 받아들이는지를 판별합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">os</span><span class="o">.</span><span class="n">chdir</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">supports_fd</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.supports_follow_symlinks">
<code class="descclassname">os.</code><code class="descname">supports_follow_symlinks</code><a class="headerlink" href="#os.supports_follow_symlinks" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal"><span class="pre">os</span></code></a> 모듈의 어떤 함수가 <em>follow_symlinks</em> 매개 변수의 사용을 허용하는지를 나타내는 <a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal"><span class="pre">Set</span></code></a> 객체입니다. 플랫폼마다 다른 기능을 제공하며, 한 플랫폼에서 작동 할 수 있는 옵션은 다른 플랫폼에서 지원되지 않을 수 있습니다. 일관성을 위해, <em>follow_symlinks</em> 를 지원하는 함수는 항상 매개 변수를 지정할 수 있도록하지만, 기능을 실제로 사용할 수 없으면 예외를 발생시킵니다.</p>
<p>특정 함수가 <em>follow_symlinks</em> 매개 변수의 사용을 허용하는지를 확인하려면, <code class="docutils literal"><span class="pre">supports_follow_symlinks</span></code>에 <code class="docutils literal"><span class="pre">in</span></code> 연산자를 사용하십시오. 예를 들어, 이 표현식은 <a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a>의 <em>follow_symlinks</em> 매개 변수가 로컬에서 사용 가능한지를 판별합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">os</span><span class="o">.</span><span class="n">stat</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">supports_follow_symlinks</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.symlink">
<code class="descclassname">os.</code><code class="descname">symlink</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em>, <em>target_is_directory=False</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.symlink" title="정의 주소">¶</a></dt>
<dd><p><em>src를</em> 가리키는 <em>dst</em> 라는 이름의 심볼릭 링크를 만듭니다.</p>
<p>윈도우에서, 심볼릭 링크는 파일이나 디렉터리를 나타내며, 동적으로 대상에 맞춰 변형되지 않습니다. 대상이 있으면, 일치하도록 심볼릭 링크의 유형이 만들어집니다. 그렇지 않으면, <em>target_is_directory</em> 가 <code class="docutils literal"><span class="pre">True</span></code> 면 심볼릭 링크가 디렉터리로 만들어지고, 그렇지 않으면 파일 심볼릭 링크(기본값)가 만들어집니다. 비 윈도우 플랫폼에서는 <em>target_is_directory</em> 가 무시됩니다.</p>
<p>심볼릭 링크 지원은 윈도우 6.0(Vista)에서 소개되었습니다. <a class="reference internal" href="#os.symlink" title="os.symlink"><code class="xref py py-func docutils literal"><span class="pre">symlink()</span></code></a>는 6.0 이전의 윈도우 버전에서 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>를 발생시킵니다.</p>
<p>이 함수는 <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a>를 지원할 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p>윈도우에서, 심볼릭 링크를 성공적으로 만들려면 <em>SeCreateSymbolicLinkPrivilege</em> 가 필요합니다. 이 권한은 보통 일반 사용자에게는 부여되지 않지만, 관리자 수준으로 권한을 상승시킬 수 있는 계정에서는 사용할 수 있습니다. 권한을 얻거나 응용 프로그램을 관리자로 실행하는 것은 심볼릭 링크를 성공적으로 만들 수 있는 방법입니다.</p>
<p class="last">권한이 없는 사용자가 함수를 호출하면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>가 발생합니다.</p>
</div>
<p>가용성: 유닉스, 윈도우.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>윈도우 6.0 (Vista) 심볼릭 링크에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>dir_fd</em> 인자를 추가했으며, 이제 비 윈도우 플랫폼에서 <em>target_is_directory</em> 를 허용합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><em>src</em> 및 <em>dst</em>로 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.sync">
<code class="descclassname">os.</code><code class="descname">sync</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.sync" title="정의 주소">¶</a></dt>
<dd><p>디스크에 모든 것을 쓰도록 강제합니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.truncate">
<code class="descclassname">os.</code><code class="descname">truncate</code><span class="sig-paren">(</span><em>path</em>, <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#os.truncate" title="정의 주소">¶</a></dt>
<dd><p>최대 <em>length</em> 바이트가 되도록 <em>path</em>에 해당하는 파일을 자릅니다.</p>
<p>이 함수는 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자 지정</span></a>을 지원할 수 있습니다.</p>
<p>가용성: 유닉스, 윈도우.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>윈도우 지원 추가</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.unlink">
<code class="descclassname">os.</code><code class="descname">unlink</code><span class="sig-paren">(</span><em>path</em>, <em>*</em>, <em>dir_fd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.unlink" title="정의 주소">¶</a></dt>
<dd><p>파일 <em>path</em>를 제거(삭제)합니다. 이 함수는 의미상 <a class="reference internal" href="#os.remove" title="os.remove"><code class="xref py py-func docutils literal"><span class="pre">remove()</span></code></a>와 같습니다; <code class="docutils literal"><span class="pre">unlink</span></code> 라는 이름은 전통적인 유닉스 이름입니다. 자세한 내용은 <a class="reference internal" href="#os.remove" title="os.remove"><code class="xref py py-func docutils literal"><span class="pre">remove()</span></code></a> 설명서를 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>dir_fd</em> 매개 변수</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.utime">
<code class="descclassname">os.</code><code class="descname">utime</code><span class="sig-paren">(</span><em>path</em>, <em>times=None</em>, <em>*</em>, <span class="optional">[</span><em>ns</em>, <span class="optional">]</span><em>dir_fd=None</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.utime" title="정의 주소">¶</a></dt>
<dd><p><em>path</em>로 지정된 파일의 액세스 및 수정 시간을 설정합니다.</p>
<p><a class="reference internal" href="#os.utime" title="os.utime"><code class="xref py py-func docutils literal"><span class="pre">utime()</span></code></a>은 <em>times</em> 과 <em>ns</em> 라는 두 개의 선택적 매개 변수를 취합니다. <em>path</em>에 설정할 시간을 지정하며 다음과 같이 사용됩니다:</p>
<ul class="simple">
<li><em>ns</em> 가 지정되면, <code class="docutils literal"><span class="pre">(atime_ns,</span> <span class="pre">mtime_ns)</span></code> 형식의 2-튜플이어야하며, 각 멤버는 나노초를 나타내는 int입니다.</li>
<li><em>times</em> 가 <code class="docutils literal"><span class="pre">None</span></code>이 아니면, <code class="docutils literal"><span class="pre">(atime,</span> <span class="pre">mtime)</span></code> 형식의 2-튜플이어야하며, 각 멤버는 초를 나타내는 int 또는 float입니다.</li>
<li><em>times</em> 가 <code class="docutils literal"><span class="pre">None</span></code>이고 <em>ns</em> 가 지정되지 않으면, <code class="docutils literal"><span class="pre">ns=(atime_ns,</span> <span class="pre">mtime_ns)</span></code>를 지정하는 것과 같은데, 두 시간 모두 현재 시간입니다.</li>
</ul>
<p><em>times</em> 와 <em>ns</em>에 모두 튜플을 지정하는 것은 에러입니다.</p>
<p>디렉터리가 <em>path</em> 로 제공 될 수 있는지는 운영 체제가 디렉터리를 파일로 구현하는지에 따라 다릅니다 (예를 들어, 윈도우는 그렇지 않습니다). 여기서 설정한 정확한 시간은 운영 체제가 액세스 및 수정 시간을 기록하는 해상도에 따라 뒤따르는 <a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a> 호출에서 반환되지 않을 수 있음에 주의해야합니다; <a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">stat()</span></code></a>를 참조하세요. 정확한 시간을 보존하는 가장 좋은 방법은 <cite>utime</cite> 의 <em>ns</em> 매개 변수에 <a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a> 결과 객체의 <em>st_atime_ns</em> 및 <em>st_mtime_ns</em> 필드를 사용하는 것입니다.</p>
<p>이 함수는 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자 지정</span></a>, <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a> 및 <a class="reference internal" href="#follow-symlinks"><span class="std std-ref">심볼릭 링크를 따르지 않음</span></a>을 지원할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><em>path</em>에 열린 파일 기술자를 지정하는 것과 <em>dir_fd</em> , <em>follow_symlinks</em> 및 <em>ns</em> 매개 변수 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.walk">
<code class="descclassname">os.</code><code class="descname">walk</code><span class="sig-paren">(</span><em>top</em>, <em>topdown=True</em>, <em>onerror=None</em>, <em>followlinks=False</em><span class="sig-paren">)</span><a class="headerlink" href="#os.walk" title="정의 주소">¶</a></dt>
<dd><p id="index-22">트리를 하향식 또는 상향식으로 탐색하여 디렉터리 트리에 있는 파일명을 생성합니다. 디렉터리 <em>top</em>을 루트로 하는 트리의 각 디렉터리(<em>top</em> 자체를 포함합니다)마다, 3-튜플 <code class="docutils literal"><span class="pre">(dirpath,</span> <span class="pre">dirnames,</span> <span class="pre">filenames)</span></code>를 산출합니다.</p>
<p><em>dirpath</em> 는 디렉터리 경로인 문자열입니다. <em>dirnames</em> 는 <em>dirpath</em> 의 하위 디렉터리 이름 리스트입니다 (<code class="docutils literal"><span class="pre">'.'</span></code> 및 <code class="docutils literal"><span class="pre">'..'</span></code> 제외). <em>filenames</em> 는 <em>dirpath</em>에 있는 디렉터리가 아닌 파일의 이름 리스트입니다. 리스트에 들어있는 이름에는 경로 구성 요소가 들어 있지 않음에 유의하십시오. <em>dirpath</em> 에 있는 파일이나 디렉터리에 대한 전체 경로(<em>top</em>으로 시작하는)를 얻으려면, <code class="docutils literal"><span class="pre">os.path.join(dirpath,</span> <span class="pre">name)</span></code>를 수행하십시오.</p>
<p>선택적 인자 <em>topdown</em> 이 <code class="docutils literal"><span class="pre">True</span></code>이거나 지정되지 않으면, 디렉터리에 대한 3-튜플은 하위 디렉터리에 대한 3-튜플이 생성되기 전에 생성됩니다 (디렉터리는 하향식으로 생성됩니다). <em>topdown</em> 이 <code class="docutils literal"><span class="pre">False</span></code>면, 모든 하위 디렉터리에 대한 3-튜플 다음에 디렉터리에 대한 3-튜플이 생성됩니다 (디렉터리가 상향식으로 생성됨). <em>topdown</em> 의 값에 상관없이, 디렉터리와 해당 하위 디렉터리의 튜플이 생성되기 전에 하위 디렉터리 목록이 조회됩니다.</p>
<p><em>topdown</em> 이 <code class="docutils literal"><span class="pre">True</span></code> 일 때, 호출자는 (아마도 <a class="reference internal" href="../reference/simple_stmts.html#del"><code class="xref std std-keyword docutils literal"><span class="pre">del</span></code></a> 또는 슬라이스 대입을 사용하여) <em>dirnames</em> 리스트를 수정할 수 있으며, <a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>는 이름이 <em>dirnames</em> 남아있는 하위 디렉터리로만 재귀합니다; 검색을 가지치기하거나, 특정 방문 순서를 지정하거나, 심지어 <a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>가 다시 시작하기 전에 호출자가 새로 만들거나 이름을 바꾼 디렉터리에 대해 <a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>에 알릴 때도 사용할 수 있습니다. <em>topdown</em> 이 <code class="docutils literal"><span class="pre">False</span></code>일 때 <em>dirnames</em>를 수정하는 것은 walk의 동작에 영향을 주지 못하는데, 상향식 모드에서 <em>dirnames</em>의 디렉터리는 <em>dirpath</em> 자체가 생성되기 전에 생성되기 때문입니다.</p>
<p>기본적으로, <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">scandir()</span></code></a> 호출의 에러는 무시됩니다. 선택적 인자 <em>onerror</em> 가 지정되면, 함수여야 합니다; 하나의 인자 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> 인스턴스로 호출됩니다. 에러를 보고하고 walk를 계속하도록 하거나, 예외를 발생시켜 walk를 중단 할 수 있습니다. 파일명은 예외 객체의 <code class="docutils literal"><span class="pre">filename</span></code> 어트리뷰트로 제공됩니다.</p>
<p>기본적으로, <a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>는 디렉터리로 해석되는 심볼릭 링크로 이동하지 않습니다. 지원하는 시트템에서, 심볼릭 링크가 가리키는 디렉터리를 방문하려면, <em>followlinks</em>를 <code class="docutils literal"><span class="pre">True</span></code>로 설정하십시오.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">심볼릭 링크가 자신의 부모 디렉터리를 가리킬 때, <em>followlinks</em>를 <code class="docutils literal"><span class="pre">True</span></code>로 설정하면 무한 재귀가 발생할 수 있음에 주의해야합니다. <a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>는 이미 방문한 디렉터리를 추적하지 않습니다.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">상대 경로명을 전달할 때는, <a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>가 실행되는 도중 현재 작업 디렉터리를 변경하지 마십시오. <a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>는 현재 디렉터리를 절대로 변경하지 않으며, 호출자도 마찬가지라고 가정합니다.</p>
</div>
<p>이 예는 시작 디렉터리 아래의 각 디렉터리에 있는 비 디렉터리 파일이 차지한 바이트 수를 표시합니다. 단, CVS 하위 디렉터리 아래는 보지 않습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="k">import</span> <span class="n">join</span><span class="p">,</span> <span class="n">getsize</span>
<span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="s1">&#39;python/Lib/email&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;consumes&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">getsize</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;bytes in&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">),</span> <span class="s2">&quot;non-directory files&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;CVS&#39;</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
        <span class="n">dirs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;CVS&#39;</span><span class="p">)</span>  <span class="c1"># CVS 디렉터리는 방문하지 않습니다</span>
</pre></div>
</div>
<p>다음 예(<a class="reference internal" href="shutil.html#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal"><span class="pre">shutil.rmtree()</span></code></a>의 간단한 구현)에서는, 트리를 상향식으로 탐색하는 것이 필수적입니다, <a class="reference internal" href="#os.rmdir" title="os.rmdir"><code class="xref py py-func docutils literal"><span class="pre">rmdir()</span></code></a>는 비어 있지 않은 디렉터리를 삭제할 수 없습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># 심볼릭 링크가 없다고 가정하고, &quot;top&quot;으로 지정한 디렉터리에서 도달할 수 있는</span>
<span class="c1"># 모든 것을 삭제합니다.</span>
<span class="c1"># 주의: 위험합니다! 예를 들어, top == &#39;/&#39; 이면, 모든 디스크 파일을 삭제할 수</span>
<span class="c1"># 있습니다.</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">topdown</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>이 함수는 이제 <a class="reference internal" href="#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal"><span class="pre">os.listdir()</span></code></a> 대신 <a class="reference internal" href="#os.scandir" title="os.scandir"><code class="xref py py-func docutils literal"><span class="pre">os.scandir()</span></code></a>를 호출하기 때문에, <a class="reference internal" href="#os.stat" title="os.stat"><code class="xref py py-func docutils literal"><span class="pre">os.stat()</span></code></a> 호출 수를 줄여 더 빨라졌습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.fwalk">
<code class="descclassname">os.</code><code class="descname">fwalk</code><span class="sig-paren">(</span><em>top='.'</em>, <em>topdown=True</em>, <em>onerror=None</em>, <em>*</em>, <em>follow_symlinks=False</em>, <em>dir_fd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.fwalk" title="정의 주소">¶</a></dt>
<dd><p id="index-23">이 함수는 <a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a>와 똑같이 동작합니다. 단, 4-튜플 <code class="docutils literal"><span class="pre">(dirpath,</span> <span class="pre">dirnames,</span> <span class="pre">filenames,</span> <span class="pre">dirfd)</span></code>를 산출하고 <code class="docutils literal"><span class="pre">dir_fd</span></code>를 지원합니다.</p>
<p><em>dirpath</em> , <em>dirnames</em> 및 <em>filenames</em> 은 <a class="reference internal" href="#os.walk" title="os.walk"><code class="xref py py-func docutils literal"><span class="pre">walk()</span></code></a> 출력과 같고, <em>dirfd</em> 는 <em>dirpath</em> 디렉터리를 가리키는 파일 기술자입니다.</p>
<p>이 함수는 항상 <a class="reference internal" href="#dir-fd"><span class="std std-ref">디렉터리 기술자에 상대적인 경로</span></a> 및 <a class="reference internal" href="#follow-symlinks"><span class="std std-ref">심볼릭 링크를 따르지 않음</span></a>을 지원합니다. 하지만, 다른 함수와는 달리, <em>follow_symlinks</em>에 대한 <a class="reference internal" href="#os.fwalk" title="os.fwalk"><code class="xref py py-func docutils literal"><span class="pre">fwalk()</span></code></a>의 기본값은 <code class="docutils literal"><span class="pre">False</span></code>입에 주의하십시오.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><a class="reference internal" href="#os.fwalk" title="os.fwalk"><code class="xref py py-func docutils literal"><span class="pre">fwalk()</span></code></a>는 다음 이터레이션 단계까지만 유효한 파일 기술자를 산출하기 때문에, 더 오래 유지하려면 복제해야합니다 (예를 들어, <a class="reference internal" href="#os.dup" title="os.dup"><code class="xref py py-func docutils literal"><span class="pre">dup()</span></code></a>로).</p>
</div>
<p>이 예는 시작 디렉터리 아래의 각 디렉터리에 있는 비 디렉터리 파일이 차지한 바이트 수를 표시합니다. 단, CVS 하위 디렉터리 아래는 보지 않습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">rootfd</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">fwalk</span><span class="p">(</span><span class="s1">&#39;python/Lib/email&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;consumes&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dir_fd</span><span class="o">=</span><span class="n">rootfd</span><span class="p">)</span><span class="o">.</span><span class="n">st_size</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]),</span>
          <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;bytes in&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">),</span> <span class="s2">&quot;non-directory files&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;CVS&#39;</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
        <span class="n">dirs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;CVS&#39;</span><span class="p">)</span>  <span class="c1"># CVS 디렉터리는 방문하지 않습니다</span>
</pre></div>
</div>
<p>다음 예에서는, 트리를 상향식으로 탐색하는 것이 필수적입니다: <a class="reference internal" href="#os.rmdir" title="os.rmdir"><code class="xref py py-func docutils literal"><span class="pre">rmdir()</span></code></a>는 비어 있지 않은 디렉터리를 삭제할 수 없습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="c1"># 심볼릭 링크가 없다고 가정하고, &quot;top&quot;으로 지정한 디렉터리에서 도달할 수 있는</span>
<span class="c1"># 모든 것을 삭제합니다.</span>
<span class="c1"># 주의: 위험합니다! 예를 들어, top == &#39;/&#39; 이면, 모든 디스크 파일을 삭제할 수</span>
<span class="c1"># 있습니다.</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">rootfd</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">fwalk</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">topdown</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dir_fd</span><span class="o">=</span><span class="n">rootfd</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dir_fd</span><span class="o">=</span><span class="n">rootfd</span><span class="p">)</span>
</pre></div>
</div>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 경로에 대한 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<div class="section" id="linux-extended-attributes">
<h3>16.1.5.1. 리눅스 확장 어트리뷰트<a class="headerlink" href="#linux-extended-attributes" title="제목 주소">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
<p>이 함수들은 모두 리눅스에서만 사용 가능합니다.</p>
<dl class="function">
<dt id="os.getxattr">
<code class="descclassname">os.</code><code class="descname">getxattr</code><span class="sig-paren">(</span><em>path</em>, <em>attribute</em>, <em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.getxattr" title="정의 주소">¶</a></dt>
<dd><p><em>path</em>의 확장 파일 시스템 어트리뷰트 <em>attribute</em>의 값을 반환합니다. <em>attribute</em> 는 bytes 또는 str(직접적으로 또는 <a class="reference internal" href="#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal"><span class="pre">PathLike</span></code></a> 인터페이스를 통해 간접적으로)일 수 있습니다. str이면, 파일 시스템 인코딩으로 인코딩됩니다.</p>
<p>이 함수는 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자 지정</span></a> 및 <a class="reference internal" href="#follow-symlinks"><span class="std std-ref">심볼릭 링크를 따르지 않음</span></a>을 지원할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><em>path</em> 및 <em>attribute</em>에 대해 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.listxattr">
<code class="descclassname">os.</code><code class="descname">listxattr</code><span class="sig-paren">(</span><em>path=None</em>, <em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.listxattr" title="정의 주소">¶</a></dt>
<dd><p><em>path</em> 의 확장 파일 시스템 어트리뷰트 목록을 반환합니다. 목록의 어트리뷰트는 파일 시스템 인코딩으로 디코딩 된 문자열로 표시됩니다. <em>path</em> 가 <code class="docutils literal"><span class="pre">None</span></code>이면, <a class="reference internal" href="#os.listxattr" title="os.listxattr"><code class="xref py py-func docutils literal"><span class="pre">listxattr()</span></code></a>는 현재 디렉터리를 검사합니다.</p>
<p>이 함수는 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자 지정</span></a> 및 <a class="reference internal" href="#follow-symlinks"><span class="std std-ref">심볼릭 링크를 따르지 않음</span></a>을 지원할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.removexattr">
<code class="descclassname">os.</code><code class="descname">removexattr</code><span class="sig-paren">(</span><em>path</em>, <em>attribute</em>, <em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.removexattr" title="정의 주소">¶</a></dt>
<dd><p><em>path</em> 에서 확장 파일 시스템 어트리뷰트 <em>attribute</em> 을 제거합니다. <em>attribute</em> 는 bytes 또는 str(직접적으로 또는 <a class="reference internal" href="#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal"><span class="pre">PathLike</span></code></a> 인터페이스를 통해 간접적으로)이어야합니다. 문자열이면, 파일 시스템 인코딩으로 인코딩됩니다.</p>
<p>이 함수는 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자 지정</span></a> 및 <a class="reference internal" href="#follow-symlinks"><span class="std std-ref">심볼릭 링크를 따르지 않음</span></a>을 지원할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><em>path</em> 및 <em>attribute</em>에 대해 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.setxattr">
<code class="descclassname">os.</code><code class="descname">setxattr</code><span class="sig-paren">(</span><em>path</em>, <em>attribute</em>, <em>value</em>, <em>flags=0</em>, <em>*</em>, <em>follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#os.setxattr" title="정의 주소">¶</a></dt>
<dd><p><em>path</em> 에있는 확장 파일 시스템 어트리뷰트 <em>attribute</em>를 <em>value</em>로 설정합니다. <em>attribute</em> 는 내장된 NUL이 없는 bytes 또는 str(직접적으로 또는 <a class="reference internal" href="#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal"><span class="pre">PathLike</span></code></a> 인터페이스를 통해 간접적으로)이어야 합니다. str 이면, 파일 시스템 인코딩으로 인코딩됩니다. <em>flags</em> 는 <a class="reference internal" href="#os.XATTR_REPLACE" title="os.XATTR_REPLACE"><code class="xref py py-data docutils literal"><span class="pre">XATTR_REPLACE</span></code></a> 또는 <a class="reference internal" href="#os.XATTR_CREATE" title="os.XATTR_CREATE"><code class="xref py py-data docutils literal"><span class="pre">XATTR_CREATE</span></code></a> 일 수 있습니다. <a class="reference internal" href="#os.XATTR_REPLACE" title="os.XATTR_REPLACE"><code class="xref py py-data docutils literal"><span class="pre">XATTR_REPLACE</span></code></a>가 주어지고 어트리뷰트가 존재하지 않으면, <code class="docutils literal"><span class="pre">EEXISTS</span></code>가 발생합니다. <a class="reference internal" href="#os.XATTR_CREATE" title="os.XATTR_CREATE"><code class="xref py py-data docutils literal"><span class="pre">XATTR_CREATE</span></code></a>가 주어지고 어트리뷰트가 이미 존재하면, 어트리뷰트는 만들어지지 않고 <code class="docutils literal"><span class="pre">ENODATA</span></code>가 발생합니다.</p>
<p>이 함수는 <a class="reference internal" href="#path-fd"><span class="std std-ref">파일 기술자 지정</span></a> 및 <a class="reference internal" href="#follow-symlinks"><span class="std std-ref">심볼릭 링크를 따르지 않음</span></a>을 지원할 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">리눅스 커널 버전 2.6.39 미만의 버그로 인해 flags 인자가 일부 파일 시스템에서 무시되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><em>path</em> 및 <em>attribute</em>에 대해 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.XATTR_SIZE_MAX">
<code class="descclassname">os.</code><code class="descname">XATTR_SIZE_MAX</code><a class="headerlink" href="#os.XATTR_SIZE_MAX" title="정의 주소">¶</a></dt>
<dd><p>확장 어트리뷰트 값의 최대 크기입니다. 현재, 리눅스에서 64 KiB입니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.XATTR_CREATE">
<code class="descclassname">os.</code><code class="descname">XATTR_CREATE</code><a class="headerlink" href="#os.XATTR_CREATE" title="정의 주소">¶</a></dt>
<dd><p>이것은 <a class="reference internal" href="#os.setxattr" title="os.setxattr"><code class="xref py py-func docutils literal"><span class="pre">setxattr()</span></code></a>의 flags 인자를 위한 값입니다. 연산이 반드시 어트리뷰트를 새로 만들어야 함을 나타냅니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.XATTR_REPLACE">
<code class="descclassname">os.</code><code class="descname">XATTR_REPLACE</code><a class="headerlink" href="#os.XATTR_REPLACE" title="정의 주소">¶</a></dt>
<dd><p>이것은 <a class="reference internal" href="#os.setxattr" title="os.setxattr"><code class="xref py py-func docutils literal"><span class="pre">setxattr()</span></code></a>의 flags 인자를 위한 값입니다. 연산이 반드시 기존 어트리뷰트를 대체해야 함을 나타냅니다.</p>
</dd></dl>

</div>
</div>
<div class="section" id="process-management">
<span id="os-process"></span><h2>16.1.6. 프로세스 관리<a class="headerlink" href="#process-management" title="제목 주소">¶</a></h2>
<p>이 함수들은 프로세스를 만들고 관리하는데 사용될 수 있습니다.</p>
<p>다양한 <a class="reference internal" href="#os.execl" title="os.execl"><code class="xref py py-func docutils literal"><span class="pre">exec*</span></code></a> 함수는 프로세스로 로드되는 새 프로그램에 대한 인자 목록을 받아들입니다. 각각의 경우에, 첫 번째 인자는 사용자가 명령 줄에 입력할 수 있는인자가 아닌 프로그램 자체의 이름으로 새 프로그램에 전달됩니다. C 프로그래머에게, 이것은 프로그램의 <code class="xref c c-func docutils literal"><span class="pre">main()</span></code>에 전달된 <code class="docutils literal"><span class="pre">argv[0]</span></code>입니다. 예를 들어, <code class="docutils literal"><span class="pre">os.execv('/bin/echo',</span> <span class="pre">['foo',</span> <span class="pre">'bar'])</span></code>는 표준 출력에 <code class="docutils literal"><span class="pre">bar</span></code>만 인쇄합니다; <code class="docutils literal"><span class="pre">foo</span></code>는 무시되는 것처럼 보이게됩니다.</p>
<dl class="function">
<dt id="os.abort">
<code class="descclassname">os.</code><code class="descname">abort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.abort" title="정의 주소">¶</a></dt>
<dd><p>현재 프로세스에 <code class="xref py py-const docutils literal"><span class="pre">SIGABRT</span></code> 시그널을 생성합니다. 유닉스에서, 기본 동작은 코어 덤프를 생성하는 것입니다; 윈도우에서, 프로세스는 즉시 종료 코드 <code class="docutils literal"><span class="pre">3</span></code>을 반환합니다. 이 함수를 호출하면 <a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal"><span class="pre">signal.signal()</span></code></a>를 사용하여 <code class="xref py py-const docutils literal"><span class="pre">SIGABRT</span></code>에 등록 된 파이썬 시그널 처리기를 호출하지 않게됨에 주의하시기 바랍니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.execl">
<code class="descclassname">os.</code><code class="descname">execl</code><span class="sig-paren">(</span><em>path</em>, <em>arg0</em>, <em>arg1</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#os.execl" title="정의 주소">¶</a></dt>
<dt id="os.execle">
<code class="descclassname">os.</code><code class="descname">execle</code><span class="sig-paren">(</span><em>path</em>, <em>arg0</em>, <em>arg1</em>, <em>...</em>, <em>env</em><span class="sig-paren">)</span><a class="headerlink" href="#os.execle" title="정의 주소">¶</a></dt>
<dt id="os.execlp">
<code class="descclassname">os.</code><code class="descname">execlp</code><span class="sig-paren">(</span><em>file</em>, <em>arg0</em>, <em>arg1</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#os.execlp" title="정의 주소">¶</a></dt>
<dt id="os.execlpe">
<code class="descclassname">os.</code><code class="descname">execlpe</code><span class="sig-paren">(</span><em>file</em>, <em>arg0</em>, <em>arg1</em>, <em>...</em>, <em>env</em><span class="sig-paren">)</span><a class="headerlink" href="#os.execlpe" title="정의 주소">¶</a></dt>
<dt id="os.execv">
<code class="descclassname">os.</code><code class="descname">execv</code><span class="sig-paren">(</span><em>path</em>, <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#os.execv" title="정의 주소">¶</a></dt>
<dt id="os.execve">
<code class="descclassname">os.</code><code class="descname">execve</code><span class="sig-paren">(</span><em>path</em>, <em>args</em>, <em>env</em><span class="sig-paren">)</span><a class="headerlink" href="#os.execve" title="정의 주소">¶</a></dt>
<dt id="os.execvp">
<code class="descclassname">os.</code><code class="descname">execvp</code><span class="sig-paren">(</span><em>file</em>, <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#os.execvp" title="정의 주소">¶</a></dt>
<dt id="os.execvpe">
<code class="descclassname">os.</code><code class="descname">execvpe</code><span class="sig-paren">(</span><em>file</em>, <em>args</em>, <em>env</em><span class="sig-paren">)</span><a class="headerlink" href="#os.execvpe" title="정의 주소">¶</a></dt>
<dd><p>이 함수들은 모두 현재 프로세스를 대체해서 새로운 프로그램을 실행합니다; 반환되지 않습니다. 유닉스에서, 새로운 실행 파일이 현재 프로세스에 로드되고, 호출자와 같은 프로세스 ID를 갖게됩니다. 에러는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> 예외로 보고됩니다.</p>
<p>현재 프로세스가 즉시 교체됩니다. 열린 파일 객체와 기술자는 플러시되지 않으므로, 이러한 열린 파일에 버퍼링 된 데이터가 있으면, <a class="reference internal" href="#os.execl" title="os.execl"><code class="xref py py-func docutils literal"><span class="pre">exec*</span></code></a> 함수를 호출하기 전에 <code class="xref py py-func docutils literal"><span class="pre">sys.stdout.flush()</span></code> 또는 <a class="reference internal" href="#os.fsync" title="os.fsync"><code class="xref py py-func docutils literal"><span class="pre">os.fsync()</span></code></a>를 사용하여 플러시해야합니다.</p>
<p><a class="reference internal" href="#os.execl" title="os.execl"><code class="xref py py-func docutils literal"><span class="pre">exec*</span></code></a> 함수의 &quot;l&quot; 및 &quot;v&quot; 변형은 명령 줄 인자가 전달되는 방식이 다릅니다. &quot;l&quot; 변형은 아마도 코드가 작성 될 때 매개 변수의 수가 고정되어 있다면 가장 작업하기 쉬운 것입니다; 개별 매개 변수는 단순히 <code class="xref py py-func docutils literal"><span class="pre">execl*()</span></code> 함수에 대한 추가 매개 변수가 됩니다. &quot;v&quot; 변형은 매개 변수의 개수가 가변적일 때 좋으며, 리스트나 튜플에 들어있는 인자가 <em>args</em> 매개 변수로 전달됩니다. 두 경우 모두, 자식 프로세스에 대한 인자는 실행중인 명령의 이름으로 시작해야하지만, 강제되지는 않습니다.</p>
<p>끝 근처에 &quot;p&quot;가 포함된 변형(<a class="reference internal" href="#os.execlp" title="os.execlp"><code class="xref py py-func docutils literal"><span class="pre">execlp()</span></code></a>, <a class="reference internal" href="#os.execlpe" title="os.execlpe"><code class="xref py py-func docutils literal"><span class="pre">execlpe()</span></code></a>, <a class="reference internal" href="#os.execvp" title="os.execvp"><code class="xref py py-func docutils literal"><span class="pre">execvp()</span></code></a> 및 <a class="reference internal" href="#os.execvpe" title="os.execvpe"><code class="xref py py-func docutils literal"><span class="pre">execvpe()</span></code></a>)은 <span class="target" id="index-56"></span><code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code> 환경 변수를 사용하여 프로그램 <em>file</em> 을 찾습니다. 환경이 대체 될 때 (다음 단락에서 설명 할 <a class="reference internal" href="#os.execl" title="os.execl"><code class="xref py py-func docutils literal"><span class="pre">exec*e</span></code></a> 변형 중 하나를 사용하여), 새 환경이 <span class="target" id="index-57"></span><code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code> 변수의 소스로 사용됩니다. 다른 변형 <a class="reference internal" href="#os.execl" title="os.execl"><code class="xref py py-func docutils literal"><span class="pre">execl()</span></code></a>, <a class="reference internal" href="#os.execle" title="os.execle"><code class="xref py py-func docutils literal"><span class="pre">execle()</span></code></a>, <a class="reference internal" href="#os.execv" title="os.execv"><code class="xref py py-func docutils literal"><span class="pre">execv()</span></code></a> 및 <a class="reference internal" href="#os.execve" title="os.execve"><code class="xref py py-func docutils literal"><span class="pre">execve()</span></code></a>는 <span class="target" id="index-58"></span><code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code> 변수를 사용하여 실행 파일을 찾지않습니다; <em>path</em> 에는 반드시 적절한 절대 또는 상대 경로가 있어야 합니다.</p>
<p><a class="reference internal" href="#os.execle" title="os.execle"><code class="xref py py-func docutils literal"><span class="pre">execle()</span></code></a>, <a class="reference internal" href="#os.execlpe" title="os.execlpe"><code class="xref py py-func docutils literal"><span class="pre">execlpe()</span></code></a>, <a class="reference internal" href="#os.execve" title="os.execve"><code class="xref py py-func docutils literal"><span class="pre">execve()</span></code></a>, <a class="reference internal" href="#os.execvpe" title="os.execvpe"><code class="xref py py-func docutils literal"><span class="pre">execvpe()</span></code></a>의 경우 (모두 &quot;e&quot;로 끝납니다), <em>env</em> 매개 변수는 새 프로세스의 환경 변수를 정의하는 데 사용되는 매핑이어야합니다 (이 것이 현재 프로세스의 환경대신 사용됩니다); 함수 <a class="reference internal" href="#os.execl" title="os.execl"><code class="xref py py-func docutils literal"><span class="pre">execl()</span></code></a>, <a class="reference internal" href="#os.execlp" title="os.execlp"><code class="xref py py-func docutils literal"><span class="pre">execlp()</span></code></a>, <a class="reference internal" href="#os.execv" title="os.execv"><code class="xref py py-func docutils literal"><span class="pre">execv()</span></code></a> 및 <a class="reference internal" href="#os.execvp" title="os.execvp"><code class="xref py py-func docutils literal"><span class="pre">execvp()</span></code></a>는 모두 새 프로세스가 현재 프로세스의 환경을 상속하게합니다.</p>
<p>일부 플랫폼에서 <a class="reference internal" href="#os.execve" title="os.execve"><code class="xref py py-func docutils literal"><span class="pre">execve()</span></code></a>의 경우, <em>path</em> 는 열린 파일 기술자로도 지정 될 수 있습니다. 이 기능은 여러분의 플랫폼에서 지원되지 않을 수 있습니다; <a class="reference internal" href="#os.supports_fd" title="os.supports_fd"><code class="xref py py-data docutils literal"><span class="pre">os.supports_fd</span></code></a>를 사용하여 사용할 수 있는지를 확인할 수 있습니다. 사용할 수 없을 때, 이를 사용하면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>가 발생합니다.</p>
<p>가용성: 유닉스, 윈도우.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><a class="reference internal" href="#os.execve" title="os.execve"><code class="xref py py-func docutils literal"><span class="pre">execve()</span></code></a>의 <em>path</em>에 열린 파일 기술자를 지정하는 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os._exit">
<code class="descclassname">os.</code><code class="descname">_exit</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#os._exit" title="정의 주소">¶</a></dt>
<dd><p>상태 <em>n</em>으로 프로세스를 종료합니다. 클린업 처리기를 호출하거나, stdio 버퍼를 플러시하거나 등등은 수행하지 않습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">종료하는 표준 방법은 <code class="docutils literal"><span class="pre">sys.exit(n)</span></code>입니다. <a class="reference internal" href="#os._exit" title="os._exit"><code class="xref py py-func docutils literal"><span class="pre">_exit()</span></code></a>는 일반적으로 <a class="reference internal" href="#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">fork()</span></code></a> 이후의 자식 프로세스에서만 사용해야합니다.</p>
</div>
</dd></dl>

<p>필수 조건은 아니지만, 다음 종료 코드가 정의되어 있으며 <a class="reference internal" href="#os._exit" title="os._exit"><code class="xref py py-func docutils literal"><span class="pre">_exit()</span></code></a>와 함께 사용할 수 있습니다. 이것은 메일 서버의 외부 명령 배달 프로그램과 같이 파이썬으로 작성된 시스템 프로그램에서 일반적으로 사용됩니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">약간의 변형이 있기 때문에, 이들 중 일부는 모든 유닉스 플랫폼에서 사용 가능하지 않을 수 있습니다. 이 상수는 하부 플랫폼에서 정의될 때만 정의됩니다.</p>
</div>
<dl class="data">
<dt id="os.EX_OK">
<code class="descclassname">os.</code><code class="descname">EX_OK</code><a class="headerlink" href="#os.EX_OK" title="정의 주소">¶</a></dt>
<dd><p>에러가 발생하지 않았음을 나타내는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_USAGE">
<code class="descclassname">os.</code><code class="descname">EX_USAGE</code><a class="headerlink" href="#os.EX_USAGE" title="정의 주소">¶</a></dt>
<dd><p>잘못된 개수의 인자가 제공된 경우처럼, 명령이 잘못 사용되었음을 나타내는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_DATAERR">
<code class="descclassname">os.</code><code class="descname">EX_DATAERR</code><a class="headerlink" href="#os.EX_DATAERR" title="정의 주소">¶</a></dt>
<dd><p>입력 데이터가 잘못되었음을 나타내는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_NOINPUT">
<code class="descclassname">os.</code><code class="descname">EX_NOINPUT</code><a class="headerlink" href="#os.EX_NOINPUT" title="정의 주소">¶</a></dt>
<dd><p>입력 파일이 없거나 읽을 수 없음을 나타내는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_NOUSER">
<code class="descclassname">os.</code><code class="descname">EX_NOUSER</code><a class="headerlink" href="#os.EX_NOUSER" title="정의 주소">¶</a></dt>
<dd><p>지정된 사용자가 존재하지 않음을 나타내는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_NOHOST">
<code class="descclassname">os.</code><code class="descname">EX_NOHOST</code><a class="headerlink" href="#os.EX_NOHOST" title="정의 주소">¶</a></dt>
<dd><p>지정된 호스트가 존재하지 않음을 나타내는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_UNAVAILABLE">
<code class="descclassname">os.</code><code class="descname">EX_UNAVAILABLE</code><a class="headerlink" href="#os.EX_UNAVAILABLE" title="정의 주소">¶</a></dt>
<dd><p>필수 서비스를 사용할 수 없음을 나타내는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_SOFTWARE">
<code class="descclassname">os.</code><code class="descname">EX_SOFTWARE</code><a class="headerlink" href="#os.EX_SOFTWARE" title="정의 주소">¶</a></dt>
<dd><p>내부 소프트웨어 에러가 감지되었음을 나타내는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_OSERR">
<code class="descclassname">os.</code><code class="descname">EX_OSERR</code><a class="headerlink" href="#os.EX_OSERR" title="정의 주소">¶</a></dt>
<dd><p>포크하거나 파이프를 만들 수 없는 등, 운영 체제 에러가 감지되었음을 나타내는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_OSFILE">
<code class="descclassname">os.</code><code class="descname">EX_OSFILE</code><a class="headerlink" href="#os.EX_OSFILE" title="정의 주소">¶</a></dt>
<dd><p>일부 시스템 파일이 없거나, 열 수 없거나, 다른 종류의 에러가 있음을 나타내는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_CANTCREAT">
<code class="descclassname">os.</code><code class="descname">EX_CANTCREAT</code><a class="headerlink" href="#os.EX_CANTCREAT" title="정의 주소">¶</a></dt>
<dd><p>사용자가 지정한 출력 파일을 만들 수 없음을 나타내는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_IOERR">
<code class="descclassname">os.</code><code class="descname">EX_IOERR</code><a class="headerlink" href="#os.EX_IOERR" title="정의 주소">¶</a></dt>
<dd><p>일부 파일에서 I/O를 수행하는 동안 에러가 발생했음을 나타내는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_TEMPFAIL">
<code class="descclassname">os.</code><code class="descname">EX_TEMPFAIL</code><a class="headerlink" href="#os.EX_TEMPFAIL" title="정의 주소">¶</a></dt>
<dd><p>임시 에러가 발생했음을 나타내는 종료 코드. 이는 재 시도 가능한 작업 중에 만들 수 없었던 네트워크 연결과 같이 실제로는 에러가 아닐 수있는 것을 나타냅니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_PROTOCOL">
<code class="descclassname">os.</code><code class="descname">EX_PROTOCOL</code><a class="headerlink" href="#os.EX_PROTOCOL" title="정의 주소">¶</a></dt>
<dd><p>프로토콜 교환이 불법이거나 유효하지 않거나 이해되지 않았 음을 나타내는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_NOPERM">
<code class="descclassname">os.</code><code class="descname">EX_NOPERM</code><a class="headerlink" href="#os.EX_NOPERM" title="정의 주소">¶</a></dt>
<dd><p>작업을 수행 할 수 있는 권한이 충분하지 않음을 나타내는 종료 코드 (파일 시스템 문제에는 사용하지 않습니다).</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_CONFIG">
<code class="descclassname">os.</code><code class="descname">EX_CONFIG</code><a class="headerlink" href="#os.EX_CONFIG" title="정의 주소">¶</a></dt>
<dd><p>어떤 종류의 구성 에러가 발생했음을 나타내는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.EX_NOTFOUND">
<code class="descclassname">os.</code><code class="descname">EX_NOTFOUND</code><a class="headerlink" href="#os.EX_NOTFOUND" title="정의 주소">¶</a></dt>
<dd><p>&quot;항목을 찾을 수 없습니다&quot;와 같은 것을 의미하는 종료 코드.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.fork">
<code class="descclassname">os.</code><code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.fork" title="정의 주소">¶</a></dt>
<dd><p>자식 프로세스를 포크합니다. 자식에서는 <code class="docutils literal"><span class="pre">0</span></code>을 반환하고, 부모에서는 자식의 프로세스 ID를 반환합니다. 에러가 발생하면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>를 일으킵니다.</p>
<p>FreeBSD &lt;= 6.3 및 Cygwin을 포함한 일부 플랫폼은 스레드에서 fork()를 사용할 때 알려진 문제점이 있습니다.</p>
<div class="admonition warning">
<p class="first admonition-title">경고</p>
<p class="last">fork()와 함께 SSL 모듈을 사용하는 응용 프로그램의 경우 <a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal"><span class="pre">ssl</span></code></a>를 참조하십시오.</p>
</div>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.forkpty">
<code class="descclassname">os.</code><code class="descname">forkpty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.forkpty" title="정의 주소">¶</a></dt>
<dd><p>새 의사 터미널을 자식의 제어 터미널로 사용하여 자식 프로세스를 포크합니다. <code class="docutils literal"><span class="pre">(pid,</span> <span class="pre">fd)</span></code> 쌍을 반환하는데, 여기서 <em>pid</em> 는 자식에서 <code class="docutils literal"><span class="pre">0</span></code>이고, 부모에서는 새 자식의 프로세스 ID이고, <em>fd</em> 는 의사 터미널의 마스터단의 파일 기술자입니다. 좀 더 이식성있는 접근법을 사용하려면, <a class="reference internal" href="pty.html#module-pty" title="pty: Pseudo-Terminal Handling for Linux. (Linux)"><code class="xref py py-mod docutils literal"><span class="pre">pty</span></code></a> 모듈을 사용하십시오. 에러가 발생하면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>를 일으킵니다.</p>
<p>가용성: 일부 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.kill">
<code class="descclassname">os.</code><code class="descname">kill</code><span class="sig-paren">(</span><em>pid</em>, <em>sig</em><span class="sig-paren">)</span><a class="headerlink" href="#os.kill" title="정의 주소">¶</a></dt>
<dd><p id="index-27">프로세스 <em>pid</em>에 시그널 <em>sig</em>를 보냅니다. 호스트 플랫폼에서 사용할 수 있는 구체적인 시그널에 대한 상수는 <a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal"><span class="pre">signal</span></code></a> 모듈에 정의되어 있습니다.</p>
<p>윈도우: <a class="reference internal" href="signal.html#signal.CTRL_C_EVENT" title="signal.CTRL_C_EVENT"><code class="xref py py-data docutils literal"><span class="pre">signal.CTRL_C_EVENT</span></code></a> 및 <a class="reference internal" href="signal.html#signal.CTRL_BREAK_EVENT" title="signal.CTRL_BREAK_EVENT"><code class="xref py py-data docutils literal"><span class="pre">signal.CTRL_BREAK_EVENT</span></code></a> 시그널은 같은 콘솔 창을 공유하는 콘솔 프로세스(예를 들어, 일부 자식 프로세스)로만 보낼 수있는 특수 시그널입니다. <em>sig</em>에 대한 다른 값은, 프로세스가 TerminateProcess API에 의해 무조건 종료되게하고, 종료 코드는 <em>sig</em> 로 설정됩니다. 윈도우 버전의 <a class="reference internal" href="#os.kill" title="os.kill"><code class="xref py py-func docutils literal"><span class="pre">kill()</span></code></a>은 종료시킬 프로세스 핸들도 받아들입니다.</p>
<p><a class="reference internal" href="signal.html#signal.pthread_kill" title="signal.pthread_kill"><code class="xref py py-func docutils literal"><span class="pre">signal.pthread_kill()</span></code></a>도 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span>윈도우 지원.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.killpg">
<code class="descclassname">os.</code><code class="descname">killpg</code><span class="sig-paren">(</span><em>pgid</em>, <em>sig</em><span class="sig-paren">)</span><a class="headerlink" href="#os.killpg" title="정의 주소">¶</a></dt>
<dd><p id="index-28">시그널 <em>sig</em> 를 프로세스 그룹 <em>pgid</em> 로 보냅니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.nice">
<code class="descclassname">os.</code><code class="descname">nice</code><span class="sig-paren">(</span><em>increment</em><span class="sig-paren">)</span><a class="headerlink" href="#os.nice" title="정의 주소">¶</a></dt>
<dd><p>프로세스의 &quot;우선도(niceness)&quot;에 <em>increment</em> 을 추가합니다. 새로운 우선도를 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.plock">
<code class="descclassname">os.</code><code class="descname">plock</code><span class="sig-paren">(</span><em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#os.plock" title="정의 주소">¶</a></dt>
<dd><p>프로그램 세그먼트를 메모리에 잠급니다. (<code class="docutils literal"><span class="pre">&lt;sys/lock.h&gt;</span></code>에서 정의된) <em>op</em> 값은 잠기는 세그먼트를 판별합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.popen">
<code class="descclassname">os.</code><code class="descname">popen</code><span class="sig-paren">(</span><em>cmd</em>, <em>mode='r'</em>, <em>buffering=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#os.popen" title="정의 주소">¶</a></dt>
<dd><p>명령 <em>cmd</em>와의 파이프 연결을 엽니다. 반환 값은 파이프에 연결된 열린 파일 객체이며, <em>mode</em> 가 <code class="docutils literal"><span class="pre">'r'``(기본값)인지</span> <span class="pre">``'w'</span></code>인지에 따라 읽거나 쓸 수 있습니다. <em>buffering</em> 인자는 내장 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> 함수에서와 같은 의미를 갖습니다. 반환 된 파일 객체는 바이트열이 아닌 텍스트 문자열을 읽거나 씁니다.</p>
<p><code class="docutils literal"><span class="pre">close</span></code> 메서드는 자식 프로세스가 성공적으로 종료되면 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>을 반환하고, 에러가 있으면 자식 프로세스가 반환한 코드를 반환합니다. POSIX 시스템에서, 반환 코드가 양수면, 프로세스의 반환 값을 1 바이트 왼쪽으로 시프트한 값을 나타냅니다. 반환 코드가 음수면, 음의 반환 코드로 주어진 시그널에 의해 강제 종료된 것입니다. 예를 들어, 서브 프로세스가 킬된 경우 반환 값은 <code class="docutils literal"><span class="pre">-</span> <span class="pre">signal.SIGKILL</span></code> 일 수 있습니다. 윈도우 시스템에서, 반환 값은 자식 프로세스의 부호있는 정수 반환 코드를 포함합니다.</p>
<p>이것은 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal"><span class="pre">subprocess.Popen</span></code></a>를 사용하여 구현됩니다; 자식 프로세스를 관리하고 통신하는 보다 강력한 방법에 대해서는 이 클래스의 설명서를 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="os.register_at_fork">
<code class="descclassname">os.</code><code class="descname">register_at_fork</code><span class="sig-paren">(</span><em>*</em>, <em>before=None</em>, <em>after_in_parent=None</em>, <em>after_in_child=None</em><span class="sig-paren">)</span><a class="headerlink" href="#os.register_at_fork" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">os.fork()</span></code></a> 또는 유사한 프로세스 복제 API를 사용하여 새 자식 프로세스가 포크될 때 실행될 콜러블들을 등록합니다. 매개 변수는 선택적이며 키워드 전용입니다. 각각은 다른 호출 지점을 지정합니다.</p>
<ul class="simple">
<li><em>before</em> 는 자식 프로세스를 포크하기 전에 호출되는 함수입니다.</li>
<li><em>after_in_parent</em> 는 자식 프로세스를 포크한 후에 부모 프로세스에서 호출되는 함수입니다.</li>
<li><em>after_in_child</em> 는 자식 프로세스에서 호출되는 함수입니다.</li>
</ul>
<p>이러한 호출은 제거가 파이썬 인터프리터로 반환 될 것으로 예상되는 경우에만 수행됩니다. 일반적인 <a class="reference internal" href="subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a> 실행은 자식이 인터프리터로 재진입하지 않기 때문에, 이 호출들이 일어나지 않습니다.</p>
<p>포크 이전에 실행되도록 등록 된 함수는 등록 역순으로 실행됩니다. 포크 후에 실행되도록 등록 된 함수(부모나 자식 모두)는 등록 순서로 호출됩니다.</p>
<p>제삼자 C 코드에의한 <code class="xref c c-func docutils literal"><span class="pre">fork()</span></code> 호출은, 그 것이 명시적으로 <a class="reference internal" href="../c-api/sys.html#c.PyOS_BeforeFork" title="PyOS_BeforeFork"><code class="xref c c-func docutils literal"><span class="pre">PyOS_BeforeFork()</span></code></a>, <a class="reference internal" href="../c-api/sys.html#c.PyOS_AfterFork_Parent" title="PyOS_AfterFork_Parent"><code class="xref c c-func docutils literal"><span class="pre">PyOS_AfterFork_Parent()</span></code></a> 및 <a class="reference internal" href="../c-api/sys.html#c.PyOS_AfterFork_Child" title="PyOS_AfterFork_Child"><code class="xref c c-func docutils literal"><span class="pre">PyOS_AfterFork_Child()</span></code></a>를 호출하지 않는 한, 이 함수들을 호출하지 않습니다.</p>
<p>함수 등록을 취소 할 수 있는 방법은 없습니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.spawnl">
<code class="descclassname">os.</code><code class="descname">spawnl</code><span class="sig-paren">(</span><em>mode</em>, <em>path</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#os.spawnl" title="정의 주소">¶</a></dt>
<dt id="os.spawnle">
<code class="descclassname">os.</code><code class="descname">spawnle</code><span class="sig-paren">(</span><em>mode</em>, <em>path</em>, <em>...</em>, <em>env</em><span class="sig-paren">)</span><a class="headerlink" href="#os.spawnle" title="정의 주소">¶</a></dt>
<dt id="os.spawnlp">
<code class="descclassname">os.</code><code class="descname">spawnlp</code><span class="sig-paren">(</span><em>mode</em>, <em>file</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#os.spawnlp" title="정의 주소">¶</a></dt>
<dt id="os.spawnlpe">
<code class="descclassname">os.</code><code class="descname">spawnlpe</code><span class="sig-paren">(</span><em>mode</em>, <em>file</em>, <em>...</em>, <em>env</em><span class="sig-paren">)</span><a class="headerlink" href="#os.spawnlpe" title="정의 주소">¶</a></dt>
<dt id="os.spawnv">
<code class="descclassname">os.</code><code class="descname">spawnv</code><span class="sig-paren">(</span><em>mode</em>, <em>path</em>, <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#os.spawnv" title="정의 주소">¶</a></dt>
<dt id="os.spawnve">
<code class="descclassname">os.</code><code class="descname">spawnve</code><span class="sig-paren">(</span><em>mode</em>, <em>path</em>, <em>args</em>, <em>env</em><span class="sig-paren">)</span><a class="headerlink" href="#os.spawnve" title="정의 주소">¶</a></dt>
<dt id="os.spawnvp">
<code class="descclassname">os.</code><code class="descname">spawnvp</code><span class="sig-paren">(</span><em>mode</em>, <em>file</em>, <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#os.spawnvp" title="정의 주소">¶</a></dt>
<dt id="os.spawnvpe">
<code class="descclassname">os.</code><code class="descname">spawnvpe</code><span class="sig-paren">(</span><em>mode</em>, <em>file</em>, <em>args</em>, <em>env</em><span class="sig-paren">)</span><a class="headerlink" href="#os.spawnvpe" title="정의 주소">¶</a></dt>
<dd><p>새 프로세스에서 프로그램 <em>path</em> 를 실행합니다.</p>
<p>(<a class="reference internal" href="subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a> 모듈은 새 프로세스를 생성하고 결과를 조회하는 데, 보다 강력한 기능을 제공합니다; 이 모듈을 사용하는 것이 이 함수들을 사용하는 것보다 더 바람직합니다. 특히 <a class="reference internal" href="subprocess.html#subprocess-replacements"><span class="std std-ref">Replacing Older Functions with the subprocess Module</span></a> 섹션을 확인하십시오.)</p>
<p><em>mode</em> 가 <a class="reference internal" href="#os.P_NOWAIT" title="os.P_NOWAIT"><code class="xref py py-const docutils literal"><span class="pre">P_NOWAIT</span></code></a>면, 이 함수는 새 프로세스의 프로세스 ID를 반환합니다; <em>mode</em>가 <a class="reference internal" href="#os.P_WAIT" title="os.P_WAIT"><code class="xref py py-const docutils literal"><span class="pre">P_WAIT</span></code></a>면, 종료 코드(정상적으로 종료했을 때)나 <code class="docutils literal"><span class="pre">-signal</span></code>(<em>signal</em>은 프로세스를 죽인 시스널입니다)을 반환합니다. 윈도우에서, 프로세스 ID는 실제로 프로세스 핸들이므로, <a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a> 함수에 사용할 수 있습니다.</p>
<p><a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*</span></code></a> 함수의 &quot;l&quot; 및 &quot;v&quot; 변형은 명령 줄 인자가 전달되는 방식이 다릅니다. &quot;l&quot; 변형은 아마도 코드가 작성 될 때 매개 변수의 수가 고정되어 있다면 가장 작업하기 쉬운 것입니다; 개별 매개 변수는 단순히 <code class="xref py py-func docutils literal"><span class="pre">spawnl*()</span></code> 함수에 대한 추가 매개 변수가 됩니다. &quot;v&quot; 변형은 매개 변수의 개수가 가변적일 때 좋으며, 리스트나 튜플에 들어있는 인자가 <em>args</em> 매개 변수로 전달됩니다. 두 경우 모두, 자식 프로세스에 대한 인자는 반드시 실행중인 명령의 이름으로 시작해야합니다.</p>
<p>끝 근처에 두번째 &quot;p&quot;가 포함된 변형(<a class="reference internal" href="#os.spawnlp" title="os.spawnlp"><code class="xref py py-func docutils literal"><span class="pre">spawnlp()</span></code></a>, <a class="reference internal" href="#os.spawnlpe" title="os.spawnlpe"><code class="xref py py-func docutils literal"><span class="pre">spawnlpe()</span></code></a>, <a class="reference internal" href="#os.spawnvp" title="os.spawnvp"><code class="xref py py-func docutils literal"><span class="pre">spawnvp()</span></code></a> 및 <a class="reference internal" href="#os.spawnvpe" title="os.spawnvpe"><code class="xref py py-func docutils literal"><span class="pre">spawnvpe()</span></code></a>)은 <span class="target" id="index-59"></span><code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code> 환경 변수를 사용하여 프로그램 <em>file</em> 을 찾습니다. 환경이 대체 될 때 (다음 단락에서 설명 할 <a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*e</span></code></a> 변형 중 하나를 사용하여), 새 환경이 <span class="target" id="index-60"></span><code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code> 변수의 소스로 사용됩니다. 다른 변형 <a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawnl()</span></code></a>, <a class="reference internal" href="#os.spawnle" title="os.spawnle"><code class="xref py py-func docutils literal"><span class="pre">spawnle()</span></code></a>, <a class="reference internal" href="#os.spawnv" title="os.spawnv"><code class="xref py py-func docutils literal"><span class="pre">spawnv()</span></code></a> 및 <a class="reference internal" href="#os.spawnve" title="os.spawnve"><code class="xref py py-func docutils literal"><span class="pre">spawnve()</span></code></a>는 <span class="target" id="index-61"></span><code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code> 변수를 사용하여 실행 파일을 찾지않습니다; <em>path</em> 에는 반드시 적절한 절대 또는 상대 경로가 있어야 합니다.</p>
<p><a class="reference internal" href="#os.spawnle" title="os.spawnle"><code class="xref py py-func docutils literal"><span class="pre">spawnle()</span></code></a>, <a class="reference internal" href="#os.spawnlpe" title="os.spawnlpe"><code class="xref py py-func docutils literal"><span class="pre">spawnlpe()</span></code></a>, <a class="reference internal" href="#os.spawnve" title="os.spawnve"><code class="xref py py-func docutils literal"><span class="pre">spawnve()</span></code></a> 및 <a class="reference internal" href="#os.spawnvpe" title="os.spawnvpe"><code class="xref py py-func docutils literal"><span class="pre">spawnvpe()</span></code></a>의 경우 (모두 &quot;e&quot;로 끝납니다), <em>env</em> 매개 변수는 새 프로세스의 환경 변수를 정의하는 데 사용되는 매핑이어야합니다 (이 것이 현재 프로세스의 환경대신 사용됩니다); 함수 <a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawnl()</span></code></a>, <a class="reference internal" href="#os.spawnlp" title="os.spawnlp"><code class="xref py py-func docutils literal"><span class="pre">spawnlp()</span></code></a>, <a class="reference internal" href="#os.spawnv" title="os.spawnv"><code class="xref py py-func docutils literal"><span class="pre">spawnv()</span></code></a> 및 <a class="reference internal" href="#os.spawnvp" title="os.spawnvp"><code class="xref py py-func docutils literal"><span class="pre">spawnvp()</span></code></a>는 모두 새 프로세스가 현재 프로세스의 환경을 상속하게합니다. <em>env</em> 딕셔너리의 키와 값은 반드시 문자열이어야함에 주의하십시오; 잘못된 키나 값은 반환값 <code class="docutils literal"><span class="pre">127</span></code>로 함수가 실패하게 합니다.</p>
<p>예를 들어, <a class="reference internal" href="#os.spawnlp" title="os.spawnlp"><code class="xref py py-func docutils literal"><span class="pre">spawnlp()</span></code></a> 및 <a class="reference internal" href="#os.spawnvpe" title="os.spawnvpe"><code class="xref py py-func docutils literal"><span class="pre">spawnvpe()</span></code></a>에 대한 다음 호출은 동등합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="n">os</span><span class="o">.</span><span class="n">spawnlp</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">P_WAIT</span><span class="p">,</span> <span class="s1">&#39;cp&#39;</span><span class="p">,</span> <span class="s1">&#39;cp&#39;</span><span class="p">,</span> <span class="s1">&#39;index.html&#39;</span><span class="p">,</span> <span class="s1">&#39;/dev/null&#39;</span><span class="p">)</span>

<span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cp&#39;</span><span class="p">,</span> <span class="s1">&#39;index.html&#39;</span><span class="p">,</span> <span class="s1">&#39;/dev/null&#39;</span><span class="p">]</span>
<span class="n">os</span><span class="o">.</span><span class="n">spawnvpe</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">P_WAIT</span><span class="p">,</span> <span class="s1">&#39;cp&#39;</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">)</span>
</pre></div>
</div>
<p>가용성: 유닉스, 윈도우. <a class="reference internal" href="#os.spawnlp" title="os.spawnlp"><code class="xref py py-func docutils literal"><span class="pre">spawnlp()</span></code></a>, <a class="reference internal" href="#os.spawnlpe" title="os.spawnlpe"><code class="xref py py-func docutils literal"><span class="pre">spawnlpe()</span></code></a>, <a class="reference internal" href="#os.spawnvp" title="os.spawnvp"><code class="xref py py-func docutils literal"><span class="pre">spawnvp()</span></code></a>, <a class="reference internal" href="#os.spawnvpe" title="os.spawnvpe"><code class="xref py py-func docutils literal"><span class="pre">spawnvpe()</span></code></a>는 윈도우에서 사용할 수 없습니다. <a class="reference internal" href="#os.spawnle" title="os.spawnle"><code class="xref py py-func docutils literal"><span class="pre">spawnle()</span></code></a> 와 <a class="reference internal" href="#os.spawnve" title="os.spawnve"><code class="xref py py-func docutils literal"><span class="pre">spawnve()</span></code></a>는 윈도우에서 스레드 안전하지 않습니다; 대신 <a class="reference internal" href="subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a> 모듈을 사용하도록 권고합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.P_NOWAIT">
<code class="descclassname">os.</code><code class="descname">P_NOWAIT</code><a class="headerlink" href="#os.P_NOWAIT" title="정의 주소">¶</a></dt>
<dt id="os.P_NOWAITO">
<code class="descclassname">os.</code><code class="descname">P_NOWAITO</code><a class="headerlink" href="#os.P_NOWAITO" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*</span></code></a> 계열 함수의 <em>mode</em> 매개 변수에 사용할 수 있는 값. 이 값 중 하나가 주어지면, <code class="xref py py-func docutils literal"><span class="pre">spawn*()</span></code> 함수는 새로운 프로세스가 생성 되자마자 프로세스 ID를 반환 값으로 사용하여 반환됩니다.</p>
<p>가용성: 유닉스, 윈도우.</p>
</dd></dl>

<dl class="data">
<dt id="os.P_WAIT">
<code class="descclassname">os.</code><code class="descname">P_WAIT</code><a class="headerlink" href="#os.P_WAIT" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*</span></code></a> 계열 함수의 <em>mode</em> 매개 변수에 사용할 수 있는 값. 이것이 <em>mode</em> 로 주어지면, <code class="xref py py-func docutils literal"><span class="pre">spawn*()</span></code> 함수는 새 프로세스가 완료 될 때까지 반환되지 않고, 실행이 성공한 프로세스의 종료 코드를 반환하거나, 시그널이 프로세스를 죽이면 <code class="docutils literal"><span class="pre">-signal</span></code>을 반환합니다.</p>
<p>가용성: 유닉스, 윈도우.</p>
</dd></dl>

<dl class="data">
<dt id="os.P_DETACH">
<code class="descclassname">os.</code><code class="descname">P_DETACH</code><a class="headerlink" href="#os.P_DETACH" title="정의 주소">¶</a></dt>
<dt id="os.P_OVERLAY">
<code class="descclassname">os.</code><code class="descname">P_OVERLAY</code><a class="headerlink" href="#os.P_OVERLAY" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*</span></code></a> 계열 함수의 <em>mode</em> 매개 변수에 사용할 수 있는 값. 이들은 위에 나열된 것보다 이식성이 낮습니다. <a class="reference internal" href="#os.P_DETACH" title="os.P_DETACH"><code class="xref py py-const docutils literal"><span class="pre">P_DETACH</span></code></a>는 <a class="reference internal" href="#os.P_NOWAIT" title="os.P_NOWAIT"><code class="xref py py-const docutils literal"><span class="pre">P_NOWAIT</span></code></a>와 비슷하지만, 새 프로세스는 호출 프로세스의 콘솔에서 분리됩니다. <a class="reference internal" href="#os.P_OVERLAY" title="os.P_OVERLAY"><code class="xref py py-const docutils literal"><span class="pre">P_OVERLAY</span></code></a>가 사용되면, 현재 프로세스가 대체됩니다; <a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*</span></code></a> 함수가 반환되지 않습니다.</p>
<p>가용성: 윈도우.</p>
</dd></dl>

<dl class="function">
<dt id="os.startfile">
<code class="descclassname">os.</code><code class="descname">startfile</code><span class="sig-paren">(</span><em>path</em><span class="optional">[</span>, <em>operation</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#os.startfile" title="정의 주소">¶</a></dt>
<dd><p>연관된 응용 프로그램으로 파일을 시작합니다.</p>
<p><em>operation</em> 이 지정되지 않았거나 <code class="docutils literal"><span class="pre">'open'</span></code>이면, 윈도우 탐색기에서 파일을 두 번 클릭하거나, 대화형 명령 셸에서 <strong class="program">start</strong> 명령에 인자로 파일명을 지정하는 것과 같은 역할을 합니다: 파일의 확장자와 연관된 (있다면) 응용 프로그램으로 파일이 열립니다.</p>
<p>다른 <em>operation</em> 이 주어지면, 파일로 수행해야 할 작업을 지정하는 &quot;명령 동사&quot;여야합니다. 마이크로소프트에서 문서화 한 일반적인 동사는 <code class="docutils literal"><span class="pre">'print'</span></code> 와 <code class="docutils literal"><span class="pre">'edit'</span></code> (파일에 사용됨) 및 <code class="docutils literal"><span class="pre">'explore'</span></code> 와 <code class="docutils literal"><span class="pre">'find'</span></code> (디렉터리에 사용됨)입니다.</p>
<p><a class="reference internal" href="#os.startfile" title="os.startfile"><code class="xref py py-func docutils literal"><span class="pre">startfile()</span></code></a>는 연관된 응용 프로그램이 시작되자 마자 반환합니다. 응용 프로그램이 닫히기를 기다리는 옵션과 응용 프로그램의 종료 상태를 검색 할 수있는 방법이 없습니다. <em>path</em> 매개 변수는 현재 디렉터리에 상대적입니다. 절대 경로를 사용하려면 첫 번째 문자가 슬래시 (<code class="docutils literal"><span class="pre">'/'</span></code>)가 아닌지 확인하십시오; 하부 Win32 <code class="xref c c-func docutils literal"><span class="pre">ShellExecute()</span></code> 함수는 첫 번째 문자가 슬래시면 작동하지 않습니다. <a class="reference internal" href="os.path.html#os.path.normpath" title="os.path.normpath"><code class="xref py py-func docutils literal"><span class="pre">os.path.normpath()</span></code></a> 함수를 사용하여 경로가 Win32 용으로 올바르게 인코딩 되도록 하십시오.</p>
<p>인터프리터 시작 오버헤드를 줄이기 위해, Win32 <code class="xref c c-func docutils literal"><span class="pre">ShellExecute()</span></code> 함수는 이 함수가 처음 호출 될 때까지 결정(resolve)되지 않습니다. 함수를 결정할 수 없으면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>가 발생합니다.</p>
<p>가용성: 윈도우.</p>
</dd></dl>

<dl class="function">
<dt id="os.system">
<code class="descclassname">os.</code><code class="descname">system</code><span class="sig-paren">(</span><em>command</em><span class="sig-paren">)</span><a class="headerlink" href="#os.system" title="정의 주소">¶</a></dt>
<dd><p>서브 셸에서 명령(문자열)을 실행합니다. 이것은 표준 C 함수 <code class="xref c c-func docutils literal"><span class="pre">system()</span></code>를 호출하여 구현되며, 동일한 제한이 있습니다. <a class="reference internal" href="sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal"><span class="pre">sys.stdin</span></code></a> 등의 변경 사항은 실행 된 명령의 환경에 반영되지 않습니다. <em>command</em>가 출력을 생성하면, 인터프리터 표준 출력 스트림으로 전송됩니다.</p>
<p>유닉스에서, 반환 값은 <a class="reference internal" href="#os.wait" title="os.wait"><code class="xref py py-func docutils literal"><span class="pre">wait()</span></code></a>에 지정된 형식으로 인코딩된 프로세스의 종료 상태입니다. POSIX는 C <code class="xref c c-func docutils literal"><span class="pre">system()</span></code> 함수의 반환값의 의미를 지정하지 않으므로, 파이썬 함수의 반환 값은 시스템 종속적입니다.</p>
<p>윈도우에서, 반환 값은 <em>command</em>를 실행 한 후 시스템 셸에서 반환 한 값입니다. 셸은 윈도우 환경 변수 <span class="target" id="index-62"></span><code class="xref std std-envvar docutils literal"><span class="pre">COMSPEC</span></code>에 의해 제공됩니다: 보통 <strong class="program">cmd.exe</strong>인데, 명령 실행의 종료 상태를 반환합니다; 기본이 아닌 셸을 사용하는 시스템에서는 셸 설명서를 참조하십시오.</p>
<p><a class="reference internal" href="subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a> 모듈은 새 프로세스를 생성하고 결과를 조회하는 데, 보다 강력한 기능을 제공합니다; 이 모듈을 사용하는 것이 이 함수들을 사용하는 것보다 더 바람직합니다. <a class="reference internal" href="subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal"><span class="pre">subprocess</span></code></a> 설명서의 <a class="reference internal" href="subprocess.html#subprocess-replacements"><span class="std std-ref">Replacing Older Functions with the subprocess Module</span></a> 섹션에서 유용한 레시피를 확인하십시오.</p>
<p>가용성: 유닉스, 윈도우.</p>
</dd></dl>

<dl class="function">
<dt id="os.times">
<code class="descclassname">os.</code><code class="descname">times</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.times" title="정의 주소">¶</a></dt>
<dd><p>현재 전역 프로세스 시간을 반환합니다. 반환값은 5가지 어트리뷰트를 가진 객체입니다:</p>
<ul class="simple">
<li><code class="xref py py-attr docutils literal"><span class="pre">user</span></code> - 사용자 시간</li>
<li><a class="reference internal" href="#os.system" title="os.system"><code class="xref py py-attr docutils literal"><span class="pre">system</span></code></a> - 시스템 시간</li>
<li><code class="xref py py-attr docutils literal"><span class="pre">children_user</span></code> - 모든 자식 프로세스의 사용자 시간</li>
<li><code class="xref py py-attr docutils literal"><span class="pre">children_system</span></code> - 모든 자식 프로세스의 시스템 시간</li>
<li><code class="xref py py-attr docutils literal"><span class="pre">elapsed</span></code> - 과거의 고정된 시점 이후 실제 경과 시간</li>
</ul>
<p>과거 호환성을 위해, 이 객체는 <code class="xref py py-attr docutils literal"><span class="pre">user</span></code>, <a class="reference internal" href="#os.system" title="os.system"><code class="xref py py-attr docutils literal"><span class="pre">system</span></code></a>, <code class="xref py py-attr docutils literal"><span class="pre">children_user</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">children_system</span></code> 및 <code class="xref py py-attr docutils literal"><span class="pre">elapsed</span></code>가 이 순서로 포함된 5-튜플처럼 작동합니다.</p>
<p>유닉스 매뉴얼 페이지 <em class="manpage">times(2)</em> 또는 해당 윈도우 플랫폼 API 설명서를 참조하십시오. 윈도우에서는, <code class="xref py py-attr docutils literal"><span class="pre">user</span></code> 및 <a class="reference internal" href="#os.system" title="os.system"><code class="xref py py-attr docutils literal"><span class="pre">system</span></code></a> 만 알려져 있습니다; 다른 어트리뷰트는 0입니다.</p>
<p>가용성: 유닉스, 윈도우.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>반환형이 튜플에서 이름이 지정된 어트리뷰트를 가진 튜플류 객체로 변경되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.wait">
<code class="descclassname">os.</code><code class="descname">wait</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.wait" title="정의 주소">¶</a></dt>
<dd><p>자식 프로세스가 완료 될 때까지 기다렸다가, pid 및 종료 상태 표시를 포함하는 튜플을 반환합니다: 종료 상태 표시는 16비트 숫자인데, 하위 바이트가 프로세스를 죽인 시그널 번호이고, 상위 바이트가 종료 상태(시그널 번호가 0이면)입니다; 코어 파일이 생성되면 하위 바이트의 상위 비트가 설정됩니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.waitid">
<code class="descclassname">os.</code><code class="descname">waitid</code><span class="sig-paren">(</span><em>idtype</em>, <em>id</em>, <em>options</em><span class="sig-paren">)</span><a class="headerlink" href="#os.waitid" title="정의 주소">¶</a></dt>
<dd><p>하나 이상의 자식 프로세스가 완료 될 때까지 기다립니다. <em>idtype</em> 은 <a class="reference internal" href="#os.P_PID" title="os.P_PID"><code class="xref py py-data docutils literal"><span class="pre">P_PID</span></code></a>, <a class="reference internal" href="#os.P_PGID" title="os.P_PGID"><code class="xref py py-data docutils literal"><span class="pre">P_PGID</span></code></a> 또는 <a class="reference internal" href="#os.P_ALL" title="os.P_ALL"><code class="xref py py-data docutils literal"><span class="pre">P_ALL</span></code></a>이 될 수 있습니다. <em>id</em> 는 기다릴 pid를 지정합니다. <em>options</em>는 하나 이상의 <a class="reference internal" href="#os.WEXITED" title="os.WEXITED"><code class="xref py py-data docutils literal"><span class="pre">WEXITED</span></code></a>, <a class="reference internal" href="#os.WSTOPPED" title="os.WSTOPPED"><code class="xref py py-data docutils literal"><span class="pre">WSTOPPED</span></code></a> 또는 <a class="reference internal" href="#os.WCONTINUED" title="os.WCONTINUED"><code class="xref py py-data docutils literal"><span class="pre">WCONTINUED</span></code></a>의 OR로 구성되며, 추가로 <a class="reference internal" href="#os.WNOHANG" title="os.WNOHANG"><code class="xref py py-data docutils literal"><span class="pre">WNOHANG</span></code></a> 또는 <a class="reference internal" href="#os.WNOWAIT" title="os.WNOWAIT"><code class="xref py py-data docutils literal"><span class="pre">WNOWAIT</span></code></a>와 OR 될 수 있습니다. 반환 값은 <code class="xref c c-type docutils literal"><span class="pre">siginfo_t</span></code> 구조체에 포함 된 데이터(즉, <code class="xref py py-attr docutils literal"><span class="pre">si_pid</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">si_uid</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">si_signo</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">si_status</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">si_code</span></code>)를 나타내는 객체이거나, <a class="reference internal" href="#os.WNOHANG" title="os.WNOHANG"><code class="xref py py-data docutils literal"><span class="pre">WNOHANG</span></code></a>가 지정되고 대기 가능한 상태의 자식이 없으면 <code class="docutils literal"><span class="pre">None</span></code>입니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.P_PID">
<code class="descclassname">os.</code><code class="descname">P_PID</code><a class="headerlink" href="#os.P_PID" title="정의 주소">¶</a></dt>
<dt id="os.P_PGID">
<code class="descclassname">os.</code><code class="descname">P_PGID</code><a class="headerlink" href="#os.P_PGID" title="정의 주소">¶</a></dt>
<dt id="os.P_ALL">
<code class="descclassname">os.</code><code class="descname">P_ALL</code><a class="headerlink" href="#os.P_ALL" title="정의 주소">¶</a></dt>
<dd><p>이 것들은 <a class="reference internal" href="#os.waitid" title="os.waitid"><code class="xref py py-func docutils literal"><span class="pre">waitid()</span></code></a>의 <em>idtype</em> 에 사용 가능한 값입니다. <em>id</em> 가 어떻게 해석되는지에 영향을 미칩니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.WEXITED">
<code class="descclassname">os.</code><code class="descname">WEXITED</code><a class="headerlink" href="#os.WEXITED" title="정의 주소">¶</a></dt>
<dt id="os.WSTOPPED">
<code class="descclassname">os.</code><code class="descname">WSTOPPED</code><a class="headerlink" href="#os.WSTOPPED" title="정의 주소">¶</a></dt>
<dt id="os.WNOWAIT">
<code class="descclassname">os.</code><code class="descname">WNOWAIT</code><a class="headerlink" href="#os.WNOWAIT" title="정의 주소">¶</a></dt>
<dd><p>기다릴 자식 시그널을 지정하는, <a class="reference internal" href="#os.waitid" title="os.waitid"><code class="xref py py-func docutils literal"><span class="pre">waitid()</span></code></a>의 <em>options</em> 에서 사용할 수 있는 플래그.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.CLD_EXITED">
<code class="descclassname">os.</code><code class="descname">CLD_EXITED</code><a class="headerlink" href="#os.CLD_EXITED" title="정의 주소">¶</a></dt>
<dt id="os.CLD_DUMPED">
<code class="descclassname">os.</code><code class="descname">CLD_DUMPED</code><a class="headerlink" href="#os.CLD_DUMPED" title="정의 주소">¶</a></dt>
<dt id="os.CLD_TRAPPED">
<code class="descclassname">os.</code><code class="descname">CLD_TRAPPED</code><a class="headerlink" href="#os.CLD_TRAPPED" title="정의 주소">¶</a></dt>
<dt id="os.CLD_CONTINUED">
<code class="descclassname">os.</code><code class="descname">CLD_CONTINUED</code><a class="headerlink" href="#os.CLD_CONTINUED" title="정의 주소">¶</a></dt>
<dd><p>이것은 <a class="reference internal" href="#os.waitid" title="os.waitid"><code class="xref py py-func docutils literal"><span class="pre">waitid()</span></code></a>에 의해 반환된 결과에서 <code class="xref py py-attr docutils literal"><span class="pre">si_code</span></code>의 가능한 값입니다.</p>
<p>가용성: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.waitpid">
<code class="descclassname">os.</code><code class="descname">waitpid</code><span class="sig-paren">(</span><em>pid</em>, <em>options</em><span class="sig-paren">)</span><a class="headerlink" href="#os.waitpid" title="정의 주소">¶</a></dt>
<dd><p>이 함수의 세부 사항은 유닉스 및 윈도우에서 다릅니다.</p>
<p>유닉스에서: 프로세스 ID <em>pid</em>에 의해 주어진 자식 프로세스의 완료를 기다리고, 프로세스 ID와 종료 상태 표시(<a class="reference internal" href="#os.wait" title="os.wait"><code class="xref py py-func docutils literal"><span class="pre">wait()</span></code></a> 처럼 인코딩 됨)를 포함하는 튜플을 반환합니다. 호출의 의미는 정수 <em>options</em> 의 값에 영향을 받는데, 일반 작업의 경우 <code class="docutils literal"><span class="pre">0</span></code> 이어야합니다.</p>
<p><em>pid</em> 가 <code class="docutils literal"><span class="pre">0</span></code>보다 크면, <a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a>는 해당 프로세스에 대한 상태 정보를 요청합니다. <em>pid</em> 가 <code class="docutils literal"><span class="pre">0</span></code>이면, 현재 프로세스의 프로세스 그룹에 있는 모든 자식의 상태를 요청합니다. <em>pid</em> 가 <code class="docutils literal"><span class="pre">-1</span></code>이면, 현재 프로세스의 모든 자식의 상태를 요청합니다. <em>pid</em> 가 <code class="docutils literal"><span class="pre">-1</span></code>보다 작으면, 프로세스 그룹 <code class="docutils literal"><span class="pre">-pid</span></code>(<em>pid</em> 의 절대값)에 있는 모든 프로세스의 상태를 요청합니다.</p>
<p>시스템 호출이 -1을 반환하면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>가 errno 값으로 발생합니다.</p>
<p>윈도우에서: 프로세스 핸들 <em>pid</em>로 지정된 프로세스가 완료 될 때까지 기다리고, <em>pid</em>와 종료 상태를 8비트 왼쪽으로 시프트한 값을 포함하는 튜플을 반환합니다 (시프팅이 함수를 더 이식성있게 만듭니다). <code class="docutils literal"><span class="pre">0</span></code>보다 작거나 같은 <em>pid</em> 는 윈도우에서 특별한 의미가 없고 예외가 발생합니다. 정수 <em>options</em> 의 값은 아무 효과가 없습니다. <em>pid</em> 는 id가 알려져 있는 모든 프로세스를 가리킬 수 있습니다, 반드시 자식 프로세스일 필요는 없습니다. <a class="reference internal" href="#os.P_NOWAIT" title="os.P_NOWAIT"><code class="xref py py-const docutils literal"><span class="pre">P_NOWAIT</span></code></a>로 호출된 <a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*</span></code></a> 함수는 적절한 프로세스 핸들을 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 함수는 이제 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal"><span class="pre">InterruptedError</span></code></a> 예외를 일으키는 대신 시스템 호출을 재시도합니다 (이유는 <span class="target" id="index-63"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하세요).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.wait3">
<code class="descclassname">os.</code><code class="descname">wait3</code><span class="sig-paren">(</span><em>options</em><span class="sig-paren">)</span><a class="headerlink" href="#os.wait3" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a>와 비슷하지만, 프로세스 ID 인자가 제공되지 않고 자식 프로세스 ID, 종료 상태 표시 및 자원 사용 정보가 포함된 3-요소 튜플이 반환된다는 점이 다릅니다. 자원 사용 정보에 대한 자세한 내용은 <a class="reference internal" href="resource.html#module-resource" title="resource: An interface to provide resource usage information on the current process. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">resource</span></code></a>.<a class="reference internal" href="resource.html#resource.getrusage" title="resource.getrusage"><code class="xref py py-func docutils literal"><span class="pre">getrusage()</span></code></a>를 참조하십시오. 옵션 인자는 <a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a> 및 <a class="reference internal" href="#os.wait4" title="os.wait4"><code class="xref py py-func docutils literal"><span class="pre">wait4()</span></code></a>에 제공된 인자와 같습니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.wait4">
<code class="descclassname">os.</code><code class="descname">wait4</code><span class="sig-paren">(</span><em>pid</em>, <em>options</em><span class="sig-paren">)</span><a class="headerlink" href="#os.wait4" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a>와 비슷하지만, 자식 프로세스 ID, 종료 상태 표시 및 자원 사용 정보가 포함된 3-요소 튜플이 반환된다는 점이 다릅니다. 자원 사용 정보에 대한 자세한 내용은 <a class="reference internal" href="resource.html#module-resource" title="resource: An interface to provide resource usage information on the current process. (Unix)"><code class="xref py py-mod docutils literal"><span class="pre">resource</span></code></a>.<a class="reference internal" href="resource.html#resource.getrusage" title="resource.getrusage"><code class="xref py py-func docutils literal"><span class="pre">getrusage()</span></code></a>를 참조하십시오. <a class="reference internal" href="#os.wait4" title="os.wait4"><code class="xref py py-func docutils literal"><span class="pre">wait4()</span></code></a>의 인자는 <a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a>와 같습니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.WNOHANG">
<code class="descclassname">os.</code><code class="descname">WNOHANG</code><a class="headerlink" href="#os.WNOHANG" title="정의 주소">¶</a></dt>
<dd><p>자식 프로세스 상태를 즉시 사용할 수 없으면, <a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a>가 즉시 반환하는 옵션입니다. 이 경우 이 함수는 <code class="docutils literal"><span class="pre">(0,</span> <span class="pre">0)</span></code>를 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.WCONTINUED">
<code class="descclassname">os.</code><code class="descname">WCONTINUED</code><a class="headerlink" href="#os.WCONTINUED" title="정의 주소">¶</a></dt>
<dd><p>이 옵션은 자식 프로세스의 상태가 마지막으로보고 된 이후에 작업 제어 중지에서 재개한 경우 보고되도록 합니다.</p>
<p>가용성: 일부 유닉스 시스템.</p>
</dd></dl>

<dl class="data">
<dt id="os.WUNTRACED">
<code class="descclassname">os.</code><code class="descname">WUNTRACED</code><a class="headerlink" href="#os.WUNTRACED" title="정의 주소">¶</a></dt>
<dd><p>이 옵션은 자식 프로세스가 중지되었지만 현재 상태가 중지 된 이후 보고되지 않은 경우 보고되게 합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<p>다음 함수들은 <a class="reference internal" href="#os.system" title="os.system"><code class="xref py py-func docutils literal"><span class="pre">system()</span></code></a>, <a class="reference internal" href="#os.wait" title="os.wait"><code class="xref py py-func docutils literal"><span class="pre">wait()</span></code></a> 또는 <a class="reference internal" href="#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal"><span class="pre">waitpid()</span></code></a>에 의해 반환 된 프로세스 상태 코드를 매개 변수로 받아들입니다. 이 것들은 프로세스의 처리를 결정하는 데 사용될 수 있습니다.</p>
<dl class="function">
<dt id="os.WCOREDUMP">
<code class="descclassname">os.</code><code class="descname">WCOREDUMP</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#os.WCOREDUMP" title="정의 주소">¶</a></dt>
<dd><p>프로세스에 대해 코어 덤프가 생성되었으면 <code class="docutils literal"><span class="pre">True</span></code>를 반환하고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.WIFCONTINUED">
<code class="descclassname">os.</code><code class="descname">WIFCONTINUED</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#os.WIFCONTINUED" title="정의 주소">¶</a></dt>
<dd><p>작업 제어 중지에서 프로세스가 재개했으면 <code class="docutils literal"><span class="pre">True</span></code>를 반환하고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.WIFSTOPPED">
<code class="descclassname">os.</code><code class="descname">WIFSTOPPED</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#os.WIFSTOPPED" title="정의 주소">¶</a></dt>
<dd><p>프로세스가 중지되었으면 <code class="docutils literal"><span class="pre">True</span></code>를 반환하고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.WIFSIGNALED">
<code class="descclassname">os.</code><code class="descname">WIFSIGNALED</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#os.WIFSIGNALED" title="정의 주소">¶</a></dt>
<dd><p>시그널로 인해 프로세스가 종료되었으면 <code class="docutils literal"><span class="pre">True</span></code>를 반환하고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.WIFEXITED">
<code class="descclassname">os.</code><code class="descname">WIFEXITED</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#os.WIFEXITED" title="정의 주소">¶</a></dt>
<dd><p>프로세스가 <em class="manpage">exit(2)</em> 시스템 호출을 사용하여 종료되었으면 <code class="docutils literal"><span class="pre">True</span></code>를 반환하고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code>를 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.WEXITSTATUS">
<code class="descclassname">os.</code><code class="descname">WEXITSTATUS</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#os.WEXITSTATUS" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">WIFEXITED(status)</span></code>가 참이면, <em class="manpage">exit(2)</em> 시스템 호출로 준 정수 매개 변수를 반환합니다. 그렇지 않으면 반환 값은 의미가 없습니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.WSTOPSIG">
<code class="descclassname">os.</code><code class="descname">WSTOPSIG</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#os.WSTOPSIG" title="정의 주소">¶</a></dt>
<dd><p>프로세스를 멈추게 한 시그널을 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.WTERMSIG">
<code class="descclassname">os.</code><code class="descname">WTERMSIG</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#os.WTERMSIG" title="정의 주소">¶</a></dt>
<dd><p>프로세스를 종료시킨 시그널을 반환합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

</div>
<div class="section" id="interface-to-the-scheduler">
<h2>16.1.7. 스케줄러에 대한 인터페이스<a class="headerlink" href="#interface-to-the-scheduler" title="제목 주소">¶</a></h2>
<p>이 함수들은 운영 체제가 프로세스에 CPU 시간을 할당하는 방법을 제어합니다. 일부 유닉스 플랫폼에서만 사용할 수 있습니다. 자세한 내용은 유닉스 매뉴얼 페이지를 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
<p>다음 스케줄 정책은 운영 체제에서 지원하는 경우 공개됩니다.</p>
<dl class="data">
<dt id="os.SCHED_OTHER">
<code class="descclassname">os.</code><code class="descname">SCHED_OTHER</code><a class="headerlink" href="#os.SCHED_OTHER" title="정의 주소">¶</a></dt>
<dd><p>기본 스케줄 정책.</p>
</dd></dl>

<dl class="data">
<dt id="os.SCHED_BATCH">
<code class="descclassname">os.</code><code class="descname">SCHED_BATCH</code><a class="headerlink" href="#os.SCHED_BATCH" title="정의 주소">¶</a></dt>
<dd><p>컴퓨터의 나머지 부분에서 반응성을 유지하려고하는 CPU 집약적인 프로세스를 위한 스케쥴 정책.</p>
</dd></dl>

<dl class="data">
<dt id="os.SCHED_IDLE">
<code class="descclassname">os.</code><code class="descname">SCHED_IDLE</code><a class="headerlink" href="#os.SCHED_IDLE" title="정의 주소">¶</a></dt>
<dd><p>매우 낮은 우선 순위의 배경 작업에 대한 스케줄 정책.</p>
</dd></dl>

<dl class="data">
<dt id="os.SCHED_SPORADIC">
<code class="descclassname">os.</code><code class="descname">SCHED_SPORADIC</code><a class="headerlink" href="#os.SCHED_SPORADIC" title="정의 주소">¶</a></dt>
<dd><p>간헐적인 서버 프로그램을 위한 스케줄 정책.</p>
</dd></dl>

<dl class="data">
<dt id="os.SCHED_FIFO">
<code class="descclassname">os.</code><code class="descname">SCHED_FIFO</code><a class="headerlink" href="#os.SCHED_FIFO" title="정의 주소">¶</a></dt>
<dd><p>선입 선출 (First In First Out) 스케줄 정책.</p>
</dd></dl>

<dl class="data">
<dt id="os.SCHED_RR">
<code class="descclassname">os.</code><code class="descname">SCHED_RR</code><a class="headerlink" href="#os.SCHED_RR" title="정의 주소">¶</a></dt>
<dd><p>라운드 로빈 스케줄 정책.</p>
</dd></dl>

<dl class="data">
<dt id="os.SCHED_RESET_ON_FORK">
<code class="descclassname">os.</code><code class="descname">SCHED_RESET_ON_FORK</code><a class="headerlink" href="#os.SCHED_RESET_ON_FORK" title="정의 주소">¶</a></dt>
<dd><p>이 플래그는 다른 스케줄 정책과 OR될 수 있습니다. 이 플래그가 설정되어있는 프로세스가 포크할 때, 자식의 스케줄링 정책 및 우선 순위가 기본값으로 재설정됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="os.sched_param">
<em class="property">class </em><code class="descclassname">os.</code><code class="descname">sched_param</code><span class="sig-paren">(</span><em>sched_priority</em><span class="sig-paren">)</span><a class="headerlink" href="#os.sched_param" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 <a class="reference internal" href="#os.sched_setparam" title="os.sched_setparam"><code class="xref py py-func docutils literal"><span class="pre">sched_setparam()</span></code></a>, <a class="reference internal" href="#os.sched_setscheduler" title="os.sched_setscheduler"><code class="xref py py-func docutils literal"><span class="pre">sched_setscheduler()</span></code></a>, 및 <a class="reference internal" href="#os.sched_getparam" title="os.sched_getparam"><code class="xref py py-func docutils literal"><span class="pre">sched_getparam()</span></code></a>에서 사용되는 튜닝 가능한 스케줄 파라미터를 나타냅니다. 불변입니다.</p>
<p>현재, 가능한 매개 변수는 하나뿐입니다:</p>
<dl class="attribute">
<dt id="os.sched_param.sched_priority">
<code class="descname">sched_priority</code><a class="headerlink" href="#os.sched_param.sched_priority" title="정의 주소">¶</a></dt>
<dd><p>스케줄 정책의 스케줄 우선 순위.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="os.sched_get_priority_min">
<code class="descclassname">os.</code><code class="descname">sched_get_priority_min</code><span class="sig-paren">(</span><em>policy</em><span class="sig-paren">)</span><a class="headerlink" href="#os.sched_get_priority_min" title="정의 주소">¶</a></dt>
<dd><p><em>policy</em>의 최소 우선 순위 값을 가져옵니다. <em>policy</em> 는 위의 스케줄 정책 상수 중 하나입니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.sched_get_priority_max">
<code class="descclassname">os.</code><code class="descname">sched_get_priority_max</code><span class="sig-paren">(</span><em>policy</em><span class="sig-paren">)</span><a class="headerlink" href="#os.sched_get_priority_max" title="정의 주소">¶</a></dt>
<dd><p><em>policy</em>의 최대 우선 순위 값을 가져옵니다. <em>policy</em> 는 위의 스케줄 정책 상수 중 하나입니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.sched_setscheduler">
<code class="descclassname">os.</code><code class="descname">sched_setscheduler</code><span class="sig-paren">(</span><em>pid</em>, <em>policy</em>, <em>param</em><span class="sig-paren">)</span><a class="headerlink" href="#os.sched_setscheduler" title="정의 주소">¶</a></dt>
<dd><p>PID가 <em>pid</em>인 프로세스의 스케줄 정책을 설정합니다. <em>pid</em> 가 0이면, 호출하는 프로세스를 의미합니다. <em>policy</em> 는 위의 스케줄 정책 상수 중 하나입니다. <em>param</em> 은 <a class="reference internal" href="#os.sched_param" title="os.sched_param"><code class="xref py py-class docutils literal"><span class="pre">sched_param</span></code></a> 인스턴스입니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.sched_getscheduler">
<code class="descclassname">os.</code><code class="descname">sched_getscheduler</code><span class="sig-paren">(</span><em>pid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.sched_getscheduler" title="정의 주소">¶</a></dt>
<dd><p>PID가 <em>pid</em>인 프로세스의 스케줄 정책을 반환합니다. <em>pid</em> 가 0이면, 호출하는 프로세스를 의미합니다. 결과는 위의 스케줄 정책 상수 중 하나입니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.sched_setparam">
<code class="descclassname">os.</code><code class="descname">sched_setparam</code><span class="sig-paren">(</span><em>pid</em>, <em>param</em><span class="sig-paren">)</span><a class="headerlink" href="#os.sched_setparam" title="정의 주소">¶</a></dt>
<dd><p>PID가 <em>pid</em>인 프로세스의 스케줄 매개 변수를 설정합니다. <em>pid</em> 가 0이면 호출하는 프로세스를 의미합니다. <em>param</em> 은 <a class="reference internal" href="#os.sched_param" title="os.sched_param"><code class="xref py py-class docutils literal"><span class="pre">sched_param</span></code></a> 인스턴스입니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.sched_getparam">
<code class="descclassname">os.</code><code class="descname">sched_getparam</code><span class="sig-paren">(</span><em>pid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.sched_getparam" title="정의 주소">¶</a></dt>
<dd><p>PID가 <em>pid</em>인 프로세스의 스케줄 매개 변수를 <a class="reference internal" href="#os.sched_param" title="os.sched_param"><code class="xref py py-class docutils literal"><span class="pre">sched_param</span></code></a> 인스턴스로 반환합니다. <em>pid</em> 가 0이면 호출하는 프로세스를 의미합니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.sched_rr_get_interval">
<code class="descclassname">os.</code><code class="descname">sched_rr_get_interval</code><span class="sig-paren">(</span><em>pid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.sched_rr_get_interval" title="정의 주소">¶</a></dt>
<dd><p>PID가 <em>pid</em>인 프로세스의 라운드 로빈 퀀텀을 초 단위로 반환합니다. <em>pid</em> 가 0이면 호출하는 프로세스를 의미합니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.sched_yield">
<code class="descclassname">os.</code><code class="descname">sched_yield</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.sched_yield" title="정의 주소">¶</a></dt>
<dd><p>자발적으로 CPU를 양도합니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.sched_setaffinity">
<code class="descclassname">os.</code><code class="descname">sched_setaffinity</code><span class="sig-paren">(</span><em>pid</em>, <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#os.sched_setaffinity" title="정의 주소">¶</a></dt>
<dd><p>PID가 <em>pid</em>인 프로세스(또는 0이면 현재 프로세스)를 CPU 집합으로 제한합니다. <em>mask</em> 는 프로세스가 제한되어야하는 CPU 집합을 나타내는 정수의 이터러블입니다.</p>
</dd></dl>

<dl class="function">
<dt id="os.sched_getaffinity">
<code class="descclassname">os.</code><code class="descname">sched_getaffinity</code><span class="sig-paren">(</span><em>pid</em><span class="sig-paren">)</span><a class="headerlink" href="#os.sched_getaffinity" title="정의 주소">¶</a></dt>
<dd><p>PID가 <em>pid</em>인 프로세스(또는 0이면 현재 프로세스)가 제한되는 CPU 집합을 반환합니다.</p>
</dd></dl>

</div>
<div class="section" id="miscellaneous-system-information">
<span id="os-path"></span><h2>16.1.8. 기타 시스템 정보<a class="headerlink" href="#miscellaneous-system-information" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="os.confstr">
<code class="descclassname">os.</code><code class="descname">confstr</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#os.confstr" title="정의 주소">¶</a></dt>
<dd><p>문자열 값 시스템 구성 값을 반환합니다. <em>name</em> 은 조회할 구성 값을 지정합니다; 정의 된 시스템 값의 이름인 문자열일 수 있습니다; 이 이름은 여러 표준(POSIX, 유닉스 95, 유닉스 98 및 기타)에서 지정됩니다. 일부 플랫폼은 추가 이름도 정의합니다. 호스트 운영 체제에 알려진 이름은 <code class="docutils literal"><span class="pre">confstr_names</span></code> 딕셔너리의 키로 제공됩니다. 해당 매핑에 포함되지 않은 구성 변수를 위해, <em>name</em>에 정수를 전달하는 것도 허용됩니다.</p>
<p><em>name</em> 으로 지정된 구성 값이 정의되어 있지 않으면, <code class="docutils literal"><span class="pre">None</span></code>이 반환됩니다.</p>
<p><em>name</em> 이 문자열이고 알 수 없으면, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>가 발생합니다. <em>name</em>에 대한 특정 값이 호스트 시스템에서 지원되지 않으면, <code class="docutils literal"><span class="pre">confstr_names</span></code>에 포함되어 있어도, 에러 번호 <a class="reference internal" href="errno.html#errno.EINVAL" title="errno.EINVAL"><code class="xref py py-const docutils literal"><span class="pre">errno.EINVAL</span></code></a>로 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>가 발생합니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.confstr_names">
<code class="descclassname">os.</code><code class="descname">confstr_names</code><a class="headerlink" href="#os.confstr_names" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.confstr" title="os.confstr"><code class="xref py py-func docutils literal"><span class="pre">confstr()</span></code></a>에서 허용하는 이름을 호스트 운영 체제가 해당 이름에 대해 정의한 정수 값으로 매핑하는 딕셔너리입니다. 이것은 시스템에 알려진 이름 집합을 판별하는 데 사용될 수 있습니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.cpu_count">
<code class="descclassname">os.</code><code class="descname">cpu_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.cpu_count" title="정의 주소">¶</a></dt>
<dd><p>시스템의 CPU 수를 반환합니다. 파악할 수 없으면, <code class="docutils literal"><span class="pre">None</span></code>을 반환합니다.</p>
<p>이 숫자는 현재 프로세스에서 사용할 수 있는 CPU 수와 같지 않습니다. 사용 가능한 CPU 수는 <code class="docutils literal"><span class="pre">len(os.sched_getaffinity(0))</span></code>로 얻을 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.getloadavg">
<code class="descclassname">os.</code><code class="descname">getloadavg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#os.getloadavg" title="정의 주소">¶</a></dt>
<dd><p>마지막 1, 5, 15분에 걸쳐 평균된 시스템 실행 대기열의 프로세스 수를 반환하거나, 로드 평균을 얻을 수 없으면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>를 발생시킵니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="os.sysconf">
<code class="descclassname">os.</code><code class="descname">sysconf</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#os.sysconf" title="정의 주소">¶</a></dt>
<dd><p>정수 값 시스템 구성 값을 반환합니다. <em>name</em> 으로 지정된 구성 값이 정의되어 있지 않으면, <code class="docutils literal"><span class="pre">-1</span></code>이 반환됩니다. <a class="reference internal" href="#os.confstr" title="os.confstr"><code class="xref py py-func docutils literal"><span class="pre">confstr()</span></code></a>의 <em>name</em> 매개 변수에 관한 주석은 여기에도 적용됩니다; 알려진 이름에 대한 정보를 제공하는 딕셔너리는 <code class="docutils literal"><span class="pre">sysconf_names</span></code>에 의해 제공됩니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="os.sysconf_names">
<code class="descclassname">os.</code><code class="descname">sysconf_names</code><a class="headerlink" href="#os.sysconf_names" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#os.sysconf" title="os.sysconf"><code class="xref py py-func docutils literal"><span class="pre">sysconf()</span></code></a>에서 허용하는 이름을 호스트 운영 체제가 해당 이름에 대해 정의한 정수 값으로 매핑하는 딕셔너리입니다. 이것은 시스템에 알려진 이름 집합을 판별하는 데 사용될 수 있습니다.</p>
<p>가용성: 유닉스.</p>
</dd></dl>

<p>다음 데이터 값들은 경로 조작 연산을 지원하는 데 사용됩니다. 이는 모든 플랫폼에서 정의됩니다.</p>
<p>경로명에 대한 고수준 연산은 <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a> 모듈에서 정의됩니다.</p>
<dl class="data">
<dt id="os.curdir">
<code class="descclassname">os.</code><code class="descname">curdir</code><a class="headerlink" href="#os.curdir" title="정의 주소">¶</a></dt>
<dd><p>현재 디렉터리를 가리키기 위해 운영 체제에서 사용하는 상수 문자열. 이것은 윈도우 및 POSIX의 경우 <code class="docutils literal"><span class="pre">'.'</span></code>입니다. <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>를 통해서도 제공됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.pardir">
<code class="descclassname">os.</code><code class="descname">pardir</code><a class="headerlink" href="#os.pardir" title="정의 주소">¶</a></dt>
<dd><p>부모 디렉터리를 가리키기 위해 운영 체제에서 사용하는 상수 문자열입니다. 이것은 윈도우 및 POSIX의 경우 <code class="docutils literal"><span class="pre">'..'</span></code>입니다. <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>를 통해서도 제공됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.sep">
<code class="descclassname">os.</code><code class="descname">sep</code><a class="headerlink" href="#os.sep" title="정의 주소">¶</a></dt>
<dd><p>경로명 구성 요소를 분리하기 위해 운영 체제에서 사용하는 문자. 이것은 POSIX의 경우 <code class="docutils literal"><span class="pre">'/'</span></code>이고, 윈도우의 경우 <code class="docutils literal"><span class="pre">'\\'</span></code>입니다. 이것을 아는 것 만으로는 경로명을 구문 분석하거나 이어붙일 수는 없습니다만 --- <a class="reference internal" href="os.path.html#os.path.split" title="os.path.split"><code class="xref py py-func docutils literal"><span class="pre">os.path.split()</span></code></a>와 <a class="reference internal" href="os.path.html#os.path.join" title="os.path.join"><code class="xref py py-func docutils literal"><span class="pre">os.path.join()</span></code></a>를 사용하세요 --- 가끔 유용합니다. <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>를 통해서도 제공됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.altsep">
<code class="descclassname">os.</code><code class="descname">altsep</code><a class="headerlink" href="#os.altsep" title="정의 주소">¶</a></dt>
<dd><p>경로명 구성 요소를 분리하기 위해 운영 체제에서 사용하는 대체 문자이거나, 단 하나의 구분 문자만 있는 경우 <code class="docutils literal"><span class="pre">None</span></code>입니다. <code class="docutils literal"><span class="pre">sep</span></code>가 백 슬래시인 윈도우 시스템에서는 <code class="docutils literal"><span class="pre">'/'</span></code>로 설정됩니다. <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>를 통해서도 제공됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.extsep">
<code class="descclassname">os.</code><code class="descname">extsep</code><a class="headerlink" href="#os.extsep" title="정의 주소">¶</a></dt>
<dd><p>기본 파일명과 확장자를 구분하는 문자; 예를 들어, <code class="file docutils literal"><span class="pre">os.py</span></code>에서 <code class="docutils literal"><span class="pre">'.'</span></code>. <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>를 통해서도 제공됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.pathsep">
<code class="descclassname">os.</code><code class="descname">pathsep</code><a class="headerlink" href="#os.pathsep" title="정의 주소">¶</a></dt>
<dd><p>검색 경로 구성 요소(<span class="target" id="index-64"></span><code class="xref std std-envvar docutils literal"><span class="pre">PATH</span></code>에서와 같이)를 분리하기 위해 운영 체제에서 관습적으로 사용하는 문자, 가령 POSIX의 <code class="docutils literal"><span class="pre">':'</span></code> 또는 윈도우의 <code class="docutils literal"><span class="pre">';'</span></code>. <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>를 통해서도 제공됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.defpath">
<code class="descclassname">os.</code><code class="descname">defpath</code><a class="headerlink" href="#os.defpath" title="정의 주소">¶</a></dt>
<dd><p>환경에 <code class="docutils literal"><span class="pre">'PATH'</span></code> 키가없을 때, <a class="reference internal" href="#os.execl" title="os.execl"><code class="xref py py-func docutils literal"><span class="pre">exec*p*</span></code></a> 및 <a class="reference internal" href="#os.spawnl" title="os.spawnl"><code class="xref py py-func docutils literal"><span class="pre">spawn*p*</span></code></a>에서 사용하는 기본 검색 경로. <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>를 통해서도 제공됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.linesep">
<code class="descclassname">os.</code><code class="descname">linesep</code><a class="headerlink" href="#os.linesep" title="정의 주소">¶</a></dt>
<dd><p>현재 플랫폼에서 행을 분리(또는 종료)하는 데 사용되는 문자열. 이는 POSIX의 <code class="docutils literal"><span class="pre">'\n'</span></code>와 같은 단일 문자이거나, 윈도우의 <code class="docutils literal"><span class="pre">'\r\n'</span></code>와 같은 여러 문자 일 수 있습니다. 텍스트 모드로 열린(기본값) 파일에 쓸 때 줄 종결자로 <em>os.linesep</em>를 사용하지 마십시오; 대신 모든 플랫폼에서 단일 <code class="docutils literal"><span class="pre">'\n'</span></code>를 사용하십시오.</p>
</dd></dl>

<dl class="data">
<dt id="os.devnull">
<code class="descclassname">os.</code><code class="descname">devnull</code><a class="headerlink" href="#os.devnull" title="정의 주소">¶</a></dt>
<dd><p>널(null) 장치의 파일 경로. 예를 들어: POSIX의 경우 <code class="docutils literal"><span class="pre">'/dev/null'</span></code>, 윈도우의 경우 <code class="docutils literal"><span class="pre">'nul'</span></code>. <a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal"><span class="pre">os.path</span></code></a>를 통해서도 제공됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="os.RTLD_LAZY">
<code class="descclassname">os.</code><code class="descname">RTLD_LAZY</code><a class="headerlink" href="#os.RTLD_LAZY" title="정의 주소">¶</a></dt>
<dt id="os.RTLD_NOW">
<code class="descclassname">os.</code><code class="descname">RTLD_NOW</code><a class="headerlink" href="#os.RTLD_NOW" title="정의 주소">¶</a></dt>
<dt id="os.RTLD_GLOBAL">
<code class="descclassname">os.</code><code class="descname">RTLD_GLOBAL</code><a class="headerlink" href="#os.RTLD_GLOBAL" title="정의 주소">¶</a></dt>
<dt id="os.RTLD_LOCAL">
<code class="descclassname">os.</code><code class="descname">RTLD_LOCAL</code><a class="headerlink" href="#os.RTLD_LOCAL" title="정의 주소">¶</a></dt>
<dt id="os.RTLD_NODELETE">
<code class="descclassname">os.</code><code class="descname">RTLD_NODELETE</code><a class="headerlink" href="#os.RTLD_NODELETE" title="정의 주소">¶</a></dt>
<dt id="os.RTLD_NOLOAD">
<code class="descclassname">os.</code><code class="descname">RTLD_NOLOAD</code><a class="headerlink" href="#os.RTLD_NOLOAD" title="정의 주소">¶</a></dt>
<dt id="os.RTLD_DEEPBIND">
<code class="descclassname">os.</code><code class="descname">RTLD_DEEPBIND</code><a class="headerlink" href="#os.RTLD_DEEPBIND" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.setdlopenflags" title="sys.setdlopenflags"><code class="xref py py-func docutils literal"><span class="pre">setdlopenflags()</span></code></a> 및 <a class="reference internal" href="sys.html#sys.getdlopenflags" title="sys.getdlopenflags"><code class="xref py py-func docutils literal"><span class="pre">getdlopenflags()</span></code></a> 함수에 사용하는 플래그. 각 플래그가 의미하는 바는 유닉스 매뉴얼 페이지 <em class="manpage">dlopen(3)</em>를 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="random-numbers">
<h2>16.1.9. 난수<a class="headerlink" href="#random-numbers" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="os.getrandom">
<code class="descclassname">os.</code><code class="descname">getrandom</code><span class="sig-paren">(</span><em>size</em>, <em>flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#os.getrandom" title="정의 주소">¶</a></dt>
<dd><p>최대 <em>size</em> 크기의 난수 바이트열을 업습니다. 이 함수는 요청한 것보다 짧은 바이트열를 반환 할 수 있습니다.</p>
<p>이 바이트열는 사용자 공간 난수 발생기를 시드하거나 암호화 목적으로 사용할 수 있습니다.</p>
<p><code class="docutils literal"><span class="pre">getrandom()</span></code>는 장치 드라이버 및 기타 환경 소음원에서 수집한 엔트로피에 의존합니다. 대량의 데이터를 불필요하게 읽는 것은 <code class="docutils literal"><span class="pre">/dev/random</span></code> 및 <code class="docutils literal"><span class="pre">/dev/urandom</span></code> 장치의 다른 사용자에게 부정적인 영향을 미칩니다.</p>
<p>flags 인자는 다음값들 중 0개 이상의 값들과 함께 OR될 수 있는 비트 마스크입니다: <a class="reference internal" href="#os.GRND_RANDOM" title="os.GRND_RANDOM"><code class="xref py py-data docutils literal"><span class="pre">os.GRND_RANDOM</span></code></a> 및 <a class="reference internal" href="#os.GRND_NONBLOCK" title="os.GRND_NONBLOCK"><code class="xref py py-data docutils literal"><span class="pre">GRND_NONBLOCK</span></code></a>.</p>
<p><a class="reference external" href="http://man7.org/linux/man-pages/man2/getrandom.2.html">리눅스 getrandom() 매뉴얼 페이지</a>도 참조하십시오.</p>
<p>가용성: 리눅스 3.17 이상.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="os.urandom">
<code class="descclassname">os.</code><code class="descname">urandom</code><span class="sig-paren">(</span><em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#os.urandom" title="정의 주소">¶</a></dt>
<dd><p>암호화에 적합한 <em>size</em> 크기의 난수 바이트열을 돌려줍니다.</p>
<p>이 함수는 OS 종속적인 임의성 소스에서 난수 바이트열을 반환합니다. 반환된 데이터는 암호화 응용에 충분하도록 예측할 수 없어야하지만, 정확한 품질은 OS 구현에 따라 달라집니다.</p>
<p>리눅스에서, <code class="docutils literal"><span class="pre">getrandom()</span></code> 시스템 호출을 사용할 수 있으면, 블로킹 모드로 사용됩니다: 시스템의 urandom 엔트로피 풀이 초기화 될 때까지 블록됩니다 (커널이 128 비트의 엔트로피를 수집합니다). 이유는 <span class="target" id="index-65"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0524"><strong>PEP 524</strong></a>를 참조하십시오. 리눅스에서, <a class="reference internal" href="#os.getrandom" title="os.getrandom"><code class="xref py py-func docutils literal"><span class="pre">getrandom()</span></code></a> 함수는 (<a class="reference internal" href="#os.GRND_NONBLOCK" title="os.GRND_NONBLOCK"><code class="xref py py-data docutils literal"><span class="pre">GRND_NONBLOCK</span></code></a> 플래그를 사용하여) 비 블로킹 모드로 난수 바이트열을 얻거나, 시스템 urandom 엔트로피 풀이 초기화 될 때까지 폴링할 수 있습니다.</p>
<p>유닉스류 시스템에서, <code class="docutils literal"><span class="pre">/dev/urandom</span></code> 장치에서 난수 바이트열을 읽습니다. <code class="docutils literal"><span class="pre">/dev/urandom</span></code> 장치를 사용할 수 없거나 읽을 수 없으면, <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> 예외가 발생합니다.</p>
<p>윈도우에서, <code class="docutils literal"><span class="pre">CryptGenRandom()</span></code>을 사용합니다.</p>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="secrets.html#module-secrets" title="secrets: Generate secure random numbers for managing secrets."><code class="xref py py-mod docutils literal"><span class="pre">secrets</span></code></a> 모듈은 고수준 함수를 제공합니다. 플랫폼에서 제공되는 난수 발생기에 대한 사용하기 쉬운 인터페이스는 <a class="reference internal" href="random.html#random.SystemRandom" title="random.SystemRandom"><code class="xref py py-class docutils literal"><span class="pre">random.SystemRandom</span></code></a>를 참조하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6.0으로 변경: </span>리눅스에서, <code class="docutils literal"><span class="pre">getrandom()</span></code>은 이제 보안을 강화하기 위해 블로킹 모드로 사용됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5.2으로 변경: </span>리눅스에서, <code class="docutils literal"><span class="pre">getrandom()</span></code> 시스템 호출이 블록하면 (urandom 엔트로피 풀이 아직 초기화되지 않았으면), <code class="docutils literal"><span class="pre">/dev/urandom</span></code>을 읽는 것으로 대체됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>리눅스 3.17 및 이후 버전에서, 이제 <code class="docutils literal"><span class="pre">getrandom()</span></code> 시스템 호출이 사용 가능하면 사용됩니다. OpenBSD 5.6 이상에서, C <code class="docutils literal"><span class="pre">getentropy()</span></code> 함수가 이제 사용됩니다. 이 함수들은 내부 파일 기술자의 사용을 피합니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.GRND_NONBLOCK">
<code class="descclassname">os.</code><code class="descname">GRND_NONBLOCK</code><a class="headerlink" href="#os.GRND_NONBLOCK" title="정의 주소">¶</a></dt>
<dd><p>기본적으로, <code class="docutils literal"><span class="pre">/dev/random</span></code>에서 읽을 때, <a class="reference internal" href="#os.getrandom" title="os.getrandom"><code class="xref py py-func docutils literal"><span class="pre">getrandom()</span></code></a>는 사용할 수 있는 난수 바이트열이 없으면 블록하고, <code class="docutils literal"><span class="pre">/dev/urandom</span></code>에서 읽을 때는, 엔트로피 풀이 아직 초기화되지 않았으면 블록합니다.</p>
<p><a class="reference internal" href="#os.GRND_NONBLOCK" title="os.GRND_NONBLOCK"><code class="xref py py-data docutils literal"><span class="pre">GRND_NONBLOCK</span></code></a> 플래그가 설정되면, <a class="reference internal" href="#os.getrandom" title="os.getrandom"><code class="xref py py-func docutils literal"><span class="pre">getrandom()</span></code></a>는 이러한 경우 블록하지 않고, 대신 즉시 <a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal"><span class="pre">BlockingIOError</span></code></a>를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="os.GRND_RANDOM">
<code class="descclassname">os.</code><code class="descname">GRND_RANDOM</code><a class="headerlink" href="#os.GRND_RANDOM" title="정의 주소">¶</a></dt>
<dd><p>이 비트가 설정되면, <code class="docutils literal"><span class="pre">/dev/urandom</span></code> 풀 대신 <code class="docutils literal"><span class="pre">/dev/random</span></code> 풀에서 난수 바이트열을 얻습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">16.1. <code class="docutils literal"><span class="pre">os</span></code> --- 기타 운영 체제 인터페이스</a><ul>
<li><a class="reference internal" href="#file-names-command-line-arguments-and-environment-variables">16.1.1. 파일명, 명령 줄 인자 및 환경 변수</a></li>
<li><a class="reference internal" href="#process-parameters">16.1.2. 프로세스 매개 변수</a></li>
<li><a class="reference internal" href="#file-object-creation">16.1.3. 파일 객체 생성</a></li>
<li><a class="reference internal" href="#file-descriptor-operations">16.1.4. 파일 기술자 연산</a><ul>
<li><a class="reference internal" href="#querying-the-size-of-a-terminal">16.1.4.1. 터미널의 크기 조회하기</a></li>
<li><a class="reference internal" href="#inheritance-of-file-descriptors">16.1.4.2. 파일 기술자의 상속</a></li>
</ul>
</li>
<li><a class="reference internal" href="#files-and-directories">16.1.5. 파일과 디렉터리</a><ul>
<li><a class="reference internal" href="#linux-extended-attributes">16.1.5.1. 리눅스 확장 어트리뷰트</a></li>
</ul>
</li>
<li><a class="reference internal" href="#process-management">16.1.6. 프로세스 관리</a></li>
<li><a class="reference internal" href="#interface-to-the-scheduler">16.1.7. 스케줄러에 대한 인터페이스</a></li>
<li><a class="reference internal" href="#miscellaneous-system-information">16.1.8. 기타 시스템 정보</a></li>
<li><a class="reference internal" href="#random-numbers">16.1.9. 난수</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="allos.html"
                        title="이전 장">16. 일반 운영 체제 서비스</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="io.html"
                        title="다음 장">16.2. <code class="docutils literal"><span class="pre">io</span></code> --- Core tools for working with streams</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="io.html" title="16.2. io --- Core tools for working with streams"
             >다음</a> |</li>
        <li class="right" >
          <a href="allos.html" title="16. 일반 운영 체제 서비스"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >16. 일반 운영 체제 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2018, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 를 사용해서 만들었습니다.
    </div>

  </body>
</html>