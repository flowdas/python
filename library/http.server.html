
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>http.server --- HTTP 서버 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="http.cookies --- HTTP 상태 관리" href="http.cookies.html" />
    <link rel="prev" title="socketserver --- 네트워크 서버를 위한 프레임워크" href="socketserver.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/http.server.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="http.cookies.html" title="http.cookies --- HTTP 상태 관리"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="socketserver.html" title="socketserver --- 네트워크 서버를 위한 프레임워크"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-http.server">
<span id="http-server-http-servers"></span><h1><a class="reference internal" href="#module-http.server" title="http.server: HTTP server and request handlers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.server</span></code></a> --- HTTP 서버<a class="headerlink" href="#module-http.server" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/http/server.py">Lib/http/server.py</a></p>
<hr class="docutils" id="index-0" />
<p>이 모듈은 HTTP 서버(웹 서버)를 구현하기 위한 클래스를 정의합니다.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>프로덕션에는 <a class="reference internal" href="#module-http.server" title="http.server: HTTP server and request handlers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.server</span></code></a>가 권장되지 않습니다. 기초적인 보안 검사만 구현합니다.</p>
</div>
<p><a class="reference internal" href="#http.server.HTTPServer" title="http.server.HTTPServer"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPServer</span></code></a> 클래스는 <a class="reference internal" href="socketserver.html#socketserver.TCPServer" title="socketserver.TCPServer"><code class="xref py py-class docutils literal notranslate"><span class="pre">socketserver.TCPServer</span></code></a> 서브 클래스입니다. HTTP 소켓을 만들고 리스닝하면서 요청을 처리기로 디스패치 합니다. 서버를 만들고 실행하는 코드는 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">server_class</span><span class="o">=</span><span class="n">HTTPServer</span><span class="p">,</span> <span class="n">handler_class</span><span class="o">=</span><span class="n">BaseHTTPRequestHandler</span><span class="p">):</span>
    <span class="n">server_address</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>
    <span class="n">httpd</span> <span class="o">=</span> <span class="n">server_class</span><span class="p">(</span><span class="n">server_address</span><span class="p">,</span> <span class="n">handler_class</span><span class="p">)</span>
    <span class="n">httpd</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<dl class="class">
<dt id="http.server.HTTPServer">
<em class="property">class </em><code class="sig-prename descclassname">http.server.</code><code class="sig-name descname">HTTPServer</code><span class="sig-paren">(</span><em class="sig-param">server_address</em>, <em class="sig-param">RequestHandlerClass</em><span class="sig-paren">)</span><a class="headerlink" href="#http.server.HTTPServer" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 <a class="reference internal" href="socketserver.html#socketserver.TCPServer" title="socketserver.TCPServer"><code class="xref py py-class docutils literal notranslate"><span class="pre">TCPServer</span></code></a> 클래스를 기반으로 하고, 서버 주소를 <code class="xref py py-attr docutils literal notranslate"><span class="pre">server_name</span></code>과 <code class="xref py py-attr docutils literal notranslate"><span class="pre">server_port</span></code>라는 인스턴스 변수로 저장합니다. 처리기는 일반적으로 처리기의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">server</span></code> 인스턴스 변수를 통해 서버에 액세스 할 수 있습니다.</p>
</dd></dl>

<dl class="class">
<dt id="http.server.ThreadingHTTPServer">
<em class="property">class </em><code class="sig-prename descclassname">http.server.</code><code class="sig-name descname">ThreadingHTTPServer</code><span class="sig-paren">(</span><em class="sig-param">server_address</em>, <em class="sig-param">RequestHandlerClass</em><span class="sig-paren">)</span><a class="headerlink" href="#http.server.ThreadingHTTPServer" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 HTTPServer와 동일하지만 <a class="reference internal" href="socketserver.html#socketserver.ThreadingMixIn" title="socketserver.ThreadingMixIn"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadingMixIn</span></code></a>을 사용하여 요청을 처리하는 데 스레드를 사용합니다. <a class="reference internal" href="#http.server.HTTPServer" title="http.server.HTTPServer"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPServer</span></code></a>가 무기한 대기하도록 만드는 소켓을 미리 여는 웹 브라우저를 처리하는 데 유용합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<p><a class="reference internal" href="#http.server.HTTPServer" title="http.server.HTTPServer"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPServer</span></code></a>와 <a class="reference internal" href="#http.server.ThreadingHTTPServer" title="http.server.ThreadingHTTPServer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadingHTTPServer</span></code></a>는 인스턴스 화할 때 <em>RequestHandlerClass</em>를 제공해야 하며, 이 모듈은 세 가지 변형을 제공합니다:</p>
<dl class="class">
<dt id="http.server.BaseHTTPRequestHandler">
<em class="property">class </em><code class="sig-prename descclassname">http.server.</code><code class="sig-name descname">BaseHTTPRequestHandler</code><span class="sig-paren">(</span><em class="sig-param">request</em>, <em class="sig-param">client_address</em>, <em class="sig-param">server</em><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 서버에 도착하는 HTTP 요청을 처리하는 데 사용됩니다. 그 자체로는, 실제 HTTP 요청에 응답할 수 없습니다; 각 요청 메서드(예를 들어 GET이나 POST)를 처리하려면 서브 클래스를 만들어야 합니다. <a class="reference internal" href="#http.server.BaseHTTPRequestHandler" title="http.server.BaseHTTPRequestHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHTTPRequestHandler</span></code></a>는 많은 클래스 및 인스턴스 변수와 서브 클래스가 사용할 메서드를 제공합니다.</p>
<p>처리기는 요청과 헤더를 구문 분석한 다음, 요청 유형에 특정한 메서드를 호출합니다. 메서드 이름은 요청으로부터 구성됩니다. 예를 들어, 요청 메서드 <code class="docutils literal notranslate"><span class="pre">SPAM</span></code>의 경우, <code class="xref py py-meth docutils literal notranslate"><span class="pre">do_SPAM()</span></code> 메서드가 인자 없이 호출됩니다. 모든 관련 정보는 처리기의 인스턴스 변수에 저장됩니다. 서브 클래스는 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드를 대체하거나 확장할 필요가 없습니다.</p>
<p><a class="reference internal" href="#http.server.BaseHTTPRequestHandler" title="http.server.BaseHTTPRequestHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHTTPRequestHandler</span></code></a>에는 다음과 같은 인스턴스 변수가 있습니다:</p>
<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.client_address">
<code class="sig-name descname">client_address</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.client_address" title="정의 주소">¶</a></dt>
<dd><p>클라이언트 주소를 나타내는 <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code> 형식의 튜플을 포함합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.server">
<code class="sig-name descname">server</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.server" title="정의 주소">¶</a></dt>
<dd><p>서버 인스턴스를 포함합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.close_connection">
<code class="sig-name descname">close_connection</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.close_connection" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#http.server.BaseHTTPRequestHandler.handle_one_request" title="http.server.BaseHTTPRequestHandler.handle_one_request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle_one_request()</span></code></a>가 반환되기 전에 설정해야 하는 불리언으로, 다른 요청이 기대되는지, 또는 연결을 종료해야 하는지를 나타냅니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.requestline">
<code class="sig-name descname">requestline</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.requestline" title="정의 주소">¶</a></dt>
<dd><p>HTTP 요청 줄의 문자열 표현을 포함합니다. 종료 CRLF가 제거됩니다. 이 어트리뷰트는 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.handle_one_request" title="http.server.BaseHTTPRequestHandler.handle_one_request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle_one_request()</span></code></a>에서 설정해야 합니다. 유효한 요청 줄이 처리되지 않았으면, 빈 문자열로 설정해야 합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.command">
<code class="sig-name descname">command</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.command" title="정의 주소">¶</a></dt>
<dd><p>명령(요청 유형)을 포함합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">'GET'</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.path" title="정의 주소">¶</a></dt>
<dd><p>요청 경로를 포함합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.request_version">
<code class="sig-name descname">request_version</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.request_version" title="정의 주소">¶</a></dt>
<dd><p>요청의 버전 문자열을 포함합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">'HTTP/1.0'</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.headers">
<code class="sig-name descname">headers</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.headers" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#http.server.BaseHTTPRequestHandler.MessageClass" title="http.server.BaseHTTPRequestHandler.MessageClass"><code class="xref py py-attr docutils literal notranslate"><span class="pre">MessageClass</span></code></a> 클래스 변수로 지정된 클래스의 인스턴스를 보유합니다. 이 인스턴스는 HTTP 요청의 헤더를 구문 분석하고 관리합니다. <a class="reference internal" href="http.client.html#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.client</span></code></a>의 <a class="reference internal" href="http.client.html#http.client.parse_headers" title="http.client.parse_headers"><code class="xref py py-func docutils literal notranslate"><span class="pre">parse_headers()</span></code></a> 함수가 헤더를 구문 분석하는 데 사용되며 HTTP 요청이 유효한 <span class="target" id="index-3"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html"><strong>RFC 2822</strong></a> 스타일 헤더를 제공할 것을 요구합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.rfile">
<code class="sig-name descname">rfile</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.rfile" title="정의 주소">¶</a></dt>
<dd><p>선택적 입력 데이터의 시작부터 읽을 준비가 된 <a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedIOBase</span></code></a> 입력 스트림.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.wfile">
<code class="sig-name descname">wfile</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.wfile" title="정의 주소">¶</a></dt>
<dd><p>클라이언트로 돌려줄 응답을 쓰기 위한 출력 스트림을 포함합니다. HTTP 클라이언트와의 성공적인 상호 운용을 위해서 이 스트림에 쓸 때 HTTP 프로토콜을 올바르게 준수해야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>이것은 <a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedIOBase</span></code></a> 스트림입니다.</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#http.server.BaseHTTPRequestHandler" title="http.server.BaseHTTPRequestHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHTTPRequestHandler</span></code></a>에는 다음과 같은 어트리뷰트가 있습니다:</p>
<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.server_version">
<code class="sig-name descname">server_version</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.server_version" title="정의 주소">¶</a></dt>
<dd><p>서버 소프트웨어 버전을 지정합니다. 이것을 재정의하고 싶을 수 있습니다. 형식은 여러 공백으로 구분된 문자열이며, 각 문자열은 name[/version] 형식입니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">'BaseHTTP/0.2'</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.sys_version">
<code class="sig-name descname">sys_version</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.sys_version" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#http.server.BaseHTTPRequestHandler.version_string" title="http.server.BaseHTTPRequestHandler.version_string"><code class="xref py py-attr docutils literal notranslate"><span class="pre">version_string</span></code></a> 메서드와 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.server_version" title="http.server.BaseHTTPRequestHandler.server_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">server_version</span></code></a> 클래스 변수에서 사용할 수 있는 형식으로 파이썬 시스템 버전을 포함합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">'Python/1.4'</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.error_message_format">
<code class="sig-name descname">error_message_format</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.error_message_format" title="정의 주소">¶</a></dt>
<dd><p>클라이언트에 대한 에러 응답을 빌드하기 위해 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.send_error" title="http.server.BaseHTTPRequestHandler.send_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_error()</span></code></a> 메서드에서 사용해야 하는 포맷 문자열을 지정합니다. 문자열은 기본적으로 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.send_error" title="http.server.BaseHTTPRequestHandler.send_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_error()</span></code></a>에 전달된 상태 코드에 따라 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.responses" title="http.server.BaseHTTPRequestHandler.responses"><code class="xref py py-attr docutils literal notranslate"><span class="pre">responses</span></code></a>의 변수로 채워집니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.error_content_type">
<code class="sig-name descname">error_content_type</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.error_content_type" title="정의 주소">¶</a></dt>
<dd><p>클라이언트로 전송되는 에러 응답의 Content-Type HTTP 헤더를 지정합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'text/html'</span></code>입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.protocol_version">
<code class="sig-name descname">protocol_version</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.protocol_version" title="정의 주소">¶</a></dt>
<dd><p>응답에 사용되는 HTTP 프로토콜 버전을 지정합니다. <code class="docutils literal notranslate"><span class="pre">'HTTP/1.1'</span></code>로 설정되면, 서버는 HTTP 지속적 연결(persistent connections)을 허용합니다; 그러나, 이때 서버는 <em>반드시</em> 클라이언트에 대한 모든 응답에 (<a class="reference internal" href="#http.server.BaseHTTPRequestHandler.send_header" title="http.server.BaseHTTPRequestHandler.send_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_header()</span></code></a>를 사용해서) 정확한 <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> 헤더를 포함해야 합니다. 이전 버전과의 호환성을 위해, 기본 설정은 <code class="docutils literal notranslate"><span class="pre">'HTTP/1.0'</span></code>입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.MessageClass">
<code class="sig-name descname">MessageClass</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.MessageClass" title="정의 주소">¶</a></dt>
<dd><p>HTTP 헤더를 구문 분석할 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.message.Message</span></code></a>와 유사한 클래스를 지정합니다. 일반적으로, 이는 재정의되지 않으며, 기본값은 <code class="xref py py-class docutils literal notranslate"><span class="pre">http.client.HTTPMessage</span></code>입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.BaseHTTPRequestHandler.responses">
<code class="sig-name descname">responses</code><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.responses" title="정의 주소">¶</a></dt>
<dd><p>이 어트리뷰트에는 에러 코드 정수에서 짧고 긴 메시지를 포함하는 두 요소 튜플로의 매핑이 포함됩니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">{code:</span> <span class="pre">(shortmessage,</span> <span class="pre">longmessage)}</span></code>. <em>shortmessage</em>는 일반적으로 에러 응답에서 <em>message</em> 키로 사용되고, <em>longmessage</em>는 <em>explain</em> 키로 사용됩니다. <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.send_response_only" title="http.server.BaseHTTPRequestHandler.send_response_only"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_response_only()</span></code></a>와 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.send_error" title="http.server.BaseHTTPRequestHandler.send_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_error()</span></code></a> 메서드에서 사용됩니다.</p>
</dd></dl>

<p><a class="reference internal" href="#http.server.BaseHTTPRequestHandler" title="http.server.BaseHTTPRequestHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHTTPRequestHandler</span></code></a> 인스턴스에는 다음과 같은 메서드가 있습니다:</p>
<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.handle">
<code class="sig-name descname">handle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.handle" title="정의 주소">¶</a></dt>
<dd><p>들어오는 HTTP 요청을 처리하기 위해 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.handle_one_request" title="http.server.BaseHTTPRequestHandler.handle_one_request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle_one_request()</span></code></a>를 한 번 (또는, 지속적 연결이 활성화되었으면, 여러 번) 호출합니다. 재정의할 필요는 없습니다; 대신 적절한 <code class="xref py py-meth docutils literal notranslate"><span class="pre">do_*()</span></code> 메서드를 구현하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.handle_one_request">
<code class="sig-name descname">handle_one_request</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.handle_one_request" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 요청을 구문 분석하여 적절한 <code class="xref py py-meth docutils literal notranslate"><span class="pre">do_*()</span></code> 메서드로 디스패치 합니다. 재정의할 필요는 없습니다.</p>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.handle_expect_100">
<code class="sig-name descname">handle_expect_100</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.handle_expect_100" title="정의 주소">¶</a></dt>
<dd><p>HTTP/1.1 호환 서버가 <code class="docutils literal notranslate"><span class="pre">Expect:</span> <span class="pre">100-continue</span></code> 요청 헤더를 수신하면 <code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">Continue</span></code>로 응답한 후 <code class="docutils literal notranslate"><span class="pre">200</span> <span class="pre">OK</span></code> 헤더가 뒤따릅니다. 클라이언트가 계속하는 것을 서버가 원하지 않으면 에러를 발생시키기 위해 이 메서드를 재정의할 수 있습니다. 예를 들어 서버는 <code class="docutils literal notranslate"><span class="pre">417</span> <span class="pre">Expectation</span> <span class="pre">Failed</span></code>를 응답 헤더로 보내고 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">False</span></code> 할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.send_error">
<code class="sig-name descname">send_error</code><span class="sig-paren">(</span><em class="sig-param">code</em>, <em class="sig-param">message=None</em>, <em class="sig-param">explain=None</em><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.send_error" title="정의 주소">¶</a></dt>
<dd><p>클라이언트에게 완전한 에러 응답을 보내고 로깅 합니다. 숫자 <em>code</em>는 HTTP 에러 코드를 지정하며, <em>message</em>는 선택적인 사람이 읽을 수 있는 에러에 대한 간단한 설명입니다. <em>explain</em> 인자는 에러에 대한 자세한 정보를 제공하는 데 사용될 수 있습니다; <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.error_message_format" title="http.server.BaseHTTPRequestHandler.error_message_format"><code class="xref py py-attr docutils literal notranslate"><span class="pre">error_message_format</span></code></a> 어트리뷰트를 사용하여 포맷되고 전체 헤더 집합 뒤에 응답 바디로 보냅니다. <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.responses" title="http.server.BaseHTTPRequestHandler.responses"><code class="xref py py-attr docutils literal notranslate"><span class="pre">responses</span></code></a> 어트리뷰트는 값이 제공되지 않을 때 사용될 <em>message</em>와 <em>explain</em>의 기본값을 담고 있습니다; 알 수 없는 코드의 경우 둘 다 기본값은 문자열 <code class="docutils literal notranslate"><span class="pre">???</span></code>입니다. 메서드가 HEAD이거나 응답 코드가 <code class="docutils literal notranslate"><span class="pre">1xx</span></code>, <code class="docutils literal notranslate"><span class="pre">204</span> <span class="pre">No</span> <span class="pre">Content</span></code>, <code class="docutils literal notranslate"><span class="pre">205</span> <span class="pre">Reset</span> <span class="pre">Content</span></code>, <code class="docutils literal notranslate"><span class="pre">304</span> <span class="pre">Not</span> <span class="pre">Modified</span></code> 중 하나면 바디는 비어 있게 됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>에러 응답에는 Content-Length 헤더가 포함됩니다. <em>explain</em> 인자를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.send_response">
<code class="sig-name descname">send_response</code><span class="sig-paren">(</span><em class="sig-param">code</em>, <em class="sig-param">message=None</em><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.send_response" title="정의 주소">¶</a></dt>
<dd><p>헤더 버퍼에 응답 헤더를 추가하고 받아들인 요청을 로깅 합니다. HTTP 응답 줄이 내부 버퍼에 기록되고, <em>Server</em>와 <em>Date</em> 헤더가 뒤따릅니다. 이 두 헤더의 값은 각각 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.version_string" title="http.server.BaseHTTPRequestHandler.version_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">version_string()</span></code></a>과 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.date_time_string" title="http.server.BaseHTTPRequestHandler.date_time_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">date_time_string()</span></code></a> 메서드에서 취합니다. 서버가 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.send_header" title="http.server.BaseHTTPRequestHandler.send_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_header()</span></code></a> 메서드를 사용하여 다른 헤더를 보내려고 하지 않는다면, <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.send_response" title="http.server.BaseHTTPRequestHandler.send_response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_response()</span></code></a> 다음에 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.end_headers" title="http.server.BaseHTTPRequestHandler.end_headers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end_headers()</span></code></a> 호출이 있어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>헤더는 내부 버퍼에 저장되며 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.end_headers" title="http.server.BaseHTTPRequestHandler.end_headers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end_headers()</span></code></a>를 명시적으로 호출해야 합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.send_header">
<code class="sig-name descname">send_header</code><span class="sig-paren">(</span><em class="sig-param">keyword</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.send_header" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#http.server.BaseHTTPRequestHandler.end_headers" title="http.server.BaseHTTPRequestHandler.end_headers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end_headers()</span></code></a>나 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.flush_headers" title="http.server.BaseHTTPRequestHandler.flush_headers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flush_headers()</span></code></a>가 호출될 때 출력 스트림에 기록될 내부 버퍼에 HTTP 헤더를 추가합니다. <em>keyword</em>는 헤더 키워드를 지정하고, <em>value</em>는 값을 지정해야 합니다. send_header 호출이 완료된 후, 작업을 완료하려면 반드시 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.end_headers" title="http.server.BaseHTTPRequestHandler.end_headers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">end_headers()</span></code></a>를 호출해야 함에 유의하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>헤더는 내부 버퍼에 저장됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.send_response_only">
<code class="sig-name descname">send_response_only</code><span class="sig-paren">(</span><em class="sig-param">code</em>, <em class="sig-param">message=None</em><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.send_response_only" title="정의 주소">¶</a></dt>
<dd><p>응답 헤더만 보내는데, 서버가 <code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">Continue</span></code> 응답을 클라이언트로 전송할 목적으로 사용됩니다. 헤더는 버퍼링 되지 않고 출력 스트림으로 직접 전송합니다. <em>message</em>를 지정하지 않으면, 응답 <em>code</em>에 해당하는 HTTP 메시지가 전송됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.end_headers">
<code class="sig-name descname">end_headers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.end_headers" title="정의 주소">¶</a></dt>
<dd><p>(응답에서 HTTP 헤더의 끝을 나타내는) 빈 줄을 헤더 버퍼에 추가하고 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.flush_headers" title="http.server.BaseHTTPRequestHandler.flush_headers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flush_headers()</span></code></a>를 호출합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>버퍼링 된 헤더는 출력 스트림에 기록됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.flush_headers">
<code class="sig-name descname">flush_headers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.flush_headers" title="정의 주소">¶</a></dt>
<dd><p>마지막으로 헤더를 출력 스트림으로 보내고 내부 헤더 버퍼를 플러시 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.log_request">
<code class="sig-name descname">log_request</code><span class="sig-paren">(</span><em class="sig-param">code='-'</em>, <em class="sig-param">size='-'</em><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.log_request" title="정의 주소">¶</a></dt>
<dd><p>받아들인 (성공적인) 요청을 로깅 합니다. <em>code</em>는 응답과 관련된 숫자 HTTP 코드를 지정해야 합니다. 응답의 크기가 있으면, <em>size</em> 매개 변수로 전달되어야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.log_error">
<code class="sig-name descname">log_error</code><span class="sig-paren">(</span><em class="sig-param">...</em><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.log_error" title="정의 주소">¶</a></dt>
<dd><p>요청을 이행할 수 없을 때 에러를 로깅 합니다. 기본적으로, 메시지를 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.log_message" title="http.server.BaseHTTPRequestHandler.log_message"><code class="xref py py-meth docutils literal notranslate"><span class="pre">log_message()</span></code></a>에 전달하므로, 같은 인자(<em>format</em>과 추가 값)를 취합니다.</p>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.log_message">
<code class="sig-name descname">log_message</code><span class="sig-paren">(</span><em class="sig-param">format</em>, <em class="sig-param">...</em><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.log_message" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>에 임의의 메시지를 로깅 합니다. 이것은 일반적으로 사용자 지정 에러 로깅 메커니즘을 만들기 위해 재정의됩니다. <em>format</em> 인자는 표준 printf 스타일 포맷 문자열이며, <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.log_message" title="http.server.BaseHTTPRequestHandler.log_message"><code class="xref py py-meth docutils literal notranslate"><span class="pre">log_message()</span></code></a>에 대한 추가 인자는 포매팅의 입력으로 적용됩니다. 클라이언트 ip 주소와 현재 날짜 및 시간은 로깅 되는 모든 메시지 앞에 붙습니다.</p>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.version_string">
<code class="sig-name descname">version_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.version_string" title="정의 주소">¶</a></dt>
<dd><p>서버 소프트웨어의 버전 문자열을 반환합니다. 이것은 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.server_version" title="http.server.BaseHTTPRequestHandler.server_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">server_version</span></code></a>과 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler.sys_version" title="http.server.BaseHTTPRequestHandler.sys_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys_version</span></code></a> 어트리뷰트의 조합입니다.</p>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.date_time_string">
<code class="sig-name descname">date_time_string</code><span class="sig-paren">(</span><em class="sig-param">timestamp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.date_time_string" title="정의 주소">¶</a></dt>
<dd><p><em>timestamp</em>(<code class="docutils literal notranslate"><span class="pre">None</span></code>이거나 <a class="reference internal" href="time.html#time.time" title="time.time"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.time()</span></code></a>이 반환한 형식이어야 합니다)로 지정된 날짜와 시간을 메시지 헤더용으로 포맷하여 반환합니다. <em>timestamp</em>를 생략하면, 현재 날짜와 시간이 사용됩니다.</p>
<p>결과는 <code class="docutils literal notranslate"><span class="pre">'Sun,</span> <span class="pre">06</span> <span class="pre">Nov</span> <span class="pre">1994</span> <span class="pre">08:49:37</span> <span class="pre">GMT'</span></code>와 같은 모습입니다.</p>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.log_date_time_string">
<code class="sig-name descname">log_date_time_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.log_date_time_string" title="정의 주소">¶</a></dt>
<dd><p>로깅용으로 포맷한 현재 날짜와 시간을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="http.server.BaseHTTPRequestHandler.address_string">
<code class="sig-name descname">address_string</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#http.server.BaseHTTPRequestHandler.address_string" title="정의 주소">¶</a></dt>
<dd><p>클라이언트 주소를 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>이전에는, 이름 조회가 수행되었습니다. 이름 결정(name resolution) 지연을 피하고자, 이제 항상 IP 주소를 반환합니다.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="http.server.SimpleHTTPRequestHandler">
<em class="property">class </em><code class="sig-prename descclassname">http.server.</code><code class="sig-name descname">SimpleHTTPRequestHandler</code><span class="sig-paren">(</span><em class="sig-param">request</em>, <em class="sig-param">client_address</em>, <em class="sig-param">server</em>, <em class="sig-param">directory=None</em><span class="sig-paren">)</span><a class="headerlink" href="#http.server.SimpleHTTPRequestHandler" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 디렉터리 구조를 HTTP 요청에 직접 매핑하여 현재 디렉터리와 그 이하의 파일을 제공합니다.</p>
<p>요청 구문 분석과 같은 많은 작업이 베이스 클래스 <a class="reference internal" href="#http.server.BaseHTTPRequestHandler" title="http.server.BaseHTTPRequestHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHTTPRequestHandler</span></code></a> 에 의해 수행됩니다. 이 클래스는 <a class="reference internal" href="#http.server.SimpleHTTPRequestHandler.do_GET" title="http.server.SimpleHTTPRequestHandler.do_GET"><code class="xref py py-func docutils literal notranslate"><span class="pre">do_GET()</span></code></a>과 <a class="reference internal" href="#http.server.SimpleHTTPRequestHandler.do_HEAD" title="http.server.SimpleHTTPRequestHandler.do_HEAD"><code class="xref py py-func docutils literal notranslate"><span class="pre">do_HEAD()</span></code></a> 함수를 구현합니다.</p>
<p>다음은 <a class="reference internal" href="#http.server.SimpleHTTPRequestHandler" title="http.server.SimpleHTTPRequestHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleHTTPRequestHandler</span></code></a> 의 클래스 수준 어트리뷰트로 정의됩니다:</p>
<dl class="attribute">
<dt id="http.server.SimpleHTTPRequestHandler.server_version">
<code class="sig-name descname">server_version</code><a class="headerlink" href="#http.server.SimpleHTTPRequestHandler.server_version" title="정의 주소">¶</a></dt>
<dd><p>이것은 <code class="docutils literal notranslate"><span class="pre">&quot;SimpleHTTP/&quot;</span> <span class="pre">+</span> <span class="pre">__version__</span></code>이며, 여기서 <code class="docutils literal notranslate"><span class="pre">__version__</span></code>은 모듈 수준에서 정의됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="http.server.SimpleHTTPRequestHandler.extensions_map">
<code class="sig-name descname">extensions_map</code><a class="headerlink" href="#http.server.SimpleHTTPRequestHandler.extensions_map" title="정의 주소">¶</a></dt>
<dd><p>접미사를 MIME 형식으로 매핑하는 딕셔너리. 기본 시스템 매핑에 대한 사용자 정의 재정의를 포함합니다. 매핑은 대소 문자를 구분 없이 사용되므로, 소문자 키만 포함해야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>이 딕셔너리는 더는 기본 시스템 매핑으로 채워지지 않고, 재정의 만 포함합니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="http.server.SimpleHTTPRequestHandler.directory">
<code class="sig-name descname">directory</code><a class="headerlink" href="#http.server.SimpleHTTPRequestHandler.directory" title="정의 주소">¶</a></dt>
<dd><p>지정되지 않으면, 제공할 디렉터리는 현재 작업 디렉터리입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span><a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#http.server.SimpleHTTPRequestHandler" title="http.server.SimpleHTTPRequestHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleHTTPRequestHandler</span></code></a> 클래스는 다음 메서드를 정의합니다:</p>
<dl class="method">
<dt id="http.server.SimpleHTTPRequestHandler.do_HEAD">
<code class="sig-name descname">do_HEAD</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#http.server.SimpleHTTPRequestHandler.do_HEAD" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <code class="docutils literal notranslate"><span class="pre">'HEAD'</span></code> 요청 유형을 제공합니다: 동등한 <code class="docutils literal notranslate"><span class="pre">GET</span></code> 요청에 대해 전송할 헤더를 전송합니다. 가능한 헤더에 대한 더 완전한 설명은 <a class="reference internal" href="#http.server.SimpleHTTPRequestHandler.do_GET" title="http.server.SimpleHTTPRequestHandler.do_GET"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_GET()</span></code></a> 메서드를 참조하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="http.server.SimpleHTTPRequestHandler.do_GET">
<code class="sig-name descname">do_GET</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#http.server.SimpleHTTPRequestHandler.do_GET" title="정의 주소">¶</a></dt>
<dd><p>요청을 현재 작업 디렉터리에 상대적인 경로로 해석하여 요청은 로컬 파일에 매핑됩니다.</p>
<p>요청이 디렉터리에 매핑되었으면, 디렉터리는 <code class="docutils literal notranslate"><span class="pre">index.html</span></code>이나 <code class="docutils literal notranslate"><span class="pre">index.htm</span></code> (이 순서대로) 파일을 검사합니다. 발견되면, 파일 내용이 반환됩니다; 그렇지 않으면 <code class="xref py py-meth docutils literal notranslate"><span class="pre">list_directory()</span></code> 메서드를 호출하여 디렉터리 목록이 생성됩니다. 이 메서드는 <a class="reference internal" href="os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a>을 사용하여 디렉터리를 스캔하고, <a class="reference internal" href="os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">listdir()</span></code></a>이 실패하면 <code class="docutils literal notranslate"><span class="pre">404</span></code> 에러 응답을 반환합니다.</p>
<p>요청이 파일에 매핑되었으면, 파일을 엽니다. 요청된 파일을 열 때 발생하는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 예외는 <code class="docutils literal notranslate"><span class="pre">404</span></code>, <code class="docutils literal notranslate"><span class="pre">'File</span> <span class="pre">not</span> <span class="pre">found'</span></code> 에러로 매핑됩니다. 요청에 <code class="docutils literal notranslate"><span class="pre">'If-Modified-Since'</span></code> 헤더가 있고, 이 시간 이후 파일이 수정되지 않았으면, <code class="docutils literal notranslate"><span class="pre">304</span></code>, <code class="docutils literal notranslate"><span class="pre">'Not</span> <span class="pre">Modified'</span></code> 응답이 전송됩니다. 그렇지 않으면, 콘텐츠 유형은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">guess_type()</span></code> 메서드를 호출하여 추측되며, 이 메서드는 <em>extensions_map</em> 변수를 사용합니다. 그런 다음 파일 내용이 반환됩니다.</p>
<p>추측된 콘텐츠 유형의 <code class="docutils literal notranslate"><span class="pre">'Content-type:'</span></code> 헤더가 출력되고, 파일 크기가 담긴 <code class="docutils literal notranslate"><span class="pre">'Content-Length:'</span></code> 헤더와 파일 수정 시간이 담긴 <code class="docutils literal notranslate"><span class="pre">'Last-Modified:'</span></code> 헤더가 뒤따릅니다.</p>
<p>그런 다음 헤더의 끝을 나타내는 빈 줄이 따라온 후에, 파일의 내용이 출력됩니다. 파일의 MIME 유형이 <code class="docutils literal notranslate"><span class="pre">text/</span></code>로 시작하면 파일은 텍스트 모드로 열립니다; 그렇지 않으면 바이너리 모드가 사용됩니다.</p>
<p>사용 예로는, <a class="reference internal" href="#module-http.server" title="http.server: HTTP server and request handlers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.server</span></code></a> 모듈에서 <a class="reference internal" href="test.html#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-func docutils literal notranslate"><span class="pre">test()</span></code></a> 함수 호출 구현을 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'If-Modified-Since'</span></code> 헤더 지원.</p>
</div>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="#http.server.SimpleHTTPRequestHandler" title="http.server.SimpleHTTPRequestHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleHTTPRequestHandler</span></code></a> 클래스는 현재 디렉터리를 기준으로 파일을 제공하는 매우 기본적인 웹 서버를 만들기 위해 다음과 같은 방식으로 사용될 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">http.server</span>
<span class="kn">import</span> <span class="nn">socketserver</span>

<span class="n">PORT</span> <span class="o">=</span> <span class="mi">8000</span>

<span class="n">Handler</span> <span class="o">=</span> <span class="n">http</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">SimpleHTTPRequestHandler</span>

<span class="k">with</span> <span class="n">socketserver</span><span class="o">.</span><span class="n">TCPServer</span><span class="p">((</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">PORT</span><span class="p">),</span> <span class="n">Handler</span><span class="p">)</span> <span class="k">as</span> <span class="n">httpd</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;serving at port&quot;</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
    <span class="n">httpd</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p id="http-server-cli"><a class="reference internal" href="#module-http.server" title="http.server: HTTP server and request handlers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.server</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">포트</span> <span class="pre">번호</span></code> 인자와 함께 인터프리터의 <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 스위치를 사용하여 직접 호출할 수도 있습니다. 앞의 예제와 유사하게, 이것은 현재 디렉터리를 기준으로 파일을 제공합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">http</span><span class="o">.</span><span class="n">server</span> <span class="mi">8000</span>
</pre></div>
</div>
<p>기본적으로, 서버는 모든 인터페이스에 자신을 바인드 합니다. 옵션 <code class="docutils literal notranslate"><span class="pre">-b/--bind</span></code>는 바인딩할 특정 주소를 지정합니다. IPv4와 IPv6 주소가 모두 지원됩니다. 예를 들어, 다음 명령은 서버가 localhost에만 바인드 하도록 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">http</span><span class="o">.</span><span class="n">server</span> <span class="mi">8000</span> <span class="o">--</span><span class="n">bind</span> <span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가: </span><code class="docutils literal notranslate"><span class="pre">--bind</span></code> 인자가 도입되었습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가: </span><code class="docutils literal notranslate"><span class="pre">--bind</span></code> 인자가 IPv6을 지원하도록 향상되었습니다</p>
</div>
<p>기본적으로 서버는 현재 디렉터리를 사용합니다. 옵션 <code class="docutils literal notranslate"><span class="pre">-d/--directory</span></code>는 파일을 제공할 디렉터리를 지정합니다. 예를 들어, 다음 명령은 특정 디렉터리를 사용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">http</span><span class="o">.</span><span class="n">server</span> <span class="o">--</span><span class="n">directory</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span><code class="docutils literal notranslate"><span class="pre">--directory</span></code>는 대체 디렉터리를 지정합니다</p>
</div>
<dl class="class">
<dt id="http.server.CGIHTTPRequestHandler">
<em class="property">class </em><code class="sig-prename descclassname">http.server.</code><code class="sig-name descname">CGIHTTPRequestHandler</code><span class="sig-paren">(</span><em class="sig-param">request</em>, <em class="sig-param">client_address</em>, <em class="sig-param">server</em><span class="sig-paren">)</span><a class="headerlink" href="#http.server.CGIHTTPRequestHandler" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 현재 디렉터리와 그 아래에 있는 파일이나 CGI 스크립트의 출력을 제공하는 데 사용됩니다. HTTP 계층 구조를 로컬 디렉터리 구조에 매핑하는 것은 <a class="reference internal" href="#http.server.SimpleHTTPRequestHandler" title="http.server.SimpleHTTPRequestHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleHTTPRequestHandler</span></code></a>와 정확히 같음에 유의하십시오.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#http.server.CGIHTTPRequestHandler" title="http.server.CGIHTTPRequestHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CGIHTTPRequestHandler</span></code></a> 클래스가 실행하는 CGI 스크립트는 리디렉션(HTTP 코드 302)을 실행할 수 없습니다, CGI 스크립트를 실행하기 전에 코드 200(스크립트 출력이 이어집니다)이 전송되기 때문입니다. 이것은 상태 코드를 선점합니다.</p>
</div>
<p>클래스는 CGI 스크립트라고 생각되면 파일로 제공하는 대신 CGI 스크립트를 실행합니다. 디렉터리 기반 CGI만 사용됩니다 --- 다른 일반적인 서버 구성은 특수한 확장자를 CGI 스크립트를 나타내는 것으로 취급하는 것입니다.</p>
<p>요청이 <code class="docutils literal notranslate"><span class="pre">cgi_directories</span></code> 경로 아래로 이어지면, 파일을 제공하는 대신 CGI 스크립트를 실행하고 출력을 제공하도록 <code class="xref py py-func docutils literal notranslate"><span class="pre">do_GET()</span></code>과 <code class="xref py py-func docutils literal notranslate"><span class="pre">do_HEAD()</span></code> 함수가 수정되었습니다.</p>
<p><a class="reference internal" href="#http.server.CGIHTTPRequestHandler" title="http.server.CGIHTTPRequestHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CGIHTTPRequestHandler</span></code></a>는 다음 데이터 멤버를 정의합니다:</p>
<dl class="attribute">
<dt id="http.server.CGIHTTPRequestHandler.cgi_directories">
<code class="sig-name descname">cgi_directories</code><a class="headerlink" href="#http.server.CGIHTTPRequestHandler.cgi_directories" title="정의 주소">¶</a></dt>
<dd><p>기본값은 <code class="docutils literal notranslate"><span class="pre">['/cgi-bin',</span> <span class="pre">'/htbin']</span></code>이며 CGI 스크립트를 포함하는 것으로 취급할 디렉터리를 기술합니다.</p>
</dd></dl>

<p><a class="reference internal" href="#http.server.CGIHTTPRequestHandler" title="http.server.CGIHTTPRequestHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CGIHTTPRequestHandler</span></code></a>는 다음 메서드를 정의합니다:</p>
<dl class="method">
<dt id="http.server.CGIHTTPRequestHandler.do_POST">
<code class="sig-name descname">do_POST</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#http.server.CGIHTTPRequestHandler.do_POST" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <code class="docutils literal notranslate"><span class="pre">'POST'</span></code> 요청 유형을 제공하며, CGI 스크립트에만 허용됩니다. CGI 이외의 url에 POST를 시도할 때 에러 501, &quot;Can only POST to CGI scripts&quot;가 출력됩니다.</p>
</dd></dl>

<p>보안상의 이유로, CGI 스크립트는 nobody 사용자의 UID로 실행됨에 유의하십시오. CGI 스크립트 문제는 에러 403으로 변환됩니다.</p>
</dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">--cgi</span></code> 옵션을 전달하여 명령 줄에서 <a class="reference internal" href="#http.server.CGIHTTPRequestHandler" title="http.server.CGIHTTPRequestHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CGIHTTPRequestHandler</span></code></a>를 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">http</span><span class="o">.</span><span class="n">server</span> <span class="o">--</span><span class="n">cgi</span> <span class="mi">8000</span>
</pre></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>이전 항목</h4>
  <p class="topless"><a href="socketserver.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socketserver</span></code> --- 네트워크 서버를 위한 프레임워크</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="http.cookies.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.cookies</span></code> --- HTTP 상태 관리</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="http.cookies.html" title="http.cookies --- HTTP 상태 관리"
             >다음</a> |</li>
        <li class="right" >
          <a href="socketserver.html" title="socketserver --- 네트워크 서버를 위한 프레임워크"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2021, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2021, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>