
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>struct --- 패킹 된 바이너리 데이터로 바이트열을 해석 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="codecs --- Codec registry and base classes" href="codecs.html" />
    <link rel="prev" title="바이너리 데이터 서비스" href="binary.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/struct.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="codecs.html" title="codecs --- Codec registry and base classes"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="binary.html" title="바이너리 데이터 서비스"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="binary.html" accesskey="U">바이너리 데이터 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-struct">
<span id="struct-interpret-bytes-as-packed-binary-data"></span><h1><a class="reference internal" href="#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> --- 패킹 된 바이너리 데이터로 바이트열을 해석<a class="headerlink" href="#module-struct" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/struct.py">Lib/struct.py</a></p>
<hr class="docutils" id="index-0" />
<p>이 모듈은 파이썬 값과 파이썬 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체로 표현되는 C 구조체 사이의 변환을 수행합니다. 다른 소스 중에서도, 파일에 저장되었거나 네트워크 연결에서 온 바이너리 데이터를 처리하는 데 사용할 수 있습니다. <a class="reference internal" href="#struct-format-strings"><span class="std std-ref">포맷 문자열</span></a>을 구조체의 배치와 파이썬 값과의 변환에 대한 간결한 기술로 사용합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>기본적으로, 주어진 C 구조체를 패킹한 결과에는 관련된 C형에 대한 적절한 정렬(alignment)을 유지하기 위해 패드(pad) 바이트가 포함됩니다; 마찬가지로, 언 패킹할 때 정렬이 고려됩니다. 이 동작은 패킹 된 구조체의 바이트열이 해당 C 구조체의 메모리 배치와 정확히 일치하도록 선택됩니다. 플랫폼 독립적인 데이터 형식을 처리하거나 묵시적 패드 바이트를 생략하려면, <code class="docutils literal notranslate"><span class="pre">native</span></code> 크기와 정렬 대신 <code class="docutils literal notranslate"><span class="pre">standard</span></code> 크기와 정렬을 사용하십시오: 자세한 내용은 <a class="reference internal" href="#struct-alignment"><span class="std std-ref">바이트 순서, 크기 및 정렬</span></a>을 참조하십시오.</p>
</div>
<p>여러 <a class="reference internal" href="#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 함수(그리고 <a class="reference internal" href="#struct.Struct" title="struct.Struct"><code class="xref py py-class docutils literal notranslate"><span class="pre">Struct</span></code></a> 의 메서드)는 <em>buffer</em> 인자를 취합니다. 이는 <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">버퍼 프로토콜</span></a>을 구현하고 읽을 수 있거나 읽고 쓸 수 있는 버퍼를 제공하는 객체를 나타냅니다. 이 목적으로 사용되는 가장 일반적인 형은 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>와 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>지만, 바이트 배열로 볼 수 있는 많은 다른 형이 버퍼 프로토콜을 구현하므로, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체에서 추가로 복사하지 않고도 읽고 채울 수 있습니다.</p>
<div class="section" id="functions-and-exceptions">
<h2>함수와 예외<a class="headerlink" href="#functions-and-exceptions" title="제목 주소">¶</a></h2>
<p>이 모듈은 다음과 같은 예외와 함수를 정의합니다:</p>
<dl class="exception">
<dt id="struct.error">
<em class="property">exception </em><code class="sig-prename descclassname">struct.</code><code class="sig-name descname">error</code><a class="headerlink" href="#struct.error" title="정의 주소">¶</a></dt>
<dd><p>여러 상황에서 발생하는 예외; 인자는 무엇이 잘못되었는지 설명하는 문자열입니다.</p>
</dd></dl>

<dl class="function">
<dt id="struct.pack">
<code class="sig-prename descclassname">struct.</code><code class="sig-name descname">pack</code><span class="sig-paren">(</span><em class="sig-param">format</em>, <em class="sig-param">v1</em>, <em class="sig-param">v2</em>, <em class="sig-param">...</em><span class="sig-paren">)</span><a class="headerlink" href="#struct.pack" title="정의 주소">¶</a></dt>
<dd><p><em>v1</em>, <em>v2</em>, ... 값을 포함하고 포맷 문자열 <em>format</em>에 따라 패킹 된 바이트열 객체를 반환합니다. 인자는 포맷이 요구하는 값과 정확히 일치해야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="struct.pack_into">
<code class="sig-prename descclassname">struct.</code><code class="sig-name descname">pack_into</code><span class="sig-paren">(</span><em class="sig-param">format</em>, <em class="sig-param">buffer</em>, <em class="sig-param">offset</em>, <em class="sig-param">v1</em>, <em class="sig-param">v2</em>, <em class="sig-param">...</em><span class="sig-paren">)</span><a class="headerlink" href="#struct.pack_into" title="정의 주소">¶</a></dt>
<dd><p>포맷 문자열 <em>format</em>에 따라 값 <em>v1</em>, <em>v2</em>, ... 를 패킹하고 패킹 된 바이트열을 쓰기 가능한 버퍼 <em>buffer</em>에 <em>offset</em> 위치에서부터 씁니다. <em>offset</em>은 필수 인자임에 유의하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="struct.unpack">
<code class="sig-prename descclassname">struct.</code><code class="sig-name descname">unpack</code><span class="sig-paren">(</span><em class="sig-param">format</em>, <em class="sig-param">buffer</em><span class="sig-paren">)</span><a class="headerlink" href="#struct.unpack" title="정의 주소">¶</a></dt>
<dd><p>포맷 문자열 <em>format</em>에 따라 버퍼 <em>buffer</em>(아마도 <code class="docutils literal notranslate"><span class="pre">pack(format,</span> <span class="pre">...)</span></code>으로 패킹 된)에서 언 패킹 합니다. 정확히 하나의 항목을 포함하더라도 결과는 튜플입니다. 바이트 단위의 버퍼 크기는 (<a class="reference internal" href="#struct.calcsize" title="struct.calcsize"><code class="xref py py-func docutils literal notranslate"><span class="pre">calcsize()</span></code></a>에 의해 반영되는) 포맷이 요구하는 크기와 일치해야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="struct.unpack_from">
<code class="sig-prename descclassname">struct.</code><code class="sig-name descname">unpack_from</code><span class="sig-paren">(</span><em class="sig-param">format</em>, <em class="sig-param">buffer</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#struct.unpack_from" title="정의 주소">¶</a></dt>
<dd><p>포맷 문자열 <em>format</em>에 따라, <em>offset</em> 위치에서 시작하여 <em>buffer</em>에서 언 패킹 합니다. 정확히 하나의 항목을 포함하더라도 결과는 튜플입니다. <em>offset</em> 위치에서 시작하여 바이트 단위로 측정한 버퍼 크기는 (<a class="reference internal" href="#struct.calcsize" title="struct.calcsize"><code class="xref py py-func docutils literal notranslate"><span class="pre">calcsize()</span></code></a>에 의해 반영되는) 포맷이 요구하는 크기 이상이어야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="struct.iter_unpack">
<code class="sig-prename descclassname">struct.</code><code class="sig-name descname">iter_unpack</code><span class="sig-paren">(</span><em class="sig-param">format</em>, <em class="sig-param">buffer</em><span class="sig-paren">)</span><a class="headerlink" href="#struct.iter_unpack" title="정의 주소">¶</a></dt>
<dd><p>포맷 문자열 <em>format</em>에 따라 버퍼 <em>buffer</em>에서 이터레이션을 통해 언 패킹 합니다. 이 함수는 모든 내용이 소비될 때까지 버퍼에서 같은 크기의 청크를 읽는 이터레이터를 반환합니다. 바이트 단위의 버퍼 크기는 (<a class="reference internal" href="#struct.calcsize" title="struct.calcsize"><code class="xref py py-func docutils literal notranslate"><span class="pre">calcsize()</span></code></a>에 의해 반영되는) 포맷이 요구하는 크기의 배수여야 합니다.</p>
<p>각 이터레이션은 포맷 문자열에 지정된 대로 튜플을 산출합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="struct.calcsize">
<code class="sig-prename descclassname">struct.</code><code class="sig-name descname">calcsize</code><span class="sig-paren">(</span><em class="sig-param">format</em><span class="sig-paren">)</span><a class="headerlink" href="#struct.calcsize" title="정의 주소">¶</a></dt>
<dd><p>포맷 문자열 <em>format</em>에 해당하는 구조체(<code class="docutils literal notranslate"><span class="pre">pack(format,</span> <span class="pre">...)</span></code>에 의해 생성되는 바이트열 객체)의 크기를 반환합니다.</p>
</dd></dl>

</div>
<div class="section" id="format-strings">
<span id="struct-format-strings"></span><h2>포맷 문자열<a class="headerlink" href="#format-strings" title="제목 주소">¶</a></h2>
<p>포맷 문자열은 데이터를 패킹과 언 패킹할 때 기대되는 배치를 지정하는 데 사용되는 메커니즘입니다. 이들은 패킹/언 패킹 될 데이터형을 지정하는 <a class="reference internal" href="#format-characters"><span class="std std-ref">포맷 문자</span></a>로 구축됩니다. 또한, <a class="reference internal" href="#struct-alignment"><span class="std std-ref">바이트 순서, 크기 및 정렬</span></a>을 제어하기 위한 특수 문자가 있습니다.</p>
<div class="section" id="byte-order-size-and-alignment">
<span id="struct-alignment"></span><h3>바이트 순서, 크기 및 정렬<a class="headerlink" href="#byte-order-size-and-alignment" title="제목 주소">¶</a></h3>
<p>기본적으로, C형은 기계의 네이티브 형식과 바이트 순서로 표현되며, 필요하면 (C 컴파일러에서 사용하는 규칙에 따라) 패드 바이트로 건너뛰어 적절하게 정렬됩니다.</p>
<p id="index-1">또는, 다음 표에 따라, 포맷 문자열의 첫 번째 문자를 사용하여 패킹 된 데이터의 바이트 순서, 크기 및 정렬을 표시할 수 있습니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 43%" />
<col style="width: 18%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>문자</p></th>
<th class="head"><p>바이트 순서</p></th>
<th class="head"><p>크기</p></th>
<th class="head"><p>정렬</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;</span></code></p></td>
<td><p>네이티브</p></td>
<td><p>네이티브</p></td>
<td><p>네이티브</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">=</span></code></p></td>
<td><p>네이티브</p></td>
<td><p>표준</p></td>
<td><p>none</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></p></td>
<td><p>리틀 엔디안</p></td>
<td><p>표준</p></td>
<td><p>none</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></td>
<td><p>빅 엔디안</p></td>
<td><p>표준</p></td>
<td><p>none</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">!</span></code></p></td>
<td><p>네트워크 (= 빅 엔디안)</p></td>
<td><p>표준</p></td>
<td><p>none</p></td>
</tr>
</tbody>
</table>
<p>첫 번째 문자가 이들 중 하나가 아니면, <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code>로 가정합니다.</p>
<p>네이티브 바이트 순서는 호스트 시스템에 따라 빅 엔디안이나 리틀 엔디안입니다. 예를 들어, 인텔 x86과 AMD64 (x86-64)는 리틀 엔디안입니다; 모토로라 68000과 PowerPC G5는 빅 엔디안입니다; ARM과 인텔 Itanium에는 전환 가능한 엔디안(bi-endian) 기능이 있습니다. 시스템의 엔디안을 확인하려면 <code class="docutils literal notranslate"><span class="pre">sys.byteorder</span></code>를 사용하십시오.</p>
<p>네이티브 크기와 정렬은 C 컴파일러의 <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> 표현식을 사용하여 결정됩니다. 이것은 항상 네이티브 바이트 순서와 결합합니다.</p>
<p>표준 크기는 포맷 문자에만 의존합니다; <a class="reference internal" href="#format-characters"><span class="std std-ref">포맷 문자</span></a> 섹션의 표를 참조하십시오.</p>
<p><code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code>과 <code class="docutils literal notranslate"><span class="pre">'='</span></code>의 차이점에 유의하십시오; 둘 다 네이티브 바이트 순서를 사용하지만, 후자는 크기와 정렬이 표준화됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">'!'</span></code> 형식은 네트워크 바이트 순서가 빅 엔디안인지 리틀 엔디안인지 기억할 수 없는 불쌍한 영혼을 위해 제공됩니다.</p>
<p>네이티브가 아닌 바이트 순서(강제 바이트 스와핑)를 표시하는 방법은 없습니다; <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code>나 <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>를 적절히 선택하십시오.</p>
<p>노트:</p>
<ol class="arabic simple">
<li><p>패딩은 연속되는 구조체 멤버 간에만 자동으로 추가됩니다. 인코딩된 구조체의 시작이나 끝에는 패딩이 추가되지 않습니다.</p></li>
<li><p>네이티브가 아닌 크기와 정렬을 사용할 때는 패딩이 추가되지 않습니다, 예를 들어 '&lt;', '&gt;', '=' 및 '!' 에서.</p></li>
<li><p>구조체의 끝을 특정 형의 정렬 요구 사항에 맞추려면, 반복 횟수가 0인 해당 형의 코드로 포맷을 끝내십시오. <a class="reference internal" href="#struct-examples"><span class="std std-ref">예</span></a>를 참조하십시오.</p></li>
</ol>
</div>
<div class="section" id="format-characters">
<span id="id1"></span><h3>포맷 문자<a class="headerlink" href="#format-characters" title="제목 주소">¶</a></h3>
<p>포맷 문자는 다음과 같은 의미가 있습니다; C와 파이썬 값 사이의 변환은 형을 주면 분명해야 합니다. '표준 크기' 열은 표준 크기를 사용할 때 패킹 된 값의 크기를 바이트 단위로 나타냅니다; 즉, 포맷 문자열이 <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'!'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'='</span></code> 중 하나로 시작하는 경우입니다. 네이티브 크기를 사용할 때, 패킹 된 값의 크기는 플랫폼에 따라 다릅니다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 32%" />
<col style="width: 24%" />
<col style="width: 20%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>포맷</p></th>
<th class="head"><p>C형</p></th>
<th class="head"><p>파이썬 형</p></th>
<th class="head"><p>표준 크기</p></th>
<th class="head"><p>노트</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x</span></code></p></td>
<td><p>패드 바이트</p></td>
<td><p>값이 없습니다</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">c</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code></p></td>
<td><p>길이가 1인 bytes</p></td>
<td><p>1</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">b</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">char</span></code></p></td>
<td><p>정수</p></td>
<td><p>1</p></td>
<td><p>(1), (2)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">B</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code></p></td>
<td><p>정수</p></td>
<td><p>1</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">?</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">_Bool</span></code></p></td>
<td><p>bool</p></td>
<td><p>1</p></td>
<td><p>(1)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">h</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">short</span></code></p></td>
<td><p>정수</p></td>
<td><p>2</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">H</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code></p></td>
<td><p>정수</p></td>
<td><p>2</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">i</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>정수</p></td>
<td><p>4</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">I</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code></p></td>
<td><p>정수</p></td>
<td><p>4</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">l</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">long</span></code></p></td>
<td><p>정수</p></td>
<td><p>4</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">L</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code></p></td>
<td><p>정수</p></td>
<td><p>4</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">q</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code></p></td>
<td><p>정수</p></td>
<td><p>8</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Q</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span>
<span class="pre">long</span></code></p></td>
<td><p>정수</p></td>
<td><p>8</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">n</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">ssize_t</span></code></p></td>
<td><p>정수</p></td>
<td></td>
<td><p>(3)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">N</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code></p></td>
<td><p>정수</p></td>
<td></td>
<td><p>(3)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">e</span></code></p></td>
<td><p>(6)</p></td>
<td><p>float</p></td>
<td><p>2</p></td>
<td><p>(4)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">f</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>float</p></td>
<td><p>4</p></td>
<td><p>(4)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">d</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">double</span></code></p></td>
<td><p>float</p></td>
<td><p>8</p></td>
<td><p>(4)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">char[]</span></code></p></td>
<td><p>bytes</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">p</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">char[]</span></code></p></td>
<td><p>bytes</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">P</span></code></p></td>
<td><p><code class="xref c c-type docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code></p></td>
<td><p>정수</p></td>
<td></td>
<td><p>(5)</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'n'</span></code>과 <code class="docutils literal notranslate"><span class="pre">'N'</span></code> 포맷에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'e'</span></code> 포맷에 대한 지원이 추가되었습니다.</p>
</div>
<p>노트:</p>
<ol class="arabic">
<li><p id="index-2"><code class="docutils literal notranslate"><span class="pre">'?'</span></code> 변환 코드는 C99가 정의한 <code class="xref c c-type docutils literal notranslate"><span class="pre">_Bool</span></code> 형에 해당합니다. 이 형을 사용할 수 없으면, <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code>를 사용하여 시뮬레이션 됩니다. 표준 모드에서는, 항상 1바이트로 표현됩니다.</p>
</li>
<li><p>정수 변환 코드 중 하나를 사용하여 정수가 아닌 값을 패킹하려고 할 때, 정수가 아닌 값에 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 메서드가 있으면 패킹 전에 해당 메서드가 호출되어 인자를 정수로 변환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>정수가 아닌 값에서 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 메서드를 사용하는 것은 3.2의 새로운 기능입니다.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">'n'</span></code>과 <code class="docutils literal notranslate"><span class="pre">'N'</span></code> 변환 코드는 (기본값이나 <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> 바이트 순서 문자로 선택된) 네이티브 크기에만 사용할 수 있습니다. 표준 크기의 경우, 응용 프로그램에 맞는 다른 정수 포맷을 사용할 수 있습니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'f'</span></code>, <code class="docutils literal notranslate"><span class="pre">'d'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'e'</span></code> 변환 코드의 경우, 패킹 된 표현은 플랫폼에서 사용하는 부동 소수점 형식과 관계없이 IEEE 754 binary32, binary64 또는 binary16 형식을 사용합니다 (각각 <code class="docutils literal notranslate"><span class="pre">'f'</span></code>, <code class="docutils literal notranslate"><span class="pre">'d'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'e'</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'P'</span></code> 포맷 문자는 (기본값이나 <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> 바이트 순서 문자로 선택된) 네이티브 바이트 순서에만 사용할 수 있습니다. 바이트 순서 문자 <code class="docutils literal notranslate"><span class="pre">'='</span></code>는 호스트 시스템에 따라 리틀이나 빅 엔디안 순서를 사용하도록 선택합니다. struct 모듈은 이를 네이티브 순서로 해석하지 않아서, <code class="docutils literal notranslate"><span class="pre">'P'</span></code> 형식을 사용할 수 없습니다.</p></li>
<li><p>IEEE 754 binary16 &quot;반 정밀도&quot; 형은 2008년 <a class="reference external" href="https://en.wikipedia.org/wiki/IEEE_floating_point#IEEE_754-2008">IEEE 754 표준</a> 개정판에서 도입되었습니다. 부호 비트, 5비트 지수 및 11비트 정밀도(10비트가 명시적으로 저장됩니다)를 가지며, 전체 정밀도에서 대략 <code class="docutils literal notranslate"><span class="pre">6.1e-05</span></code>와 <code class="docutils literal notranslate"><span class="pre">6.5e+04</span></code> 사이의 숫자를 나타낼 수 있습니다. 이 형은 C 컴파일러에서 널리 지원되지 않습니다: 일반적인 기계에서는, unsigned short를 저장에 사용할 수 있지만, 수학 연산에는 사용할 수 없습니다. 자세한 내용은 <a class="reference external" href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">half-precision floating-point format</a>의 Wikipedia 페이지를 참조하십시오.</p></li>
</ol>
<p>포맷 문자 앞에는 정수 반복 횟수가 올 수 있습니다. 예를 들어, 포맷 문자열 <code class="docutils literal notranslate"><span class="pre">'4h'</span></code>는 <code class="docutils literal notranslate"><span class="pre">'hhhh'</span></code>와 정확히 같습니다.</p>
<p>포맷 사이의 공백 문자는 무시됩니다; 횟수와 형식 사이에는 공백이 없어야 합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">'s'</span></code> 포맷 문자의 경우, 횟수는 다른 포맷 문자와 같은 반복 횟수가 아닌 바이트열의 길이로 해석됩니다; 예를 들어, <code class="docutils literal notranslate"><span class="pre">'10s'</span></code>는 단일 10바이트 문자열을 의미하고, <code class="docutils literal notranslate"><span class="pre">'10c'</span></code>는 10문자를 의미합니다. 횟수를 지정하지 않으면, 기본값은 1입니다. 패킹의 경우, 맞도록 문자열이 잘리거나 널 바이트로 채워집니다. 언 패킹의 경우, 결과 바이트열 객체는 항상 지정된 바이트 수를 갖습니다. 특별한 경우로, <code class="docutils literal notranslate"><span class="pre">'0s'</span></code>는 하나의 빈 문자열을 의미합니다(반면에 <code class="docutils literal notranslate"><span class="pre">'0c'</span></code>는 0문자를 의미합니다).</p>
<p>정수 형식 (<code class="docutils literal notranslate"><span class="pre">'b'</span></code>, <code class="docutils literal notranslate"><span class="pre">'B'</span></code>, <code class="docutils literal notranslate"><span class="pre">'h'</span></code>, <code class="docutils literal notranslate"><span class="pre">'H'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'I'</span></code>, <code class="docutils literal notranslate"><span class="pre">'l'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'q'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Q'</span></code>) 중 하나를 사용하여 값 <code class="docutils literal notranslate"><span class="pre">x</span></code>를 패킹할 때, <code class="docutils literal notranslate"><span class="pre">x</span></code>가 해당 포맷의 유효한 범위를 벗어나면 <a class="reference internal" href="#struct.error" title="struct.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">struct.error</span></code></a>가 발생합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span>3.0에서, 일부 정수 포맷은 범위를 벗어난 값을 래핑하고 <a class="reference internal" href="#struct.error" title="struct.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">struct.error</span></code></a> 대신 <a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>을 발생시켰습니다.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">'p'</span></code> 포맷 문자는 &quot;파스칼 문자열&quot;을 인코딩하는데, 이는 카운트에 의해 주어진 <em>고정된 바이트 수</em>에 저장된 짧은 가변 길이 문자열을 의미합니다. 저장된 첫 번째 바이트는 문자열의 길이나 255중 작은 값입니다. 문자열의 바이트가 그 뒤에 옵니다. <a class="reference internal" href="#struct.pack" title="struct.pack"><code class="xref py py-func docutils literal notranslate"><span class="pre">pack()</span></code></a>에 전달된 문자열이 너무 길면 (횟수 빼기 1보다 길면), 문자열의 선행 <code class="docutils literal notranslate"><span class="pre">count-1</span></code> 바이트만 저장됩니다. 문자열이 <code class="docutils literal notranslate"><span class="pre">count-1</span></code>보다 짧으면, 전부 정확한 바이트 수가 되도록 널 바이트로 채워집니다. <a class="reference internal" href="#struct.unpack" title="struct.unpack"><code class="xref py py-func docutils literal notranslate"><span class="pre">unpack()</span></code></a>의 경우, <code class="docutils literal notranslate"><span class="pre">'p'</span></code> 포맷 문자는 <code class="docutils literal notranslate"><span class="pre">count</span></code> 바이트를 소비하지만, 반환된 문자열은 255바이트를 초과할 수 없음에 유의하십시오.</p>
<p id="index-3"><code class="docutils literal notranslate"><span class="pre">'?'</span></code> 포맷 문자의 경우, 반환 값은 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>나 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>입니다. 패킹할 때, 인자 객체의 논리값이 사용됩니다. 네이티브나 표준 bool 표현에서 0이나 1이 패킹 되고, 언 패킹할 때 모든 0이 아닌 값은 <code class="docutils literal notranslate"><span class="pre">True</span></code>가 됩니다.</p>
</div>
<div class="section" id="examples">
<span id="struct-examples"></span><h3>예<a class="headerlink" href="#examples" title="제목 주소">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>모든 예는 빅 엔디안 기계에서 네이티브 바이트 순서, 크기 및 정렬을 가정합니다.</p>
</div>
<p>3개의 정수를 패킹/언 패킹하는 기본 예제:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">struct</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;hhl&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">b&#39;\x00\x01\x00\x02\x00\x00\x00\x03&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;hhl&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x01\x00\x02\x00\x00\x00\x03</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">(1, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;hhl&#39;</span><span class="p">)</span>
<span class="go">8</span>
</pre></div>
</div>
<p>언 패킹 된 필드는 변수에 대입하거나 결과를 네임드 튜플로 감싸서 이름을 붙일 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">record</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;raymond   </span><span class="se">\x32\x12\x08\x01\x08</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span><span class="p">,</span> <span class="n">serialnum</span><span class="p">,</span> <span class="n">school</span><span class="p">,</span> <span class="n">gradelevel</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;10sHHb&#39;</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Student</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Student&#39;</span><span class="p">,</span> <span class="s1">&#39;name serialnum school gradelevel&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Student</span><span class="o">.</span><span class="n">_make</span><span class="p">(</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;10sHHb&#39;</span><span class="p">,</span> <span class="n">record</span><span class="p">))</span>
<span class="go">Student(name=b&#39;raymond   &#39;, serialnum=4658, school=264, gradelevel=8)</span>
</pre></div>
</div>
<p>정렬 요구 사항을 충족시키는 데 필요한 패딩이 다르기 때문에 포맷 문자의 순서는 크기에 영향을 줄 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;ci&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="mh">0x12131415</span><span class="p">)</span>
<span class="go">b&#39;*\x00\x00\x00\x12\x13\x14\x15&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;ic&#39;</span><span class="p">,</span> <span class="mh">0x12131415</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x12\x13\x14\x15*&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;ci&#39;</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;ic&#39;</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p>다음 포맷 <code class="docutils literal notranslate"><span class="pre">'llh0l'</span></code>는 long이 4바이트 경계에 정렬된다고 가정할 때 끝에 2개의 패드 바이트를 지정합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;llh0l&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">b&#39;\x00\x00\x00\x01\x00\x00\x00\x02\x00\x03\x00\x00&#39;</span>
</pre></div>
</div>
<p>이것은 네이티브 크기와 정렬이 유효한 경우에만 작동합니다; 표준 크기와 정렬은 어떤 정렬도 강제하지 않습니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt>모듈 <a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a></dt><dd><p>동종 데이터의 패킹 된 바이너리 저장소.</p>
</dd>
<dt>모듈 <a class="reference internal" href="xdrlib.html#module-xdrlib" title="xdrlib: Encoders and decoders for the External Data Representation (XDR)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xdrlib</span></code></a></dt><dd><p>XDR 데이터의 패킹과 언 패킹.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="classes">
<span id="struct-objects"></span><h2>클래스<a class="headerlink" href="#classes" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 모듈은 또한 다음 형을 정의합니다:</p>
<dl class="class">
<dt id="struct.Struct">
<em class="property">class </em><code class="sig-prename descclassname">struct.</code><code class="sig-name descname">Struct</code><span class="sig-paren">(</span><em class="sig-param">format</em><span class="sig-paren">)</span><a class="headerlink" href="#struct.Struct" title="정의 주소">¶</a></dt>
<dd><p>포맷 문자열 <em>format</em>에 따라 바이너리 데이터를 쓰고 읽는 새 Struct 객체를 반환합니다. Struct 객체를 한 번 만들고 메서드를 호출하는 것은 포맷 문자열을 한 번만 컴파일하면 되기 때문에 같은 포맷으로 <a class="reference internal" href="#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 함수를 호출하는 것보다 효율적입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#struct.Struct" title="struct.Struct"><code class="xref py py-class docutils literal notranslate"><span class="pre">Struct</span></code></a> 와 모듈 수준 함수에 전달된 최신 포맷 문자열의 컴파일된 버전이 캐시 되므로, 몇 가지 포맷 문자열만 사용하는 프로그램은 단일 <a class="reference internal" href="#struct.Struct" title="struct.Struct"><code class="xref py py-class docutils literal notranslate"><span class="pre">Struct</span></code></a> 인스턴스 재사용에 대해 신경 쓸 필요가 없습니다.</p>
</div>
<p>컴파일된 Struct 객체는 다음 메서드와 어트리뷰트를 지원합니다:</p>
<dl class="method">
<dt id="struct.Struct.pack">
<code class="sig-name descname">pack</code><span class="sig-paren">(</span><em class="sig-param">v1</em>, <em class="sig-param">v2</em>, <em class="sig-param">...</em><span class="sig-paren">)</span><a class="headerlink" href="#struct.Struct.pack" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#struct.pack" title="struct.pack"><code class="xref py py-func docutils literal notranslate"><span class="pre">pack()</span></code></a> 함수와 동일하고, 컴파일된 포맷을 사용합니다. (<code class="docutils literal notranslate"><span class="pre">len(result)</span></code>는 <a class="reference internal" href="#struct.Struct.size" title="struct.Struct.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a>와 같게 됩니다.)</p>
</dd></dl>

<dl class="method">
<dt id="struct.Struct.pack_into">
<code class="sig-name descname">pack_into</code><span class="sig-paren">(</span><em class="sig-param">buffer</em>, <em class="sig-param">offset</em>, <em class="sig-param">v1</em>, <em class="sig-param">v2</em>, <em class="sig-param">...</em><span class="sig-paren">)</span><a class="headerlink" href="#struct.Struct.pack_into" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#struct.pack_into" title="struct.pack_into"><code class="xref py py-func docutils literal notranslate"><span class="pre">pack_into()</span></code></a> 함수와 동일하고, 컴파일된 포맷을 사용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="struct.Struct.unpack">
<code class="sig-name descname">unpack</code><span class="sig-paren">(</span><em class="sig-param">buffer</em><span class="sig-paren">)</span><a class="headerlink" href="#struct.Struct.unpack" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#struct.unpack" title="struct.unpack"><code class="xref py py-func docutils literal notranslate"><span class="pre">unpack()</span></code></a> 함수와 동일하고, 컴파일된 포맷을 사용합니다. 바이트 단위의 버퍼 크기는 <a class="reference internal" href="#struct.Struct.size" title="struct.Struct.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a>와 같아야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="struct.Struct.unpack_from">
<code class="sig-name descname">unpack_from</code><span class="sig-paren">(</span><em class="sig-param">buffer</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#struct.Struct.unpack_from" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#struct.unpack_from" title="struct.unpack_from"><code class="xref py py-func docutils literal notranslate"><span class="pre">unpack_from()</span></code></a> 함수와 동일하고, 컴파일된 포맷을 사용합니다. <em>offset</em> 위치에서 시작하는 바이트 단위의 버퍼 크기는 <a class="reference internal" href="#struct.Struct.size" title="struct.Struct.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a> 이상이어야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="struct.Struct.iter_unpack">
<code class="sig-name descname">iter_unpack</code><span class="sig-paren">(</span><em class="sig-param">buffer</em><span class="sig-paren">)</span><a class="headerlink" href="#struct.Struct.iter_unpack" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#struct.iter_unpack" title="struct.iter_unpack"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter_unpack()</span></code></a> 함수와 동일하고, 컴파일된 포맷을 사용합니다. 바이트 단위의 버퍼 크기는 <a class="reference internal" href="#struct.Struct.size" title="struct.Struct.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a>의 배수이어야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="struct.Struct.format">
<code class="sig-name descname">format</code><a class="headerlink" href="#struct.Struct.format" title="정의 주소">¶</a></dt>
<dd><p>이 Struct 객체를 구성하는 데 사용된 포맷 문자열.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>포맷 문자열형은 이제 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 대신 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>입니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="struct.Struct.size">
<code class="sig-name descname">size</code><a class="headerlink" href="#struct.Struct.size" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="functions.html#format" title="format"><code class="xref py py-attr docutils literal notranslate"><span class="pre">format</span></code></a>에 해당하는 구조체(<a class="reference internal" href="#struct.pack" title="struct.pack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pack()</span></code></a> 메서드에 의해 생성된 바이트열 객체)의 계산된 크기.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code> --- 패킹 된 바이너리 데이터로 바이트열을 해석</a><ul>
<li><a class="reference internal" href="#functions-and-exceptions">함수와 예외</a></li>
<li><a class="reference internal" href="#format-strings">포맷 문자열</a><ul>
<li><a class="reference internal" href="#byte-order-size-and-alignment">바이트 순서, 크기 및 정렬</a></li>
<li><a class="reference internal" href="#format-characters">포맷 문자</a></li>
<li><a class="reference internal" href="#examples">예</a></li>
</ul>
</li>
<li><a class="reference internal" href="#classes">클래스</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="binary.html"
                        title="이전 장">바이너리 데이터 서비스</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="codecs.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code> --- Codec registry and base classes</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="codecs.html" title="codecs --- Codec registry and base classes"
             >다음</a> |</li>
        <li class="right" >
          <a href="binary.html" title="바이너리 데이터 서비스"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="binary.html" >바이너리 데이터 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>