
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>unittest --- 단위 테스트 프레임워크 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="unittest.mock --- 모의 객체 라이브러리" href="unittest.mock.html" />
    <link rel="prev" title="doctest --- 대화형 파이썬 예제 테스트" href="doctest.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/unittest.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="unittest.mock.html" title="unittest.mock --- 모의 객체 라이브러리"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="doctest --- 대화형 파이썬 예제 테스트"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">개발 도구</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-unittest">
<span id="unittest-unit-testing-framework"></span><h1><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> --- 단위 테스트 프레임워크<a class="headerlink" href="#module-unittest" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/unittest/__init__.py">Lib/unittest/__init__.py</a></p>
<hr class="docutils" />
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>이 페이지는 <a class="reference external" href="https://github.com/unace">Hyukhoon Kwon</a> 님의 번역입니다.</p>
</div>
<p>(당신이 이미 테스트 기본 개념에 친숙하다면, <a class="reference internal" href="#assert-methods"><span class="std std-ref">assert 메서드 목록</span></a>으로 건너뛰어도 좋습니다.)</p>
<p><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 단위 테스트 프레임워크는 본래 JUnit으로부터 영감을 받고 다른 언어의 주요 단위 테스트 프레임워크와 비슷한 특징을 가지고 있습니다. 이것은 테스트 자동화, 테스트를 위한 사전 설정(setup)과 종료(shutdown) 코드 공유, 테스트를 컬렉션에 종합하기, 테스트와 리포트 프레임워크의 분리 등을 지원합니다.</p>
<p>이를 달성하기 위해 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>는 객체 지향적인 방법으로 몇 가지 중요한 개념을 지원합니다.</p>
<dl class="simple">
<dt>테스트 픽스쳐</dt><dd><p><em class="dfn">테스트 픽스쳐 (test fixture)</em>는 1개 또는 그 이상의 테스트를 수행할 때 필요한 준비와 그와 관련된 정리 동작에 해당합니다. 예를 들어 이것은 임시 또는 프락시 데이터베이스, 디렉터리를 생성하거나 서버 프로세스를 시작하는 것 등을 포함합니다.</p>
</dd>
<dt>테스트 케이스</dt><dd><p><em class="dfn">테스트 케이스(test case)</em>는 테스트의 개별 단위입니다. 이것은 특정한 입력 모음에 대해서 특정한 결과를 확인합니다. <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>는 베이스 클래스인 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>를 지원합니다. 이 클래스는 새로운 테스트 케이스를 만드는 데 사용됩니다.</p>
</dd>
<dt>테스트 묶음</dt><dd><p><em class="dfn">테스트 묶음(test suite)</em>은 여러 테스트 케이스, 테스트 묶음, 또는 둘 다의 모임입니다. 이것은 서로 같이 실행되어야 할 테스트들을 종합하는 데 사용됩니다.</p>
</dd>
<dt>테스트 실행자</dt><dd><p><em class="dfn">테스트 실행자(test runner)</em>는 테스트 실행을 조율하고 테스트 결과를 사용자에게 제공하는 역할을 하는 컴포넌트입니다. 실행자는 테스트 실행 결과를 보여주기 위해 그래픽 인터페이스, 텍스트 인터페이스를 사용하거나 특별한 값을 반환할 수도 있습니다.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 모듈</dt><dd><p>매우 다른 특징을 가지고 있는 또 다른 테스트 지원 모듈</p>
</dd>
<dt><a class="reference external" href="https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm">Simple Smalltalk Testing: With Patterns</a></dt><dd><p><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>에 영향을 준 Kent Beck의 패턴을 사용한 테스트 프레임워크 원본 논문</p>
</dd>
<dt><a class="reference external" href="https://docs.pytest.org/">pytest</a></dt><dd><p>테스트를 작성하기에 간편한 문법을 가지고 있는 제삼자의 단위 테스트 프레임워크. 예시, <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">func(10)</span> <span class="pre">==</span> <span class="pre">42</span></code>.</p>
</dd>
<dt><a class="reference external" href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">파이썬 테스트 도구 분류</a></dt><dd><p>함수형 테스트 프레임워크와 모의 객체 라이브러리를 포함한 광범위한 파이썬 테스트 도구 목록</p>
</dd>
<dt><a class="reference external" href="http://lists.idyll.org/listinfo/testing-in-python">Testing in Python 메일링 리스트</a></dt><dd><p>파이썬에서 테스트하기와 테스트 도구에 대해 논의하는 특정-주제-그룹(special-interest-group)</p>
</dd>
</dl>
<p>파이썬 소스 배포판에 있는 <code class="file docutils literal notranslate"><span class="pre">Tools/unittestgui/unittestgui.py</span></code> 스크립트는 테스트 탐색 및 실행을 위한 GUI 도구입니다. 이것은 단위 테스트가 처음인 사람들이 쉽게 사용할 수 있도록 만들어졌습니다. 라이브 환경에서는 <a class="reference external" href="https://buildbot.net/">Buildbot</a>, <a class="reference external" href="https://jenkins.io/">Jenkins</a> 또는  <a class="reference external" href="http://hudson-ci.org/">Hudson</a>과 같은 지속적인 통합 시스템을 이용하여 테스트가 이루어지길 추천합니다.</p>
</div>
<div class="section" id="basic-example">
<span id="unittest-minimal-example"></span><h2>기본 예시<a class="headerlink" href="#basic-example" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 모듈은 테스트를 구성하고 실행하는 데 풍부한 도구 모음을 제공하고 있습니다. 이 절에서는 대부분 사용자의 요구를 충족시키기 위해 일부 도구 모음만으로도 충분하다는 것을 보여줍니다.</p>
<p>문자열 관련된 3개의 메서드를 테스트하기 위한 짧은 스크립트가 여기에 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">TestStringMethods</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="s1">&#39;FOO&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_isupper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="s1">&#39;FOO&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="s1">&#39;Foo&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">test_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;hello world&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">])</span>
        <span class="c1"># 구분 기호가 문자열이 아닐 때 s.split이 실패하는지 검사합니다</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
            <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>테스트 케이스는 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a>를 서브 클래스 해서 생성하였습니다. 각각 3개의 테스트는 <code class="docutils literal notranslate"><span class="pre">test</span></code> 글자로 시작하는 이름을 가진 메서드로 정의했습니다. 이 명명 규칙은 테스트 실행자가 어떤 메서드가 테스트인지 알게 해줍니다.</p>
<p>각 테스트의 핵심은 기대되는 결과를 확인하기 위해 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>를 호출, 조건을 검증하기 위해 <a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue()</span></code></a> 또는 <a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse()</span></code></a>를 호출, 특정 예외가 발생했는지 검증하기 위해 <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a>를 호출하는 것입니다. <a class="reference internal" href="../reference/simple_stmts.html#assert"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> 문장을 대신하여 이 메서드들을 사용하면 테스트 실행자가 모든 테스트 결과를 취합하여 리포트를 생성할 수 있습니다.</p>
<p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>과 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> 메서드로 각각의 테스트 메서드 전과 후에 실행될 명령어를 정의할 수 있습니다. <a class="reference internal" href="#organizing-tests"><span class="std std-ref">테스트 코드 구조 잡기</span></a>에서 이것을 더 자세히 다루겠습니다.</p>
<p>마지막 블록은 테스트를 실행하는 간단한 방법을 보여줍니다. <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a>은 테스트 스크립트에 명령행 인터페이스를 제공합니다. 명령행에서 위 스크립트를 실행하면, 다음과 같은 출력이 나옵니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.000</span><span class="n">s</span>

<span class="n">OK</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-v</span></code> 옵션을 테스트 스크립트에 넘겨주게 되면 <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a>은 높은 상세도(verbosity)를 설정하여 그에 따른 출력이 나옵니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_isupper</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_split</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_upper</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.001</span><span class="n">s</span>

<span class="n">OK</span>
</pre></div>
</div>
<p>위의 예시는 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>에서 가장 자주 사용되는 기능을 보여주며 이것은 많은 일상적인 테스트 요구 사항을 충족시키기에 충분합니다. 문서의 나머지 부분은 기초부터 시작해서 모든 기능을 살펴봅니다.</p>
</div>
<div class="section" id="command-line-interface">
<span id="unittest-command-line-interface"></span><h2>명령행 인터페이스<a class="headerlink" href="#command-line-interface" title="제목 주소">¶</a></h2>
<p>unittest 모듈은 명령행을 사용하여 모듈, 클래스, 심지어 각 테스트 메서드의 테스트들을 실행할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module1</span> <span class="n">test_module2</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module</span><span class="o">.</span><span class="n">TestClass</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module</span><span class="o">.</span><span class="n">TestClass</span><span class="o">.</span><span class="n">test_method</span>
</pre></div>
</div>
<p>모듈 이름이나 완전히 정규화된 클래스나 메서드 이름이 포함된 목록을 전달할 수 있습니다.</p>
<p>테스트 모듈은 파일 경로로도 지정할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">tests</span><span class="o">/</span><span class="n">test_something</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>이것으로 테스트 모듈을 지정할 때 셸(shell)의 파일 이름 완성 기능을 사용할 수 있습니다. 지정된 파일은 반드시 모듈로 임포트 가능해야 합니다. 파일 경로는 '.py' 가 빠지면서 모듈 이름으로 변경되고 경로 구분자도 '.'로 변경됩니다. 만약 당신이 임포트 가능하지 않은 테스트 파일을 모듈로 사용하고 싶으시다면 이 방법 대신에 그 파일을 직접 실행해야 합니다.</p>
<p>-v 옵션을 사용하여 더 자세한 정보(높은 상세도)로 테스트를 실행할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="o">-</span><span class="n">v</span> <span class="n">test_module</span>
</pre></div>
</div>
<p>아무 인자 없이 실행하면 <a class="reference internal" href="#unittest-test-discovery"><span class="std std-ref">테스트 탐색(Discovery)</span></a>이 실행됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span>
</pre></div>
</div>
<p>모든 명령행 옵션 목록을 보기:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="o">-</span><span class="n">h</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>이전 버전에서는 개별 테스트 메서드만 실행이 가능했고, 모듈과 클래스는 불가능했습니다.</p>
</div>
<div class="section" id="command-line-options">
<h3>명령행 옵션<a class="headerlink" href="#command-line-options" title="제목 주소">¶</a></h3>
<p><strong class="program">unittest</strong>는 다음과 같은 명령행 옵션을 제공합니다:</p>
<dl class="cmdoption">
<dt id="cmdoption-unittest-b">
<code class="descname">-b</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--buffer</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-unittest-b" title="정의 주소">¶</a></dt>
<dd><p>테스트가 실행될 동안 표준 출력과 표준 에러 스트림이 버퍼링 됩니다. 통과한 테스트 중에 나온 출력은 버려집니다. 보통 테스트 실패나 에러에서 나온 출력은 표시되고 실패 메시지에 추가됩니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-c">
<code class="descname">-c</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--catch</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-unittest-c" title="정의 주소">¶</a></dt>
<dd><p>테스트 실행 중에 <kbd class="kbd docutils literal notranslate">Control-C</kbd>를 누르면 현재 테스트가 끝날 때까지 기다린 다음 지금까지의 모든 결과를 보고합니다. <kbd class="kbd docutils literal notranslate">Control-C</kbd>를 다시 누르면 일반적인 <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 예외를 발생합니다.</p>
<p>이 기능과 관련된 함수는 <a class="reference internal" href="#signal-handling">시그널 처리하기</a>를 참고하십시오.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-f">
<code class="descname">-f</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--failfast</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-unittest-f" title="정의 주소">¶</a></dt>
<dd><p>첫 번째 에러나 실패가 발생하면 테스트 실행을 중단합니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-k">
<code class="descname">-k</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-unittest-k" title="정의 주소">¶</a></dt>
<dd><p>패턴이나 부분 문자열과 일치하는 테스트 메서드나 클래스만 실행합니다. 이 옵션은 여러 번 사용될 수 있습니다. 이 경우 주어진 패턴과 일치하는 모든 테스트 케이스가 포함됩니다.</p>
<p>와일드카드 문자(<code class="docutils literal notranslate"><span class="pre">*</span></code>)를 포함한 패턴은 <a class="reference internal" href="fnmatch.html#fnmatch.fnmatchcase" title="fnmatch.fnmatchcase"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fnmatch.fnmatchcase()</span></code></a>를 사용하여 그에 일치하는 테스트 이름을 찾고; 그렇지 않은 경우 단순히 대소문자를 구별하는 부분 문자열 일치가 사용됩니다.</p>
<p>패턴을 테스트 로더가 임포트한 완전히 정규화된 테스트 메서드 이름과 대조합니다.</p>
<p>예를 들어 <code class="docutils literal notranslate"><span class="pre">-k</span> <span class="pre">foo</span></code>는 <code class="docutils literal notranslate"><span class="pre">foo_tests.SomeTest.test_something</span></code>, <code class="docutils literal notranslate"><span class="pre">bar_tests.SomeTest.test_foo</span></code>에 일치하지만, <code class="docutils literal notranslate"><span class="pre">bar_tests.FooTest.test_something</span></code>에는 일치하지 않습니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-locals">
<code class="descname">--locals</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-unittest-locals" title="정의 주소">¶</a></dt>
<dd><p>트레이스백(traceback)에서 지역 변수를 표시합니다.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가: </span>명령행 옵션인 <code class="docutils literal notranslate"><span class="pre">-b</span></code>, <code class="docutils literal notranslate"><span class="pre">-c</span></code>, <code class="docutils literal notranslate"><span class="pre">-f</span></code>가 추가되었습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가: </span>명령행 옵션 <code class="docutils literal notranslate"><span class="pre">--locals</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span>명령행 옵션 <code class="docutils literal notranslate"><span class="pre">-k</span></code>.</p>
</div>
<p>명령행은 프로젝트의 모든 테스트 또는 일부분의 테스트 탐색을 위해서도 사용할 수 있습니다.</p>
</div>
</div>
<div class="section" id="test-discovery">
<span id="unittest-test-discovery"></span><h2>테스트 탐색(Discovery)<a class="headerlink" href="#test-discovery" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<p>unittest는 간단한 테스트 탐색을 지원합니다. 테스트 탐색에 호환되기 위해서는 모든 테스트 파일은 반드시 프로젝트의 가장 상위 디렉터리로부터 <a class="reference internal" href="../tutorial/modules.html#tut-modules"><span class="std std-ref">모듈</span></a> 또는 <a class="reference internal" href="../tutorial/modules.html#tut-packages"><span class="std std-ref">패키지</span></a>(<a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">이름 공간 패키지</span></a> 포함)로 임포트 가능해야 합니다(이 말은 파일 이름이 반드시 유효한 <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">식별자</span></a>이어야 한다는 뜻입니다).</p>
<p>테스트 탐색은 <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.discover()</span></code></a>로 구현되어 있습니다, 그러나 명령행으로 사용할 수도 있습니다. 기본적인 명령행 사용법은 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">project_directory</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>단축형인 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span></code>는 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span> <span class="pre">discover</span></code>와 같습니다. 테스트 탐색에 인자를 전달하고 싶을 때는 <code class="docutils literal notranslate"><span class="pre">discover</span></code> 부속 명령어(sub-command)를 명시적으로 사용해야 합니다.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">discover</span></code> 부-명령어는 다음과 같은 옵션을 가지고 있습니다:</p>
<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-v">
<code class="descname">-v</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--verbose</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-unittest-discover-v" title="정의 주소">¶</a></dt>
<dd><p>상세한 출력</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-s">
<code class="descname">-s</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--start-directory</code><code class="descclassname"> directory</code><a class="headerlink" href="#cmdoption-unittest-discover-s" title="정의 주소">¶</a></dt>
<dd><p>탐색을 시작할 디렉터리(기본값 <code class="docutils literal notranslate"><span class="pre">.</span></code>)</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-p">
<code class="descname">-p</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--pattern</code><code class="descclassname"> pattern</code><a class="headerlink" href="#cmdoption-unittest-discover-p" title="정의 주소">¶</a></dt>
<dd><p>테스트 파일을 검색할 패턴(기본값 <code class="docutils literal notranslate"><span class="pre">test*.py</span></code>)</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-unittest-discover-t">
<code class="descname">-t</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">--top-level-directory</code><code class="descclassname"> directory</code><a class="headerlink" href="#cmdoption-unittest-discover-t" title="정의 주소">¶</a></dt>
<dd><p>프로젝트의 최상위 디렉터리(기본값 시작 디렉터리)</p>
</dd></dl>

<p><a class="reference internal" href="#cmdoption-unittest-discover-s"><code class="xref std std-option docutils literal notranslate"><span class="pre">-s</span></code></a>, <a class="reference internal" href="#cmdoption-unittest-discover-p"><code class="xref std std-option docutils literal notranslate"><span class="pre">-p</span></code></a>, <a class="reference internal" href="#cmdoption-unittest-discover-t"><code class="xref std std-option docutils literal notranslate"><span class="pre">-t</span></code></a> 옵션은 이 순서대로 위치 인자로서 사용할 수 있습니다. 다음 2개의 명령행은 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="o">-</span><span class="n">s</span> <span class="n">project_directory</span> <span class="o">-</span><span class="n">p</span> <span class="s2">&quot;*_test.py&quot;</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="n">project_directory</span> <span class="s2">&quot;*_test.py&quot;</span>
</pre></div>
</div>
<p>경로가 사용되는 곳에 패키지 이름을 전달하는 것도 가능합니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">myproject.subpackage.test</span></code>를 시작 디렉터리로 사용할 수 있습니다. 주어진 패키지 이름은 임포트되어 그것의 파일 시스템상의 위치를 시작 디렉터리로 사용하게 됩니다.</p>
<div class="admonition caution">
<p class="admonition-title">조심</p>
<p>테스트 탐색은 테스트를 임포트하여 로드합니다. 테스트 탐색이 당신이 지정한 시작 디렉터리로부터 모든 테스트 파일을 찾았다면 임포트하기 위해 그 파일 경로를 패키지 이름으로 바꿉니다. 예를 들어 <code class="file docutils literal notranslate"><span class="pre">foo/bar/baz.py</span></code>는 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>로 임포트될 것입니다.</p>
<p>만약 당신이 전역적으로 설치된 패키지가 있고 테스트 탐색을 다른 패키지 복사본에 하려고 시도한다면 임포트가 잘못된 위치에서 발생할 <em>수도 있습니다</em>. 만약 이런 일이 발생한다면 테스트 탐색은 경고하고 종료될 것입니다.</p>
<p>만약 당신이 시작 디렉터리로 경로가 아닌 패키지 이름을 전달했다면 테스트 탐색은 임포트가 어느 경로로부터 되었든 간에 당신이 의도한 경로라고 간주하여 경고를 발생하지 않을 것입니다.</p>
</div>
<p>테스트 모듈과 패키지는 <a class="reference internal" href="#load-tests-protocol">load_tests 프로토콜</a>을 통하여 테스트 로드와 탐색을 사용자 정의할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>테스트 탐색은 <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">이름 공간 패키지</span></a>를 지원합니다.</p>
</div>
</div>
<div class="section" id="organizing-test-code">
<span id="organizing-tests"></span><h2>테스트 코드 구조 잡기<a class="headerlink" href="#organizing-test-code" title="제목 주소">¶</a></h2>
<p>단위 테스트의 기본 구성 블록은 <em class="dfn">테스트 케이스(test cases)</em> --- 정확성을 위해 설정되고 확인될 하나의 시나리오입니다. <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>에서 테스트 케이스는 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a> 인스턴스에 해당합니다. 당신만의 테스트 케이스를 만들기 위해서는 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>의 서브 클래스를 작성하거나 <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a>를 사용해야 합니다.</p>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 인스턴스의 테스트 코드는 완전히 독립적으로 되어 있어야 합니다, 그래야지 이것을 각각 단독으로 실행하거나 다른 여러 테스트 케이스와 함께 임의의 조합으로 실행할 수 있습니다.</p>
<p>가장 간단한 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>의 서브 클래스는 특정 테스트 코드를 수행하도록 단순히 테스트 메서드(즉 <code class="docutils literal notranslate"><span class="pre">test</span></code>로 이름이 시작하는 함수)를 구현하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">DefaultWidgetSizeTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_default_widget_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
</pre></div>
</div>
<p>어떤 것을 테스트하기 위해서는 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 베이스 클래스에서 제공하는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">assert*()</span></code> 메서드 중 한 개를 사용합니다. 테스트가 실패한다면 그 이유를 설명한 메시지가 포함된 예외가 발생합니다, 그리고 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>는 해당 테스트 케이스를 <em class="dfn">실패(failure)</em>로 취급합니다. 다른 모든 예외는 <em class="dfn">에러(errors)</em>로 취급합니다.</p>
<p>테스트는 매우 많지만, 그것을 위한 사전 설정은 계속 반복될 수 있습니다. 다행히, <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>이란 메서드를 작성하여 사전 설정 코드를 밖으로 분리해낼 수 있습니다. 테스트 프레임워크가 1개의 테스트마다 매번 자동으로 이것을 호출할 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">WidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_default_widget_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
                         <span class="s1">&#39;incorrect default size&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_widget_resize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">),</span>
                         <span class="s1">&#39;wrong size after resize&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>다양한 테스트가 실행될 순서는 테스트 메서드의 이름을 가지고 내장된 문자열 정렬 순서에 의하여 결정될 것입니다.</p>
</div>
<p>만약 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> 메서드가 테스트 실행 중에 예외를 발생시킨다면 프레임워크는 테스트에 오류가 있는 것으로 간주하여 테스트 메서드를 실행하지 않을 것입니다.</p>
<p>마찬가지로 테스트 메서드가 실행되고 나서 정리하기 위해 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> 메서드를 제공합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">WidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
</pre></div>
</div>
<p>만약 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>이 성공했다면, 테스트가 성공했든 실패했든 상관없이 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a>이 실행될 것입니다.</p>
<p>이와 같은 테스트를 위한 실행 환경을 <em class="dfn">테스트 픽스쳐(test fixture)</em>라고 부릅니다. 개별 테스트 메서드를 실행하기 위해 고유한 테스트 픽스쳐에 해당하는 새로운 테스트 케이스 인스턴스가 생성됩니다. 따라서 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>는 테스트 당 1번씩 실행됩니다.</p>
<p>테스트하려는 기능에 따라 테스트들을 같이 모아서 테스트 케이스 구현을 사용하는 것을 추천합니다. 이것을 위해 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>는 메커니즘을 제공합니다: <em class="dfn">테스트 묶음(test suite)</em>, 이것은 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>의 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 클래스에 해당합니다. 대부분의 경우 <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a>이 테스트를 실행하기 위해 모듈의 모든 테스트 케이스를 수집하여 적절한 행동을 취할 것입니다.</p>
<p>그러나 당신이 테스트 묶음을 사용자 정의하고 싶다면 그것을 직접 만들어야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">suite</span><span class="p">():</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_default_widget_size&#39;</span><span class="p">))</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_widget_resize&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">suite</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">runner</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TextTestRunner</span><span class="p">()</span>
    <span class="n">runner</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">suite</span><span class="p">())</span>
</pre></div>
</div>
<p>당신은 테스트 케이스와 테스트 묶음의 정의를 테스트하려는 코드와 같은 모듈(예를 들어 file:<cite>widget.py</cite>)에 넣을 수 있습니다, 그러나 테스트 코드를 분리된 모듈(예를 들어 <code class="file docutils literal notranslate"><span class="pre">test_widget.py</span></code>)에 넣으면 몇 가지 이점이 있습니다:</p>
<ul class="simple">
<li><p>테스트 모듈이 명령행에서 독립적으로 작동할 수 있습니다.</p></li>
<li><p>테스트 코드가 배포될 코드와 쉽게 분리될 수 있습니다.</p></li>
<li><p>충분한 이유 없이 테스트하려는 코드에 맞춰서 테스트 코드를 바꾸려는 유혹이 덜 합니다.</p></li>
<li><p>테스트 코드가 테스트하려는 코드에 비해 훨씬 덜 빈번하게 수정되어야 합니다.</p></li>
<li><p>테스트하려는 코드는 더 쉽게 리팩토링할 수 있습니다.</p></li>
<li><p>C 언어로 작성된 모듈의 테스트 코드는 반드시 분리된 모듈에 위치해야 합니다, 따라서 일관성을 지키는 것이 어떨까요?</p></li>
<li><p>만약 테스트 전략이 바뀌더라도 소스 코드를 바꿀 필요가 없습니다.</p></li>
</ul>
</div>
<div class="section" id="re-using-old-test-code">
<span id="legacy-unit-tests"></span><h2>이전의 테스트 코드를 다시 사용하기<a class="headerlink" href="#re-using-old-test-code" title="제목 주소">¶</a></h2>
<p>어떤 사용자들은 이전의 모든 테스트 함수를 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 서브 클래스로 변경하는 작업 없이 기존의 테스트 코드를 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>로 실행하고 싶어 할 것입니다.</p>
<p>이러한 이유로 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>는 <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a> 클래스를 제공합니다. 이 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>의 서브 클래스는 기존 테스트 함수를 감싸는데 사용할 수 있습니다. 사전 설정과 정리 함수 또한 같이 사용할 수 있습니다.</p>
<p>다음과 같은 테스트 함수가 있을 때:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">testSomething</span><span class="p">():</span>
    <span class="n">something</span> <span class="o">=</span> <span class="n">makeSomething</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">something</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>다음과 같이 동등한 테스트 케이스 인스턴스를 생성할 수 있습니다, 추가로 사전 설정과 정리 메서드를 함께 설정합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">testcase</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">FunctionTestCase</span><span class="p">(</span><span class="n">testSomething</span><span class="p">,</span>
                                     <span class="n">setUp</span><span class="o">=</span><span class="n">makeSomethingDB</span><span class="p">,</span>
                                     <span class="n">tearDown</span><span class="o">=</span><span class="n">deleteSomethingDB</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a>를 사용하여 기존 테스트를 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>-기반 시스템으로 빠르게 변경할 수 있을지라도 이 방법을 추천하지는 않습니다. 시간을 들여서 적절한 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 서브 클래스를 설정하는 것이 미래에 있을 테스트 리팩토링을 대단히 쉽게 만들어줄 것입니다.</p>
</div>
<p>어떤 경우에는 <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 모듈을 사용하여 기존 테스트가 작성되었을 수도 있습니다. 만약 그렇다면 <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>가 제공하는 <code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestSuite</span></code> 클래스를 사용하여 기존의 <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>-기반 테스트로부터 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a> 인스턴스를 자동으로 만들 수 있습니다.</p>
</div>
<div class="section" id="skipping-tests-and-expected-failures">
<span id="unittest-skipping"></span><h2>테스트 건너뛰기와 예상된 실패<a class="headerlink" href="#skipping-tests-and-expected-failures" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
<p>unittest는 테스트 중에서 개별 테스트 메서드나 심지어 전체 클래스를 건너뛸 수 있는 기능을 제공합니다. 게다가 테스트를 &quot;예상된 실패&quot;로 표시하는 기능도 지원합니다, 테스트가 망가져서 실패하더라도 그것을 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>에 실패라고 기록하지 않습니다.</p>
<p>테스트 건너뛰기는 단순히 <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code class="xref py py-func docutils literal notranslate"><span class="pre">skip()</span></code></a> <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">데코레이터</span></a>나 그것의 조건 변형 중 하나를 사용하거나, <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>이나 테스트 메서드 안에서 <a class="reference internal" href="#unittest.TestCase.skipTest" title="unittest.TestCase.skipTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.skipTest()</span></code></a>를 호출하거나, <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>를 직접 발생시키면 됩니다.</p>
<p>기본적인 건너뛰기는 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;demonstrating skipping&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_nothing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s2">&quot;shouldn&#39;t happen&quot;</span><span class="p">)</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipIf</span><span class="p">(</span><span class="n">mylib</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                     <span class="s2">&quot;not supported in this library version&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 특정 버전의 라이브러리에서만 작동하는 테스트.</span>
        <span class="k">pass</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipUnless</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;win&quot;</span><span class="p">),</span> <span class="s2">&quot;requires Windows&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_windows_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 윈도우 특정 테스트 코드</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">test_maybe_skipped</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">external_resource_available</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipTest</span><span class="p">(</span><span class="s2">&quot;external resource not available&quot;</span><span class="p">)</span>
        <span class="c1"># test code that depends on the external resource</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>아래는 위의 예를 상세 모드로 실행했을 때의 출력입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_format</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;not supported in this library version&#39;</span>
<span class="n">test_nothing</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;demonstrating skipping&#39;</span>
<span class="n">test_maybe_skipped</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;external resource not available&#39;</span>
<span class="n">test_windows_support</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;requires Windows&#39;</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">4</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.005</span><span class="n">s</span>

<span class="n">OK</span> <span class="p">(</span><span class="n">skipped</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>클래스도 메서드처럼 건너뛰기가 가능합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;showing class skipping&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MySkippedTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_not_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.setUp()</span></code></a> 또한 테스트를 건너뛸 수 있습니다. 이것은 사전 설정해야 할 자원을 사용할 수 없을 때 유용합니다.</p>
<p>예상된 실패는 <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a> 데코레이터를 사용합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExpectedFailureTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@unittest</span><span class="o">.</span><span class="n">expectedFailure</span>
    <span class="k">def</span> <span class="nf">test_fail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;broken&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>자신만의 건너뛰기 데코레이터를 만들기는 쉽습니다. 테스트를 건너뛰고 싶을 때 <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code class="xref py py-func docutils literal notranslate"><span class="pre">skip()</span></code></a>를 호출하도록 데코레이터를 만들면 됩니다. 다음의 데코레이터는 특정 어트리뷰트가 있는 객체가 전달되지 않으면 테스트를 건너뜁니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">skipUnlessHasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">func</span><span class="p">:</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> doesn&#39;t have </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
</pre></div>
</div>
<p>다음 데코레이터들과 예외는 테스트 건너뛰기와 예상된 실패를 구현합니다:</p>
<dl class="function">
<dt id="unittest.skip">
<code class="descclassname">&#64;</code><code class="descclassname">unittest.</code><code class="descname">skip</code><span class="sig-paren">(</span><em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skip" title="정의 주소">¶</a></dt>
<dd><p>조건 없이 데코레이트된 테스트를 건너뜁니다. <em>reason</em>은 왜 이 테스트가 건너뛰어 졌는지를 설명해야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="unittest.skipIf">
<code class="descclassname">&#64;</code><code class="descclassname">unittest.</code><code class="descname">skipIf</code><span class="sig-paren">(</span><em>condition</em>, <em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skipIf" title="정의 주소">¶</a></dt>
<dd><p><em>condition</em>이 참이면 데코레이트된 테스트를 건너뜁니다.</p>
</dd></dl>

<dl class="function">
<dt id="unittest.skipUnless">
<code class="descclassname">&#64;</code><code class="descclassname">unittest.</code><code class="descname">skipUnless</code><span class="sig-paren">(</span><em>condition</em>, <em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skipUnless" title="정의 주소">¶</a></dt>
<dd><p><em>condition</em>이 참이 아니면 데코레이트된 테스트를 건너뜁니다.</p>
</dd></dl>

<dl class="function">
<dt id="unittest.expectedFailure">
<code class="descclassname">&#64;</code><code class="descclassname">unittest.</code><code class="descname">expectedFailure</code><a class="headerlink" href="#unittest.expectedFailure" title="정의 주소">¶</a></dt>
<dd><p>테스트가 예상된 실패라는 표시를 합니다. 테스트가 실패하면 성공으로 간주합니다. 테스트에 통과하면 실패로 간주합니다.</p>
</dd></dl>

<dl class="exception">
<dt id="unittest.SkipTest">
<em class="property">exception </em><code class="descclassname">unittest.</code><code class="descname">SkipTest</code><span class="sig-paren">(</span><em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.SkipTest" title="정의 주소">¶</a></dt>
<dd><p>이 예외는 테스트를 건너뛰기 위해서 발생합니다.</p>
<p>보통은 이 예외를 직접 발생시키기보다는 <a class="reference internal" href="#unittest.TestCase.skipTest" title="unittest.TestCase.skipTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.skipTest()</span></code></a>나 건너뛰기 데코레이터를 사용할 수 있습니다.</p>
</dd></dl>

<p>건너뛰는 테스트는 테스트 전후로 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>이나 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a>를 실행하지 않을 것입니다. 건너뛰는 클래스는 <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a>나 <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a>를 실행하지 않을 것입니다. 건너뛰는 모듈은 <code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code>이나 <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code>을 실행하지 않을 것입니다.</p>
</div>
<div class="section" id="distinguishing-test-iterations-using-subtests">
<span id="subtests"></span><h2>부분 테스트(subtest)를 사용하여 테스트 반복 구별 짖기<a class="headerlink" href="#distinguishing-test-iterations-using-subtests" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<p>여러분의 테스트들이 아주 작은 부분에서만 다를 때, 예를 들어 몇몇 매개변수, unittest는 <a class="reference internal" href="#unittest.TestCase.subTest" title="unittest.TestCase.subTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subTest()</span></code></a> 컨텍스트 관리자를 사용하여 테스트 메서드의 바디 안에서 그것들은 구별 짖게 해줍니다.</p>
<p>예를 들어, 다음 테스트는:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NumbersTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_even</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        0과 5 사이의 숫자가 모두 짝수인지 테스트합니다.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">subTest</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>다음의 출력을 만듭니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>

<span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>

<span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>부분 테스트를 사용하지 않는다면 테스트 실행은 첫 번째 실패 후에 중단될 것이고 <code class="docutils literal notranslate"><span class="pre">i</span></code> 값이 표시되지 않기 때문에 에러를 진단하는 데 쉽지 않을 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="section" id="classes-and-functions">
<span id="unittest-contents"></span><h2>클래스와 함수<a class="headerlink" href="#classes-and-functions" title="제목 주소">¶</a></h2>
<p>이 절은 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>의 API를 심도 있게 설명합니다.</p>
<div class="section" id="test-cases">
<span id="testcase-objects"></span><h3>테스트 케이스<a class="headerlink" href="#test-cases" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="unittest.TestCase">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">TestCase</code><span class="sig-paren">(</span><em>methodName='runTest'</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 클래스의 인스턴스는 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 세계에서 논리적인 테스트 단위에 해당합니다. 이 클래스는 베이스 클래스로 사용되며, 특정 테스트는 구상 클래스로 구현됩니다. 이 클래스는 테스트 실행자가 테스트를 실행할 수 있는 인터페이스를 구현하고 테스트 코드가 검사하고 다양한 실패를 보고할 수 있는 메서드를 구현합니다.</p>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>의 각 인스턴스는 하나의 베이스 메서드: <em>methodName</em>이 지정하는 이름의 메서드를 실행할 것입니다. 대부분의 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 사용에서, 당신은 <em>methodName</em>을 바꾸거나 기본 <code class="docutils literal notranslate"><span class="pre">runTest()</span></code> 메서드를 재구현하지 않을 것입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>methodName</em> 제공 없이도 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>를 성공적으로 인스턴스화할 수 있습니다. 이것은 대화형 인터프리터에서 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>로 쉽게 실험을 할 수 있게 합니다.</p>
</div>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 인스턴스는 3가지 메서드 그룹을 제공합니다: 한 그룹은 테스트를 실행하는 데 사용되고, 다른 한 그룹은 조건을 확인하고 실패를 보고하는 테스트 구현으로 사용되고, 몇몇 조회 메서드는 테스트 자체에 관한 정보를 수집할 수 있게 해줍니다.</p>
<p>첫 번째 그룹(테스트 실행) 안에 메서드는:</p>
<dl class="method">
<dt id="unittest.TestCase.setUp">
<code class="descname">setUp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.setUp" title="정의 주소">¶</a></dt>
<dd><p>테스트 픽스쳐를 준비하기 위해 호출되는 메서드입니다. 이 메서드는 테스트 메서드를 호출하기 바로 직전에 호출됩니다; <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> 또는 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>이외의 이 메서드에서 발생한 모든 예외는 테스트 실패가 아닌 오류로 간주합니다. 기본 구현은 아무것도 하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.tearDown">
<code class="descname">tearDown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.tearDown" title="정의 주소">¶</a></dt>
<dd><p>테스트 메서드가 불리고 결과가 기록되고 나서 바로 다음에 호출되는 메서드입니다. 테스트 메서드가 예외를 발생했더라도 이 메서드는 불립니다, 따라서 서브 클래스의 구현은 내부 상태를 확인하는 데 특별히 주의를 기울여야 합니다. <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> 또는 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>이외의 이 메서드에서 발생하는 모든 예외는 테스트 실패가 아닌 오류로 간주합니다(따라서 보고된 오류의 총 숫자가 증가합니다). 이 메서드는 테스트 메서드의 결과물에 영향받지 않고 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>이 성공했을 때만 불립니다. 기본 구현은 아무것도 하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.setUpClass">
<code class="descname">setUpClass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.setUpClass" title="정의 주소">¶</a></dt>
<dd><p>개별 클래스의 테스트들이 실행되기 전에 불리는 클래스 메서드입니다. <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code>는 클래스만 인자로 받아 호출되고 <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a>로 데코레이트해야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>더 자세한 것은 <a class="reference internal" href="#class-and-module-fixtures">클래스와 모듈 픽스쳐</a>를 보십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.tearDownClass">
<code class="descname">tearDownClass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.tearDownClass" title="정의 주소">¶</a></dt>
<dd><p>개별 클래스의 테스트들이 실행되고 난 뒤에 불리는 클래스 메서드입니다. <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code>는 클래스만 인자로 받아 호출되고 <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a>로 데코레이트해야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>더 자세한 것은 <a class="reference internal" href="#class-and-module-fixtures">클래스와 모듈 픽스쳐</a>를 보십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>result=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.run" title="정의 주소">¶</a></dt>
<dd><p>테스트를 실행하고, <em>result</em> 인자로 전달된 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>에 결과를 수집합니다. 만약 <em>result</em> 인자가 전달 안 되거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>이라면 임시 결과 객체를 (<a class="reference internal" href="#unittest.TestCase.defaultTestResult" title="unittest.TestCase.defaultTestResult"><code class="xref py py-meth docutils literal notranslate"><span class="pre">defaultTestResult()</span></code></a> 메서드를 불러서) 생성하여 사용합니다. <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> 호출자에게 결과 객체를 반환합니다.</p>
<p>단순히 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 인스턴스를 호출하는 것으로 같은 효과를 볼 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>기존 버전의 <code class="docutils literal notranslate"><span class="pre">run</span></code>은 결과를 반환하지 않았습니다. 인스턴스 호출 또한 그렇지 않았습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.skipTest">
<code class="descname">skipTest</code><span class="sig-paren">(</span><em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.skipTest" title="정의 주소">¶</a></dt>
<dd><p>테스트 메서드나 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>에서 이것을 호출하면 현재 테스트를 건너뜁니다. 자세한 정보는 <a class="reference internal" href="#unittest-skipping"><span class="std std-ref">테스트 건너뛰기와 예상된 실패</span></a>를 보십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.subTest">
<code class="descname">subTest</code><span class="sig-paren">(</span><em>msg=None</em>, <em>**params</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.subTest" title="정의 주소">¶</a></dt>
<dd><p>둘러싼 코드 블록을 부분 테스트로서 실행하는 컨텍스트 관리자를 반환합니다. <em>msg</em> 및 <em>params</em>는 선택 사항이며 부분 테스트가 실패 할 때마다 표시되는 임의의 값으로 당신이 명확하게 알아보게 해줍니다.</p>
<p>테스트 케이스는 여러 개의 부분 테스트 선언을 포함할 수 있고, 그것들은 자유롭게 중첩될 수 있습니다.</p>
<p>자세한 정보는 <a class="reference internal" href="#subtests"><span class="std std-ref">부분 테스트(subtest)를 사용하여 테스트 반복 구별 짖기</span></a>를 보십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.debug">
<code class="descname">debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.debug" title="정의 주소">¶</a></dt>
<dd><p>결과를 수집하지 않고 테스트를 실행합니다. 이것은 테스트에서 발생한 예외가 호출자로 전파될 수 있게 해서, 디버거 환경에서 테스트를 실행할 때 사용될 수 있습니다.</p>
</dd></dl>

<p id="assert-methods"><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 클래스는 값을 검사하고 실패를 보고하기 위해 몇 개의 assert 메서드를 제공합니다. 다음 표는 보통 많이 사용되는 메서드들입니다(더 많은 assert 메서드는 표 아래를 보십시오):</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 48%" />
<col style="width: 34%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>메서드</p></th>
<th class="head"><p>검사하는 내용</p></th>
<th class="head"><p>추가된 버전</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">True</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">False</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIs(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNot" title="unittest.TestCase.assertIsNot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNot(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNone" title="unittest.TestCase.assertIsNone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNone(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">None</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNotNone" title="unittest.TestCase.assertIsNotNone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNotNone(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIn" title="unittest.TestCase.assertIn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIn(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">in</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotIn" title="unittest.TestCase.assertNotIn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotIn(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsInstance" title="unittest.TestCase.assertIsInstance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsInstance(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">isinstance(a,</span> <span class="pre">b)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotIsInstance" title="unittest.TestCase.assertNotIsInstance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotIsInstance(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">isinstance(a,</span> <span class="pre">b)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
</tbody>
</table>
<p>모든 assert 메서드는 <em>msg</em> 인자를 받을 수 있습니다, 만약 그것이 전달된다면 실패 시 에러 메시지로 사용됩니다(<a class="reference internal" href="#unittest.TestCase.longMessage" title="unittest.TestCase.longMessage"><code class="xref py py-data docutils literal notranslate"><span class="pre">longMessage</span></code></a> 도 참고하십시오). <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertWarnsRegex" title="unittest.TestCase.assertWarnsRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarnsRegex()</span></code></a>는 컨텍스트 관리자로서 사용될 때만 그들에게 <em>msg</em> 키워드 인자를 전달할 수 있다는 점을 주의하십시오.</p>
<dl class="method">
<dt id="unittest.TestCase.assertEqual">
<code class="descname">assertEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertEqual" title="정의 주소">¶</a></dt>
<dd><p><em>first</em>와 <em>second</em>가 같은지 테스트합니다. 비교한 값이 같지 않으면 테스트는 실패할 것입니다.</p>
<p>추가로, 만약 <em>first</em>와 <em>second</em>가 정확히 같은 형(type)이고 list, tuple, dict, set, frozenset, str 이거나 <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTypeEqualityFunc()</span></code></a>에 등록된 서브 클래스 형 중 하나일 경우 더 유용한 기본 에러 메시지를 생성하기 위해 형-특화(type-specific) 동등성 함수가 불릴 것입니다(<a class="reference internal" href="#type-specific-methods"><span class="std std-ref">형-특화 메서드 목록</span></a>을 참고하십시오).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span>형-특화 동등성 함수가 자동으로 불리도록 추가</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>문자열 비교를 위해서 <a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual()</span></code></a>를 기본 형-특화 동등성 함수에 추가</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertNotEqual">
<code class="descname">assertNotEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotEqual" title="정의 주소">¶</a></dt>
<dd><p><em>first</em>와 <em>second</em>가 같지 않은지 테스트합니다, 비교한 값이 같으면 테스트는 실패할 것입니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertTrue">
<code class="descname">assertTrue</code><span class="sig-paren">(</span><em>expr</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertTrue" title="정의 주소">¶</a></dt>
<dt id="unittest.TestCase.assertFalse">
<code class="descname">assertFalse</code><span class="sig-paren">(</span><em>expr</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertFalse" title="정의 주소">¶</a></dt>
<dd><p><em>expr</em>이 참(또는 거짓)인지 테스트합니다.</p>
<p>이것은 <code class="docutils literal notranslate"><span class="pre">bool(expr)</span> <span class="pre">is</span> <span class="pre">True</span></code>와 동등하고 <code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">is</span> <span class="pre">True</span></code>와 동등하지 않다는 것에 주의하십시오(후자를 위해선 <code class="docutils literal notranslate"><span class="pre">assertIs(expr,</span> <span class="pre">True)</span></code>를 사용하십시오). 더 구체적인 메서드를 사용할 수 있을 때는 이 메서드를 지양해야 합니다(예, <code class="docutils literal notranslate"><span class="pre">assertTrue(a</span> <span class="pre">==</span> <span class="pre">b)</span></code> 대신에 <code class="docutils literal notranslate"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></code>), 왜냐하면 실패의 경우에 구체적인 메서드가 더 나은 에러 메시지를 제공하기 때문입니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIs">
<code class="descname">assertIs</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIs" title="정의 주소">¶</a></dt>
<dt id="unittest.TestCase.assertIsNot">
<code class="descname">assertIsNot</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNot" title="정의 주소">¶</a></dt>
<dd><p><em>first</em>와 <em>second</em>가 같은 객체로 평가되는지(아닌지) 테스트합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIsNone">
<code class="descname">assertIsNone</code><span class="sig-paren">(</span><em>expr</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNone" title="정의 주소">¶</a></dt>
<dt id="unittest.TestCase.assertIsNotNone">
<code class="descname">assertIsNotNone</code><span class="sig-paren">(</span><em>expr</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNotNone" title="정의 주소">¶</a></dt>
<dd><p><em>expr</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 인지(아닌지) 테스트합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIn">
<code class="descname">assertIn</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIn" title="정의 주소">¶</a></dt>
<dt id="unittest.TestCase.assertNotIn">
<code class="descname">assertNotIn</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotIn" title="정의 주소">¶</a></dt>
<dd><p><em>first</em>가 <em>second</em> 안에 있는지(아닌지) 테스트합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertIsInstance">
<code class="descname">assertIsInstance</code><span class="sig-paren">(</span><em>obj</em>, <em>cls</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsInstance" title="정의 주소">¶</a></dt>
<dt id="unittest.TestCase.assertNotIsInstance">
<code class="descname">assertNotIsInstance</code><span class="sig-paren">(</span><em>obj</em>, <em>cls</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotIsInstance" title="정의 주소">¶</a></dt>
<dd><p><em>obj</em>가 <em>cls</em>(<a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>가 지원하는 것처럼 클래스 또는 클래스의 튜플)의 인스턴스인지(아닌지) 테스트합니다. 정확한 형 검사를 위해서는 <a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code class="xref py py-func docutils literal notranslate"><span class="pre">assertIs(type(obj),</span> <span class="pre">cls)</span></code></a>를 사용하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<p>다음의 메서드를 사용하여 예외, 경고, 로그 메시지의 발생을 검사할 수 있습니다:</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 53%" />
<col style="width: 36%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>메서드</p></th>
<th class="head"><p>검사하는 내용</p></th>
<th class="head"><p>추가된 버전</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises(exc,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code>가 <em>exc</em>를 발생</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex(exc,</span> <span class="pre">r,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code>가 <em>exc</em>를 발생하고 메시지가 정규식 <em>r</em>에 일치</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns(warn,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code>가 <em>warn</em>을 발생</p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertWarnsRegex" title="unittest.TestCase.assertWarnsRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarnsRegex(warn,</span> <span class="pre">r,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code>가 <em>warn</em>을 발생하고 메시지가 정규식 <em>r</em>에 일치</p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertLogs" title="unittest.TestCase.assertLogs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLogs(logger,</span> <span class="pre">level)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">with</span></code> 블록이 최소 <em>level</em>로 <em>logger</em>에 로그를 남김</p></td>
<td><p>3.4</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="unittest.TestCase.assertRaises">
<code class="descname">assertRaises</code><span class="sig-paren">(</span><em>exception</em>, <em>callable</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRaises" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">assertRaises</code><span class="sig-paren">(</span><em>exception</em>, <em>*</em>, <em>msg=None</em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a>에 전달된 어떤 위치 또는 키워드 인자와 함께 <em>callable</em>이 호출되었을 때 예외가 발생하는지 테스트합니다. <em>exception</em>이 발생하면 테스트를 통과하고, 다른 예외가 발생하면 에러이고, 아무 예외도 발생하지 않으면 실패입니다. 여러 예외 모음을 잡기 위해서 예외 클래스를 포함한 튜플을 <em>exception</em>으로 전달해도 좋습니다.</p>
<p>만약 선택적인 <em>msg</em>와 함께 오직 <em>exception</em> 인자만 전달된다면, 테스트할 코드를 함수가 아닌 인라인으로 작성할 수 있도록 컨텍스트 관리자를 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">()</span>
</pre></div>
</div>
<p>컨텍스트 관리자로 사용되면, <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a>는 추가적인 키워드 인자인 <em>msg</em>를 받을 수 있습니다.</p>
<p>컨텍스트 관리자는 잡은 예외 객체를 <code class="xref py py-attr docutils literal notranslate"><span class="pre">exception</span></code> 어트리뷰트에 저장할 것입니다. 이것은 발생한 예외에 대해서 추가적인 검사를 수행하려는 경우에 유용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>

<span class="n">the_exception</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">exception</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">the_exception</span><span class="o">.</span><span class="n">error_code</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a>를 컨텍스트 관리자로 사용할 수 있도록 기능 추가.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><code class="xref py py-attr docutils literal notranslate"><span class="pre">exception</span></code> 어트리뷰트 추가.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>컨텍스트 관리자로 사용될 때 <em>msg</em> 키워드 인자 추가.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertRaisesRegex">
<code class="descname">assertRaisesRegex</code><span class="sig-paren">(</span><em>exception</em>, <em>regex</em>, <em>callable</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRaisesRegex" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">assertRaisesRegex</code><span class="sig-paren">(</span><em>exception</em>, <em>regex</em>, <em>*</em>, <em>msg=None</em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a>와 비슷하지만 발생한 예외의 문자열 표현이 <em>regex</em>에 일치하는지 테스트합니다. <em>regex</em>는 정규식 객체나 <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>에 사용되기 적합한 정규식 문자열이 될 수 있습니다. 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegex</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;invalid literal for.*XYZ&#39;$&quot;</span><span class="p">,</span>
                       <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>또는:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegex</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s1">&#39;literal&#39;</span><span class="p">):</span>
   <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가: </span><code class="docutils literal notranslate"><span class="pre">assertRaisesRegexp</span></code> 라는 이름으로 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a>으로 이름 변경.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>컨텍스트 관리자로 사용될 때 <em>msg</em> 키워드 인자 추가.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertWarns">
<code class="descname">assertWarns</code><span class="sig-paren">(</span><em>warning</em>, <em>callable</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertWarns" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">assertWarns</code><span class="sig-paren">(</span><em>warning</em>, <em>*</em>, <em>msg=None</em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a>에 전달된 어떤 위치 또는 키워드 인자와 함께 <em>callable</em>이 호출되었을 때 경고(warning)가 발생하는지 테스트합니다. <em>warning</em>이 발생하면 테스트를 통과하고, 그렇지 않으면 실패입니다. 예외가 발생하면 에러입니다. 여러 경고 모음을 잡기 위해서 경고 클래스를 포함한 튜플을 <em>warnings</em>로 전달해도 좋습니다.</p>
<p>만약 선택적인 <em>msg</em>와 함께 오직 <em>warning</em> 인자만 전달된다면, 테스트할 코드를 함수가 아닌 인라인으로 작성할 수 있도록 컨텍스트 관리자를 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarns</span><span class="p">(</span><span class="n">SomeWarning</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">()</span>
</pre></div>
</div>
<p>컨텍스트 관리자로 사용되면, <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a>는 추가적인 키워드 인자인 <em>msg</em>를 받을 수 있습니다.</p>
<p>컨텍스트 관리자는 잡은 경고 객체를 <code class="xref py py-attr docutils literal notranslate"><span class="pre">warning</span></code> 어트리뷰트에 저장하고, 경고를 발생한 소스코드 줄을 <code class="xref py py-attr docutils literal notranslate"><span class="pre">filename</span></code>과 <code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code>에 저장할 것입니다. 이것은 발생한 경고에 대해서 추가적인 검사를 수행하려는 경우에 유용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarns</span><span class="p">(</span><span class="n">SomeWarning</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>

<span class="bp">self</span><span class="o">.</span><span class="n">assertIn</span><span class="p">(</span><span class="s1">&#39;myfile.py&#39;</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">lineno</span><span class="p">)</span>
</pre></div>
</div>
<p>이 메서드는 호출될 때 적용될 경고 필터와 관계없이 작동합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>컨텍스트 관리자로 사용될 때 <em>msg</em> 키워드 인자 추가.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertWarnsRegex">
<code class="descname">assertWarnsRegex</code><span class="sig-paren">(</span><em>warning</em>, <em>regex</em>, <em>callable</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertWarnsRegex" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">assertWarnsRegex</code><span class="sig-paren">(</span><em>warning</em>, <em>regex</em>, <em>*</em>, <em>msg=None</em><span class="sig-paren">)</span></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a>와 비슷하지만 발생한 경고의 메시지가 <em>regex</em>에 일치하는지 테스트합니다. <em>regex</em>는 정규식 객체나 <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>에 사용되기 적합한 정규식 문자열이 될 수 있습니다. 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">assertWarnsRegex</span><span class="p">(</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                      <span class="sa">r</span><span class="s1">&#39;legacy_function\(\) is deprecated&#39;</span><span class="p">,</span>
                      <span class="n">legacy_function</span><span class="p">,</span> <span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>또는:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarnsRegex</span><span class="p">(</span><span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="s1">&#39;unsafe frobnicating&#39;</span><span class="p">):</span>
    <span class="n">frobnicate</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>컨텍스트 관리자로 사용될 때 <em>msg</em> 키워드 인자 추가.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertLogs">
<code class="descname">assertLogs</code><span class="sig-paren">(</span><em>logger=None</em>, <em>level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLogs" title="정의 주소">¶</a></dt>
<dd><p>최소한 <em>level</em>로 <em>logger</em>나 그 자식들에 최소한 1개의 메시지가 기록되는지 테스트하는 컨텍스트 관리자입니다.</p>
<p><em>logger</em>가 주어졌다면, <a class="reference internal" href="logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Logger</span></code></a> 객체이거나 로거의 이름인 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>이어야 합니다. 기본값은 모든 메시지를 잡을 루트 로거입니다.</p>
<p><em>level</em>이 주어졌다면, 로그 수준의 숫자 값이거나 그에 대응하는 문자열이어야 합니다(예를 들어 <code class="docutils literal notranslate"><span class="pre">&quot;ERROR&quot;</span></code>이거나  <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.ERROR</span></code>). 기본값은 <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.INFO</span></code>입니다.</p>
<p>만약 <code class="docutils literal notranslate"><span class="pre">with</span></code> 블록 안에서 <em>logger</em>와 <em>level</em> 조건을 만족하는 최소한 1개의 메시지가 나왔다면 테스트는 성공하고, 그렇지 않으면 실패합니다.</p>
<p>컨텍스트 관리자에 의해 반환되는 객체는 조건에 일치하는 로그 메시지를 추적하기 위한 기록 도우미입니다. 이것은 2개의 어트리뷰트를 가지고 있습니다:</p>
<dl class="attribute">
<dt id="unittest.TestCase.records">
<code class="descname">records</code><a class="headerlink" href="#unittest.TestCase.records" title="정의 주소">¶</a></dt>
<dd><p>조건에 일치하는 메시지의 <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.LogRecord</span></code></a> 객체 목록.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestCase.output">
<code class="descname">output</code><a class="headerlink" href="#unittest.TestCase.output" title="정의 주소">¶</a></dt>
<dd><p>조건에 일치하는 메시지의 포맷 출력인 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체 목록.</p>
</dd></dl>

<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertLogs</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;INFO&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
   <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;first message&#39;</span><span class="p">)</span>
   <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;foo.bar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;second message&#39;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;INFO:foo:first message&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;ERROR:foo.bar:second message&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<p>더 구체적인 검사를 수행하기 위한 또 다른 메서드가 있습니다, 아래와 같이:</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 46%" />
<col style="width: 38%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>메서드</p></th>
<th class="head"><p>검사하는 내용</p></th>
<th class="head"><p>추가된 버전</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">==</span> <span class="pre">0</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">!=</span> <span class="pre">0</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertGreater" title="unittest.TestCase.assertGreater"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertGreater(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertGreaterEqual" title="unittest.TestCase.assertGreaterEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertGreaterEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertLess" title="unittest.TestCase.assertLess"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLess(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertLessEqual" title="unittest.TestCase.assertLessEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLessEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex(s,</span> <span class="pre">r)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r.search(s)</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex(s,</span> <span class="pre">r)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">r.search(s)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertCountEqual" title="unittest.TestCase.assertCountEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertCountEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>순서와 상관없이 <em>a</em>와 <em>b</em>가 같은 개수의 같은 요소를 가졌는지.</p></td>
<td><p>3.2</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="unittest.TestCase.assertAlmostEqual">
<code class="descname">assertAlmostEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>places=7</em>, <em>msg=None</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertAlmostEqual" title="정의 주소">¶</a></dt>
<dt id="unittest.TestCase.assertNotAlmostEqual">
<code class="descname">assertNotAlmostEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>places=7</em>, <em>msg=None</em>, <em>delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotAlmostEqual" title="정의 주소">¶</a></dt>
<dd><p><em>first</em>와 <em>second</em>가 근사하게 같은지(또는 근사하게 같지 않은지) 테스트합니다. 이는 값 차이를 계산하고, 주어진 소수 <em>자릿(places)</em>수(기본값 7)로 반올림한 뒤, 0과 비교하는 것으로 이루어집니다. 이 메서드는 값을 <em>유효 숫자 자릿수(significant digits)</em>가 아닌 주어진 <em>소수 자릿수(decimal places)</em>(즉, <a class="reference internal" href="functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> 함수와 같이)로 반올림합니다.</p>
<p>만약 <em>places</em> 대신에 <em>delta</em>가 주어진다면 <em>first</em>와 <em>second</em>의 값 차이는 반드시 <em>delta</em>보다 작거나 같아야(또는 커야) 합니다.</p>
<p><em>delta</em>와 <em>places</em>가 동시에 주어지면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual()</span></code></a>은 같다고 비교되는 거의 동등한 객체를 자동으로 고려합니다. <a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual()</span></code></a>은 객체가 같다고 비교되면 자동으로 실패합니다. <em>delta</em> 키워드 인자를 추가.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertGreater">
<code class="descname">assertGreater</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertGreater" title="정의 주소">¶</a></dt>
<dt id="unittest.TestCase.assertGreaterEqual">
<code class="descname">assertGreaterEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertGreaterEqual" title="정의 주소">¶</a></dt>
<dt id="unittest.TestCase.assertLess">
<code class="descname">assertLess</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLess" title="정의 주소">¶</a></dt>
<dt id="unittest.TestCase.assertLessEqual">
<code class="descname">assertLessEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLessEqual" title="정의 주소">¶</a></dt>
<dd><p><em>first</em>를 <em>second</em>와 비교해서 각각 메서드 이름에 해당하는 &gt;, &gt;=, &lt;, &lt;= 인지 테스트합니다. 그렇지 않으면 테스트는 실패합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">assertGreaterEqual</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">AssertionError: &quot;3&quot; unexpectedly not greater than or equal to &quot;4&quot;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertRegex">
<code class="descname">assertRegex</code><span class="sig-paren">(</span><em>text</em>, <em>regex</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRegex" title="정의 주소">¶</a></dt>
<dt id="unittest.TestCase.assertNotRegex">
<code class="descname">assertNotRegex</code><span class="sig-paren">(</span><em>text</em>, <em>regex</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotRegex" title="정의 주소">¶</a></dt>
<dd><p><em>regex</em> 검색이 <em>text</em>에 일치하는지(아닌지) 테스트합니다. 실패의 경우, 에러 메시지는 패턴과 <em>text</em>(또는 패턴과 예상과 달리 일치한 <em>text</em>의 부분)를 포함할 것입니다. <em>regex</em>는 정규식 객체나 <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>에 사용되기 적합한 정규식 문자열이 될 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가: </span><code class="docutils literal notranslate"><span class="pre">assertRegexpMatches</span></code> 라는 이름으로 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><code class="docutils literal notranslate"><span class="pre">assertRegexpMatches()</span></code> 메서드가 <a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex()</span></code></a>로 이름 변경되었습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가: </span><a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가: </span><code class="docutils literal notranslate"><span class="pre">assertNotRegexpMatches</span></code>이름은 <a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a>의 폐지된 에일리어스입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertCountEqual">
<code class="descname">assertCountEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertCountEqual" title="정의 주소">¶</a></dt>
<dd><p><em>first</em> 시퀀스가 순서에 상관없이 <em>second</em>와 같은 요소를 포함하는지 테스트합니다. 그렇지 않은 경우, 시퀀스들의 차이를 나열한 에러 메시지가 생성됩니다.</p>
<p><em>first</em>와 <em>second</em>를 비교할 때 중복된 요소는 무시하지 <em>않습니다</em>. 두 개의 시퀀스에 각 요소가 같은 수 만큼 있는 것을 확인합니다. <code class="docutils literal notranslate"><span class="pre">assertEqual(Counter(list(first)),</span> <span class="pre">Counter(list(second)))</span></code>와 같지만 해시 불가능한(unhashable) 시퀀스에도 작동합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<p id="type-specific-methods"><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> 메서드는 같은 형의 객체의 동등성 검사를 다른 형-특화 메서드에게로 보냅니다. 이러한 메서드들은 대부분의 내장 형에 대해서 이미 구현되어 있지만, <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTypeEqualityFunc()</span></code></a>을 사용하여 새로운 메서드를 등록하는 것도 가능합니다:</p>
<dl class="method">
<dt id="unittest.TestCase.addTypeEqualityFunc">
<code class="descname">addTypeEqualityFunc</code><span class="sig-paren">(</span><em>typeobj</em>, <em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addTypeEqualityFunc" title="정의 주소">¶</a></dt>
<dd><p>정확히 같은 (서브 클래스가 아닌) <em>typeobj</em> 형의 두 객체가 같은지 비교 검사하기 위해 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>한테 불리는 형-특화 메서드를 등록합니다. <em>function</em>은 반드시 2개의 위치 인자를 받아야 하고 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>이 그러한 것처럼 msg=None 키워드 인자를 세 번째로 받아야 합니다. 이것은 처음 2개의 매개변수가 같지 않은 것이 확인될 경우 <a class="reference internal" href="#unittest.TestCase.failureException" title="unittest.TestCase.failureException"><code class="xref py py-data docutils literal notranslate"><span class="pre">self.failureException(msg)</span></code></a>을 반드시 발생시켜야 합니다 -- 에러 메시지에 유용한 정보를 제공하고 비동등성을 자세히 설명할 수 있을 것입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>에서 자동으로 사용하는 형-특화 메서드 목록은 다음 표에 정리되어 있습니다. 보통은 이 메서드를 직접 부를 필요가 없다는 것을 기억하십시오.</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 49%" />
<col style="width: 35%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>메서드</p></th>
<th class="head"><p>을 비교하기 위해</p></th>
<th class="head"><p>추가된 버전</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>문자열</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSequenceEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>시퀀스</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertListEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>리스트</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTupleEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>튜플</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertSetEqual" title="unittest.TestCase.assertSetEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSetEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>집합 또는 불변 집합</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDictEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>딕셔너리</p></td>
<td><p>3.1</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="unittest.TestCase.assertMultiLineEqual">
<code class="descname">assertMultiLineEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertMultiLineEqual" title="정의 주소">¶</a></dt>
<dd><p>여러 줄 문자열인 <em>first</em>와 <em>second</em>가 같은지 테스트합니다. 같지 않을 경우 에러 메시지에 다른 부분이 강조된 두 문자열의 차이가 포함됩니다. 이 메서드는 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>에서 문자열을 비교할 때 기본적으로 사용됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertSequenceEqual">
<code class="descname">assertSequenceEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em>, <em>seq_type=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertSequenceEqual" title="정의 주소">¶</a></dt>
<dd><p>2개의 시퀀스가 같은지 테스트합니다. <em>seq_type</em>이 전달된 경우, <em>first</em>와 <em>second</em> 둘 다 <em>seq_type</em>의 인스턴스이어야 하고 그렇지 않은 경우 실패가 발생합니다. 시퀀스가 다른 경우, 에러 메시지는 2개 사이의 차이점을 보여주게 됩니다.</p>
<p>이 메서드는 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>에서 직접 호출되진 않지만, <a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertListEqual()</span></code></a>와 <a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTupleEqual()</span></code></a>을 구현할 때 사용됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertListEqual">
<code class="descname">assertListEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertListEqual" title="정의 주소">¶</a></dt>
<dt id="unittest.TestCase.assertTupleEqual">
<code class="descname">assertTupleEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertTupleEqual" title="정의 주소">¶</a></dt>
<dd><p>2개의 리스트나 튜플이 같은지 테스트합니다. 만약 같지 않다면 에러 메시지는 2개 사이의 차이점만 보여주게 됩니다. 매개변수 중 하나가 잘못된 형인 경우 에러가 발생합니다. 이 메서드는 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>에서 리스트와 튜플을 비교할 때 기본적으로 사용됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertSetEqual">
<code class="descname">assertSetEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertSetEqual" title="정의 주소">¶</a></dt>
<dd><p>2개의 집합이 같은지 테스트합니다. 같지 않은 경우 에러 메시지는 집합 사이의 차이를 나열하게 됩니다. 이 메서드는 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>에서 집합이나 불변 집합을 비교할 때 기본적으로 사용됩니다.</p>
<p><em>first</em>와 <em>second</em> 중 하나가 <code class="xref py py-meth docutils literal notranslate"><span class="pre">set.difference()</span></code> 메서드를 가지고 있지 않으면 실패합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.assertDictEqual">
<code class="descname">assertDictEqual</code><span class="sig-paren">(</span><em>first</em>, <em>second</em>, <em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertDictEqual" title="정의 주소">¶</a></dt>
<dd><p>2개의 딕셔너리가 같은지 테스트합니다. 같지 않은 경우 에러 메시지는 딕셔너리 사이의 차이를 보여주게 됩니다. 이 메서드는 <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>에서 딕셔너리를 비교할 때 기본적으로 사용될 것입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<p id="other-methods-and-attrs">마지막으로 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>가 다음의 메서드와 어트리뷰트를 제공합니다:</p>
<dl class="method">
<dt id="unittest.TestCase.fail">
<code class="descname">fail</code><span class="sig-paren">(</span><em>msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.fail" title="정의 주소">¶</a></dt>
<dd><p>무조건 테스트 실패 신호를 보냅니다, 에러 메시지를 위해 <em>msg</em>나 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 전달합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestCase.failureException">
<code class="descname">failureException</code><a class="headerlink" href="#unittest.TestCase.failureException" title="정의 주소">¶</a></dt>
<dd><p>이 클래스 어트리뷰트는 테스트 메서드에서 발생한 예외를 줍니다. 만약 테스트 프레임워크가 추가 정보를 전달하기 위해 특수한 예외를 사용할 필요가 있다면, 프레임워크와 &quot;공정하게 행동하기&quot; 위해서 이 예외를 서브 클래스해야 합니다. 이 어트리뷰트의 초깃값은 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> 입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestCase.longMessage">
<code class="descname">longMessage</code><a class="headerlink" href="#unittest.TestCase.longMessage" title="정의 주소">¶</a></dt>
<dd><p>이 클래스 어트리뷰트는 실패한 assertXYY 호출에 msg 인자로 전달된 사용자 정의 실패 메시지가 어떻게 동작하는지를 결정합니다. <code class="docutils literal notranslate"><span class="pre">True</span></code>가 기본값입니다. 이 경우, 사용자 정의 메시지가 표준 실패 메시지 끝에 추가됩니다. <code class="docutils literal notranslate"><span class="pre">False</span></code>로 설정할 경우 사용자 정의 메시지가 표준 메시지를 대체합니다.</p>
<p>이 클래스 설정은 인스턴스 어트리뷰트를 설정하여 개별 테스트 메서드에 의해 재정의될 수 있습니다, assert 메서드를 호출하기 전에 self.longMessage를 <code class="docutils literal notranslate"><span class="pre">True</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 설정하는 것입니다.</p>
<p>이 클래스 설정은 각 테스트 호출 전에 재설정됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestCase.maxDiff">
<code class="descname">maxDiff</code><a class="headerlink" href="#unittest.TestCase.maxDiff" title="정의 주소">¶</a></dt>
<dd><p>이 어트리뷰트는 실패 시 diff를 보고하는 assert 메서드의 최대 diff 출력 길이를 설정합니다. 기본값은 80*8 문자입니다. 이 어트리뷰트에 영향을 받는 assert 메서드는 <a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSequenceEqual()</span></code></a>(이것에 위임하는 모든 시퀀스 비교 메서드를 포함), <a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDictEqual()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual()</span></code></a> 입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">maxDiff</span></code>를 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정하면 diff의 최대 길이 제한이 없어지는 것을 뜻합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<p>테스트 프레임워크는 테스트에 관한 정보를 수집하기 위해 다음의 메서드를 사용할 수 있습니다:</p>
<dl class="method">
<dt id="unittest.TestCase.countTestCases">
<code class="descname">countTestCases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.countTestCases" title="정의 주소">¶</a></dt>
<dd><p>이 테스트 객체에 해당하는 테스트 개수를 반환합니다. <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 인스턴스에 대해서는 이것은 항상 <code class="docutils literal notranslate"><span class="pre">1</span></code>입니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.defaultTestResult">
<code class="descname">defaultTestResult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.defaultTestResult" title="정의 주소">¶</a></dt>
<dd><p>이 테스트 케이스 클래스를 위해서 사용되는 테스트 결과 클래스의 인스턴스를 반환합니다(<a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> 메서드에 다른 결과 인스턴스가 전달되지 않은 경우에).</p>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 인스턴스에 대해서는 이것은 항상 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>의 인스턴스입니다; <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>의 서브 클래스는 이것을 필요에 따라 재정의해야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.id">
<code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.id" title="정의 주소">¶</a></dt>
<dd><p>특정 테스트 케이스를 식별하는 문자열을 반환합니다. 이것은 보통 모듈과 클래스 이름을 포함한 테스트 메서드의 완전한 이름(full name)입니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.shortDescription">
<code class="descname">shortDescription</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.shortDescription" title="정의 주소">¶</a></dt>
<dd><p>테스트의 설명을 반환하거나 설명이 제공되지 않았으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 이 메서드의 기본 구현은 가능하다면 테스트 메서드의 독스트링의 첫 번째 줄을 반환하고 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span>3.1 버전에서 docstring이 있는 경우에도 짧은 설명에 테스트 이름을 추가하도록 변경되었습니다. 이것은 unittest 확장과 호환성 문제를 일으켰고 테스트 이름 추가는 파이썬 3.2에서 <a class="reference internal" href="#unittest.TextTestResult" title="unittest.TextTestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestResult</span></code></a>로 옮겨졌습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.addCleanup">
<code class="descname">addCleanup</code><span class="sig-paren">(</span><em>function</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addCleanup" title="정의 주소">¶</a></dt>
<dd><p>테스트 중에 사용된 자원을 정리하기 위해 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> 이후에 불리는 함수를 추가합니다. 함수들은 추가된 순서의 반대 순서대로 불리게 됩니다(<abbr title="후입 선출법(last-in, first-out)">LIFO</abbr>). 함수가 추가될 때 <a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanup()</span></code></a>에 같이 전달된 위치 인자나 키워드 인자와 함께 호출됩니다.</p>
<p>만약 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>이 실패한다면, 즉 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a>이 불리지 않더라도, 정리 함수들은 여전히 불리게 될 것입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestCase.doCleanups">
<code class="descname">doCleanups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.doCleanups" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> 이후나, <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>이 예외를 발생시키면 <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>이후에 조건 없이 호출됩니다.</p>
<p><a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanup()</span></code></a>에서 추가된 모든 정리 함수들을 호출하는 책임이 있습니다. 만약 정리 함수를 <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> <em>이전에</em> 불러야 할 필요가 있다면 <a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanups()</span></code></a>를 직접 부를 수 있습니다.</p>
<p><a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanups()</span></code></a>는 한 번에 하나씩 정리 함수 스택에서 메서드를 꺼내기 때문에 언제든지 호출될 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="unittest.TestCase.addClassCleanup">
<em class="property">classmethod </em><code class="descname">addClassCleanup</code><span class="sig-paren">(</span><em>function</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addClassCleanup" title="정의 주소">¶</a></dt>
<dd><p>테스트 클래스 중에 사용된 자원을 정리하기 위해 <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> 이후에 불리는 함수를 추가합니다. 함수들은 추가된 순서의 반대 순서대로 불리게 됩니다(<abbr title="후입 선출법(last-in, first-out)">LIFO</abbr>). 함수가 추가될 때 <a class="reference internal" href="#unittest.TestCase.addClassCleanup" title="unittest.TestCase.addClassCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addClassCleanup()</span></code></a>에 같이 전달된 위치 인자나 키워드 인자와 함께 호출됩니다.</p>
<p>만약 <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a>가 실패한다면, 즉 <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a>가 불리지 않더라도, 정리 함수들은 여전히 불리게 될 것입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="unittest.TestCase.doClassCleanups">
<em class="property">classmethod </em><code class="descname">doClassCleanups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.doClassCleanups" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> 이후나, <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a>이 예외를 발생시키면 <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a>이후에 조건 없이 호출됩니다.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanupClass()</span></code>에서 추가된 모든 정리 함수들을 호출하는 책임이 있습니다. 만약 정리 함수를 <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> <em>이전에</em> 불러야 할 필요가 있다면 <code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanupsClass()</span></code>를 직접 부를 수 있습니다.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanupsClass()</span></code>는 한 번에 하나씩 정리 함수 스택에서 메서드를 꺼내기 때문에 언제든지 호출될 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="unittest.IsolatedAsyncioTestCase">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">IsolatedAsyncioTestCase</code><span class="sig-paren">(</span><em>methodName='runTest'</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase" title="정의 주소">¶</a></dt>
<dd><p>This class provides an API similar to <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> and also accepts
coroutines as test functions.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
<dl class="method">
<dt id="unittest.IsolatedAsyncioTestCase.asyncSetUp">
<em class="property">coroutine </em><code class="descname">asyncSetUp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.asyncSetUp" title="정의 주소">¶</a></dt>
<dd><p>Method called to prepare the test fixture. This is called after <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code>.
This is called immediately before calling the test method; other than
<a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> or <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>, any exception raised by this method
will be considered an error rather than a test failure. The default implementation
does nothing.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.IsolatedAsyncioTestCase.asyncTearDown">
<em class="property">coroutine </em><code class="descname">asyncTearDown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.asyncTearDown" title="정의 주소">¶</a></dt>
<dd><p>Method called immediately after the test method has been called and the
result recorded.  This is called before <code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code>. This is called even if
the test method raised an exception, so the implementation in subclasses may need
to be particularly careful about checking internal state.  Any exception, other than
<a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> or <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>, raised by this method will be
considered an additional error rather than a test failure (thus increasing
the total number of reported errors). This method will only be called if
the <a class="reference internal" href="#unittest.IsolatedAsyncioTestCase.asyncSetUp" title="unittest.IsolatedAsyncioTestCase.asyncSetUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncSetUp()</span></code></a> succeeds, regardless of the outcome of the test method.
The default implementation does nothing.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.IsolatedAsyncioTestCase.addAsyncCleanup">
<code class="descname">addAsyncCleanup</code><span class="sig-paren">(</span><em>function</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.addAsyncCleanup" title="정의 주소">¶</a></dt>
<dd><p>This method accepts a coroutine that can be used as a cleanup function.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.IsolatedAsyncioTestCase.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>result=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.run" title="정의 주소">¶</a></dt>
<dd><p>Sets up a new event loop to run the test, collecting the result into
the <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> object passed as <em>result</em>.  If <em>result</em> is
omitted or <code class="docutils literal notranslate"><span class="pre">None</span></code>, a temporary result object is created (by calling
the <code class="xref py py-meth docutils literal notranslate"><span class="pre">defaultTestResult()</span></code> method) and used. The result object is
returned to <a class="reference internal" href="#unittest.IsolatedAsyncioTestCase.run" title="unittest.IsolatedAsyncioTestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>'s caller. At the end of the test all the tasks
in the event loop are cancelled.</p>
</dd></dl>

<p>An example illustrating the order:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">unittest</span> <span class="k">import</span> <span class="n">IsolatedAsyncioTestCase</span>

<span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">IsolatedAsyncioTestCase</span><span class="p">):</span>


    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;setUp&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncSetUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span> <span class="o">=</span> <span class="k">await</span> <span class="n">AsyncConnection</span><span class="p">()</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;asyncSetUp&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">test_response</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;test_response&quot;</span><span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;https://example.com&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addAsyncCleanup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_cleanup</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;tearDown&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncTearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;asyncTearDown&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;cleanup&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>After running the test, <code class="docutils literal notranslate"><span class="pre">events</span></code> would contain <code class="docutils literal notranslate"><span class="pre">[&quot;setUp&quot;,</span> <span class="pre">&quot;asyncSetUp&quot;,</span> <span class="pre">&quot;test_response&quot;,</span> <span class="pre">&quot;asyncTearDown&quot;,</span> <span class="pre">&quot;tearDown&quot;,</span> <span class="pre">&quot;cleanup&quot;]</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="unittest.FunctionTestCase">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">FunctionTestCase</code><span class="sig-paren">(</span><em>testFunc</em>, <em>setUp=None</em>, <em>tearDown=None</em>, <em>description=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.FunctionTestCase" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 테스트 실행자가 테스트를 수행할 수 있게 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 인터페이스 일부를 구현합니다, 하지만 테스트 코드가 검사하거나 에러를 보고하는 데 사용하는 메서드를 제공하지는 않습니다. 이것은 레거시 테스트 코드를 사용하여 테스트 케이스를 생성할 때 사용할 수 있습니다, 이것은 레거시 테스트 코드가 <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>-기반 테스트 프레임워크에 통합될 수 있게 해줍니다.</p>
</dd></dl>

<div class="section" id="deprecated-aliases">
<span id="id1"></span><h4>폐지된 에일리어스<a class="headerlink" href="#deprecated-aliases" title="제목 주소">¶</a></h4>
<p>역사적인 이유로 인해 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 메서드의 일부는 지금은 폐지된 에일리어스를 1개 또는 그 이상 가졌습니다. 다음 표는 폐지된 에일리어스과 그에 맞는 올바른 이름을 나열합니다:</p>
<blockquote>
<div><table class="docutils align-center">
<colgroup>
<col style="width: 40%" />
<col style="width: 29%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>메서드 이름</p></th>
<th class="head"><p>폐지된 에일리어스</p></th>
<th class="head"><p>폐지된 에일리어스</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a></p></td>
<td><p>failUnlessEqual</p></td>
<td><p>assertEquals</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotEqual()</span></code></a></p></td>
<td><p>failIfEqual</p></td>
<td><p>assertNotEquals</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue()</span></code></a></p></td>
<td><p>failUnless</p></td>
<td><p>assert_</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse()</span></code></a></p></td>
<td><p>failIf</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a></p></td>
<td><p>failUnlessRaises</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual()</span></code></a></p></td>
<td><p>failUnlessAlmostEqual</p></td>
<td><p>assertAlmostEquals</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual()</span></code></a></p></td>
<td><p>failIfAlmostEqual</p></td>
<td><p>assertNotAlmostEquals</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex()</span></code></a></p></td>
<td></td>
<td><p>assertRegexpMatches</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a></p></td>
<td></td>
<td><p>assertNotRegexpMatches</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a></p></td>
<td></td>
<td><p>assertRaisesRegexp</p></td>
</tr>
</tbody>
</table>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.1부터 폐지: </span>두 번째 열에 나열된 fail* 에일리어스는 폐지되었습니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.2부터 폐지: </span>세 번째 열에 나열된 assert* 에일리어스는 폐지되었습니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.2부터 폐지: </span><code class="docutils literal notranslate"><span class="pre">assertRegexpMatches</span></code>와 <code class="docutils literal notranslate"><span class="pre">assertRaisesRegexp</span></code>는 <a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex()</span></code></a>와 <a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a>로 이름이 변경되었습니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.5부터 폐지: </span><code class="docutils literal notranslate"><span class="pre">assertNotRegexpMatches</span></code> 이름은 폐지되고 <a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a>으로 대체합니다.</p>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="grouping-tests">
<span id="testsuite-objects"></span><h3>테스트 분류<a class="headerlink" href="#grouping-tests" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="unittest.TestSuite">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">TestSuite</code><span class="sig-paren">(</span><em>tests=()</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 개별 테스트 케이스와 테스트 묶음의 집합체를 나타냅니다. 이 클래스는 테스트 실행자가 이것을 다른 테스트 케이스처럼 실행할 수 있기 위해 필요한 인터페이스를 제공합니다. <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 인스턴스를 실행하는 것은 테스트 묶음을 이터레이션하면서 각 테스트를 개별적으로 실행하는 것과 같습니다.</p>
<p><em>tests</em>가 주어졌다면, 그것은 초기에 이 테스트 묶음을 만들 때 사용될 개별 테스트 케이스이거나 다른 테스트 묶음의 이터러블이어야 합니다. 나중에 컬렉션에 테스트 케이스나 테스트 묶음을 추가할 수 있는 추가 메서드가 제공됩니다.</p>
<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 객체는 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 객체와 흡사하게 행동합니다만, 테스트를 실제로 구현하지 않는 것이 다릅니다. 대신에, 이것은 다 같이 실행되어야 하는 테스트 그룹에 테스트들을 모으는 데 사용됩니다. <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 인스턴스에 테스트를 추가하기 위해 몇몇 추가적인 메서드를 사용할 수 있습니다.</p>
<dl class="method">
<dt id="unittest.TestSuite.addTest">
<code class="descname">addTest</code><span class="sig-paren">(</span><em>test</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.addTest" title="정의 주소">¶</a></dt>
<dd><p>테스트 묶음에 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>나 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 추가하기.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestSuite.addTests">
<code class="descname">addTests</code><span class="sig-paren">(</span><em>tests</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.addTests" title="정의 주소">¶</a></dt>
<dd><p>이 테스트 묶음에 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>와 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 인스턴스의 이터러블에서 나온 모든 테스트를 추가하기.</p>
<p>이것은 <em>tests</em>를 이터레이션하면서 각 요소에 대해 <a class="reference internal" href="#unittest.TestSuite.addTest" title="unittest.TestSuite.addTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTest()</span></code></a>를 호출하는 것과 같습니다.</p>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>는 다음 메서드를 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>와 공유합니다:</p>
<dl class="method">
<dt id="unittest.TestSuite.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.run" title="정의 주소">¶</a></dt>
<dd><p>이 테스트 묶음과 연관된 테스트를 실행하고, <em>result</em>로 전달된 테스트 결과 객체에 결과를 수집합니다. <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.run()</span></code></a>과 달리 <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a>은 결과 객체가 반드시 전달되어야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestSuite.debug">
<code class="descname">debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.debug" title="정의 주소">¶</a></dt>
<dd><p>결과를 수집하지 않고 이 테스트 묶음과 연관된 테스트를 실행합니다. 이것은 테스트에서 발생한 예외가 호출자로 전파될 수 있게 해서 디버거 환경에서 테스트를 실행할 때 사용될 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestSuite.countTestCases">
<code class="descname">countTestCases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.countTestCases" title="정의 주소">¶</a></dt>
<dd><p>이 테스트 객체에 해당하는 테스트 개수를 반환합니다, 모든 개별 테스트와 서브-테스트 묶음을 포함합니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestSuite.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.__iter__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>로 묶인 테스트들은 항상 이터레이션으로 접근합니다. 서브 클래스는 <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>를 재정의하여 테스트를 지연해서 제공할 수 있습니다. 이 메서드는 한 개의 테스트 묶음에서 여러 번 불릴 수 있다는 것을 기억하십시오(예를 들어 테스트 개수를 세거나 동등성을 위해 비교할 때), 그러므로 <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a> 전에 수 번의 이터레이션이 반환한 테스트들은 매 이터레이션 호출마다 반드시 같아야 합니다. <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a> 후에는 호출자가 테스트 참조를 보존하기 위해 <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite._removeTestAtIndex()</span></code>를 재정의한 서브 클래스를 사용하는 경우가 아니라면 이 메서드에 의해 반환된 테스트에 의존하면 안 됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>이전 버전에서는 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>가 이터레이션을 사용하기보다는 직접 테스트에 접근했습니다, 따라서 <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>를 재정의하는 것은 테스트를 제공하기에 충분하지 않았습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>이전 버전에서는 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>가 <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a> 후에 각 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 의 참조를 유지했습니다. 서브 클래스는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite._removeTestAtIndex()</span></code>를 재정의해서 이 동작을 복구할 수 있습니다.</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 객체의 전형적인 사용법은 최종 사용자 테스트 장치(harness)보다는 <code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code>에 의해 <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> 메서드가 호출되는 것입니다.</p>
</dd></dl>

</div>
<div class="section" id="loading-and-running-tests">
<h3>테스트를 로드하고 실행하기<a class="headerlink" href="#loading-and-running-tests" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="unittest.TestLoader">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">TestLoader</code><a class="headerlink" href="#unittest.TestLoader" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 클래스는 클래스와 모듈로부터 테스트 묶음을 생성하는 데 사용됩니다. 보통, 이 클래스의 인스턴스를 생성할 필요는 없습니다; <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 모듈은 공유 가능한 <a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><code class="xref py py-data docutils literal notranslate"><span class="pre">unittest.defaultTestLoader</span></code></a> 인스턴스를 제공합니다. 그러나 서브 클래스나 인스턴스를 사용함으로 몇몇 변경 가능한 속성을 사용자 정의할 수 있습니다.</p>
<p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 객체는 다음 어트리뷰트를 가집니다:</p>
<dl class="attribute">
<dt id="unittest.TestLoader.errors">
<code class="descname">errors</code><a class="headerlink" href="#unittest.TestLoader.errors" title="정의 주소">¶</a></dt>
<dd><p>테스트를 로드하는 동안 발생한 치명적이지 않은(non-fatal) 에러 목록입니다. 어떤 시점에도 로더에 의해 재설정되지 않습니다. 치명적인 에러는 예외를 발생시키는 관련 메서드에 의해 신호가 발생하여 호출자에게 전달됩니다. 치명적이지 않은 에러는 실행 시에 원래 에러를 발생시킬 합성(synthetic) 테스트가 표시하기도 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 객체는 다음 메서드를 가집니다:</p>
<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromTestCase">
<code class="descname">loadTestsFromTestCase</code><span class="sig-paren">(</span><em>testCaseClass</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromTestCase" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>에서 파생된 <code class="xref py py-class docutils literal notranslate"><span class="pre">testCaseClass</span></code>에 포함된 모든 테스트 케이스의 묶음을 반환합니다.</p>
<p>테스트 케이스 인스턴스는 <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a>에 의해 이름 지어진 각 메서드를 위해 생성됩니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">test</span></code>로 시작되는 메서드 이름입니다. 만약 <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a>가 아무 메서드도 반환하지 않지만, <code class="xref py py-meth docutils literal notranslate"><span class="pre">runTest()</span></code> 메서드가 구현되었다면 이 메서드를 위해서 1개의 테스트 케이스가 대신 생성됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromModule">
<code class="descname">loadTestsFromModule</code><span class="sig-paren">(</span><em>module</em>, <em>pattern=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromModule" title="정의 주소">¶</a></dt>
<dd><p>주어진 모듈에 포함된 모든 테스트 케이스 묶음을 반환합니다. 이 메서드는 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>에서 파생된 클래스를 찾기 위해 <em>module</em>을 검색하고 클래스에 정의된 각 테스트 메서드를 위해 클래스의 인스턴스를 생성합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>에서 파생된 클래스의 계층 사용이 픽스쳐와 도우미 함수를 공유하는 데 편리할 수 있지만 직접 인스턴스화를 하도록 의도되지 않은 베이스 클래스에 테스트 메서드를 정의하는 것은 이 메서드와 잘 작동하지 않습니다. 그러나 그렇게 하는 것이 픽스처들이 다르고 서브 클래스에서 정의될 경우에는 유용할 수 있습니다.</p>
</div>
<p>만약 모듈이 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 함수를 제공한다면 테스트 로드를 위해 이것을 호출할 것입니다. 이것은 모듈이 테스트 로드를 사용자 정의할 수 있도록 해줍니다. 이것은 <a class="reference internal" href="#load-tests-protocol">load_tests 프로토콜</a>입니다. <em>pattern</em> 인자는 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>에 세 번째 인자로 전달됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 지원이 추가됨.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>문서로 만들어 져 있지 않고 공식적이지 않은 <em>use_load_tests</em> 기본 인자를 폐지하고 무시합니다, 하지만 하위 호환성을 위해 여전히 그것을 수용합니다. 이 메서드는 이제 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>에 세 번째 인자로 전달되는 <em>pattern</em>을 오직 키워드 인자로써 수용합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromName">
<code class="descname">loadTestsFromName</code><span class="sig-paren">(</span><em>name</em>, <em>module=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromName" title="정의 주소">¶</a></dt>
<dd><p>문자열 지정자에 맞는 모든 테스트 케이스 묶음을 반환합니다.</p>
<p>지정자 <em>name</em>은 모듈, 테스트 케이스 클래스, 테스트 케이스 클래스에 있는 테스트 메서드, <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 인스턴스, <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>나 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 인스턴스를 반환하는 콜러블 객체로 해석될 수 있는 &quot;점으로 구분된 이름(dotted name)&quot;입니다. 이 검사는 여기에 나열된 순서대로 적용됩니다; 즉, 테스트 케이스 클래스에 있는 메서드는 &quot;콜러블  객체&quot;보다는 &quot;테스트 케이스 클래스에 있는 테스트 메서드&quot;로 선택될 것입니다.</p>
<p>예를 들어, 만약 당신이 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>에서 파생된 클래스인 <code class="xref py py-class docutils literal notranslate"><span class="pre">SampleTestCase</span></code>를 포함한 <code class="xref py py-mod docutils literal notranslate"><span class="pre">SampleTests</span></code> 모듈을 가지고 있고 그 클래스는 3개의 테스트 메서드(<code class="xref py py-meth docutils literal notranslate"><span class="pre">test_one()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_two()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_three()</span></code>)를 가지고 있다면, 지정자 <code class="docutils literal notranslate"><span class="pre">'SampleTests.SampleTestCase'</span></code> 에 대해서 이 메서드는 모든 3개의 테스트 메서드를 실행할 테스트 묶음으로 반환할 것입니다. 지정자가  <code class="docutils literal notranslate"><span class="pre">'SampleTests.SampleTestCase.test_two'</span></code> 라면 이 메서드는 오직 <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_two()</span></code> 테스트 메서드를 실행할 테스트 묶음을 반환할 것입니다. 지정자는 아직 임포트되지 않은 모듈이나 패키지를 가리킬 수 있습니다; 부작용(side-effect)으로써 그것들이 임포트될 것입니다.</p>
<p>이 메서드는 주어진 <em>module</em>에 상대적인 <em>name</em>을 선택적으로 해석할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>만약 <em>name</em> 순회 중에 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>나 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>가 발생한다면 실행할 때 그 에러를 일으키는 합성 테스트가 반환될 것입니다. 이 에러는 self.errors 에러 모임에 포함될 것입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.loadTestsFromNames">
<code class="descname">loadTestsFromNames</code><span class="sig-paren">(</span><em>names</em>, <em>module=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromNames" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestLoader.loadTestsFromName" title="unittest.TestLoader.loadTestsFromName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFromName()</span></code></a>와 비슷하지만, 1개의 이름이 아닌 이름의 시퀀스를 받습니다. 반환 값은 각 이름에 정의된 모든 테스트를 지원하는 테스트 묶음입니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.getTestCaseNames">
<code class="descname">getTestCaseNames</code><span class="sig-paren">(</span><em>testCaseClass</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.getTestCaseNames" title="정의 주소">¶</a></dt>
<dd><p><em>testCaseClass</em> 안에서 찾은 메서드 이름을 정렬된 시퀀스로 반환합니다; 이 클래스는 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>의 서브 클래스이어야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestLoader.discover">
<code class="descname">discover</code><span class="sig-paren">(</span><em>start_dir</em>, <em>pattern='test*.py'</em>, <em>top_level_dir=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.discover" title="정의 주소">¶</a></dt>
<dd><p>지정된 시작 디렉터리부터 하위 디렉터리를 재귀적으로 순회하여 모든 테스트 모듈을 찾아, 이를 포함하는 TestSuite 객체를 반환합니다. <em>pattern</em>에 일치하는 테스트 파일만 로드될 것입니다. (셸 방식의 패턴 일치를 사용합니다.) 임포트 가능한(즉, 유효한 파이썬 식별자인) 모듈 이름만 로드될 것입니다.</p>
<p>모든 테스트 모듈은 반드시 프로젝트의 최상위 수준에서 임포트 가능해야 합니다. 만약 시작 디렉터리가 최상위 디렉터리가 아니라면 최상위 디렉터리를 따로 지정해야 합니다.</p>
<p>만약 모듈 임포트가 실패한다면, 예를 들어 문법 에러로 인해, 이것은 1개의 에러로 기록되고 탐색이 계속 진행될 것입니다. 만약 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>가 발생해서 임포트가 실패했다면, 이것은 에러가 아닌 건너뛰기로 기록될 것입니다.</p>
<p>만약 패키지(<code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 라는 이름의 파일을 포함한 디렉터리)를 찾으면, <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 함수가 있는지 패키지를 검사할 것입니다. 만약 존재한다면 그 패키지에 대해서 <code class="docutils literal notranslate"><span class="pre">package.load_tests(loader,</span> <span class="pre">tests,</span> <span class="pre">pattern)</span></code>가 불릴 것입니다. 만약 load_tests 함수 자체가 <code class="docutils literal notranslate"><span class="pre">loader.discover</span></code>를 호출할지라도, 테스트 탐색은 실행 중에 패키지에 대한 테스트 검사를 한 번만 실행하도록 보장합니다.</p>
<p>만약 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>가 존재한다면 탐색은 패키지 안을 재귀 탐색하지 <em>않습니다</em>. <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>가 패키지 안의 모든 테스트를 로드할 책임이 있습니다.</p>
<p>패턴은 의도적으로 로더 어트리뷰트로 저장되지 않아 패키지가 자신에 대한 탐색을 계속할 수 있습니다. <em>top_level_dir</em>는 저장되어 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>가 <code class="docutils literal notranslate"><span class="pre">loader.discover()</span></code>에게 이 인자를 건네줄 필요가 없습니다.</p>
<p><em>start_dir</em>는 디렉터리뿐만 아니라 점으로 구분된 모듈 이름이 될 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>임포트 시에 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>가 발생한 모듈은 에러가 아닌, 건너뛰기로 기록됩니다. 탐색은 <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">이름 공간 패키지</span></a>를 지원합니다. 임포트되기 전에 경로들이 정렬되어 파일 시스템의 정렬 순서가 파일 이름에 의존하지 않더라도 실행 순서가 같아지도록 합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이제 발견된 패키지는 그것의 경로가 <em>pattern</em>과 일치하는지 여부와 상관없이 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>를 검사합니다, 왜냐하면 패키지 이름이 기본 패턴과 일치하는 것이 불가능하기 때문입니다.</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a>의 다음 어트리뷰트들은 서브 클래스나 인스턴스에 대입을 통해 구성할 수 있습니다.</p>
<dl class="attribute">
<dt id="unittest.TestLoader.testMethodPrefix">
<code class="descname">testMethodPrefix</code><a class="headerlink" href="#unittest.TestLoader.testMethodPrefix" title="정의 주소">¶</a></dt>
<dd><p>테스트 메서드로 해석할 메서드 이름의 접두사에 해당하는 문자열입니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'test'</span></code> 입니다.</p>
<p>이것은 <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a> 과 모든 <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code> 메서드에 영향을 미칩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestLoader.sortTestMethodsUsing">
<code class="descname">sortTestMethodsUsing</code><a class="headerlink" href="#unittest.TestLoader.sortTestMethodsUsing" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a>와 모든 <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code> 메서드에서 메서드 이름 정렬 시에 이름 비교하는 데 사용될 함수입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestLoader.suiteClass">
<code class="descname">suiteClass</code><a class="headerlink" href="#unittest.TestLoader.suiteClass" title="정의 주소">¶</a></dt>
<dd><p>테스트 목록에서 테스트 묶음을 생성하는 콜러블 객체입니다. 결과 객체에 어떤 메서드도 필요하지 않습니다. 기본값은 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 클래스입니다.</p>
<p>이것은 모든 <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code> 메서드에 영향을 미칩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestLoader.testNamePatterns">
<code class="descname">testNamePatterns</code><a class="headerlink" href="#unittest.TestLoader.testNamePatterns" title="정의 주소">¶</a></dt>
<dd><p>테스트 묶음에 포함되기 위해서 테스트 메서드가 일치해야 할 유닉스 셸-방식의 와일드카드 테스트 이름 패턴 목록입니다(<code class="docutils literal notranslate"><span class="pre">-v</span></code> 옵션을 보십시오).</p>
<p>만약 이 어트리뷰트가 <code class="docutils literal notranslate"><span class="pre">None</span></code>(기본값)이 아니라면, 테스트 묶음에 포함될 모든 테스트 메서드는 이 목록의 패턴 중 1개와 반드시 일치해야 합니다. 이 패턴 일치는 항상 <a class="reference internal" href="fnmatch.html#fnmatch.fnmatchcase" title="fnmatch.fnmatchcase"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fnmatch.fnmatchcase()</span></code></a>를 사용하여 수행된다는 것을 기억하십시오, 그래서 <code class="docutils literal notranslate"><span class="pre">-v</span></code> 옵션에 패턴을 건네주는 것과 달리, 간단한 부분 문자열 패턴은 <code class="docutils literal notranslate"><span class="pre">*</span></code> 와일드카드를 사용하도록 변경되어야 할 것입니다.</p>
<p>이것은 모든 <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code> 메서드에 영향을 미칩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="unittest.TestResult">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">TestResult</code><a class="headerlink" href="#unittest.TestResult" title="정의 주소">¶</a></dt>
<dd><p>어떤 테스트가 성공했고 어떤 테스트가 실패했는지에 관한 정보를 엮는데 사용되는 클래스입니다.</p>
<p><a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 객체는 여러 테스트의 결과들을 저장합니다. <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>와 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 클래스는 결과가 올바르게 기록되는 것을 보장합니다; 테스트 작성자가 테스트 결과를 기록하는 것에 대해서 걱정할 필요가 없습니다.</p>
<p><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 위에 만들어진 테스트 프레임워크는 보고 목적으로 여러 테스트가 실행하면서 만들어낸 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 객체에 접근하고 싶을 수도 있습니다; <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestRunner.run()</span></code> 메서드는 이 목적을 위해 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 인스턴스를 반환합니다.</p>
<p><a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 인스턴스는 테스트 실행 결과를 조사할 때 관심이 생길만한 다음과 같은 어트리뷰트를 가지고 있습니다.</p>
<dl class="attribute">
<dt id="unittest.TestResult.errors">
<code class="descname">errors</code><a class="headerlink" href="#unittest.TestResult.errors" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 인스턴스와 포맷된(formatted) 트레이스백 문자열로 구성된 2-튜플을 포함하는 목록입니다. 각 튜플은 예기치 못한 예외가 발생한 테스트에 해당합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.failures">
<code class="descname">failures</code><a class="headerlink" href="#unittest.TestResult.failures" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 인스턴스와 포맷된(formatted) 트레이스백 문자열로 구성된 2-튜플을 포함하는 목록입니다. 각 튜플은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.assert*()</span></code> 메서드를 사용하여 명시적으로 실패가 발생한 테스트에 해당합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.skipped">
<code class="descname">skipped</code><a class="headerlink" href="#unittest.TestResult.skipped" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 인스턴스와 테스트 건너뛰기한 이유 문자열로 구성된 2-튜플을 포함하는 목록입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.expectedFailures">
<code class="descname">expectedFailures</code><a class="headerlink" href="#unittest.TestResult.expectedFailures" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 인스턴스와 포맷된(formatted) 트레이스백 문자열로 구성된 2-튜플을 포함하는 목록입니다. 각 튜플은 테스트 케이스의 예상된 실패에 해당합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.unexpectedSuccesses">
<code class="descname">unexpectedSuccesses</code><a class="headerlink" href="#unittest.TestResult.unexpectedSuccesses" title="정의 주소">¶</a></dt>
<dd><p>예상된 실패로 표시되었지만 성공한 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 인스턴스를 포함하는 목록입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.shouldStop">
<code class="descname">shouldStop</code><a class="headerlink" href="#unittest.TestResult.shouldStop" title="정의 주소">¶</a></dt>
<dd><p>테스트 실행이 <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a>에 의해 정지되어야 할 때 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.testsRun">
<code class="descname">testsRun</code><a class="headerlink" href="#unittest.TestResult.testsRun" title="정의 주소">¶</a></dt>
<dd><p>이제까지 실행된 테스트 총 개수입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.buffer">
<code class="descname">buffer</code><a class="headerlink" href="#unittest.TestResult.buffer" title="정의 주소">¶</a></dt>
<dd><p>참으로 설정하면 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>와 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>가 <a class="reference internal" href="#unittest.TestResult.startTest" title="unittest.TestResult.startTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startTest()</span></code></a>와 <a class="reference internal" href="#unittest.TestResult.stopTest" title="unittest.TestResult.stopTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stopTest()</span></code></a> 호출 사이에서 버퍼링될 것입니다. 수집된 출력은 테스트가 실패하거나 에러가 발생한 경우에만 실제 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>와 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>에 출력될 것입니다. 모든 출력은 실패 / 에러 메시지에도 첨부됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.failfast">
<code class="descname">failfast</code><a class="headerlink" href="#unittest.TestResult.failfast" title="정의 주소">¶</a></dt>
<dd><p>참으로 설정하면 첫 번째 실패 또는 에러에서 <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a>이 호출될 것입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="unittest.TestResult.tb_locals">
<code class="descname">tb_locals</code><a class="headerlink" href="#unittest.TestResult.tb_locals" title="정의 주소">¶</a></dt>
<dd><p>참으로 설정하면 지역 변수가 트레이스백에 보일 것입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.wasSuccessful">
<code class="descname">wasSuccessful</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.wasSuccessful" title="정의 주소">¶</a></dt>
<dd><p>이제까지 실행한 모든 테스트가 성공했다면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환하고, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a> 데코레이터로 표시된 테스트에서 <a class="reference internal" href="#unittest.TestResult.unexpectedSuccesses" title="unittest.TestResult.unexpectedSuccesses"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unexpectedSuccesses</span></code></a>가 있다면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stop" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TestResult.shouldStop" title="unittest.TestResult.shouldStop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shouldStop</span></code></a> 어트리뷰트를 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정하여 현재 실행 중인 테스트 모음을 중단해야 함을 알리기 위한 용도로 이 메서드를 부를 수 있습니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code> 객체는 이 신호를 존중하여 어떠한 추가 테스트 없이 반환해야 합니다.</p>
<p>예를 들어, 사용자가 키보드로 중단 신호를 보낼 때 테스트 프레임워크를 중단하기 위해 <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestRunner</span></code></a>가 이 기능을 사용합니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code> 구현을 제공하는 대화형 도구는 비슷한 방법으로 이것을 사용할 수 있습니다.</p>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 클래스의 다음 메서드는 내부 자료 구조를 관리하려고 사용되고, 추가적인 보고 요구사항을 지원하기 위해 서브 클래스에서 확장할 수도 있습니다. 이것은 테스트가 실행 중에 대화형 보고를 지원하는 도구를 만들 때 특별히 유용합니다.</p>
<dl class="method">
<dt id="unittest.TestResult.startTest">
<code class="descname">startTest</code><span class="sig-paren">(</span><em>test</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.startTest" title="정의 주소">¶</a></dt>
<dd><p>테스트 케이스 <em>test</em>가 막 실행되려 할 때 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.stopTest">
<code class="descname">stopTest</code><span class="sig-paren">(</span><em>test</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stopTest" title="정의 주소">¶</a></dt>
<dd><p>결과에 상관없이 테스트 케이스 <em>test</em>가 실행되고 나서 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.startTestRun">
<code class="descname">startTestRun</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.startTestRun" title="정의 주소">¶</a></dt>
<dd><p>모든 테스트가 실행되기 전에 1번 호출됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.stopTestRun">
<code class="descname">stopTestRun</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stopTestRun" title="정의 주소">¶</a></dt>
<dd><p>모든 테스트가 실행되고 나서 1번 호출됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addError">
<code class="descname">addError</code><span class="sig-paren">(</span><em>test</em>, <em>err</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addError" title="정의 주소">¶</a></dt>
<dd><p>테스트 케이스 <em>test</em>가 예기치 못한 예외를 발생한 경우 호출됩니다. <em>err</em>는 <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>가 반환한 형식의 튜플입니다: <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code>.</p>
<p>기본 구현은 <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> 튜플을 인스턴스의 <a class="reference internal" href="#unittest.TestResult.errors" title="unittest.TestResult.errors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errors</span></code></a> 어트리뷰트에 추가합니다, 여기서 <em>formatted_err</em>는 <em>err</em>에서 파생된 포맷한 트레이스백입니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addFailure">
<code class="descname">addFailure</code><span class="sig-paren">(</span><em>test</em>, <em>err</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addFailure" title="정의 주소">¶</a></dt>
<dd><p>테스트 케이스 <em>test</em>가 실패 신호를 보낸 경우 호출됩니다. <em>err</em>는 <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>가 반환한 형식의 튜플입니다: <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code>.</p>
<p>기본 구현은 <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> 튜플을 인스턴스의 <a class="reference internal" href="#unittest.TestResult.failures" title="unittest.TestResult.failures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">failures</span></code></a> 어트리뷰트에 추가합니다, 여기서 <em>formatted_err</em>는 <em>err</em>에서 파생된 포맷한 트레이스백입니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addSuccess">
<code class="descname">addSuccess</code><span class="sig-paren">(</span><em>test</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSuccess" title="정의 주소">¶</a></dt>
<dd><p>테스트 케이스 <em>test</em>가 성공하면 호출됩니다.</p>
<p>기본 구현은 아무것도 하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addSkip">
<code class="descname">addSkip</code><span class="sig-paren">(</span><em>test</em>, <em>reason</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSkip" title="정의 주소">¶</a></dt>
<dd><p>테스트 케이스 <em>test</em>가 건너뛰어지면 호출됩니다. <em>reason</em>은 테스트가 준 건너뛰는 이유입니다.</p>
<p>기본 구현은 <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">reason)</span></code> 튜플을 인스턴스의 <a class="reference internal" href="#unittest.TestResult.skipped" title="unittest.TestResult.skipped"><code class="xref py py-attr docutils literal notranslate"><span class="pre">skipped</span></code></a> 어트리뷰트에 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addExpectedFailure">
<code class="descname">addExpectedFailure</code><span class="sig-paren">(</span><em>test</em>, <em>err</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addExpectedFailure" title="정의 주소">¶</a></dt>
<dd><p>테스트 케이스 <em>test</em>가 실패했지만 <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a> 데코레이터로 표시된 경우 호출됩니다</p>
<p>기본 구현은 <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> 튜플을 인스턴스의 <a class="reference internal" href="#unittest.TestResult.expectedFailures" title="unittest.TestResult.expectedFailures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">expectedFailures</span></code></a> 어트리뷰트에 추가합니다, 여기서 <em>formatted_err</em>는 <em>err</em>에서 파생된 포맷한 트레이스백입니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addUnexpectedSuccess">
<code class="descname">addUnexpectedSuccess</code><span class="sig-paren">(</span><em>test</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addUnexpectedSuccess" title="정의 주소">¶</a></dt>
<dd><p>테스트 케이스 <em>test</em>가 <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a> 데코레이터로 표시되었지만, 성공한 경우 호출됩니다.</p>
<p>기본 구현은 테스트를 인스턴스의 <a class="reference internal" href="#unittest.TestResult.unexpectedSuccesses" title="unittest.TestResult.unexpectedSuccesses"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unexpectedSuccesses</span></code></a> 어트리뷰트에 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="unittest.TestResult.addSubTest">
<code class="descname">addSubTest</code><span class="sig-paren">(</span><em>test</em>, <em>subtest</em>, <em>outcome</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSubTest" title="정의 주소">¶</a></dt>
<dd><p>부분 테스트가 완료되었을 때 호출됩니다. <em>test</em>는 테스트 메서드에 대응하는 테스트 케이스입니다. <em>subtest</em>는 부분 테스트를 설명하는 사용자 지정 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 인스턴스입니다.</p>
<p><em>outcome</em>이 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>이면, 부분 테스트가 성공한 것입니다. 그렇지 않으면 예외와 함께 실패한 것인데 <em>outcome</em>은 <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>가 반환한 형식의 튜플입니다: <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code>.</p>
<p>기본 구현은 결과가 성공인 경우 아무것도 하지 않고 부분 테스트의 실패를 일반적인 실패로 기록합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="unittest.TextTestResult">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">TextTestResult</code><span class="sig-paren">(</span><em>stream</em>, <em>descriptions</em>, <em>verbosity</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestResult" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestRunner</span></code></a>에서 사용하는 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>의 구체적인 구현입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가: </span>이 클래스는 이전에 <code class="docutils literal notranslate"><span class="pre">_TextTestResult</span></code> 이름이었습니다. 이 이름은 여전히 에일리어스로 존재하지만 폐지된 상태입니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="unittest.defaultTestLoader">
<code class="descclassname">unittest.</code><code class="descname">defaultTestLoader</code><a class="headerlink" href="#unittest.defaultTestLoader" title="정의 주소">¶</a></dt>
<dd><p>공유 목적의 <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 클래스의 인스턴스입니다. 만약 <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a>를 사용자 정의할 필요가 없다면, 계속 새로운 인스턴스를 생성하는 것 대신 이 인스턴스를 사용할 수 있습니다.</p>
</dd></dl>

<dl class="class">
<dt id="unittest.TextTestRunner">
<em class="property">class </em><code class="descclassname">unittest.</code><code class="descname">TextTestRunner</code><span class="sig-paren">(</span><em>stream=None</em>, <em>descriptions=True</em>, <em>verbosity=1</em>, <em>failfast=False</em>, <em>buffer=False</em>, <em>resultclass=None</em>, <em>warnings=None</em>, <em>*</em>, <em>tb_locals=False</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner" title="정의 주소">¶</a></dt>
<dd><p>결과를 스트림으로 출력하는 기본 테스트 실행자 구현입니다. 만약 <em>stream</em>이 기본값인 <code class="docutils literal notranslate"><span class="pre">None</span></code>이라면, <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a>가 출력 스트림으로 사용됩니다. 이 클래스는 몇 가지 설정 가능한 매개변수를 가지고 있지만, 본질적으로 매우 간단합니다. 테스트 묶음을 실행하는 그래픽 애플리케이션은 대안 구현을 제공해야 합니다. 이러한 구현은 unittest에 기능이 추가될 때 실행자를 만드는 인터페이스가 변하기 때문에 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>를 받아들여야 합니다.</p>
<p>기본적으로 이 실행자는 <a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>, <a class="reference internal" href="exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a>, <a class="reference internal" href="exceptions.html#ResourceWarning" title="ResourceWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ResourceWarning</span></code></a>, <a class="reference internal" href="exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a>이 <a class="reference internal" href="warnings.html#warning-ignored"><span class="std std-ref">기본적으로 무시</span></a> 설정이 되어 있더라도 이것들을 보여줍니다. <a class="reference internal" href="#deprecated-aliases"><span class="std std-ref">폐지된 unittest 메서드</span></a> 에 의해 발생한 폐지 경고도 특수한 경우이고, 경고 필터가 <code class="docutils literal notranslate"><span class="pre">'default'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'always'</span></code> 일 때, 너무 많은 경고 메시지를 피하고자 그것들이 모듈당 1번만 보일 것입니다. 파이썬의 <code class="xref std std-option docutils literal notranslate"><span class="pre">-Wd</span></code>이나 <code class="xref std std-option docutils literal notranslate"><span class="pre">-Wa</span></code> 옵션(<a class="reference internal" href="../using/cmdline.html#using-on-warnings"><span class="std std-ref">경고 제어</span></a>를 보십시오)을 사용하고 <em>warnings</em>를 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정하여 이 동작을 오버라이드 할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><code class="docutils literal notranslate"><span class="pre">warnings</span></code> 인자 추가.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>임포트 시간이 아닌 인스턴스화 시간에 기본 스트림이 <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a>으로 설정됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>tb_locals 매개변수 추가.</p>
</div>
<dl class="method">
<dt id="unittest.TextTestRunner._makeResult">
<code class="descname">_makeResult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner._makeResult" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#unittest.TextTestRunner.run" title="unittest.TextTestRunner.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>가 사용하는 <code class="docutils literal notranslate"><span class="pre">TestResult</span></code> 인스턴스를 반환합니다. 직접 호출하게 의도되지 않았지만, 사용자 정의 <code class="docutils literal notranslate"><span class="pre">TestResult</span></code>를 제공하기 위해 서브 클래스에서 오버라이드할 수 있습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">_makeResult()</span></code>는 <code class="docutils literal notranslate"><span class="pre">TextTestRunner</span></code> 생성자에 <code class="docutils literal notranslate"><span class="pre">resultclass</span></code> 인자로 전달된 클래스나 콜러블을 인스턴스화합니다. 만약 <code class="docutils literal notranslate"><span class="pre">resultclass</span></code>가 제공되지 않았다면 기본값은 <a class="reference internal" href="#unittest.TextTestResult" title="unittest.TextTestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestResult</span></code></a> 입니다. 결과 클래스는 다음 인자와 함께 인스턴스화됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">stream</span><span class="p">,</span> <span class="n">descriptions</span><span class="p">,</span> <span class="n">verbosity</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="unittest.TextTestRunner.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>test</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner.run" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <code class="docutils literal notranslate"><span class="pre">TextTestRunner</span></code>의 주된 공개 인터페이스입니다. 이 메서드는 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>나 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 인스턴스를 받습니다. <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>는 <a class="reference internal" href="#unittest.TextTestRunner._makeResult" title="unittest.TextTestRunner._makeResult"><code class="xref py py-func docutils literal notranslate"><span class="pre">_makeResult()</span></code></a>를 호출하여 생성하고 테스트가 실행되며 결과가 stdout에 출력됩니다.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="unittest.main">
<code class="descclassname">unittest.</code><code class="descname">main</code><span class="sig-paren">(</span><em>module='__main__'</em>, <em>defaultTest=None</em>, <em>argv=None</em>, <em>testRunner=None</em>, <em>testLoader=unittest.defaultTestLoader</em>, <em>exit=True</em>, <em>verbosity=1</em>, <em>failfast=None</em>, <em>catchbreak=None</em>, <em>buffer=None</em>, <em>warnings=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.main" title="정의 주소">¶</a></dt>
<dd><p><em>module</em>에서 테스트 모음을 로드하고 실행하는 명령행 프로그램입니다; 이것은 주로 편리하게 실행 가능한 테스트 모듈을 만들기 위한 것입니다. 이 함수의 가장 간단한 사용은 테스트 스크립트 마지막에 다음과 같은 줄을 포함하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>당신은 상세도 인자를 전달하여 좀 더 자세한 정보와 함께 테스트를 실행할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p><em>defaultTest</em> 인자는 <em>argv</em>로 테스트 이름이 지정되지 않은 경우 실행될 1개의 테스트 이름이거나 테스트 이름의 이터러블입니다. 만약 이 인자가 지정되지 않거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면서 <em>argv</em>로 테스트 이름이 지정되지 않으면 <em>module</em> 안에서 찾은 모든 테스트가 실행됩니다.</p>
<p><em>argv</em> 인자는 프로그램에 전달된 옵션 목록이 될 수 있습니다, 첫 번째 요소는 프로그램 이름입니다. 만약 이 인자가 지정되지 않거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, <a class="reference internal" href="sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a> 값이 사용됩니다.</p>
<p><em>testRunner</em> 인자는 테스트 실행자 클래스나 이미 생성된 테스트 실행자 인스턴스일 수 있습니다. 기본적으로 <code class="docutils literal notranslate"><span class="pre">main</span></code>은 실행한 테스트가 성공인지 실패인지를 나타내는 종료 코드와 함께 <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a>을 호출합니다.</p>
<p><em>testLoader</em> 인자는 <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 인스턴스이어야 하고 기본값은 <a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><code class="xref py py-data docutils literal notranslate"><span class="pre">defaultTestLoader</span></code></a> 입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">main</span></code>은 <code class="docutils literal notranslate"><span class="pre">exit=False</span></code> 인자를 전달하여 대화형 인터프리터에서 사용하는 것을 지원합니다. 이것은 <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> 호출 없이 결과가 표준 출력에 표시됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest</span> <span class="k">import</span> <span class="n">main</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="s1">&#39;test_module&#39;</span><span class="p">,</span> <span class="n">exit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><em>failfast</em>, <em>catchbreak</em>, <em>buffer</em> 매개변수는 <a class="reference internal" href="#command-line-options">명령행 옵션</a>의 같은 이름과 같은 효과를 가지고 있습니다.</p>
<p><em>warnings</em> 인자는 테스트 실행 중에 사용되어야 할 <a class="reference internal" href="warnings.html#warning-filter"><span class="std std-ref">경고 필터</span></a>를 지정합니다. 만약 아무 값도 지정되지 않았다면, <code class="xref std std-option docutils literal notranslate"><span class="pre">-W</span></code> 옵션이 <strong class="program">python</strong>으로 전달된 경우(<a class="reference internal" href="../using/cmdline.html#using-on-warnings"><span class="std std-ref">경고 제어</span></a>를 보십시오)에는 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 남아 있고, 그렇지 않은 경우에는 <code class="docutils literal notranslate"><span class="pre">'default'</span></code>로 설정됩니다.</p>
<p>사실 <code class="docutils literal notranslate"><span class="pre">main</span></code> 호출은 <code class="docutils literal notranslate"><span class="pre">TestProgram</span></code> 클래스의 인스턴스를 반환합니다. 이것은 실행된 테스트의 결과를 <code class="docutils literal notranslate"><span class="pre">result</span></code> 어트리뷰트에 저장합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span><em>exit</em> 매개변수가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>verbosity</em>, <em>failfast</em>, <em>catchbreak</em>, <em>buffer</em>, <em>warnings</em> 매개변수가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><em>defaultTest</em> 매개변수가 테스트 이름의 이터러블도 받을 수 있게 바뀌었습니다.</p>
</div>
</dd></dl>

<div class="section" id="load-tests-protocol">
<h4>load_tests 프로토콜<a class="headerlink" href="#load-tests-protocol" title="제목 주소">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 라 불리는 함수를 구현함으로써 모듈이나 패키지는 일반 테스트 실행이나 테스트 탐색 중에 그것들로부터 테스트가 어떻게 로드될지를 사용자 정의할 수 있습니다.</p>
<p>만약 테스트 모듈이 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>를 정의했다면 그것은 다음 인자와 함께 <a class="reference internal" href="#unittest.TestLoader.loadTestsFromModule" title="unittest.TestLoader.loadTestsFromModule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.loadTestsFromModule()</span></code></a>의해 호출될 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<p>여기서 <em>pattern</em>은 <code class="docutils literal notranslate"><span class="pre">loadTestsFromModule</span></code>에서 바로 전달된 것입니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다.</p>
<p>이것은 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>를 반환해야 합니다.</p>
<p><em>loader</em>는 로딩을 실행할 <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 인스턴스입니다. <em>standard_tests</em>는 모듈에서 기본적으로 로드될 테스트입니다. 테스트 모듈이 테스트 기본 모음에서 오직 테스트를 추가하거나 빼기를 원하는 것은 흔한 일입니다. 세 번째 인자는 테스트 탐색의 일부로서 패키지를 로드할 때 사용됩니다.</p>
<p>특정 <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 클래스 모음에서 테스트를 로드하는 전형적인 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 함수는 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_cases</span> <span class="o">=</span> <span class="p">(</span><span class="n">TestCase1</span><span class="p">,</span> <span class="n">TestCase2</span><span class="p">,</span> <span class="n">TestCase3</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">TestSuite</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">test_class</span> <span class="ow">in</span> <span class="n">test_cases</span><span class="p">:</span>
        <span class="n">tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">loadTestsFromTestCase</span><span class="p">(</span><span class="n">test_class</span><span class="p">)</span>
        <span class="n">suite</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">suite</span>
</pre></div>
</div>
<p>만약 탐색이 명령행 또는 <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.discover()</span></code></a>로부터, 패키지가 포함된 디렉터리에서 시작된다면, <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>를 위해 패키지 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code>를 검사합니다. 만약 함수가 존재하지 않으면, 탐색은 그저 다른 디렉터리인 것처럼 패키지 안을 재귀 순회할 것입니다. 그렇지 않다면, 패키지의 테스트를 위한 탐색은 다음 인자와 함께 불리는 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>에게 맡겨질 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<p>이것은 패키지의 모든 테스트에 해당하는 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>를 반환해야 합니다. (<code class="docutils literal notranslate"><span class="pre">standard_tests</span></code>는 오직 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code>로부터 수집된 테스트만 포함할 것입니다.</p>
<p>패턴이 load_tests로 전달되기 때문에 패키지는 테스트 검색을 계속 진행(그리고 잠재적으로 수정)할 수 있습니다. 테스트 패키지를 위해서 '아무것도 하지 않는' <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 함수는 다음과 같을 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="c1"># 로더 인스턴스에 캐시 된 최상위 디렉터리</span>
    <span class="n">this_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
    <span class="n">package_tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">discover</span><span class="p">(</span><span class="n">start_dir</span><span class="o">=</span><span class="n">this_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="n">pattern</span><span class="p">)</span>
    <span class="n">standard_tests</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">package_tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">standard_tests</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>패키지 이름이 기본 패턴과 일치하는 것이 불가능하기 때문에 탐색이 더는 <em>pattern</em> 일치를 위해서 패키지 이름을 검사하지 않습니다.</p>
</div>
</div>
</div>
</div>
<div class="section" id="class-and-module-fixtures">
<h2>클래스와 모듈 픽스쳐<a class="headerlink" href="#class-and-module-fixtures" title="제목 주소">¶</a></h2>
<p>클래스와 모듈 단계의 픽스쳐는 <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>에 구현되어 있습니다. 테스트 묶음이 새로운 클래스의 테스트를 만나면(만약 존재한다면) 이전 클래스의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code> 가 호출되고, 이어 새로운 클래스의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code>가 호출됩니다.</p>
<p>마찬가지로 만약 테스트가 이전 테스트와 다른 모듈의 것이라면 이전 모듈의 <code class="docutils literal notranslate"><span class="pre">tearDownModule</span></code>이 실행되고, 이어 새로운 모듈의 <code class="docutils literal notranslate"><span class="pre">setUpModule</span></code>이 호출됩니다.</p>
<p>모든 테스트가 실행된 뒤에 마지막으로 <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code>와 <code class="docutils literal notranslate"><span class="pre">tearDownModule</span></code>이 실행됩니다.</p>
<p>공유하는 픽스쳐의 경우 테스트 병렬화와 같은 [잠재적인] 기능과 잘 동작하지 않고 이것은 테스트 분리를 망가트립니다. 이것을 주의 깊게 사용해야 합니다.</p>
<p>unittest의 테스트 로더에 의해 생성된 테스트들의 기본 정렬 순서는 같은 모듈과 클래스의 모든 테스트를 그룹화하는 것입니다. 이것은 <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> / <code class="docutils literal notranslate"><span class="pre">setUpModule</span></code>(등) 이 클래스와 모듈별로 정확하게 1번씩 호출되게 할 것입니다. 만약 당신이 무작위로 순서를 정하여, 그래서 다른 모듈과 클래스의 테스트가 서로 인접한다면, 이 공유 픽스처 함수는 1번의 테스트 실행에서 여러 번 호출될 수 있습니다.</p>
<p>공유 픽스처는 비표준 정렬 순서를 사용하는 테스트 묶음과 같이 작동하는 것을 의도하지 않습니다. 공유 픽스처를 지원하길 원치 않는 프레임워크를 위해서 <code class="docutils literal notranslate"><span class="pre">BaseTestSuite</span></code>가 여전히 존재합니다.</p>
<p>공유 픽스처 함수 중 1개에서 발생한 예외가 있다면, 테스트를 에러로 보고합니다. 해당 테스트 인스턴스가 없기 때문에 에러를 나타내기 위해 <code class="docutils literal notranslate"><span class="pre">_ErrorHolder</span></code> 객체(<a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>와 같은 인터페이스를 가진)가 생성됩니다. 당신이 그저 표준 unittest의 테스트 실행자를 사용한다면 이 세부 항목은 중요하지 않습니다, 그러나 당신이 프레임워크의 저자라면 이것은 관련이 있을 수 있습니다.</p>
<div class="section" id="setupclass-and-teardownclass">
<h3>setUpClass 와 tearDownClass<a class="headerlink" href="#setupclass-and-teardownclass" title="제목 주소">¶</a></h3>
<p>이것들은 반드시 클래스 메서드로 구현되어야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">createExpensiveConnectionObject</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
</pre></div>
</div>
<p>만약 당신이 베이스 클래스의 <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code>와 <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code>를 호출하고 싶다면 당신이 그것을 직접 호출해야만 합니다. <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>의 구현은 비어있습니다.</p>
<p>만약 <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> 중에 예외가 발생한다면 클래스의 테스트는 실행되지 않고 <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> 는 실행되지 않습니다. 건너뛴 클래스는 <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code>가 실행되지 않을 것입니다. 만약 예외가 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> 예외라면 클래스는 에러 대신 건너뛰어졌다고 보고될 것입니다.</p>
</div>
<div class="section" id="setupmodule-and-teardownmodule">
<h3>setUpModule 과 tearDownModule<a class="headerlink" href="#setupmodule-and-teardownmodule" title="제목 주소">¶</a></h3>
<p>이것들은 함수로 구현되어야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setUpModule</span><span class="p">():</span>
    <span class="n">createConnection</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">tearDownModule</span><span class="p">():</span>
    <span class="n">closeConnection</span><span class="p">()</span>
</pre></div>
</div>
<p>만약 <code class="docutils literal notranslate"><span class="pre">setUpModule</span></code> 중에 예외가 발생한다면 모듈의 테스트는 실행되지 않고 <code class="docutils literal notranslate"><span class="pre">tearDownModule</span></code> 는 실행되지 않습니다. 만약 예외가 <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> 예외라면 모듈은 에러 대신 건너뛰어졌다고 보고될 것입니다.</p>
<p>예외가 발생하는 경우에도 실행해야 하는 정리 코드를 추가하려면, <code class="docutils literal notranslate"><span class="pre">addModuleCleanup</span></code>을 사용하십시오:</p>
<dl class="function">
<dt id="unittest.addModuleCleanup">
<code class="descclassname">unittest.</code><code class="descname">addModuleCleanup</code><span class="sig-paren">(</span><em>function</em>, <em>/</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.addModuleCleanup" title="정의 주소">¶</a></dt>
<dd><p>테스트 클래스 중에 사용된 자원을 정리하기 위해 <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> 이후에 불리는 함수를 추가합니다. 함수들은 추가된 순서의 반대 순서대로 불리게 됩니다(<abbr title="후입 선출법(last-in, first-out)">LIFO</abbr>). 함수가 추가될 때 <a class="reference internal" href="#unittest.addModuleCleanup" title="unittest.addModuleCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addModuleCleanup()</span></code></a>에 같이 전달된 위치 인자나 키워드 인자와 함께 호출됩니다.</p>
<p>만약 <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpModule()</span></code>이 실패한다면, 즉 <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code>이 불리지 않더라도, 정리 함수들은 여전히 불리게 될 것입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="unittest.doModuleCleanups">
<code class="descclassname">unittest.</code><code class="descname">doModuleCleanups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.doModuleCleanups" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> 이후나, <code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code>이 예외를 발생시키면 <code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code>이후에 조건 없이 호출됩니다.</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">addCleanupModule()</span></code>에서 추가된 모든 정리 함수들을 호출하는 책임이 있습니다. 만약 정리 함수를 <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> <em>이전에</em> 불러야 할 필요가 있다면 <a class="reference internal" href="#unittest.doModuleCleanups" title="unittest.doModuleCleanups"><code class="xref py py-func docutils literal notranslate"><span class="pre">doModuleCleanups()</span></code></a>를 직접 부를 수 있습니다.</p>
<p><a class="reference internal" href="#unittest.doModuleCleanups" title="unittest.doModuleCleanups"><code class="xref py py-func docutils literal notranslate"><span class="pre">doModuleCleanups()</span></code></a>는 한 번에 하나씩 정리 함수 스택에서 메서드를 꺼내기 때문에 언제든지 호출될 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="signal-handling">
<h2>시그널 처리하기<a class="headerlink" href="#signal-handling" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<p>unittest의 <a class="reference internal" href="#cmdoption-unittest-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c/--catch</span></code></a> 명령행 옵션은, <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">catchbreak</span></code> 매개 변수와 함께, 테스트 실행 중에 control-C를 사용하기 편하게 처리하도록 합니다. 중단 시그널 잡기를 활성화 하면 control-C는 현재 실행 중인 테스트를 완료하고, 그러면 테스트 실행이 끝나고 이제까지의 모든 결과를 보고할 것입니다. 두 번째 control-c는 평소와 같이 <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>를 발생할 것입니다.</p>
<p>control-c 시그널 처리기는 자체 <code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code> 처리기를 설치하는 코드 또는 테스트와의 호환성을 유지하려고 노력합니다. 만약 <code class="docutils literal notranslate"><span class="pre">unittest</span></code> 처리기가 불리지만 그것이 설치된 <code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code> 처리기가 <em>아니면</em>, 즉 그것이 테스트 중에 시스템에 의해 대체되고 위임된다면, 그것은 기본 처리기를 호출합니다. 이것은 설치된 처리기를 대체하고 위임하는 코드에 의해 일반적으로 기대되는 동작입니다. <code class="docutils literal notranslate"><span class="pre">unittest</span></code> control-c 처리를 개별 테스트 별로 비활성화하고 싶을 때는 <a class="reference internal" href="#unittest.removeHandler" title="unittest.removeHandler"><code class="xref py py-func docutils literal notranslate"><span class="pre">removeHandler()</span></code></a> 데코레이터를 사용할 수 있습니다.</p>
<p>프레임워크 작성자가 테스트 프레임워크에서 control-c 처리 기능을 활성화하기 위해 몇 가지 유틸리티 함수가 있습니다.</p>
<dl class="function">
<dt id="unittest.installHandler">
<code class="descclassname">unittest.</code><code class="descname">installHandler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.installHandler" title="정의 주소">¶</a></dt>
<dd><p>control-c 처리기를 설치합니다. <code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code>를 받았을 때(보통 사용자가 control-c를 눌렀을 때의 응답으로써) 모든 등록된 결과에 <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a>이 호출됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="unittest.registerResult">
<code class="descclassname">unittest.</code><code class="descname">registerResult</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.registerResult" title="정의 주소">¶</a></dt>
<dd><p>control-c 처리를 위해서 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 객체를 등록합니다. 결과 등록은 그것의 약한 참조를 저장합니다, 그래서 결과가 가비지 수거되는 것을 막지 않습니다.</p>
<p>만약 control-c 처리가 활성화되지 않았다면 <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 객체 등록은 부작용이 없습니다, 그래서 테스트 프레임워크는 처리가 가능한지 여부와 관계없이 자신이 만든 모든 결과를 무조건 등록할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="unittest.removeResult">
<code class="descclassname">unittest.</code><code class="descname">removeResult</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.removeResult" title="정의 주소">¶</a></dt>
<dd><p>등록한 결과를 제거합니다. 결과가 제거되고 나면 control-c에 대한 응답으로 결과 객체의 <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a>을 더는 호출하지 않게 됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="unittest.removeHandler">
<code class="descclassname">unittest.</code><code class="descname">removeHandler</code><span class="sig-paren">(</span><em>function=None</em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.removeHandler" title="정의 주소">¶</a></dt>
<dd><p>인자 없이 호출된 경우 이 함수는 만약 control-c 처리기가 설치되었다면 그것을 제거합니다. 또한 이 함수는 테스트 실행 중에 임시로 처리기를 제거하기 위해 테스트 데코레이터로써 사용될 수도 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@unittest</span><span class="o">.</span><span class="n">removeHandler</span>
<span class="k">def</span> <span class="nf">test_signal_handling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> --- 단위 테스트 프레임워크</a><ul>
<li><a class="reference internal" href="#basic-example">기본 예시</a></li>
<li><a class="reference internal" href="#command-line-interface">명령행 인터페이스</a><ul>
<li><a class="reference internal" href="#command-line-options">명령행 옵션</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-discovery">테스트 탐색(Discovery)</a></li>
<li><a class="reference internal" href="#organizing-test-code">테스트 코드 구조 잡기</a></li>
<li><a class="reference internal" href="#re-using-old-test-code">이전의 테스트 코드를 다시 사용하기</a></li>
<li><a class="reference internal" href="#skipping-tests-and-expected-failures">테스트 건너뛰기와 예상된 실패</a></li>
<li><a class="reference internal" href="#distinguishing-test-iterations-using-subtests">부분 테스트(subtest)를 사용하여 테스트 반복 구별 짖기</a></li>
<li><a class="reference internal" href="#classes-and-functions">클래스와 함수</a><ul>
<li><a class="reference internal" href="#test-cases">테스트 케이스</a><ul>
<li><a class="reference internal" href="#deprecated-aliases">폐지된 에일리어스</a></li>
</ul>
</li>
<li><a class="reference internal" href="#grouping-tests">테스트 분류</a></li>
<li><a class="reference internal" href="#loading-and-running-tests">테스트를 로드하고 실행하기</a><ul>
<li><a class="reference internal" href="#load-tests-protocol">load_tests 프로토콜</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#class-and-module-fixtures">클래스와 모듈 픽스쳐</a><ul>
<li><a class="reference internal" href="#setupclass-and-teardownclass">setUpClass 와 tearDownClass</a></li>
<li><a class="reference internal" href="#setupmodule-and-teardownmodule">setUpModule 과 tearDownModule</a></li>
</ul>
</li>
<li><a class="reference internal" href="#signal-handling">시그널 처리하기</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="doctest.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code> --- 대화형 파이썬 예제 테스트</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="unittest.mock.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest.mock</span></code> --- 모의 객체 라이브러리</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="unittest.mock.html" title="unittest.mock --- 모의 객체 라이브러리"
             >다음</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="doctest --- 대화형 파이썬 예제 테스트"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >개발 도구</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>