
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>codecs --- 코덱 레지스트리와 베이스 클래스 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="데이터형" href="datatypes.html" />
    <link rel="prev" title="struct --- 패킹 된 바이너리 데이터로 바이트열을 해석" href="struct.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/codecs.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="datatypes.html" title="데이터형"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="struct.html" title="struct --- 패킹 된 바이너리 데이터로 바이트열을 해석"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="binary.html" accesskey="U">바이너리 데이터 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-codecs">
<span id="codecs-codec-registry-and-base-classes"></span><h1><a class="reference internal" href="#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> --- 코덱 레지스트리와 베이스 클래스<a class="headerlink" href="#module-codecs" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/codecs.py">Lib/codecs.py</a></p>
<hr class="docutils" id="index-0" />
<p>이 모듈은 표준 파이썬 코덱(인코더와 디코더)의 베이스 클래스를 정의하고, 코덱과 에러 처리 조회 프로세스를 관리하는 내부 파이썬 코덱 레지스트리에 대한 액세스를 제공합니다. 대부분의 표준 코덱은 텍스트를 바이트열로 인코딩하는 <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>이지만, 텍스트를 텍스트로 인코딩하고 바이트열을 바이트열로 인코딩하는 코덱도 제공됩니다. 사용자 정의 코덱은 임의 형간에 인코딩과 디코딩 할 수 있지만, 일부 모듈 기능은 <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>이나 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>로 인코딩하는 코덱과 함께 사용하도록 특별히 제한됩니다.</p>
<p>이 모듈은 임의의 코덱으로 인코딩과 디코딩하는 다음 함수를 정의합니다:</p>
<dl class="function">
<dt id="codecs.encode">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">encode</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.encode" title="정의 주소">¶</a></dt>
<dd><p><em>encoding</em>을 위해 등록된 코덱을 사용하여 <em>obj</em>를 인코딩합니다.</p>
<p>원하는 에러 처리 방식을 설정하기 위해 <em>errors</em>가 주어질 수 있습니다. 기본 에러 처리기는 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>이며 인코딩 에러가 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>(또는 <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a>와 같은 더 많은 코덱 관련 서브 클래스)를 발생시킨다는 뜻입니다. 코덱 에러 처리에 대한 자세한 내용은 <a class="reference internal" href="#codec-base-classes"><span class="std std-ref">코덱 베이스 클래스</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.decode">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">decode</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.decode" title="정의 주소">¶</a></dt>
<dd><p><em>encoding</em>을 위해 등록된 코덱을 사용하여 <em>obj</em>를 디코딩합니다.</p>
<p>원하는 에러 처리 방식을 설정하기 위해 <em>errors</em>가 주어질 수 있습니다. 기본 에러 처리기는 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>이며 디코딩 에러가 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> (또는 <a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a>와 같은 더 많은 코덱 관련 서브 클래스)를 발생시킨다는 뜻입니다. 코덱 에러 처리에 대한 자세한 내용은 <a class="reference internal" href="#codec-base-classes"><span class="std std-ref">코덱 베이스 클래스</span></a>를 참조하십시오.</p>
</dd></dl>

<p>각 코덱에 대한 자세한 내용도 직접 확인할 수 있습니다:</p>
<dl class="function">
<dt id="codecs.lookup">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">lookup</code><span class="sig-paren">(</span><em class="sig-param">encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.lookup" title="정의 주소">¶</a></dt>
<dd><p>파이썬 코덱 레지스트리에서 코덱 정보를 조회하고 아래 정의된 <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code></a> 객체를 반환합니다.</p>
<p>인코딩은 먼저 레지스트리 캐시에서 조회됩니다. 찾을 수 없으면, 등록된 검색 함수 리스트를 탐색합니다. <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code></a> 객체가 없으면, <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>가 발생합니다. 그렇지 않으면, <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code></a> 객체가 캐시에 저장되고 호출자에게 반환됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="codecs.CodecInfo">
<em class="property">class </em><code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">CodecInfo</code><span class="sig-paren">(</span><em class="sig-param">encode</em>, <em class="sig-param">decode</em>, <em class="sig-param">streamreader=None</em>, <em class="sig-param">streamwriter=None</em>, <em class="sig-param">incrementalencoder=None</em>, <em class="sig-param">incrementaldecoder=None</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.CodecInfo" title="정의 주소">¶</a></dt>
<dd><p>코덱 레지스트리를 조회할 때의 코덱 세부 정보. 생성자 인자는 같은 이름의 어트리뷰트에 저장됩니다:</p>
<dl class="attribute">
<dt id="codecs.CodecInfo.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#codecs.CodecInfo.name" title="정의 주소">¶</a></dt>
<dd><p>인코딩의 이름.</p>
</dd></dl>

<dl class="attribute">
<dt id="codecs.CodecInfo.encode">
<code class="sig-name descname">encode</code><a class="headerlink" href="#codecs.CodecInfo.encode" title="정의 주소">¶</a></dt>
<dt id="codecs.CodecInfo.decode">
<code class="sig-name descname">decode</code><a class="headerlink" href="#codecs.CodecInfo.decode" title="정의 주소">¶</a></dt>
<dd><p>상태 없는 인코딩과 디코딩 함수. 이들은 코덱 인스턴스의 <a class="reference internal" href="#codecs.Codec.encode" title="codecs.Codec.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a>와 <a class="reference internal" href="#codecs.Codec.decode" title="codecs.Codec.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> 메서드와 같은 인터페이스를 갖는 함수나 메서드여야 합니다 (<a class="reference internal" href="#codec-objects"><span class="std std-ref">코덱 인터페이스</span></a>를 참조하십시오). 함수나 메서드는 상태 없는 모드로 작동할 것으로 기대됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="codecs.CodecInfo.incrementalencoder">
<code class="sig-name descname">incrementalencoder</code><a class="headerlink" href="#codecs.CodecInfo.incrementalencoder" title="정의 주소">¶</a></dt>
<dt id="codecs.CodecInfo.incrementaldecoder">
<code class="sig-name descname">incrementaldecoder</code><a class="headerlink" href="#codecs.CodecInfo.incrementaldecoder" title="정의 주소">¶</a></dt>
<dd><p>증분형 인코더와 디코더 클래스 또는 팩토리 함수. 이들은 각각 베이스 클래스 <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a>와 <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a>가 정의하는 인터페이스를 제공해야합니다. 증분 코덱은 상태를 유지할 수 있습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="codecs.CodecInfo.streamwriter">
<code class="sig-name descname">streamwriter</code><a class="headerlink" href="#codecs.CodecInfo.streamwriter" title="정의 주소">¶</a></dt>
<dt id="codecs.CodecInfo.streamreader">
<code class="sig-name descname">streamreader</code><a class="headerlink" href="#codecs.CodecInfo.streamreader" title="정의 주소">¶</a></dt>
<dd><p>스트림 기록기와 판독기 클래스 또는 팩토리 함수. 이들은 각각 베이스 클래스 <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>와 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>가 정의하는 인터페이스를 제공해야합니다. 스트림 코덱은 상태를 유지할 수 있습니다.</p>
</dd></dl>

</dd></dl>

<p>다양한 코덱 구성 요소에 대한 액세스를 단순화하기 위해, 이 모듈은 코덱 조회에 <a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal notranslate"><span class="pre">lookup()</span></code></a>을 사용하는 다음과 같은 추가 함수를 제공합니다:</p>
<dl class="function">
<dt id="codecs.getencoder">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">getencoder</code><span class="sig-paren">(</span><em class="sig-param">encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getencoder" title="정의 주소">¶</a></dt>
<dd><p>주어진 인코딩에 대한 코덱을 찾아서 해당 인코더 함수를 반환합니다.</p>
<p>인코딩을 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getdecoder">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">getdecoder</code><span class="sig-paren">(</span><em class="sig-param">encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getdecoder" title="정의 주소">¶</a></dt>
<dd><p>주어진 인코딩에 대한 코덱을 찾아서 해당 디코더 함수를 반환합니다.</p>
<p>인코딩을 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getincrementalencoder">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">getincrementalencoder</code><span class="sig-paren">(</span><em class="sig-param">encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getincrementalencoder" title="정의 주소">¶</a></dt>
<dd><p>주어진 인코딩에 대한 코덱을 찾아서 증분 인코더 클래스나 팩토리 함수를 반환합니다.</p>
<p>인코딩을 찾을 수 없거나 코덱이 증분 인코더를 지원하지 않는 경우 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getincrementaldecoder">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">getincrementaldecoder</code><span class="sig-paren">(</span><em class="sig-param">encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getincrementaldecoder" title="정의 주소">¶</a></dt>
<dd><p>주어진 인코딩에 대한 코덱을 찾아서 증분 디코더 클래스나 팩토리 함수를 반환합니다.</p>
<p>인코딩을 찾을 수 없거나 코덱이 증분 디코더를 지원하지 않는 경우 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getreader">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">getreader</code><span class="sig-paren">(</span><em class="sig-param">encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getreader" title="정의 주소">¶</a></dt>
<dd><p>주어진 인코딩의 코덱을 찾아서 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> 클래스나 팩토리 함수를 반환합니다.</p>
<p>인코딩을 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getwriter">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">getwriter</code><span class="sig-paren">(</span><em class="sig-param">encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getwriter" title="정의 주소">¶</a></dt>
<dd><p>주어진 인코딩의 코덱을 찾아서 <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> 클래스나 팩토리 함수를 반환합니다.</p>
<p>인코딩을 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<p>적합한 코덱 검색 함수를 등록하여 사용자 정의 코덱을 사용할 수 있도록 합니다:</p>
<dl class="function">
<dt id="codecs.register">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">register</code><span class="sig-paren">(</span><em class="sig-param">search_function</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.register" title="정의 주소">¶</a></dt>
<dd><p>코덱 검색 함수를 등록합니다. 검색 함수는 모두 소문자로 이루어진 인코딩 이름인 하나의 인자를 취하고, <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code></a> 객체를 반환해야합니다. 검색 함수가 주어진 인코딩을 찾지 못하면, <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환해야합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>검색 함수 등록은 현재 되돌릴 수 없어서, 단위 테스트나 모듈 다시 로드하기와 같은 몇몇 경우에 문제을 일으킬 수 있습니다.</p>
</div>
</dd></dl>

<p>내장 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>과 관련 <a class="reference internal" href="io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 모듈은 인코딩 된 텍스트 파일 작업에 권장되는 접근 방법이지만, 이 모듈은 바이너리 파일로 작업할 때 더 넓은 범위의 코덱을 사용할 수 있도록 하는 추가 유틸리티 함수와 클래스를 제공합니다:</p>
<dl class="function">
<dt id="codecs.open">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">mode='r'</em>, <em class="sig-param">encoding=None</em>, <em class="sig-param">errors='strict'</em>, <em class="sig-param">buffering=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.open" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>mode</em>를 사용하여 인코딩 된 파일을 열고 투명한 인코딩/디코딩을 제공하는 <a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a>의 인스턴스를 반환합니다. 기본 파일 모드는 <code class="docutils literal notranslate"><span class="pre">'r'</span></code>이고, 파일을 읽기 모드로 연다는 뜻입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>하부 인코딩 된 파일은 항상 바이너리 모드로 열립니다. 읽기와 쓰기 시 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>의 자동 변환이 수행되지 않습니다. <em>mode</em> 인자는 내장 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 함수에 허용되는 모든 바이너리 모드일 수 있습니다; <code class="docutils literal notranslate"><span class="pre">'b'</span></code>가 자동으로 추가됩니다.</p>
</div>
<p><em>encoding</em>은 파일에 사용될 인코딩을 지정합니다. 바이트열에서 인코딩하고 바이트열로 디코딩하는 모든 인코딩이 허용되며, 파일 메서드가 지원하는 데이터 형은 사용된 코덱에 따라 다릅니다.</p>
<p>에러 처리를 정의하기 위해 <em>errors</em>가 제공될 수 있습니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>이고 인코딩 에러가 발생하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p><em>buffering</em>은 내장 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 함수에서와 같은 의미입니다. 기본값은 -1이며 기본 버퍼 크기가 사용됨을 의미합니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.EncodedFile">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">EncodedFile</code><span class="sig-paren">(</span><em class="sig-param">file</em>, <em class="sig-param">data_encoding</em>, <em class="sig-param">file_encoding=None</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.EncodedFile" title="정의 주소">¶</a></dt>
<dd><p>투명한 트랜스코딩을 제공하는 <em>file</em>의 래핑 된 버전인 <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a> 인스턴스를 반환합니다. 랩핑 된 버전이 닫힐 때 원본 파일이 닫힙니다.</p>
<p>랩핑 된 파일에 기록된 데이터는 주어진 <em>data_encoding</em>에 따라 디코딩 된 다음 <em>file_encoding</em>을 사용하여 바이트열로 원본 파일에 기록됩니다. 원본 파일에서 읽은 바이트열은 <em>file_encoding</em>에 따라 디코딩되며, 결과는 <em>data_encoding</em>을 사용하여 인코딩됩니다.</p>
<p><em>file_encoding</em>이 제공되지 않으면, 기본값은 <em>data_encoding</em>입니다.</p>
<p>에러 처리를 정의하기 위해 <em>errors</em>가 제공될 수 있습니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>이며, 인코딩 에러가 발생하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.iterencode">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">iterencode</code><span class="sig-paren">(</span><em class="sig-param">iterator</em>, <em class="sig-param">encoding</em>, <em class="sig-param">errors='strict'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.iterencode" title="정의 주소">¶</a></dt>
<dd><p>증분 인코더를 사용하여 <em>iterator</em>에서 제공하는 입력을 반복적으로 인코딩합니다. 이 함수는 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a>입니다. <em>errors</em> 인자(다른 키워드 인자 뿐만 아니라)는 증분 인코더로 전달됩니다.</p>
<p>이 함수를 사용하려면 코덱에서 인코딩 할 텍스트 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체를 허용해야 합니다. 따라서 <code class="docutils literal notranslate"><span class="pre">base64_codec</span></code>과 같은 바이트열-바이트열 인코더는 지원하지 않습니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.iterdecode">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">iterdecode</code><span class="sig-paren">(</span><em class="sig-param">iterator</em>, <em class="sig-param">encoding</em>, <em class="sig-param">errors='strict'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.iterdecode" title="정의 주소">¶</a></dt>
<dd><p>증분 디코더를 사용하여 <em>iterator</em>에서 제공하는 입력을 반복적으로 디코딩합니다. 이 함수는 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a>입니다. <em>errors</em> 인자(다른 키워드 인자 뿐만 아니라)는 증분 디코더로 전달됩니다.</p>
<p>이 함수를 사용하려면 코덱에서 디코딩 할 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체를 허용해야 합니다. 따라서 <code class="docutils literal notranslate"><span class="pre">rot_13</span></code>이 <a class="reference internal" href="#codecs.iterencode" title="codecs.iterencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">iterencode()</span></code></a>로 동등하게 사용될 수 있지만, <code class="docutils literal notranslate"><span class="pre">rot_13</span></code>과 같은 텍스트-텍스트 인코더는 지원하지 않습니다.</p>
</dd></dl>

<p>이 모듈은 또한 플랫폼 종속 파일을 읽고 쓰는 데 유용한 다음 상수를 제공합니다:</p>
<dl class="data">
<dt id="codecs.BOM">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM</code><a class="headerlink" href="#codecs.BOM" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_BE">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_BE</code><a class="headerlink" href="#codecs.BOM_BE" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_LE">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_LE</code><a class="headerlink" href="#codecs.BOM_LE" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_UTF8">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_UTF8</code><a class="headerlink" href="#codecs.BOM_UTF8" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_UTF16">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_UTF16</code><a class="headerlink" href="#codecs.BOM_UTF16" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_UTF16_BE">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_UTF16_BE</code><a class="headerlink" href="#codecs.BOM_UTF16_BE" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_UTF16_LE">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_UTF16_LE</code><a class="headerlink" href="#codecs.BOM_UTF16_LE" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_UTF32">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_UTF32</code><a class="headerlink" href="#codecs.BOM_UTF32" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_UTF32_BE">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_UTF32_BE</code><a class="headerlink" href="#codecs.BOM_UTF32_BE" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_UTF32_LE">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_UTF32_LE</code><a class="headerlink" href="#codecs.BOM_UTF32_LE" title="정의 주소">¶</a></dt>
<dd><p>이 상수는 여러 인코딩에서 유니코드 바이트 순서 표시(BOM)인 다양한 바이트 시퀀스를 정의합니다. UTF-16과 UTF-32 데이터 스트림에서 사용된 바이트 순서를 나타내는데 사용되며, UTF-8에서 유니코드 서명으로 사용됩니다. <a class="reference internal" href="#codecs.BOM_UTF16" title="codecs.BOM_UTF16"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16</span></code></a>은 플랫폼의 네이티브 바이트 순서에 따라 <a class="reference internal" href="#codecs.BOM_UTF16_BE" title="codecs.BOM_UTF16_BE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_BE</span></code></a>나 <a class="reference internal" href="#codecs.BOM_UTF16_LE" title="codecs.BOM_UTF16_LE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_LE</span></code></a>이며, <a class="reference internal" href="#codecs.BOM" title="codecs.BOM"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM</span></code></a>은 <a class="reference internal" href="#codecs.BOM_UTF16" title="codecs.BOM_UTF16"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16</span></code></a>의 별칭, <a class="reference internal" href="#codecs.BOM_LE" title="codecs.BOM_LE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_LE</span></code></a>는 <a class="reference internal" href="#codecs.BOM_UTF16_LE" title="codecs.BOM_UTF16_LE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_LE</span></code></a>의 별칭, <a class="reference internal" href="#codecs.BOM_BE" title="codecs.BOM_BE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_BE</span></code></a>는 <a class="reference internal" href="#codecs.BOM_UTF16_BE" title="codecs.BOM_UTF16_BE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_BE</span></code></a>의 별칭입니다. 다른 것은 UTF-8과 UTF-32 인코딩에서 BOM을 나타냅니다.</p>
</dd></dl>

<div class="section" id="codec-base-classes">
<span id="id1"></span><h2>코덱 베이스 클래스<a class="headerlink" href="#codec-base-classes" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> 모듈은 코덱 객체로 작업하기 위한 인터페이스를 정의하는 베이스 클래스 집합을 정의하며, 사용자 정의 코덱 구현의 기초로 사용될 수도 있습니다.</p>
<p>각 코덱은 파이썬에서 코덱으로 사용할 수 있도록 네 가지 인터페이스를 정의해야합니다: 상태없는 인코더, 상태 없는 디코더, 스트림 판독기 및 스트림 기록기. 스트림 판독기와 기록기는 일반적으로 상태 없는 인코더/디코더를 재사용하여 파일 프로토콜을 구현합니다. 코덱 작성자는 코덱에서 인코딩과 디코딩 에러를 처리하는 방법도 정의해야합니다.</p>
<div class="section" id="error-handlers">
<span id="surrogateescape"></span><span id="id2"></span><h3>에러 처리기<a class="headerlink" href="#error-handlers" title="제목 주소">¶</a></h3>
<p>에러 처리를 단순화하고 표준화하기 위해, 코덱은 <em>errors</em> 문자열 인자를 받아들여 다른 에러 처리 체계를 구현할 수 있습니다. 다음 문자열 값은 모든 표준 파이썬 코덱에서 정의되고 구현됩니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>값</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'strict'</span></code></p></td>
<td><p><a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>(또는 서브 클래스)를 발생시킵니다; 이것이 기본값입니다. <a class="reference internal" href="#codecs.strict_errors" title="codecs.strict_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">strict_errors()</span></code></a>에서 구현되었습니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code></p></td>
<td><p>잘못된 데이터를 무시하고 추가 통지없이 계속 진행합니다. <a class="reference internal" href="#codecs.ignore_errors" title="codecs.ignore_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">ignore_errors()</span></code></a>에서 구현되었습니다.</p></td>
</tr>
</tbody>
</table>
<p>다음 에러 처리기는 <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>에만 적용됩니다:</p>
<table class="docutils align-default" id="index-1">
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>값</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'replace'</span></code></p></td>
<td><p>적절한 교체 마커로 교체합니다; 파이썬은 내장 코덱에 디코딩시 공식 <code class="docutils literal notranslate"><span class="pre">U+FFFD</span></code> REPLACEMENT CHARACTER를, 인코딩시 '?'를 사용합니다. <a class="reference internal" href="#codecs.replace_errors" title="codecs.replace_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">replace_errors()</span></code></a>에서 구현되었습니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code></p></td>
<td><p>적절한 XML 문자 참조로 교체합니다 (인코딩에만 해당합니다). <a class="reference internal" href="#codecs.xmlcharrefreplace_errors" title="codecs.xmlcharrefreplace_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">xmlcharrefreplace_errors()</span></code></a>에서 구현되었습니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code></p></td>
<td><p>역 슬래시 이스케이프 시퀀스로 교체합니다. <a class="reference internal" href="#codecs.backslashreplace_errors" title="codecs.backslashreplace_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">backslashreplace_errors()</span></code></a>에서 구현되었습니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\N{...}</span></code> 이스케이프 시퀀스로 교체합니다 (인코딩에만 해당합니다). <a class="reference internal" href="#codecs.namereplace_errors" title="codecs.namereplace_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">namereplace_errors()</span></code></a>에서 구현되었습니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code></p></td>
<td><p>디코딩시, 바이트를 <code class="docutils literal notranslate"><span class="pre">U+DC80</span></code>에서 <code class="docutils literal notranslate"><span class="pre">U+DCFF</span></code> 범위의 개별 서로게이트 코드(surrogate code)로 바꿉니다. 이 코드는 데이터를 인코딩 할 때 <code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code> 에러 처리기가 사용되면 같은 바이트로 다시 변환됩니다. (자세한 내용은 <span class="target" id="index-12"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a>을 참조하십시오.)</p></td>
</tr>
</tbody>
</table>
<p>또한, 다음 에러 처리기는 지정된 코덱에만 적용됩니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 28%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>값</p></th>
<th class="head"><p>코덱</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'surrogatepass'</span></code></p></td>
<td><p>utf-8, utf-16, utf-32,
utf-16-be, utf-16-le,
utf-32-be, utf-32-le</p></td>
<td><p>서로게이트 코드의 인코딩과 디코딩을 허용합니다. 이 코덱들은 일반적으로 서로게이트의 존재를 에러로 취급합니다.</p></td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가: </span><code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code>와 <code class="docutils literal notranslate"><span class="pre">'surrogatepass'</span></code> 에러 처리기.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'surrogatepass'</span></code> 에러 처리기는 이제 utf-16* 와 utf-32* 코덱에서 작동합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가: </span><code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code> 에러 처리기.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> 에러 처리기는 이제 디코딩과 변환(translating)에서 작동합니다.</p>
</div>
<p>새 이름으로 에러 처리기를 등록하여 허용되는 값 집합을 확장할 수 있습니다:</p>
<dl class="function">
<dt id="codecs.register_error">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">register_error</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">error_handler</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.register_error" title="정의 주소">¶</a></dt>
<dd><p>에러 처리 함수 <em>error_handler</em>를 <em>name</em>이라는 이름으로 등록합니다. <em>error_handler</em> 인자는 <em>name</em>이 errors 매개 변수로 지정될 때, 인코딩과 디코딩 중에 에러가 있으면 호출됩니다.</p>
<p>인코딩의 경우, 에러 위치에 대한 정보가 포함된 <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a> 인스턴스와 함께 <em>error_handler</em>가 호출됩니다. 에러 처리기는 이 예외나 다른 예외를 발생 시키거나, 입력의 인코딩할 수 없는 부분의 대체값과 인코딩을 계속할 위치를 담은 튜플을 반환해야합니다. 대체값은 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>이나 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>일 수 있습니다. 대체값이 바이트열이면, 인코더는 이를 단순히 출력 버퍼에 복사합니다. 대체값이 문자열이면, 인코더는 대체값을 인코딩합니다. 지정된 위치에서 원래 입력으로 인코딩이 계속됩니다. 음수 위치 값은 입력 문자열의 끝을 기준으로 처리됩니다. 결과 위치가 범위를 벗어나면 <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>가 발생합니다.</p>
<p><a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a>나 <a class="reference internal" href="exceptions.html#UnicodeTranslateError" title="UnicodeTranslateError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeTranslateError</span></code></a>가 처리기로 전달되고 에러 처리기의 대체값을 출력에 직접 넣는다는 점을 제외하면, 디코딩과 변환(translating)은 비슷하게 작동합니다.</p>
</dd></dl>

<p>이전에 등록된 에러 처리기(표준 에러 처리기를 포함하여)는 이름으로 조회할 수 있습니다:</p>
<dl class="function">
<dt id="codecs.lookup_error">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">lookup_error</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.lookup_error" title="정의 주소">¶</a></dt>
<dd><p><em>name</em>이라는 이름으로 이전에 등록된 에러 처리기를 반환합니다.</p>
<p>처리기를 찾을 수 없으면 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<p>다음과 같은 표준 에러 처리기가 모듈 수준 함수로 제공됩니다:</p>
<dl class="function">
<dt id="codecs.strict_errors">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">strict_errors</code><span class="sig-paren">(</span><em class="sig-param">exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.strict_errors" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'strict'</span></code> 에러 처리를 구현합니다: 각 인코딩이나 디코딩 에러는 <a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.replace_errors">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">replace_errors</code><span class="sig-paren">(</span><em class="sig-param">exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.replace_errors" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'replace'</span></code> 에러 처리를 구현합니다 (<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a> 전용): 인코딩 에러를 <code class="docutils literal notranslate"><span class="pre">'?'</span></code>로 대체하고 (코덱으로 인코딩 됩니다), 디코딩 에러를 <code class="docutils literal notranslate"><span class="pre">'\ufffd'</span></code>(유니코드 대체 문자)로 대체합니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.ignore_errors">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">ignore_errors</code><span class="sig-paren">(</span><em class="sig-param">exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.ignore_errors" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> 에러 처리를 구현합니다: 잘못된 형식의 데이터는 무시되고 추가 통지없이 인코딩이나 디코딩이 계속됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.xmlcharrefreplace_errors">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">xmlcharrefreplace_errors</code><span class="sig-paren">(</span><em class="sig-param">exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.xmlcharrefreplace_errors" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code> 에러 처리를 구현합니다 (<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>으로 인코딩하는 경우에만 해당): 인코드할 수 없는 문자는 적절한 XML 문자 참조로 대체됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.backslashreplace_errors">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">backslashreplace_errors</code><span class="sig-paren">(</span><em class="sig-param">exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.backslashreplace_errors" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> 에러 처리를 구현합니다 (<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a> 전용): 잘못된 형식의 데이터는 역 슬래시 이스케이프 시퀀스로 대체됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.namereplace_errors">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">namereplace_errors</code><span class="sig-paren">(</span><em class="sig-param">exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.namereplace_errors" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code> 에러 처리를 구현합니다 (<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>으로 인코딩하는 경우에만 해당): 인토드할 수 없는 문자는 <code class="docutils literal notranslate"><span class="pre">\N{...}</span></code> 이스케이프 시퀀스로 대체됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="stateless-encoding-and-decoding">
<span id="codec-objects"></span><h3>상태 없는 인코딩과 디코딩<a class="headerlink" href="#stateless-encoding-and-decoding" title="제목 주소">¶</a></h3>
<p>기본 <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> 클래스는 다음과 같은 메서드들 정의하는데, 상태 없는 인코더와 디코더의 함수 인터페이스를 정의하기도 합니다:</p>
<dl class="method">
<dt id="codecs.Codec.encode">
<code class="sig-prename descclassname">Codec.</code><code class="sig-name descname">encode</code><span class="sig-paren">(</span><em class="sig-param">input</em><span class="optional">[</span>, <em class="sig-param">errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.Codec.encode" title="정의 주소">¶</a></dt>
<dd><p>객체 <em>input</em>을 인코딩하고 튜플(출력 객체, 소비한 길이)을 반환합니다. 예를 들어, <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>은 특정 문자 집합 인코딩 (예를 들어, <code class="docutils literal notranslate"><span class="pre">cp1252</span></code>나 <code class="docutils literal notranslate"><span class="pre">iso-8859-1</span></code>)을 사용하여 문자열 객체를 바이트열 객체로 변환합니다.</p>
<p><em>errors</em> 인자는 적용할 에러 처리를 정의합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code> 처리입니다.</p>
<p>이 메서드는 <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> 인스턴스에 상태를 저장하지 않을 수 있습니다. 인코딩 효율을 높이기 위해 상태를 유지해야하는 코덱에서는 <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>를 사용하십시오.</p>
<p>인코더는 길이가 0인 입력을 처리하고 이 상황에서는 출력 객체 형의 빈 객체를 반환할 수 있어야합니다.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.Codec.decode">
<code class="sig-prename descclassname">Codec.</code><code class="sig-name descname">decode</code><span class="sig-paren">(</span><em class="sig-param">input</em><span class="optional">[</span>, <em class="sig-param">errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.Codec.decode" title="정의 주소">¶</a></dt>
<dd><p>객체 <em>input</em>을 디코딩하고 튜플 (출력 객체, 소비한 길이)을 반환합니다. 예를 들어, <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>의 경우, 디코딩은 특정 문자 집합 인코딩을 사용하여 인코딩 된 바이트열 객체를 문자열 객체로 변환합니다.</p>
<p>텍스트 인코딩과 바이트열-바이트열 코덱의 경우, <em>input</em>은 바이트열 객체이거나 읽기 전용 버퍼 인터페이스를 제공하는 객체여야 합니다 -- 예를 들어, 버퍼 객체와 및 메모리 맵핑 파일.</p>
<p><em>errors</em> 인자는 적용할 에러 처리를 정의합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code> 처리입니다.</p>
<p>이 메서드는 <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> 인스턴스에 상태를 저장하지 않을 수 있습니다. 디코딩 효율을 높이기 위해 상태를 유지해야하는 코덱에서는 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>를 사용하십시오.</p>
<p>디코더는 길이가 0인 입력을 처리하고 이 상황에서 출력 객체 형의 빈 객체를 반환할 수 있어야합니다.</p>
</dd></dl>

</div>
<div class="section" id="incremental-encoding-and-decoding">
<h3>증분 인코딩과 디코딩<a class="headerlink" href="#incremental-encoding-and-decoding" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a>와 <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> 클래스는 증분 인코딩과 디코딩을 위한 기본 인터페이스를 제공합니다. 입력을 인코딩/디코딩하는 것이 상태 없는 인코더/디코더 함수를 한 번 호출하는 것이 아니라, 증분 인코더/디코더의 <a class="reference internal" href="#codecs.IncrementalEncoder.encode" title="codecs.IncrementalEncoder.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a>/<a class="reference internal" href="#codecs.IncrementalDecoder.decode" title="codecs.IncrementalDecoder.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> 메서드를 여러 번 호출하여 수행됩니다. 증분 인코더/디코더는 메서드 호출 중에 인코딩/디코딩 프로세스를 추적합니다.</p>
<p><a class="reference internal" href="#codecs.IncrementalEncoder.encode" title="codecs.IncrementalEncoder.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a>/<a class="reference internal" href="#codecs.IncrementalDecoder.decode" title="codecs.IncrementalDecoder.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> 메서드에 대한 호출의 연결된 출력은 모든 단일 입력이 하나로 결합되어 상태 없는 인코더/디코더로 인코딩/디코딩되는 것과 같습니다.</p>
<div class="section" id="incrementalencoder-objects">
<span id="incremental-encoder-objects"></span><h4>IncrementalEncoder Objects<a class="headerlink" href="#incrementalencoder-objects" title="제목 주소">¶</a></h4>
<p>The <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> class is used for encoding an input in multiple
steps. It defines the following methods which every incremental encoder must
define in order to be compatible with the Python codec registry.</p>
<dl class="class">
<dt id="codecs.IncrementalEncoder">
<em class="property">class </em><code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">IncrementalEncoder</code><span class="sig-paren">(</span><em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder" title="정의 주소">¶</a></dt>
<dd><p>Constructor for an <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> instance.</p>
<p>All incremental encoders must provide this constructor interface. They are free
to add additional keyword arguments, but only the ones defined here are used by
the Python codec registry.</p>
<p>The <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> may implement different error handling schemes
by providing the <em>errors</em> keyword argument. See <a class="reference internal" href="#error-handlers"><span class="std std-ref">에러 처리기</span></a> for
possible values.</p>
<p>The <em>errors</em> argument will be assigned to an attribute of the same name.
Assigning to this attribute makes it possible to switch between different error
handling strategies during the lifetime of the <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a>
object.</p>
<dl class="method">
<dt id="codecs.IncrementalEncoder.encode">
<code class="sig-name descname">encode</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="optional">[</span>, <em class="sig-param">final</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.encode" title="정의 주소">¶</a></dt>
<dd><p>Encodes <em>object</em> (taking the current state of the encoder into account)
and returns the resulting encoded object. If this is the last call to
<a class="reference internal" href="#codecs.encode" title="codecs.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a> <em>final</em> must be true (the default is false).</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalEncoder.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.reset" title="정의 주소">¶</a></dt>
<dd><p>Reset the encoder to the initial state. The output is discarded: call
<code class="docutils literal notranslate"><span class="pre">.encode(object,</span> <span class="pre">final=True)</span></code>, passing an empty byte or text string
if necessary, to reset the encoder and to get the output.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalEncoder.getstate">
<code class="sig-name descname">getstate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.getstate" title="정의 주소">¶</a></dt>
<dd><p>Return the current state of the encoder which must be an integer. The
implementation should make sure that <code class="docutils literal notranslate"><span class="pre">0</span></code> is the most common
state. (States that are more complicated than integers can be converted
into an integer by marshaling/pickling the state and encoding the bytes
of the resulting string into an integer.)</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalEncoder.setstate">
<code class="sig-name descname">setstate</code><span class="sig-paren">(</span><em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.setstate" title="정의 주소">¶</a></dt>
<dd><p>Set the state of the encoder to <em>state</em>. <em>state</em> must be an encoder state
returned by <a class="reference internal" href="#codecs.IncrementalEncoder.getstate" title="codecs.IncrementalEncoder.getstate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getstate()</span></code></a>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="incrementaldecoder-objects">
<span id="incremental-decoder-objects"></span><h4>IncrementalDecoder Objects<a class="headerlink" href="#incrementaldecoder-objects" title="제목 주소">¶</a></h4>
<p>The <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> class is used for decoding an input in multiple
steps. It defines the following methods which every incremental decoder must
define in order to be compatible with the Python codec registry.</p>
<dl class="class">
<dt id="codecs.IncrementalDecoder">
<em class="property">class </em><code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">IncrementalDecoder</code><span class="sig-paren">(</span><em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder" title="정의 주소">¶</a></dt>
<dd><p>Constructor for an <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> instance.</p>
<p>All incremental decoders must provide this constructor interface. They are free
to add additional keyword arguments, but only the ones defined here are used by
the Python codec registry.</p>
<p>The <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> may implement different error handling schemes
by providing the <em>errors</em> keyword argument. See <a class="reference internal" href="#error-handlers"><span class="std std-ref">에러 처리기</span></a> for
possible values.</p>
<p>The <em>errors</em> argument will be assigned to an attribute of the same name.
Assigning to this attribute makes it possible to switch between different error
handling strategies during the lifetime of the <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a>
object.</p>
<dl class="method">
<dt id="codecs.IncrementalDecoder.decode">
<code class="sig-name descname">decode</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="optional">[</span>, <em class="sig-param">final</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.decode" title="정의 주소">¶</a></dt>
<dd><p>Decodes <em>object</em> (taking the current state of the decoder into account)
and returns the resulting decoded object. If this is the last call to
<a class="reference internal" href="#codecs.decode" title="codecs.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> <em>final</em> must be true (the default is false). If <em>final</em> is
true the decoder must decode the input completely and must flush all
buffers. If this isn't possible (e.g. because of incomplete byte sequences
at the end of the input) it must initiate error handling just like in the
stateless case (which might raise an exception).</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalDecoder.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.reset" title="정의 주소">¶</a></dt>
<dd><p>Reset the decoder to the initial state.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalDecoder.getstate">
<code class="sig-name descname">getstate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.getstate" title="정의 주소">¶</a></dt>
<dd><p>Return the current state of the decoder. This must be a tuple with two
items, the first must be the buffer containing the still undecoded
input. The second must be an integer and can be additional state
info. (The implementation should make sure that <code class="docutils literal notranslate"><span class="pre">0</span></code> is the most common
additional state info.) If this additional state info is <code class="docutils literal notranslate"><span class="pre">0</span></code> it must be
possible to set the decoder to the state which has no input buffered and
<code class="docutils literal notranslate"><span class="pre">0</span></code> as the additional state info, so that feeding the previously
buffered input to the decoder returns it to the previous state without
producing any output. (Additional state info that is more complicated than
integers can be converted into an integer by marshaling/pickling the info
and encoding the bytes of the resulting string into an integer.)</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalDecoder.setstate">
<code class="sig-name descname">setstate</code><span class="sig-paren">(</span><em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.setstate" title="정의 주소">¶</a></dt>
<dd><p>Set the state of the decoder to <em>state</em>. <em>state</em> must be a decoder state
returned by <a class="reference internal" href="#codecs.IncrementalDecoder.getstate" title="codecs.IncrementalDecoder.getstate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getstate()</span></code></a>.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="stream-encoding-and-decoding">
<h3>Stream Encoding and Decoding<a class="headerlink" href="#stream-encoding-and-decoding" title="제목 주소">¶</a></h3>
<p>The <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> and <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> classes provide generic
working interfaces which can be used to implement new encoding submodules very
easily. See <code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.utf_8</span></code> for an example of how this is done.</p>
<div class="section" id="streamwriter-objects">
<span id="stream-writer-objects"></span><h4>StreamWriter Objects<a class="headerlink" href="#streamwriter-objects" title="제목 주소">¶</a></h4>
<p>The <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> class is a subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> and defines the
following methods which every stream writer must define in order to be
compatible with the Python codec registry.</p>
<dl class="class">
<dt id="codecs.StreamWriter">
<em class="property">class </em><code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">StreamWriter</code><span class="sig-paren">(</span><em class="sig-param">stream</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter" title="정의 주소">¶</a></dt>
<dd><p>Constructor for a <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> instance.</p>
<p>All stream writers must provide this constructor interface. They are free to add
additional keyword arguments, but only the ones defined here are used by the
Python codec registry.</p>
<p>The <em>stream</em> argument must be a file-like object open for writing
text or binary data, as appropriate for the specific codec.</p>
<p>The <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> may implement different error handling schemes by
providing the <em>errors</em> keyword argument. See <a class="reference internal" href="#error-handlers"><span class="std std-ref">에러 처리기</span></a> for
the standard error handlers the underlying stream codec may support.</p>
<p>The <em>errors</em> argument will be assigned to an attribute of the same name.
Assigning to this attribute makes it possible to switch between different error
handling strategies during the lifetime of the <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> object.</p>
<dl class="method">
<dt id="codecs.StreamWriter.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.write" title="정의 주소">¶</a></dt>
<dd><p>Writes the object's contents encoded to the stream.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamWriter.writelines">
<code class="sig-name descname">writelines</code><span class="sig-paren">(</span><em class="sig-param">list</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.writelines" title="정의 주소">¶</a></dt>
<dd><p>Writes the concatenated list of strings to the stream (possibly by reusing
the <a class="reference internal" href="#codecs.StreamWriter.write" title="codecs.StreamWriter.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> method). The standard bytes-to-bytes codecs
do not support this method.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamWriter.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.reset" title="정의 주소">¶</a></dt>
<dd><p>Flushes and resets the codec buffers used for keeping state.</p>
<p>Calling this method should ensure that the data on the output is put into
a clean state that allows appending of new fresh data without having to
rescan the whole stream to recover state.</p>
</dd></dl>

</dd></dl>

<p>In addition to the above methods, the <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> must also inherit
all other methods and attributes from the underlying stream.</p>
</div>
<div class="section" id="streamreader-objects">
<span id="stream-reader-objects"></span><h4>StreamReader Objects<a class="headerlink" href="#streamreader-objects" title="제목 주소">¶</a></h4>
<p>The <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> class is a subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> and defines the
following methods which every stream reader must define in order to be
compatible with the Python codec registry.</p>
<dl class="class">
<dt id="codecs.StreamReader">
<em class="property">class </em><code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">StreamReader</code><span class="sig-paren">(</span><em class="sig-param">stream</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader" title="정의 주소">¶</a></dt>
<dd><p>Constructor for a <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> instance.</p>
<p>All stream readers must provide this constructor interface. They are free to add
additional keyword arguments, but only the ones defined here are used by the
Python codec registry.</p>
<p>The <em>stream</em> argument must be a file-like object open for reading
text or binary data, as appropriate for the specific codec.</p>
<p>The <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> may implement different error handling schemes by
providing the <em>errors</em> keyword argument. See <a class="reference internal" href="#error-handlers"><span class="std std-ref">에러 처리기</span></a> for
the standard error handlers the underlying stream codec may support.</p>
<p>The <em>errors</em> argument will be assigned to an attribute of the same name.
Assigning to this attribute makes it possible to switch between different error
handling strategies during the lifetime of the <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> object.</p>
<p>The set of allowed values for the <em>errors</em> argument can be extended with
<a class="reference internal" href="#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_error()</span></code></a>.</p>
<dl class="method">
<dt id="codecs.StreamReader.read">
<code class="sig-name descname">read</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">size</em><span class="optional">[</span>, <em class="sig-param">chars</em><span class="optional">[</span>, <em class="sig-param">firstline</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.read" title="정의 주소">¶</a></dt>
<dd><p>Decodes data from the stream and returns the resulting object.</p>
<p>The <em>chars</em> argument indicates the number of decoded
code points or bytes to return. The <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-func docutils literal notranslate"><span class="pre">read()</span></code></a> method will
never return more data than requested, but it might return less,
if there is not enough available.</p>
<p>The <em>size</em> argument indicates the approximate maximum
number of encoded bytes or code points to read
for decoding. The decoder can modify this setting as
appropriate. The default value -1 indicates to read and decode as much as
possible. This parameter is intended to
prevent having to decode huge files in one step.</p>
<p>The <em>firstline</em> flag indicates that
it would be sufficient to only return the first
line, if there are decoding errors on later lines.</p>
<p>The method should use a greedy read strategy meaning that it should read
as much data as is allowed within the definition of the encoding and the
given size, e.g.  if optional encoding endings or state markers are
available on the stream, these should be read too.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamReader.readline">
<code class="sig-name descname">readline</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">size</em><span class="optional">[</span>, <em class="sig-param">keepends</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.readline" title="정의 주소">¶</a></dt>
<dd><p>Read one line from the input stream and return the decoded data.</p>
<p><em>size</em>, if given, is passed as size argument to the stream's
<a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> method.</p>
<p>If <em>keepends</em> is false line-endings will be stripped from the lines
returned.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamReader.readlines">
<code class="sig-name descname">readlines</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">sizehint</em><span class="optional">[</span>, <em class="sig-param">keepends</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.readlines" title="정의 주소">¶</a></dt>
<dd><p>Read all lines available on the input stream and return them as a list of
lines.</p>
<p>Line-endings are implemented using the codec's <a class="reference internal" href="#codecs.decode" title="codecs.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> method and
are included in the list entries if <em>keepends</em> is true.</p>
<p><em>sizehint</em>, if given, is passed as the <em>size</em> argument to the stream's
<a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamReader.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.reset" title="정의 주소">¶</a></dt>
<dd><p>Resets the codec buffers used for keeping state.</p>
<p>Note that no stream repositioning should take place. This method is
primarily intended to be able to recover from decoding errors.</p>
</dd></dl>

</dd></dl>

<p>In addition to the above methods, the <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> must also inherit
all other methods and attributes from the underlying stream.</p>
</div>
<div class="section" id="streamreaderwriter-objects">
<span id="stream-reader-writer"></span><h4>StreamReaderWriter Objects<a class="headerlink" href="#streamreaderwriter-objects" title="제목 주소">¶</a></h4>
<p>The <a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a> is a convenience class that allows wrapping
streams which work in both read and write modes.</p>
<p>The design is such that one can use the factory functions returned by the
<a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal notranslate"><span class="pre">lookup()</span></code></a> function to construct the instance.</p>
<dl class="class">
<dt id="codecs.StreamReaderWriter">
<em class="property">class </em><code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">StreamReaderWriter</code><span class="sig-paren">(</span><em class="sig-param">stream</em>, <em class="sig-param">Reader</em>, <em class="sig-param">Writer</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReaderWriter" title="정의 주소">¶</a></dt>
<dd><p>Creates a <a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a> instance. <em>stream</em> must be a file-like
object. <em>Reader</em> and <em>Writer</em> must be factory functions or classes providing the
<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> interface resp. Error handling
is done in the same way as defined for the stream readers and writers.</p>
</dd></dl>

<p><a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a> instances define the combined interfaces of
<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> classes. They inherit all other
methods and attributes from the underlying stream.</p>
</div>
<div class="section" id="streamrecoder-objects">
<span id="stream-recoder-objects"></span><h4>StreamRecoder Objects<a class="headerlink" href="#streamrecoder-objects" title="제목 주소">¶</a></h4>
<p>The <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a> translates data from one encoding to another,
which is sometimes useful when dealing with different encoding environments.</p>
<p>The design is such that one can use the factory functions returned by the
<a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal notranslate"><span class="pre">lookup()</span></code></a> function to construct the instance.</p>
<dl class="class">
<dt id="codecs.StreamRecoder">
<em class="property">class </em><code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">StreamRecoder</code><span class="sig-paren">(</span><em class="sig-param">stream</em>, <em class="sig-param">encode</em>, <em class="sig-param">decode</em>, <em class="sig-param">Reader</em>, <em class="sig-param">Writer</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamRecoder" title="정의 주소">¶</a></dt>
<dd><p>Creates a <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a> instance which implements a two-way conversion:
<em>encode</em> and <em>decode</em> work on the frontend — the data visible to
code calling <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>, while <em>Reader</em> and <em>Writer</em>
work on the backend — the data in <em>stream</em>.</p>
<p>You can use these objects to do transparent transcodings, e.g., from Latin-1
to UTF-8 and back.</p>
<p>The <em>stream</em> argument must be a file-like object.</p>
<p>The <em>encode</em> and <em>decode</em> arguments must
adhere to the <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> interface. <em>Reader</em> and
<em>Writer</em> must be factory functions or classes providing objects of the
<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> interface respectively.</p>
<p>Error handling is done in the same way as defined for the stream readers and
writers.</p>
</dd></dl>

<p><a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a> instances define the combined interfaces of
<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> classes. They inherit all other
methods and attributes from the underlying stream.</p>
</div>
</div>
</div>
<div class="section" id="encodings-and-unicode">
<span id="encodings-overview"></span><h2>Encodings and Unicode<a class="headerlink" href="#encodings-and-unicode" title="제목 주소">¶</a></h2>
<p>Strings are stored internally as sequences of code points in
range <code class="docutils literal notranslate"><span class="pre">0x0</span></code>--<code class="docutils literal notranslate"><span class="pre">0x10FFFF</span></code>. (See <span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0393"><strong>PEP 393</strong></a> for
more details about the implementation.)
Once a string object is used outside of CPU and memory, endianness
and how these arrays are stored as bytes become an issue. As with other
codecs, serialising a string into a sequence of bytes is known as <em>encoding</em>,
and recreating the string from the sequence of bytes is known as <em>decoding</em>.
There are a variety of different text serialisation codecs, which are
collectivity referred to as <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>.</p>
<p>The simplest text encoding (called <code class="docutils literal notranslate"><span class="pre">'latin-1'</span></code> or <code class="docutils literal notranslate"><span class="pre">'iso-8859-1'</span></code>) maps
the code points 0--255 to the bytes <code class="docutils literal notranslate"><span class="pre">0x0</span></code>--<code class="docutils literal notranslate"><span class="pre">0xff</span></code>, which means that a string
object that contains code points above <code class="docutils literal notranslate"><span class="pre">U+00FF</span></code> can't be encoded with this
codec. Doing so will raise a <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a> that looks
like the following (although the details of the error message may differ):
<code class="docutils literal notranslate"><span class="pre">UnicodeEncodeError:</span> <span class="pre">'latin-1'</span> <span class="pre">codec</span> <span class="pre">can't</span> <span class="pre">encode</span> <span class="pre">character</span> <span class="pre">'\u1234'</span> <span class="pre">in</span>
<span class="pre">position</span> <span class="pre">3:</span> <span class="pre">ordinal</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">range(256)</span></code>.</p>
<p>There's another group of encodings (the so called charmap encodings) that choose
a different subset of all Unicode code points and how these code points are
mapped to the bytes <code class="docutils literal notranslate"><span class="pre">0x0</span></code>--<code class="docutils literal notranslate"><span class="pre">0xff</span></code>. To see how this is done simply open
e.g. <code class="file docutils literal notranslate"><span class="pre">encodings/cp1252.py</span></code> (which is an encoding that is used primarily on
Windows). There's a string constant with 256 characters that shows you which
character is mapped to which byte value.</p>
<p>All of these encodings can only encode 256 of the 1114112 code points
defined in Unicode. A simple and straightforward way that can store each Unicode
code point, is to store each code point as four consecutive bytes. There are two
possibilities: store the bytes in big endian or in little endian order. These
two encodings are called <code class="docutils literal notranslate"><span class="pre">UTF-32-BE</span></code> and <code class="docutils literal notranslate"><span class="pre">UTF-32-LE</span></code> respectively. Their
disadvantage is that if e.g. you use <code class="docutils literal notranslate"><span class="pre">UTF-32-BE</span></code> on a little endian machine you
will always have to swap bytes on encoding and decoding. <code class="docutils literal notranslate"><span class="pre">UTF-32</span></code> avoids this
problem: bytes will always be in natural endianness. When these bytes are read
by a CPU with a different endianness, then bytes have to be swapped though. To
be able to detect the endianness of a <code class="docutils literal notranslate"><span class="pre">UTF-16</span></code> or <code class="docutils literal notranslate"><span class="pre">UTF-32</span></code> byte sequence,
there's the so called BOM (&quot;Byte Order Mark&quot;). This is the Unicode character
<code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code>. This character can be prepended to every <code class="docutils literal notranslate"><span class="pre">UTF-16</span></code> or <code class="docutils literal notranslate"><span class="pre">UTF-32</span></code>
byte sequence. The byte swapped version of this character (<code class="docutils literal notranslate"><span class="pre">0xFFFE</span></code>) is an
illegal character that may not appear in a Unicode text. So when the
first character in an <code class="docutils literal notranslate"><span class="pre">UTF-16</span></code> or <code class="docutils literal notranslate"><span class="pre">UTF-32</span></code> byte sequence
appears to be a <code class="docutils literal notranslate"><span class="pre">U+FFFE</span></code> the bytes have to be swapped on decoding.
Unfortunately the character <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code> had a second purpose as
a <code class="docutils literal notranslate"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code>: a character that has no width and doesn't allow
a word to be split. It can e.g. be used to give hints to a ligature algorithm.
With Unicode 4.0 using <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code> as a <code class="docutils literal notranslate"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code> has been
deprecated (with <code class="docutils literal notranslate"><span class="pre">U+2060</span></code> (<code class="docutils literal notranslate"><span class="pre">WORD</span> <span class="pre">JOINER</span></code>) assuming this role). Nevertheless
Unicode software still must be able to handle <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code> in both roles: as a BOM
it's a device to determine the storage layout of the encoded bytes, and vanishes
once the byte sequence has been decoded into a string; as a <code class="docutils literal notranslate"><span class="pre">ZERO</span> <span class="pre">WIDTH</span>
<span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code> it's a normal character that will be decoded like any other.</p>
<p>There's another encoding that is able to encoding the full range of Unicode
characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no issues
with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists of two
parts: marker bits (the most significant bits) and payload bits. The marker bits
are a sequence of zero to four <code class="docutils literal notranslate"><span class="pre">1</span></code> bits followed by a <code class="docutils literal notranslate"><span class="pre">0</span></code> bit. Unicode characters are
encoded like this (with x being payload bits, which when concatenated give the
Unicode character):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Range</p></th>
<th class="head"><p>Encoding</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">U-00000000</span></code> ... <code class="docutils literal notranslate"><span class="pre">U-0000007F</span></code></p></td>
<td><p>0xxxxxxx</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">U-00000080</span></code> ... <code class="docutils literal notranslate"><span class="pre">U-000007FF</span></code></p></td>
<td><p>110xxxxx 10xxxxxx</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">U-00000800</span></code> ... <code class="docutils literal notranslate"><span class="pre">U-0000FFFF</span></code></p></td>
<td><p>1110xxxx 10xxxxxx 10xxxxxx</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">U-00010000</span></code> ... <code class="docutils literal notranslate"><span class="pre">U-0010FFFF</span></code></p></td>
<td><p>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p></td>
</tr>
</tbody>
</table>
<p>The least significant bit of the Unicode character is the rightmost x bit.</p>
<p>As UTF-8 is an 8-bit encoding no BOM is required and any <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code> character in
the decoded string (even if it's the first character) is treated as a <code class="docutils literal notranslate"><span class="pre">ZERO</span>
<span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code>.</p>
<p>Without external information it's impossible to reliably determine which
encoding was used for encoding a string. Each charmap encoding can
decode any random byte sequence. However that's not possible with UTF-8, as
UTF-8 byte sequences have a structure that doesn't allow arbitrary byte
sequences. To increase the reliability with which a UTF-8 encoding can be
detected, Microsoft invented a variant of UTF-8 (that Python 2.5 calls
<code class="docutils literal notranslate"><span class="pre">&quot;utf-8-sig&quot;</span></code>) for its Notepad program: Before any of the Unicode characters
is written to the file, a UTF-8 encoded BOM (which looks like this as a byte
sequence: <code class="docutils literal notranslate"><span class="pre">0xef</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbb</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbf</span></code>) is written. As it's rather improbable
that any charmap encoded file starts with these byte values (which would e.g.
map to</p>
<blockquote>
<div><div class="line-block">
<div class="line">LATIN SMALL LETTER I WITH DIAERESIS</div>
<div class="line">RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK</div>
<div class="line">INVERTED QUESTION MARK</div>
</div>
</div></blockquote>
<p>in iso-8859-1), this increases the probability that a <code class="docutils literal notranslate"><span class="pre">utf-8-sig</span></code> encoding can be
correctly guessed from the byte sequence. So here the BOM is not used to be able
to determine the byte order used for generating the byte sequence, but as a
signature that helps in guessing the encoding. On encoding the utf-8-sig codec
will write <code class="docutils literal notranslate"><span class="pre">0xef</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbb</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbf</span></code> as the first three bytes to the file. On
decoding <code class="docutils literal notranslate"><span class="pre">utf-8-sig</span></code> will skip those three bytes if they appear as the first
three bytes in the file. In UTF-8, the use of the BOM is discouraged and
should generally be avoided.</p>
</div>
<div class="section" id="standard-encodings">
<span id="id3"></span><h2>Standard Encodings<a class="headerlink" href="#standard-encodings" title="제목 주소">¶</a></h2>
<p>Python comes with a number of codecs built-in, either implemented as C functions
or with dictionaries as mapping tables. The following table lists the codecs by
name, together with a few common aliases, and the languages for which the
encoding is likely used. Neither the list of aliases nor the list of languages
is meant to be exhaustive. Notice that spelling alternatives that only differ in
case or use a hyphen instead of an underscore are also valid aliases; therefore,
e.g. <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> is a valid alias for the <code class="docutils literal notranslate"><span class="pre">'utf_8'</span></code> codec.</p>
<div class="impl-detail compound">
<p class="compound-first"><strong>CPython implementation detail:</strong> Some common encodings can bypass the codecs lookup machinery to
improve performance. These optimization opportunities are only
recognized by CPython for a limited set of (case insensitive)
aliases: utf-8, utf8, latin-1, latin1, iso-8859-1, iso8859-1, mbcs
(Windows only), ascii, us-ascii, utf-16, utf16, utf-32, utf32, and
the same using underscores instead of dashes. Using alternative
aliases for these encodings may result in slower execution.</p>
<div class="compound-last versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>Optimization opportunity recognized for us-ascii.</p>
</div>
</div>
<p>Many of the character sets support the same languages. They vary in individual
characters (e.g. whether the EURO SIGN is supported or not), and in the
assignment of characters to code positions. For the European languages in
particular, the following variants typically exist:</p>
<ul class="simple">
<li><p>an ISO 8859 codeset</p></li>
<li><p>a Microsoft Windows code page, which is typically derived from an 8859 codeset,
but replaces control characters with additional graphic characters</p></li>
<li><p>an IBM EBCDIC code page</p></li>
<li><p>an IBM PC code page, which is ASCII compatible</p></li>
</ul>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 40%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Codec</p></th>
<th class="head"><p>Aliases</p></th>
<th class="head"><p>Languages</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ascii</p></td>
<td><p>646, us-ascii</p></td>
<td><p>English</p></td>
</tr>
<tr class="row-odd"><td><p>big5</p></td>
<td><p>big5-tw, csbig5</p></td>
<td><p>Traditional Chinese</p></td>
</tr>
<tr class="row-even"><td><p>big5hkscs</p></td>
<td><p>big5-hkscs, hkscs</p></td>
<td><p>Traditional Chinese</p></td>
</tr>
<tr class="row-odd"><td><p>cp037</p></td>
<td><p>IBM037, IBM039</p></td>
<td><p>English</p></td>
</tr>
<tr class="row-even"><td><p>cp273</p></td>
<td><p>273, IBM273, csIBM273</p></td>
<td><p>German</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>cp424</p></td>
<td><p>EBCDIC-CP-HE, IBM424</p></td>
<td><p>Hebrew</p></td>
</tr>
<tr class="row-even"><td><p>cp437</p></td>
<td><p>437, IBM437</p></td>
<td><p>English</p></td>
</tr>
<tr class="row-odd"><td><p>cp500</p></td>
<td><p>EBCDIC-CP-BE, EBCDIC-CP-CH,
IBM500</p></td>
<td><p>Western Europe</p></td>
</tr>
<tr class="row-even"><td><p>cp720</p></td>
<td></td>
<td><p>Arabic</p></td>
</tr>
<tr class="row-odd"><td><p>cp737</p></td>
<td></td>
<td><p>Greek</p></td>
</tr>
<tr class="row-even"><td><p>cp775</p></td>
<td><p>IBM775</p></td>
<td><p>Baltic languages</p></td>
</tr>
<tr class="row-odd"><td><p>cp850</p></td>
<td><p>850, IBM850</p></td>
<td><p>Western Europe</p></td>
</tr>
<tr class="row-even"><td><p>cp852</p></td>
<td><p>852, IBM852</p></td>
<td><p>Central and Eastern Europe</p></td>
</tr>
<tr class="row-odd"><td><p>cp855</p></td>
<td><p>855, IBM855</p></td>
<td><p>Bulgarian, Byelorussian,
Macedonian, Russian, Serbian</p></td>
</tr>
<tr class="row-even"><td><p>cp856</p></td>
<td></td>
<td><p>Hebrew</p></td>
</tr>
<tr class="row-odd"><td><p>cp857</p></td>
<td><p>857, IBM857</p></td>
<td><p>Turkish</p></td>
</tr>
<tr class="row-even"><td><p>cp858</p></td>
<td><p>858, IBM858</p></td>
<td><p>Western Europe</p></td>
</tr>
<tr class="row-odd"><td><p>cp860</p></td>
<td><p>860, IBM860</p></td>
<td><p>Portuguese</p></td>
</tr>
<tr class="row-even"><td><p>cp861</p></td>
<td><p>861, CP-IS, IBM861</p></td>
<td><p>Icelandic</p></td>
</tr>
<tr class="row-odd"><td><p>cp862</p></td>
<td><p>862, IBM862</p></td>
<td><p>Hebrew</p></td>
</tr>
<tr class="row-even"><td><p>cp863</p></td>
<td><p>863, IBM863</p></td>
<td><p>Canadian</p></td>
</tr>
<tr class="row-odd"><td><p>cp864</p></td>
<td><p>IBM864</p></td>
<td><p>Arabic</p></td>
</tr>
<tr class="row-even"><td><p>cp865</p></td>
<td><p>865, IBM865</p></td>
<td><p>Danish, Norwegian</p></td>
</tr>
<tr class="row-odd"><td><p>cp866</p></td>
<td><p>866, IBM866</p></td>
<td><p>Russian</p></td>
</tr>
<tr class="row-even"><td><p>cp869</p></td>
<td><p>869, CP-GR, IBM869</p></td>
<td><p>Greek</p></td>
</tr>
<tr class="row-odd"><td><p>cp874</p></td>
<td></td>
<td><p>Thai</p></td>
</tr>
<tr class="row-even"><td><p>cp875</p></td>
<td></td>
<td><p>Greek</p></td>
</tr>
<tr class="row-odd"><td><p>cp932</p></td>
<td><p>932, ms932, mskanji, ms-kanji</p></td>
<td><p>Japanese</p></td>
</tr>
<tr class="row-even"><td><p>cp949</p></td>
<td><p>949, ms949, uhc</p></td>
<td><p>Korean</p></td>
</tr>
<tr class="row-odd"><td><p>cp950</p></td>
<td><p>950, ms950</p></td>
<td><p>Traditional Chinese</p></td>
</tr>
<tr class="row-even"><td><p>cp1006</p></td>
<td></td>
<td><p>Urdu</p></td>
</tr>
<tr class="row-odd"><td><p>cp1026</p></td>
<td><p>ibm1026</p></td>
<td><p>Turkish</p></td>
</tr>
<tr class="row-even"><td><p>cp1125</p></td>
<td><p>1125, ibm1125, cp866u, ruscii</p></td>
<td><p>Ukrainian</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>cp1140</p></td>
<td><p>ibm1140</p></td>
<td><p>Western Europe</p></td>
</tr>
<tr class="row-even"><td><p>cp1250</p></td>
<td><p>windows-1250</p></td>
<td><p>Central and Eastern Europe</p></td>
</tr>
<tr class="row-odd"><td><p>cp1251</p></td>
<td><p>windows-1251</p></td>
<td><p>Bulgarian, Byelorussian,
Macedonian, Russian, Serbian</p></td>
</tr>
<tr class="row-even"><td><p>cp1252</p></td>
<td><p>windows-1252</p></td>
<td><p>Western Europe</p></td>
</tr>
<tr class="row-odd"><td><p>cp1253</p></td>
<td><p>windows-1253</p></td>
<td><p>Greek</p></td>
</tr>
<tr class="row-even"><td><p>cp1254</p></td>
<td><p>windows-1254</p></td>
<td><p>Turkish</p></td>
</tr>
<tr class="row-odd"><td><p>cp1255</p></td>
<td><p>windows-1255</p></td>
<td><p>Hebrew</p></td>
</tr>
<tr class="row-even"><td><p>cp1256</p></td>
<td><p>windows-1256</p></td>
<td><p>Arabic</p></td>
</tr>
<tr class="row-odd"><td><p>cp1257</p></td>
<td><p>windows-1257</p></td>
<td><p>Baltic languages</p></td>
</tr>
<tr class="row-even"><td><p>cp1258</p></td>
<td><p>windows-1258</p></td>
<td><p>Vietnamese</p></td>
</tr>
<tr class="row-odd"><td><p>euc_jp</p></td>
<td><p>eucjp, ujis, u-jis</p></td>
<td><p>Japanese</p></td>
</tr>
<tr class="row-even"><td><p>euc_jis_2004</p></td>
<td><p>jisx0213, eucjis2004</p></td>
<td><p>Japanese</p></td>
</tr>
<tr class="row-odd"><td><p>euc_jisx0213</p></td>
<td><p>eucjisx0213</p></td>
<td><p>Japanese</p></td>
</tr>
<tr class="row-even"><td><p>euc_kr</p></td>
<td><p>euckr, korean, ksc5601,
ks_c-5601, ks_c-5601-1987,
ksx1001, ks_x-1001</p></td>
<td><p>Korean</p></td>
</tr>
<tr class="row-odd"><td><p>gb2312</p></td>
<td><p>chinese, csiso58gb231280,
euc-cn, euccn, eucgb2312-cn,
gb2312-1980, gb2312-80,
iso-ir-58</p></td>
<td><p>Simplified Chinese</p></td>
</tr>
<tr class="row-even"><td><p>gbk</p></td>
<td><p>936, cp936, ms936</p></td>
<td><p>Unified Chinese</p></td>
</tr>
<tr class="row-odd"><td><p>gb18030</p></td>
<td><p>gb18030-2000</p></td>
<td><p>Unified Chinese</p></td>
</tr>
<tr class="row-even"><td><p>hz</p></td>
<td><p>hzgb, hz-gb, hz-gb-2312</p></td>
<td><p>Simplified Chinese</p></td>
</tr>
<tr class="row-odd"><td><p>iso2022_jp</p></td>
<td><p>csiso2022jp, iso2022jp,
iso-2022-jp</p></td>
<td><p>Japanese</p></td>
</tr>
<tr class="row-even"><td><p>iso2022_jp_1</p></td>
<td><p>iso2022jp-1, iso-2022-jp-1</p></td>
<td><p>Japanese</p></td>
</tr>
<tr class="row-odd"><td><p>iso2022_jp_2</p></td>
<td><p>iso2022jp-2, iso-2022-jp-2</p></td>
<td><p>Japanese, Korean, Simplified
Chinese, Western Europe, Greek</p></td>
</tr>
<tr class="row-even"><td><p>iso2022_jp_2004</p></td>
<td><p>iso2022jp-2004,
iso-2022-jp-2004</p></td>
<td><p>Japanese</p></td>
</tr>
<tr class="row-odd"><td><p>iso2022_jp_3</p></td>
<td><p>iso2022jp-3, iso-2022-jp-3</p></td>
<td><p>Japanese</p></td>
</tr>
<tr class="row-even"><td><p>iso2022_jp_ext</p></td>
<td><p>iso2022jp-ext, iso-2022-jp-ext</p></td>
<td><p>Japanese</p></td>
</tr>
<tr class="row-odd"><td><p>iso2022_kr</p></td>
<td><p>csiso2022kr, iso2022kr,
iso-2022-kr</p></td>
<td><p>Korean</p></td>
</tr>
<tr class="row-even"><td><p>latin_1</p></td>
<td><p>iso-8859-1, iso8859-1, 8859,
cp819, latin, latin1, L1</p></td>
<td><p>Western Europe</p></td>
</tr>
<tr class="row-odd"><td><p>iso8859_2</p></td>
<td><p>iso-8859-2, latin2, L2</p></td>
<td><p>Central and Eastern Europe</p></td>
</tr>
<tr class="row-even"><td><p>iso8859_3</p></td>
<td><p>iso-8859-3, latin3, L3</p></td>
<td><p>Esperanto, Maltese</p></td>
</tr>
<tr class="row-odd"><td><p>iso8859_4</p></td>
<td><p>iso-8859-4, latin4, L4</p></td>
<td><p>Baltic languages</p></td>
</tr>
<tr class="row-even"><td><p>iso8859_5</p></td>
<td><p>iso-8859-5, cyrillic</p></td>
<td><p>Bulgarian, Byelorussian,
Macedonian, Russian, Serbian</p></td>
</tr>
<tr class="row-odd"><td><p>iso8859_6</p></td>
<td><p>iso-8859-6, arabic</p></td>
<td><p>Arabic</p></td>
</tr>
<tr class="row-even"><td><p>iso8859_7</p></td>
<td><p>iso-8859-7, greek, greek8</p></td>
<td><p>Greek</p></td>
</tr>
<tr class="row-odd"><td><p>iso8859_8</p></td>
<td><p>iso-8859-8, hebrew</p></td>
<td><p>Hebrew</p></td>
</tr>
<tr class="row-even"><td><p>iso8859_9</p></td>
<td><p>iso-8859-9, latin5, L5</p></td>
<td><p>Turkish</p></td>
</tr>
<tr class="row-odd"><td><p>iso8859_10</p></td>
<td><p>iso-8859-10, latin6, L6</p></td>
<td><p>Nordic languages</p></td>
</tr>
<tr class="row-even"><td><p>iso8859_11</p></td>
<td><p>iso-8859-11, thai</p></td>
<td><p>Thai languages</p></td>
</tr>
<tr class="row-odd"><td><p>iso8859_13</p></td>
<td><p>iso-8859-13, latin7, L7</p></td>
<td><p>Baltic languages</p></td>
</tr>
<tr class="row-even"><td><p>iso8859_14</p></td>
<td><p>iso-8859-14, latin8, L8</p></td>
<td><p>Celtic languages</p></td>
</tr>
<tr class="row-odd"><td><p>iso8859_15</p></td>
<td><p>iso-8859-15, latin9, L9</p></td>
<td><p>Western Europe</p></td>
</tr>
<tr class="row-even"><td><p>iso8859_16</p></td>
<td><p>iso-8859-16, latin10, L10</p></td>
<td><p>South-Eastern Europe</p></td>
</tr>
<tr class="row-odd"><td><p>johab</p></td>
<td><p>cp1361, ms1361</p></td>
<td><p>Korean</p></td>
</tr>
<tr class="row-even"><td><p>koi8_r</p></td>
<td></td>
<td><p>Russian</p></td>
</tr>
<tr class="row-odd"><td><p>koi8_t</p></td>
<td></td>
<td><p>Tajik</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td><p>koi8_u</p></td>
<td></td>
<td><p>Ukrainian</p></td>
</tr>
<tr class="row-odd"><td><p>kz1048</p></td>
<td><p>kz_1048, strk1048_2002, rk1048</p></td>
<td><p>Kazakh</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td><p>mac_cyrillic</p></td>
<td><p>maccyrillic</p></td>
<td><p>Bulgarian, Byelorussian,
Macedonian, Russian, Serbian</p></td>
</tr>
<tr class="row-odd"><td><p>mac_greek</p></td>
<td><p>macgreek</p></td>
<td><p>Greek</p></td>
</tr>
<tr class="row-even"><td><p>mac_iceland</p></td>
<td><p>maciceland</p></td>
<td><p>Icelandic</p></td>
</tr>
<tr class="row-odd"><td><p>mac_latin2</p></td>
<td><p>maclatin2, maccentraleurope,
mac_centeuro</p></td>
<td><p>Central and Eastern Europe</p></td>
</tr>
<tr class="row-even"><td><p>mac_roman</p></td>
<td><p>macroman, macintosh</p></td>
<td><p>Western Europe</p></td>
</tr>
<tr class="row-odd"><td><p>mac_turkish</p></td>
<td><p>macturkish</p></td>
<td><p>Turkish</p></td>
</tr>
<tr class="row-even"><td><p>ptcp154</p></td>
<td><p>csptcp154, pt154, cp154,
cyrillic-asian</p></td>
<td><p>Kazakh</p></td>
</tr>
<tr class="row-odd"><td><p>shift_jis</p></td>
<td><p>csshiftjis, shiftjis, sjis,
s_jis</p></td>
<td><p>Japanese</p></td>
</tr>
<tr class="row-even"><td><p>shift_jis_2004</p></td>
<td><p>shiftjis2004, sjis_2004,
sjis2004</p></td>
<td><p>Japanese</p></td>
</tr>
<tr class="row-odd"><td><p>shift_jisx0213</p></td>
<td><p>shiftjisx0213, sjisx0213,
s_jisx0213</p></td>
<td><p>Japanese</p></td>
</tr>
<tr class="row-even"><td><p>utf_32</p></td>
<td><p>U32, utf32</p></td>
<td><p>all languages</p></td>
</tr>
<tr class="row-odd"><td><p>utf_32_be</p></td>
<td><p>UTF-32BE</p></td>
<td><p>all languages</p></td>
</tr>
<tr class="row-even"><td><p>utf_32_le</p></td>
<td><p>UTF-32LE</p></td>
<td><p>all languages</p></td>
</tr>
<tr class="row-odd"><td><p>utf_16</p></td>
<td><p>U16, utf16</p></td>
<td><p>all languages</p></td>
</tr>
<tr class="row-even"><td><p>utf_16_be</p></td>
<td><p>UTF-16BE</p></td>
<td><p>all languages</p></td>
</tr>
<tr class="row-odd"><td><p>utf_16_le</p></td>
<td><p>UTF-16LE</p></td>
<td><p>all languages</p></td>
</tr>
<tr class="row-even"><td><p>utf_7</p></td>
<td><p>U7, unicode-1-1-utf-7</p></td>
<td><p>all languages</p></td>
</tr>
<tr class="row-odd"><td><p>utf_8</p></td>
<td><p>U8, UTF, utf8, cp65001</p></td>
<td><p>all languages</p></td>
</tr>
<tr class="row-even"><td><p>utf_8_sig</p></td>
<td></td>
<td><p>all languages</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>The utf-16* and utf-32* encoders no longer allow surrogate code points
(<code class="docutils literal notranslate"><span class="pre">U+D800</span></code>--<code class="docutils literal notranslate"><span class="pre">U+DFFF</span></code>) to be encoded.
The utf-32* decoders no longer decode
byte sequences that correspond to surrogate code points.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><code class="docutils literal notranslate"><span class="pre">cp65001</span></code> is now an alias to <code class="docutils literal notranslate"><span class="pre">utf_8</span></code>.</p>
</div>
</div>
<div class="section" id="python-specific-encodings">
<h2>Python Specific Encodings<a class="headerlink" href="#python-specific-encodings" title="제목 주소">¶</a></h2>
<p>A number of predefined codecs are specific to Python, so their codec names have
no meaning outside Python. These are listed in the tables below based on the
expected input and output types (note that while text encodings are the most
common use case for codecs, the underlying codec infrastructure supports
arbitrary data transforms rather than just text encodings). For asymmetric
codecs, the stated meaning describes the encoding direction.</p>
<div class="section" id="text-encodings">
<h3>Text Encodings<a class="headerlink" href="#text-encodings" title="제목 주소">¶</a></h3>
<p>The following codecs provide <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> to <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> encoding and
<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> to <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> decoding, similar to the Unicode text
encodings.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 16%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Codec</p></th>
<th class="head"><p>Aliases</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>idna</p></td>
<td></td>
<td><p>Implement <span class="target" id="index-4"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a>,
see also
<a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code></a>.
Only <code class="docutils literal notranslate"><span class="pre">errors='strict'</span></code>
is supported.</p></td>
</tr>
<tr class="row-odd"><td><p>mbcs</p></td>
<td><p>ansi,
dbcs</p></td>
<td><p>Windows only: Encode the
operand according to the
ANSI codepage (CP_ACP).</p></td>
</tr>
<tr class="row-even"><td><p>oem</p></td>
<td></td>
<td><p>Windows only: Encode the
operand according to the
OEM codepage (CP_OEMCP).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>palmos</p></td>
<td></td>
<td><p>Encoding of PalmOS 3.5.</p></td>
</tr>
<tr class="row-even"><td><p>punycode</p></td>
<td></td>
<td><p>Implement <span class="target" id="index-5"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3492.html"><strong>RFC 3492</strong></a>.
Stateful codecs are not
supported.</p></td>
</tr>
<tr class="row-odd"><td><p>raw_unicode_escape</p></td>
<td></td>
<td><p>Latin-1 encoding with
<code class="docutils literal notranslate"><span class="pre">\uXXXX</span></code> and
<code class="docutils literal notranslate"><span class="pre">\UXXXXXXXX</span></code> for other
code points. Existing
backslashes are not
escaped in any way.
It is used in the Python
pickle protocol.</p></td>
</tr>
<tr class="row-even"><td><p>undefined</p></td>
<td></td>
<td><p>Raise an exception for
all conversions, even
empty strings. The error
handler is ignored.</p></td>
</tr>
<tr class="row-odd"><td><p>unicode_escape</p></td>
<td></td>
<td><p>Encoding suitable as the
contents of a Unicode
literal in ASCII-encoded
Python source code,
except that quotes are
not escaped. Decode
from Latin-1 source code.
Beware that Python source
code actually uses UTF-8
by default.</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>&quot;unicode_internal&quot; codec is removed.</p>
</div>
</div>
<div class="section" id="binary-transforms">
<span id="id4"></span><h3>Binary Transforms<a class="headerlink" href="#binary-transforms" title="제목 주소">¶</a></h3>
<p>The following codecs provide binary transforms: <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>
to <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> mappings. They are not supported by <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a>
(which only produces <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> output).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 18%" />
<col style="width: 30%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Codec</p></th>
<th class="head"><p>Aliases</p></th>
<th class="head"><p>의미</p></th>
<th class="head"><p>Encoder / decoder</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>base64_codec <a class="footnote-reference brackets" href="#b64" id="id5">1</a></p></td>
<td><p>base64, base_64</p></td>
<td><p>Convert the operand to
multiline MIME base64 (the
result always includes a
trailing <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>accepts any
<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>
as input for encoding and
decoding</p>
</div>
</td>
<td><p><a class="reference internal" href="base64.html#base64.encodebytes" title="base64.encodebytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base64.encodebytes()</span></code></a> /
<a class="reference internal" href="base64.html#base64.decodebytes" title="base64.decodebytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base64.decodebytes()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>bz2_codec</p></td>
<td><p>bz2</p></td>
<td><p>Compress the operand using
bz2.</p></td>
<td><p><a class="reference internal" href="bz2.html#bz2.compress" title="bz2.compress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bz2.compress()</span></code></a> /
<a class="reference internal" href="bz2.html#bz2.decompress" title="bz2.decompress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bz2.decompress()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>hex_codec</p></td>
<td><p>hex</p></td>
<td><p>Convert the operand to
hexadecimal
representation, with two
digits per byte.</p></td>
<td><p><a class="reference internal" href="binascii.html#binascii.b2a_hex" title="binascii.b2a_hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">binascii.b2a_hex()</span></code></a> /
<a class="reference internal" href="binascii.html#binascii.a2b_hex" title="binascii.a2b_hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">binascii.a2b_hex()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>quopri_codec</p></td>
<td><p>quopri,
quotedprintable,
quoted_printable</p></td>
<td><p>Convert the operand to MIME
quoted printable.</p></td>
<td><p><a class="reference internal" href="quopri.html#quopri.encode" title="quopri.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quopri.encode()</span></code></a> with
<code class="docutils literal notranslate"><span class="pre">quotetabs=True</span></code> /
<a class="reference internal" href="quopri.html#quopri.decode" title="quopri.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quopri.decode()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>uu_codec</p></td>
<td><p>uu</p></td>
<td><p>Convert the operand using
uuencode.</p></td>
<td><p><a class="reference internal" href="uu.html#uu.encode" title="uu.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">uu.encode()</span></code></a> /
<a class="reference internal" href="uu.html#uu.decode" title="uu.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">uu.decode()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>zlib_codec</p></td>
<td><p>zip, zlib</p></td>
<td><p>Compress the operand using
gzip.</p></td>
<td><p><a class="reference internal" href="zlib.html#zlib.compress" title="zlib.compress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zlib.compress()</span></code></a> /
<a class="reference internal" href="zlib.html#zlib.decompress" title="zlib.decompress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zlib.decompress()</span></code></a></p></td>
</tr>
</tbody>
</table>
<dl class="footnote brackets">
<dt class="label" id="b64"><span class="brackets"><a class="fn-backref" href="#id5">1</a></span></dt>
<dd><p>In addition to <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>,
<code class="docutils literal notranslate"><span class="pre">'base64_codec'</span></code> also accepts ASCII-only instances of <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> for
decoding</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가: </span>Restoration of the binary transforms.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>Restoration of the aliases for the binary transforms.</p>
</div>
</div>
<div class="section" id="text-transforms">
<span id="id6"></span><h3>Text Transforms<a class="headerlink" href="#text-transforms" title="제목 주소">¶</a></h3>
<p>The following codec provides a text transform: a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> to <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>
mapping. It is not supported by <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> (which only produces
<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> output).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 16%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Codec</p></th>
<th class="head"><p>Aliases</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>rot_13</p></td>
<td><p>rot13</p></td>
<td><p>Return the Caesar-cypher
encryption of the
operand.</p></td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가: </span>Restoration of the <code class="docutils literal notranslate"><span class="pre">rot_13</span></code> text transform.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>Restoration of the <code class="docutils literal notranslate"><span class="pre">rot13</span></code> alias.</p>
</div>
</div>
</div>
<div class="section" id="module-encodings.idna">
<span id="encodings-idna-internationalized-domain-names-in-applications"></span><h2><a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code></a> --- Internationalized Domain Names in Applications<a class="headerlink" href="#module-encodings.idna" title="제목 주소">¶</a></h2>
<p>This module implements <span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a> (Internationalized Domain Names in
Applications) and <span class="target" id="index-7"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3492.html"><strong>RFC 3492</strong></a> (Nameprep: A Stringprep Profile for
Internationalized Domain Names (IDN)). It builds upon the <code class="docutils literal notranslate"><span class="pre">punycode</span></code> encoding
and <a class="reference internal" href="stringprep.html#module-stringprep" title="stringprep: String preparation, as per RFC 3453"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stringprep</span></code></a>.</p>
<p>These RFCs together define a protocol to support non-ASCII characters in domain
names. A domain name containing non-ASCII characters (such as
<code class="docutils literal notranslate"><span class="pre">www.Alliancefrançaise.nu</span></code>) is converted into an ASCII-compatible encoding
(ACE, such as <code class="docutils literal notranslate"><span class="pre">www.xn--alliancefranaise-npb.nu</span></code>). The ACE form of the domain
name is then used in all places where arbitrary characters are not allowed by
the protocol, such as DNS queries, HTTP <em class="mailheader">Host</em> fields, and so
on. This conversion is carried out in the application; if possible invisible to
the user: The application should transparently convert Unicode domain labels to
IDNA on the wire, and convert back ACE labels to Unicode before presenting them
to the user.</p>
<p>Python supports this conversion in several ways:  the <code class="docutils literal notranslate"><span class="pre">idna</span></code> codec performs
conversion between Unicode and ACE, separating an input string into labels
based on the separator characters defined in <span class="target" id="index-8"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html#section-3.1"><strong>section 3.1 of RFC 3490</strong></a>
and converting each label to ACE as required, and conversely separating an input
byte string into labels based on the <code class="docutils literal notranslate"><span class="pre">.</span></code> separator and converting any ACE
labels found into unicode. Furthermore, the <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> module
transparently converts Unicode host names to ACE, so that applications need not
be concerned about converting host names themselves when they pass them to the
socket module. On top of that, modules that have host names as function
parameters, such as <a class="reference internal" href="http.client.html#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.client</span></code></a> and <a class="reference internal" href="ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a>, accept Unicode host
names (<a class="reference internal" href="http.client.html#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.client</span></code></a> then also transparently sends an IDNA hostname in the
<em class="mailheader">Host</em> field if it sends that field at all).</p>
<p>When receiving host names from the wire (such as in reverse name lookup), no
automatic conversion to Unicode is performed: applications wishing to present
such host names to the user should decode them to Unicode.</p>
<p>The module <a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code></a> also implements the nameprep procedure, which
performs certain normalizations on host names, to achieve case-insensitivity of
international domain names, and to unify similar characters. The nameprep
functions can be used directly if desired.</p>
<dl class="function">
<dt id="encodings.idna.nameprep">
<code class="sig-prename descclassname">encodings.idna.</code><code class="sig-name descname">nameprep</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.nameprep" title="정의 주소">¶</a></dt>
<dd><p>Return the nameprepped version of <em>label</em>. The implementation currently assumes
query strings, so <code class="docutils literal notranslate"><span class="pre">AllowUnassigned</span></code> is true.</p>
</dd></dl>

<dl class="function">
<dt id="encodings.idna.ToASCII">
<code class="sig-prename descclassname">encodings.idna.</code><code class="sig-name descname">ToASCII</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.ToASCII" title="정의 주소">¶</a></dt>
<dd><p>Convert a label to ASCII, as specified in <span class="target" id="index-9"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a>. <code class="docutils literal notranslate"><span class="pre">UseSTD3ASCIIRules</span></code> is
assumed to be false.</p>
</dd></dl>

<dl class="function">
<dt id="encodings.idna.ToUnicode">
<code class="sig-prename descclassname">encodings.idna.</code><code class="sig-name descname">ToUnicode</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.ToUnicode" title="정의 주소">¶</a></dt>
<dd><p>Convert a label to Unicode, as specified in <span class="target" id="index-10"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a>.</p>
</dd></dl>

</div>
<div class="section" id="module-encodings.mbcs">
<span id="encodings-mbcs-windows-ansi-codepage"></span><h2><a class="reference internal" href="#module-encodings.mbcs" title="encodings.mbcs: Windows ANSI codepage"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.mbcs</span></code></a> --- Windows ANSI codepage<a class="headerlink" href="#module-encodings.mbcs" title="제목 주소">¶</a></h2>
<p>This module implements the ANSI codepage (CP_ACP).</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows only.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>Support any error handler.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>Before 3.2, the <em>errors</em> argument was ignored; <code class="docutils literal notranslate"><span class="pre">'replace'</span></code> was always used
to encode, and <code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> to decode.</p>
</div>
</div>
<div class="section" id="module-encodings.utf_8_sig">
<span id="encodings-utf-8-sig-utf-8-codec-with-bom-signature"></span><h2><a class="reference internal" href="#module-encodings.utf_8_sig" title="encodings.utf_8_sig: UTF-8 codec with BOM signature"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.utf_8_sig</span></code></a> --- UTF-8 codec with BOM signature<a class="headerlink" href="#module-encodings.utf_8_sig" title="제목 주소">¶</a></h2>
<p>This module implements a variant of the UTF-8 codec. On encoding, a UTF-8 encoded
BOM will be prepended to the UTF-8 encoded bytes. For the stateful encoder this
is only done once (on the first write to the byte stream). On decoding, an
optional UTF-8 encoded BOM at the start of the data will be skipped.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code> --- 코덱 레지스트리와 베이스 클래스</a><ul>
<li><a class="reference internal" href="#codec-base-classes">코덱 베이스 클래스</a><ul>
<li><a class="reference internal" href="#error-handlers">에러 처리기</a></li>
<li><a class="reference internal" href="#stateless-encoding-and-decoding">상태 없는 인코딩과 디코딩</a></li>
<li><a class="reference internal" href="#incremental-encoding-and-decoding">증분 인코딩과 디코딩</a><ul>
<li><a class="reference internal" href="#incrementalencoder-objects">IncrementalEncoder Objects</a></li>
<li><a class="reference internal" href="#incrementaldecoder-objects">IncrementalDecoder Objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#stream-encoding-and-decoding">Stream Encoding and Decoding</a><ul>
<li><a class="reference internal" href="#streamwriter-objects">StreamWriter Objects</a></li>
<li><a class="reference internal" href="#streamreader-objects">StreamReader Objects</a></li>
<li><a class="reference internal" href="#streamreaderwriter-objects">StreamReaderWriter Objects</a></li>
<li><a class="reference internal" href="#streamrecoder-objects">StreamRecoder Objects</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#encodings-and-unicode">Encodings and Unicode</a></li>
<li><a class="reference internal" href="#standard-encodings">Standard Encodings</a></li>
<li><a class="reference internal" href="#python-specific-encodings">Python Specific Encodings</a><ul>
<li><a class="reference internal" href="#text-encodings">Text Encodings</a></li>
<li><a class="reference internal" href="#binary-transforms">Binary Transforms</a></li>
<li><a class="reference internal" href="#text-transforms">Text Transforms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-encodings.idna"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code> --- Internationalized Domain Names in Applications</a></li>
<li><a class="reference internal" href="#module-encodings.mbcs"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.mbcs</span></code> --- Windows ANSI codepage</a></li>
<li><a class="reference internal" href="#module-encodings.utf_8_sig"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.utf_8_sig</span></code> --- UTF-8 codec with BOM signature</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="struct.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code> --- 패킹 된 바이너리 데이터로 바이트열을 해석</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="datatypes.html"
                        title="다음 장">데이터형</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="datatypes.html" title="데이터형"
             >다음</a> |</li>
        <li class="right" >
          <a href="struct.html" title="struct --- 패킹 된 바이너리 데이터로 바이트열을 해석"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="binary.html" >바이너리 데이터 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>