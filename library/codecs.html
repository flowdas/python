
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>codecs --- 코덱 레지스트리와 베이스 클래스 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="데이터형" href="datatypes.html" />
    <link rel="prev" title="struct --- 패킹 된 바이너리 데이터로 바이트열을 해석" href="struct.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/codecs.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="datatypes.html" title="데이터형"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="struct.html" title="struct --- 패킹 된 바이너리 데이터로 바이트열을 해석"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="binary.html" accesskey="U">바이너리 데이터 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-codecs">
<span id="codecs-codec-registry-and-base-classes"></span><h1><a class="reference internal" href="#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> --- 코덱 레지스트리와 베이스 클래스<a class="headerlink" href="#module-codecs" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/codecs.py">Lib/codecs.py</a></p>
<hr class="docutils" id="index-0" />
<p>이 모듈은 표준 파이썬 코덱(인코더와 디코더)의 베이스 클래스를 정의하고, 코덱과 에러 처리 조회 프로세스를 관리하는 내부 파이썬 코덱 레지스트리에 대한 액세스를 제공합니다. 대부분의 표준 코덱은 텍스트를 바이트열로 인코딩하는 <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>이지만, 텍스트를 텍스트로 인코딩하고 바이트열을 바이트열로 인코딩하는 코덱도 제공됩니다. 사용자 정의 코덱은 임의 형 간에 인코딩과 디코딩 할 수 있지만, 일부 모듈 기능은 <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>이나 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>로 인코딩하는 코덱과 함께 사용하도록 특별히 제한됩니다.</p>
<p>이 모듈은 임의의 코덱으로 인코딩과 디코딩하는 다음 함수를 정의합니다:</p>
<dl class="function">
<dt id="codecs.encode">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">encode</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.encode" title="정의 주소">¶</a></dt>
<dd><p><em>encoding</em>을 위해 등록된 코덱을 사용하여 <em>obj</em>를 인코딩합니다.</p>
<p>원하는 에러 처리 방식을 설정하기 위해 <em>errors</em>가 주어질 수 있습니다. 기본 에러 처리기는 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>이며 인코딩 에러가 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>(또는 <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a> 와 같은 더 많은 코덱 관련 서브 클래스)를 발생시킨다는 뜻입니다. 코덱 에러 처리에 대한 자세한 내용은 <a class="reference internal" href="#codec-base-classes"><span class="std std-ref">코덱 베이스 클래스</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.decode">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">decode</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.decode" title="정의 주소">¶</a></dt>
<dd><p><em>encoding</em>을 위해 등록된 코덱을 사용하여 <em>obj</em>를 디코딩합니다.</p>
<p>원하는 에러 처리 방식을 설정하기 위해 <em>errors</em>가 주어질 수 있습니다. 기본 에러 처리기는 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>이며 디코딩 에러가 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> (또는 <a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a> 와 같은 더 많은 코덱 관련 서브 클래스)를 발생시킨다는 뜻입니다. 코덱 에러 처리에 대한 자세한 내용은 <a class="reference internal" href="#codec-base-classes"><span class="std std-ref">코덱 베이스 클래스</span></a>를 참조하십시오.</p>
</dd></dl>

<p>각 코덱에 대한 자세한 내용도 직접 확인할 수 있습니다:</p>
<dl class="function">
<dt id="codecs.lookup">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">lookup</code><span class="sig-paren">(</span><em class="sig-param">encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.lookup" title="정의 주소">¶</a></dt>
<dd><p>파이썬 코덱 레지스트리에서 코덱 정보를 조회하고 아래 정의된 <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code></a> 객체를 반환합니다.</p>
<p>인코딩은 먼저 레지스트리 캐시에서 조회됩니다. 찾을 수 없으면, 등록된 검색 함수 리스트를 탐색합니다. <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code></a> 객체가 없으면, <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>가 발생합니다. 그렇지 않으면, <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code></a> 객체가 캐시에 저장되고 호출자에게 반환됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="codecs.CodecInfo">
<em class="property">class </em><code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">CodecInfo</code><span class="sig-paren">(</span><em class="sig-param">encode</em>, <em class="sig-param">decode</em>, <em class="sig-param">streamreader=None</em>, <em class="sig-param">streamwriter=None</em>, <em class="sig-param">incrementalencoder=None</em>, <em class="sig-param">incrementaldecoder=None</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.CodecInfo" title="정의 주소">¶</a></dt>
<dd><p>코덱 레지스트리를 조회할 때의 코덱 세부 정보. 생성자 인자는 같은 이름의 어트리뷰트에 저장됩니다:</p>
<dl class="attribute">
<dt id="codecs.CodecInfo.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#codecs.CodecInfo.name" title="정의 주소">¶</a></dt>
<dd><p>인코딩의 이름.</p>
</dd></dl>

<dl class="attribute">
<dt id="codecs.CodecInfo.encode">
<code class="sig-name descname">encode</code><a class="headerlink" href="#codecs.CodecInfo.encode" title="정의 주소">¶</a></dt>
<dt id="codecs.CodecInfo.decode">
<code class="sig-name descname">decode</code><a class="headerlink" href="#codecs.CodecInfo.decode" title="정의 주소">¶</a></dt>
<dd><p>상태 없는 인코딩과 디코딩 함수. 이들은 코덱 인스턴스의 <a class="reference internal" href="#codecs.Codec.encode" title="codecs.Codec.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a>와 <a class="reference internal" href="#codecs.Codec.decode" title="codecs.Codec.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> 메서드와 같은 인터페이스를 갖는 함수나 메서드여야 합니다 (<a class="reference internal" href="#codec-objects"><span class="std std-ref">코덱 인터페이스</span></a>를 참조하십시오). 함수나 메서드는 상태 없는 모드로 작동할 것으로 기대됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="codecs.CodecInfo.incrementalencoder">
<code class="sig-name descname">incrementalencoder</code><a class="headerlink" href="#codecs.CodecInfo.incrementalencoder" title="정의 주소">¶</a></dt>
<dt id="codecs.CodecInfo.incrementaldecoder">
<code class="sig-name descname">incrementaldecoder</code><a class="headerlink" href="#codecs.CodecInfo.incrementaldecoder" title="정의 주소">¶</a></dt>
<dd><p>증분형 인코더와 디코더 클래스 또는 팩토리 함수. 이들은 각각 베이스 클래스 <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a>와 <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a>가 정의하는 인터페이스를 제공해야 합니다. 증분 코덱은 상태를 유지할 수 있습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="codecs.CodecInfo.streamwriter">
<code class="sig-name descname">streamwriter</code><a class="headerlink" href="#codecs.CodecInfo.streamwriter" title="정의 주소">¶</a></dt>
<dt id="codecs.CodecInfo.streamreader">
<code class="sig-name descname">streamreader</code><a class="headerlink" href="#codecs.CodecInfo.streamreader" title="정의 주소">¶</a></dt>
<dd><p>스트림 기록기와 판독기 클래스 또는 팩토리 함수. 이들은 각각 베이스 클래스 <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>와 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>가 정의하는 인터페이스를 제공해야 합니다. 스트림 코덱은 상태를 유지할 수 있습니다.</p>
</dd></dl>

</dd></dl>

<p>다양한 코덱 구성 요소에 대한 액세스를 단순화하기 위해, 이 모듈은 코덱 조회에 <a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal notranslate"><span class="pre">lookup()</span></code></a>을 사용하는 다음과 같은 추가 함수를 제공합니다:</p>
<dl class="function">
<dt id="codecs.getencoder">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">getencoder</code><span class="sig-paren">(</span><em class="sig-param">encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getencoder" title="정의 주소">¶</a></dt>
<dd><p>주어진 인코딩에 대한 코덱을 찾아서 해당 인코더 함수를 반환합니다.</p>
<p>인코딩을 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getdecoder">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">getdecoder</code><span class="sig-paren">(</span><em class="sig-param">encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getdecoder" title="정의 주소">¶</a></dt>
<dd><p>주어진 인코딩에 대한 코덱을 찾아서 해당 디코더 함수를 반환합니다.</p>
<p>인코딩을 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getincrementalencoder">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">getincrementalencoder</code><span class="sig-paren">(</span><em class="sig-param">encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getincrementalencoder" title="정의 주소">¶</a></dt>
<dd><p>주어진 인코딩에 대한 코덱을 찾아서 증분 인코더 클래스나 팩토리 함수를 반환합니다.</p>
<p>인코딩을 찾을 수 없거나 코덱이 증분 인코더를 지원하지 않는 경우 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getincrementaldecoder">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">getincrementaldecoder</code><span class="sig-paren">(</span><em class="sig-param">encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getincrementaldecoder" title="정의 주소">¶</a></dt>
<dd><p>주어진 인코딩에 대한 코덱을 찾아서 증분 디코더 클래스나 팩토리 함수를 반환합니다.</p>
<p>인코딩을 찾을 수 없거나 코덱이 증분 디코더를 지원하지 않는 경우 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getreader">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">getreader</code><span class="sig-paren">(</span><em class="sig-param">encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getreader" title="정의 주소">¶</a></dt>
<dd><p>주어진 인코딩의 코덱을 찾아서 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> 클래스나 팩토리 함수를 반환합니다.</p>
<p>인코딩을 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getwriter">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">getwriter</code><span class="sig-paren">(</span><em class="sig-param">encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getwriter" title="정의 주소">¶</a></dt>
<dd><p>주어진 인코딩의 코덱을 찾아서 <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> 클래스나 팩토리 함수를 반환합니다.</p>
<p>인코딩을 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<p>적합한 코덱 검색 함수를 등록하여 사용자 정의 코덱을 사용할 수 있도록 합니다:</p>
<dl class="function">
<dt id="codecs.register">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">register</code><span class="sig-paren">(</span><em class="sig-param">search_function</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.register" title="정의 주소">¶</a></dt>
<dd><p>코덱 검색 함수를 등록합니다. 검색 함수는 모두 소문자로 이루어진 인코딩 이름인 하나의 인자를 취하고, <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code></a> 객체를 반환해야 합니다. 검색 함수가 주어진 인코딩을 찾지 못하면, <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환해야 합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>검색 함수 등록은 현재 되돌릴 수 없어서, 단위 테스트나 모듈 다시 로드하기와 같은 몇몇 경우에 문제를 일으킬 수 있습니다.</p>
</div>
</dd></dl>

<p>내장 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>과 관련 <a class="reference internal" href="io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 모듈은 인코딩된 텍스트 파일 작업에 권장되는 접근 방법이지만, 이 모듈은 바이너리 파일로 작업할 때 더 넓은 범위의 코덱을 사용할 수 있도록 하는 추가 유틸리티 함수와 클래스를 제공합니다:</p>
<dl class="function">
<dt id="codecs.open">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">mode='r'</em>, <em class="sig-param">encoding=None</em>, <em class="sig-param">errors='strict'</em>, <em class="sig-param">buffering=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.open" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>mode</em>를 사용하여 인코딩된 파일을 열고 투명한 인코딩/디코딩을 제공하는 <a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a> 의 인스턴스를 반환합니다. 기본 파일 모드는 <code class="docutils literal notranslate"><span class="pre">'r'</span></code>이고, 파일을 읽기 모드로 연다는 뜻입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>하부 인코딩된 파일은 항상 바이너리 모드로 열립니다. 읽기와 쓰기 시 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>의 자동 변환이 수행되지 않습니다. <em>mode</em> 인자는 내장 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 함수에 허용되는 모든 바이너리 모드일 수 있습니다; <code class="docutils literal notranslate"><span class="pre">'b'</span></code>가 자동으로 추가됩니다.</p>
</div>
<p><em>encoding</em>은 파일에 사용될 인코딩을 지정합니다. 바이트열에서 인코딩하고 바이트열로 디코딩하는 모든 인코딩이 허용되며, 파일 메서드가 지원하는 데이터형은 사용된 코덱에 따라 다릅니다.</p>
<p>에러 처리를 정의하기 위해 <em>errors</em>가 제공될 수 있습니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>이고 인코딩 에러가 발생하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p><em>buffering</em>은 내장 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 함수에서와 같은 의미입니다. 기본값은 -1이며 기본 버퍼 크기가 사용됨을 의미합니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.EncodedFile">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">EncodedFile</code><span class="sig-paren">(</span><em class="sig-param">file</em>, <em class="sig-param">data_encoding</em>, <em class="sig-param">file_encoding=None</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.EncodedFile" title="정의 주소">¶</a></dt>
<dd><p>투명한 트랜스코딩을 제공하는 <em>file</em>의 래핑 된 버전인 <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a> 인스턴스를 반환합니다. 래핑 된 버전이 닫힐 때 원본 파일이 닫힙니다.</p>
<p>래핑 된 파일에 기록된 데이터는 주어진 <em>data_encoding</em>에 따라 디코딩된 다음 <em>file_encoding</em>을 사용하여 바이트열로 원본 파일에 기록됩니다. 원본 파일에서 읽은 바이트열은 <em>file_encoding</em>에 따라 디코딩되며, 결과는 <em>data_encoding</em>을 사용하여 인코딩됩니다.</p>
<p><em>file_encoding</em>이 제공되지 않으면, 기본값은 <em>data_encoding</em>입니다.</p>
<p>에러 처리를 정의하기 위해 <em>errors</em>가 제공될 수 있습니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>이며, 인코딩 에러가 발생하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.iterencode">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">iterencode</code><span class="sig-paren">(</span><em class="sig-param">iterator</em>, <em class="sig-param">encoding</em>, <em class="sig-param">errors='strict'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.iterencode" title="정의 주소">¶</a></dt>
<dd><p>증분 인코더를 사용하여 <em>iterator</em>에서 제공하는 입력을 반복적으로 인코딩합니다. 이 함수는 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a>입니다. <em>errors</em> 인자(다른 키워드 인자뿐만 아니라)는 증분 인코더로 전달됩니다.</p>
<p>이 함수를 사용하려면 코덱에서 인코딩할 텍스트 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체를 허용해야 합니다. 따라서 <code class="docutils literal notranslate"><span class="pre">base64_codec</span></code>과 같은 바이트열-바이트열 인코더는 지원하지 않습니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.iterdecode">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">iterdecode</code><span class="sig-paren">(</span><em class="sig-param">iterator</em>, <em class="sig-param">encoding</em>, <em class="sig-param">errors='strict'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.iterdecode" title="정의 주소">¶</a></dt>
<dd><p>증분 디코더를 사용하여 <em>iterator</em>에서 제공하는 입력을 반복적으로 디코딩합니다. 이 함수는 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a>입니다. <em>errors</em> 인자(다른 키워드 인자뿐만 아니라)는 증분 디코더로 전달됩니다.</p>
<p>이 함수를 사용하려면 코덱에서 디코딩할 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체를 허용해야 합니다. 따라서 <code class="docutils literal notranslate"><span class="pre">rot_13</span></code>이 <a class="reference internal" href="#codecs.iterencode" title="codecs.iterencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">iterencode()</span></code></a>로 동등하게 사용될 수 있지만, <code class="docutils literal notranslate"><span class="pre">rot_13</span></code>과 같은 텍스트-텍스트 인코더는 지원하지 않습니다.</p>
</dd></dl>

<p>이 모듈은 또한 플랫폼 종속 파일을 읽고 쓰는 데 유용한 다음 상수를 제공합니다:</p>
<dl class="data">
<dt id="codecs.BOM">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM</code><a class="headerlink" href="#codecs.BOM" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_BE">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_BE</code><a class="headerlink" href="#codecs.BOM_BE" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_LE">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_LE</code><a class="headerlink" href="#codecs.BOM_LE" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_UTF8">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_UTF8</code><a class="headerlink" href="#codecs.BOM_UTF8" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_UTF16">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_UTF16</code><a class="headerlink" href="#codecs.BOM_UTF16" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_UTF16_BE">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_UTF16_BE</code><a class="headerlink" href="#codecs.BOM_UTF16_BE" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_UTF16_LE">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_UTF16_LE</code><a class="headerlink" href="#codecs.BOM_UTF16_LE" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_UTF32">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_UTF32</code><a class="headerlink" href="#codecs.BOM_UTF32" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_UTF32_BE">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_UTF32_BE</code><a class="headerlink" href="#codecs.BOM_UTF32_BE" title="정의 주소">¶</a></dt>
<dt id="codecs.BOM_UTF32_LE">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">BOM_UTF32_LE</code><a class="headerlink" href="#codecs.BOM_UTF32_LE" title="정의 주소">¶</a></dt>
<dd><p>이 상수는 여러 인코딩에서 유니코드 바이트 순서 표시(BOM)인 다양한 바이트 시퀀스를 정의합니다. UTF-16과 UTF-32 데이터 스트림에서 사용된 바이트 순서를 나타내는 데 사용되며, UTF-8에서 유니코드 서명으로 사용됩니다. <a class="reference internal" href="#codecs.BOM_UTF16" title="codecs.BOM_UTF16"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16</span></code></a>은 플랫폼의 네이티브 바이트 순서에 따라 <a class="reference internal" href="#codecs.BOM_UTF16_BE" title="codecs.BOM_UTF16_BE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_BE</span></code></a>나 <a class="reference internal" href="#codecs.BOM_UTF16_LE" title="codecs.BOM_UTF16_LE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_LE</span></code></a>이며, <a class="reference internal" href="#codecs.BOM" title="codecs.BOM"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM</span></code></a>은 <a class="reference internal" href="#codecs.BOM_UTF16" title="codecs.BOM_UTF16"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16</span></code></a>의 별칭, <a class="reference internal" href="#codecs.BOM_LE" title="codecs.BOM_LE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_LE</span></code></a>는 <a class="reference internal" href="#codecs.BOM_UTF16_LE" title="codecs.BOM_UTF16_LE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_LE</span></code></a>의 별칭, <a class="reference internal" href="#codecs.BOM_BE" title="codecs.BOM_BE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_BE</span></code></a>는 <a class="reference internal" href="#codecs.BOM_UTF16_BE" title="codecs.BOM_UTF16_BE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_BE</span></code></a>의 별칭입니다. 다른 것은 UTF-8과 UTF-32 인코딩에서 BOM을 나타냅니다.</p>
</dd></dl>

<div class="section" id="codec-base-classes">
<span id="id1"></span><h2>코덱 베이스 클래스<a class="headerlink" href="#codec-base-classes" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> 모듈은 코덱 객체로 작업하기 위한 인터페이스를 정의하는 베이스 클래스 집합을 정의하며, 사용자 정의 코덱 구현의 기초로 사용될 수도 있습니다.</p>
<p>각 코덱은 파이썬에서 코덱으로 사용할 수 있도록 네 가지 인터페이스를 정의해야 합니다: 상태 없는 인코더, 상태 없는 디코더, 스트림 판독기 및 스트림 기록기. 스트림 판독기와 기록기는 일반적으로 상태 없는 인코더/디코더를 재사용하여 파일 프로토콜을 구현합니다. 코덱 작성자는 코덱에서 인코딩과 디코딩 에러를 처리하는 방법도 정의해야 합니다.</p>
<div class="section" id="error-handlers">
<span id="surrogateescape"></span><span id="id2"></span><h3>에러 처리기<a class="headerlink" href="#error-handlers" title="제목 주소">¶</a></h3>
<p>에러 처리를 단순화하고 표준화하기 위해, 코덱은 <em>errors</em> 문자열 인자를 받아들여 다른 에러 처리 체계를 구현할 수 있습니다. 다음 문자열 값은 모든 표준 파이썬 코덱에서 정의되고 구현됩니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>값</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'strict'</span></code></p></td>
<td><p><a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>(또는 서브 클래스)를 발생시킵니다; 이것이 기본값입니다. <a class="reference internal" href="#codecs.strict_errors" title="codecs.strict_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">strict_errors()</span></code></a>에서 구현되었습니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code></p></td>
<td><p>잘못된 데이터를 무시하고 추가 통지 없이 계속 진행합니다. <a class="reference internal" href="#codecs.ignore_errors" title="codecs.ignore_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">ignore_errors()</span></code></a>에서 구현되었습니다.</p></td>
</tr>
</tbody>
</table>
<p>다음 에러 처리기는 <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>에만 적용됩니다:</p>
<table class="docutils align-default" id="index-1">
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>값</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'replace'</span></code></p></td>
<td><p>적절한 교체 마커로 교체합니다; 파이썬은 내장 코덱에 디코딩 시 공식 <code class="docutils literal notranslate"><span class="pre">U+FFFD</span></code> REPLACEMENT CHARACTER를, 인코딩 시 '?'를 사용합니다. <a class="reference internal" href="#codecs.replace_errors" title="codecs.replace_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">replace_errors()</span></code></a>에서 구현되었습니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code></p></td>
<td><p>적절한 XML 문자 참조로 교체합니다 (인코딩에만 해당합니다). <a class="reference internal" href="#codecs.xmlcharrefreplace_errors" title="codecs.xmlcharrefreplace_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">xmlcharrefreplace_errors()</span></code></a>에서 구현되었습니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code></p></td>
<td><p>역 슬래시 이스케이프 시퀀스로 교체합니다. <a class="reference internal" href="#codecs.backslashreplace_errors" title="codecs.backslashreplace_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">backslashreplace_errors()</span></code></a>에서 구현되었습니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\N{...}</span></code> 이스케이프 시퀀스로 교체합니다 (인코딩에만 해당합니다). <a class="reference internal" href="#codecs.namereplace_errors" title="codecs.namereplace_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">namereplace_errors()</span></code></a>에서 구현되었습니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code></p></td>
<td><p>디코딩 시, 바이트를 <code class="docutils literal notranslate"><span class="pre">U+DC80</span></code>에서 <code class="docutils literal notranslate"><span class="pre">U+DCFF</span></code> 범위의 개별 서로게이트 코드(surrogate code)로 바꿉니다. 이 코드는 데이터를 인코딩할 때 <code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code> 에러 처리기가 사용되면 같은 바이트로 다시 변환됩니다. (자세한 내용은 <span class="target" id="index-20"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a>을 참조하십시오.)</p></td>
</tr>
</tbody>
</table>
<p>또한, 다음 에러 처리기는 지정된 코덱에만 적용됩니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 28%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>값</p></th>
<th class="head"><p>코덱</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'surrogatepass'</span></code></p></td>
<td><p>utf-8, utf-16, utf-32,
utf-16-be, utf-16-le,
utf-32-be, utf-32-le</p></td>
<td><p>서로게이트 코드의 인코딩과 디코딩을 허용합니다. 이 코덱들은 일반적으로 서로게이트의 존재를 에러로 취급합니다.</p></td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가: </span><code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code>와 <code class="docutils literal notranslate"><span class="pre">'surrogatepass'</span></code> 에러 처리기.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'surrogatepass'</span></code> 에러 처리기는 이제 utf-16* 와 utf-32* 코덱에서 작동합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가: </span><code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code> 에러 처리기.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> 에러 처리기는 이제 디코딩과 변환(translating)에서 작동합니다.</p>
</div>
<p>새 이름으로 에러 처리기를 등록하여 허용되는 값 집합을 확장할 수 있습니다:</p>
<dl class="function">
<dt id="codecs.register_error">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">register_error</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">error_handler</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.register_error" title="정의 주소">¶</a></dt>
<dd><p>에러 처리 함수 <em>error_handler</em>를 <em>name</em>이라는 이름으로 등록합니다. <em>error_handler</em> 인자는 <em>name</em>이 errors 매개 변수로 지정될 때, 인코딩과 디코딩 중에 에러가 있으면 호출됩니다.</p>
<p>인코딩의 경우, 에러 위치에 대한 정보가 포함된 <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a> 인스턴스와 함께 <em>error_handler</em>가 호출됩니다. 에러 처리기는 이 예외나 다른 예외를 발생시키거나, 입력의 인코딩할 수 없는 부분의 대체 값과 인코딩을 계속할 위치를 담은 튜플을 반환해야 합니다. 대체 값은 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>이나 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>일 수 있습니다. 대체 값이 바이트열이면, 인코더는 이를 단순히 출력 버퍼에 복사합니다. 대체 값이 문자열이면, 인코더는 대체 값을 인코딩합니다. 지정된 위치에서 원래 입력으로 인코딩이 계속됩니다. 음수 위칫값은 입력 문자열의 끝을 기준으로 처리됩니다. 결과 위치가 범위를 벗어나면 <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>가 발생합니다.</p>
<p><a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a> 나 <a class="reference internal" href="exceptions.html#UnicodeTranslateError" title="UnicodeTranslateError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeTranslateError</span></code></a> 가 처리기로 전달되고 에러 처리기의 대체 값을 출력에 직접 넣는다는 점을 제외하면, 디코딩과 변환(translating)은 비슷하게 작동합니다.</p>
</dd></dl>

<p>이전에 등록된 에러 처리기(표준 에러 처리기를 포함하여)는 이름으로 조회할 수 있습니다:</p>
<dl class="function">
<dt id="codecs.lookup_error">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">lookup_error</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.lookup_error" title="정의 주소">¶</a></dt>
<dd><p><em>name</em>이라는 이름으로 이전에 등록된 에러 처리기를 반환합니다.</p>
<p>처리기를 찾을 수 없으면 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<p>다음과 같은 표준 에러 처리기가 모듈 수준 함수로 제공됩니다:</p>
<dl class="function">
<dt id="codecs.strict_errors">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">strict_errors</code><span class="sig-paren">(</span><em class="sig-param">exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.strict_errors" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'strict'</span></code> 에러 처리를 구현합니다: 각 인코딩이나 디코딩 에러는 <a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.replace_errors">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">replace_errors</code><span class="sig-paren">(</span><em class="sig-param">exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.replace_errors" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'replace'</span></code> 에러 처리를 구현합니다 (<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a> 전용): 인코딩 에러를 <code class="docutils literal notranslate"><span class="pre">'?'</span></code>로 대체하고 (코덱으로 인코딩됩니다), 디코딩 에러를 <code class="docutils literal notranslate"><span class="pre">'\ufffd'</span></code>(유니코드 대체 문자)로 대체합니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.ignore_errors">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">ignore_errors</code><span class="sig-paren">(</span><em class="sig-param">exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.ignore_errors" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> 에러 처리를 구현합니다: 잘못된 형식의 데이터는 무시되고 추가 통지 없이 인코딩이나 디코딩이 계속됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.xmlcharrefreplace_errors">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">xmlcharrefreplace_errors</code><span class="sig-paren">(</span><em class="sig-param">exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.xmlcharrefreplace_errors" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code> 에러 처리를 구현합니다 (<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>으로 인코딩하는 경우에만 해당): 인코드할 수 없는 문자는 적절한 XML 문자 참조로 대체됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.backslashreplace_errors">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">backslashreplace_errors</code><span class="sig-paren">(</span><em class="sig-param">exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.backslashreplace_errors" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> 에러 처리를 구현합니다 (<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a> 전용): 잘못된 형식의 데이터는 역 슬래시 이스케이프 시퀀스로 대체됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.namereplace_errors">
<code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">namereplace_errors</code><span class="sig-paren">(</span><em class="sig-param">exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.namereplace_errors" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code> 에러 처리를 구현합니다 (<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>으로 인코딩하는 경우에만 해당): 인코드할 수 없는 문자는 <code class="docutils literal notranslate"><span class="pre">\N{...}</span></code> 이스케이프 시퀀스로 대체됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="stateless-encoding-and-decoding">
<span id="codec-objects"></span><h3>상태 없는 인코딩과 디코딩<a class="headerlink" href="#stateless-encoding-and-decoding" title="제목 주소">¶</a></h3>
<p>기본 <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> 클래스는 다음과 같은 메서드를 정의하는데, 상태 없는 인코더와 디코더의 함수 인터페이스를 정의하기도 합니다:</p>
<dl class="method">
<dt id="codecs.Codec.encode">
<code class="sig-prename descclassname">Codec.</code><code class="sig-name descname">encode</code><span class="sig-paren">(</span><em class="sig-param">input</em><span class="optional">[</span>, <em class="sig-param">errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.Codec.encode" title="정의 주소">¶</a></dt>
<dd><p>객체 <em>input</em>을 인코딩하고 튜플(출력 객체, 소비한 길이)을 반환합니다. 예를 들어, <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>은 특정 문자 집합 인코딩 (예를 들어, <code class="docutils literal notranslate"><span class="pre">cp1252</span></code>나 <code class="docutils literal notranslate"><span class="pre">iso-8859-1</span></code>)을 사용하여 문자열 객체를 바이트열 객체로 변환합니다.</p>
<p><em>errors</em> 인자는 적용할 에러 처리를 정의합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code> 처리입니다.</p>
<p>이 메서드는 <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> 인스턴스에 상태를 저장하지 않을 수 있습니다. 인코딩 효율을 높이기 위해 상태를 유지해야 하는 코덱에서는 <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>를 사용하십시오.</p>
<p>인코더는 길이가 0인 입력을 처리하고 이 상황에서는 출력 객체 형의 빈 객체를 반환할 수 있어야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.Codec.decode">
<code class="sig-prename descclassname">Codec.</code><code class="sig-name descname">decode</code><span class="sig-paren">(</span><em class="sig-param">input</em><span class="optional">[</span>, <em class="sig-param">errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.Codec.decode" title="정의 주소">¶</a></dt>
<dd><p>객체 <em>input</em>을 디코딩하고 튜플 (출력 객체, 소비한 길이)를 반환합니다. 예를 들어, <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>의 경우, 디코딩은 특정 문자 집합 인코딩을 사용하여 인코딩된 바이트열 객체를 문자열 객체로 변환합니다.</p>
<p>텍스트 인코딩과 바이트열-바이트열 코덱의 경우, <em>input</em>은 바이트열 객체이거나 읽기 전용 버퍼 인터페이스를 제공하는 객체여야 합니다 -- 예를 들어, 버퍼 객체와 및 메모리 맵핑 파일.</p>
<p><em>errors</em> 인자는 적용할 에러 처리를 정의합니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code> 처리입니다.</p>
<p>이 메서드는 <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> 인스턴스에 상태를 저장하지 않을 수 있습니다. 디코딩 효율을 높이기 위해 상태를 유지해야 하는 코덱에서는 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>를 사용하십시오.</p>
<p>디코더는 길이가 0인 입력을 처리하고 이 상황에서 출력 객체 형의 빈 객체를 반환할 수 있어야 합니다.</p>
</dd></dl>

</div>
<div class="section" id="incremental-encoding-and-decoding">
<h3>증분 인코딩과 디코딩<a class="headerlink" href="#incremental-encoding-and-decoding" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a>와 <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> 클래스는 증분 인코딩과 디코딩을 위한 기본 인터페이스를 제공합니다. 입력을 인코딩/디코딩하는 것이 상태 없는 인코더/디코더 함수를 한 번 호출하는 것이 아니라, 증분 인코더/디코더의 <a class="reference internal" href="#codecs.IncrementalEncoder.encode" title="codecs.IncrementalEncoder.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a>/<a class="reference internal" href="#codecs.IncrementalDecoder.decode" title="codecs.IncrementalDecoder.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> 메서드를 여러 번 호출하여 수행됩니다. 증분 인코더/디코더는 메서드 호출 중에 인코딩/디코딩 프로세스를 추적합니다.</p>
<p><a class="reference internal" href="#codecs.IncrementalEncoder.encode" title="codecs.IncrementalEncoder.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a>/<a class="reference internal" href="#codecs.IncrementalDecoder.decode" title="codecs.IncrementalDecoder.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> 메서드에 대한 호출의 연결된 출력은 모든 단일 입력을 하나로 결합하여 상태 없는 인코더/디코더로 인코딩/디코딩되는 것과 같습니다.</p>
<div class="section" id="incrementalencoder-objects">
<span id="incremental-encoder-objects"></span><h4>IncrementalEncoder 객체<a class="headerlink" href="#incrementalencoder-objects" title="제목 주소">¶</a></h4>
<p><a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> 클래스는 여러 단계로 입력을 인코딩하는 데 사용됩니다. 파이썬 코덱 레지스트리와 호환되도록 모든 증분 인코더가 정의해야 하는 다음 메서드를 정의합니다.</p>
<dl class="class">
<dt id="codecs.IncrementalEncoder">
<em class="property">class </em><code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">IncrementalEncoder</code><span class="sig-paren">(</span><em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> 인스턴스의 생성자.</p>
<p>모든 증분 인코더는 이 생성자 인터페이스를 제공해야 합니다. 추가 키워드 인자를 자유롭게 추가할 수 있지만, 여기에 정의된 키워드 인자만 파이썬 코덱 레지스트리에서 사용됩니다.</p>
<p><a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a>는 <em>errors</em> 키워드 인자를 제공하여 다른 에러 처리 체계를 구현할 수 있습니다. 가능한 값은 <a class="reference internal" href="#error-handlers"><span class="std std-ref">에러 처리기</span></a>를 참조하십시오.</p>
<p><em>errors</em> 인자는 같은 이름의 어트리뷰트에 대입됩니다. 이 어트리뷰트에 대입하면 <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> 객체의 수명 동안 다른 에러 처리 전략 간에 전환할 수 있습니다.</p>
<dl class="method">
<dt id="codecs.IncrementalEncoder.encode">
<code class="sig-name descname">encode</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="optional">[</span>, <em class="sig-param">final</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.encode" title="정의 주소">¶</a></dt>
<dd><p><em>object</em>를 (인코더의 현재 상태를 고려하여) 인코딩하고 결과 인코딩된 객체를 반환합니다. 이것이 <a class="reference internal" href="#codecs.encode" title="codecs.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a>에 대한 마지막 호출이면 <em>final</em>은 참이어야 합니다 (기본값은 거짓).</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalEncoder.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.reset" title="정의 주소">¶</a></dt>
<dd><p>인코더를 초기 상태로 재설정합니다. 출력은 버려집니다: 인코더를 재설정하고 출력을 얻으려면, 필요하면 빈 바이트열이나 텍스트 문자열을 전달하여, <code class="docutils literal notranslate"><span class="pre">.encode(object,</span> <span class="pre">final=True)</span></code>를 호출하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalEncoder.getstate">
<code class="sig-name descname">getstate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.getstate" title="정의 주소">¶</a></dt>
<dd><p>인코더의 현재 상태를 반환하는데, 정수여야 합니다. 구현은 <code class="docutils literal notranslate"><span class="pre">0</span></code>이 가장 흔한 상태가 되도록 해야 합니다. (정수보다 복잡한 상태는 상태를 마샬링/피클링하고 결과 문자열의 바이트열을 정수로 인코딩하여 정수로 변환할 수 있습니다.)</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalEncoder.setstate">
<code class="sig-name descname">setstate</code><span class="sig-paren">(</span><em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.setstate" title="정의 주소">¶</a></dt>
<dd><p>인코더 상태를 <em>state</em>로 설정합니다. <em>state</em>는 <a class="reference internal" href="#codecs.IncrementalEncoder.getstate" title="codecs.IncrementalEncoder.getstate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getstate()</span></code></a>가 반환한 인코더 상태여야 합니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="incrementaldecoder-objects">
<span id="incremental-decoder-objects"></span><h4>IncrementalDecoder 객체<a class="headerlink" href="#incrementaldecoder-objects" title="제목 주소">¶</a></h4>
<p><a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> 클래스는 여러 단계로 입력을 디코딩하는 데 사용됩니다. 파이썬 코덱 레지스트리와 호환되도록 모든 증분 디코더에서 정의해야 하는 다음 메서드를 정의합니다.</p>
<dl class="class">
<dt id="codecs.IncrementalDecoder">
<em class="property">class </em><code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">IncrementalDecoder</code><span class="sig-paren">(</span><em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> 인스턴스의 생성자.</p>
<p>모든 증분 디코더는 이 생성자 인터페이스를 제공해야 합니다. 추가 키워드 인자를 자유롭게 추가할 수 있지만, 여기에 정의된 키워드 인자만 파이썬 코덱 레지스트리에서 사용됩니다.</p>
<p><a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a>는 <em>errors</em> 키워드 인자를 제공하여 다른 에러 처리 체계를 구현할 수 있습니다. 가능한 값은 <a class="reference internal" href="#error-handlers"><span class="std std-ref">에러 처리기</span></a>를 참조하십시오.</p>
<p><em>errors</em> 인자는 같은 이름의 어트리뷰트에 대입됩니다. 이 어트리뷰트에 대입하면 <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> 객체의 수명 동안 다른 에러 처리 전략 간에 전환할 수 있습니다.</p>
<dl class="method">
<dt id="codecs.IncrementalDecoder.decode">
<code class="sig-name descname">decode</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="optional">[</span>, <em class="sig-param">final</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.decode" title="정의 주소">¶</a></dt>
<dd><p><em>object</em>를 디코딩하고 (디코더의 현재 상태를 고려하여) 결과 디코딩된 객체를 반환합니다. 이것이 <a class="reference internal" href="#codecs.decode" title="codecs.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a>에 대한 마지막 호출이면 <em>final</em>은 참이어야 합니다 (기본값은 거짓). <em>final</em>이 참이면 디코더는 입력을 완전히 디코딩해야 하며 모든 버퍼를 플러시 해야 합니다. 이것이 가능하지 않으면 (예를 들어 입력 끝의 불완전한 바이트 시퀀스로 인해), 상태 없는 경우와 같이 에러 처리를 시작해야 합니다 (예외가 발생시킬 수 있습니다).</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalDecoder.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.reset" title="정의 주소">¶</a></dt>
<dd><p>디코더를 초기 상태로 재설정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalDecoder.getstate">
<code class="sig-name descname">getstate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.getstate" title="정의 주소">¶</a></dt>
<dd><p>디코더의 현재 상태를 반환합니다. 두 항목이 있는 튜플이어야 하며, 첫 번째는 여전히 디코딩되지 않은 입력을 포함하는 버퍼여야 합니다. 두 번째는 정수여야 하며 추가 상태 정보일 수 있습니다. (구현은 <code class="docutils literal notranslate"><span class="pre">0</span></code>이 가장 흔한 추가 상태 정보가 되도록 해야 합니다.) 이 추가 상태 정보가 <code class="docutils literal notranslate"><span class="pre">0</span></code>이면, 입력 버퍼가 없고 추가 상태 정보가 <code class="docutils literal notranslate"><span class="pre">0</span></code>인 상태로 디코더를 설정할 수 있어서, 이전에 버퍼링 된 입력을 디코더에 공급하면 출력을 생성하지 않고 이전 상태로 되돌아갈 수 있어야 합니다. (정수보다 복잡한 추가 상태 정보는 정보를 마샬링/피클링하고 결과 문자열의 바이트를 정수로 인코딩하여 정수로 변환할 수 있습니다.)</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalDecoder.setstate">
<code class="sig-name descname">setstate</code><span class="sig-paren">(</span><em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.setstate" title="정의 주소">¶</a></dt>
<dd><p>디코더의 상태를 <em>state</em>로 설정합니다. <em>state</em>는 <a class="reference internal" href="#codecs.IncrementalDecoder.getstate" title="codecs.IncrementalDecoder.getstate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getstate()</span></code></a>가 반환한 디코더 상태여야 합니다.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="stream-encoding-and-decoding">
<h3>스트림 인코딩과 디코딩<a class="headerlink" href="#stream-encoding-and-decoding" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>와 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> 클래스는 새로운 인코딩 서브 모듈을 매우 쉽게 구현하는 데 사용할 수 있는 범용 작업 인터페이스를 제공합니다. 이를 수행하는 방법에 대한 예는 <code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.utf_8</span></code>을 참조하십시오.</p>
<div class="section" id="streamwriter-objects">
<span id="stream-writer-objects"></span><h4>StreamWriter 객체<a class="headerlink" href="#streamwriter-objects" title="제목 주소">¶</a></h4>
<p><a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> 클래스는 <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code>의 서브 클래스이며 파이썬 코덱 레지스트리와 호환되도록 모든 스트림 기록기가 정의해야 하는 다음 메서드를 정의합니다.</p>
<dl class="class">
<dt id="codecs.StreamWriter">
<em class="property">class </em><code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">StreamWriter</code><span class="sig-paren">(</span><em class="sig-param">stream</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> 인스턴스의 생성자.</p>
<p>모든 스트림 기록기는 이 생성자 인터페이스를 제공해야 합니다. 추가 키워드 인자를 자유롭게 추가할 수 있지만, 여기에 정의된 키워드 인자만 파이썬 코덱 레지스트리에서 사용됩니다.</p>
<p><em>stream</em> 인자는 특정 코덱에 적합하도록 텍스트나 바이너리 데이터를 쓰기 위해 열린 파일류 객체여야 합니다.</p>
<p><a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>는 <em>errors</em> 키워드 인자를 제공하여 다른 에러 처리 체계를 구현할 수 있습니다. 하부 스트림 코덱이 지원할 수 있는 표준 에러 처리기에 대해서는 <a class="reference internal" href="#error-handlers"><span class="std std-ref">에러 처리기</span></a>를 참조하십시오.</p>
<p><em>errors</em> 인자는 같은 이름의 어트리뷰트에 대입됩니다. 이 어트리뷰트에 대입하면 <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> 객체의 수명 동안 다른 에러 처리 전략 간에 전환할 수 있습니다.</p>
<dl class="method">
<dt id="codecs.StreamWriter.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.write" title="정의 주소">¶</a></dt>
<dd><p>스트림에 인코딩된 객체의 내용을 씁니다.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamWriter.writelines">
<code class="sig-name descname">writelines</code><span class="sig-paren">(</span><em class="sig-param">list</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.writelines" title="정의 주소">¶</a></dt>
<dd><p>이어붙인 문자열 리스트를 스트림에 씁니다 (<a class="reference internal" href="#codecs.StreamWriter.write" title="codecs.StreamWriter.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> 메서드를 재사용할 수 있습니다). 표준 바이트열-바이트열 코덱은 이 메서드를 지원하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamWriter.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.reset" title="정의 주소">¶</a></dt>
<dd><p>Resets the codec buffers used for keeping internal state.</p>
<p>이 메서드를 호출하면 출력의 데이터가 깨끗한 상태가 되어 상태를 복구하기 위해 전체 스트림을 다시 스캔하지 않고도 새로운 최신 데이터를 추가할 수 있도록 합니다.</p>
</dd></dl>

</dd></dl>

<p>위의 메서드 외에도, <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>는 하부 스트림에서 온 다른 모든 메서드와 어트리뷰트를 상속해야 합니다.</p>
</div>
<div class="section" id="streamreader-objects">
<span id="stream-reader-objects"></span><h4>StreamReader 객체<a class="headerlink" href="#streamreader-objects" title="제목 주소">¶</a></h4>
<p><a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> 클래스는 <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code>의 서브 클래스이며 파이썬 코덱 레지스트리와 호환되도록 모든 스트림 판독기가 정의해야 하는 다음 메서드를 정의합니다.</p>
<dl class="class">
<dt id="codecs.StreamReader">
<em class="property">class </em><code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">StreamReader</code><span class="sig-paren">(</span><em class="sig-param">stream</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> 인스턴스의 생성자.</p>
<p>모든 스트림 판독기는 이 생성자 인터페이스를 제공해야 합니다. 추가 키워드 인자를 자유롭게 추가할 수 있지만, 여기에 정의된 키워드 인자만 파이썬 코덱 레지스트리에서 사용됩니다.</p>
<p><em>stream</em> 인자는 특정 코덱에 적합하게 텍스트나 바이너리 데이터를 읽기 위해 열린 파일류 객체여야 합니다.</p>
<p><a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>는 <em>errors</em> 키워드 인자를 제공하여 다른 에러 처리 체계를 구현할 수 있습니다. 하부 스트림 코덱이 지원할 수 있는 표준 에러 처리기에 대해서는 <a class="reference internal" href="#error-handlers"><span class="std std-ref">에러 처리기</span></a>를 참조하십시오.</p>
<p><em>errors</em> 인자는 같은 이름의 어트리뷰트에 대입됩니다. 이 어트리뷰트에 대입하면 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> 객체의 수명 동안 다른 에러 처리 전략 간에 전환할 수 있습니다.</p>
<p><em>errors</em> 인자에 허용되는 값 집합은 <a class="reference internal" href="#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_error()</span></code></a>로 확장될 수 있습니다.</p>
<dl class="method">
<dt id="codecs.StreamReader.read">
<code class="sig-name descname">read</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">size</em><span class="optional">[</span>, <em class="sig-param">chars</em><span class="optional">[</span>, <em class="sig-param">firstline</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.read" title="정의 주소">¶</a></dt>
<dd><p>스트림에서 데이터를 디코딩하고 결과 객체를 반환합니다.</p>
<p><em>chars</em> 인자는 반환할 디코딩 된 코드 포인트나 바이트의 수를 나타냅니다. <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-func docutils literal notranslate"><span class="pre">read()</span></code></a> 메서드는 요청된 것보다 더 많은 데이터를 반환하지 않지만, 사용 가능한 것이 충분하지 않으면 더 적게 반환할 수 있습니다.</p>
<p><em>size</em> 인자는 디코딩을 위해 읽을 인코딩 된 바이트나 코드 포인트의 대략적인 최대 수를 나타냅니다. 디코더는 이 설정을 적절하게 수정할 수 있습니다. 기본값 -1은 가능한 한 많이 읽고 디코딩함을 나타냅니다. 이 매개 변수는 커다란 파일을 한 번에 디코딩하지 않도록 하기 위한 것입니다.</p>
<p><em>firstline</em> 플래그는 이후 줄에 디코딩 에러가 있으면 첫 번째 줄만 반환해도 충분함을 나타냅니다.</p>
<p>이 메서드는 탐욕스러운(greedy) 읽기 전략을 사용해야 합니다. 즉, 인코딩 정의와 주어진 size 내에서 허용되는 만큼 많은 데이터를 읽어야 합니다. 예를 들어 스트림에 선택적 인코딩 종료나 상태 마커가 있으면, 이것도 읽어야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamReader.readline">
<code class="sig-name descname">readline</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">size</em><span class="optional">[</span>, <em class="sig-param">keepends</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.readline" title="정의 주소">¶</a></dt>
<dd><p>입력 스트림에서 한 줄을 읽고 디코딩된 데이터를 반환합니다.</p>
<p>주어지면, <em>size</em>는 스트림의 <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> 메서드에 size 인자로 전달됩니다.</p>
<p><em>keepends</em>가 거짓이면 줄 종료가 반환된 줄에서 제거됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamReader.readlines">
<code class="sig-name descname">readlines</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">sizehint</em><span class="optional">[</span>, <em class="sig-param">keepends</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.readlines" title="정의 주소">¶</a></dt>
<dd><p>입력 스트림에서 사용 가능한 모든 줄을 읽고 줄의 리스트로 반환합니다.</p>
<p>줄 종료는 코덱의 <a class="reference internal" href="#codecs.decode" title="codecs.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> 메서드를 사용하여 구현되며 <em>keepends</em>가 참이면 리스트 항목에 포함됩니다.</p>
<p>주어지면, <em>sizehint</em>는 스트림의 <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> 메서드에 <em>size</em> 인자로 전달됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamReader.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.reset" title="정의 주소">¶</a></dt>
<dd><p>Resets the codec buffers used for keeping internal state.</p>
<p>스트림 위치 변경이 발생하지 않아야 함에 유의하십시오. 이 메서드는 주로 디코딩 에러에서 복구할 수 있도록 하기 위한 것입니다.</p>
</dd></dl>

</dd></dl>

<p>위의 메서드 외에도 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>는 하부 스트림에서 다른 모든 메서드와 어트리뷰트를 상속해야 합니다.</p>
</div>
<div class="section" id="streamreaderwriter-objects">
<span id="stream-reader-writer"></span><h4>StreamReaderWriter 객체<a class="headerlink" href="#streamreaderwriter-objects" title="제목 주소">¶</a></h4>
<p><a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a> 는 읽기와 쓰기 모드 모두에서 작동하는 스트림을 래핑하도록 하는 편의 클래스입니다.</p>
<p><a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal notranslate"><span class="pre">lookup()</span></code></a> 함수가 반환한 팩토리 함수를 사용하여 인스턴스를 구성할 수 있도록 설계되었습니다.</p>
<dl class="class">
<dt id="codecs.StreamReaderWriter">
<em class="property">class </em><code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">StreamReaderWriter</code><span class="sig-paren">(</span><em class="sig-param">stream</em>, <em class="sig-param">Reader</em>, <em class="sig-param">Writer</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReaderWriter" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a> 인스턴스를 만듭니다. <em>stream</em>은 파일류 객체여야 합니다. <em>Reader</em>와 <em>Writer</em>는 각각 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>와 <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> 인터페이스를 제공하는 팩토리 함수나 클래스여야 합니다. 에러 처리는 스트림 판독기와 기록기에 정의된 것과 같은 방식으로 수행됩니다.</p>
</dd></dl>

<p><a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a> 인스턴스는 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>와 <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> 클래스가 결합한 인터페이스를 정의합니다. 하부 스트림에서 다른 모든 메서드와 어트리뷰트를 상속합니다.</p>
</div>
<div class="section" id="streamrecoder-objects">
<span id="stream-recoder-objects"></span><h4>StreamRecoder 객체<a class="headerlink" href="#streamrecoder-objects" title="제목 주소">¶</a></h4>
<p><a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a>는 한 인코딩에서 다른 인코딩으로 데이터를 변환하는데, 이는 때때로 다른 인코딩 환경을 다룰 때 유용합니다.</p>
<p><a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal notranslate"><span class="pre">lookup()</span></code></a> 함수가 반환한 팩토리 함수를 사용하여 인스턴스를 구성할 수 있도록 설계되었습니다.</p>
<dl class="class">
<dt id="codecs.StreamRecoder">
<em class="property">class </em><code class="sig-prename descclassname">codecs.</code><code class="sig-name descname">StreamRecoder</code><span class="sig-paren">(</span><em class="sig-param">stream</em>, <em class="sig-param">encode</em>, <em class="sig-param">decode</em>, <em class="sig-param">Reader</em>, <em class="sig-param">Writer</em>, <em class="sig-param">errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamRecoder" title="정의 주소">¶</a></dt>
<dd><p>양방향 변환을 구현하는 <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a> 인스턴스를 만듭니다: <em>encode</em>와 <em>decode</em>는 프런트 엔드에 작동합니다 - <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code>와 <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>를 호출하는 코드가 보는 데이터, 반면에 <em>Reader</em>와 <em>Writer</em>는 백 엔드에 작동합니다 - <em>stream</em>의 데이터.</p>
<p>이러한 객체를 사용하여 투명한 트랜스코딩을 수행 할 수 있습니다, 예를 들어, Latin-1 에서 UTF-8로 또는 그 반대로.</p>
<p><em>stream</em> 인자는 파일류 객체여야 합니다.</p>
<p><em>encode</em>와 <em>decode</em> 인자는 <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> 인터페이스를 준수해야 합니다. <em>Reader</em>와 <em>Writer</em>는 각각 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>와 <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> 인터페이스의 객체를 제공하는 팩토리 함수나 클래스여야 합니다.</p>
<p>에러 처리는 스트림 판독기와 기록기에 정의된 것과 같은 방식으로 수행됩니다.</p>
</dd></dl>

<p><a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a> 인스턴스는 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>와 <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> 클래스가 결합한 인터페이스를 정의합니다. 하부 스트림에서 다른 모든 메서드와 어트리뷰트를 상속합니다.</p>
</div>
</div>
</div>
<div class="section" id="encodings-and-unicode">
<span id="encodings-overview"></span><h2>인코딩과 유니코드<a class="headerlink" href="#encodings-and-unicode" title="제목 주소">¶</a></h2>
<p>문자열은 <code class="docutils literal notranslate"><span class="pre">0x0</span></code>--<code class="docutils literal notranslate"><span class="pre">0x10FFFF</span></code> 범위의 코드 포인트 시퀀스로 내부적으로 저장됩니다. (구현에 대한 자세한 내용은 <span class="target" id="index-21"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0393"><strong>PEP 393</strong></a>을 참조하십시오.) 일단 문자열 객체가 CPU와 메모리 외부에서 사용되면, 엔디안(endianness)과 이러한 배열이 바이트열로 저장되는 방식이 문제가 됩니다. 다른 코덱과 마찬가지로, 문자열을 바이트 시퀀스로 직렬화하는 것을 <em>인코딩</em>이라고 하며, 바이트 시퀀스에서 문자열을 다시 만드는 것을 <em>디코딩</em>이라고 합니다. 다양한 텍스트 직렬화 코덱이 있으며, 이를 집합적으로 <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">텍스트 인코딩</span></a>이라고 합니다.</p>
<p>가장 간단한 텍스트 인코딩(<code class="docutils literal notranslate"><span class="pre">'latin-1'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'iso-8859-1'</span></code>이라고 합니다)은 코드 포인트 0--255를 바이트 <code class="docutils literal notranslate"><span class="pre">0x0</span></code>--<code class="docutils literal notranslate"><span class="pre">0xff</span></code>로 매핑합니다. 이것은 <code class="docutils literal notranslate"><span class="pre">U+00FF</span></code> 위의 코드 포인트를 포함하는 문자열 객체는 이 코덱으로 인코딩할 수 없음을 뜻합니다. 그렇게 하면 다음과 유사한 <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a> 가 발생합니다 (에러 메시지의 세부 사항은 다를 수 있습니다): <code class="docutils literal notranslate"><span class="pre">UnicodeEncodeError:</span> <span class="pre">'latin-1'</span> <span class="pre">codec</span> <span class="pre">can't</span> <span class="pre">encode</span> <span class="pre">character</span> <span class="pre">'\u1234'</span> <span class="pre">in</span> <span class="pre">position</span> <span class="pre">3:</span> <span class="pre">ordinal</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">range(256)</span></code>.</p>
<p>모든 유니코드 코드 포인트의 다른 부분 집합과 이러한 코드 포인트가 바이트 <code class="docutils literal notranslate"><span class="pre">0x0</span></code>--<code class="docutils literal notranslate"><span class="pre">0xff</span></code>에 매핑되는 방식을 선택하는 또 다른 인코딩 그룹(소위 charmap 인코딩)이 있습니다. 이 작업을 수행하는 방법을 보려면 간단히 예를 들어 <code class="file docutils literal notranslate"><span class="pre">encodings/cp1252.py</span></code>(윈도우에서 주로 사용되는 인코딩)를 열어보십시오. 어떤 문자가 어떤 바이트 값에 매핑되는지를 나타내는 256개의 문자로 구성된 문자열 상수가 있습니다.</p>
<p>이러한 모든 인코딩은 유니코드로 정의된 1114112 코드 포인트 중 256개만 인코딩 할 수 있습니다. 각 유니코드 코드 포인트를 저장할 수 있는 간단하고 간단한 방법은 각 코드 포인트를 4개의 연속 바이트로 저장하는 것입니다. 두 가지 가능성이 있습니다: 바이트를 빅 엔디안이나 리틀 엔디안 순서로 저장합니다. 이 두 가지 인코딩을 각각 <code class="docutils literal notranslate"><span class="pre">UTF-32-BE</span></code>와 <code class="docutils literal notranslate"><span class="pre">UTF-32-LE</span></code>라고 합니다. 단점은, 예를 들어 리틀 엔디안 기계에서 <code class="docutils literal notranslate"><span class="pre">UTF-32-BE</span></code>를 사용하면 인코딩과 디코딩 시 항상 바이트를 스와프해야 한다는 것입니다. <code class="docutils literal notranslate"><span class="pre">UTF-32</span></code>는 이 문제를 피합니다: 바이트는 항상 자연 엔디안입니다. 이 바이트를 엔디안이 다른 CPU에서 읽을 때는, 바이트를 스와프해야 합니다. <code class="docutils literal notranslate"><span class="pre">UTF-16</span></code>이나 <code class="docutils literal notranslate"><span class="pre">UTF-32</span></code> 바이트 시퀀스의 엔디안을 감지할 수 있도록, BOM(&quot;Byte Order Mark -- 바이트 순서 마크&quot;)이 있습니다. 이것은 유니코드 문자 <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code>입니다. 이 문자는 모든 <code class="docutils literal notranslate"><span class="pre">UTF-16</span></code>이나 <code class="docutils literal notranslate"><span class="pre">UTF-32</span></code> 바이트 시퀀스 앞에 붙일 수 있습니다. 이 문자의 바이트 스와프된 버전(<code class="docutils literal notranslate"><span class="pre">0xFFFE</span></code>)은 유니코드 텍스트에 나타날 수 없는 잘못된 문자입니다. 따라서 <code class="docutils literal notranslate"><span class="pre">UTF-16</span></code>이나 <code class="docutils literal notranslate"><span class="pre">UTF-32</span></code> 바이트 시퀀스의 첫 번째 문자가 <code class="docutils literal notranslate"><span class="pre">U+FFFE</span></code>이면, 디코딩 시 바이트를 스와프해야 합니다. 불행히도 <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code> 문자는 <code class="docutils literal notranslate"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code>라는 두 번째 목적을 가지고 있었습니다: 너비가 없고 단어를 나눌 수 없도록 하는 문자입니다. 예를 들어 합자(ligature) 알고리즘에 힌트를 주기 위해 사용될 수 있습니다. 유니코드 4.0에서는 <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code>를 <code class="docutils literal notranslate"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code>로 사용하는 것이 폐지되었습니다 (<code class="docutils literal notranslate"><span class="pre">U+2060</span></code>(<code class="docutils literal notranslate"><span class="pre">WORD</span> <span class="pre">JOINER</span></code>)이 이 역할을 맡습니다). 그런데도 유니코드 소프트웨어는 여전히 두 가지 역할 모두로 <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code>를 처리할 수 있어야 합니다: 인코딩된 바이트의 스토리지 배치를 결정하는 장치이며, 바이트 시퀀스가 문자열로 디코딩되면 사라지는 BOM의 역할, 다른 문자처럼 디코딩되는 일반 문자 <code class="docutils literal notranslate"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code>의 역할.</p>
<p>유니코드 문자의 전체 범위를 인코딩 할 수 있는 또 다른 인코딩이 있습니다: UTF-8. UTF-8은 8비트 인코딩입니다. UTF-8에서는 바이트 순서에 관한 문제가 없음을 의미합니다. UTF-8 바이트 시퀀스의 각 바이트는 두 부분으로 구성됩니다: 마커 비트(최상위 비트)와 페이로드 비트. 마커 비트는 0에서 4개의 <code class="docutils literal notranslate"><span class="pre">1</span></code> 비트와 그 뒤에 <code class="docutils literal notranslate"><span class="pre">0</span></code>비트가 오는 시퀀스입니다. 유니코드 문자는 다음과 같이 인코딩됩니다 (x는 페이로드 비트이며, 이어 붙이면 유니코드 문자가 됩니다):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>범위</p></th>
<th class="head"><p>인코딩</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">U-00000000</span></code> ... <code class="docutils literal notranslate"><span class="pre">U-0000007F</span></code></p></td>
<td><p>0xxxxxxx</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">U-00000080</span></code> ... <code class="docutils literal notranslate"><span class="pre">U-000007FF</span></code></p></td>
<td><p>110xxxxx 10xxxxxx</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">U-00000800</span></code> ... <code class="docutils literal notranslate"><span class="pre">U-0000FFFF</span></code></p></td>
<td><p>1110xxxx 10xxxxxx 10xxxxxx</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">U-00010000</span></code> ... <code class="docutils literal notranslate"><span class="pre">U-0010FFFF</span></code></p></td>
<td><p>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p></td>
</tr>
</tbody>
</table>
<p>유니코드 문자의 최하위 비트는 가장 오른쪽에 있는 x 비트입니다.</p>
<p>UTF-8은 8비트 인코딩이라서 BOM이 필요하지 않으며 디코딩된 문자열의 모든 <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code> 문자(첫 번째 문자라 할지라도)는 <code class="docutils literal notranslate"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code>로 처리됩니다.</p>
<p>외부 정보 없이 문자열 인코딩에 사용된 인코딩을 신뢰성 있게 결정하는 것은 불가능합니다. 각 charmap 인코딩은 모든 임의의 바이트 시퀀스를 디코딩 할 수 있습니다. 그러나 UTF-8에서는 그렇지 않습니다, UTF-8 바이트 시퀀스는 임의의 바이트 시퀀스를 허용하지 않는 구조를 갖기 때문입니다. UTF-8 인코딩 감지의 신뢰성을 높이기 위해, Microsoft는 메모장(Notepad) 프로그램을 위해 UTF-8의 변형을 발명했습니다 (파이썬 2.5에서 <code class="docutils literal notranslate"><span class="pre">&quot;utf-8-sig&quot;</span></code>라고 부릅니다): 유니코드 문자를 파일에 쓰기 전에, UTF-8 인코딩된 BOM(다음과 같은 바이트 시퀀스로 표시됩니다: <code class="docutils literal notranslate"><span class="pre">0xef</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbb</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbf</span></code>)이 기록됩니다. 모든 charmap 인코딩된 파일이 이러한 바이트 값으로 시작한다는 것은 다소 불가능하기 때문에 (예를 들어 iso-8859-1 에서 다음과 같은 것으로 매핑됩니다</p>
<blockquote>
<div><div class="line-block">
<div class="line">LATIN SMALL LETTER I WITH DIAERESIS</div>
<div class="line">RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK</div>
<div class="line">INVERTED QUESTION MARK</div>
</div>
</div></blockquote>
<p>), 바이트 시퀀스에서 <code class="docutils literal notranslate"><span class="pre">utf-8-sig</span></code> 인코딩을 정확하게 추측할 수 있는 가능성을 높입니다. 따라서 여기서 BOM은 바이트 시퀀스를 생성하는 데 사용되는 바이트 순서를 결정할 수 있도록 하는데 사용되지는 않지만, 인코딩을 추측하는 데 도움이 되는 서명으로 사용됩니다. 인코딩할 때 utf-8-sig 코덱은 <code class="docutils literal notranslate"><span class="pre">0xef</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbb</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbf</span></code>를 파일의 처음 3바이트로 기록합니다. 디코딩할 때 <code class="docutils literal notranslate"><span class="pre">utf-8-sig</span></code>는 파일에서 처음 3바이트에 등장하면 이 3바이트를 건너뜁니다. UTF-8에서는, BOM 사용을 권장하지 않으며 일반적으로 피해야 합니다.</p>
</div>
<div class="section" id="standard-encodings">
<span id="id3"></span><h2>표준 인코딩<a class="headerlink" href="#standard-encodings" title="제목 주소">¶</a></h2>
<p>파이썬에는 C 함수로 구현되거나 딕셔너리를 매핑 테이블로 사용하는 많은 코덱이 내장되어 있습니다. 다음 표는 몇 가지 공통 별칭과 인코딩이 사용되는 언어와 함께 이름별로 코덱을 나열합니다. 별칭 목록이나 언어 목록이 모두 철저하지는 않습니다. 대소 문자만 다르거나 밑줄 대신 하이픈을 사용하는 철자 대안도 유효한 별칭임에 유의하십시오; 따라서, 예를 들어 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>은 <code class="docutils literal notranslate"><span class="pre">'utf_8'</span></code> 코덱의 유효한 별칭입니다.</p>
<div class="impl-detail compound">
<p class="compound-first"><strong>CPython implementation detail:</strong> 일부 공통 인코딩은 코덱 조회 메커니즘을 우회하여 성능을 향상할 수 있습니다. 이러한 최적화 기회는 CPython에서만 제한된 (대소 문자를 구분하는) 별칭 집합에 대해서 인식됩니다:  utf-8, utf8, latin-1, latin1, iso-8859-1, iso8859-1, mbcs (윈도우 전용), ascii, us-ascii, utf-16, utf16, utf-32, utf32 및 대시 대신 밑줄을 사용한 것들. 이러한 인코딩에 대체 대안 별칭을 사용하면 실행 속도가 느려질 수 있습니다.</p>
<div class="compound-last versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>us-ascii에서 최적화 기회가 인식됩니다.</p>
</div>
</div>
<p>많은 문자 집합이 같은 언어를 지원합니다. 개별 문자(예를 들어 EURO SIGN 지원 여부)와 코드 위치에 문자를 대입하는 것에서 다릅니다. 특히 유럽 언어의 경우, 일반적으로 다음과 같은 변형이 있습니다:</p>
<ul class="simple">
<li><p>ISO 8859 코드 집합</p></li>
<li><p>Microsoft 윈도우 코드 페이지, 일반적으로 8859 코드 집합에서 파생되지만, 제어 문자를 추가 그래픽 문자로 대체합니다</p></li>
<li><p>IBM EBCDIC 코드 페이지</p></li>
<li><p>IBM PC 코드 페이지, ASCII와 호환됩니다</p></li>
</ul>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 40%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>코덱</p></th>
<th class="head"><p>별칭</p></th>
<th class="head"><p>언어</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ascii</p></td>
<td><p>646, us-ascii</p></td>
<td><p>영어</p></td>
</tr>
<tr class="row-odd"><td><p>big5</p></td>
<td><p>big5-tw, csbig5</p></td>
<td><p>중국어 번체</p></td>
</tr>
<tr class="row-even"><td><p>big5hkscs</p></td>
<td><p>big5-hkscs, hkscs</p></td>
<td><p>중국어 번체</p></td>
</tr>
<tr class="row-odd"><td><p>cp037</p></td>
<td><p>IBM037, IBM039</p></td>
<td><p>영어</p></td>
</tr>
<tr class="row-even"><td><p>cp273</p></td>
<td><p>273, IBM273, csIBM273</p></td>
<td><p>독일어</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>cp424</p></td>
<td><p>EBCDIC-CP-HE, IBM424</p></td>
<td><p>히브리어</p></td>
</tr>
<tr class="row-even"><td><p>cp437</p></td>
<td><p>437, IBM437</p></td>
<td><p>영어</p></td>
</tr>
<tr class="row-odd"><td><p>cp500</p></td>
<td><p>EBCDIC-CP-BE, EBCDIC-CP-CH,
IBM500</p></td>
<td><p>서유럽어</p></td>
</tr>
<tr class="row-even"><td><p>cp720</p></td>
<td></td>
<td><p>아랍어</p></td>
</tr>
<tr class="row-odd"><td><p>cp737</p></td>
<td></td>
<td><p>그리스어</p></td>
</tr>
<tr class="row-even"><td><p>cp775</p></td>
<td><p>IBM775</p></td>
<td><p>발트어</p></td>
</tr>
<tr class="row-odd"><td><p>cp850</p></td>
<td><p>850, IBM850</p></td>
<td><p>서유럽어</p></td>
</tr>
<tr class="row-even"><td><p>cp852</p></td>
<td><p>852, IBM852</p></td>
<td><p>중부와 동유럽어</p></td>
</tr>
<tr class="row-odd"><td><p>cp855</p></td>
<td><p>855, IBM855</p></td>
<td><p>불가리아어, 벨로루시야어, 마케도니아어, 러시아어, 세르비아어</p></td>
</tr>
<tr class="row-even"><td><p>cp856</p></td>
<td></td>
<td><p>히브리어</p></td>
</tr>
<tr class="row-odd"><td><p>cp857</p></td>
<td><p>857, IBM857</p></td>
<td><p>터키어</p></td>
</tr>
<tr class="row-even"><td><p>cp858</p></td>
<td><p>858, IBM858</p></td>
<td><p>서유럽어</p></td>
</tr>
<tr class="row-odd"><td><p>cp860</p></td>
<td><p>860, IBM860</p></td>
<td><p>포르투갈어</p></td>
</tr>
<tr class="row-even"><td><p>cp861</p></td>
<td><p>861, CP-IS, IBM861</p></td>
<td><p>아이슬란드어</p></td>
</tr>
<tr class="row-odd"><td><p>cp862</p></td>
<td><p>862, IBM862</p></td>
<td><p>히브리어</p></td>
</tr>
<tr class="row-even"><td><p>cp863</p></td>
<td><p>863, IBM863</p></td>
<td><p>캐나다어</p></td>
</tr>
<tr class="row-odd"><td><p>cp864</p></td>
<td><p>IBM864</p></td>
<td><p>아랍어</p></td>
</tr>
<tr class="row-even"><td><p>cp865</p></td>
<td><p>865, IBM865</p></td>
<td><p>덴마크어, 노르웨이어</p></td>
</tr>
<tr class="row-odd"><td><p>cp866</p></td>
<td><p>866, IBM866</p></td>
<td><p>러시아어</p></td>
</tr>
<tr class="row-even"><td><p>cp869</p></td>
<td><p>869, CP-GR, IBM869</p></td>
<td><p>그리스어</p></td>
</tr>
<tr class="row-odd"><td><p>cp874</p></td>
<td></td>
<td><p>태국어</p></td>
</tr>
<tr class="row-even"><td><p>cp875</p></td>
<td></td>
<td><p>그리스어</p></td>
</tr>
<tr class="row-odd"><td><p>cp932</p></td>
<td><p>932, ms932, mskanji, ms-kanji</p></td>
<td><p>일본어</p></td>
</tr>
<tr class="row-even"><td><p>cp949</p></td>
<td><p>949, ms949, uhc</p></td>
<td><p>한국어</p></td>
</tr>
<tr class="row-odd"><td><p>cp950</p></td>
<td><p>950, ms950</p></td>
<td><p>중국어 번체</p></td>
</tr>
<tr class="row-even"><td><p>cp1006</p></td>
<td></td>
<td><p>우르두어</p></td>
</tr>
<tr class="row-odd"><td><p>cp1026</p></td>
<td><p>ibm1026</p></td>
<td><p>터키어</p></td>
</tr>
<tr class="row-even"><td><p>cp1125</p></td>
<td><p>1125, ibm1125, cp866u, ruscii</p></td>
<td><p>우크라이나어</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>cp1140</p></td>
<td><p>ibm1140</p></td>
<td><p>서유럽어</p></td>
</tr>
<tr class="row-even"><td><p>cp1250</p></td>
<td><p>windows-1250</p></td>
<td><p>중부와 동유럽어</p></td>
</tr>
<tr class="row-odd"><td><p>cp1251</p></td>
<td><p>windows-1251</p></td>
<td><p>불가리아어, 벨로루시야어, 마케도니아어, 러시아어, 세르비아어</p></td>
</tr>
<tr class="row-even"><td><p>cp1252</p></td>
<td><p>windows-1252</p></td>
<td><p>서유럽어</p></td>
</tr>
<tr class="row-odd"><td><p>cp1253</p></td>
<td><p>windows-1253</p></td>
<td><p>그리스어</p></td>
</tr>
<tr class="row-even"><td><p>cp1254</p></td>
<td><p>windows-1254</p></td>
<td><p>터키어</p></td>
</tr>
<tr class="row-odd"><td><p>cp1255</p></td>
<td><p>windows-1255</p></td>
<td><p>히브리어</p></td>
</tr>
<tr class="row-even"><td><p>cp1256</p></td>
<td><p>windows-1256</p></td>
<td><p>아랍어</p></td>
</tr>
<tr class="row-odd"><td><p>cp1257</p></td>
<td><p>windows-1257</p></td>
<td><p>발트어</p></td>
</tr>
<tr class="row-even"><td><p>cp1258</p></td>
<td><p>windows-1258</p></td>
<td><p>베트남어</p></td>
</tr>
<tr class="row-odd"><td><p>euc_jp</p></td>
<td><p>eucjp, ujis, u-jis</p></td>
<td><p>일본어</p></td>
</tr>
<tr class="row-even"><td><p>euc_jis_2004</p></td>
<td><p>jisx0213, eucjis2004</p></td>
<td><p>일본어</p></td>
</tr>
<tr class="row-odd"><td><p>euc_jisx0213</p></td>
<td><p>eucjisx0213</p></td>
<td><p>일본어</p></td>
</tr>
<tr class="row-even"><td><p>euc_kr</p></td>
<td><p>euckr, korean, ksc5601,
ks_c-5601, ks_c-5601-1987,
ksx1001, ks_x-1001</p></td>
<td><p>한국어</p></td>
</tr>
<tr class="row-odd"><td><p>gb2312</p></td>
<td><p>chinese, csiso58gb231280,
euc-cn, euccn, eucgb2312-cn,
gb2312-1980, gb2312-80,
iso-ir-58</p></td>
<td><p>중국어 간체</p></td>
</tr>
<tr class="row-even"><td><p>gbk</p></td>
<td><p>936, cp936, ms936</p></td>
<td><p>통합 중국어</p></td>
</tr>
<tr class="row-odd"><td><p>gb18030</p></td>
<td><p>gb18030-2000</p></td>
<td><p>통합 중국어</p></td>
</tr>
<tr class="row-even"><td><p>hz</p></td>
<td><p>hzgb, hz-gb, hz-gb-2312</p></td>
<td><p>중국어 간체</p></td>
</tr>
<tr class="row-odd"><td><p>iso2022_jp</p></td>
<td><p>csiso2022jp, iso2022jp,
iso-2022-jp</p></td>
<td><p>일본어</p></td>
</tr>
<tr class="row-even"><td><p>iso2022_jp_1</p></td>
<td><p>iso2022jp-1, iso-2022-jp-1</p></td>
<td><p>일본어</p></td>
</tr>
<tr class="row-odd"><td><p>iso2022_jp_2</p></td>
<td><p>iso2022jp-2, iso-2022-jp-2</p></td>
<td><p>일본어, 한국어, 중국어 간체, 서유럽어, 그리스어</p></td>
</tr>
<tr class="row-even"><td><p>iso2022_jp_2004</p></td>
<td><p>iso2022jp-2004,
iso-2022-jp-2004</p></td>
<td><p>일본어</p></td>
</tr>
<tr class="row-odd"><td><p>iso2022_jp_3</p></td>
<td><p>iso2022jp-3, iso-2022-jp-3</p></td>
<td><p>일본어</p></td>
</tr>
<tr class="row-even"><td><p>iso2022_jp_ext</p></td>
<td><p>iso2022jp-ext, iso-2022-jp-ext</p></td>
<td><p>일본어</p></td>
</tr>
<tr class="row-odd"><td><p>iso2022_kr</p></td>
<td><p>csiso2022kr, iso2022kr,
iso-2022-kr</p></td>
<td><p>한국어</p></td>
</tr>
<tr class="row-even"><td><p>latin_1</p></td>
<td><p>iso-8859-1, iso8859-1, 8859,
cp819, latin, latin1, L1</p></td>
<td><p>서유럽어</p></td>
</tr>
<tr class="row-odd"><td><p>iso8859_2</p></td>
<td><p>iso-8859-2, latin2, L2</p></td>
<td><p>중부와 동유럽어</p></td>
</tr>
<tr class="row-even"><td><p>iso8859_3</p></td>
<td><p>iso-8859-3, latin3, L3</p></td>
<td><p>에스페란토어, 몰타어</p></td>
</tr>
<tr class="row-odd"><td><p>iso8859_4</p></td>
<td><p>iso-8859-4, latin4, L4</p></td>
<td><p>발트어</p></td>
</tr>
<tr class="row-even"><td><p>iso8859_5</p></td>
<td><p>iso-8859-5, cyrillic</p></td>
<td><p>불가리아어, 벨로루시야어, 마케도니아어, 러시아어, 세르비아어</p></td>
</tr>
<tr class="row-odd"><td><p>iso8859_6</p></td>
<td><p>iso-8859-6, arabic</p></td>
<td><p>아랍어</p></td>
</tr>
<tr class="row-even"><td><p>iso8859_7</p></td>
<td><p>iso-8859-7, greek, greek8</p></td>
<td><p>그리스어</p></td>
</tr>
<tr class="row-odd"><td><p>iso8859_8</p></td>
<td><p>iso-8859-8, hebrew</p></td>
<td><p>히브리어</p></td>
</tr>
<tr class="row-even"><td><p>iso8859_9</p></td>
<td><p>iso-8859-9, latin5, L5</p></td>
<td><p>터키어</p></td>
</tr>
<tr class="row-odd"><td><p>iso8859_10</p></td>
<td><p>iso-8859-10, latin6, L6</p></td>
<td><p>북유럽어</p></td>
</tr>
<tr class="row-even"><td><p>iso8859_11</p></td>
<td><p>iso-8859-11, thai</p></td>
<td><p>태국어</p></td>
</tr>
<tr class="row-odd"><td><p>iso8859_13</p></td>
<td><p>iso-8859-13, latin7, L7</p></td>
<td><p>발트어</p></td>
</tr>
<tr class="row-even"><td><p>iso8859_14</p></td>
<td><p>iso-8859-14, latin8, L8</p></td>
<td><p>켈틱어</p></td>
</tr>
<tr class="row-odd"><td><p>iso8859_15</p></td>
<td><p>iso-8859-15, latin9, L9</p></td>
<td><p>서유럽어</p></td>
</tr>
<tr class="row-even"><td><p>iso8859_16</p></td>
<td><p>iso-8859-16, latin10, L10</p></td>
<td><p>남유럽어</p></td>
</tr>
<tr class="row-odd"><td><p>johab</p></td>
<td><p>cp1361, ms1361</p></td>
<td><p>한국어</p></td>
</tr>
<tr class="row-even"><td><p>koi8_r</p></td>
<td></td>
<td><p>러시아어</p></td>
</tr>
<tr class="row-odd"><td><p>koi8_t</p></td>
<td></td>
<td><p>타지크어</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td><p>koi8_u</p></td>
<td></td>
<td><p>우크라이나어</p></td>
</tr>
<tr class="row-odd"><td><p>kz1048</p></td>
<td><p>kz_1048, strk1048_2002, rk1048</p></td>
<td><p>카자흐어</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td><p>mac_cyrillic</p></td>
<td><p>maccyrillic</p></td>
<td><p>불가리아어, 벨로루시야어, 마케도니아어, 러시아어, 세르비아어</p></td>
</tr>
<tr class="row-odd"><td><p>mac_greek</p></td>
<td><p>macgreek</p></td>
<td><p>그리스어</p></td>
</tr>
<tr class="row-even"><td><p>mac_iceland</p></td>
<td><p>maciceland</p></td>
<td><p>아이슬란드어</p></td>
</tr>
<tr class="row-odd"><td><p>mac_latin2</p></td>
<td><p>maclatin2, maccentraleurope,
mac_centeuro</p></td>
<td><p>중부와 동유럽어</p></td>
</tr>
<tr class="row-even"><td><p>mac_roman</p></td>
<td><p>macroman, macintosh</p></td>
<td><p>서유럽어</p></td>
</tr>
<tr class="row-odd"><td><p>mac_turkish</p></td>
<td><p>macturkish</p></td>
<td><p>터키어</p></td>
</tr>
<tr class="row-even"><td><p>ptcp154</p></td>
<td><p>csptcp154, pt154, cp154,
cyrillic-asian</p></td>
<td><p>카자흐어</p></td>
</tr>
<tr class="row-odd"><td><p>shift_jis</p></td>
<td><p>csshiftjis, shiftjis, sjis,
s_jis</p></td>
<td><p>일본어</p></td>
</tr>
<tr class="row-even"><td><p>shift_jis_2004</p></td>
<td><p>shiftjis2004, sjis_2004,
sjis2004</p></td>
<td><p>일본어</p></td>
</tr>
<tr class="row-odd"><td><p>shift_jisx0213</p></td>
<td><p>shiftjisx0213, sjisx0213,
s_jisx0213</p></td>
<td><p>일본어</p></td>
</tr>
<tr class="row-even"><td><p>utf_32</p></td>
<td><p>U32, utf32</p></td>
<td><p>모든 언어</p></td>
</tr>
<tr class="row-odd"><td><p>utf_32_be</p></td>
<td><p>UTF-32BE</p></td>
<td><p>모든 언어</p></td>
</tr>
<tr class="row-even"><td><p>utf_32_le</p></td>
<td><p>UTF-32LE</p></td>
<td><p>모든 언어</p></td>
</tr>
<tr class="row-odd"><td><p>utf_16</p></td>
<td><p>U16, utf16</p></td>
<td><p>모든 언어</p></td>
</tr>
<tr class="row-even"><td><p>utf_16_be</p></td>
<td><p>UTF-16BE</p></td>
<td><p>모든 언어</p></td>
</tr>
<tr class="row-odd"><td><p>utf_16_le</p></td>
<td><p>UTF-16LE</p></td>
<td><p>모든 언어</p></td>
</tr>
<tr class="row-even"><td><p>utf_7</p></td>
<td><p>U7, unicode-1-1-utf-7</p></td>
<td><p>모든 언어</p></td>
</tr>
<tr class="row-odd"><td><p>utf_8</p></td>
<td><p>U8, UTF, utf8, cp65001</p></td>
<td><p>모든 언어</p></td>
</tr>
<tr class="row-even"><td><p>utf_8_sig</p></td>
<td></td>
<td><p>모든 언어</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>utf-16* 과 utf-32* 인코더는 더는 서로게이트 코드 포인트(<code class="docutils literal notranslate"><span class="pre">U+D800</span></code>--<code class="docutils literal notranslate"><span class="pre">U+DFFF</span></code>)를 인코딩할 수 없습니다. utf-32* 디코더는 더는 서로게이트 코드 포인트에 해당하는 바이트 시퀀스를 디코딩하지 않습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><code class="docutils literal notranslate"><span class="pre">cp65001</span></code>은 이제 <code class="docutils literal notranslate"><span class="pre">utf_8</span></code>의 별칭입니다.</p>
</div>
</div>
<div class="section" id="python-specific-encodings">
<h2>파이썬 특정 인코딩<a class="headerlink" href="#python-specific-encodings" title="제목 주소">¶</a></h2>
<p>사전 정의된 많은 코덱이 파이썬에만 해당하여, 코덱 이름은 파이썬 외부에서 의미가 없습니다. 예상되는 입력과 출력형에 따라 아래 표에 나열되어 있습니다 (텍스트 인코딩은 코덱의 가장 일반적인 사용 사례이지만, 하부 코덱 인프라는 단지 텍스트 인코딩이 아닌 임의의 데이터 변환을 지원합니다). 비대칭 코덱의 경우, 언급된 의미는 인코딩 방향을 설명합니다.</p>
<div class="section" id="text-encodings">
<h3>텍스트 인코딩<a class="headerlink" href="#text-encodings" title="제목 주소">¶</a></h3>
<p>다음 코덱은 유니코드 텍스트 인코딩과 유사하게, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>에서 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>로의 인코딩과 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>에서 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로의 디코딩을 제공합니다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 16%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>코덱</p></th>
<th class="head"><p>별칭</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>idna</p></td>
<td></td>
<td><p><span class="target" id="index-22"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a>을 구현합니다. <a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code></a>도 참조하십시오. <code class="docutils literal notranslate"><span class="pre">errors='strict'</span></code>만 지원됩니다.</p></td>
</tr>
<tr class="row-odd"><td><p>mbcs</p></td>
<td><p>ansi,
dbcs</p></td>
<td><p>윈도우 전용: ANSI 코드 페이지(CP_ACP)에 따라 피연산자를 인코딩합니다.</p></td>
</tr>
<tr class="row-even"><td><p>oem</p></td>
<td></td>
<td><p>윈도우 전용: OEM 코드 페이지(CP_OEMCP)에 따라 피연산자를 인코딩합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>palmos</p></td>
<td></td>
<td><p>PalmOS 3.5의 인코딩.</p></td>
</tr>
<tr class="row-even"><td><p>punycode</p></td>
<td></td>
<td><p><span class="target" id="index-23"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3492.html"><strong>RFC 3492</strong></a>를 구현합니다. 상태 있는 코덱은 지원되지 않습니다.</p></td>
</tr>
<tr class="row-odd"><td><p>raw_unicode_escape</p></td>
<td></td>
<td><p>다른 코드 포인트를 위해 <code class="docutils literal notranslate"><span class="pre">\uXXXX</span></code>와 <code class="docutils literal notranslate"><span class="pre">\UXXXXXXXX</span></code>를 사용하는 Latin-1 인코딩. 기존 역 슬래시는 어떤 방식으로도 이스케이프 되지 않습니다. 파이썬 피클 프로토콜에서 사용됩니다.</p></td>
</tr>
<tr class="row-even"><td><p>undefined</p></td>
<td></td>
<td><p>모든 변환에 대해 예외를 발생시킵니다, 빈 문자열조차. 에러 처리기는 무시됩니다.</p></td>
</tr>
<tr class="row-odd"><td><p>unicode_escape</p></td>
<td></td>
<td><p>따옴표가 이스케이프 되지 않는 것을 제외하고, ASCII로 인코딩된 파이썬 소스 코드에서 유니코드 리터럴 내용으로 적합한 인코딩. Latin-1 소스 코드에서 디코딩합니다. 파이썬 소스 코드는 실제로는 기본적으로 UTF-8을 사용합니다.</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>&quot;unicode_internal&quot; 코덱이 제거되었습니다.</p>
</div>
</div>
<div class="section" id="binary-transforms">
<span id="id4"></span><h3>바이너리 변환<a class="headerlink" href="#binary-transforms" title="제목 주소">¶</a></h3>
<p>다음 코덱은 바이너리 변환을 제공합니다: <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>에서 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>로의 매핑.  (<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 출력만 생성하는) <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a>에서는 지원되지 않습니다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 18%" />
<col style="width: 30%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>코덱</p></th>
<th class="head"><p>별칭</p></th>
<th class="head"><p>의미</p></th>
<th class="head"><p>인코더 / 디코더</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>base64_codec <a class="footnote-reference brackets" href="#b64" id="id5">1</a></p></td>
<td><p>base64, base_64</p></td>
<td><p>피연산자를 여러 줄 MIME base64로 변환합니다 (결과에는 항상 후행 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>이 포함됩니다).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>인코딩과 디코딩을 위해 모든 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>를 입력으로 받아들입니다.</p>
</div>
</td>
<td><p><a class="reference internal" href="base64.html#base64.encodebytes" title="base64.encodebytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base64.encodebytes()</span></code></a> /
<a class="reference internal" href="base64.html#base64.decodebytes" title="base64.decodebytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base64.decodebytes()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>bz2_codec</p></td>
<td><p>bz2</p></td>
<td><p>bz2를 사용하여 피연산자를 압축합니다.</p></td>
<td><p><a class="reference internal" href="bz2.html#bz2.compress" title="bz2.compress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bz2.compress()</span></code></a> /
<a class="reference internal" href="bz2.html#bz2.decompress" title="bz2.decompress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bz2.decompress()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>hex_codec</p></td>
<td><p>hex</p></td>
<td><p>바이트 당 두 자리 숫자를 사용하여, 피연산자를 16진 표현으로 변환합니다.</p></td>
<td><p><a class="reference internal" href="binascii.html#binascii.b2a_hex" title="binascii.b2a_hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">binascii.b2a_hex()</span></code></a> /
<a class="reference internal" href="binascii.html#binascii.a2b_hex" title="binascii.a2b_hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">binascii.a2b_hex()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>quopri_codec</p></td>
<td><p>quopri,
quotedprintable,
quoted_printable</p></td>
<td><p>피연산자를 MIME quoted printable로 변환합니다.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">quotetabs=True</span></code>를 사용한 <a class="reference internal" href="quopri.html#quopri.encode" title="quopri.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quopri.encode()</span></code></a> / <a class="reference internal" href="quopri.html#quopri.decode" title="quopri.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quopri.decode()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>uu_codec</p></td>
<td><p>uu</p></td>
<td><p>uuencode를 사용하여 피연산자를 변환합니다.</p></td>
<td><p><a class="reference internal" href="uu.html#uu.encode" title="uu.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">uu.encode()</span></code></a> /
<a class="reference internal" href="uu.html#uu.decode" title="uu.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">uu.decode()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>zlib_codec</p></td>
<td><p>zip, zlib</p></td>
<td><p>gzip을 사용하여 피연산자를 압축합니다.</p></td>
<td><p><a class="reference internal" href="zlib.html#zlib.compress" title="zlib.compress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zlib.compress()</span></code></a> /
<a class="reference internal" href="zlib.html#zlib.decompress" title="zlib.decompress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zlib.decompress()</span></code></a></p></td>
</tr>
</tbody>
</table>
<dl class="footnote brackets">
<dt class="label" id="b64"><span class="brackets"><a class="fn-backref" href="#id5">1</a></span></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'base64_codec'</span></code>는 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a> 외에도 디코딩을 위해 ASCII만 있는 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 인스턴스도 허용합니다.</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가: </span>바이너리 변환의 복원.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>바이너리 변환에 대한 별칭의 복원.</p>
</div>
</div>
<div class="section" id="text-transforms">
<span id="id6"></span><h3>텍스트 변환<a class="headerlink" href="#text-transforms" title="제목 주소">¶</a></h3>
<p>다음 코덱은 텍스트 변환을 제공합니다: <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>에서 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로의 매핑. (<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 출력만 생성하는) <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a>에서는 지원되지 않습니다.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 16%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>코덱</p></th>
<th class="head"><p>별칭</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>rot_13</p></td>
<td><p>rot13</p></td>
<td><p>피연산자의 시저 암호(Caesar-cypher) 암호화를 반환합니다.</p></td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가: </span><code class="docutils literal notranslate"><span class="pre">rot_13</span></code> 텍스트 변환 복원.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">rot13</span></code> 별칭 복원.</p>
</div>
</div>
</div>
<div class="section" id="module-encodings.idna">
<span id="encodings-idna-internationalized-domain-names-in-applications"></span><h2><a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code></a> --- 응용 프로그램에서의 국제화된 도메인 이름<a class="headerlink" href="#module-encodings.idna" title="제목 주소">¶</a></h2>
<p>이 모듈은 <span class="target" id="index-24"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a>(Internationalized Domain Names in Applications)과 <span class="target" id="index-25"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3492.html"><strong>RFC 3492</strong></a>(Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN))를 구현합니다. <code class="docutils literal notranslate"><span class="pre">punycode</span></code> 인코딩과 <a class="reference internal" href="stringprep.html#module-stringprep" title="stringprep: String preparation, as per RFC 3453"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stringprep</span></code></a>을 기반으로 합니다.</p>
<p>이 RFC는 함께 도메인 이름에서 비 ASCII 문자를 지원하는 프로토콜을 정의합니다. 비 ASCII 문자(가령 <code class="docutils literal notranslate"><span class="pre">www.Alliancefrançaise.nu</span></code>)를 포함하는 도메인 이름은 ASCII 호환 인코딩(ACE, 가령 <code class="docutils literal notranslate"><span class="pre">www.xn--alliancefranaise-npb.nu</span></code>)으로 변환됩니다. 그런 다음 도메인 이름의 ACE 형식은 DNS 조회, HTTP <em class="mailheader">Host</em> 필드 등과 같이 프로토콜에 의해 임의의 문자가 허용되지 않는 모든 위치에서 사용됩니다. 이 변환은 응용 프로그램에서 수행됩니다; 가능하다면 사용자에게 보이지 않습니다: 응용 프로그램은 전송 시에 유니코드 도메인 레이블을 투명하게 IDNA로 변환하고, 사용자에게 표시하기 전에 ACE 레이블을 다시 유니코드로 변환해야 합니다.</p>
<p>파이썬은 여러 가지 방식으로 이 변환을 지원합니다: <code class="docutils literal notranslate"><span class="pre">idna</span></code> 코덱은 유니코드와 ACE 간의 변환을 수행하여, <span class="target" id="index-26"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html#section-3.1"><strong>RFC 3490의 섹션 3.1</strong></a>에 정의된 구분 문자를 기반으로 입력 문자열을 레이블로 분리하고 필요에 따라 각 레이블을 ACE로 변환하고, 반대로 입력 바이트 문자열을 <code class="docutils literal notranslate"><span class="pre">.</span></code> 구분 기호를 기반으로 레이블로 분리하고 모든 ACE 레이블을 유니코드로 변환합니다. 또한, <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 모듈은 유니코드 호스트 이름을 투명하게 ACE로 변환하므로, 응용 프로그램이 호스트 이름을 소켓 모듈로 전달할 때 호스트 이름 자체를 변환할 필요가 없습니다. 이에 더해, <a class="reference internal" href="http.client.html#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.client</span></code></a>와 <a class="reference internal" href="ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a>와 같은, 함수 매개 변수로 호스트 이름이 있는 모듈은 유니코드 호스트 이름을 받아들입니다 (<a class="reference internal" href="http.client.html#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.client</span></code></a>는 해당 필드를 전송한다면 <em class="mailheader">Host</em> 필드에 IDNA 호스트 이름을 투명하게 전송합니다).</p>
<p>회선에서 호스트 이름을 수신할 때 (가령 역 이름 조회(reverse name lookup)에서), 유니코드로 자동 변환되지 않습니다: 이러한 호스트 이름을 사용자에게 제시하려는 응용 프로그램은 유니코드로 디코딩해야 합니다.</p>
<p>또한 모듈 <a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code></a>는 nameprep 절차를 구현합니다. 이는 국제 도메인 이름의 대소 문자를 구분하지 않고 유사한 문자를 통합하기 위해 호스트 이름에 대해 특정 정규화를 수행합니다. 원한다면 nameprep 함수를 직접 사용할 수 있습니다.</p>
<dl class="function">
<dt id="encodings.idna.nameprep">
<code class="sig-prename descclassname">encodings.idna.</code><code class="sig-name descname">nameprep</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.nameprep" title="정의 주소">¶</a></dt>
<dd><p><em>label</em>의 nameprep 된 버전을 반환합니다. 구현은 현재 쿼리 문자열을 가정하므로, <code class="docutils literal notranslate"><span class="pre">AllowUnassigned</span></code>는 참입니다.</p>
</dd></dl>

<dl class="function">
<dt id="encodings.idna.ToASCII">
<code class="sig-prename descclassname">encodings.idna.</code><code class="sig-name descname">ToASCII</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.ToASCII" title="정의 주소">¶</a></dt>
<dd><p><span class="target" id="index-27"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a>에 지정된 대로 레이블을 ASCII로 변환합니다. <code class="docutils literal notranslate"><span class="pre">UseSTD3ASCIIRules</span></code>는 거짓으로 가정합니다.</p>
</dd></dl>

<dl class="function">
<dt id="encodings.idna.ToUnicode">
<code class="sig-prename descclassname">encodings.idna.</code><code class="sig-name descname">ToUnicode</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.ToUnicode" title="정의 주소">¶</a></dt>
<dd><p><span class="target" id="index-28"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a>에 지정된 대로 레이블을 유니코드로 변환합니다.</p>
</dd></dl>

</div>
<div class="section" id="module-encodings.mbcs">
<span id="encodings-mbcs-windows-ansi-codepage"></span><h2><a class="reference internal" href="#module-encodings.mbcs" title="encodings.mbcs: Windows ANSI codepage"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.mbcs</span></code></a> --- 윈도우 ANSI 코드 페이지<a class="headerlink" href="#module-encodings.mbcs" title="제목 주소">¶</a></h2>
<p>이 모듈은 ANSI 코드 페이지(CP_ACP)를 구현합니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 윈도우 전용.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>모든 에러 처리기를 지원합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>3.2 이전에는, <em>errors</em> 인자가 무시되었습니다; 인코딩에는 항상 <code class="docutils literal notranslate"><span class="pre">'replace'</span></code>가 사용되고, 디코딩에는 항상 <code class="docutils literal notranslate"><span class="pre">'ignore'</span></code>가 사용되었습니다.</p>
</div>
</div>
<div class="section" id="module-encodings.utf_8_sig">
<span id="encodings-utf-8-sig-utf-8-codec-with-bom-signature"></span><h2><a class="reference internal" href="#module-encodings.utf_8_sig" title="encodings.utf_8_sig: UTF-8 codec with BOM signature"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.utf_8_sig</span></code></a> --- BOM 서명이 있는 UTF-8 코덱<a class="headerlink" href="#module-encodings.utf_8_sig" title="제목 주소">¶</a></h2>
<p>이 모듈은 UTF-8 코덱의 변형을 구현합니다. 인코딩 시, UTF-8로 인코딩된 BOM을 UTF-8로 인코딩된 바이트열 앞에 붙입니다. 상태 있는 인코더의 경우 이 작업은 한 번만 수행됩니다 (바이트 스트림에 대한 첫 번째 쓰기 시). 디코딩 시, 데이터 시작에 있는 선택적 UTF-8 인코딩된 BOM을 건너뜁니다.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code> --- 코덱 레지스트리와 베이스 클래스</a><ul>
<li><a class="reference internal" href="#codec-base-classes">코덱 베이스 클래스</a><ul>
<li><a class="reference internal" href="#error-handlers">에러 처리기</a></li>
<li><a class="reference internal" href="#stateless-encoding-and-decoding">상태 없는 인코딩과 디코딩</a></li>
<li><a class="reference internal" href="#incremental-encoding-and-decoding">증분 인코딩과 디코딩</a><ul>
<li><a class="reference internal" href="#incrementalencoder-objects">IncrementalEncoder 객체</a></li>
<li><a class="reference internal" href="#incrementaldecoder-objects">IncrementalDecoder 객체</a></li>
</ul>
</li>
<li><a class="reference internal" href="#stream-encoding-and-decoding">스트림 인코딩과 디코딩</a><ul>
<li><a class="reference internal" href="#streamwriter-objects">StreamWriter 객체</a></li>
<li><a class="reference internal" href="#streamreader-objects">StreamReader 객체</a></li>
<li><a class="reference internal" href="#streamreaderwriter-objects">StreamReaderWriter 객체</a></li>
<li><a class="reference internal" href="#streamrecoder-objects">StreamRecoder 객체</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#encodings-and-unicode">인코딩과 유니코드</a></li>
<li><a class="reference internal" href="#standard-encodings">표준 인코딩</a></li>
<li><a class="reference internal" href="#python-specific-encodings">파이썬 특정 인코딩</a><ul>
<li><a class="reference internal" href="#text-encodings">텍스트 인코딩</a></li>
<li><a class="reference internal" href="#binary-transforms">바이너리 변환</a></li>
<li><a class="reference internal" href="#text-transforms">텍스트 변환</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-encodings.idna"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code> --- 응용 프로그램에서의 국제화된 도메인 이름</a></li>
<li><a class="reference internal" href="#module-encodings.mbcs"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.mbcs</span></code> --- 윈도우 ANSI 코드 페이지</a></li>
<li><a class="reference internal" href="#module-encodings.utf_8_sig"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.utf_8_sig</span></code> --- BOM 서명이 있는 UTF-8 코덱</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="struct.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code> --- 패킹 된 바이너리 데이터로 바이트열을 해석</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="datatypes.html"
                        title="다음 장">데이터형</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="datatypes.html" title="데이터형"
             >다음</a> |</li>
        <li class="right" >
          <a href="struct.html" title="struct --- 패킹 된 바이너리 데이터로 바이트열을 해석"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="binary.html" >바이너리 데이터 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2021, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2021, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>