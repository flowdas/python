
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>xml.etree.ElementTree --- ElementTree XML API &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="xml.dom --- 문서 객체 모델 API" href="xml.dom.html" />
    <link rel="prev" title="XML 처리 모듈" href="xml.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/xml.etree.elementtree.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="xml.dom.html" title="xml.dom --- 문서 객체 모델 API"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="xml.html" title="XML 처리 모듈"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="markup.html" accesskey="U">구조화된 마크업 처리 도구</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-xml.etree.ElementTree">
<span id="xml-etree-elementtree-the-elementtree-xml-api"></span><h1><a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> --- ElementTree XML API<a class="headerlink" href="#module-xml.etree.ElementTree" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/xml/etree/ElementTree.py">Lib/xml/etree/ElementTree.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> 모듈은 XML 데이터를 구문 분석하고 만들기 위한 단순하고 효율적인 API를 구현합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>이 모듈은 가능할 때마다 빠른 구현을 사용합니다.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.3부터 폐지: </span><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.cElementTree</span></code> 모듈은 폐지되었습니다.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p><a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> 모듈은 악의적으로 구성된 데이터로부터 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 데이터를 구문 분석해야 하면 <a class="reference internal" href="xml.html#xml-vulnerabilities"><span class="std std-ref">XML 취약점</span></a>을 참조하십시오.</p>
</div>
<div class="section" id="tutorial">
<h2>자습서<a class="headerlink" href="#tutorial" title="제목 주소">¶</a></h2>
<p>이것은 <a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a>(줄여서 <code class="docutils literal notranslate"><span class="pre">ET</span></code>)를 사용하기 위한 간단한 자습서입니다. 목표는 모듈의 일부 빌딩 블록과 기본 개념을 예시하는 것입니다.</p>
<div class="section" id="xml-tree-and-elements">
<h3>XML 트리와 엘리먼트<a class="headerlink" href="#xml-tree-and-elements" title="제목 주소">¶</a></h3>
<p>XML은 본질적으로 위계적(hierarchical) 데이터 형식이며, 이를 나타내는 가장 자연스러운 방법은 트리를 사용하는 것입니다. <code class="docutils literal notranslate"><span class="pre">ET</span></code>에는 이 목적을 위한 두 가지 클래스가 있습니다 - <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a>는 전체 XML 문서를 트리로 나타내고, <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>는 이 트리에 있는 단일 노드를 나타냅니다. 전체 문서와의 상호 작용(파일 읽기와 쓰기)은 일반적으로 <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a> 수준에서 수행됩니다. 단일 XML 엘리먼트와 해당 서브 엘리먼트와의 상호 작용은 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 수준에서 수행됩니다.</p>
</div>
<div class="section" id="parsing-xml">
<span id="elementtree-parsing-xml"></span><h3>XML 구문 분석하기<a class="headerlink" href="#parsing-xml" title="제목 주소">¶</a></h3>
<p>이 섹션의 샘플 데이터로 다음 XML 문서를 사용합니다:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;data&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Liechtenstein&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank&gt;</span>1<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2008<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>141100<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Austria&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Switzerland&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Singapore&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank&gt;</span>4<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>59900<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Malaysia&quot;</span> <span class="na">direction=</span><span class="s">&quot;N&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Panama&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank&gt;</span>68<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>13600<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Costa Rica&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Colombia&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
<span class="nt">&lt;/data&gt;</span>
</pre></div>
</div>
<p>파일을 읽어서 이 데이터를 가져올 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;country_data.xml&#39;</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
</pre></div>
</div>
<p>또는 문자열에서 직접:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">country_data_as_string</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#xml.etree.ElementTree.fromstring" title="xml.etree.ElementTree.fromstring"><code class="xref py py-func docutils literal notranslate"><span class="pre">fromstring()</span></code></a>은 문자열에서 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>로 XML을 직접 구문 분석하는데, 구문 분석된 트리의 루트 엘리먼트입니다. 다른 구문 분석 함수는 <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a>를 만들 수 있습니다. 설명서를 확인하십시오.</p>
<p><a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>로서, <code class="docutils literal notranslate"><span class="pre">root</span></code>에는 태그(tag)와 어트리뷰트 딕셔너리가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">tag</span>
<span class="go">&#39;data&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span>
<span class="go">{}</span>
</pre></div>
</div>
<p>또한 우리가 이터레이트 할 수 있는 자식 노드가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">country {&#39;name&#39;: &#39;Liechtenstein&#39;}</span>
<span class="go">country {&#39;name&#39;: &#39;Singapore&#39;}</span>
<span class="go">country {&#39;name&#39;: &#39;Panama&#39;}</span>
</pre></div>
</div>
<p>자식은 중첩되며, 인덱스로 특정 자식 노드에 액세스 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span>
<span class="go">&#39;2008&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>XML 입력의 모든 엘리먼트가 구문 분석된 트리의 엘리먼트가 되는 것은 아닙니다. 현재, 이 모듈은 입력에서 XML 주석, 처리 명령(processing instructions) 및 문서 형 선언(document type declarations)을 건너뜁니다. 그런데도, XML 텍스트를 구문 분석하는 대신 이 모듈의 API를 사용하여 만들어진 트리에는 주석과 처리 명령이 있을 수 있습니다; 이들은 XML 출력을 생성할 때 포함됩니다. 사용자 정의 <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a> 인스턴스를 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 생성자에 전달하여 문서 형 선언에 액세스 할 수 있습니다.</p>
</div>
</div>
<div class="section" id="pull-api-for-non-blocking-parsing">
<span id="elementtree-pull-parsing"></span><h3>비 블로킹 구문 분석을 위한 풀(pull) API<a class="headerlink" href="#pull-api-for-non-blocking-parsing" title="제목 주소">¶</a></h3>
<p>이 모듈이 제공하는 대부분의 구문 분석 함수는 결과를 반환하기 전에 전체 문서를 한 번에 읽도록 요구합니다. <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>를 사용하고 점진적으로 데이터를 공급하는 것이 가능하지만, 콜백 대상에 메서드를 호출하는 푸시(push) API로, 대부분의 경우 너무 저 수준이고 불편합니다. 때로 사용자가 실제로 원하는 것은 완전히 구성된 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 객체의 편리함을 즐기면서 연산을 블로킹하지 않고 XML을 점진적으로 구문 분석할 수 있는 것입니다.</p>
<p>이를 위한 가장 강력한 도구는 <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a> 입니다. XML 데이터를 얻기 위해 블로킹 읽기가 필요하지 않으며, 대신 <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.feed" title="xml.etree.ElementTree.XMLPullParser.feed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLPullParser.feed()</span></code></a> 호출을 통해 점진적으로 데이터가 제공됩니다. 구문 분석된 XML 엘리먼트를 얻으려면, <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="xml.etree.ElementTree.XMLPullParser.read_events"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLPullParser.read_events()</span></code></a>를 호출하십시오. 예를 들면 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">XMLPullParser</span><span class="p">([</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="s1">&#39;&lt;mytag&gt;sometext&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">read_events</span><span class="p">())</span>
<span class="go">[(&#39;start&#39;, &lt;Element &#39;mytag&#39; at 0x7fa66db2be58&gt;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="s1">&#39; more text&lt;/mytag&gt;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">read_events</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="s1">&#39;text=&#39;</span><span class="p">,</span> <span class="n">elem</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">end</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>출력의 마지막 줄이 빠져있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mytag</span> <span class="n">text</span><span class="o">=</span> <span class="n">sometext</span> <span class="n">more</span> <span class="n">text</span>
</pre></div>
</div>
</div>
<p>명백한 사용 사례는 XML 데이터가 소켓에서 수신되거나 일부 저장 장치에서 점진적으로 읽히는 비 블로킹 방식으로 작동하는 응용 프로그램입니다. 이럴 때, 블로킹 읽기는 허용되지 않습니다.</p>
<p><a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a>는 매우 유연하기 때문에 더 단순한 사용 사례에 사용하기 불편할 수 있습니다. 응용 프로그램이 XML 데이터 읽기를 블로킹해도 상관없지만, 여전히 점진적인 구문 분석 기능이 필요하면, <a class="reference internal" href="#xml.etree.ElementTree.iterparse" title="xml.etree.ElementTree.iterparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">iterparse()</span></code></a>를 살펴보십시오. 큰 XML 문서를 읽을 때 메모리에 전체를 저장하지 않으려는 경우 유용할 수 있습니다.</p>
</div>
<div class="section" id="finding-interesting-elements">
<h3>흥미로운 엘리먼트 찾기<a class="headerlink" href="#finding-interesting-elements" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>에는 그 아래의 모든 서브 트리(자식, 자식의 자식 등)를 재귀적으로 이터레이트 하는 데 도움을 주는 유용한 메서드가 있습니다. 예를 들어, <a class="reference internal" href="#xml.etree.ElementTree.Element.iter" title="xml.etree.ElementTree.Element.iter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.iter()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;neighbor&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">neighbor</span><span class="o">.</span><span class="n">attrib</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">{&#39;name&#39;: &#39;Austria&#39;, &#39;direction&#39;: &#39;E&#39;}</span>
<span class="go">{&#39;name&#39;: &#39;Switzerland&#39;, &#39;direction&#39;: &#39;W&#39;}</span>
<span class="go">{&#39;name&#39;: &#39;Malaysia&#39;, &#39;direction&#39;: &#39;N&#39;}</span>
<span class="go">{&#39;name&#39;: &#39;Costa Rica&#39;, &#39;direction&#39;: &#39;W&#39;}</span>
<span class="go">{&#39;name&#39;: &#39;Colombia&#39;, &#39;direction&#39;: &#39;E&#39;}</span>
</pre></div>
</div>
<p><a class="reference internal" href="#xml.etree.ElementTree.Element.findall" title="xml.etree.ElementTree.Element.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.findall()</span></code></a>은 현재 엘리먼트의 직접적인 자식인 태그가 있는 엘리먼트만 찾습니다. <a class="reference internal" href="#xml.etree.ElementTree.Element.find" title="xml.etree.ElementTree.Element.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.find()</span></code></a>는 특정 태그가 있는 <em>첫 번째</em> 자식을 찾고, <a class="reference internal" href="#xml.etree.ElementTree.Element.text" title="xml.etree.ElementTree.Element.text"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Element.text</span></code></a>는 엘리먼트의 텍스트 내용에 액세스합니다. <a class="reference internal" href="#xml.etree.ElementTree.Element.get" title="xml.etree.ElementTree.Element.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.get()</span></code></a>은 엘리먼트의 어트리뷰트에 액세스합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">country</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;country&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">rank</span> <span class="o">=</span> <span class="n">country</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="n">country</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Liechtenstein 1</span>
<span class="go">Singapore 4</span>
<span class="go">Panama 68</span>
</pre></div>
</div>
<p><a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">XPath</span></a>를 사용하면 찾을 엘리먼트를 더 정교하게 지정할 수 있습니다.</p>
</div>
<div class="section" id="modifying-an-xml-file">
<h3>XML 파일 수정하기<a class="headerlink" href="#modifying-an-xml-file" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a>는 XML 문서를 구축하고 파일에 쓰는 간단한 방법을 제공합니다. <a class="reference internal" href="#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ElementTree.write()</span></code></a> 메서드가 이 용도입니다.</p>
<p>일단 만들어지면, <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 객체는 필드(가령 <a class="reference internal" href="#xml.etree.ElementTree.Element.text" title="xml.etree.ElementTree.Element.text"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Element.text</span></code></a>)를 직접 변경하고, 어트리뷰트를 추가하고 수정(<a class="reference internal" href="#xml.etree.ElementTree.Element.set" title="xml.etree.ElementTree.Element.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.set()</span></code></a> 메서드)하는 것뿐만 아니라 새로운 자식을 추가하여 (예를 들어 <a class="reference internal" href="#xml.etree.ElementTree.Element.append" title="xml.etree.ElementTree.Element.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.append()</span></code></a>) 조작 할 수 있습니다.</p>
<p>각각의 국가(country)의 순위(rank)에 1을 더하고, rank 엘리먼트에 <code class="docutils literal notranslate"><span class="pre">updated</span></code> 어트리뷰트를 추가하고 싶다고 합시다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">new_rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rank</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">rank</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_rank</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">rank</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;updated&#39;</span><span class="p">,</span> <span class="s1">&#39;yes&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;output.xml&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>우리의 XML은 이제 다음과 같습니다:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;data&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Liechtenstein&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>2<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2008<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>141100<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Austria&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Switzerland&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Singapore&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>5<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>59900<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Malaysia&quot;</span> <span class="na">direction=</span><span class="s">&quot;N&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Panama&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>69<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>13600<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Costa Rica&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Colombia&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
<span class="nt">&lt;/data&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#xml.etree.ElementTree.Element.remove" title="xml.etree.ElementTree.Element.remove"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.remove()</span></code></a>를 사용하여 엘리먼트를 제거할 수 있습니다. rank가 50보다 큰 모든 국가를 제거하려고 한다고 합시다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">country</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;country&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># using root.findall() to avoid removal during traversal</span>
<span class="gp">... </span>    <span class="n">rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">country</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">root</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">country</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;output.xml&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>이터레이션 하는 동안 동시 수정은 파이썬 리스트나 딕셔너리를 이터레이션 할 때와 마찬가지로 문제를 유발할 수 있음에 유의하십시오. 따라서, 이 예제에서는 먼저 <code class="docutils literal notranslate"><span class="pre">root.findall()</span></code>로 일치하는 모든 엘리먼트를 수집한 다음, 일치 항목 리스트를 이터레이트 합니다.</p>
<p>우리의 XML은 이제 다음과 같습니다:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;data&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Liechtenstein&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>2<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2008<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>141100<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Austria&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Switzerland&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Singapore&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>5<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>59900<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Malaysia&quot;</span> <span class="na">direction=</span><span class="s">&quot;N&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
<span class="nt">&lt;/data&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="building-xml-documents">
<h3>XML 문서 구축하기<a class="headerlink" href="#building-xml-documents" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#xml.etree.ElementTree.SubElement" title="xml.etree.ElementTree.SubElement"><code class="xref py py-func docutils literal notranslate"><span class="pre">SubElement()</span></code></a> 함수는 주어진 엘리먼트에 대해 새로운 서브 엘리먼트를 만드는 편리한 방법을 제공합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ET</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;a&gt;&lt;b /&gt;&lt;c&gt;&lt;d /&gt;&lt;/c&gt;&lt;/a&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="parsing-xml-with-namespaces">
<h3>이름 공간이 있는 XML 구문 분석하기<a class="headerlink" href="#parsing-xml-with-namespaces" title="제목 주소">¶</a></h3>
<p>XML 입력에 <a class="reference external" href="https://en.wikipedia.org/wiki/XML_namespace">이름 공간(namespaces)</a>이 있으면, <code class="docutils literal notranslate"><span class="pre">prefix:sometag</span></code> 형식의 접두사가 있는 태그와 어트리뷰트는 <code class="docutils literal notranslate"><span class="pre">{uri}sometag</span></code>로 확장되는데, 여기서 <em>prefix</em>는 전체 <em>URI</em>로 대체됩니다. 또한 <a class="reference external" href="https://www.w3.org/TR/xml-names/#defaulting">기본 이름 공간(default namespace)</a>이 있으면, 그 전체 URI가 접두사가 없는 모든 태그 앞에 추가됩니다.</p>
<p>다음은 두 개의 이름 공간을 통합한 XML 예제입니다, 하나는 접두사가 &quot;fictional&quot;이고 다른 하나는 기본 이름 공간으로 사용됩니다:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;actors</span> <span class="na">xmlns:fictional=</span><span class="s">&quot;http://characters.example.com&quot;</span>
        <span class="na">xmlns=</span><span class="s">&quot;http://people.example.com&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;actor&gt;</span>
        <span class="nt">&lt;name&gt;</span>John Cleese<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Lancelot<span class="nt">&lt;/fictional:character&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Archie Leach<span class="nt">&lt;/fictional:character&gt;</span>
    <span class="nt">&lt;/actor&gt;</span>
    <span class="nt">&lt;actor&gt;</span>
        <span class="nt">&lt;name&gt;</span>Eric Idle<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Sir Robin<span class="nt">&lt;/fictional:character&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Gunther<span class="nt">&lt;/fictional:character&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Commander Clement<span class="nt">&lt;/fictional:character&gt;</span>
    <span class="nt">&lt;/actor&gt;</span>
<span class="nt">&lt;/actors&gt;</span>
</pre></div>
</div>
<p>이 XML 예제를 검색하고 탐색하는 한 가지 방법은 <a class="reference internal" href="#xml.etree.ElementTree.Element.find" title="xml.etree.ElementTree.Element.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a>나 <a class="reference internal" href="#xml.etree.ElementTree.Element.findall" title="xml.etree.ElementTree.Element.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">findall()</span></code></a>의 xpath에 있는 모든 태그나 어트리뷰트에 URI를 수동으로 추가하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">fromstring</span><span class="p">(</span><span class="n">xml_text</span><span class="p">)</span>
<span class="k">for</span> <span class="n">actor</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;{http://people.example.com}actor&#39;</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;{http://people.example.com}name&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">actor</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;{http://characters.example.com}character&#39;</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; |--&gt;&#39;</span><span class="p">,</span> <span class="n">char</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
<p>이름 공간이 있는 XML 예제를 검색하는 더 좋은 방법은 여러분 자신의 접두사가 담긴 딕셔너리를 만들고 검색 함수에서 사용하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ns</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;real_person&#39;</span><span class="p">:</span> <span class="s1">&#39;http://people.example.com&#39;</span><span class="p">,</span>
      <span class="s1">&#39;role&#39;</span><span class="p">:</span> <span class="s1">&#39;http://characters.example.com&#39;</span><span class="p">}</span>

<span class="k">for</span> <span class="n">actor</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;real_person:actor&#39;</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;real_person:name&#39;</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">actor</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;role:character&#39;</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; |--&gt;&#39;</span><span class="p">,</span> <span class="n">char</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
<p>이 두 가지 방법 모두 다음과 같이 출력합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">John</span> <span class="n">Cleese</span>
 <span class="o">|--&gt;</span> <span class="n">Lancelot</span>
 <span class="o">|--&gt;</span> <span class="n">Archie</span> <span class="n">Leach</span>
<span class="n">Eric</span> <span class="n">Idle</span>
 <span class="o">|--&gt;</span> <span class="n">Sir</span> <span class="n">Robin</span>
 <span class="o">|--&gt;</span> <span class="n">Gunther</span>
 <span class="o">|--&gt;</span> <span class="n">Commander</span> <span class="n">Clement</span>
</pre></div>
</div>
</div>
<div class="section" id="additional-resources">
<h3>추가 자료<a class="headerlink" href="#additional-resources" title="제목 주소">¶</a></h3>
<p>자습서와 다른 문서에 대한 링크는 <a class="reference external" href="http://effbot.org/zone/element-index.htm">http://effbot.org/zone/element-index.htm</a> 을 참조하십시오.</p>
</div>
</div>
<div class="section" id="xpath-support">
<span id="elementtree-xpath"></span><h2>XPath 지원<a class="headerlink" href="#xpath-support" title="제목 주소">¶</a></h2>
<p>이 모듈은 트리에서 엘리먼트를 찾기 위해 <a class="reference external" href="https://www.w3.org/TR/xpath">XPath 표현식</a>을 제한적으로 지원합니다. 목표는 축약된 문법의 작은 부분 집합을 지원하는 것입니다; 완전한 XPath 엔진은 이 모듈의 범위를 벗어납니다.</p>
<div class="section" id="example">
<h3>예<a class="headerlink" href="#example" title="제목 주소">¶</a></h3>
<p>다음은 모듈의 일부 XPath 기능을 보여주는 예입니다. <a class="reference internal" href="#elementtree-parsing-xml"><span class="std std-ref">XML 구문 분석하기</span></a> 섹션의 <code class="docutils literal notranslate"><span class="pre">countrydata</span></code> XML 문서를 사용할 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>

<span class="n">root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">countrydata</span><span class="p">)</span>

<span class="c1"># 최상위 엘리먼트</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>

<span class="c1"># 최상위 엘리먼트의 모든 &#39;country&#39; 자식의 &#39;neighbor&#39; 손자</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;./country/neighbor&quot;</span><span class="p">)</span>

<span class="c1"># &#39;year&#39; 자식이 있고 name=&#39;Singapore&#39;인 노드</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.//year/..[@name=&#39;Singapore&#39;]&quot;</span><span class="p">)</span>

<span class="c1"># name=&#39;Singapore&#39;인 노드의 자식인 &#39;year&#39; 노드</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.//*[@name=&#39;Singapore&#39;]/year&quot;</span><span class="p">)</span>

<span class="c1"># 부모의 두 번째 자식인 모든 &#39;neighbor&#39; 노드</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.//neighbor[2]&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>이름 공간이 있는 XML의 경우, 일반적인 정규화된 <code class="docutils literal notranslate"><span class="pre">{namespace}tag</span></code> 표기법을 사용하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 문서의 모든 더블린 코어(dublin-core) &quot;title&quot; 태그</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.//{http://purl.org/dc/elements/1.1/}title&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="supported-xpath-syntax">
<h3>지원되는 XPath 문법<a class="headerlink" href="#supported-xpath-syntax" title="제목 주소">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>문법</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tag</span></code></p></td>
<td><p>주어진 태그를 가진 모든 자식 엘리먼트를 선택합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">spam</span></code>은 <code class="docutils literal notranslate"><span class="pre">spam</span></code>이라는 모든 자식 엘리먼트를 선택하고, <code class="docutils literal notranslate"><span class="pre">spam/egg</span></code>는 <code class="docutils literal notranslate"><span class="pre">spam</span></code>이라는 모든 자식의 <code class="docutils literal notranslate"><span class="pre">egg</span></code>라는 모든 손자를 선택합니다. <code class="docutils literal notranslate"><span class="pre">{namespace}*</span></code>는 지정된 이름 공간의 모든 태그를 선택하고, <code class="docutils literal notranslate"><span class="pre">{*}spam</span></code>은 모든 이름 공간의 (또는 이름 공간이 없는) <code class="docutils literal notranslate"><span class="pre">spam</span></code>이라는 태그를 선택하고, <code class="docutils literal notranslate"><span class="pre">{}*</span></code>은 이름 공간이 없는 태그만 선택합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>애스터리스크 와일드카드 지원이 추가되었습니다.</p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">*</span></code></p></td>
<td><p>주석과 처리 명령을 포함한 모든 자식 엘리먼트를 선택합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">*/egg</span></code>는 <code class="docutils literal notranslate"><span class="pre">egg</span></code>라는 모든 손자를 선택합니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.</span></code></p></td>
<td><p>현재 노드를 선택합니다. 상대 경로임을 나타내기 위해 경로의 시작 부분에서 주로 유용합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">//</span></code></p></td>
<td><p>현재 엘리먼트 아래의 모든 수준에서 모든 서브 엘리먼트를 선택합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">.//egg</span></code>는 전체 트리에서 모든 <code class="docutils literal notranslate"><span class="pre">egg</span></code> 엘리먼트를 선택합니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">..</span></code></p></td>
<td><p>부모 엘리먼트를 선택합니다. 경로가 (엘리먼트 <code class="docutils literal notranslate"><span class="pre">find</span></code>가 호출된) 시작 엘리먼트의 조상에 도달하려고 하면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[&#64;attrib]</span></code></p></td>
<td><p>주어진 어트리뷰트를 가진 모든 엘리먼트를 선택합니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[&#64;attrib='value']</span></code></p></td>
<td><p>주어진 어트리뷰트가 주어진 값을 갖는 모든 엘리먼트를 선택합니다. 값은 따옴표를 포함할 수 없습니다.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[tag]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">tag</span></code>라는 자식이 있는 모든 엘리먼트를 선택합니다. 직계 자식만 지원됩니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[.='text']</span></code></p></td>
<td><p>자손을 포함한 전체 텍스트 내용이 주어진 <code class="docutils literal notranslate"><span class="pre">text</span></code>와 같은 모든 엘리먼트를 선택합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[tag='text']</span></code></p></td>
<td><p>자손을 포함한 전체 텍스트 내용이 지정된 <code class="docutils literal notranslate"><span class="pre">text</span></code>와 같은 이름이 <code class="docutils literal notranslate"><span class="pre">tag</span></code>인 자식이 있는 모든 엘리먼트를 선택합니다.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[position]</span></code></p></td>
<td><p>주어진 위치(position)에 있는 모든 엘리먼트를 선택합니다. 위치(position)는 정수(1이 첫 번째 위치입니다), 표현식 <code class="docutils literal notranslate"><span class="pre">last()</span></code> (마지막 위치) 또는 마지막 위치에 상대적인 위치(예를 들어 <code class="docutils literal notranslate"><span class="pre">last()-1</span></code>)일 수 있습니다.</p></td>
</tr>
</tbody>
</table>
<p>술어 (대괄호 안에 있는 표현식) 앞에는 태그 이름, 애스터리스크 또는 다른 술어가 와야 합니다. <code class="docutils literal notranslate"><span class="pre">position</span></code> 술어 앞에는 태그 이름이 와야 합니다.</p>
</div>
</div>
<div class="section" id="reference">
<h2>레퍼런스<a class="headerlink" href="#reference" title="제목 주소">¶</a></h2>
<div class="section" id="functions">
<span id="elementtree-functions"></span><h3>함수<a class="headerlink" href="#functions" title="제목 주소">¶</a></h3>
<dl class="function">
<dt id="xml.etree.ElementTree.canonicalize">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">canonicalize</code><span class="sig-paren">(</span><em class="sig-param">xml_data=None</em>, <em class="sig-param">*</em>, <em class="sig-param">out=None</em>, <em class="sig-param">from_file=None</em>, <em class="sig-param">**options</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.canonicalize" title="정의 주소">¶</a></dt>
<dd><p><a class="reference external" href="https://www.w3.org/TR/xml-c14n2/">C14N 2.0</a> 변환 함수.</p>
<p>규범화(canonicalization)는 바이트 단위 비교와 디지털 서명을 허용하는 방식으로 XML 출력을 정규화하는 방법입니다. XML 직렬화기가 갖는 자유도를 줄이고 대신 더 제한된 XML 표현을 생성합니다. 주요 제한 사항은 이름 공간 선언의 배치, 어트리뷰트의 순서 및 무시할 수 있는 공백입니다.</p>
<p>이 함수는 XML 데이터 문자열(<em>xml_data</em>)이나 파일 경로 또는 파일류 객체(<em>from_file</em>)를 입력으로 받아서, 규범적 형식으로 변환한 후, 제공된다면 <em>out</em> 파일(류) 객체를 사용하여 기록하고, 그렇지 않으면 텍스트 문자열로 반환합니다. 출력 파일은 바이트열이 아닌 텍스트를 받습니다. 따라서 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> 인코딩을 사용하여 텍스트 모드로 열어야 합니다.</p>
<p>일반적인 사용:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">xml_data</span> <span class="o">=</span> <span class="s2">&quot;&lt;root&gt;...&lt;/root&gt;&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">canonicalize</span><span class="p">(</span><span class="n">xml_data</span><span class="p">))</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;c14n_output.xml&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_file</span><span class="p">:</span>
    <span class="n">canonicalize</span><span class="p">(</span><span class="n">xml_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out_file</span><span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;c14n_output.xml&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_file</span><span class="p">:</span>
    <span class="n">canonicalize</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s2">&quot;inputfile.xml&quot;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out_file</span><span class="p">)</span>
</pre></div>
</div>
<p>구성 <em>options</em>는 다음과 같습니다:</p>
<ul class="simple">
<li><p><em>with_comments</em>: 주석을 포함하려면 참으로 설정합니다 (기본값: 거짓).</p></li>
<li><dl class="simple">
<dt><em>strip_text</em>: 텍스트 내용 전후의 공백을 제거하려면 참으로 설정합니다</dt><dd><p>(기본값: 거짓)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><em>rewrite_prefixes</em>: 이름 공간 접두사를 &quot;n{number}&quot; 로 바꾸려면 참으로 설정합니다</dt><dd><p>(기본값: 거짓)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><em>qname_aware_tags</em>: 텍스트 내용에서 접두사를 대체해야 하는 qname 인식 태그 이름 집합</dt><dd><p>(기본값: 비어 있음)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><em>qname_aware_attrs</em>: 텍스트 내용에서 접두사를 대체해야 하는 qname 인식 어트리뷰트 이름 집합</dt><dd><p>(기본값: 비어 있음)</p>
</dd>
</dl>
</li>
<li><p><em>exclude_attrs</em>: 직렬화하면 안 되는 어트리뷰트 이름 집합</p></li>
<li><p><em>exclude_tags</em>: 직렬화하면 안 되는 태그 이름 집합</p></li>
</ul>
<p>위의 옵션 목록에서, &quot;집합&quot;은 문자열의 모든 컬렉션이나 이터러블을 가리키며, 순서는 고려하지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.Comment">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">Comment</code><span class="sig-paren">(</span><em class="sig-param">text=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Comment" title="정의 주소">¶</a></dt>
<dd><p>주석 엘리먼트 팩토리. 이 팩토리 함수는 표준 직렬화기가 XML 주석으로 직렬화할 특수 엘리먼트를 만듭니다. 주석 문자열은 바이트 문자열이나 유니코드 문자열일 수 있습니다. <em>text</em>는 주석 문자열이 포함된 문자열입니다. 주석을 나타내는 엘리먼트 인스턴스를 반환합니다.</p>
<p><a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>는 주석 객체를 만드는 대신 입력에서 주석을 건너뜀에 유의하십시오. <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a>는 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 메서드 중 하나를 사용하여 트리에 삽입된 주석 노드만 포함합니다.</p>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.dump">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">dump</code><span class="sig-paren">(</span><em class="sig-param">elem</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.dump" title="정의 주소">¶</a></dt>
<dd><p>엘리먼트 트리나 엘리먼트 구조를 sys.stdout에 씁니다. 이 함수는 디버깅에만 사용해야 합니다.</p>
<p>정확한 출력 형식은 구현에 따라 다릅니다. 이 버전에서는, 일반 XML 파일로 기록됩니다.</p>
<p><em>elem</em>은 엘리먼트 트리나 개별 엘리먼트입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><a class="reference internal" href="#xml.etree.ElementTree.dump" title="xml.etree.ElementTree.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a> 함수는 이제 사용자가 지정한 어트리뷰트 순서를 유지합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.fromstring">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">fromstring</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">parser=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.fromstring" title="정의 주소">¶</a></dt>
<dd><p>문자열 상수에서 XML 섹션을 구문 분석합니다. <a class="reference internal" href="#xml.etree.ElementTree.XML" title="xml.etree.ElementTree.XML"><code class="xref py py-func docutils literal notranslate"><span class="pre">XML()</span></code></a>과 같습니다. <em>text</em>는 XML 데이터를 포함하는 문자열입니다. <em>parser</em>는 선택적 구문 분석기 인스턴스입니다. 지정하지 않으면, 표준 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 구문 분석기가 사용됩니다. <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 인스턴스를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.fromstringlist">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">fromstringlist</code><span class="sig-paren">(</span><em class="sig-param">sequence</em>, <em class="sig-param">parser=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.fromstringlist" title="정의 주소">¶</a></dt>
<dd><p>문자열 조각의 시퀀스에서 XML 문서를 구문 분석합니다. <em>sequence</em>는 XML 데이터 조각을 포함하는 리스트나 다른 시퀀스입니다. <em>parser</em>는 선택적 구문 분석기 인스턴스입니다. 지정하지 않으면 표준 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 구문 분석기가 사용됩니다. <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 인스턴스를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.indent">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">indent</code><span class="sig-paren">(</span><em class="sig-param">tree</em>, <em class="sig-param">space=&quot;  &quot;</em>, <em class="sig-param">level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.indent" title="정의 주소">¶</a></dt>
<dd><p>트리를 시각적으로 들여쓰기하기 위해 서브 트리에 공백을 추가합니다. 이것은 예쁘게 인쇄된 XML 출력을 생성하는 데 사용될 수 있습니다. <em>tree</em>는 Element나 ElementTree 일 수 있습니다. <em>space</em>는 각 들여쓰기 수준에 삽입되는 공백 문자열이며 기본적으로 두 개의 스페이스 문자입니다. 이미 들여쓰기 된 트리 내부에서 부분 서브 트리를 들여 쓰려면, 초기 들여쓰기 수준을 <em>level</em>로 전달하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.iselement">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">iselement</code><span class="sig-paren">(</span><em class="sig-param">element</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.iselement" title="정의 주소">¶</a></dt>
<dd><p>객체가 유효한 엘리먼트 객체로 보이는지 확인합니다. <em>element</em>는 엘리먼트 인스턴스입니다. 이것이 엘리먼트 객체이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.iterparse">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">iterparse</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">events=None</em>, <em class="sig-param">parser=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.iterparse" title="정의 주소">¶</a></dt>
<dd><p>XML 섹션을 엘리먼트 트리로 점진적으로 구문 분석하고, 사용자에게 진행 중인 작업을 보고합니다. <em>source</em>는 파일명이나 XML 데이터를 포함하는 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a>입니다. <em>events</em>는 보고할 이벤트의 시퀀스입니다. 지원되는 이벤트는 문자열 <code class="docutils literal notranslate"><span class="pre">&quot;start&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;end&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;comment&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;pi&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;start-ns&quot;</span></code> 및 <code class="docutils literal notranslate"><span class="pre">&quot;end-ns&quot;</span></code>입니다 (&quot;ns&quot; 이벤트는 자세한 이름 공간 정보를 얻는 데 사용됩니다). <em>events</em>를 생략하면, <code class="docutils literal notranslate"><span class="pre">&quot;end&quot;</span></code> 이벤트만 보고됩니다. <em>parser</em>는 선택적 구문 분석기 인스턴스입니다. 지정하지 않으면 표준 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 구문 분석기가 사용됩니다. <em>parser</em>는 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>의 서브 클래스여야 하며 기본 <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a> 만 대상으로 사용할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">(event,</span> <span class="pre">elem)</span></code> 쌍을 제공하는 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a>를 반환합니다.</p>
<p><a class="reference internal" href="#xml.etree.ElementTree.iterparse" title="xml.etree.ElementTree.iterparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">iterparse()</span></code></a>는 점진적으로 트리를 구축하지만, <em>source</em>(또는 그 이름의 파일)에 대한 블로킹 읽기를 유발함에 유의하십시오. 따라서, 블로킹 읽기를 할 수 없는 응용 프로그램에는 적합하지 않습니다. 완전한 비 블로킹 구문 분석에 대해서는 <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a>를 참조하십시오.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#xml.etree.ElementTree.iterparse" title="xml.etree.ElementTree.iterparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">iterparse()</span></code></a>는 &quot;start&quot; 이벤트를 방출할 때 시작 태그의 &quot;&gt;&quot; 문자를 보았다는 것만 보장해서, 어트리뷰트는 정의되지만, 텍스트의 내용과 테일(tail) 어트리뷰트는 그 시점에 정의되지 않습니다. 자식 엘리먼트에도 마찬가지로 적용됩니다; 그들은 존재할 수도 그렇지 않을 수도 있습니다.</p>
<p>완전히 채워진 엘리먼트가 필요하면, 대신 &quot;end&quot; 이벤트를 찾으십시오.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.4부터 폐지: </span><em>parser</em> 인자.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><code class="docutils literal notranslate"><span class="pre">comment</span></code>와 <code class="docutils literal notranslate"><span class="pre">pi</span></code> 이벤트가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.parse">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">parse</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">parser=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.parse" title="정의 주소">¶</a></dt>
<dd><p>XML 섹션을 엘리먼트 트리로 구문 분석합니다. <em>source</em>는 XML 데이터를 포함하는 파일명이나 파일 객체입니다. <em>parser</em>는 선택적 구문 분석기 인스턴스입니다. 지정하지 않으면 표준 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 구문 분석기가 사용됩니다. <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a> 인스턴스를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.ProcessingInstruction">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">ProcessingInstruction</code><span class="sig-paren">(</span><em class="sig-param">target</em>, <em class="sig-param">text=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ProcessingInstruction" title="정의 주소">¶</a></dt>
<dd><p>PI 엘리먼트 팩토리. 이 팩토리 함수는 XML 처리 명령으로 직렬화될 특수 엘리먼트를 만듭니다. <em>target</em>은 PI 대상을 포함하는 문자열입니다. 주어지면, <em>text</em>는 PI 내용을 포함하는 문자열입니다. 처리 명령을 나타내는 엘리먼트 인스턴스를 반환합니다.</p>
<p><a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>는 처리 명령 객체를 작성하는 대신 입력에서 처리 명령을 건너뜀에 유의하십시오. <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a>는 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 메서드 중 하나를 사용하여 트리에 삽입된 처리 명령 노드만 포함합니다.</p>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.register_namespace">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">register_namespace</code><span class="sig-paren">(</span><em class="sig-param">prefix</em>, <em class="sig-param">uri</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.register_namespace" title="정의 주소">¶</a></dt>
<dd><p>이름 공간 접두사를 등록합니다. 레지스트리는 전역적이며, 지정된 접두사나 이름 공간 URI에 대한 기존 매핑이 제거됩니다. <em>prefix</em>는 이름 공간 접두사입니다. <em>uri</em>는 이름 공간 URI입니다. 이 이름 공간의 태그와 어트리뷰트는 가능하다면 주어진 접두사로 직렬화됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.SubElement">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">SubElement</code><span class="sig-paren">(</span><em class="sig-param">parent</em>, <em class="sig-param">tag</em>, <em class="sig-param">attrib={}</em>, <em class="sig-param">**extra</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.SubElement" title="정의 주소">¶</a></dt>
<dd><p>서브 엘리먼트 팩토리. 이 함수는 엘리먼트 인스턴스를 만들어 기존 엘리먼트에 추가합니다.</p>
<p>엘리먼트 이름, 어트리뷰트 이름 및 어트리뷰트 값은 바이트 문자열이나 유니코드 문자열일 수 있습니다. <em>parent</em>는 부모 엘리먼트입니다. <em>tag</em>는 서브 엘리먼트 이름입니다. <em>attrib</em>는 엘리먼트 어트리뷰트를 포함하는 선택적 딕셔너리입니다. <em>extra</em>에는 키워드 인자로 지정된 추가 어트리뷰트가 포함됩니다. 엘리먼트 인스턴스를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.tostring">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">tostring</code><span class="sig-paren">(</span><em class="sig-param">element</em>, <em class="sig-param">encoding=&quot;us-ascii&quot;</em>, <em class="sig-param">method=&quot;xml&quot;</em>, <em class="sig-param">*</em>, <em class="sig-param">xml_declaration=None</em>, <em class="sig-param">default_namespace=None</em>, <em class="sig-param">short_empty_elements=True</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.tostring" title="정의 주소">¶</a></dt>
<dd><p>모든 서브 엘리먼트를 포함하는, XML 엘리먼트의 문자열 표현을 생성합니다. <em>element</em>는 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 인스턴스입니다. <em>encoding</em> <a class="footnote-reference brackets" href="#id9" id="id1">1</a> 은 출력 인코딩입니다 (기본값은 US-ASCII입니다). <code class="docutils literal notranslate"><span class="pre">encoding=&quot;unicode&quot;</span></code>를 사용하여 유니코드 문자열을 생성하십시오 (그렇지 않으면 바이트 문자열이 생성됩니다). <em>method</em>는 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;html&quot;</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">&quot;text&quot;</span></code>입니다 (기본값은 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>입니다). <em>xml_declaration</em>, <em>default_namespace</em> 및 <em>short_empty_elements</em>는 <a class="reference internal" href="#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ElementTree.write()</span></code></a>에서와 같은 의미입니다. XML 데이터를 포함하는 (선택적으로) 인코딩된 문자열을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가: </span><em>short_empty_elements</em> 매개 변수.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가: </span><em>xml_declaration</em>과 <em>default_namespace</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><a class="reference internal" href="#xml.etree.ElementTree.tostring" title="xml.etree.ElementTree.tostring"><code class="xref py py-func docutils literal notranslate"><span class="pre">tostring()</span></code></a> 함수는 이제 사용자가 지정한 어트리뷰트 순서를 유지합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.tostringlist">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">tostringlist</code><span class="sig-paren">(</span><em class="sig-param">element</em>, <em class="sig-param">encoding=&quot;us-ascii&quot;</em>, <em class="sig-param">method=&quot;xml&quot;</em>, <em class="sig-param">*</em>, <em class="sig-param">xml_declaration=None</em>, <em class="sig-param">default_namespace=None</em>, <em class="sig-param">short_empty_elements=True</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.tostringlist" title="정의 주소">¶</a></dt>
<dd><p>모든 서브 엘리먼트를 포함하는, XML 엘리먼트의 문자열 표현을 생성합니다. <em>element</em>는 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 인스턴스입니다. <em>encoding</em> <a class="footnote-reference brackets" href="#id9" id="id2">1</a> 은 출력 인코딩입니다 (기본값은 US-ASCII입니다). <code class="docutils literal notranslate"><span class="pre">encoding=&quot;unicode&quot;</span></code>를 사용하여 유니코드 문자열을 생성하십시오 (그렇지 않으면 바이트 문자열이 생성됩니다). <em>method</em>는 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;html&quot;</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">&quot;text&quot;</span></code>입니다 (기본값은 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>입니다). <em>xml_declaration</em>, <em>default_namespace</em> 및 <em>short_empty_elements</em>는 <a class="reference internal" href="#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ElementTree.write()</span></code></a>에서와 같은 의미입니다. XML 데이터가 포함된 (선택적으로) 인코딩된 문자열의 리스트를 반환합니다. <code class="docutils literal notranslate"><span class="pre">b&quot;&quot;.join(tostringlist(element))</span> <span class="pre">==</span> <span class="pre">tostring(element)</span></code>라는 사실을 제외하고는, 특정 시퀀스를 보장하지는 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가: </span><em>short_empty_elements</em> 매개 변수.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가: </span><em>xml_declaration</em>과 <em>default_namespace</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><a class="reference internal" href="#xml.etree.ElementTree.tostringlist" title="xml.etree.ElementTree.tostringlist"><code class="xref py py-func docutils literal notranslate"><span class="pre">tostringlist()</span></code></a> 함수는 이제 사용자가 지정한 어트리뷰트 순서를 유지합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.XML">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">XML</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">parser=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XML" title="정의 주소">¶</a></dt>
<dd><p>문자열 상수에서 XML 섹션을 구문 분석합니다. 이 함수는 &quot;XML 리터럴&quot;을 파이썬 코드에 내장시키는 데 사용할 수 있습니다. <em>text</em>는 XML 데이터를 포함하는 문자열입니다. <em>parser</em>는 선택적 구문 분석기 인스턴스입니다. 지정하지 않으면 표준 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 구문 분석기가 사용됩니다. <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 인스턴스를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.XMLID">
<code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">XMLID</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">parser=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLID" title="정의 주소">¶</a></dt>
<dd><p>문자열 상수에서 XML 섹션을 구문 분석하고, 엘리먼트 id:s 를 엘리먼트로 매핑하는 딕셔너리도 반환합니다. <em>text</em>는 XML 데이터를 포함하는 문자열입니다. <em>parser</em>는 선택적 구문 분석기 인스턴스입니다. 지정하지 않으면 표준 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 구문 분석기가 사용됩니다. <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 인스턴스와 딕셔너리를 포함하는 튜플을 반환합니다.</p>
</dd></dl>

</div>
</div>
<div class="section" id="xinclude-support">
<span id="elementtree-xinclude"></span><h2>XInclude 지원<a class="headerlink" href="#xinclude-support" title="제목 주소">¶</a></h2>
<p>이 모듈은 <code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementInclude</span></code> 도우미 모듈을 통해 <a class="reference external" href="https://www.w3.org/TR/xinclude/">XInclude 지시어</a>를 제한적으로 지원합니다. 이 모듈은 트리의 정보를 기반으로, 서브 트리와 텍스트 문자열을 엘리먼트 트리에 삽입하는 데 사용할 수 있습니다.</p>
<div class="section" id="id3">
<h3>예<a class="headerlink" href="#id3" title="제목 주소">¶</a></h3>
<p>다음은 XInclude 모듈의 사용법을 보여주는 예입니다. 현재 문서에 XML 문서를 포함 시키려면, <code class="docutils literal notranslate"><span class="pre">{http://www.w3.org/2001/XInclude}include</span></code> 엘리먼트를 사용하고 <strong>parse</strong> 어트리뷰트를 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>로 설정하고, <strong>href</strong> 어트리뷰트를 사용하여 포함할 문서를 지정하십시오.</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;document</span> <span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;xi:include</span> <span class="na">href=</span><span class="s">&quot;source.xml&quot;</span> <span class="na">parse=</span><span class="s">&quot;xml&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/document&gt;</span>
</pre></div>
</div>
<p>기본적으로, <strong>href</strong> 어트리뷰트는 파일 이름으로 취급됩니다. 사용자 정의 로더를 사용하여 이 동작을 대체 할 수 있습니다. 또한 표준 도우미는 XPointer 문법을 지원하지 않음에 유의하십시오.</p>
<p>이 파일을 처리하려면, 평소와 같이 로드하고, 루트 엘리먼트를 <a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> 모듈에 전달하십시오:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml.etree</span> <span class="kn">import</span> <span class="n">ElementTree</span><span class="p">,</span> <span class="n">ElementInclude</span>

<span class="n">tree</span> <span class="o">=</span> <span class="n">ElementTree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;document.xml&quot;</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>

<span class="n">ElementInclude</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
<p>ElementInclude 모듈은 <code class="docutils literal notranslate"><span class="pre">{http://www.w3.org/2001/XInclude}include</span></code> 엘리먼트를 <strong>source.xml</strong> 문서의 루트 엘리먼트로 바꿉니다. 결과는 다음과 같습니다:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;document</span> <span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;para&gt;</span>This is a paragraph.<span class="nt">&lt;/para&gt;</span>
<span class="nt">&lt;/document&gt;</span>
</pre></div>
</div>
<p><strong>parse</strong> 어트리뷰트가 생략되면, 기본값은 &quot;xml&quot;입니다. href 어트리뷰트는 필수입니다.</p>
<p>텍스트 문서를 포함 시키려면, <code class="docutils literal notranslate"><span class="pre">{http://www.w3.org/2001/XInclude}include</span></code> 엘리먼트를 사용하고, <strong>parse</strong> 어트리뷰트를 &quot;text&quot;로 설정하십시오:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;document</span> <span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span><span class="nt">&gt;</span>
  Copyright (c) <span class="nt">&lt;xi:include</span> <span class="na">href=</span><span class="s">&quot;year.txt&quot;</span> <span class="na">parse=</span><span class="s">&quot;text&quot;</span> <span class="nt">/&gt;</span>.
<span class="nt">&lt;/document&gt;</span>
</pre></div>
</div>
<p>결과는 다음과 같습니다:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;document</span> <span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span><span class="nt">&gt;</span>
  Copyright (c) 2003.
<span class="nt">&lt;/document&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id4">
<h2>레퍼런스<a class="headerlink" href="#id4" title="제목 주소">¶</a></h2>
<div class="section" id="elementinclude-functions">
<span id="id5"></span><h3>함수<a class="headerlink" href="#elementinclude-functions" title="제목 주소">¶</a></h3>
<dl class="function">
<dt id="xml.etree.ElementTree.xml.etree.ElementInclude.default_loader">
<code class="sig-prename descclassname">xml.etree.ElementInclude.</code><code class="sig-name descname">default_loader</code><span class="sig-paren">(</span><em class="sig-param">href</em>, <em class="sig-param">parse</em>, <em class="sig-param">encoding=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.xml.etree.ElementInclude.default_loader" title="정의 주소">¶</a></dt>
<dd><p>기본 로더. 이 기본 로더는 디스크에서 포함되는 리소스를 읽습니다. <em>href</em>는 URL입니다. <em>parse</em>는 구문 분석 모드로 &quot;xml&quot; 이나 &quot;text&quot;입니다. <em>encoding</em>은 선택적 텍스트 인코딩입니다. 지정하지 않으면, 인코딩은 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code>입니다. 확장된 리소스를 반환합니다. 구문 분석 모드가 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>이면, ElementTree 인스턴스입니다. 구문 분석 모드가 &quot;text&quot;이면, 유니코드 문자열입니다. 로더가 실패하면, None을 반환하거나 예외를 발생시킬 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="xml.etree.ElementTree.xml.etree.ElementInclude.include">
<code class="sig-prename descclassname">xml.etree.ElementInclude.</code><code class="sig-name descname">include</code><span class="sig-paren">(</span><em class="sig-param">elem</em>, <em class="sig-param">loader=None</em>, <em class="sig-param">base_url=None</em>, <em class="sig-param">max_depth=6</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.xml.etree.ElementInclude.include" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 XInclude 지시어를 확장합니다. <em>elem</em>은 루트 엘리먼트입니다. <em>loader</em>는 선택적 리소스 로더입니다. 생략하면, 기본값은 <a class="reference internal" href="#xml.etree.ElementTree.xml.etree.ElementInclude.default_loader" title="xml.etree.ElementTree.xml.etree.ElementInclude.default_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">default_loader()</span></code></a>입니다. 주어지면, <a class="reference internal" href="#xml.etree.ElementTree.xml.etree.ElementInclude.default_loader" title="xml.etree.ElementTree.xml.etree.ElementInclude.default_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">default_loader()</span></code></a>와 같은 인터페이스를 구현하는 콜러블 이어야 합니다. <em>base_url</em>은 상대적인 포함 파일 참조를 결정하기 위한 원본 파일의 베이스 URL입니다. <em>max_depth</em>는 최대 재귀 포함 수입니다. 악의적인 내용 폭발의 위험을 줄이도록 제한되었습니다. 제한을 비활성화하려면 음수 값을 전달하십시오.</p>
<p>확장된 리소스를 반환합니다. 구문 분석 모드가 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>이면 ElementTree 인스턴스입니다. 구문 분석 모드가 &quot;text&quot;이면 유니코드 문자열입니다. 로더가 실패하면 None을 반환하거나 예외를 발생시킬 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가: </span><em>base_url</em>과 <em>max_depth</em> 매개 변수.</p>
</div>
</dd></dl>

</div>
<div class="section" id="element-objects">
<span id="elementtree-element-objects"></span><h3>Element 객체<a class="headerlink" href="#element-objects" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="xml.etree.ElementTree.Element">
<em class="property">class </em><code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">Element</code><span class="sig-paren">(</span><em class="sig-param">tag</em>, <em class="sig-param">attrib={}</em>, <em class="sig-param">**extra</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element" title="정의 주소">¶</a></dt>
<dd><p>Element 클래스. 이 클래스는 Element 인터페이스를 정의하고, 이 인터페이스의 참조 구현을 제공합니다.</p>
<p>엘리먼트 이름, 어트리뷰트 이름 및 어트리뷰트 값은 바이트 문자열이나 유니코드 문자열일 수 있습니다. <em>tag</em>는 엘리먼트 이름입니다. <em>attrib</em>는 엘리먼트 어트리뷰트를 포함하는 선택적 딕셔너리입니다. <em>extra</em>에는 키워드 인자로 지정된 추가 어트리뷰트가 포함되어 있습니다.</p>
<dl class="attribute">
<dt id="xml.etree.ElementTree.Element.tag">
<code class="sig-name descname">tag</code><a class="headerlink" href="#xml.etree.ElementTree.Element.tag" title="정의 주소">¶</a></dt>
<dd><p>이 엘리먼트가 나타내는 데이터 종류(즉, 엘리먼트 유형)를 식별하는 문자열.</p>
</dd></dl>

<dl class="attribute">
<dt id="xml.etree.ElementTree.Element.text">
<code class="sig-name descname">text</code><a class="headerlink" href="#xml.etree.ElementTree.Element.text" title="정의 주소">¶</a></dt>
<dt id="xml.etree.ElementTree.Element.tail">
<code class="sig-name descname">tail</code><a class="headerlink" href="#xml.etree.ElementTree.Element.tail" title="정의 주소">¶</a></dt>
<dd><p>이 어트리뷰트는 엘리먼트와 연관된 추가 데이터를 담는 데 사용될 수 있습니다. 해당 값은 일반적으로 문자열이지만 임의의 응용 프로그램별 객체일 수 있습니다. 엘리먼트가 XML 파일에서 만들어지면, <em>text</em> 어트리뷰트는 엘리먼트의 시작 태그와 첫 번째 자식이나 종료 태그 사이의 텍스트를 담거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>이고, <em>tail</em> 어트리뷰트는 엘리먼트의 종료 태그와 다음 태그 사이의 텍스트를 담거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. 다음과 같은 XML 데이터의 경우</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;a&gt;&lt;b&gt;</span>1<span class="nt">&lt;c&gt;</span>2<span class="nt">&lt;d/&gt;</span>3<span class="nt">&lt;/c&gt;&lt;/b&gt;</span>4<span class="nt">&lt;/a&gt;</span>
</pre></div>
</div>
<p><em>a</em> 엘리먼트는 <em>text</em>와 <em>tail</em> 어트리뷰트 모두에 대해 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 갖고, <em>b</em> 엘리먼트는 <em>text</em> <code class="docutils literal notranslate"><span class="pre">&quot;1&quot;</span></code>과 <em>tail</em> <code class="docutils literal notranslate"><span class="pre">&quot;4&quot;</span></code>를 갖고, <em>c</em> 엘리먼트는 <em>text</em> <code class="docutils literal notranslate"><span class="pre">&quot;2&quot;</span></code>와 <em>tail</em> <code class="docutils literal notranslate"><span class="pre">None</span></code>을 갖고, <em>d</em> 엘리먼트는 <em>text</em> <code class="docutils literal notranslate"><span class="pre">None</span></code>과 <em>tail</em> <code class="docutils literal notranslate"><span class="pre">&quot;3&quot;</span></code>을 갖습니다.</p>
<p>엘리먼트의 내부 텍스트를 수집하려면, <a class="reference internal" href="#xml.etree.ElementTree.Element.itertext" title="xml.etree.ElementTree.Element.itertext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itertext()</span></code></a>를 참조하십시오, 예를 들어 <code class="docutils literal notranslate"><span class="pre">&quot;&quot;.join(element.itertext())</span></code>.</p>
<p>응용 프로그램은 이 어트리뷰트들에 임의의 객체를 저장할 수 있습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="xml.etree.ElementTree.Element.attrib">
<code class="sig-name descname">attrib</code><a class="headerlink" href="#xml.etree.ElementTree.Element.attrib" title="정의 주소">¶</a></dt>
<dd><p>엘리먼트의 어트리뷰트를 포함하는 딕셔너리. <em>attrib</em> 값은 항상 진짜 가변 파이썬 딕셔너리이지만, ElementTree 구현은 다른 내부 표현을 사용하도록 선택하고, 누군가가 요청할 때만 딕셔너리를 만들 수 있습니다. 이러한 구현의 이점을 활용하려면, 가능한 한 아래의 딕셔너리 메서드를 사용하십시오.</p>
</dd></dl>

<p>다음과 같은 딕셔너리와 유사한 메서드가 엘리먼트 어트리뷰트에서 작동합니다.</p>
<dl class="method">
<dt id="xml.etree.ElementTree.Element.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.clear" title="정의 주소">¶</a></dt>
<dd><p>엘리먼트를 재설정합니다. 이 함수는 모든 서브 엘리먼트를 제거하고, 모든 어트리뷰트를 지우고, text 및 tail 어트리뷰트를 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.Element.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.get" title="정의 주소">¶</a></dt>
<dd><p><em>key</em>라는 이름의 엘리먼트 어트리뷰트를 가져옵니다.</p>
<p>어트리뷰트 값을 반환하거나, 어트리뷰트를 찾을 수 없으면 <em>default</em>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.Element.items">
<code class="sig-name descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.items" title="정의 주소">¶</a></dt>
<dd><p>엘리먼트 어트리뷰트를 (이름, 값) 쌍의 시퀀스로 반환합니다. 어트리뷰트는 임의의 순서로 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.Element.keys">
<code class="sig-name descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.keys" title="정의 주소">¶</a></dt>
<dd><p>엘리먼트 어트리뷰트 이름을 리스트로 반환합니다. 이름은 임의의 순서로 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.Element.set">
<code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.set" title="정의 주소">¶</a></dt>
<dd><p>엘리먼트의 <em>key</em> 어트리뷰트를 <em>value</em>로 설정합니다.</p>
</dd></dl>

<p>다음 메서드는 엘리먼트의 자식(서브 엘리먼트)에서 작동합니다.</p>
<dl class="method">
<dt id="xml.etree.ElementTree.Element.append">
<code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param">subelement</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.append" title="정의 주소">¶</a></dt>
<dd><p>이 엘리먼트의 내부 서브 엘리먼트 리스트 끝에 엘리먼트 <em>subelement</em>를 추가합니다. <em>subelement</em>가 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>가 아니면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.Element.extend">
<code class="sig-name descname">extend</code><span class="sig-paren">(</span><em class="sig-param">subelements</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.extend" title="정의 주소">¶</a></dt>
<dd><p>0개 이상의 엘리먼트가 있는 시퀀스 객체로 제공되는 <em>subelements</em>를 추가합니다. 서브 엘리먼트가 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>가 아니면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.Element.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">match</em>, <em class="sig-param">namespaces=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.find" title="정의 주소">¶</a></dt>
<dd><p><em>match</em>와 일치하는 첫 번째 서브 엘리먼트를 찾습니다. <em>match</em>는 태그 이름이나 <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">경로</span></a>일 수 있습니다. 엘리먼트 인스턴스나 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. <em>namespaces</em>는 이름 공간 접두사에서 전체 이름으로의 선택적 매핑입니다. 표현식에서 접두사가 없는 모든 태그 이름을 지정된 이름 공간으로 이동하려면 <code class="docutils literal notranslate"><span class="pre">''</span></code>를 접두사로 전달하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.Element.findall">
<code class="sig-name descname">findall</code><span class="sig-paren">(</span><em class="sig-param">match</em>, <em class="sig-param">namespaces=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.findall" title="정의 주소">¶</a></dt>
<dd><p>태그 이름이나 <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">경로</span></a>로 일치하는 모든 서브 엘리먼트를 찾습니다. 일치하는 모든 엘리먼트가 문서 순서로 포함된 리스트를 반환합니다. <em>namespaces</em>는 이름 공간 접두사에서 전체 이름으로의 선택적 매핑입니다. 표현식에서 접두사가 없는 모든 태그 이름을 지정된 이름 공간으로 이동하려면 <code class="docutils literal notranslate"><span class="pre">''</span></code>를 접두사로 전달하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.Element.findtext">
<code class="sig-name descname">findtext</code><span class="sig-paren">(</span><em class="sig-param">match</em>, <em class="sig-param">default=None</em>, <em class="sig-param">namespaces=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.findtext" title="정의 주소">¶</a></dt>
<dd><p><em>match</em>와 일치하는 첫 번째 서브 엘리먼트의 텍스트를 찾습니다. <em>match</em>는 태그 이름이나 <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">경로</span></a>일 수 있습니다. 일치하는 첫 번째 엘리먼트의 텍스트 내용을 반환하거나, 엘리먼트가 없으면 <em>default</em>를 반환합니다. 일치하는 엘리먼트에 텍스트 내용이 없으면 빈 문자열이 반환됨에 유의하십시오. <em>namespaces</em>는 이름 공간 접두사에서 전체 이름으로의 선택적 매핑입니다. 표현식에서 접두사가 없는 모든 태그 이름을 지정된 이름 공간으로 이동하려면 <code class="docutils literal notranslate"><span class="pre">''</span></code>를 접두사로 전달하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.Element.insert">
<code class="sig-name descname">insert</code><span class="sig-paren">(</span><em class="sig-param">index</em>, <em class="sig-param">subelement</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.insert" title="정의 주소">¶</a></dt>
<dd><p>이 엘리먼트의 지정된 위치에 <em>subelement</em>를 삽입합니다. <em>subelement</em>가 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>가 아니면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.Element.iter">
<code class="sig-name descname">iter</code><span class="sig-paren">(</span><em class="sig-param">tag=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.iter" title="정의 주소">¶</a></dt>
<dd><p>현재 엘리먼트를 루트로 하여 트리 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a>를 만듭니다. 이터레이터는 이 엘리먼트와 그 아래의 모든 엘리먼트를 문서 순서로 (깊이 우선) 이터레이트 합니다. <em>tag</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이나 <code class="docutils literal notranslate"><span class="pre">'*'</span></code>가 아니면, 태그가 <em>tag</em>와 같은 엘리먼트만 이터레이터에서 반환됩니다. 이터레이션 중에 트리 구조가 수정되면, 결과는 정의되지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.Element.iterfind">
<code class="sig-name descname">iterfind</code><span class="sig-paren">(</span><em class="sig-param">match</em>, <em class="sig-param">namespaces=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.iterfind" title="정의 주소">¶</a></dt>
<dd><p>태그 이름이나 <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">경로</span></a>로 일치하는 모든 서브 엘리먼트를 찾습니다. 일치하는 모든 엘리먼트를 문서 순서로 산출하는 이터러블을 반환합니다. <em>namespaces</em>는 이름 공간 접두사에서 전체 이름으로의 선택적 매핑입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.Element.itertext">
<code class="sig-name descname">itertext</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.itertext" title="정의 주소">¶</a></dt>
<dd><p>텍스트 이터레이터를 만듭니다. 이터레이터는 이 엘리먼트와 모든 서브 엘리먼트를 문서 순서대로 루핑하고, 모든 내부 텍스트를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.Element.makeelement">
<code class="sig-name descname">makeelement</code><span class="sig-paren">(</span><em class="sig-param">tag</em>, <em class="sig-param">attrib</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.makeelement" title="정의 주소">¶</a></dt>
<dd><p>이 엘리먼트와 같은 유형의 새 엘리먼트 객체를 만듭니다. 이 메서드를 호출하지 말고, 대신 <a class="reference internal" href="#xml.etree.ElementTree.SubElement" title="xml.etree.ElementTree.SubElement"><code class="xref py py-func docutils literal notranslate"><span class="pre">SubElement()</span></code></a> 팩토리 함수를 사용하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.Element.remove">
<code class="sig-name descname">remove</code><span class="sig-paren">(</span><em class="sig-param">subelement</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.remove" title="정의 주소">¶</a></dt>
<dd><p>엘리먼트에서 <em>subelement</em>를 제거합니다. find* 메서드와 달리 이 메서드는 태그값이나 내용이 아닌 인스턴스 아이덴티티를 기준으로 엘리먼트를 비교합니다.</p>
</dd></dl>

<p><a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 객체는 서브 엘리먼트 작업을 위한 <a class="reference internal" href="../reference/datamodel.html#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 시퀀스 형 메서드도 지원합니다.</p>
<p>주의: 서브 엘리먼트가 없는 엘리먼트는 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 테스트 됩니다. 이 동작은 이후 버전에서 변경될 것입니다. 대신 구체적으로 <code class="docutils literal notranslate"><span class="pre">len(elem)</span></code>이나 <code class="docutils literal notranslate"><span class="pre">elem</span> <span class="pre">is</span> <span class="pre">None</span></code> 테스트를 사용하십시오.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">element</span><span class="p">:</span>  <span class="c1"># 주의!</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;element not found, or element has no subelements&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">element</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;element not found&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>파이썬 3.8 이전에는, 어트리뷰트를 이름으로 정렬하여 엘리먼트의 XML 어트리뷰트의 직렬화 순서를 인위적으로 예측할 수 있도록 했습니다. 이제 보장되는 딕셔너리 순서를 기반으로, 이 임의 재정렬은 파이썬 3.8에서 제거되어 어트리뷰트가 원래 구문 분석되거나 사용자 코드에 의해 만들어진 순서를 유지합니다.</p>
<p>일반적으로, 사용자 코드는 <a class="reference external" href="https://www.w3.org/TR/xml-infoset/">XML Information Set</a>이 정보 전달에서 어트리뷰트 순서를 명시적으로 제외한다는 점에서 구체적인 어트리뷰트 순서에 의존하지 않아야 합니다. 입력의 모든 순서를 다룰 수 있도록 코드를 준비해야 합니다. 예를 들어 암호화 서명이나 테스트 데이터 집합과 같이 결정론적 XML 출력이 필요한 경우, <a class="reference internal" href="#xml.etree.ElementTree.canonicalize" title="xml.etree.ElementTree.canonicalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">canonicalize()</span></code></a> 함수로 규범적 직렬화를 사용할 수 있습니다.</p>
<p>규범적 출력이 적용되지는 않지만, 출력에서 특정 어트리뷰트 순서가 여전히 필요하면, 코드는 코드를 읽는 사람의 지각 불일치를 피하고자, 원하는 순서로 어트리뷰트를 직접 만드는 것을 목표로 해야 합니다. 이를 달성하기 어려운 경우, Element 생성과 독립적으로 순서를 강제하기 위해 직렬화 전에 다음과 같은 조리법을 적용 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reorder_attributes</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">():</span>
        <span class="n">attrib</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">attrib</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrib</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># 어트리뷰트 순서를 조정합니다, 예를 들어 정렬로</span>
            <span class="n">attribs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">attrib</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="n">attrib</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">attrib</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attribs</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="elementtree-objects">
<span id="elementtree-elementtree-objects"></span><h3>ElementTree 객체<a class="headerlink" href="#elementtree-objects" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="xml.etree.ElementTree.ElementTree">
<em class="property">class </em><code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">ElementTree</code><span class="sig-paren">(</span><em class="sig-param">element=None</em>, <em class="sig-param">file=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree" title="정의 주소">¶</a></dt>
<dd><p>ElementTree 래퍼 클래스. 이 클래스는 전체 엘리먼트 위계를 나타내며, 표준 XML과의 직렬화에 대한 추가 지원을 추가합니다.</p>
<p><em>element</em>는 루트 엘리먼트입니다. 주어지면 XML <em>file</em>의 내용으로 트리가 초기화됩니다.</p>
<dl class="method">
<dt id="xml.etree.ElementTree.ElementTree._setroot">
<code class="sig-name descname">_setroot</code><span class="sig-paren">(</span><em class="sig-param">element</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree._setroot" title="정의 주소">¶</a></dt>
<dd><p>이 트리의 루트 엘리먼트를 교체합니다. 이것은 트리의 현재 내용을 버리고, 주어진 엘리먼트로 대체합니다. 주의해서 사용하십시오. <em>element</em>는 엘리먼트 인스턴스입니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.ElementTree.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">match</em>, <em class="sig-param">namespaces=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.find" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#xml.etree.ElementTree.Element.find" title="xml.etree.ElementTree.Element.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.find()</span></code></a>와 같습니다, 트리의 루트에서 시작합니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.ElementTree.findall">
<code class="sig-name descname">findall</code><span class="sig-paren">(</span><em class="sig-param">match</em>, <em class="sig-param">namespaces=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.findall" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#xml.etree.ElementTree.Element.findall" title="xml.etree.ElementTree.Element.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.findall()</span></code></a>과 같습니다, 트리의 루트에서 시작합니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.ElementTree.findtext">
<code class="sig-name descname">findtext</code><span class="sig-paren">(</span><em class="sig-param">match</em>, <em class="sig-param">default=None</em>, <em class="sig-param">namespaces=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.findtext" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#xml.etree.ElementTree.Element.findtext" title="xml.etree.ElementTree.Element.findtext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.findtext()</span></code></a>와 같습니다, 트리의 루트에서 시작합니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.ElementTree.getroot">
<code class="sig-name descname">getroot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.getroot" title="정의 주소">¶</a></dt>
<dd><p>이 트리의 루트 엘리먼트를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.ElementTree.iter">
<code class="sig-name descname">iter</code><span class="sig-paren">(</span><em class="sig-param">tag=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.iter" title="정의 주소">¶</a></dt>
<dd><p>루트 엘리먼트에 대한 트리 이터레이터를 만들고 반환합니다. 이터레이터는 이 트리의 모든 엘리먼트를 섹션 순서대로 루핑합니다. <em>tag</em>는 찾을 태그입니다 (기본값은 모든 엘리먼트를 반환하는 것입니다).</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.ElementTree.iterfind">
<code class="sig-name descname">iterfind</code><span class="sig-paren">(</span><em class="sig-param">match</em>, <em class="sig-param">namespaces=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.iterfind" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#xml.etree.ElementTree.Element.iterfind" title="xml.etree.ElementTree.Element.iterfind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.iterfind()</span></code></a>와 같습니다, 트리의 루트에서 시작합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.ElementTree.parse">
<code class="sig-name descname">parse</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">parser=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.parse" title="정의 주소">¶</a></dt>
<dd><p>이 엘리먼트 트리에 외부 XML 섹션을 로드합니다. <em>source</em>는 파일 이름이나 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a>입니다. <em>parser</em>는 선택적 구문 분석기 인스턴스입니다. 지정하지 않으면 표준 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 구문 분석기가 사용됩니다. 섹션 루트 엘리먼트를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.ElementTree.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">file</em>, <em class="sig-param">encoding=&quot;us-ascii&quot;</em>, <em class="sig-param">xml_declaration=None</em>, <em class="sig-param">default_namespace=None</em>, <em class="sig-param">method=&quot;xml&quot;</em>, <em class="sig-param">*</em>, <em class="sig-param">short_empty_elements=True</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.write" title="정의 주소">¶</a></dt>
<dd><p>엘리먼트 트리를 XML로 파일에 씁니다. <em>file</em>은 파일 이름이거나 쓰기 위해 열린 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a>입니다. <em>encoding</em> <a class="footnote-reference brackets" href="#id9" id="id6">1</a> 은 출력 인코딩입니다 (기본값은 US-ASCII입니다). <em>xml_declaration</em>은 파일에 XML 선언을 추가해야 하는지를 제어합니다. 추가하지 말아야 하면 <code class="docutils literal notranslate"><span class="pre">False</span></code>, 항상 추가하면 <code class="docutils literal notranslate"><span class="pre">True</span></code>, US-ASCII나 UTF-8이나 유니코드가 아닐 때만 추가하면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 사용하십시오 (기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다). <em>default_namespace</em>는 기본 XML 이름 공간을 설정합니다 (&quot;xmlns&quot;). <em>method</em>는 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;html&quot;</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">&quot;text&quot;</span></code>입니다 (기본값은 <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>입니다). 키워드 전용 <em>short_empty_elements</em> 매개 변수는 내용이 없는 엘리먼트의 포매팅을 제어합니다. <code class="docutils literal notranslate"><span class="pre">True</span></code>(기본값)이면, 단일 스스로 닫힌 태그로 방출되고, 그렇지 않으면 한 쌍의 시작/종료 태그로 방출됩니다.</p>
<p>출력은 문자열(<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>)이나 바이너리(<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>)입니다. 이것은 <em>encoding</em> 인자에 의해 제어됩니다. <em>encoding</em>이 <code class="docutils literal notranslate"><span class="pre">&quot;unicode&quot;</span></code>이면, 출력은 문자열입니다; 그렇지 않으면 바이너리입니다. <em>file</em>이 열린 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a>이면 <em>file</em>의 유형과 충돌할 수 있음에 유의하십시오; 문자열을 바이너리 스트림에 쓰거나 그 반대로 하지 않도록 하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가: </span><em>short_empty_elements</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><a class="reference internal" href="#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> 메서드는 이제 사용자가 지정한 어트리뷰트 순서를 유지합니다.</p>
</div>
</dd></dl>

</dd></dl>

<p>이것은 조작될 XML 파일입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">head</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span><span class="n">Example</span> <span class="n">page</span><span class="o">&lt;/</span><span class="n">title</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">head</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">Moved</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.org/&quot;</span><span class="o">&gt;</span><span class="n">example</span><span class="o">.</span><span class="n">org</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
        <span class="ow">or</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.com/&quot;</span><span class="o">&gt;</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;.&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">body</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">html</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>첫 번째 문단에 있는 모든 링크의 어트리뷰트 &quot;target&quot;을 변경하는 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">import</span> <span class="n">ElementTree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">ElementTree</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;index.xhtml&quot;</span><span class="p">)</span>
<span class="go">&lt;Element &#39;html&#39; at 0xb77e6fac&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;body/p&quot;</span><span class="p">)</span>     <span class="c1"># body에서 처음 등장하는 태그 p를 찾습니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">&lt;Element &#39;p&#39; at 0xb77ec26c&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">links</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">))</span>   <span class="c1"># 모든 링크의 리스트를 반환합니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">links</span>
<span class="go">[&lt;Element &#39;a&#39; at 0xb77ec2ac&gt;, &lt;Element &#39;a&#39; at 0xb77ec1cc&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>             <span class="c1"># 발견된 모든 링크를 이터레이트 합니다</span>
<span class="gp">... </span>    <span class="n">i</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;blank&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;output.xhtml&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="qname-objects">
<span id="elementtree-qname-objects"></span><h3>QName 객체<a class="headerlink" href="#qname-objects" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="xml.etree.ElementTree.QName">
<em class="property">class </em><code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">QName</code><span class="sig-paren">(</span><em class="sig-param">text_or_uri</em>, <em class="sig-param">tag=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.QName" title="정의 주소">¶</a></dt>
<dd><p>QName 래퍼. 출력에서 이름 공간을 올바르게 처리하기 위해, QName 어트리뷰트 값을 래핑하는 데 사용할 수 있습니다. <em>text_or_uri</em>는 {uri}local 형식으로 QName 값을 포함하는 문자열이거나, tag 인자가 제공되면 QName의 URI 부분입니다. <em>tag</em>가 제공되면, 첫 번째 인자는 URI로 해석되고, 이 인자는 로컬 이름으로 해석됩니다. <a class="reference internal" href="#xml.etree.ElementTree.QName" title="xml.etree.ElementTree.QName"><code class="xref py py-class docutils literal notranslate"><span class="pre">QName</span></code></a> 인스턴스는 불투명합니다.</p>
</dd></dl>

</div>
<div class="section" id="treebuilder-objects">
<span id="elementtree-treebuilder-objects"></span><h3>TreeBuilder 객체<a class="headerlink" href="#treebuilder-objects" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="xml.etree.ElementTree.TreeBuilder">
<em class="property">class </em><code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">TreeBuilder</code><span class="sig-paren">(</span><em class="sig-param">element_factory=None</em>, <em class="sig-param">*</em>, <em class="sig-param">comment_factory=None</em>, <em class="sig-param">pi_factory=None</em>, <em class="sig-param">insert_comments=False</em>, <em class="sig-param">insert_pis=False</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder" title="정의 주소">¶</a></dt>
<dd><p>일반 엘리먼트 구조 빌더. 이 빌더는 일련의 start, data, end, comment 및 pi 메서드 호출을 올바른 형식의 엘리먼트 구조로 변환합니다. 이 클래스를 사용하여 사용자 정의 XML 구문 분석기를 사용하거나 다른 XML 형식의 구문 분석기를 사용하는 엘리먼트 구조를 구축할 수 있습니다.</p>
<p>주어지면 <em>element_factory</em>는 두 개의 위치 인자를 받아들이는 콜러블 이어야 합니다: 태그와 어트리뷰트 딕셔너리. 새로운 엘리먼트 인스턴스를 반환할 것으로 기대합니다.</p>
<p>주어지면, <em>comment_factory</em>와 <em>pi_factory</em> 함수는 주석과 처리 명령을 만들기 위해 <a class="reference internal" href="#xml.etree.ElementTree.Comment" title="xml.etree.ElementTree.Comment"><code class="xref py py-func docutils literal notranslate"><span class="pre">Comment()</span></code></a>와 <a class="reference internal" href="#xml.etree.ElementTree.ProcessingInstruction" title="xml.etree.ElementTree.ProcessingInstruction"><code class="xref py py-func docutils literal notranslate"><span class="pre">ProcessingInstruction()</span></code></a> 함수처럼 동작해야 합니다. 지정하지 않으면, 기본 팩토리가 사용됩니다. <em>insert_comments</em> 및/또는 <em>insert_pis</em>가 참이면, 주석/처리 명령이 루트 엘리먼트 내에 있으면 (하지만 외부에 있지 않으면) 트리에 삽입됩니다.</p>
<dl class="method">
<dt id="xml.etree.ElementTree.TreeBuilder.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.close" title="정의 주소">¶</a></dt>
<dd><p>빌더 버퍼를 플러시하고, 최상위 문서 엘리먼트를 반환합니다. <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 인스턴스를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.TreeBuilder.data">
<code class="sig-name descname">data</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.data" title="정의 주소">¶</a></dt>
<dd><p>현재 엘리먼트에 텍스트를 추가합니다. <em>data</em>는 문자열입니다. 바이트 문자열이거나 유니코드 문자열이어야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.TreeBuilder.end">
<code class="sig-name descname">end</code><span class="sig-paren">(</span><em class="sig-param">tag</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.end" title="정의 주소">¶</a></dt>
<dd><p>현재 엘리먼트를 닫습니다. <em>tag</em>는 엘리먼트 이름입니다. 닫힌 엘리먼트를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.TreeBuilder.start">
<code class="sig-name descname">start</code><span class="sig-paren">(</span><em class="sig-param">tag</em>, <em class="sig-param">attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.start" title="정의 주소">¶</a></dt>
<dd><p>새로운 엘리먼트를 엽니다. <em>tag</em>는 엘리먼트 이름입니다. <em>attrs</em>는 엘리먼트 어트리뷰트를 포함하는 딕셔너리입니다. 열린 엘리먼트를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.TreeBuilder.comment">
<code class="sig-name descname">comment</code><span class="sig-paren">(</span><em class="sig-param">text</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.comment" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>text</em>로 주석을 만듭니다. <code class="docutils literal notranslate"><span class="pre">insert_comments</span></code>가 참이면, 트리에 추가합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.TreeBuilder.pi">
<code class="sig-name descname">pi</code><span class="sig-paren">(</span><em class="sig-param">target</em>, <em class="sig-param">text</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.pi" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>target</em> 이름과 <em>text</em>로 처리 명령을 만듭니다. <code class="docutils literal notranslate"><span class="pre">insert_pis</span></code>가 참이면, 트리에 추가합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<p>또한, 사용자 정의 <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a> 객체는 다음 메서드를 제공할 수 있습니다:</p>
<dl class="method">
<dt id="xml.etree.ElementTree.TreeBuilder.doctype">
<code class="sig-name descname">doctype</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">pubid</em>, <em class="sig-param">system</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.doctype" title="정의 주소">¶</a></dt>
<dd><p>doctype 선언을 처리합니다. <em>name</em>은 doctype 이름입니다. <em>pubid</em>는 공개 식별자입니다. <em>system</em>은 시스템 식별자입니다. 이 메서드는 기본 <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a> 클래스에 없습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.TreeBuilder.start_ns">
<code class="sig-name descname">start_ns</code><span class="sig-paren">(</span><em class="sig-param">prefix</em>, <em class="sig-param">uri</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.start_ns" title="정의 주소">¶</a></dt>
<dd><p>구문 분석기가 새 이름 공간 선언을 발견할 때마다 이를 정의하는 여는 엘리먼트에 대한 <code class="docutils literal notranslate"><span class="pre">start()</span></code> 콜백 전에 호출됩니다. <em>prefix</em>는 기본 이름 공간의 경우 <code class="docutils literal notranslate"><span class="pre">''</span></code>이고, 그렇지 않으면 선언된 이름 공간 접두사 이름입니다. <em>uri</em>는 이름 공간 URI입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.TreeBuilder.end_ns">
<code class="sig-name descname">end_ns</code><span class="sig-paren">(</span><em class="sig-param">prefix</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.end_ns" title="정의 주소">¶</a></dt>
<dd><p>이름 공간 접두사 매핑을 선언한 엘리먼트의 <code class="docutils literal notranslate"><span class="pre">end()</span></code> 콜백 후에, 스코프를 벗어난 <em>prefix</em>의 이름으로 호출됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="xml.etree.ElementTree.C14NWriterTarget">
<em class="property">class </em><code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">C14NWriterTarget</code><span class="sig-paren">(</span><em class="sig-param">write</em>, <em class="sig-param">*</em>, <em class="sig-param">with_comments=False</em>, <em class="sig-param">strip_text=False</em>, <em class="sig-param">rewrite_prefixes=False</em>, <em class="sig-param">qname_aware_tags=None</em>, <em class="sig-param">qname_aware_attrs=None</em>, <em class="sig-param">exclude_attrs=None</em>, <em class="sig-param">exclude_tags=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.C14NWriterTarget" title="정의 주소">¶</a></dt>
<dd><p><a class="reference external" href="https://www.w3.org/TR/xml-c14n2/">C14N 2.0</a> 기록기. 인자는 <a class="reference internal" href="#xml.etree.ElementTree.canonicalize" title="xml.etree.ElementTree.canonicalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">canonicalize()</span></code></a> 함수와 같습니다. 이 클래스는 트리를 구축하지 않지만, <em>write</em> 함수를 사용하여 콜백 이벤트를 직렬화된 형식으로 직접 변환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="xmlparser-objects">
<span id="elementtree-xmlparser-objects"></span><h3>XMLParser 객체<a class="headerlink" href="#xmlparser-objects" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="xml.etree.ElementTree.XMLParser">
<em class="property">class </em><code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">XMLParser</code><span class="sig-paren">(</span><em class="sig-param">*</em>, <em class="sig-param">target=None</em>, <em class="sig-param">encoding=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLParser" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 모듈의 저수준 빌딩 블록입니다. 효율적인 이벤트 기반 XML 구문 분석을 위해 <a class="reference internal" href="pyexpat.html#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.parsers.expat</span></code></a>을 사용합니다. <a class="reference internal" href="#xml.etree.ElementTree.XMLParser.feed" title="xml.etree.ElementTree.XMLParser.feed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">feed()</span></code></a> 메서드를 사용하여 XML 데이터를 점진적으로 공급할 수 있으며, 구문 분석 이벤트는 <em>target</em> 객체에서 콜백을 호출하여 푸시 API로 변환됩니다. <em>target</em>을 생략하면, 표준 <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a>가 사용됩니다. <em>encoding</em> <a class="footnote-reference brackets" href="#id9" id="id8">1</a> 이 제공되면, 값이 XML 파일에 지정된 인코딩을 대체합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>매개 변수는 이제 <a class="reference internal" href="../glossary.html#keyword-only-parameter"><span class="std std-ref">키워드-전용</span></a>입니다. <em>html</em> 인자는 더는 지원되지 않습니다.</p>
</div>
<dl class="method">
<dt id="xml.etree.ElementTree.XMLParser.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLParser.close" title="정의 주소">¶</a></dt>
<dd><p>구문 분석기로의 데이터 공급을 완료합니다. 생성 중에 전달된 <em>target</em>의 <code class="docutils literal notranslate"><span class="pre">close()</span></code> 메서드를 호출한 결과를 반환합니다; 기본적으로, 최상위 문서 엘리먼트입니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.XMLParser.feed">
<code class="sig-name descname">feed</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLParser.feed" title="정의 주소">¶</a></dt>
<dd><p>구문 분석기에 데이터를 공급합니다. <em>data</em>는 인코딩된 데이터입니다.</p>
</dd></dl>

<p><a class="reference internal" href="#xml.etree.ElementTree.XMLParser.feed" title="xml.etree.ElementTree.XMLParser.feed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLParser.feed()</span></code></a>는 각 여는 태그마다 <em>target</em>의 <code class="docutils literal notranslate"><span class="pre">start(tag,</span> <span class="pre">attrs_dict)</span></code> 메서드를 호출하고, 닫는 태그마다 <code class="docutils literal notranslate"><span class="pre">end(tag)</span></code> 메서드를 호출하며, 데이터는 메서드 <code class="docutils literal notranslate"><span class="pre">data(data)</span></code>로 처리됩니다. 추가로 지원되는 콜백 메서드는, <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a> 클래스를 참조하십시오. <a class="reference internal" href="#xml.etree.ElementTree.XMLParser.close" title="xml.etree.ElementTree.XMLParser.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLParser.close()</span></code></a>는 <em>target</em>의 메서드 <code class="docutils literal notranslate"><span class="pre">close()</span></code>를 호출합니다. <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>는 트리 구조 구축에만 사용할 수 있는 것은 아닙니다. 다음은 XML 파일의 최대 깊이를 계산하는 예입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">import</span> <span class="n">XMLParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MaxDepth</span><span class="p">:</span>                     <span class="c1"># 구문 분석기의 대상 객체</span>
<span class="gp">... </span>    <span class="n">maxDepth</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">attrib</span><span class="p">):</span>   <span class="c1"># 여는 태그마다 호출됩니다.</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxDepth</span><span class="p">:</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">maxDepth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>             <span class="c1"># 닫는 태그마다 호출됩니다.</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>            <span class="c1"># 우리는 데이터로 아무것도 할 필요가 없습니다.</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>    <span class="c1"># 모든 데이터가 구문 분석되었을 때 호출됩니다.</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxDepth</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="n">MaxDepth</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">XMLParser</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exampleXml</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="gp">... </span><span class="s2">&lt;a&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;b&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;/b&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;b&gt;</span>
<span class="gp">... </span><span class="s2">    &lt;c&gt;</span>
<span class="gp">... </span><span class="s2">      &lt;d&gt;</span>
<span class="gp">... </span><span class="s2">      &lt;/d&gt;</span>
<span class="gp">... </span><span class="s2">    &lt;/c&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;/b&gt;</span>
<span class="gp">... </span><span class="s2">&lt;/a&gt;&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="n">exampleXml</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="xmlpullparser-objects">
<span id="elementtree-xmlpullparser-objects"></span><h3>XMLPullParser 객체<a class="headerlink" href="#xmlpullparser-objects" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="xml.etree.ElementTree.XMLPullParser">
<em class="property">class </em><code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">XMLPullParser</code><span class="sig-paren">(</span><em class="sig-param">events=None</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLPullParser" title="정의 주소">¶</a></dt>
<dd><p>비 블로킹 응용 프로그램에 적합한 풀 구문 분석기. 입력 측 API는 <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>의 것과 유사하지만, 콜백 대상으로 호출을 푸시하는 대신, <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a>는 내부 구문 분석 이벤트 리스트를 수집하여 사용자가 여기서 읽을 수 있도록 합니다. <em>events</em>는 보고할 이벤트의 시퀀스입니다. 지원되는 이벤트는 문자열 <code class="docutils literal notranslate"><span class="pre">&quot;start&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;end&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;comment&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;pi&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;start-ns&quot;</span></code> 및 <code class="docutils literal notranslate"><span class="pre">&quot;end-ns&quot;</span></code>입니다 (&quot;ns&quot; 이벤트는 자세한 이름 공간 정보를 얻는 데 사용됩니다). <em>events</em>를 생략하면, <code class="docutils literal notranslate"><span class="pre">&quot;end&quot;</span></code> 이벤트만 보고됩니다.</p>
<dl class="method">
<dt id="xml.etree.ElementTree.XMLPullParser.feed">
<code class="sig-name descname">feed</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLPullParser.feed" title="정의 주소">¶</a></dt>
<dd><p>주어진 바이트열 데이터를 구문 분석기에 공급합니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.XMLPullParser.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLPullParser.close" title="정의 주소">¶</a></dt>
<dd><p>구문 분석기에 데이터 스트림이 종료되었음을 알립니다. <a class="reference internal" href="#xml.etree.ElementTree.XMLParser.close" title="xml.etree.ElementTree.XMLParser.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLParser.close()</span></code></a>와 달리, 이 메서드는 항상 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환합니다. 구문 분석기가 닫힐 때 아직 꺼내지 않은 이벤트는 <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="xml.etree.ElementTree.XMLPullParser.read_events"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_events()</span></code></a>로 계속 읽을 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="xml.etree.ElementTree.XMLPullParser.read_events">
<code class="sig-name descname">read_events</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="정의 주소">¶</a></dt>
<dd><p>구문 분석기에 공급된 데이터에서 발생한 이벤트에 대한 이터레이터를 반환합니다. 이터레이터는 <code class="docutils literal notranslate"><span class="pre">(event,</span> <span class="pre">elem)</span></code> 쌍을 산출합니다, 여기서 <em>event</em>는 이벤트 유형을 나타내는 문자열(예를 들어 <code class="docutils literal notranslate"><span class="pre">&quot;end&quot;</span></code>)이고 <em>elem</em>은 발견된 <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 객체나, 다음과 같은 기타 문맥 값입니다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>: 현재 엘리먼트.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">comment</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>: 현재 주석 / 처리 명령</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">start-ns</span></code>: 선언된 이름 공간 매핑을 명명하는 튜플 <code class="docutils literal notranslate"><span class="pre">(prefix,</span> <span class="pre">uri)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">end-ns</span></code>: <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> (향후 버전에서 변경될 수 있습니다)</p></li>
</ul>
<p><a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="xml.etree.ElementTree.XMLPullParser.read_events"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_events()</span></code></a>에 대한 이전 호출에서 제공된 이벤트는 다시 산출되지 않습니다. 이벤트는 이터레이터에서 꺼낼 때만 내부 큐에서 소비되므로, <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="xml.etree.ElementTree.XMLPullParser.read_events"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_events()</span></code></a>에서 얻은 이터레이터에 대해 병렬로 이터레이션 하는 여러 판독기는 예측할 수 없는 결과를 얻게 됩니다.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a> 는 &quot;start&quot; 이벤트를 방출할 때 시작 태그의 &quot;&gt;&quot; 문자를 보았다는 것만 보장해서, 어트리뷰트는 정의되지만, 텍스트의 내용과 테일(tail) 어트리뷰트는 그 시점에 정의되지 않습니다. 자식 엘리먼트에도 마찬가지로 적용됩니다; 그들은 존재할 수도 그렇지 않을 수도 있습니다.</p>
<p>완전히 채워진 엘리먼트가 필요하면, 대신 &quot;end&quot; 이벤트를 찾으십시오.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><code class="docutils literal notranslate"><span class="pre">comment</span></code>와 <code class="docutils literal notranslate"><span class="pre">pi</span></code> 이벤트가 추가되었습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="exceptions">
<h3>예외<a class="headerlink" href="#exceptions" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="xml.etree.ElementTree.ParseError">
<em class="property">class </em><code class="sig-prename descclassname">xml.etree.ElementTree.</code><code class="sig-name descname">ParseError</code><a class="headerlink" href="#xml.etree.ElementTree.ParseError" title="정의 주소">¶</a></dt>
<dd><p>XML 구문 분석 에러, 이 모듈의 다양한 구문 분석 메서드가 구문 분석이 실패할 때 발생시킵니다. 이 예외 인스턴스의 문자열 표현에는 사용자 친화적인 에러 메시지가 포함됩니다. 또한, 다음과 같은 어트리뷰트를 사용할 수 있습니다:</p>
<dl class="attribute">
<dt id="xml.etree.ElementTree.ParseError.code">
<code class="sig-name descname">code</code><a class="headerlink" href="#xml.etree.ElementTree.ParseError.code" title="정의 주소">¶</a></dt>
<dd><p>expat 구문 분석기의 숫자 에러 코드. 에러 코드와 의미의 목록은 <a class="reference internal" href="pyexpat.html#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.parsers.expat</span></code></a> 설명서를 참조하십시오.</p>
</dd></dl>

<dl class="attribute">
<dt id="xml.etree.ElementTree.ParseError.position">
<code class="sig-name descname">position</code><a class="headerlink" href="#xml.etree.ElementTree.ParseError.position" title="정의 주소">¶</a></dt>
<dd><p>에러가 발생한 위치를 지정하는, <em>line</em>, <em>column</em> 숫자의 튜플.</p>
</dd></dl>

</dd></dl>

<p class="rubric">각주</p>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>,<a href="#id6">3</a>,<a href="#id8">4</a>)</span></dt>
<dd><p>XML 출력에 포함된 인코딩 문자열은 적절한 표준을 준수해야 합니다. 예를 들어, &quot;UTF-8&quot;은 유효하지만, &quot;UTF8&quot;은 유효하지 않습니다. <a class="reference external" href="https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl">https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl</a> and <a class="reference external" href="https://www.iana.org/assignments/character-sets/character-sets.xhtml">https://www.iana.org/assignments/character-sets/character-sets.xhtml</a> 을 참조하십시오.</p>
</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code> --- ElementTree XML API</a><ul>
<li><a class="reference internal" href="#tutorial">자습서</a><ul>
<li><a class="reference internal" href="#xml-tree-and-elements">XML 트리와 엘리먼트</a></li>
<li><a class="reference internal" href="#parsing-xml">XML 구문 분석하기</a></li>
<li><a class="reference internal" href="#pull-api-for-non-blocking-parsing">비 블로킹 구문 분석을 위한 풀(pull) API</a></li>
<li><a class="reference internal" href="#finding-interesting-elements">흥미로운 엘리먼트 찾기</a></li>
<li><a class="reference internal" href="#modifying-an-xml-file">XML 파일 수정하기</a></li>
<li><a class="reference internal" href="#building-xml-documents">XML 문서 구축하기</a></li>
<li><a class="reference internal" href="#parsing-xml-with-namespaces">이름 공간이 있는 XML 구문 분석하기</a></li>
<li><a class="reference internal" href="#additional-resources">추가 자료</a></li>
</ul>
</li>
<li><a class="reference internal" href="#xpath-support">XPath 지원</a><ul>
<li><a class="reference internal" href="#example">예</a></li>
<li><a class="reference internal" href="#supported-xpath-syntax">지원되는 XPath 문법</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference">레퍼런스</a><ul>
<li><a class="reference internal" href="#functions">함수</a></li>
</ul>
</li>
<li><a class="reference internal" href="#xinclude-support">XInclude 지원</a><ul>
<li><a class="reference internal" href="#id3">예</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">레퍼런스</a><ul>
<li><a class="reference internal" href="#elementinclude-functions">함수</a></li>
<li><a class="reference internal" href="#element-objects">Element 객체</a></li>
<li><a class="reference internal" href="#elementtree-objects">ElementTree 객체</a></li>
<li><a class="reference internal" href="#qname-objects">QName 객체</a></li>
<li><a class="reference internal" href="#treebuilder-objects">TreeBuilder 객체</a></li>
<li><a class="reference internal" href="#xmlparser-objects">XMLParser 객체</a></li>
<li><a class="reference internal" href="#xmlpullparser-objects">XMLPullParser 객체</a></li>
<li><a class="reference internal" href="#exceptions">예외</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="xml.html"
                        title="이전 장">XML 처리 모듈</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="xml.dom.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom</span></code> --- 문서 객체 모델 API</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="xml.dom.html" title="xml.dom --- 문서 객체 모델 API"
             >다음</a> |</li>
        <li class="right" >
          <a href="xml.html" title="XML 처리 모듈"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="markup.html" >구조화된 마크업 처리 도구</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>