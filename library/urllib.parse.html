
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>urllib.parse --- URL을 구성 요소로 구문 분석 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="urllib.error --- urllib.request에 의해 발생하는 예외 클래스" href="urllib.error.html" />
    <link rel="prev" title="urllib.request --- Extensible library for opening URLs" href="urllib.request.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/urllib.parse.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="urllib.error.html" title="urllib.error --- urllib.request에 의해 발생하는 예외 클래스"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="urllib.request.html" title="urllib.request --- Extensible library for opening URLs"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-urllib.parse">
<span id="urllib-parse-parse-urls-into-components"></span><h1><a class="reference internal" href="#module-urllib.parse" title="urllib.parse: Parse URLs into or assemble them from components."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code></a> --- URL을 구성 요소로 구문 분석<a class="headerlink" href="#module-urllib.parse" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/urllib/parse.py">Lib/urllib/parse.py</a></p>
<hr class="docutils" id="index-0" />
<p>이 모듈은 URL(Uniform Resource Locator) 문자열을 구성 요소(주소 지정 체계, 네트워크 위치, 경로 등)로 분리하고, 구성 요소를 다시 URL 문자열로 결합하고, &quot;상대 URL&quot;을 주어진 &quot;기본 URL&quot;에 따라 절대 URL로 변환하는 표준 인터페이스를 정의합니다.</p>
<p>이 모듈은 상대 URL(Relative Uniform Resource Locators)의 인터넷 RFC와 일치하도록 설계되었습니다. 다음과 같은 URL 스킴을 지원합니다: <code class="docutils literal notranslate"><span class="pre">file</span></code>, <code class="docutils literal notranslate"><span class="pre">ftp</span></code>, <code class="docutils literal notranslate"><span class="pre">gopher</span></code>, <code class="docutils literal notranslate"><span class="pre">hdl</span></code>, <code class="docutils literal notranslate"><span class="pre">http</span></code>, <code class="docutils literal notranslate"><span class="pre">https</span></code>, <code class="docutils literal notranslate"><span class="pre">imap</span></code>, <code class="docutils literal notranslate"><span class="pre">mailto</span></code>, <code class="docutils literal notranslate"><span class="pre">mms</span></code>, <code class="docutils literal notranslate"><span class="pre">news</span></code>, <code class="docutils literal notranslate"><span class="pre">nntp</span></code>, <code class="docutils literal notranslate"><span class="pre">prospero</span></code>, <code class="docutils literal notranslate"><span class="pre">rsync</span></code>, <code class="docutils literal notranslate"><span class="pre">rtsp</span></code>, <code class="docutils literal notranslate"><span class="pre">rtspu</span></code>, <code class="docutils literal notranslate"><span class="pre">sftp</span></code>, <code class="docutils literal notranslate"><span class="pre">shttp</span></code>, <code class="docutils literal notranslate"><span class="pre">sip</span></code>, <code class="docutils literal notranslate"><span class="pre">sips</span></code>, <code class="docutils literal notranslate"><span class="pre">snews</span></code>, <code class="docutils literal notranslate"><span class="pre">svn</span></code>, <code class="docutils literal notranslate"><span class="pre">svn+ssh</span></code>, <code class="docutils literal notranslate"><span class="pre">telnet</span></code>, <code class="docutils literal notranslate"><span class="pre">wais</span></code>, <code class="docutils literal notranslate"><span class="pre">ws</span></code>, <code class="docutils literal notranslate"><span class="pre">wss</span></code>.</p>
<p><a class="reference internal" href="#module-urllib.parse" title="urllib.parse: Parse URLs into or assemble them from components."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code></a> 모듈은 두 가지 넓은 범주에 속하는 함수들을 정의합니다: URL 구문 분석과 URL 인용(quoting). 이에 대해서는 다음 섹션에서 자세히 설명합니다.</p>
<div class="section" id="url-parsing">
<h2>URL 구문 분석<a class="headerlink" href="#url-parsing" title="제목 주소">¶</a></h2>
<p>URL 구문 분석 함수는 URL 문자열을 구성 요소로 분할하거나 URL 구성 요소를 URL 문자열로 결합하는 데 중점을 둡니다.</p>
<dl class="function">
<dt id="urllib.parse.urlparse">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">urlparse</code><span class="sig-paren">(</span><em class="sig-param">urlstring</em>, <em class="sig-param">scheme=''</em>, <em class="sig-param">allow_fragments=True</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlparse" title="정의 주소">¶</a></dt>
<dd><p>URL을 6개의 구성 요소로 구문 분석하여, 6개 항목 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a>을 반환합니다. 이는 URL의 일반적인 구조에 해당합니다: <code class="docutils literal notranslate"><span class="pre">scheme://netloc/path;parameters?query#fragment</span></code>. 각 튜플 항목은 문자열이며 비어있을 수 있습니다. 구성 요소는 더 작은 부분으로 나뉘지 않으며 (예를 들어 네트워크 위치는 단일 문자열입니다), % 이스케이프는 확장되지 않습니다. 위에 표시된 분리 문자는 <em>path</em> 구성 요소의 선행 슬래시를 제외하고는 결과의 일부가 아니며 존재하면 유지됩니다. 예를 들면:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;http://www.cwi.nl:80/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span>   
<span class="go">ParseResult(scheme=&#39;http&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">scheme</span>
<span class="go">&#39;http&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">port</span>
<span class="go">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">&#39;http://www.cwi.nl:80/%7Eguido/Python.html&#39;</span>
</pre></div>
</div>
<p><span class="target" id="index-15"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1808.html"><strong>RFC 1808</strong></a>의 문법 명세에 따라, urlparse는 '//' 로 올바르게 도입되었을 때만 netloc을 인식합니다. 그렇지 않으면 입력은 상대 URL인 것으로 간주하고 path 구성 요소로 시작합니다.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="go"> &gt;&gt;&gt; from urllib.parse import urlparse</span>
<span class="go"> &gt;&gt;&gt; urlparse(&#39;//www.cwi.nl:80/%7Eguido/Python.html&#39;)</span>
<span class="go"> ParseResult(scheme=&#39;&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="go"> &gt;&gt;&gt; urlparse(&#39;www.cwi.nl/%7Eguido/Python.html&#39;)</span>
<span class="go"> ParseResult(scheme=&#39;&#39;, netloc=&#39;&#39;, path=&#39;www.cwi.nl/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="go"> &gt;&gt;&gt; urlparse(&#39;help/Python.html&#39;)</span>
<span class="go"> ParseResult(scheme=&#39;&#39;, netloc=&#39;&#39;, path=&#39;help/Python.html&#39;, params=&#39;&#39;,</span>
<span class="go">            query=&#39;&#39;, fragment=&#39;&#39;)</span>
</pre></div>
</div>
<p><em>scheme</em> 인자는 URL이 지정하지 않은 경우에만 사용될 기본 주소 지정 체계를 제공합니다. 기본값 <code class="docutils literal notranslate"><span class="pre">''</span></code>가 항상 허용되고 필요하면 자동으로 <code class="docutils literal notranslate"><span class="pre">b''</span></code>로 변환된다는 점을 제외하고, <em>urlstring</em>과 같은 형(텍스트나 바이트열)이어야 합니다.</p>
<p><em>allow_fragments</em> 인자가 거짓이면, 프래그먼트 식별자는 인식되지 않습니다. 대신, path, parameters 또는 query 구성 요소의 일부로 구문 분석되고 <code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code>는 반환 값에서 빈 문자열로 설정됩니다.</p>
<p>반환 값은 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a>입니다. 즉, 다음과 같은 인덱스나 이름있는 어트리뷰트로 해당 항목에 액세스 할 수 있습니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 10%" />
<col style="width: 36%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>어트리뷰트</p></th>
<th class="head"><p>인덱스</p></th>
<th class="head"><p>값</p></th>
<th class="head"><p>존재하지 않을 때의 값</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">scheme</span></code></p></td>
<td><p>0</p></td>
<td><p>URL 스킴 지정자</p></td>
<td><p><em>scheme</em> 매개 변수</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code></p></td>
<td><p>1</p></td>
<td><p>네트워크 위치 부분</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></p></td>
<td><p>2</p></td>
<td><p>계층적 경로</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">params</span></code></p></td>
<td><p>3</p></td>
<td><p>마지막 경로 요소의 파라미터</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">query</span></code></p></td>
<td><p>4</p></td>
<td><p>쿼리 구성 요소</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code></p></td>
<td><p>5</p></td>
<td><p>프래그먼트 식별자</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">username</span></code></p></td>
<td></td>
<td><p>사용자 이름</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">password</span></code></p></td>
<td></td>
<td><p>비밀번호</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">hostname</span></code></p></td>
<td></td>
<td><p>호스트 이름 (소문자)</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code></p></td>
<td></td>
<td><p>존재하면, 정수로 표시되는 포트 번호</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>URL에 잘못된 포트가 지정된 경우 <code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code> 어트리뷰트를 읽으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 결과 객체에 대한 자세한 내용은 <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">Structured Parse Results</span></a> 섹션을 참조하십시오.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> 어트리뷰트에서 대 괄호(square brackets)가 일치하지 않으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p>(IDNA 인코딩에서 사용되는) NFKC 정규화에서 <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">#</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">:</span></code> 중 하나로 분해(decompose)되는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> 어트리뷰트의 문자는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다. 구문 분석하기 전에 URL이 분해(decompose)되면, 에러가 발생하지 않습니다.</p>
<p>모든 네임드 튜플의 경우와 마찬가지로, 서브 클래스는 특히 유용한 몇 가지 추가 메서드와 어트리뷰트를 갖습니다. 그러한 메서드 중 하나는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_replace()</span></code>입니다. <code class="xref py py-meth docutils literal notranslate"><span class="pre">_replace()</span></code> 메서드는 지정된 필드를 새로운 값으로 대체한 새로운 ParseResult 객체를 반환합니다.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="go"> &gt;&gt;&gt; from urllib.parse import urlparse</span>
<span class="go"> &gt;&gt;&gt; u = urlparse(&#39;//www.cwi.nl:80/%7Eguido/Python.html&#39;)</span>
<span class="go"> &gt;&gt;&gt; u</span>
<span class="go"> ParseResult(scheme=&#39;&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="go">             params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="go"> &gt;&gt;&gt; u._replace(scheme=&#39;http&#39;)</span>
<span class="go"> ParseResult(scheme=&#39;http&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="go">             params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>IPv6 URL 구문 분석 기능이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><span class="target" id="index-16"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3986.html"><strong>RFC 3986</strong></a>에 따라, 프래그먼트는 이제 모든 URL 스킴에 대해 구문 분석됩니다 (<em>allow_fragment</em>가 거짓이 아니라면). 이전에는, 프래그먼트를 지원하는 스킴의 화이트리스트가 있었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>범위를 벗어난 포트 번호는 이제 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>를 반환하는 대신 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>NFKC 정규화에서 netloc 구문 분석에 영향을 주는 문자는 이제 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.parse_qs">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">parse_qs</code><span class="sig-paren">(</span><em class="sig-param">qs</em>, <em class="sig-param">keep_blank_values=False</em>, <em class="sig-param">strict_parsing=False</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='replace'</em>, <em class="sig-param">max_num_fields=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.parse_qs" title="정의 주소">¶</a></dt>
<dd><p>문자열 인자(<em class="mimetype">application/x-www-form-urlencoded</em> 유형의 데이터)로 제공된 쿼리 문자열을 구문 분석합니다. 데이터는 딕셔너리로 반환됩니다. 딕셔너리 키는 고유한 쿼리 변수 이름이고 값은 각 이름의 값 리스트입니다.</p>
<p>선택적 인자 <em>keep_blank_values</em>는 퍼센트 인코딩 된 쿼리의 빈 값을 빈 문자열로 처리해야하는지를 나타내는 플래그입니다. 참 값은 빈 값을 빈 문자열로 유지해야 함을 나타냅니다. 기본 거짓 값은 빈 값이 무시되고 포함되지 않은 것처럼 처리됨을 나타냅니다.</p>
<p>선택적 인자 <em>strict_parsing</em>은 구문 분석 에러시 수행 할 작업을 나타내는 플래그입니다. 거짓(기본값)이면, 에러가 조용히 무시됩니다. 참이면, 에러는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 예외를 발생시킵니다.</p>
<p>선택적 <em>encoding</em>과 <em>errors</em> 매개 변수는 <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> 메서드에서 받아들이는 것 처럼 퍼센트 인코딩된 시퀀스를 유니코드 문자로 디코딩하는 방법을 지정합니다.</p>
<p>선택적 인자 <em>max_num_fields</em>는 읽을 최대 필드 수입니다. 설정되면, <em>max_num_fields</em> 필드보다 많은 것을 읽을 때 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p>이러한 딕셔너리를 쿼리 문자열로 변환하려면 <a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 함수를 (<code class="docutils literal notranslate"><span class="pre">doseq</span></code> 매개 변수를 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정해서) 사용하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>encoding</em>과 <em>errors</em> 매개 변수를 추가합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><em>max_num_fields</em> 매개 변수를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.parse_qsl">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">parse_qsl</code><span class="sig-paren">(</span><em class="sig-param">qs</em>, <em class="sig-param">keep_blank_values=False</em>, <em class="sig-param">strict_parsing=False</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='replace'</em>, <em class="sig-param">max_num_fields=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.parse_qsl" title="정의 주소">¶</a></dt>
<dd><p>문자열 인자(<em class="mimetype">application/x-www-form-urlencoded</em> 유형의 데이터)로 제공된 쿼리 문자열을 구문 분석합니다. 데이터는 이름, 값 쌍의 리스트로 반환됩니다.</p>
<p>선택적 인자 <em>keep_blank_values</em>는 퍼센트 인코딩 된 쿼리의 빈 값을 빈 문자열로 처리해야하는지를 나타내는 플래그입니다. 참 값은 빈 값을 빈 문자열로 유지해야 함을 나타냅니다. 기본 거짓 값은 빈 값이 무시되고 포함되지 않은 것처럼 처리됨을 나타냅니다.</p>
<p>선택적 인자 <em>strict_parsing</em>은 구문 분석 에러시 수행 할 작업을 나타내는 플래그입니다. 거짓(기본값)이면, 에러가 조용히 무시됩니다. 참이면, 에러는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 예외를 발생시킵니다.</p>
<p>선택적 <em>encoding</em>과 <em>errors</em> 매개 변수는 <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> 메서드에서 받아들이는 것 처럼 퍼센트 인코딩된 시퀀스를 유니코드 문자로 디코딩하는 방법을 지정합니다.</p>
<p>선택적 인자 <em>max_num_fields</em>는 읽을 최대 필드 수입니다. 설정되면, <em>max_num_fields</em> 필드보다 많은 것을 읽을 때 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p>이러한 쌍의 리스트를 쿼리 문자열로 변환하려면 <a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 함수를 사용하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>encoding</em>과 <em>errors</em> 매개 변수를 추가합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><em>max_num_fields</em> 매개 변수를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.urlunparse">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">urlunparse</code><span class="sig-paren">(</span><em class="sig-param">parts</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlunparse" title="정의 주소">¶</a></dt>
<dd><p>Construct a URL from a tuple as returned by <code class="docutils literal notranslate"><span class="pre">urlparse()</span></code>. The <em>parts</em>
argument can be any six-item iterable. This may result in a slightly
different, but equivalent URL, if the URL that was parsed originally had
unnecessary delimiters (for example, a <code class="docutils literal notranslate"><span class="pre">?</span></code> with an empty query; the RFC
states that these are equivalent).</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.urlsplit">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">urlsplit</code><span class="sig-paren">(</span><em class="sig-param">urlstring</em>, <em class="sig-param">scheme=''</em>, <em class="sig-param">allow_fragments=True</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlsplit" title="정의 주소">¶</a></dt>
<dd><p>This is similar to <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a>, but does not split the params from the URL.
This should generally be used instead of <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> if the more recent URL
syntax allowing parameters to be applied to each segment of the <em>path</em> portion
of the URL (see <span class="target" id="index-3"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2396.html"><strong>RFC 2396</strong></a>) is wanted.  A separate function is needed to
separate the path segments and parameters.  This function returns a 5-item
<a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">addressing</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">network</span> <span class="n">location</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">fragment</span> <span class="n">identifier</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>The return value is a <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>, its items can be accessed by index
or as named attributes:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 10%" />
<col style="width: 35%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>어트리뷰트</p></th>
<th class="head"><p>인덱스</p></th>
<th class="head"><p>값</p></th>
<th class="head"><p>존재하지 않을 때의 값</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">scheme</span></code></p></td>
<td><p>0</p></td>
<td><p>URL 스킴 지정자</p></td>
<td><p><em>scheme</em> 매개 변수</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code></p></td>
<td><p>1</p></td>
<td><p>네트워크 위치 부분</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></p></td>
<td><p>2</p></td>
<td><p>계층적 경로</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">query</span></code></p></td>
<td><p>3</p></td>
<td><p>쿼리 구성 요소</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code></p></td>
<td><p>4</p></td>
<td><p>프래그먼트 식별자</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">username</span></code></p></td>
<td></td>
<td><p>사용자 이름</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">password</span></code></p></td>
<td></td>
<td><p>비밀번호</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">hostname</span></code></p></td>
<td></td>
<td><p>호스트 이름 (소문자)</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code></p></td>
<td></td>
<td><p>존재하면, 정수로 표시되는 포트 번호</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>URL에 잘못된 포트가 지정된 경우 <code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code> 어트리뷰트를 읽으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 결과 객체에 대한 자세한 내용은 <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">Structured Parse Results</span></a> 섹션을 참조하십시오.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> 어트리뷰트에서 대 괄호(square brackets)가 일치하지 않으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p>(IDNA 인코딩에서 사용되는) NFKC 정규화에서 <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">#</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">:</span></code> 중 하나로 분해(decompose)되는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> 어트리뷰트의 문자는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다. 구문 분석하기 전에 URL이 분해(decompose)되면, 에러가 발생하지 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>범위를 벗어난 포트 번호는 이제 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>를 반환하는 대신 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>NFKC 정규화에서 netloc 구문 분석에 영향을 주는 문자는 이제 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.urlunsplit">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">urlunsplit</code><span class="sig-paren">(</span><em class="sig-param">parts</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlunsplit" title="정의 주소">¶</a></dt>
<dd><p>Combine the elements of a tuple as returned by <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> into a
complete URL as a string. The <em>parts</em> argument can be any five-item
iterable. This may result in a slightly different, but equivalent URL, if the
URL that was parsed originally had unnecessary delimiters (for example, a ?
with an empty query; the RFC states that these are equivalent).</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.urljoin">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">urljoin</code><span class="sig-paren">(</span><em class="sig-param">base</em>, <em class="sig-param">url</em>, <em class="sig-param">allow_fragments=True</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urljoin" title="정의 주소">¶</a></dt>
<dd><p>Construct a full (&quot;absolute&quot;) URL by combining a &quot;base URL&quot; (<em>base</em>) with
another URL (<em>url</em>).  Informally, this uses components of the base URL, in
particular the addressing scheme, the network location and (part of) the
path, to provide missing components in the relative URL.  For example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urljoin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urljoin</span><span class="p">(</span><span class="s1">&#39;http://www.cwi.nl/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">,</span> <span class="s1">&#39;FAQ.html&#39;</span><span class="p">)</span>
<span class="go">&#39;http://www.cwi.nl/%7Eguido/FAQ.html&#39;</span>
</pre></div>
</div>
<p>The <em>allow_fragments</em> argument has the same meaning and default as for
<a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>If <em>url</em> is an absolute URL (that is, starting with <code class="docutils literal notranslate"><span class="pre">//</span></code> or <code class="docutils literal notranslate"><span class="pre">scheme://</span></code>),
the <em>url</em>'s host name and/or scheme will be present in the result.  For example:</p>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">urljoin</span><span class="p">(</span><span class="s1">&#39;http://www.cwi.nl/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">&#39;//www.python.org/</span><span class="si">%7E</span><span class="s1">guido&#39;</span><span class="p">)</span>
<span class="go">&#39;http://www.python.org/%7Eguido&#39;</span>
</pre></div>
</div>
<p>If you do not want that behavior, preprocess the <em>url</em> with <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> and
<a class="reference internal" href="#urllib.parse.urlunsplit" title="urllib.parse.urlunsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlunsplit()</span></code></a>, removing possible <em>scheme</em> and <em>netloc</em> parts.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>Behaviour updated to match the semantics defined in <span class="target" id="index-4"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3986.html"><strong>RFC 3986</strong></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.urldefrag">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">urldefrag</code><span class="sig-paren">(</span><em class="sig-param">url</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urldefrag" title="정의 주소">¶</a></dt>
<dd><p>If <em>url</em> contains a fragment identifier, return a modified version of <em>url</em>
with no fragment identifier, and the fragment identifier as a separate
string.  If there is no fragment identifier in <em>url</em>, return <em>url</em> unmodified
and an empty string.</p>
<p>The return value is a <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>, its items can be accessed by index
or as named attributes:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 10%" />
<col style="width: 35%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>어트리뷰트</p></th>
<th class="head"><p>인덱스</p></th>
<th class="head"><p>값</p></th>
<th class="head"><p>존재하지 않을 때의 값</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">url</span></code></p></td>
<td><p>0</p></td>
<td><p>URL with no fragment</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code></p></td>
<td><p>1</p></td>
<td><p>프래그먼트 식별자</p></td>
<td><p>빈 문자열</p></td>
</tr>
</tbody>
</table>
<p>See section <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">Structured Parse Results</span></a> for more information on the result
object.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>Result is a structured object rather than a simple 2-tuple.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.unwrap">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">unwrap</code><span class="sig-paren">(</span><em class="sig-param">url</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.unwrap" title="정의 주소">¶</a></dt>
<dd><p>Extract the url from a wrapped URL (that is, a string formatted as
<code class="docutils literal notranslate"><span class="pre">&lt;URL:scheme://host/path&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;scheme://host/path&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">URL:scheme://host/path</span></code>
or <code class="docutils literal notranslate"><span class="pre">scheme://host/path</span></code>). If <em>url</em> is not a wrapped URL, it is returned
without changes.</p>
</dd></dl>

</div>
<div class="section" id="parsing-ascii-encoded-bytes">
<span id="id1"></span><h2>Parsing ASCII Encoded Bytes<a class="headerlink" href="#parsing-ascii-encoded-bytes" title="제목 주소">¶</a></h2>
<p>The URL parsing functions were originally designed to operate on character
strings only. In practice, it is useful to be able to manipulate properly
quoted and encoded URLs as sequences of ASCII bytes. Accordingly, the
URL parsing functions in this module all operate on <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> and
<a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> objects in addition to <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> objects.</p>
<p>If <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> data is passed in, the result will also contain only
<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> data. If <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> or <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> data is
passed in, the result will contain only <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> data.</p>
<p>Attempting to mix <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> data with <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> or
<a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> in a single function call will result in a
<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> being raised, while attempting to pass in non-ASCII
byte values will trigger <a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a>.</p>
<p>To support easier conversion of result objects between <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> and
<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, all return values from URL parsing functions provide
either an <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> method (when the result contains <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>
data) or a <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> method (when the result contains <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>
data). The signatures of these methods match those of the corresponding
<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> and <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> methods (except that the default encoding
is <code class="docutils literal notranslate"><span class="pre">'ascii'</span></code> rather than <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>). Each produces a value of a
corresponding type that contains either <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> data (for
<code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> methods) or <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> data (for
<code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> methods).</p>
<p>Applications that need to operate on potentially improperly quoted URLs
that may contain non-ASCII data will need to do their own decoding from
bytes to characters before invoking the URL parsing methods.</p>
<p>The behaviour described in this section applies only to the URL parsing
functions. The URL quoting functions use their own rules when producing
or consuming byte sequences as detailed in the documentation of the
individual URL quoting functions.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>URL parsing functions now accept ASCII encoded byte sequences</p>
</div>
</div>
<div class="section" id="structured-parse-results">
<span id="urlparse-result-object"></span><h2>Structured Parse Results<a class="headerlink" href="#structured-parse-results" title="제목 주소">¶</a></h2>
<p>The result objects from the <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a>, <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a>  and
<a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> functions are subclasses of the <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> type.
These subclasses add the attributes listed in the documentation for
those functions, the encoding and decoding support described in the
previous section, as well as an additional method:</p>
<dl class="method">
<dt id="urllib.parse.urllib.parse.SplitResult.geturl">
<code class="sig-prename descclassname">urllib.parse.SplitResult.</code><code class="sig-name descname">geturl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urllib.parse.SplitResult.geturl" title="정의 주소">¶</a></dt>
<dd><p>Return the re-combined version of the original URL as a string. This may
differ from the original URL in that the scheme may be normalized to lower
case and empty components may be dropped. Specifically, empty parameters,
queries, and fragment identifiers will be removed.</p>
<p>For <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> results, only empty fragment identifiers will be removed.
For <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> and <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> results, all noted changes will be
made to the URL returned by this method.</p>
<p>The result of this method remains unchanged if passed back through the original
parsing function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urlsplit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;HTTP://www.Python.org/doc/#&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">&#39;http://www.Python.org/doc/&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">r1</span><span class="o">.</span><span class="n">geturl</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">&#39;http://www.Python.org/doc/&#39;</span>
</pre></div>
</div>
</dd></dl>

<p>The following classes provide the implementations of the structured parse
results when operating on <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> objects:</p>
<dl class="class">
<dt id="urllib.parse.DefragResult">
<em class="property">class </em><code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">DefragResult</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">fragment</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.DefragResult" title="정의 주소">¶</a></dt>
<dd><p>Concrete class for <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> results containing <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>
data. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> method returns a <a class="reference internal" href="#urllib.parse.DefragResultBytes" title="urllib.parse.DefragResultBytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">DefragResultBytes</span></code></a>
instance.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.parse.ParseResult">
<em class="property">class </em><code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">ParseResult</code><span class="sig-paren">(</span><em class="sig-param">scheme</em>, <em class="sig-param">netloc</em>, <em class="sig-param">path</em>, <em class="sig-param">params</em>, <em class="sig-param">query</em>, <em class="sig-param">fragment</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.ParseResult" title="정의 주소">¶</a></dt>
<dd><p>Concrete class for <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> results containing <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>
data. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> method returns a <a class="reference internal" href="#urllib.parse.ParseResultBytes" title="urllib.parse.ParseResultBytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParseResultBytes</span></code></a>
instance.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.parse.SplitResult">
<em class="property">class </em><code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">SplitResult</code><span class="sig-paren">(</span><em class="sig-param">scheme</em>, <em class="sig-param">netloc</em>, <em class="sig-param">path</em>, <em class="sig-param">query</em>, <em class="sig-param">fragment</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.SplitResult" title="정의 주소">¶</a></dt>
<dd><p>Concrete class for <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> results containing <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>
data. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> method returns a <a class="reference internal" href="#urllib.parse.SplitResultBytes" title="urllib.parse.SplitResultBytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitResultBytes</span></code></a>
instance.</p>
</dd></dl>

<p>The following classes provide the implementations of the parse results when
operating on <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> or <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> objects:</p>
<dl class="class">
<dt id="urllib.parse.DefragResultBytes">
<em class="property">class </em><code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">DefragResultBytes</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">fragment</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.DefragResultBytes" title="정의 주소">¶</a></dt>
<dd><p>Concrete class for <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> results containing <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>
data. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> method returns a <a class="reference internal" href="#urllib.parse.DefragResult" title="urllib.parse.DefragResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">DefragResult</span></code></a>
instance.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.parse.ParseResultBytes">
<em class="property">class </em><code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">ParseResultBytes</code><span class="sig-paren">(</span><em class="sig-param">scheme</em>, <em class="sig-param">netloc</em>, <em class="sig-param">path</em>, <em class="sig-param">params</em>, <em class="sig-param">query</em>, <em class="sig-param">fragment</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.ParseResultBytes" title="정의 주소">¶</a></dt>
<dd><p>Concrete class for <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> results containing <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>
data. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> method returns a <a class="reference internal" href="#urllib.parse.ParseResult" title="urllib.parse.ParseResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParseResult</span></code></a>
instance.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.parse.SplitResultBytes">
<em class="property">class </em><code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">SplitResultBytes</code><span class="sig-paren">(</span><em class="sig-param">scheme</em>, <em class="sig-param">netloc</em>, <em class="sig-param">path</em>, <em class="sig-param">query</em>, <em class="sig-param">fragment</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.SplitResultBytes" title="정의 주소">¶</a></dt>
<dd><p>Concrete class for <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> results containing <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>
data. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> method returns a <a class="reference internal" href="#urllib.parse.SplitResult" title="urllib.parse.SplitResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitResult</span></code></a>
instance.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="url-quoting">
<h2>URL Quoting<a class="headerlink" href="#url-quoting" title="제목 주소">¶</a></h2>
<p>The URL quoting functions focus on taking program data and making it safe
for use as URL components by quoting special characters and appropriately
encoding non-ASCII text. They also support reversing these operations to
recreate the original data from the contents of a URL component if that
task isn't already covered by the URL parsing functions above.</p>
<dl class="function">
<dt id="urllib.parse.quote">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">quote</code><span class="sig-paren">(</span><em class="sig-param">string</em>, <em class="sig-param">safe='/'</em>, <em class="sig-param">encoding=None</em>, <em class="sig-param">errors=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.quote" title="정의 주소">¶</a></dt>
<dd><p>Replace special characters in <em>string</em> using the <code class="docutils literal notranslate"><span class="pre">%xx</span></code> escape. Letters,
digits, and the characters <code class="docutils literal notranslate"><span class="pre">'_.-~'</span></code> are never quoted. By default, this
function is intended for quoting the path section of URL. The optional <em>safe</em>
parameter specifies additional ASCII characters that should not be quoted
--- its default value is <code class="docutils literal notranslate"><span class="pre">'/'</span></code>.</p>
<p><em>string</em> may be either a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Moved from <span class="target" id="index-5"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2396.html"><strong>RFC 2396</strong></a> to <span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3986.html"><strong>RFC 3986</strong></a> for quoting URL strings. &quot;~&quot; is now
included in the set of unreserved characters.</p>
</div>
<p>The optional <em>encoding</em> and <em>errors</em> parameters specify how to deal with
non-ASCII characters, as accepted by the <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> method.
<em>encoding</em> defaults to <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>.
<em>errors</em> defaults to <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>, meaning unsupported characters raise a
<a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a>.
<em>encoding</em> and <em>errors</em> must not be supplied if <em>string</em> is a
<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, or a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code></a> is raised.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">quote(string,</span> <span class="pre">safe,</span> <span class="pre">encoding,</span> <span class="pre">errors)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">quote_from_bytes(string.encode(encoding,</span> <span class="pre">errors),</span> <span class="pre">safe)</span></code>.</p>
<p>Example: <code class="docutils literal notranslate"><span class="pre">quote('/El</span> <span class="pre">Niño/')</span></code> yields <code class="docutils literal notranslate"><span class="pre">'/El%20Ni%C3%B1o/'</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.quote_plus">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">quote_plus</code><span class="sig-paren">(</span><em class="sig-param">string</em>, <em class="sig-param">safe=''</em>, <em class="sig-param">encoding=None</em>, <em class="sig-param">errors=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.quote_plus" title="정의 주소">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>, but also replace spaces by plus signs, as required for
quoting HTML form values when building up a query string to go into a URL.
Plus signs in the original string are escaped unless they are included in
<em>safe</em>.  It also does not have <em>safe</em> default to <code class="docutils literal notranslate"><span class="pre">'/'</span></code>.</p>
<p>Example: <code class="docutils literal notranslate"><span class="pre">quote_plus('/El</span> <span class="pre">Niño/')</span></code> yields <code class="docutils literal notranslate"><span class="pre">'%2FEl+Ni%C3%B1o%2F'</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.quote_from_bytes">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">quote_from_bytes</code><span class="sig-paren">(</span><em class="sig-param">bytes</em>, <em class="sig-param">safe='/'</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.quote_from_bytes" title="정의 주소">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>, but accepts a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> object rather than a
<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, and does not perform string-to-bytes encoding.</p>
<p>Example: <code class="docutils literal notranslate"><span class="pre">quote_from_bytes(b'a&amp;\xef')</span></code> yields
<code class="docutils literal notranslate"><span class="pre">'a%26%EF'</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.unquote">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">unquote</code><span class="sig-paren">(</span><em class="sig-param">string</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='replace'</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.unquote" title="정의 주소">¶</a></dt>
<dd><p>Replace <code class="docutils literal notranslate"><span class="pre">%xx</span></code> escapes by their single-character equivalent.
The optional <em>encoding</em> and <em>errors</em> parameters specify how to decode
percent-encoded sequences into Unicode characters, as accepted by the
<a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> method.</p>
<p><em>string</em> must be a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
<p><em>encoding</em> defaults to <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>.
<em>errors</em> defaults to <code class="docutils literal notranslate"><span class="pre">'replace'</span></code>, meaning invalid sequences are replaced
by a placeholder character.</p>
<p>Example: <code class="docutils literal notranslate"><span class="pre">unquote('/El%20Ni%C3%B1o/')</span></code> yields <code class="docutils literal notranslate"><span class="pre">'/El</span> <span class="pre">Niño/'</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.unquote_plus">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">unquote_plus</code><span class="sig-paren">(</span><em class="sig-param">string</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='replace'</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.unquote_plus" title="정의 주소">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#urllib.parse.unquote" title="urllib.parse.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">unquote()</span></code></a>, but also replace plus signs by spaces, as required for
unquoting HTML form values.</p>
<p><em>string</em> must be a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
<p>Example: <code class="docutils literal notranslate"><span class="pre">unquote_plus('/El+Ni%C3%B1o/')</span></code> yields <code class="docutils literal notranslate"><span class="pre">'/El</span> <span class="pre">Niño/'</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.unquote_to_bytes">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">unquote_to_bytes</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.unquote_to_bytes" title="정의 주소">¶</a></dt>
<dd><p>Replace <code class="docutils literal notranslate"><span class="pre">%xx</span></code> escapes by their single-octet equivalent, and return a
<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> object.</p>
<p><em>string</em> may be either a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<p>If it is a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, unescaped non-ASCII characters in <em>string</em>
are encoded into UTF-8 bytes.</p>
<p>Example: <code class="docutils literal notranslate"><span class="pre">unquote_to_bytes('a%26%EF')</span></code> yields <code class="docutils literal notranslate"><span class="pre">b'a&amp;\xef'</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.urlencode">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">urlencode</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">doseq=False</em>, <em class="sig-param">safe=''</em>, <em class="sig-param">encoding=None</em>, <em class="sig-param">errors=None</em>, <em class="sig-param">quote_via=quote_plus</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlencode" title="정의 주소">¶</a></dt>
<dd><p>Convert a mapping object or a sequence of two-element tuples, which may
contain <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> objects, to a percent-encoded ASCII
text string.  If the resultant string is to be used as a <em>data</em> for POST
operation with the <a class="reference internal" href="urllib.request.html#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> function, then
it should be encoded to bytes, otherwise it would result in a
<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<p>The resulting string is a series of <code class="docutils literal notranslate"><span class="pre">key=value</span></code> pairs separated by <code class="docutils literal notranslate"><span class="pre">'&amp;'</span></code>
characters, where both <em>key</em> and <em>value</em> are quoted using the <em>quote_via</em>
function.  By default, <a class="reference internal" href="#urllib.parse.quote_plus" title="urllib.parse.quote_plus"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote_plus()</span></code></a> is used to quote the values, which
means spaces are quoted as a <code class="docutils literal notranslate"><span class="pre">'+'</span></code> character and '/' characters are
encoded as <code class="docutils literal notranslate"><span class="pre">%2F</span></code>, which follows the standard for GET requests
(<code class="docutils literal notranslate"><span class="pre">application/x-www-form-urlencoded</span></code>).  An alternate function that can be
passed as <em>quote_via</em> is <a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>, which will encode spaces as <code class="docutils literal notranslate"><span class="pre">%20</span></code>
and not encode '/' characters.  For maximum control of what is quoted, use
<code class="docutils literal notranslate"><span class="pre">quote</span></code> and specify a value for <em>safe</em>.</p>
<p>When a sequence of two-element tuples is used as the <em>query</em>
argument, the first element of each tuple is a key and the second is a
value. The value element in itself can be a sequence and in that case, if
the optional parameter <em>doseq</em> is evaluates to <code class="docutils literal notranslate"><span class="pre">True</span></code>, individual
<code class="docutils literal notranslate"><span class="pre">key=value</span></code> pairs separated by <code class="docutils literal notranslate"><span class="pre">'&amp;'</span></code> are generated for each element of
the value sequence for the key.  The order of parameters in the encoded
string will match the order of parameter tuples in the sequence.</p>
<p>The <em>safe</em>, <em>encoding</em>, and <em>errors</em> parameters are passed down to
<em>quote_via</em> (the <em>encoding</em> and <em>errors</em> parameters are only passed
when a query element is a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>).</p>
<p>To reverse this encoding process, <a class="reference internal" href="#urllib.parse.parse_qs" title="urllib.parse.parse_qs"><code class="xref py py-func docutils literal notranslate"><span class="pre">parse_qs()</span></code></a> and <a class="reference internal" href="#urllib.parse.parse_qsl" title="urllib.parse.parse_qsl"><code class="xref py py-func docutils literal notranslate"><span class="pre">parse_qsl()</span></code></a> are
provided in this module to parse query strings into Python data structures.</p>
<p>Refer to <a class="reference internal" href="urllib.request.html#urllib-examples"><span class="std std-ref">urllib examples</span></a> to find out how urlencode
method can be used for generating query string for a URL or data for POST.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>Query parameter supports bytes and string objects.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가: </span><em>quote_via</em> parameter.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-7"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3986.html"><strong>RFC 3986</strong></a> - Uniform Resource Identifiers</dt><dd><p>This is the current standard (STD66). Any changes to urllib.parse module
should conform to this. Certain deviations could be observed, which are
mostly for backward compatibility purposes and for certain de-facto
parsing requirements as commonly observed in major browsers.</p>
</dd>
<dt><span class="target" id="index-8"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2732.html"><strong>RFC 2732</strong></a> - Format for Literal IPv6 Addresses in URL's.</dt><dd><p>This specifies the parsing requirements of IPv6 URLs.</p>
</dd>
<dt><span class="target" id="index-9"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2396.html"><strong>RFC 2396</strong></a> - Uniform Resource Identifiers (URI): Generic Syntax</dt><dd><p>Document describing the generic syntactic requirements for both Uniform Resource
Names (URNs) and Uniform Resource Locators (URLs).</p>
</dd>
<dt><span class="target" id="index-10"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2368.html"><strong>RFC 2368</strong></a> - The mailto URL scheme.</dt><dd><p>Parsing requirements for mailto URL schemes.</p>
</dd>
<dt><span class="target" id="index-11"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1808.html"><strong>RFC 1808</strong></a> - Relative Uniform Resource Locators</dt><dd><p>This Request For Comments includes the rules for joining an absolute and a
relative URL, including a fair number of &quot;Abnormal Examples&quot; which govern the
treatment of border cases.</p>
</dd>
<dt><span class="target" id="index-12"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1738.html"><strong>RFC 1738</strong></a> - Uniform Resource Locators (URL)</dt><dd><p>This specifies the formal syntax and semantics of absolute URLs.</p>
</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code> --- URL을 구성 요소로 구문 분석</a><ul>
<li><a class="reference internal" href="#url-parsing">URL 구문 분석</a></li>
<li><a class="reference internal" href="#parsing-ascii-encoded-bytes">Parsing ASCII Encoded Bytes</a></li>
<li><a class="reference internal" href="#structured-parse-results">Structured Parse Results</a></li>
<li><a class="reference internal" href="#url-quoting">URL Quoting</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="urllib.request.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> --- Extensible library for opening URLs</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="urllib.error.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.error</span></code> --- urllib.request에 의해 발생하는 예외 클래스</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="urllib.error.html" title="urllib.error --- urllib.request에 의해 발생하는 예외 클래스"
             >다음</a> |</li>
        <li class="right" >
          <a href="urllib.request.html" title="urllib.request --- Extensible library for opening URLs"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>