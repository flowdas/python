
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>urllib.parse --- URL을 구성 요소로 구문 분석 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="urllib.error --- urllib.request에 의해 발생하는 예외 클래스" href="urllib.error.html" />
    <link rel="prev" title="urllib.request --- URL을 열기 위한 확장 가능한 라이브러리" href="urllib.request.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/urllib.parse.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="urllib.error.html" title="urllib.error --- urllib.request에 의해 발생하는 예외 클래스"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="urllib.request.html" title="urllib.request --- URL을 열기 위한 확장 가능한 라이브러리"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-urllib.parse">
<span id="urllib-parse-parse-urls-into-components"></span><h1><a class="reference internal" href="#module-urllib.parse" title="urllib.parse: Parse URLs into or assemble them from components."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code></a> --- URL을 구성 요소로 구문 분석<a class="headerlink" href="#module-urllib.parse" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/urllib/parse.py">Lib/urllib/parse.py</a></p>
<hr class="docutils" id="index-0" />
<p>이 모듈은 URL(Uniform Resource Locator) 문자열을 구성 요소(주소 지정 체계, 네트워크 위치, 경로 등)로 분리하고, 구성 요소를 다시 URL 문자열로 결합하고, &quot;상대 URL&quot;을 주어진 &quot;기본 URL&quot;에 따라 절대 URL로 변환하는 표준 인터페이스를 정의합니다.</p>
<p>이 모듈은 상대 URL(Relative Uniform Resource Locators)의 인터넷 RFC와 일치하도록 설계되었습니다. 다음과 같은 URL 스킴을 지원합니다: <code class="docutils literal notranslate"><span class="pre">file</span></code>, <code class="docutils literal notranslate"><span class="pre">ftp</span></code>, <code class="docutils literal notranslate"><span class="pre">gopher</span></code>, <code class="docutils literal notranslate"><span class="pre">hdl</span></code>, <code class="docutils literal notranslate"><span class="pre">http</span></code>, <code class="docutils literal notranslate"><span class="pre">https</span></code>, <code class="docutils literal notranslate"><span class="pre">imap</span></code>, <code class="docutils literal notranslate"><span class="pre">mailto</span></code>, <code class="docutils literal notranslate"><span class="pre">mms</span></code>, <code class="docutils literal notranslate"><span class="pre">news</span></code>, <code class="docutils literal notranslate"><span class="pre">nntp</span></code>, <code class="docutils literal notranslate"><span class="pre">prospero</span></code>, <code class="docutils literal notranslate"><span class="pre">rsync</span></code>, <code class="docutils literal notranslate"><span class="pre">rtsp</span></code>, <code class="docutils literal notranslate"><span class="pre">rtspu</span></code>, <code class="docutils literal notranslate"><span class="pre">sftp</span></code>, <code class="docutils literal notranslate"><span class="pre">shttp</span></code>, <code class="docutils literal notranslate"><span class="pre">sip</span></code>, <code class="docutils literal notranslate"><span class="pre">sips</span></code>, <code class="docutils literal notranslate"><span class="pre">snews</span></code>, <code class="docutils literal notranslate"><span class="pre">svn</span></code>, <code class="docutils literal notranslate"><span class="pre">svn+ssh</span></code>, <code class="docutils literal notranslate"><span class="pre">telnet</span></code>, <code class="docutils literal notranslate"><span class="pre">wais</span></code>, <code class="docutils literal notranslate"><span class="pre">ws</span></code>, <code class="docutils literal notranslate"><span class="pre">wss</span></code>.</p>
<p><a class="reference internal" href="#module-urllib.parse" title="urllib.parse: Parse URLs into or assemble them from components."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code></a> 모듈은 두 가지 넓은 범주에 속하는 함수들을 정의합니다: URL 구문 분석과 URL 인용(quoting). 이에 대해서는 다음 섹션에서 자세히 설명합니다.</p>
<div class="section" id="url-parsing">
<h2>URL 구문 분석<a class="headerlink" href="#url-parsing" title="제목 주소">¶</a></h2>
<p>URL 구문 분석 함수는 URL 문자열을 구성 요소로 분할하거나 URL 구성 요소를 URL 문자열로 결합하는 데 중점을 둡니다.</p>
<dl class="function">
<dt id="urllib.parse.urlparse">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">urlparse</code><span class="sig-paren">(</span><em class="sig-param">urlstring</em>, <em class="sig-param">scheme=''</em>, <em class="sig-param">allow_fragments=True</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlparse" title="정의 주소">¶</a></dt>
<dd><p>URL을 6개의 구성 요소로 구문 분석하여, 6개 항목 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a>을 반환합니다. 이는 URL의 일반적인 구조에 해당합니다: <code class="docutils literal notranslate"><span class="pre">scheme://netloc/path;parameters?query#fragment</span></code>. 각 튜플 항목은 문자열이며 비어있을 수 있습니다. 구성 요소는 더 작은 부분으로 나뉘지 않으며 (예를 들어 네트워크 위치는 단일 문자열입니다), % 이스케이프는 확장되지 않습니다. 위에 표시된 분리 문자는 <em>path</em> 구성 요소의 선행 슬래시를 제외하고는 결과의 일부가 아니며 존재하면 유지됩니다. 예를 들면:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;http://www.cwi.nl:80/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span>   
<span class="go">ParseResult(scheme=&#39;http&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">scheme</span>
<span class="go">&#39;http&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">port</span>
<span class="go">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">&#39;http://www.cwi.nl:80/%7Eguido/Python.html&#39;</span>
</pre></div>
</div>
<p><span class="target" id="index-19"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1808.html"><strong>RFC 1808</strong></a>의 문법 명세에 따라, urlparse는 '//' 로 올바르게 도입되었을 때만 netloc을 인식합니다. 그렇지 않으면 입력은 상대 URL인 것으로 간주하고 path 구성 요소로 시작합니다.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;//www.cwi.nl:80/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;www.cwi.nl/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;&#39;, netloc=&#39;&#39;, path=&#39;www.cwi.nl/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;help/Python.html&#39;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;&#39;, netloc=&#39;&#39;, path=&#39;help/Python.html&#39;, params=&#39;&#39;,</span>
<span class="go">            query=&#39;&#39;, fragment=&#39;&#39;)</span>
</pre></div>
</div>
<p><em>scheme</em> 인자는 URL이 지정하지 않은 경우에만 사용될 기본 주소 지정 체계를 제공합니다. 기본값 <code class="docutils literal notranslate"><span class="pre">''</span></code>가 항상 허용되고 필요하면 자동으로 <code class="docutils literal notranslate"><span class="pre">b''</span></code>로 변환된다는 점을 제외하고, <em>urlstring</em>과 같은 형(텍스트나 바이트열)이어야 합니다.</p>
<p><em>allow_fragments</em> 인자가 거짓이면, 프래그먼트 식별자는 인식되지 않습니다. 대신, path, parameters 또는 query 구성 요소의 일부로 구문 분석되고 <code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code>는 반환 값에서 빈 문자열로 설정됩니다.</p>
<p>반환 값은 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a>입니다. 즉, 다음과 같은 인덱스나 이름있는 어트리뷰트로 해당 항목에 액세스 할 수 있습니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 10%" />
<col style="width: 36%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>어트리뷰트</p></th>
<th class="head"><p>인덱스</p></th>
<th class="head"><p>값</p></th>
<th class="head"><p>존재하지 않을 때의 값</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">scheme</span></code></p></td>
<td><p>0</p></td>
<td><p>URL 스킴 지정자</p></td>
<td><p><em>scheme</em> 매개 변수</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code></p></td>
<td><p>1</p></td>
<td><p>네트워크 위치 부분</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></p></td>
<td><p>2</p></td>
<td><p>계층적 경로</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">params</span></code></p></td>
<td><p>3</p></td>
<td><p>마지막 경로 요소의 파라미터</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">query</span></code></p></td>
<td><p>4</p></td>
<td><p>쿼리 구성 요소</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code></p></td>
<td><p>5</p></td>
<td><p>프래그먼트 식별자</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">username</span></code></p></td>
<td></td>
<td><p>사용자 이름</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">password</span></code></p></td>
<td></td>
<td><p>비밀번호</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">hostname</span></code></p></td>
<td></td>
<td><p>호스트 이름 (소문자)</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code></p></td>
<td></td>
<td><p>존재하면, 정수로 표시되는 포트 번호</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>URL에 잘못된 포트가 지정된 경우 <code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code> 어트리뷰트를 읽으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 결과 객체에 대한 자세한 내용은 <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">구조화된 구문 분석 결과</span></a> 섹션을 참조하십시오.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> 어트리뷰트에서 대괄호(square brackets)가 일치하지 않으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p>(IDNA 인코딩에서 사용되는) NFKC 정규화에서 <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">#</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">:</span></code> 중 하나로 분해(decompose)되는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> 어트리뷰트의 문자는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다. 구문 분석하기 전에 URL이 분해(decompose)되면, 에러가 발생하지 않습니다.</p>
<p>모든 네임드 튜플의 경우와 마찬가지로, 서브 클래스는 특히 유용한 몇 가지 추가 메서드와 어트리뷰트를 갖습니다. 그러한 메서드 중 하나는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">_replace()</span></code>입니다. <code class="xref py py-meth docutils literal notranslate"><span class="pre">_replace()</span></code> 메서드는 지정된 필드를 새로운 값으로 대체한 새로운 ParseResult 객체를 반환합니다.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;//www.cwi.nl:80/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">ParseResult(scheme=&#39;&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">scheme</span><span class="o">=</span><span class="s1">&#39;http&#39;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;http&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>IPv6 URL 구문 분석 기능이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><span class="target" id="index-20"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3986.html"><strong>RFC 3986</strong></a>에 따라, 프래그먼트는 이제 모든 URL 스킴에 대해 구문 분석됩니다 (<em>allow_fragment</em>가 거짓이 아니라면). 이전에는, 프래그먼트를 지원하는 스킴의 화이트리스트가 있었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>범위를 벗어난 포트 번호는 이제 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환하는 대신 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>NFKC 정규화에서 netloc 구문 분석에 영향을 주는 문자는 이제 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.parse_qs">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">parse_qs</code><span class="sig-paren">(</span><em class="sig-param">qs</em>, <em class="sig-param">keep_blank_values=False</em>, <em class="sig-param">strict_parsing=False</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='replace'</em>, <em class="sig-param">max_num_fields=None</em>, <em class="sig-param">separator='&amp;'</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.parse_qs" title="정의 주소">¶</a></dt>
<dd><p>문자열 인자(<em class="mimetype">application/x-www-form-urlencoded</em> 유형의 데이터)로 제공된 쿼리 문자열을 구문 분석합니다. 데이터는 딕셔너리로 반환됩니다. 딕셔너리 키는 고유한 쿼리 변수 이름이고 값은 각 이름의 값 리스트입니다.</p>
<p>선택적 인자 <em>keep_blank_values</em>는 퍼센트 인코딩된 쿼리의 빈 값을 빈 문자열로 처리해야 하는지를 나타내는 플래그입니다. 참값은 빈 값을 빈 문자열로 유지해야 함을 나타냅니다. 기본 거짓 값은 빈 값이 무시되고 포함되지 않은 것처럼 처리됨을 나타냅니다.</p>
<p>선택적 인자 <em>strict_parsing</em>은 구문 분석 에러 시 수행할 작업을 나타내는 플래그입니다. 거짓(기본값)이면, 에러가 조용히 무시됩니다. 참이면, 에러는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 예외를 발생시킵니다.</p>
<p>선택적 <em>encoding</em>과 <em>errors</em> 매개 변수는 <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> 메서드에서 받아들이는 것처럼 퍼센트 인코딩된 시퀀스를 유니코드 문자로 디코딩하는 방법을 지정합니다.</p>
<p>선택적 인자 <em>max_num_fields</em>는 읽을 최대 필드 수입니다. 설정되면, <em>max_num_fields</em> 필드보다 많은 것을 읽을 때 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p>The optional argument <em>separator</em> is the symbol to use for separating the
query arguments. It defaults to <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>.</p>
<p>이러한 딕셔너리를 쿼리 문자열로 변환하려면 <a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 함수를 (<code class="docutils literal notranslate"><span class="pre">doseq</span></code> 매개 변수를 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정해서) 사용하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>encoding</em>과 <em>errors</em> 매개 변수를 추가합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><em>max_num_fields</em> 매개 변수를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9.2에서 변경: </span>Added <em>separator</em> parameter with the default value of <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>. Python
versions earlier than Python 3.9.2 allowed using both <code class="docutils literal notranslate"><span class="pre">;</span></code> and <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> as
query parameter separator. This has been changed to allow only a single
separator key, with <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> as the default separator.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.parse_qsl">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">parse_qsl</code><span class="sig-paren">(</span><em class="sig-param">qs</em>, <em class="sig-param">keep_blank_values=False</em>, <em class="sig-param">strict_parsing=False</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='replace'</em>, <em class="sig-param">max_num_fields=None</em>, <em class="sig-param">separator='&amp;'</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.parse_qsl" title="정의 주소">¶</a></dt>
<dd><p>문자열 인자(<em class="mimetype">application/x-www-form-urlencoded</em> 유형의 데이터)로 제공된 쿼리 문자열을 구문 분석합니다. 데이터는 이름, 값 쌍의 리스트로 반환됩니다.</p>
<p>선택적 인자 <em>keep_blank_values</em>는 퍼센트 인코딩된 쿼리의 빈 값을 빈 문자열로 처리해야 하는지를 나타내는 플래그입니다. 참값은 빈 값을 빈 문자열로 유지해야 함을 나타냅니다. 기본 거짓 값은 빈 값이 무시되고 포함되지 않은 것처럼 처리됨을 나타냅니다.</p>
<p>선택적 인자 <em>strict_parsing</em>은 구문 분석 에러 시 수행할 작업을 나타내는 플래그입니다. 거짓(기본값)이면, 에러가 조용히 무시됩니다. 참이면, 에러는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 예외를 발생시킵니다.</p>
<p>선택적 <em>encoding</em>과 <em>errors</em> 매개 변수는 <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> 메서드에서 받아들이는 것처럼 퍼센트 인코딩된 시퀀스를 유니코드 문자로 디코딩하는 방법을 지정합니다.</p>
<p>선택적 인자 <em>max_num_fields</em>는 읽을 최대 필드 수입니다. 설정되면, <em>max_num_fields</em> 필드보다 많은 것을 읽을 때 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p>The optional argument <em>separator</em> is the symbol to use for separating the query arguments. It defaults to <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>.</p>
<p>이러한 쌍의 리스트를 쿼리 문자열로 변환하려면 <a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 함수를 사용하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>encoding</em>과 <em>errors</em> 매개 변수를 추가합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><em>max_num_fields</em> 매개 변수를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9.2에서 변경: </span>Added <em>separator</em> parameter with the default value of <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>. Python
versions earlier than Python 3.9.2 allowed using both <code class="docutils literal notranslate"><span class="pre">;</span></code> and <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> as
query parameter separator. This has been changed to allow only a single
separator key, with <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> as the default separator.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.urlunparse">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">urlunparse</code><span class="sig-paren">(</span><em class="sig-param">parts</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlunparse" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">urlparse()</span></code>에 의해 반환된 튜플에서 URL을 구성합니다. <em>parts</em> 인자는 임의의 6개 항목 이터러블일 수 있습니다. 구문 분석된 원래 URL에 불필요한 구분자가 있는 경우 (예를 들어 비어있는 쿼리가 있는 <code class="docutils literal notranslate"><span class="pre">?</span></code>; RFC는 이들이 동등하다고 말합니다) 약간 다르지만 동등한 URL이 만들어질 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.urlsplit">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">urlsplit</code><span class="sig-paren">(</span><em class="sig-param">urlstring</em>, <em class="sig-param">scheme=''</em>, <em class="sig-param">allow_fragments=True</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlsplit" title="정의 주소">¶</a></dt>
<dd><p>이것은 <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a>와 유사하지만, URL에서 파라미터를 분할하지 않습니다. URL의 <em>path</em> 부분의 각 세그먼트에 파라미터를 적용할 수 있는 최신 URL 문법(<span class="target" id="index-21"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2396.html"><strong>RFC 2396</strong></a>을 참조하십시오)이 필요하면 일반적으로 <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> 대신 사용해야 합니다. 경로 세그먼트와 파라미터를 분리하려면 별도의 함수가 필요합니다. 이 함수는 5개 항목 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a>을 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">addressing</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">network</span> <span class="n">location</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">fragment</span> <span class="n">identifier</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>반환 값은 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a>입니다, 항목은 인덱스나 이름 붙은 어트리뷰트로 액세스 할 수 있습니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 10%" />
<col style="width: 35%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>어트리뷰트</p></th>
<th class="head"><p>인덱스</p></th>
<th class="head"><p>값</p></th>
<th class="head"><p>존재하지 않을 때의 값</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">scheme</span></code></p></td>
<td><p>0</p></td>
<td><p>URL 스킴 지정자</p></td>
<td><p><em>scheme</em> 매개 변수</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code></p></td>
<td><p>1</p></td>
<td><p>네트워크 위치 부분</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></p></td>
<td><p>2</p></td>
<td><p>계층적 경로</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">query</span></code></p></td>
<td><p>3</p></td>
<td><p>쿼리 구성 요소</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code></p></td>
<td><p>4</p></td>
<td><p>프래그먼트 식별자</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">username</span></code></p></td>
<td></td>
<td><p>사용자 이름</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">password</span></code></p></td>
<td></td>
<td><p>비밀번호</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">hostname</span></code></p></td>
<td></td>
<td><p>호스트 이름 (소문자)</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code></p></td>
<td></td>
<td><p>존재하면, 정수로 표시되는 포트 번호</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>URL에 잘못된 포트가 지정된 경우 <code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code> 어트리뷰트를 읽으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 결과 객체에 대한 자세한 내용은 <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">구조화된 구문 분석 결과</span></a> 섹션을 참조하십시오.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> 어트리뷰트에서 대괄호(square brackets)가 일치하지 않으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p>(IDNA 인코딩에서 사용되는) NFKC 정규화에서 <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">#</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">:</span></code> 중 하나로 분해(decompose)되는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> 어트리뷰트의 문자는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다. 구문 분석하기 전에 URL이 분해(decompose)되면, 에러가 발생하지 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>범위를 벗어난 포트 번호는 이제 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환하는 대신 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>NFKC 정규화에서 netloc 구문 분석에 영향을 주는 문자는 이제 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킵니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.urlunsplit">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">urlunsplit</code><span class="sig-paren">(</span><em class="sig-param">parts</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlunsplit" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a>에 의해 반환된 튜플 요소를 완전한 URL 문자열로 결합합니다. <em>parts</em> 인자는 임의의 5개 항목 이터러블일 수 있습니다. 구문 분석된 원래 URL에 불필요한 구분자가 있는 경우 (예를 들어 비어있는 쿼리가 있는 ?; RFC는 이들이 동등하다고 말합니다) 약간 다르지만 동등한 URL이 만들어질 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.urljoin">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">urljoin</code><span class="sig-paren">(</span><em class="sig-param">base</em>, <em class="sig-param">url</em>, <em class="sig-param">allow_fragments=True</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urljoin" title="정의 주소">¶</a></dt>
<dd><p>&quot;기본 URL&quot;(<em>base</em>)을 다른 URL(<em>url</em>)과 결합하여 전체 (&quot;절대&quot;) URL을 구성합니다. 비형식적으로, 이것은 기본 URL의 구성 요소, 특히 주소 지정 체계, 네트워크 위치 및 경로(의 일부)를 사용하여 상대 URL에 누락된 구성 요소를 제공합니다. 예를 들면:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urljoin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urljoin</span><span class="p">(</span><span class="s1">&#39;http://www.cwi.nl/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">,</span> <span class="s1">&#39;FAQ.html&#39;</span><span class="p">)</span>
<span class="go">&#39;http://www.cwi.nl/%7Eguido/FAQ.html&#39;</span>
</pre></div>
</div>
<p><em>allow_fragments</em> 인자는 <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a>와 같은 의미와 기본값을 갖습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><em>url</em>이 절대 URL이면 (즉, <code class="docutils literal notranslate"><span class="pre">//</span></code>나 <code class="docutils literal notranslate"><span class="pre">scheme://</span></code>로 시작하면), <em>url</em>의 호스트명 및/또는 스킴이 결과에 나타납니다. 예를 들면:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">urljoin</span><span class="p">(</span><span class="s1">&#39;http://www.cwi.nl/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">&#39;//www.python.org/</span><span class="si">%7E</span><span class="s1">guido&#39;</span><span class="p">)</span>
<span class="go">&#39;http://www.python.org/%7Eguido&#39;</span>
</pre></div>
</div>
<p>이런 동작을 원하지 않으면, <em>url</em>을 <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a>과 <a class="reference internal" href="#urllib.parse.urlunsplit" title="urllib.parse.urlunsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlunsplit()</span></code></a>으로 사전 처리하여 가능한 <em>scheme</em>과 <em>netloc</em> 부분을 제거하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><span class="target" id="index-22"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3986.html"><strong>RFC 3986</strong></a>에 정의된 의미론과 일치하도록 동작이 갱신되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.urldefrag">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">urldefrag</code><span class="sig-paren">(</span><em class="sig-param">url</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urldefrag" title="정의 주소">¶</a></dt>
<dd><p><em>url</em>에 프래그먼트 식별자가 포함되면, 프래그먼트 식별자 없는 <em>url</em>의 수정된 버전과 프래그먼트 식별자를 별도의 문자열로 반환합니다. <em>url</em>에 프래그먼트 식별자가 없으면, 수정되지 않은 <em>url</em>과 빈 문자열을 반환합니다.</p>
<p>반환 값은 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a>입니다, 항목은 인덱스나 이름 붙은 어트리뷰트로 액세스 할 수 있습니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 10%" />
<col style="width: 35%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>어트리뷰트</p></th>
<th class="head"><p>인덱스</p></th>
<th class="head"><p>값</p></th>
<th class="head"><p>존재하지 않을 때의 값</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">url</span></code></p></td>
<td><p>0</p></td>
<td><p>프래그먼트 없는 URL</p></td>
<td><p>빈 문자열</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code></p></td>
<td><p>1</p></td>
<td><p>프래그먼트 식별자</p></td>
<td><p>빈 문자열</p></td>
</tr>
</tbody>
</table>
<p>결과 객체에 대한 자세한 정보는 섹션 <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">구조화된 구문 분석 결과</span></a>를 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>결과는 단순한 2-튜플이 아닌 구조화된 객체입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.unwrap">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">unwrap</code><span class="sig-paren">(</span><em class="sig-param">url</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.unwrap" title="정의 주소">¶</a></dt>
<dd><p>래핑 된 URL(즉, <code class="docutils literal notranslate"><span class="pre">&lt;URL:scheme://host/path&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;scheme://host/path&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">URL:scheme://host/path</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">scheme://host/path</span></code> 형식의 문자열)에서 URL을 추출합니다. <em>url</em>이 래핑 된 URL이 아니면, 변경 없이 반환됩니다.</p>
</dd></dl>

</div>
<div class="section" id="parsing-ascii-encoded-bytes">
<span id="id1"></span><h2>ASCII로 인코딩된 바이트열 구문 분석<a class="headerlink" href="#parsing-ascii-encoded-bytes" title="제목 주소">¶</a></h2>
<p>URL 구문 분석 함수는 원래 문자열에서만 작동하도록 설계되었습니다. 실제로는, 적절히 인용되고 인코딩된 URL을 ASCII 바이트 시퀀스로 조작할 수 있으면 유용합니다. 따라서, 이 모듈의 URL 구문 분석 함수는 모두 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체 외에 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>와 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 객체에서 작동합니다.</p>
<p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 데이터가 전달되면, 결과에는 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 데이터만 포함됩니다. <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>나 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 데이터가 전달되면, 결과에는 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 데이터만 포함됩니다.</p>
<p>단일 함수 호출에서 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 데이터를 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>나 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>와 혼합하려고 시도하면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생하는 반면, 비 ASCII 바이트 값을 전달하면 <a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a>가 트리거 됩니다.</p>
<p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>과 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 간에 결과 객체를 쉽게 변환 할 수 있도록, URL 구문 분석 함수의 모든 반환 값은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> 메서드(결과에 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 데이터가 포함될 때)나 <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> 메서드(결과에 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 데이터가 포함될 때)를 제공합니다. 이러한 메서드의 서명은 해당 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>와 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 메서드의 서명과 일치합니다 (기본 인코딩이 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>가 아니라 <code class="docutils literal notranslate"><span class="pre">'ascii'</span></code>라는 점은 예외입니다). 각각은 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 데이터(<code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> 메서드의 경우)나 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 데이터(<code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> 메서드의 경우)를 포함하는 해당 형의 값을 생성합니다.</p>
<p>ASCII가 아닌 데이터를 포함할 수 있는 잘못 인용된 URL에서 작동할 가능성이 있는 응용 프로그램은 URL 구문 분석 메서드를 호출하기 전에 바이트열에서 문자로 자체 디코딩을 수행할 필요가 있습니다.</p>
<p>이 섹션에서 설명하는 동작은 URL 구문 분석 함수에만 적용됩니다. URL 인용 함수는 개별 URL 인용 함수의 설명서에 기술된 대로 바이트 시퀀스를 생성하거나 소비할 때 자체 규칙을 사용합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>URL 구문 분석 함수는 이제 ASCII 인코딩된 바이트 시퀀스를 받아들입니다.</p>
</div>
</div>
<div class="section" id="structured-parse-results">
<span id="urlparse-result-object"></span><h2>구조화된 구문 분석 결과<a class="headerlink" href="#structured-parse-results" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a>, <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> 및 <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> 함수의 결과 객체는 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 형의 서브 클래스입니다. 이 서브 클래스는 해당 함수에 대한 설명서에 나열된 어트리뷰트, 이전 섹션에서 설명한 인코딩과 디코딩 지원 및 추가 메서드를 추가합니다:</p>
<dl class="method">
<dt id="urllib.parse.urllib.parse.SplitResult.geturl">
<code class="sig-prename descclassname">urllib.parse.SplitResult.</code><code class="sig-name descname">geturl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urllib.parse.SplitResult.geturl" title="정의 주소">¶</a></dt>
<dd><p>원래 URL의 재결합된 버전을 문자열로 반환합니다. 스킴이 소문자로 정규화되고 빈 구성 요소가 삭제될 수 있다는 점에서 원래 URL과 다를 수 있습니다. 특히, 빈 파라미터, 쿼리 및 프래그먼트 식별자가 제거됩니다.</p>
<p><a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> 결과의 경우, 빈 프래그먼트 식별자만 제거됩니다. <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a>과 <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> 결과의 경우, 이 메서드가 반환한 URL에 대해 언급된 모든 변경 사항이 적용됩니다.</p>
<p>이 메서드의 결과는 원래 구문 분석 함수를 통해 다시 전달될 때 변경되지 않은 상태로 유지됩니다:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urlsplit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;HTTP://www.Python.org/doc/#&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">&#39;http://www.Python.org/doc/&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">r1</span><span class="o">.</span><span class="n">geturl</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">&#39;http://www.Python.org/doc/&#39;</span>
</pre></div>
</div>
</dd></dl>

<p>다음 클래스는 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 객체에서 작동할 때 구조화된 구문 분석 결과의 구현을 제공합니다:</p>
<dl class="class">
<dt id="urllib.parse.DefragResult">
<em class="property">class </em><code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">DefragResult</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">fragment</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.DefragResult" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 데이터를 포함하는 <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> 결과의 구상 클래스. <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> 메서드는 <a class="reference internal" href="#urllib.parse.DefragResultBytes" title="urllib.parse.DefragResultBytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">DefragResultBytes</span></code></a> 인스턴스를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.parse.ParseResult">
<em class="property">class </em><code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">ParseResult</code><span class="sig-paren">(</span><em class="sig-param">scheme</em>, <em class="sig-param">netloc</em>, <em class="sig-param">path</em>, <em class="sig-param">params</em>, <em class="sig-param">query</em>, <em class="sig-param">fragment</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.ParseResult" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 데이터를 포함하는 <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> 결과의 구상 클래스. <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> 메서드는 <a class="reference internal" href="#urllib.parse.ParseResultBytes" title="urllib.parse.ParseResultBytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParseResultBytes</span></code></a> 인스턴스를 반환합니다.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.parse.SplitResult">
<em class="property">class </em><code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">SplitResult</code><span class="sig-paren">(</span><em class="sig-param">scheme</em>, <em class="sig-param">netloc</em>, <em class="sig-param">path</em>, <em class="sig-param">query</em>, <em class="sig-param">fragment</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.SplitResult" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 데이터를 포함하는 <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> 결과의 구상 클래스. <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> 메서드는 <a class="reference internal" href="#urllib.parse.SplitResultBytes" title="urllib.parse.SplitResultBytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitResultBytes</span></code></a> 인스턴스를 반환합니다.</p>
</dd></dl>

<p>다음 클래스는 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>나 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 객체에서 작동할 때 구문 분석 결과의 구현을 제공합니다:</p>
<dl class="class">
<dt id="urllib.parse.DefragResultBytes">
<em class="property">class </em><code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">DefragResultBytes</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">fragment</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.DefragResultBytes" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 데이터를 포함하는 <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> 결과의 구상 클래스. <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> 메서드는 <a class="reference internal" href="#urllib.parse.DefragResult" title="urllib.parse.DefragResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">DefragResult</span></code></a> 인스턴스를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.parse.ParseResultBytes">
<em class="property">class </em><code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">ParseResultBytes</code><span class="sig-paren">(</span><em class="sig-param">scheme</em>, <em class="sig-param">netloc</em>, <em class="sig-param">path</em>, <em class="sig-param">params</em>, <em class="sig-param">query</em>, <em class="sig-param">fragment</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.ParseResultBytes" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 데이터를 포함하는 <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> 결과의 구상 클래스. <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> 메서드는 <a class="reference internal" href="#urllib.parse.ParseResult" title="urllib.parse.ParseResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParseResult</span></code></a> 인스턴스를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="urllib.parse.SplitResultBytes">
<em class="property">class </em><code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">SplitResultBytes</code><span class="sig-paren">(</span><em class="sig-param">scheme</em>, <em class="sig-param">netloc</em>, <em class="sig-param">path</em>, <em class="sig-param">query</em>, <em class="sig-param">fragment</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.SplitResultBytes" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 데이터를 포함하는 <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> 결과의 구상 클래스. <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> 메서드는 <a class="reference internal" href="#urllib.parse.SplitResult" title="urllib.parse.SplitResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitResult</span></code></a> 인스턴스를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="url-quoting">
<h2>URL 인용<a class="headerlink" href="#url-quoting" title="제목 주소">¶</a></h2>
<p>URL 인용(quoting) 함수는 특수 문자를 인용하고 비 ASCII 텍스트를 적절히 인코딩하여 프로그램 데이터를 취해서 URL 구성 요소로 안전하게 사용할 수 있도록 하는 데 중점을 둡니다. 또한 해당 작업이 위의 URL 구문 분석 함수로 처리되지 않는 경우 URL 구성 요소의 내용에서 원래 데이터를 다시 만들기 위해 이러한 작업을 뒤집는 것도 지원합니다.</p>
<dl class="function">
<dt id="urllib.parse.quote">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">quote</code><span class="sig-paren">(</span><em class="sig-param">string</em>, <em class="sig-param">safe='/'</em>, <em class="sig-param">encoding=None</em>, <em class="sig-param">errors=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.quote" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">%xx</span></code> 이스케이프를 사용하여 <em>string</em>의 특수 문자를 치환합니다. 글자, 숫자 및 문자 <code class="docutils literal notranslate"><span class="pre">'_.-~'</span></code>는 절대 인용되지 않습니다. 기본적으로, 이 함수는 URL의 경로 섹션을 인용하기 위한 것입니다. 선택적 <em>safe</em> 매개 변수는 인용해서는 안 되는 추가 ASCII 문자를 지정합니다 --- 기본값은 <code class="docutils literal notranslate"><span class="pre">'/'</span></code>입니다.</p>
<p><em>string</em>은 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>이나 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체일 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>URL 문자열 인용을 <span class="target" id="index-23"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2396.html"><strong>RFC 2396</strong></a>에서 <span class="target" id="index-24"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3986.html"><strong>RFC 3986</strong></a>으로 옮겼습니다. &quot;~&quot;는 이제 예약되지 않은 문자 집합에 포함됩니다.</p>
</div>
<p>선택적 <em>encoding</em>과 <em>errors</em> 매개 변수는 <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> 메서드에서 받아들이는 것처럼 비 ASCII 문자를 처리하는 방법을 지정합니다. <em>encoding</em>의 기본값은 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>입니다. <em>errors</em>의 기본값은 <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>로, 지원되지 않는 문자는 <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a>를 발생시킴을 의미합니다. <em>string</em>이 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>이면 <em>encoding</em>과 <em>errors</em>를 제공해서는 안 됩니다, 그렇지 않으면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">quote(string,</span> <span class="pre">safe,</span> <span class="pre">encoding,</span> <span class="pre">errors)</span></code>는 <code class="docutils literal notranslate"><span class="pre">quote_from_bytes(string.encode(encoding,</span> <span class="pre">errors),</span> <span class="pre">safe)</span></code>와 동등함에 유의하십시오.</p>
<p>예: <code class="docutils literal notranslate"><span class="pre">quote('/El</span> <span class="pre">Niño/')</span></code>는 <code class="docutils literal notranslate"><span class="pre">'/El%20Ni%C3%B1o/'</span></code>를 산출합니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.quote_plus">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">quote_plus</code><span class="sig-paren">(</span><em class="sig-param">string</em>, <em class="sig-param">safe=''</em>, <em class="sig-param">encoding=None</em>, <em class="sig-param">errors=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.quote_plus" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>와 유사하지만, URL로 이동하기 위한 쿼리 문자열을 만들 때 HTML 폼값을 인용하는 데 필요한 대로 스페이스를 더하기 부호로 치환하기도 합니다. <em>safe</em>에 포함되지 않으면 원래 문자열의 더하기 부호가 이스케이프 됩니다. 또한 <em>safe</em>의 기본값은 <code class="docutils literal notranslate"><span class="pre">'/'</span></code>가 아닙니다.</p>
<p>예: <code class="docutils literal notranslate"><span class="pre">quote_plus('/El</span> <span class="pre">Niño/')</span></code>는 <code class="docutils literal notranslate"><span class="pre">'%2FEl+Ni%C3%B1o%2F'</span></code>를 산출합니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.quote_from_bytes">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">quote_from_bytes</code><span class="sig-paren">(</span><em class="sig-param">bytes</em>, <em class="sig-param">safe='/'</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.quote_from_bytes" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>와 유사하지만, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 대신 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체를 받아들이고, 문자열을 바이트열로 인코딩하지 않습니다.</p>
<p>예: <code class="docutils literal notranslate"><span class="pre">quote_from_bytes(b'a&amp;\xef')</span></code>는 <code class="docutils literal notranslate"><span class="pre">'a%26%EF'</span></code>를 산출합니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.unquote">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">unquote</code><span class="sig-paren">(</span><em class="sig-param">string</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='replace'</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.unquote" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">%xx</span></code> 이스케이프를 동등한 단일 문자로 대체합니다. 선택적 <em>encoding</em>과 <em>errors</em> 매개 변수는 <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> 메서드에서 받아들이는 것처럼 퍼센트 인코딩된 시퀀스를 유니코드 문자로 디코딩하는 방법을 지정합니다.</p>
<p><em>string</em>은 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>이나 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체일 수 있습니다.</p>
<p><em>encoding</em>의 기본값은 <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>입니다. <em>errors</em>의 기본값은 <code class="docutils literal notranslate"><span class="pre">'replace'</span></code>로, 유효하지 않은 시퀀스는 자리 표시자 문자(placeholder character)로 대체됩니다.</p>
<p>예: <code class="docutils literal notranslate"><span class="pre">unquote('/El%20Ni%C3%B1o/')</span></code>는 <code class="docutils literal notranslate"><span class="pre">'/El</span> <span class="pre">Niño/'</span></code>를 산출합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span><em>string</em> 매개 변수는 바이트열과 문자열 객체를 지원합니다 (이전에는 문자열만 지원했습니다).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.unquote_plus">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">unquote_plus</code><span class="sig-paren">(</span><em class="sig-param">string</em>, <em class="sig-param">encoding='utf-8'</em>, <em class="sig-param">errors='replace'</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.unquote_plus" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#urllib.parse.unquote" title="urllib.parse.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">unquote()</span></code></a>와 유사하지만, HTML 폼값을 인용 해제할 때 요구되는 것처럼, 더하기 부호를 스페이스로 치환하기도 합니다.</p>
<p><em>string</em>은 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>이어야 합니다.</p>
<p>예: <code class="docutils literal notranslate"><span class="pre">unquote_plus('/El+Ni%C3%B1o/')</span></code>는 <code class="docutils literal notranslate"><span class="pre">'/El</span> <span class="pre">Niño/'</span></code>를 산출합니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.unquote_to_bytes">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">unquote_to_bytes</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.unquote_to_bytes" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">%xx</span></code> 이스케이프를 해당 단일 옥텟(octet)으로 대체하고, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체를 반환합니다.</p>
<p><em>string</em>은 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>이나 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체일 수 있습니다.</p>
<p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>이면, <em>string</em>의 이스케이프 되지 않은 비 ASCII 문자는 UTF-8 바이트열로 인코딩됩니다.</p>
<p>예: <code class="docutils literal notranslate"><span class="pre">unquote_to_bytes('a%26%EF')</span></code>는 <code class="docutils literal notranslate"><span class="pre">b'a&amp;\xef'</span></code>를 산출합니다.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.parse.urlencode">
<code class="sig-prename descclassname">urllib.parse.</code><code class="sig-name descname">urlencode</code><span class="sig-paren">(</span><em class="sig-param">query</em>, <em class="sig-param">doseq=False</em>, <em class="sig-param">safe=''</em>, <em class="sig-param">encoding=None</em>, <em class="sig-param">errors=None</em>, <em class="sig-param">quote_via=quote_plus</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlencode" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>이나 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체를 포함할 수 있는 매핑 객체나 두 요소 튜플의 시퀀스를 퍼센트 인코딩된 ASCII 텍스트 문자열로 변환합니다. 결과 문자열을 <a class="reference internal" href="urllib.request.html#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> 함수를 사용하여 POST 연산을 위한 <em>data</em>로 사용하려면, 바이트열로 인코딩해야 합니다, 그렇지 않으면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생합니다.</p>
<p>결과 문자열은 <code class="docutils literal notranslate"><span class="pre">'&amp;'</span></code> 문자로 구분된 일련의 <code class="docutils literal notranslate"><span class="pre">key=value</span></code> 쌍이고, 여기서 <em>key</em>와 <em>value</em>는 <em>quote_via</em> 함수를 사용하여 인용됩니다. 기본적으로, <a class="reference internal" href="#urllib.parse.quote_plus" title="urllib.parse.quote_plus"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote_plus()</span></code></a>가 값을 인용하는 데 사용되는데, 스페이스는 <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 문자로 인용되고 '/' 문자는 <code class="docutils literal notranslate"><span class="pre">%2F</span></code>로 인코딩되어 GET 요청 표준(<code class="docutils literal notranslate"><span class="pre">application/x-www-form-urlencoded</span></code>)을 따름을 뜻합니다. <em>quote_via</em>로 전달될 수 있는 대체 함수는 <a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>이며, 스페이스를 <code class="docutils literal notranslate"><span class="pre">%20</span></code>로 인코딩하고 '/' 문자를 인코딩하지 않습니다. 무엇을 인용할지를 최대한 제어하려면, <code class="docutils literal notranslate"><span class="pre">quote</span></code>를 사용하고 <em>safe</em>의 값을 지정하십시오.</p>
<p><em>query</em> 인자에 두 요소 튜플의 시퀀스가 사용될 때, 각 튜플의 첫 번째 요소는 키이고 두 번째 요소는 값입니다. 값 요소 자체는 시퀀스일 수 있으며, 이 경우 선택적 매개 변수 <em>doseq</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 평가되면, <code class="docutils literal notranslate"><span class="pre">'&amp;'</span></code>로 구분된 개별 <code class="docutils literal notranslate"><span class="pre">key=value</span></code> 쌍이 키에 대한 값 시퀀스의 각 요소에 대해 생성됩니다. 인코딩된 문자열의 파라미터 순서는 시퀀스의 파라미터 튜플 순서와 일치합니다.</p>
<p><em>safe</em>, <em>encoding</em> 및 <em>errors</em> 매개 변수는 <em>quote_via</em>로 전달됩니다 (<em>encoding</em>과 <em>errors</em> 매개 변수는 쿼리 요소가 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>일 때만 전달됩니다).</p>
<p>이 인코딩 프로세스를 뒤집기 위해, 쿼리 문자열을 파이썬 데이터 구조로 구문 분석하기 위해 이 모듈에서 <a class="reference internal" href="#urllib.parse.parse_qs" title="urllib.parse.parse_qs"><code class="xref py py-func docutils literal notranslate"><span class="pre">parse_qs()</span></code></a>와 <a class="reference internal" href="#urllib.parse.parse_qsl" title="urllib.parse.parse_qsl"><code class="xref py py-func docutils literal notranslate"><span class="pre">parse_qsl()</span></code></a>이 제공됩니다.</p>
<p><a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> 메서드를 사용하여 URL의 쿼리 문자열이나 POST 요청의 데이터를 생성하는 방법을 알아보려면 <a class="reference internal" href="urllib.request.html#urllib-examples"><span class="std std-ref">urllib 예제</span></a>를 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>query</em> 매개 변수는 바이트열과 문자열 객체를 지원합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가: </span><em>quote_via</em> 매개 변수.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-7"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3986.html"><strong>RFC 3986</strong></a> - Uniform Resource Identifiers</dt><dd><p>이것이 현재 표준입니다 (STD66). urllib.parse 모듈에 대한 모든 변경 사항은 이를 준수해야 합니다. 특정 편차가 관찰될 수 있는데, 이는 대부분 이전 버전과의 호환성과 주요 브라우저에서 일반적으로 관찰되는 사실상의 구문 분석 요구 사항을 위한 것입니다.</p>
</dd>
<dt><span class="target" id="index-8"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2732.html"><strong>RFC 2732</strong></a> - Format for Literal IPv6 Addresses in URL's.</dt><dd><p>IPv6 URL의 구문 분석 요구 사항을 지정합니다.</p>
</dd>
<dt><span class="target" id="index-9"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2396.html"><strong>RFC 2396</strong></a> - Uniform Resource Identifiers (URI): Generic Syntax</dt><dd><p>URN(Uniform Resource Names)과 URL(Uniform Resource Locator)에 대한 일반적인 문법 요구 사항을 설명하는 문서.</p>
</dd>
<dt><span class="target" id="index-10"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2368.html"><strong>RFC 2368</strong></a> - The mailto URL scheme.</dt><dd><p>mailto URL 스킴에 대한 구문 분석 요구 사항.</p>
</dd>
<dt><span class="target" id="index-11"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1808.html"><strong>RFC 1808</strong></a> - Relative Uniform Resource Locators</dt><dd><p>이 RFC는 경계 사례의 처리를 정의하는 꽤 많은 수의 &quot;비정상적인 예&quot;를 포함하여, 절대와 상대 URL을 결합하는 규칙을 포함합니다.</p>
</dd>
<dt><span class="target" id="index-12"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1738.html"><strong>RFC 1738</strong></a> - Uniform Resource Locators (URL)</dt><dd><p>절대 URL의 형식 문법과 의미를 지정합니다.</p>
</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code> --- URL을 구성 요소로 구문 분석</a><ul>
<li><a class="reference internal" href="#url-parsing">URL 구문 분석</a></li>
<li><a class="reference internal" href="#parsing-ascii-encoded-bytes">ASCII로 인코딩된 바이트열 구문 분석</a></li>
<li><a class="reference internal" href="#structured-parse-results">구조화된 구문 분석 결과</a></li>
<li><a class="reference internal" href="#url-quoting">URL 인용</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="urllib.request.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> --- URL을 열기 위한 확장 가능한 라이브러리</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="urllib.error.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.error</span></code> --- urllib.request에 의해 발생하는 예외 클래스</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="urllib.error.html" title="urllib.error --- urllib.request에 의해 발생하는 예외 클래스"
             >다음</a> |</li>
        <li class="right" >
          <a href="urllib.request.html" title="urllib.request --- URL을 열기 위한 확장 가능한 라이브러리"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2021, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2021, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>