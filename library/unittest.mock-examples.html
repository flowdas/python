
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>unittest.mock --- 시작하기 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="2to3 - 파이썬 2에서 파이썬 3으로 자동 코드 변환" href="2to3.html" />
    <link rel="prev" title="unittest.mock --- mock object library" href="unittest.mock.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/library/unittest.mock-examples.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="2to3.html" title="2to3 - 파이썬 2에서 파이썬 3으로 자동 코드 변환"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="unittest.mock.html" title="unittest.mock --- mock object library"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">개발 도구</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="unittest-mock-getting-started">
<h1><a class="reference internal" href="unittest.mock.html#module-unittest.mock" title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest.mock</span></code></a> --- 시작하기<a class="headerlink" href="#unittest-mock-getting-started" title="제목 주소">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>이 페이지는 <a class="reference external" href="https://github.com/kahee">KaHee, Yu</a> 님의 번역입니다.</p>
</div>
<div class="section" id="using-mock">
<span id="getting-started"></span><h2>Mock 사용하기<a class="headerlink" href="#using-mock" title="제목 주소">¶</a></h2>
<div class="section" id="mock-patching-methods">
<h3>Mock Patching 메서드<a class="headerlink" href="#mock-patching-methods" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="unittest.mock.html#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mock</span></code></a> 객체의 일반적인 사용은 다음과 같습니다.:</p>
<ul class="simple">
<li><p>Patching 메서드</p></li>
<li><p>객체에 대한 메서드 호출 기록</p></li>
</ul>
<p>객체의 메서드를 대체하여 시스템의 다른 부분에서 올바른 인수로 호출되는지 확인 할 수 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">real</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;method&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">)</span>
<span class="go">&lt;MagicMock name=&#39;method()&#39; id=&#39;...&#39;&gt;</span>
</pre></div>
</div>
<p>우선 mock (이 예제의 <code class="docutils literal notranslate"><span class="pre">real.method</span></code> )을 사용하면 메서드와 속성이 어떻게 사용되었는지에 대해 어써션 수 있습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>대부분의 예제에서 <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mock</span></code></a> 과 <a class="reference internal" href="unittest.mock.html#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal notranslate"><span class="pre">MagicMock</span></code></a> 클래스들은 서로 바꿔 사용할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">MagicMock</span></code> 은 좀 더 유능한 클래스이므로, 기본으로 사용할 수 있는 합리적인 클래스입니다.</p>
</div>
<p>Once the mock has been called its <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.called" title="unittest.mock.Mock.called"><code class="xref py py-attr docutils literal notranslate"><span class="pre">called</span></code></a> attribute is set to
<code class="docutils literal notranslate"><span class="pre">True</span></code>. More importantly we can use the <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.assert_called_with" title="unittest.mock.Mock.assert_called_with"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assert_called_with()</span></code></a> or
<a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.assert_called_once_with" title="unittest.mock.Mock.assert_called_once_with"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assert_called_once_with()</span></code></a> method to check that it was called with
the correct arguments.</p>
<p>이 예제는 <code class="docutils literal notranslate"><span class="pre">ProductionClass().method</span></code> 를 호출하면, <code class="docutils literal notranslate"><span class="pre">something</span></code> 메서드를 호출하는지 테스트합니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ProductionClass</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">something</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">something</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span> <span class="o">=</span> <span class="n">ProductionClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span><span class="o">.</span><span class="n">something</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span><span class="o">.</span><span class="n">something</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="mock-for-method-calls-on-an-object">
<h3>객체에 대한 메서드 호출 Mock 하기<a class="headerlink" href="#mock-for-method-calls-on-an-object" title="제목 주소">¶</a></h3>
<p>지난 예제에서 우리는 객체에 대한 메서드를 직접 패치하여 올바르게 호출되었는지 확인했습니다. 또 다른 일반적인 사용 사례는 메서드 (혹은 시스템 일부의 테스트)에 객체를 전달한 다음, 올바른 방법으로 사용되는지 확인하는 것입니다.</p>
<p>아래의 간단한 <code class="docutils literal notranslate"><span class="pre">ProductionClass</span></code> 는 <code class="docutils literal notranslate"><span class="pre">closer</span></code> 메서드를 가지고 있습니다. 이 객체와 함께 호출된 경우, <code class="docutils literal notranslate"><span class="pre">close</span></code> 를 호출합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ProductionClass</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">closer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">something</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">something</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>따라서 이를 테스트하기 위해선 <code class="docutils literal notranslate"><span class="pre">close</span></code> 메서드를 사용하여 객체를 전달하고 올바르게 호출되었는지 확인해야 합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">real</span> <span class="o">=</span> <span class="n">ProductionClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">real</span><span class="o">.</span><span class="n">closer</span><span class="p">(</span><span class="n">mock</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">close</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">()</span>
</pre></div>
</div>
<p>우리는 mock에 'close' 메서드를 제공하기 위해 어떠한 노력도 하지 않아도 됩니다. close에 접근하면, 해당 메서드가 생성됩니다. 따라서 'close'가 아직 호출되지 않았다면, 테스트에 접근하면 생성되지만, <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.assert_called_with" title="unittest.mock.Mock.assert_called_with"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assert_called_with()</span></code></a> 는 실패 예외를 발생시킵니다.</p>
</div>
<div class="section" id="mocking-classes">
<h3>Mocking 클래스<a class="headerlink" href="#mocking-classes" title="제목 주소">¶</a></h3>
<p>일반적인 사용 사례는 테스트 중인 코드에서 인스턴스화된 클래스를 mock으로 대체하는 것입니다. 클래스를 패치할 때, 그 클래스는 mock으로 대체됩니다. 인스턴스는 <em>클래스를 호출</em> 하여 생성됩니다. 즉, mock된 클래스의 반환 값을 보고 &quot;mock 인스턴스&quot; 에 접근한다는 것을 의미합니다.</p>
<p>아래 예제에서, <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 를 인스턴스화하고 메서드를 호출하는 <code class="docutils literal notranslate"><span class="pre">some_function</span></code> 함수가 있습니다. <a class="reference internal" href="unittest.mock.html#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch()</span></code></a> 를 호출하면, 클래스 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 가 mock으로 대체됩니다. <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 인스턴스는 mock을 호출한 결과로서 mock의 <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.return_value" title="unittest.mock.Mock.return_value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">return_value</span></code></a> 를 수정하여 구성됩니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">some_function</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">instance</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">Foo</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">instance</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;module.Foo&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">instance</span> <span class="o">=</span> <span class="n">mock</span><span class="o">.</span><span class="n">return_value</span>
<span class="gp">... </span>    <span class="n">instance</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s1">&#39;the result&#39;</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">some_function</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="s1">&#39;the result&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="naming-your-mocks">
<h3>mock 이름 짓기<a class="headerlink" href="#naming-your-mocks" title="제목 주소">¶</a></h3>
<p>mock 이름을 붙이는 것은 유용할 수 있습니다. 이름은 mock의 repr에 표시되며 테스트 실패 메시지에 mock이 표시될 때 도움이 될 수 있습니다. 또한, 이름은 mock의 속성이나 메서드에도 전달됩니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span>
<span class="go">&lt;MagicMock name=&#39;foo&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">method</span>
<span class="go">&lt;MagicMock name=&#39;foo.method&#39; id=&#39;...&#39;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="tracking-all-calls">
<h3>모든 호출 추적하기<a class="headerlink" href="#tracking-all-calls" title="제목 주소">¶</a></h3>
<p>종종 메서드에 대한 단일 호출 이상을 추적하려고 합니다. <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal notranslate"><span class="pre">mock_calls</span></code></a> 속성은 모든 mock의 자식 속성 (또는 그들의 자식 속성에) 대한 호출 기록합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>
<span class="go">&lt;MagicMock name=&#39;mock.method()&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">attribute</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">53</span><span class="p">)</span>
<span class="go">&lt;MagicMock name=&#39;mock.attribute.method()&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">mock_calls</span>
<span class="go">[call.method(), call.attribute.method(10, x=53)]</span>
</pre></div>
</div>
<p>만약 <code class="docutils literal notranslate"><span class="pre">mock_calls</span></code> 에 대해 어써션 할때, 예상치 못한 메서드가 호출된 경우, 그 어써션는 실패합니다. 이는 예상된 호출에 대한 확인뿐만 아니라, 올바른 순서로 추가적인 호출 없이 이루어졌는지 확인하기 때문에 유용합니다.:</p>
<p><code class="docutils literal notranslate"><span class="pre">mock_calls</span></code> 과 비교하기 위한 리스트를 구성하기 위해 <a class="reference internal" href="unittest.mock.html#unittest.mock.call" title="unittest.mock.call"><code class="xref py py-data docutils literal notranslate"><span class="pre">call</span></code></a> 객체를 사용합니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expected</span> <span class="o">=</span> <span class="p">[</span><span class="n">call</span><span class="o">.</span><span class="n">method</span><span class="p">(),</span> <span class="n">call</span><span class="o">.</span><span class="n">attribute</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">53</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">mock_calls</span> <span class="o">==</span> <span class="n">expected</span>
<span class="go">True</span>
</pre></div>
</div>
<p>그러나 mock을 반환하는 호출에 대한 매개 변수는 기록되지 않습니다. 따라서 조상을 만드는 데 사용된 매개 변수가 중요한 중첩 호출을 추적하는 것은 불가능합니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span><span class="n">important</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">deliver</span><span class="p">()</span>
<span class="go">&lt;Mock name=&#39;mock.factory().deliver()&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">mock_calls</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">call</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span><span class="n">important</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">deliver</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="setting-return-values-and-attributes">
<h3>반환 값과 속성 설정하기<a class="headerlink" href="#setting-return-values-and-attributes" title="제목 주소">¶</a></h3>
<p>mock 객체에서 반환 값을 설정하기는 쉽습니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>물론 mock 메서드에서도 같은 설정을 할 수 있습니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>반환 값은 생성자에서도 설정할 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>만약 mock에서 속성 설정이 필요한 경우, 바로 설정하시면 됩니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">x</span>
<span class="go">3</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mock.connection.cursor().execute(&quot;SELECT</span> <span class="pre">1&quot;)</span></code> 같은 예제처럼 때로는 좀 더 복잡한 상황을 목업(mock up) 하고 싶을 때가 있습니다. 만약 이 호출을 리스트로 반환하려면, 중첩 호출의 결과를 구성해야 합니다.</p>
<p><a class="reference internal" href="unittest.mock.html#unittest.mock.call" title="unittest.mock.call"><code class="xref py py-data docutils literal notranslate"><span class="pre">call</span></code></a> 를 사용하여 나중에 쉽게 어써션하기위해, &quot;연결된 호출&quot; 에서 호출 집합을 구성할 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cursor</span> <span class="o">=</span> <span class="n">mock</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">return_value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT 1&quot;</span><span class="p">)</span>
<span class="go">[&#39;foo&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expected</span> <span class="o">=</span> <span class="n">call</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT 1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">call_list</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">mock_calls</span>
<span class="go">[call.connection.cursor(), call.connection.cursor().execute(&#39;SELECT 1&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">mock_calls</span> <span class="o">==</span> <span class="n">expected</span>
<span class="go">True</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">.call_list()</span></code> 를 호출하면, 호출 객체가 연결된 호출을 나타내는 호출 리스트로 바뀝니다.</p>
</div>
<div class="section" id="raising-exceptions-with-mocks">
<h3>mock으로 예외 발생시키기<a class="headerlink" href="#raising-exceptions-with-mocks" title="제목 주소">¶</a></h3>
<p>유용한 속성은 <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.side_effect" title="unittest.mock.Mock.side_effect"><code class="xref py py-attr docutils literal notranslate"><span class="pre">side_effect</span></code></a> 입니다. 만약 클래스 또는 인스턴스 예외를 설정하면 mock을 호출 했을 때, 예외가 발생됩니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">side_effect</span><span class="o">=</span><span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Boom!&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">Exception</span>: <span class="n">Boom!</span>
</pre></div>
</div>
</div>
<div class="section" id="side-effect-functions-and-iterables">
<h3>부작용 함수와 이터러블<a class="headerlink" href="#side-effect-functions-and-iterables" title="제목 주소">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">side_effect</span></code> 역시 함수 혹은 이터러블로 설정할 수 있습니다. 이터러블로 <code class="docutils literal notranslate"><span class="pre">side_effect</span></code> 를 사용하는 사례는 mock이 여러 번 호출되는 곳이며, 호출마다 다른 값을 반환하기 원하는 경우입니다. <code class="docutils literal notranslate"><span class="pre">side_effect</span></code> 를 이터러블로 설정하면, mock을 호출 할 때마다 다음 값을 반환합니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">side_effect</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<p>mock이 호출되는 것에 따라 반환 값이 동적으로 바뀌는 것과 같은 고급 사용 사례의 경우, <code class="docutils literal notranslate"><span class="pre">side_effect</span></code> 는 함수가 될 수 있습니다. 이 함수는 mock과 같은 인자로 호출됩니다. 어떠한 함수 반환이든 간에 호출이 반환하는 것입니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">side_effect</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">vals</span><span class="p">[</span><span class="n">args</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">side_effect</span><span class="o">=</span><span class="n">side_effect</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</div>
<div class="section" id="creating-a-mock-from-an-existing-object">
<h3>기존 객체에서 mock 생성하기<a class="headerlink" href="#creating-a-mock-from-an-existing-object" title="제목 주소">¶</a></h3>
<p>과도한 mocking 사용의 한 가지 문제점은 실제 코드가 아닌 mock으로 구현된 테스트를 결합한다는 것입니다. <code class="docutils literal notranslate"><span class="pre">some_method</span></code> 를 구현하는 클래스가 있다고 가정해 봅시다. <em>또한</em> 이 객체의 mock이 제공하는 <code class="docutils literal notranslate"><span class="pre">some_method</span></code> 를  다른 클래스 테스트에서도 제공합니다.나중에 첫 번째 클래스를 리팩토링하여 <code class="docutils literal notranslate"><span class="pre">some_method</span></code> 가 없어진 경우, 코드가 깨졌음에도 불구하고 테스트가 계속 통과될 것입니다.</p>
<p><a class="reference internal" href="unittest.mock.html#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mock</span></code></a> 은 <em>spec</em> 키워드 인자를 사용하여 mock 객체를 정의할 수 있게 합니다. 정의된 mock 객체에 존재하지 않는 메서드 / 속성에 접근하면, 속성 오류가 즉시 발생합니다. 만약 정의을 변경하면, 해당 클래스를 사용하는 테스트는 해당 테스트에서 클래스를 인스턴스화하지 않고 즉시 실패합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="n">SomeClass</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">old_method</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">object has no attribute &#39;old_method&#39;</span>
</pre></div>
</div>
<p>정의를 사용하면 일부 매개 변수가 위치 인자 또는 이름있는 인자로 전달되었는지에 대한 여부와 관계없이 mock에 대한 호출을 좀 더 똑똑하게 일치시킬 수 있습니다.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">&lt;Mock name=&#39;mock()&#39; id=&#39;140161580456576&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>만약 좀 더 똑똑한 매칭을 mock 메서드 호출과 함께 사용하려면, <a class="reference internal" href="unittest.mock.html#auto-speccing"><span class="std std-ref">auto-speccing</span></a> 사용하면 됩니다.</p>
<p>만약 임의의 속성을 설정하는 것뿐만 아니라 설정하지 못하게 하는 더 강력한 규격을 원한다면, <em>spec</em> 대신 <em>spec_set</em> 을 사용하면 됩니다.</p>
</div>
</div>
<div class="section" id="patch-decorators">
<h2>데코레이터 패치하기<a class="headerlink" href="#patch-decorators" title="제목 주소">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="unittest.mock.html#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch()</span></code></a> 를 사용하면 룩업된 네임스페이스의 객체들을 패치하는 것이 중요합니다. 일반적으로 간단하지만, 빠른 안내 위해 <a class="reference internal" href="unittest.mock.html#where-to-patch"><span class="std std-ref">where to patch</span></a> 를 참고하세요.</p>
</div>
<p>테스트에서 공통으로 필요한 것은 클래스 속성 또는 모듈 속성을 패치하는 것입니다. 예를 들어, 모듈에 클래스를 내장하거나 패치하여 이것이 인스턴스화 되었는지 확인하는 테스트가 있습니다. 모듈과 클래스는 실제로 전역적이므로, 테스트가 끝난 후에는 패치를 풀어줘야 합니다. 그렇지 않은 경우, 패치가 다른 테스트에도 유지되어 문제를 판단하는데 어려질 수 있습니다.</p>
<p>mock은 3가지 편리한 데코레이터를 제공합니다.: <a class="reference internal" href="unittest.mock.html#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch()</span></code></a>, <a class="reference internal" href="unittest.mock.html#unittest.mock.patch.object" title="unittest.mock.patch.object"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch.object()</span></code></a> 그리고 <a class="reference internal" href="unittest.mock.html#unittest.mock.patch.dict" title="unittest.mock.patch.dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch.dict()</span></code></a> <code class="docutils literal notranslate"><span class="pre">patch</span></code> 는 <code class="docutils literal notranslate"><span class="pre">package.module.Class.attribute</span></code> 형식의 단일 문자열을 이용하여, 패치 할 속성을 지정합니다. 또한 선택적으로 대체하고 싶은 속성 (또는 클래스 또는 아무거나) 값을 가질 수 있습니다. 'patch.object'는 객체와 패치 하고 싶은 속성의 이름, 그리고 패치할 값을 지정할 수 있습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">patch.object</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">original</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="o">.</span><span class="n">attribute</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@patch</span><span class="o">.</span><span class="n">object</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;attribute&#39;</span><span class="p">,</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">attribute</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">SomeClass</span><span class="o">.</span><span class="n">attribute</span> <span class="o">==</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">attribute</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">SomeClass</span><span class="o">.</span><span class="n">attribute</span> <span class="o">==</span> <span class="n">original</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@patch</span><span class="p">(</span><span class="s1">&#39;package.module.attribute&#39;</span><span class="p">,</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">attribute</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
<span class="gp">... </span>    <span class="kn">from</span> <span class="nn">package.module</span> <span class="k">import</span> <span class="n">attribute</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">attribute</span> <span class="ow">is</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">attribute</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">()</span>
</pre></div>
</div>
<p>만약 모듈 (<a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 을 포함)을 패치하면, <a class="reference internal" href="unittest.mock.html#unittest.mock.patch.object" title="unittest.mock.patch.object"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch.object()</span></code></a> 대신 <a class="reference internal" href="unittest.mock.html#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch()</span></code></a> 를 사용하세요.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="n">sentinel</span><span class="o">.</span><span class="n">file_handle</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;builtins.open&#39;</span><span class="p">,</span> <span class="n">mock</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">handle</span> <span class="o">==</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">file_handle</span><span class="p">,</span> <span class="s2">&quot;incorrect file handle returned&quot;</span>
</pre></div>
</div>
<p>필요한 경우 <code class="docutils literal notranslate"><span class="pre">package.module</span></code> 형식으로 모듈 이름을 '점'으로 구분 할 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@patch</span><span class="p">(</span><span class="s1">&#39;package.module.ClassName.attribute&#39;</span><span class="p">,</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">attribute</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
<span class="gp">... </span>    <span class="kn">from</span> <span class="nn">package.module</span> <span class="k">import</span> <span class="n">ClassName</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">ClassName</span><span class="o">.</span><span class="n">attribute</span> <span class="o">==</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">attribute</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span><span class="p">()</span>
</pre></div>
</div>
<p>좋은 패턴은 실제로 테스트 메서드 자체를 데코레이트 하는 것입니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@patch</span><span class="o">.</span><span class="n">object</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;attribute&#39;</span><span class="p">,</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">attribute</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">test_something</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">attribute</span><span class="p">,</span> <span class="n">sentinel</span><span class="o">.</span><span class="n">attribute</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">original</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="o">.</span><span class="n">attribute</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyTest</span><span class="p">(</span><span class="s1">&#39;test_something&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">test_something</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">SomeClass</span><span class="o">.</span><span class="n">attribute</span> <span class="o">==</span> <span class="n">original</span>
</pre></div>
</div>
<p>Mock으로 패치 하고 싶다면, 하나의 인자 (혹은 두 개의 인자가 있는 <a class="reference internal" href="unittest.mock.html#unittest.mock.patch.object" title="unittest.mock.patch.object"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch.object()</span></code></a> )와 함께 <a class="reference internal" href="unittest.mock.html#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch()</span></code></a> 를 사용할 수 있습니다. mock은 생성되어 테스트 함수 / 메서드로 전달됩니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@patch</span><span class="o">.</span><span class="n">object</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;static_method&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">test_something</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mock_method</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">SomeClass</span><span class="o">.</span><span class="n">static_method</span><span class="p">()</span>
<span class="gp">... </span>        <span class="n">mock_method</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyTest</span><span class="p">(</span><span class="s1">&#39;test_something&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">test_something</span><span class="p">()</span>
</pre></div>
</div>
<p>아래와 같은 패턴을 사용하여 여러 개의 패치 데코레이터를 계속 쌓을 수 있습니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nd">@patch</span><span class="p">(</span><span class="s1">&#39;package.module.ClassName1&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nd">@patch</span><span class="p">(</span><span class="s1">&#39;package.module.ClassName2&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">test_something</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MockClass2</span><span class="p">,</span> <span class="n">MockClass1</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">assertIs</span><span class="p">(</span><span class="n">package</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">ClassName1</span><span class="p">,</span> <span class="n">MockClass1</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">assertIs</span><span class="p">(</span><span class="n">package</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">ClassName2</span><span class="p">,</span> <span class="n">MockClass2</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyTest</span><span class="p">(</span><span class="s1">&#39;test_something&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">test_something</span><span class="p">()</span>
</pre></div>
</div>
<p>패치 데코레이터를 중첩하여 사용할 때, mock은 데코레이터가 적용된 순서대로 (데코레이터가 적용되는 일반적인 <strong>파이썬</strong> 순서) 데코레이팅 된 함수에 전달됩니다. 즉, 위에서 아래로 적용되는 것을 의미합니다. 위의 예제에서 <code class="docutils literal notranslate"><span class="pre">test_module.ClassName2</span></code> 가 먼저 mock에 전달됩니다.</p>
<p>또한 범위 내에서 딕셔너리에 값을 설정하고, 테스트가 끝나면 딕셔너리를 원래 상태로 다시 되돌리는 <a class="reference internal" href="unittest.mock.html#unittest.mock.patch.dict" title="unittest.mock.patch.dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch.dict()</span></code></a> 도 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="s1">&#39;value&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">original</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;newkey&#39;</span><span class="p">:</span> <span class="s1">&#39;newvalue&#39;</span><span class="p">},</span> <span class="n">clear</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">foo</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;newkey&#39;</span><span class="p">:</span> <span class="s1">&#39;newvalue&#39;</span><span class="p">}</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">foo</span> <span class="o">==</span> <span class="n">original</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">patch</span></code>, <code class="docutils literal notranslate"><span class="pre">patch.object</span></code> 그리고 <code class="docutils literal notranslate"><span class="pre">patch.dict</span></code>는 모두 컨텍스트 관리자로 사용할 수 있습니다.</p>
<p>mock을 생성하기 위해 <a class="reference internal" href="unittest.mock.html#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch()</span></code></a> 를 사용하는 경우, with 문에서 &quot;as&quot; 형식 사용하여 mock에 대한 참조를 얻을 수 있습니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ProductionClass</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">object</span><span class="p">(</span><span class="n">ProductionClass</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_method</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">mock_method</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">... </span>    <span class="n">real</span> <span class="o">=</span> <span class="n">ProductionClass</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">real</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_method</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>다른 <code class="docutils literal notranslate"><span class="pre">patch</span></code> 로, <code class="docutils literal notranslate"><span class="pre">patch.object</span></code> 그리고 <code class="docutils literal notranslate"><span class="pre">patch.dict</span></code> 를 클래스 데코레이터로 사용할 수 있습니다. 이 방법을 이용하는 경우, 이름이 &quot;test&quot;로 시작하는 모든 메서드에 개별적으로 데코레이터를 적용하는 것과 같습니다.</p>
</div>
<div class="section" id="further-examples">
<span id="id1"></span><h2>추가 예제<a class="headerlink" href="#further-examples" title="제목 주소">¶</a></h2>
<p>조금 더 고급스러운 시나리오에 대한 몇 가지 예시가 있습니다.</p>
<div class="section" id="mocking-chained-calls">
<h3>연결 된 호출 Mocking<a class="headerlink" href="#mocking-chained-calls" title="제목 주소">¶</a></h3>
<p>연결된 호출은 <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.return_value" title="unittest.mock.Mock.return_value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">return_value</span></code></a> 속성을 이해하고 나면, mock이 좀 더 간단해집니다. mock을 처음 호출하거나, 호출되기 전 <code class="docutils literal notranslate"><span class="pre">return_value</span></code> 를 패치하면 새로운 <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mock</span></code></a> 이 생성됩니다.</p>
<p>즉, mock 된 객체 호출에서 반환된 객체가 <code class="docutils literal notranslate"><span class="pre">return_value</span></code> mock을 통해 어떻게 사용되었는지 확인할 수 있습니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&lt;Mock name=&#39;mock().foo()&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="n">foo</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>여기에서 연결된 호출에 대해 구성한 뒤, 어써션을 수행하는 간단한 일입니다. 물론 다른 대안은 처음부터 코드를 좀 더 테스트 가능한 방식으로 작성하는 것입니다.</p>
<p>따라서 우리는 이 코드와 비슷한 코드를 가지고 있다고 가정해 봅시다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Something</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">BackendProvider</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">get_endpoint</span><span class="p">(</span><span class="s1">&#39;foobar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">create_call</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">start_call</span><span class="p">()</span>
<span class="gp">... </span>        <span class="c1"># more code</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BackendProvider</span></code>의 테스트가 이미 잘 되었다고 가정하면, <code class="docutils literal notranslate"><span class="pre">method()</span></code> 를 테스트하는 방법은 무엇일까요? 특히 코드 섹션 <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">more</span> <span class="pre">code</span></code> 가 응답 객체를 올바른 방법으로 사용하는지 테스트하고 싶습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">Something</span></code> 인스턴스에 <code class="docutils literal notranslate"><span class="pre">backend</span></code> 속성을 몽키패치(Monkey Patch) 할 수 있는 인스턴스 속성으로부터 호출의 연결이 생성됩니다. 이러한 특별 케이스에서는 <code class="docutils literal notranslate"><span class="pre">start_call</span></code>에 대한 최종 호출의 반환 값에만 관심이 있기 때문에 많은 구성이 필요하지 않습니다. 반환하는 객체가 '파일형'이라고 가정하고, 응답 객체를 내장된 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 을 <code class="docutils literal notranslate"><span class="pre">spec</span></code> 로 사용하도록 할 것입니다.</p>
<p>이를 위해 mock 백엔드로서 mock 인스턴스를 생성하고 이를 위한 mock 응답을 생성합니다. 마지막 <code class="docutils literal notranslate"><span class="pre">start_call</span></code> 에 대한 응답을 반환 값으로 설정하기 위해선, 다음을 수행해야 합니다.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mock_backend</span><span class="o">.</span><span class="n">get_endpoint</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="n">create_call</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="n">start_call</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">mock_response</span>
</pre></div>
</div>
<p><a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.configure_mock" title="unittest.mock.Mock.configure_mock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">configure_mock()</span></code></a> 메서드를 사용하여 우리가 반환 값을 직접 설정하는 방식을 이용하여 좀 더 좋게 할 수 있습니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">something</span> <span class="o">=</span> <span class="n">Something</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_response</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="nb">open</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_backend</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;get_endpoint.return_value.create_call.return_value.start_call.return_value&#39;</span><span class="p">:</span> <span class="n">mock_response</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_backend</span><span class="o">.</span><span class="n">configure_mock</span><span class="p">(</span><span class="o">**</span><span class="n">config</span><span class="p">)</span>
</pre></div>
</div>
<p>이러한 &quot;mock backend&quot; 에서 몽키패치(Monkey Patch)하고 실제 호출을 만들 수 있습니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">something</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">mock_backend</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">something</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal notranslate"><span class="pre">mock_calls</span></code></a> 을 이용하여 연결된 호출을 단일 어서트로 확인 할 수 있습니다. 체인 된 호출은 한 줄의 코드에서 여러번 호출되기 때문에, <code class="docutils literal notranslate"><span class="pre">mock_calls</span></code> 에 여러 속성들이 있습니다. <a class="reference internal" href="unittest.mock.html#unittest.mock.call.call_list" title="unittest.mock.call.call_list"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call.call_list()</span></code></a> 를 이용해서, 호출 목록을 만들 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chained</span> <span class="o">=</span> <span class="n">call</span><span class="o">.</span><span class="n">get_endpoint</span><span class="p">(</span><span class="s1">&#39;foobar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">create_call</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">start_call</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">call_list</span> <span class="o">=</span> <span class="n">chained</span><span class="o">.</span><span class="n">call_list</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">mock_backend</span><span class="o">.</span><span class="n">mock_calls</span> <span class="o">==</span> <span class="n">call_list</span>
</pre></div>
</div>
</div>
<div class="section" id="partial-mocking">
<h3>부분 Mocking<a class="headerlink" href="#partial-mocking" title="제목 주소">¶</a></h3>
<p>일부 테스트에서 <a class="reference internal" href="datetime.html#datetime.date.today" title="datetime.date.today"><code class="xref py py-meth docutils literal notranslate"><span class="pre">datetime.date.today()</span></code></a> 호출을 대체하여 알려진 날짜를 반환하고 싶었지만, 테스트 중인 코드가 새 날짜 객체를 못 만들게 하고 싶지는 않았습니다. 아쉽게도, <a class="reference internal" href="datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.date</span></code></a> 는 C로 작성되었기 때문에, 정적 <code class="xref py py-meth docutils literal notranslate"><span class="pre">date.today()</span></code> 메서드를 몽키패치 할 수 없습니다.</p>
<p>mock을 사용하여 날짜 클래스를 효과적으로 랩핑하는 것과 관련된 간단한 방법을 찾았지만, 생성자 호출을 실제 클래스 (그리고 실제 인스턴스)로 전달했습니다.</p>
<p><a class="reference internal" href="unittest.mock.html#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch</span> <span class="pre">decorator</span></code></a> 는 테스트 중인 모듈에서 <code class="docutils literal notranslate"><span class="pre">date</span></code> 클래스를 대체하는 데 사용됩니다. 날짜 클래스 mock 에서 <code class="xref py py-attr docutils literal notranslate"><span class="pre">side_effect</span></code> 속성은 실제 날짜를 반환하는 람다 함수로 설정했습니다. 날짜 클래스 mock이 호출 될 때, 실제 날짜는 생성되고 <code class="docutils literal notranslate"><span class="pre">side_effect</span></code> 에 의해 반환됩니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">date</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;mymodule.date&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_date</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">mock_date</span><span class="o">.</span><span class="n">today</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">date</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">mock_date</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="n">date</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">()</span> <span class="o">==</span> <span class="n">date</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2009</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="n">date</span><span class="p">(</span><span class="mi">2009</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.date</span></code></a> 를 전역으로 패치하지 않고, <em>사용</em> 하려는 모듈에서 <code class="docutils literal notranslate"><span class="pre">date</span></code> 를 패치합니다. <a class="reference internal" href="unittest.mock.html#where-to-patch"><span class="std std-ref">where to patch</span></a> 를 참고하세요.</p>
<p><code class="docutils literal notranslate"><span class="pre">date.today()</span></code>가 호출 되면, 알려진 날짜가 반환되지만, <code class="docutils literal notranslate"><span class="pre">date(...)</span></code> 생성자는 여전히 정상 날짜를 호출합니다. 이것이 없다면 고전적인 안티 패턴 테스트인 테스트 중인 코드와 같은 알고리즘을 사용하여 예상 결과를 계산해야 한다는 것을 알 수 있습니다.</p>
<p>날짜 생성자에 대한 호출은 테스트에 유용할 수 있는 <code class="docutils literal notranslate"><span class="pre">mock_date</span></code> 속성 (<code class="docutils literal notranslate"><span class="pre">call_count</span></code> 그리고 친구들)에 기록됩니다.</p>
<p>mocking 날짜 또는 내장된 클래스를 다루는 다른 방법은, <a class="reference external" href="https://williambert.online/2011/07/how-to-unit-testing-in-django-with-mocking-and-patching/">이 블로그 엔트리</a> 를 참고하세요.</p>
</div>
<div class="section" id="mocking-a-generator-method">
<h3>제너레이터 메서드 Mocking<a class="headerlink" href="#mocking-a-generator-method" title="제목 주소">¶</a></h3>
<p>파이썬 제너레이터는 <a class="footnote-reference brackets" href="#id3" id="id2">1</a> 를 반복 할 때 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문을 사용하여 일련의 값들을 반환하는 함수 혹은 메서드 입니다.</p>
<p>제너레이터 메서드 / 함수는 제너레이터 객체를 반환하기 위해 호출됩니다. 제너레이터 객체는 반복되는 객체입니다. 이터레이션 메서드의 프로토콜은 <a class="reference internal" href="stdtypes.html#container.__iter__" title="container.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 입니다. 따라서 우리는 <a class="reference internal" href="unittest.mock.html#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal notranslate"><span class="pre">MagicMock</span></code></a> 을 이용하여 mock 할 수 있습니다.</p>
<p>다음은 &quot;iter&quot; 메서드가 제너레이터로 구현 된 예제 클래스 입니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
<span class="gp">... </span>            <span class="k">yield</span> <span class="n">i</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">iter</span><span class="p">())</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
<p>어떻게 이 클래스와 &quot;iter&quot; 메서드를 mock 할 수 있을까요?</p>
<p>이터레이션 (암시적으론 <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 호출)에서 반환된 값을 구성하기 위해선, <code class="docutils literal notranslate"><span class="pre">foo.iter()</span></code> 를 호출하여 반환된 객체를 구성해야 합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock_foo</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_foo</span><span class="o">.</span><span class="n">iter</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">mock_foo</span><span class="o">.</span><span class="n">iter</span><span class="p">())</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>제너레이터의 표현식과 좀 더 <a class="reference external" href="http://www.dabeaz.com/coroutines/index.html">고급스러운 사용법</a> 은 여기에서는 언급하지 않겠습니다. 제너레이터에 대한 매우 훌륭한 입문서와 발전 방법은: <a class="reference external" href="http://www.dabeaz.com/generators/">Generator Tricks for Systems Programmers</a> 를 참고하세요.</p>
</dd>
</dl>
</div>
<div class="section" id="applying-the-same-patch-to-every-test-method">
<h3>모든 테스트 메서드에 동일한 패치 적용하기<a class="headerlink" href="#applying-the-same-patch-to-every-test-method" title="제목 주소">¶</a></h3>
<p>여러 테스트 방법을 위해 다양한 패치를 원한다면, 모든 메서드에 패치 데코레이터를 적용하는 것이 좋습니다. 이것은 불필요한 반복처럼 느껴질 수도 있습니다. 파이썬 2.6 이상에서는 <a class="reference internal" href="unittest.mock.html#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch()</span></code></a> 를 (다양한 형태로) 클래스 데코레이터로 사용 할 수 있습니다. 이렇게 함으로써 클래스의 모든 테스트 메서드에 패치가 적용됩니다. 테스트 메서드는 메서드 이름이 <code class="docutils literal notranslate"><span class="pre">test</span></code> 로 시작하는 것으로 식별됩니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@patch</span><span class="p">(</span><span class="s1">&#39;mymodule.SomeClass&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">class</span> <span class="nc">MyTest</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">test_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MockSomeClass</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">assertIs</span><span class="p">(</span><span class="n">mymodule</span><span class="o">.</span><span class="n">SomeClass</span><span class="p">,</span> <span class="n">MockSomeClass</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">test_two</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MockSomeClass</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">assertIs</span><span class="p">(</span><span class="n">mymodule</span><span class="o">.</span><span class="n">SomeClass</span><span class="p">,</span> <span class="n">MockSomeClass</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">not_a_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s1">&#39;something&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyTest</span><span class="p">(</span><span class="s1">&#39;test_one&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">test_one</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyTest</span><span class="p">(</span><span class="s1">&#39;test_two&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">test_two</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyTest</span><span class="p">(</span><span class="s1">&#39;test_two&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">not_a_test</span><span class="p">()</span>
<span class="go">&#39;something&#39;</span>
</pre></div>
</div>
<p>패치를 관리하는 다른 방법은 <a class="reference internal" href="unittest.mock.html#start-and-stop"><span class="std std-ref">patch methods: start and stop</span></a> 을 사용하는 것입니다. 이를 통해 패치를 <code class="docutils literal notranslate"><span class="pre">setUp</span></code> 메서드와 <code class="docutils literal notranslate"><span class="pre">tearDown</span></code> 메서드로 이동 시킬 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyTest</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">patcher</span> <span class="o">=</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;mymodule.foo&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">mock_foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">patcher</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">test_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">assertIs</span><span class="p">(</span><span class="n">mymodule</span><span class="o">.</span><span class="n">foo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mock_foo</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">patcher</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyTest</span><span class="p">(</span><span class="s1">&#39;test_foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>이 방법을 사용하는 경우엔 반드시 <code class="docutils literal notranslate"><span class="pre">stop</span></code> 호출하여 패치를 &quot;실행 취소&quot; 시켜야 합니다. 이것은 setUp에서 예외가 발생하면 tearDown이 호출되지 않기 때문에, 생각보다 번거로울 수 있습니다. <a class="reference internal" href="unittest.html#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unittest.TestCase.addCleanup()</span></code></a> 을 사용하면 좀 더 쉬워집니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyTest</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">patcher</span> <span class="o">=</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;mymodule.foo&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">addCleanup</span><span class="p">(</span><span class="n">patcher</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">mock_foo</span> <span class="o">=</span> <span class="n">patcher</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">test_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">assertIs</span><span class="p">(</span><span class="n">mymodule</span><span class="o">.</span><span class="n">foo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mock_foo</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyTest</span><span class="p">(</span><span class="s1">&#39;test_foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="mocking-unbound-methods">
<h3>언 바운드 메서드 Mocking<a class="headerlink" href="#mocking-unbound-methods" title="제목 주소">¶</a></h3>
<p>저는 테스트를 작성하는 동안 <em>언 바운드 메서드</em> (인스턴스가 아닌 클래스에 메서드 패치)를 패치해야했습니다. 이 특정 메서드를 호출하는 객체가 무엇인지 어서트하고 싶었기 때문에, 첫번째 인자로 전달되어야 했습니다. 문제는 mock으로 이 메서드를 패치 할 수 없다는 것입니다. 왜냐하면 언 바운드 메서드를 mock 객체로 대체하면 인스턴스에서 가져올 때 바운드 메서드가 되지 않아서 자체적으로 전달되지 않기 때문입니다. 해결 방법은 언 바운드 메서드를 대신해서 실제 메서드를 패치하는 것입니다. <a class="reference internal" href="unittest.mock.html#unittest.mock.patch" title="unittest.mock.patch"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch()</span></code></a> 데코레이터는 실제 메서드를 만들어야 하는 mock 으로 메서드를 패치하는 것을 굉장히 간단하게 만들어 주었습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">autospec=True</span></code>를 패치 옵션으로 설정하면, <em>실제</em> 메서드 객체로 패치합니다. 이 함수 객체는 대체할 시그니처와 동일한 시그니처를 갖지만, 후드(hood) 부분은 mock에 위임합니다. 이전과 같은 방법으로 mock이 자동으로 생성됩니다. 클래스에서 언 바운드 메소드를 패치하기 위해, mock 된 함수는 인스턴스에서 가져온다면 바운드 메서드로 변환되는 의미입니다. 첫 번재 인자로 <code class="docutils literal notranslate"><span class="pre">self</span></code> 를 전달할 것이고, 이것은 제가 원했던 것입니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
<span class="gp">... </span>  <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">object</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">autospec</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_foo</span><span class="p">:</span>
<span class="gp">... </span>  <span class="n">mock_foo</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span>
<span class="gp">... </span>  <span class="n">foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="gp">... </span>  <span class="n">foo</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">&#39;foo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_foo</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</pre></div>
</div>
<p>만약 <code class="docutils literal notranslate"><span class="pre">autospec=True</span></code> 를 사용하지 않았다면, 언 바운드 메소드는 Mock 인스턴스로 대신 패치되고, <code class="docutils literal notranslate"><span class="pre">self</span></code> 는 호출되지 않습니다.</p>
</div>
<div class="section" id="checking-multiple-calls-with-mock">
<h3>mock 으로 여러 호출 확인하기<a class="headerlink" href="#checking-multiple-calls-with-mock" title="제목 주소">¶</a></h3>
<p>mock에는 mock 객체 사용 방법에 대한 어설션을 만들기 위한 좋은 API가 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">foo_bar</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">foo_bar</span><span class="p">(</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="n">spam</span><span class="o">=</span><span class="s1">&#39;eggs&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">foo_bar</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="n">spam</span><span class="o">=</span><span class="s1">&#39;eggs&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>mock 이 한 번만 호출 되었다면, <code class="xref py py-meth docutils literal notranslate"><span class="pre">assert_called_once_with()</span></code> 메소드를 사용할 수 있습니다. 이 메서드는 또한 <code class="xref py py-attr docutils literal notranslate"><span class="pre">call_count</span></code> 가 1이라고 어서트합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">foo_bar</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="n">spam</span><span class="o">=</span><span class="s1">&#39;eggs&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">foo_bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">foo_bar</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="n">spam</span><span class="o">=</span><span class="s1">&#39;eggs&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AssertionError</span>: <span class="n">Expected to be called once. Called 2 times.</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">assert_called_with</span></code> 과 <code class="docutils literal notranslate"><span class="pre">assert_called_once_with</span></code> 모두 <em>가장 최근</em> 에 호출 되었다는 것을 어써션합니다. mock을 여러번 호출 했을 경우, <em>모든</em> 호출에 대해 어써션 하고 싶다면 <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.call_args_list" title="unittest.mock.Mock.call_args_list"><code class="xref py py-attr docutils literal notranslate"><span class="pre">call_args_list</span></code></a>: 를 사용할 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">call_args_list</span>
<span class="go">[call(1, 2, 3), call(4, 5, 6), call()]</span>
</pre></div>
</div>
<p><a class="reference internal" href="unittest.mock.html#unittest.mock.call" title="unittest.mock.call"><code class="xref py py-data docutils literal notranslate"><span class="pre">call</span></code></a> 도우미는 이러한 호출에 대한 어써션을 쉽게 만듭니다. 예상되는 호출 목록을 작성하여 <code class="docutils literal notranslate"><span class="pre">call_args_list</span></code> 와 비교할 수 있습니다. <a href="#id1"><span class="problematic" id="id2">``</span></a>call_args_list``의 repr 과 매우 유사해 보입니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expected</span> <span class="o">=</span> <span class="p">[</span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">call</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">call</span><span class="p">()]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">call_args_list</span> <span class="o">==</span> <span class="n">expected</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="coping-with-mutable-arguments">
<h3>가변 인자 복사하기<a class="headerlink" href="#coping-with-mutable-arguments" title="제목 주소">¶</a></h3>
<p>이러한 상환은 드물지만, mock이 가변 인자로 호출 될 때 발생 할 수도 있습니다. <code class="docutils literal notranslate"><span class="pre">call_args</span></code> 그리고 <code class="docutils literal notranslate"><span class="pre">call_args_list</span></code> 는 인자에 대한 <em>참조</em>를 저장합니다. 인자가 테스트 중인 코드에 의해 변경되면, 더 이상 mock이 호출 되었을 때 값에 대한 어서션을 만들 수 없습니다.</p>
<p>이러한 문제를 보여주는 몇 가지 예제 코드가 있습니다. 'mymodule': 에 정의 된 다음 함수를 상상해보십시오.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">frob</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">grob</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="s2">&quot;First frob and then clear val&quot;</span>
    <span class="n">frob</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">val</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</pre></div>
</div>
<p>우리가 <code class="docutils literal notranslate"><span class="pre">grob</span></code> 호출을 테스트하려고 할 때, 올바른 인자를 가진 <code class="docutils literal notranslate"><span class="pre">frob</span></code>는 어떻게 되는지 보여줍니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;mymodule.frob&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_frob</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">val</span> <span class="o">=</span> <span class="p">{</span><span class="mi">6</span><span class="p">}</span>
<span class="gp">... </span>    <span class="n">mymodule</span><span class="o">.</span><span class="n">grob</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">val</span>
<span class="go">set()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_frob</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">({</span><span class="mi">6</span><span class="p">})</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AssertionError</span>: <span class="n">Expected: (({6},), {})</span>
<span class="go">Called with: ((set(),), {})</span>
</pre></div>
</div>
<p>하나의 가능성은 우리가 전달한 어서션을 mock이 복사하는 것입니다. 만약 동등성을 위해 객체의 동일성에 의존하는 어서션을 수행하면 문제가 발생 할 수도 있습니다.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">side_effect</span></code> 기능을 사용하는 한 가지 해결책이 있습니다. 만약 mock 에 <code class="docutils literal notranslate"><span class="pre">side_effect</span></code> 함수를 제공하면, <code class="docutils literal notranslate"><span class="pre">side_effect</span></code> 는 mock 객체와 동일한 args로 호출됩니다. 이것은 인자를 복사하고 나중에 어서션을 위해 저장할 수 있는 기회를 줍니다. 이 예제에서 인자를 저장하기 위해 <em>또 다른</em> mock을 사용하고 있기 때문에, 어서션을 하기 위해 mock 메서드를 사용 할 수 있습니다. 다시 한 번 도우미 함수가 이것을 설정합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest.mock</span> <span class="k">import</span> <span class="n">Mock</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">DEFAULT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">copy_call_args</span><span class="p">(</span><span class="n">mock</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">new_mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">side_effect</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">args</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">new_mock</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">DEFAULT</span>
<span class="gp">... </span>    <span class="n">mock</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="n">side_effect</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">new_mock</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;mymodule.frob&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_frob</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">new_mock</span> <span class="o">=</span> <span class="n">copy_call_args</span><span class="p">(</span><span class="n">mock_frob</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">val</span> <span class="o">=</span> <span class="p">{</span><span class="mi">6</span><span class="p">}</span>
<span class="gp">... </span>    <span class="n">mymodule</span><span class="o">.</span><span class="n">grob</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_mock</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">({</span><span class="mi">6</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_mock</span><span class="o">.</span><span class="n">call_args</span>
<span class="go">call({6})</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">copy_call_args</span></code> mock이 호출 될 때 호출됩니다. 이것은 우리가 어서션할 새로운 mock을 반환합니다. <code class="docutils literal notranslate"><span class="pre">side_effect</span></code> 함수는 args 의 사본을 만들고 <a href="#id1"><span class="problematic" id="id2">``</span></a>new_mock``을 사본으로 호출합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>mock을 한 번 사용하게 되면, 인자가 호출 되는 시점에서 인자를 확인하는 더 쉬운 방법이 있습니다. <a href="#id1"><span class="problematic" id="id2">``</span></a>side_effect` 함수 내에서 간단히 검사를 할 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">side_effect</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="n">arg</span> <span class="o">==</span> <span class="p">{</span><span class="mi">6</span><span class="p">}</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">side_effect</span><span class="o">=</span><span class="n">side_effect</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">({</span><span class="mi">6</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="nb">set</span><span class="p">())</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AssertionError</span>
</pre></div>
</div>
</div>
<p>또 다른 방법은 인자를 (<a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a> 를 사용한) 복사하여 <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mock</span></code></a> 또는 <a class="reference internal" href="unittest.mock.html#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal notranslate"><span class="pre">MagicMock</span></code></a> 의 하위 클래스를 만드는 것입니다. 다음은 구현 예시입니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">CopyingMock</span><span class="p">(</span><span class="n">MagicMock</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">args</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">CopyingMock</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">CopyingMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arg</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="nb">set</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AssertionError</span>: <span class="n">Expected call: mock({1})</span>
<span class="go">Actual call: mock(set())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">foo</span>
<span class="go">&lt;CopyingMock name=&#39;mock.foo&#39; id=&#39;...&#39;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Mock</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">MagicMock</span></code> 를 서브 클래스로 만들 때, 동적으로 생성된 모든 속성이 있고, <code class="docutils literal notranslate"><span class="pre">return_value</span></code> 는 서브 클래스를 자동으로 사용합니다. <code class="docutils literal notranslate"><span class="pre">CopyingMock</span></code> 의 모든 자식들은 <code class="docutils literal notranslate"><span class="pre">CopyingMock</span></code> 을 가지고 있다는 의미힙니다.</p>
</div>
<div class="section" id="nesting-patches">
<h3>중첩 패치<a class="headerlink" href="#nesting-patches" title="제목 주소">¶</a></h3>
<p>컨텍스트 관리자로 패치를 사용하는 것은 좋지만, 여러 패치를 수행하면계속해서 오른쪽으로 들여쓰기가 되는 문장으로 중첩 될 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyTest</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">test_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;mymodule.Foo&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_foo</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;mymodule.Bar&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_bar</span><span class="p">:</span>
<span class="gp">... </span>                <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;mymodule.Spam&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_spam</span><span class="p">:</span>
<span class="gp">... </span>                    <span class="k">assert</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">Foo</span> <span class="ow">is</span> <span class="n">mock_foo</span>
<span class="gp">... </span>                    <span class="k">assert</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">Bar</span> <span class="ow">is</span> <span class="n">mock_bar</span>
<span class="gp">... </span>                    <span class="k">assert</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">Spam</span> <span class="ow">is</span> <span class="n">mock_spam</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">original</span> <span class="o">=</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">Foo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyTest</span><span class="p">(</span><span class="s1">&#39;test_foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">test_foo</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">Foo</span> <span class="ow">is</span> <span class="n">original</span>
</pre></div>
</div>
<p><cite>cleanup`</cite> 함수와 <a class="reference internal" href="unittest.mock.html#start-and-stop"><span class="std std-ref">patch methods: start and stop</span></a> 는 중첩 된 들여쓰기 없이 동일한 효과를 얻을 수 있습니다.간단한 도우미 메소드인 <code class="docutils literal notranslate"><span class="pre">create_patch</span></code> 가 패치하고 생성된 mock을 반환합니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyTest</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">create_patch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">patcher</span> <span class="o">=</span> <span class="n">patch</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">thing</span> <span class="o">=</span> <span class="n">patcher</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">addCleanup</span><span class="p">(</span><span class="n">patcher</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">thing</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">test_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">mock_foo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_patch</span><span class="p">(</span><span class="s1">&#39;mymodule.Foo&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">mock_bar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_patch</span><span class="p">(</span><span class="s1">&#39;mymodule.Bar&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">mock_spam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_patch</span><span class="p">(</span><span class="s1">&#39;mymodule.Spam&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>        <span class="k">assert</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">Foo</span> <span class="ow">is</span> <span class="n">mock_foo</span>
<span class="gp">... </span>        <span class="k">assert</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">Bar</span> <span class="ow">is</span> <span class="n">mock_bar</span>
<span class="gp">... </span>        <span class="k">assert</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">Spam</span> <span class="ow">is</span> <span class="n">mock_spam</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">original</span> <span class="o">=</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">Foo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyTest</span><span class="p">(</span><span class="s1">&#39;test_foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">mymodule</span><span class="o">.</span><span class="n">Foo</span> <span class="ow">is</span> <span class="n">original</span>
</pre></div>
</div>
</div>
<div class="section" id="mocking-a-dictionary-with-magicmock">
<h3>MagicMock으로 딕셔너리 mocking<a class="headerlink" href="#mocking-a-dictionary-with-magicmock" title="제목 주소">¶</a></h3>
<p>딕셔너리 또는 다른 컨테이너 객체를 mock을 원한다면, 딕셔너리처럼 작동하는 동안 모든 접근을 기록할 수 있습니다.</p>
<p>(딕셔너리 처럼 행동하는) <a class="reference internal" href="unittest.mock.html#unittest.mock.MagicMock" title="unittest.mock.MagicMock"><code class="xref py py-class docutils literal notranslate"><span class="pre">MagicMock</span></code></a> 와 <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.side_effect" title="unittest.mock.Mock.side_effect"><code class="xref py py-data docutils literal notranslate"><span class="pre">side_effect</span></code></a> 를 사용하여 우리가 제어하고 있는 실제 딕셔너리에 딕셔너리 접근권을 위임 할 수 있습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">MagicMock</span></code> 의  <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 와 <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a> 메서드가 호출 되면, (일반 딕셔너리 접근권) <code class="docutils literal notranslate"><span class="pre">side_effect</span></code> 가 키와 함께 호출됩니다. ( <code class="docutils literal notranslate"><span class="pre">__setitem__</span></code> 경우에는 값도) 우리는 반환되는 것 또한 제어 할 수 있습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">MagicMock</span></code> 가 사용 된 후에는 <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.call_args_list" title="unittest.mock.Mock.call_args_list"><code class="xref py py-data docutils literal notranslate"><span class="pre">call_args_list</span></code></a> 와 같은 속성을 사용하여 딕셔너리가 어떻게 사용되었는지 어서트 할 수 있습니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">getitem</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>     <span class="k">return</span> <span class="n">my_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">setitem</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">my_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="fm">__getitem__</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="n">getitem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="fm">__setitem__</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="n">setitem</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><code class="docutils literal notranslate"><span class="pre">MagicMock``을</span> <span class="pre">사용하는</span> <span class="pre">대신,</span> <span class="pre">``Mock</span></code> 을 사용하여 <em>오직</em> 특별히 원하는 magic 메서드만 제공 할 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="fm">__getitem__</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">side_effect</span><span class="o">=</span><span class="n">getitem</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="fm">__setitem__</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">side_effect</span><span class="o">=</span><span class="n">setitem</span><span class="p">)</span>
</pre></div>
</div>
<p><em>세 번째</em> 옵션은 <code class="docutils literal notranslate"><span class="pre">MagicMock</span></code> 을 사용하지만, <code class="docutils literal notranslate"><span class="pre">dict</span></code> 을 <em>spec</em> (또는 <em>spec_set</em>//) 인자로 전달하여 <code class="docutils literal notranslate"><span class="pre">MagicMock</span></code> 에서 만든 딕셔너리 magic 메서드만 사용 할 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">spec_set</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="fm">__getitem__</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="n">getitem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="fm">__setitem__</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="n">setitem</span>
</pre></div>
</div>
</div>
<p>이러한 부작용 기능을 사용하면,  <code class="docutils literal notranslate"><span class="pre">mock</span></code> 은 일반 딕셔너리처럼 작동하지만 접근들을 기록합니다. 존재하지 않는 키에 접근하려고 하면, <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> 가 발생합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">KeyError</span>: <span class="n">&#39;d&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;fish&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;eggs&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="go">&#39;fish&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span>
<span class="go">&#39;eggs&#39;</span>
</pre></div>
</div>
<p>사용 된 후에는 일반적인 mock 메서드와 속성을 사용하여 접근권에 대한 어써션을 만들 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="fm">__getitem__</span><span class="o">.</span><span class="n">call_args_list</span>
<span class="go">[call(&#39;a&#39;), call(&#39;c&#39;), call(&#39;d&#39;), call(&#39;b&#39;), call(&#39;d&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="fm">__setitem__</span><span class="o">.</span><span class="n">call_args_list</span>
<span class="go">[call(&#39;b&#39;, &#39;fish&#39;), call(&#39;d&#39;, &#39;eggs&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_dict</span>
<span class="go">{&#39;a&#39;: 1, &#39;c&#39;: 3, &#39;b&#39;: &#39;fish&#39;, &#39;d&#39;: &#39;eggs&#39;}</span>
</pre></div>
</div>
</div>
<div class="section" id="mock-subclasses-and-their-attributes">
<h3>Mock 하위 클래스와 그 속성들<a class="headerlink" href="#mock-subclasses-and-their-attributes" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="unittest.mock.html#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mock</span></code></a> 을 하위 클래스로 만들려고 하는데는 여러 이유가 있습니다. 한 가지 이유는 도우미 메서드를 추가하는 것일 수 있습니다. 다음은 바보같은 예입니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyMock</span><span class="p">(</span><span class="n">MagicMock</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">has_been_called</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">called</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mymock</span> <span class="o">=</span> <span class="n">MyMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mymock</span>
<span class="go">&lt;MyMock id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mymock</span><span class="o">.</span><span class="n">has_been_called</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mymock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mymock</span><span class="o">.</span><span class="n">has_been_called</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Mock</span></code> 인스턴스의 표준 동작은 속성과 반환 값 mock이 접근되는 mock 과 같은 타입이라는 것입니다. 이것은 <code class="docutils literal notranslate"><span class="pre">Mock</span></code> 속성이 <code class="docutils literal notranslate"><span class="pre">Mocks</span></code> 이고, <code class="docutils literal notranslate"><span class="pre">MagicMock</span></code> 속성이 <code class="docutils literal notranslate"><span class="pre">MagicMocks</span></code> 임을 보장합니다 <a class="footnote-reference brackets" href="#id5" id="id4">2</a>. 따라서 하위 클래스로 도우미 메서드를 추가하려면, 하위 클래스의 인스턴스에 대한 속성과 반환 값 mock 에 대해서 사용할 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mymock</span><span class="o">.</span><span class="n">foo</span>
<span class="go">&lt;MyMock name=&#39;mock.foo&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mymock</span><span class="o">.</span><span class="n">foo</span><span class="o">.</span><span class="n">has_been_called</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mymock</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
<span class="go">&lt;MyMock name=&#39;mock.foo()&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mymock</span><span class="o">.</span><span class="n">foo</span><span class="o">.</span><span class="n">has_been_called</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>때때로 이것은 불편합니다. 예를 들어, 한 유저가 &lt;<a class="reference external" href="https://code.google.com/archive/p/mock/issues/105">https://code.google.com/archive/p/mock/issues/105</a>&gt;`_ mock 을 하위 클래스로 만들어 <a class="reference external" href="https://twistedmatrix.com/documents/11.0.0/api/twisted.python.components.html">Twisted 어댑터를</a>. 만들었습니다. 이것을 속성에 적용하면 실제로 오류가 발생합니다.</p>
<p>(모든 속성에서) <code class="docutils literal notranslate"><span class="pre">Mock</span></code> 은 <code class="docutils literal notranslate"><span class="pre">_get_child_mock</span></code> 호출을 이용하여, 속성과 반환 값에 대한 &quot;하위-mock&quot; 을 만듭니다. 이 메서드를 오버라이드하는 것이므로, 하위 클래스가 속성에 사용되지 않게 할 수 있습니다. 사인은 임의의 키워드 인자(<code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>) 를 가지고, mock 생성자로 전달 된다는 것입니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Subclass</span><span class="p">(</span><span class="n">MagicMock</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_get_child_mock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">MagicMock</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mymock</span> <span class="o">=</span> <span class="n">Subclass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mymock</span><span class="o">.</span><span class="n">foo</span>
<span class="go">&lt;MagicMock name=&#39;mock.foo&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mymock</span><span class="p">,</span> <span class="n">Subclass</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mymock</span><span class="o">.</span><span class="n">foo</span><span class="p">,</span> <span class="n">Subclass</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mymock</span><span class="p">(),</span> <span class="n">Subclass</span><span class="p">)</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id4">2</a></span></dt>
<dd><p>이 규칙에 대한 예외는 호출 할 수 없는 mock입니다. 호출 할 수 없는 mock은 호출 가능한 메서드를 가질 수 없기 때문에, 속성은 호출 가능한 형태를 사용합니다.</p>
</dd>
</dl>
</div>
<div class="section" id="mocking-imports-with-patch-dict">
<h3>patch.dict 임포트 Mocking<a class="headerlink" href="#mocking-imports-with-patch-dict" title="제목 주소">¶</a></h3>
<p>mock이 어려울 수 있는 한 가지 경우는 함수 내에 로컬 임포트가 있는 경우입니다. 우리가 패치 할 수있는 모듈 네임스페이스의 객체를 사용하지 않기 때문에, mock 하기가 더 어렵습니다.</p>
<p>일반적으로 로컬 임포트는 피해야 합니다. 순환적 종속성을 종종 방지하기 위해 수행됩니다. 이 문제는 <em>일반적으로</em> 문제를 해결하거나 (코드를 리팩토링하는) 임포트를 지연시켜 &quot;최대 비용&quot;을 방지하는 훨씬 좋은 방법이 있습니다. 이는 무조건 로컬 임포트 (모듈을 클래스 또는 모듈 속성으로 저장하고, 처음 사용할때 만 임포트)를 하는 것 보다 더 나은 방법으로 해결할 수도 있습니다.</p>
<p>그 외에도 <code class="docutils literal notranslate"><span class="pre">mock</span></code> 를 사용하여 임포트 결과에 영향을 주는 방법도 있습니다. 임포팅은 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 딕셔너리로부터 <em>객체</em>를 패치합니다. 모듈이 될 필요 없는 <em>객체</em>를 가져오는 것을 주의합시다. 모듈을 처음으로 임포팅하면 모듈 객체가 <cite>sys.modules</cite> 에 저장되어, 보통 무언가를 임포트 할때 모듈을 되찾습니다. 그러나 그럴 필요는 없습니다.</p>
<p>즉 <a class="reference internal" href="unittest.mock.html#unittest.mock.patch.dict" title="unittest.mock.patch.dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">patch.dict()</span></code></a> 를 사용하여 <em>일시적으로</em> mock 을 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 배치합니다. 이 패치가 임포트 되어있는 동안, mock 을 가져옵니다. 패치가 완료되면 (데코레이팅 된 함수가 종료되면, with 문이 완전히 완료되거나 <code class="docutils literal notranslate"><span class="pre">patcher.stop()</span></code> 이 호출 됩니다.) 이전에 무엇이 있든 안전하게 복원 될 것입니다.</p>
<p>다음은 'fooble' 모듈을 목아웃하는 예제입니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="s1">&#39;sys.modules&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;fooble&#39;</span><span class="p">:</span> <span class="n">mock</span><span class="p">}):</span>
<span class="gp">... </span>   <span class="kn">import</span> <span class="nn">fooble</span>
<span class="gp">... </span>   <span class="n">fooble</span><span class="o">.</span><span class="n">blob</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">&lt;Mock name=&#39;mock.blob()&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="s1">&#39;fooble&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">blob</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">fooble</span></code> 이 성공한 것을 볼 수 있지만, 종료될 때에는 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 에 'fooble' 이 남아 있지 않습니다.</p>
<p>이것은 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">name</span></code> 형식에서도 작동합니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="s1">&#39;sys.modules&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;fooble&#39;</span><span class="p">:</span> <span class="n">mock</span><span class="p">}):</span>
<span class="gp">... </span>   <span class="kn">from</span> <span class="nn">fooble</span> <span class="k">import</span> <span class="n">blob</span>
<span class="gp">... </span>   <span class="n">blob</span><span class="o">.</span><span class="n">blip</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">&lt;Mock name=&#39;mock.blob.blip()&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">blob</span><span class="o">.</span><span class="n">blip</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">()</span>
</pre></div>
</div>
<p>약간 더 많은 작업을 통해 패키지 임포트를 mock 할 수 있습니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">modules</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;package&#39;</span><span class="p">:</span> <span class="n">mock</span><span class="p">,</span> <span class="s1">&#39;package.module&#39;</span><span class="p">:</span> <span class="n">mock</span><span class="o">.</span><span class="n">module</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="s1">&#39;sys.modules&#39;</span><span class="p">,</span> <span class="n">modules</span><span class="p">):</span>
<span class="gp">... </span>   <span class="kn">from</span> <span class="nn">package.module</span> <span class="k">import</span> <span class="n">fooble</span>
<span class="gp">... </span>   <span class="n">fooble</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">&lt;Mock name=&#39;mock.module.fooble()&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">fooble</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="tracking-order-of-calls-and-less-verbose-call-assertions">
<h3>호출 순서와 적은 추가 정보 호출 어써션 추적하기<a class="headerlink" href="#tracking-order-of-calls-and-less-verbose-call-assertions" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="unittest.mock.html#unittest.mock.Mock" title="unittest.mock.Mock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mock</span></code></a> 클래스는 <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.method_calls" title="unittest.mock.Mock.method_calls"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method_calls</span></code></a> 속성을 통해 mock 객체에서 메서드 호출 순서를 추적 할 수 있다. 별도의 mock 객체 사이의 호출 순서를 추적하는 것은 허용하지 않지만, <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal notranslate"><span class="pre">mock_calls</span></code></a> 를 사용하면 같은 효과를 얻을 수 있습니다.</p>
<p>왜냐하면 mock은 <code class="docutils literal notranslate"><span class="pre">mock_calls</span></code> 에 있는 자식 mock에 대한 호출을 추적하고, mock의 임의 속성에 접근하면 자식 mock 을 생성하기 때문에 부모 mock 과 별도로 mock 을 생성할 수 있습니다. 그 자식 mock 호출은 모든 부모의 <a href="#id1"><span class="problematic" id="id2">``</span></a>mock_calls` 에 순서대로 기록됩니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">manager</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_foo</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">foo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_bar</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">bar</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mock_foo</span><span class="o">.</span><span class="n">something</span><span class="p">()</span>
<span class="go">&lt;Mock name=&#39;mock.foo.something()&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock_bar</span><span class="o">.</span><span class="n">other</span><span class="o">.</span><span class="n">thing</span><span class="p">()</span>
<span class="go">&lt;Mock name=&#39;mock.bar.other.thing()&#39; id=&#39;...&#39;&gt;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">manager</span><span class="o">.</span><span class="n">mock_calls</span>
<span class="go">[call.foo.something(), call.bar.other.thing()]</span>
</pre></div>
</div>
<p>관리자 mock 의 <code class="docutils literal notranslate"><span class="pre">mock_calls</span></code> 속성과 비교하면서, 순서를 포함한 호출에 대해 어서트를 할 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expected_calls</span> <span class="o">=</span> <span class="p">[</span><span class="n">call</span><span class="o">.</span><span class="n">foo</span><span class="o">.</span><span class="n">something</span><span class="p">(),</span> <span class="n">call</span><span class="o">.</span><span class="n">bar</span><span class="o">.</span><span class="n">other</span><span class="o">.</span><span class="n">thing</span><span class="p">()]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">manager</span><span class="o">.</span><span class="n">mock_calls</span> <span class="o">==</span> <span class="n">expected_calls</span>
<span class="go">True</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">patch</span></code> 를 생성되고 있다면, mocks 을 <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.attach_mock" title="unittest.mock.Mock.attach_mock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">attach_mock()</span></code></a> 메서드를 이용하여 mock 관리자에 첨부 할 수 있습니다.호출이 첨부되면, 관리자의 <code class="docutils literal notranslate"><span class="pre">mock_calls</span></code> 에 기록됩니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">manager</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;mymodule.Class1&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">MockClass1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;mymodule.Class2&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">MockClass2</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">manager</span><span class="o">.</span><span class="n">attach_mock</span><span class="p">(</span><span class="n">MockClass1</span><span class="p">,</span> <span class="s1">&#39;MockClass1&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">manager</span><span class="o">.</span><span class="n">attach_mock</span><span class="p">(</span><span class="n">MockClass2</span><span class="p">,</span> <span class="s1">&#39;MockClass2&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">MockClass1</span><span class="p">()</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
<span class="gp">... </span>        <span class="n">MockClass2</span><span class="p">()</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">&lt;MagicMock name=&#39;mock.MockClass1().foo()&#39; id=&#39;...&#39;&gt;</span>
<span class="go">&lt;MagicMock name=&#39;mock.MockClass2().bar()&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">manager</span><span class="o">.</span><span class="n">mock_calls</span>
<span class="go">[call.MockClass1(),</span>
<span class="go"> call.MockClass1().foo(),</span>
<span class="go"> call.MockClass2(),</span>
<span class="go"> call.MockClass2().bar()]</span>
</pre></div>
</div>
<p>많은 호출이 생성되었지만, 특정 순서에만 관심있다면 <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.assert_has_calls" title="unittest.mock.Mock.assert_has_calls"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assert_has_calls()</span></code></a> 메서드를 사용하는 방법도 있습니다. 이것은 ( <a class="reference internal" href="unittest.mock.html#unittest.mock.call" title="unittest.mock.call"><code class="xref py py-data docutils literal notranslate"><span class="pre">call</span></code></a> 생성된) 호출 목록을 가지고 있습니다 해당 호출 순서가 <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.mock_calls" title="unittest.mock.Mock.mock_calls"><code class="xref py py-attr docutils literal notranslate"><span class="pre">mock_calls</span></code></a> 이면, 어서트가 성공합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">()</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span><span class="o">.</span><span class="n">baz</span><span class="p">()</span>
<span class="go">&lt;MagicMock name=&#39;mock().foo().bar().baz()&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">one</span><span class="p">()</span><span class="o">.</span><span class="n">two</span><span class="p">()</span><span class="o">.</span><span class="n">three</span><span class="p">()</span>
<span class="go">&lt;MagicMock name=&#39;mock.one().two().three()&#39; id=&#39;...&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calls</span> <span class="o">=</span> <span class="n">call</span><span class="o">.</span><span class="n">one</span><span class="p">()</span><span class="o">.</span><span class="n">two</span><span class="p">()</span><span class="o">.</span><span class="n">three</span><span class="p">()</span><span class="o">.</span><span class="n">call_list</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">assert_has_calls</span><span class="p">(</span><span class="n">calls</span><span class="p">)</span>
</pre></div>
</div>
<p>비록 체이닝 된 호출 <code class="docutils literal notranslate"><span class="pre">m.one().two().three()</span></code> 이 mock호출에 유일한 호출은 아니지만, 어서트는 계속 성공합니다.</p>
<p>때때로 mock은 여러번 호출 될 수 있으며, <em>일부</em> 호출에 대해서만 관심이 있습니다. 순서에 대해 신경쓰지 않을 수도 있습니다. 이 경우 <code class="docutils literal notranslate"><span class="pre">any_order=True</span></code> 를 <code class="docutils literal notranslate"><span class="pre">assert_has_calls</span></code> 에 전달 할 수 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">two</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">seven</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">fifty</span><span class="p">(</span><span class="s1">&#39;50&#39;</span><span class="p">)</span>
<span class="go">(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">calls</span> <span class="o">=</span> <span class="p">[</span><span class="n">call</span><span class="o">.</span><span class="n">fifty</span><span class="p">(</span><span class="s1">&#39;50&#39;</span><span class="p">),</span> <span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">call</span><span class="o">.</span><span class="n">seven</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">assert_has_calls</span><span class="p">(</span><span class="n">calls</span><span class="p">,</span> <span class="n">any_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="more-complex-argument-matching">
<h3>조금 더 복잡한 인자 매칭하기<a class="headerlink" href="#more-complex-argument-matching" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="unittest.mock.html#unittest.mock.ANY" title="unittest.mock.ANY"><code class="xref py py-data docutils literal notranslate"><span class="pre">ANY</span></code></a>와 같은 기본 개념을 사용하여, 우리는 mock에 인자로 사용되는 객체에 대해 좀 더 복잡한 어서션을 수행하는 matcher를 구현 할 수 있습니다.</p>
<p>어떤 객체가 mock 에 전달 되는 것을 예상한다고 가정해 봅시다. 이 객체는 기본적으로 객체 동일성 (사용자 정의 클래스에 대한 파이썬 기본값)을 바탕으로 동등을 비교합니다. <a class="reference internal" href="unittest.mock.html#unittest.mock.Mock.assert_called_with" title="unittest.mock.Mock.assert_called_with"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assert_called_with()</span></code></a> 사용하려면, 같은 객체를 전달해야 합니다. 이 객체의 일부만 관심이 있는 경우 이러한 속성을 확인하는 matcher를 만들 수 있습니다.</p>
<p>이 예제에서 <code class="docutils literal notranslate"><span class="pre">assert_called_with</span></code> 에 대한 '표준' 호출이 충분하지 않다는 것을 볼 수 있습니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="p">(</span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AssertionError</span>: <span class="n">Expected: call(&lt;__main__.Foo object at 0x...&gt;)</span>
<span class="go">Actual call: call(&lt;__main__.Foo object at 0x...&gt;)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Foo</span></code> 클래스의 비교 함수는 다음과 같습니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">a</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">b</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="kc">True</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>그리고 동등 연산을 위해 이와 같은 비교 함수를 사용할 수 있는 matcher 객체는 다음과 같습니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Matcher</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compare</span><span class="p">,</span> <span class="n">some_obj</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">compare</span> <span class="o">=</span> <span class="n">compare</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">some_obj</span> <span class="o">=</span> <span class="n">some_obj</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">some_obj</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>모든것을 하나로 모으기:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match_foo</span> <span class="o">=</span> <span class="n">Matcher</span><span class="p">(</span><span class="n">compare</span><span class="p">,</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="n">match_foo</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Matcher</span></code> 는 비교 함수와 비교할 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 객체로 인스턴스화 됩니다. <code class="docutils literal notranslate"><span class="pre">assert_called_with</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">Matcher</span></code> 동등 메서드가 호출되어 mock 을 호출한 객체와우리가 만든 matcher 객체와 비교합니다 만약 일치하면 <code class="docutils literal notranslate"><span class="pre">assert_called_with</span></code> 가 통과되고, 그렇지 않으면 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> 가 발생합니다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match_wrong</span> <span class="o">=</span> <span class="n">Matcher</span><span class="p">(</span><span class="n">compare</span><span class="p">,</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mock</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="n">match_wrong</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AssertionError</span>: <span class="n">Expected: ((&lt;Matcher object at 0x...&gt;,), {})</span>
<span class="go">Called with: ((&lt;Foo object at 0x...&gt;,), {})</span>
</pre></div>
</div>
<p>약간 수정하면 비교 함수가 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> 를 직접 발생시키고, 유용한 실패 메시지를 제공 할 수 있습니다.</p>
<p>파이썬 테스트 라이브러리 <a class="reference external" href="https://pyhamcrest.readthedocs.io/">PyHamcrest</a> 는 버전 1.5 부터 동등 matcher (<a class="reference external" href="https://pyhamcrest.readthedocs.io/en/release-1.8/integration/#module-hamcrest.library.integration.match_equality">hamcrest.library.integration.match_equality</a>) 의 형태로 비슷한 기능을 제공합니다.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest.mock</span></code> --- 시작하기</a><ul>
<li><a class="reference internal" href="#using-mock">Mock 사용하기</a><ul>
<li><a class="reference internal" href="#mock-patching-methods">Mock Patching 메서드</a></li>
<li><a class="reference internal" href="#mock-for-method-calls-on-an-object">객체에 대한 메서드 호출 Mock 하기</a></li>
<li><a class="reference internal" href="#mocking-classes">Mocking 클래스</a></li>
<li><a class="reference internal" href="#naming-your-mocks">mock 이름 짓기</a></li>
<li><a class="reference internal" href="#tracking-all-calls">모든 호출 추적하기</a></li>
<li><a class="reference internal" href="#setting-return-values-and-attributes">반환 값과 속성 설정하기</a></li>
<li><a class="reference internal" href="#raising-exceptions-with-mocks">mock으로 예외 발생시키기</a></li>
<li><a class="reference internal" href="#side-effect-functions-and-iterables">부작용 함수와 이터러블</a></li>
<li><a class="reference internal" href="#creating-a-mock-from-an-existing-object">기존 객체에서 mock 생성하기</a></li>
</ul>
</li>
<li><a class="reference internal" href="#patch-decorators">데코레이터 패치하기</a></li>
<li><a class="reference internal" href="#further-examples">추가 예제</a><ul>
<li><a class="reference internal" href="#mocking-chained-calls">연결 된 호출 Mocking</a></li>
<li><a class="reference internal" href="#partial-mocking">부분 Mocking</a></li>
<li><a class="reference internal" href="#mocking-a-generator-method">제너레이터 메서드 Mocking</a></li>
<li><a class="reference internal" href="#applying-the-same-patch-to-every-test-method">모든 테스트 메서드에 동일한 패치 적용하기</a></li>
<li><a class="reference internal" href="#mocking-unbound-methods">언 바운드 메서드 Mocking</a></li>
<li><a class="reference internal" href="#checking-multiple-calls-with-mock">mock 으로 여러 호출 확인하기</a></li>
<li><a class="reference internal" href="#coping-with-mutable-arguments">가변 인자 복사하기</a></li>
<li><a class="reference internal" href="#nesting-patches">중첩 패치</a></li>
<li><a class="reference internal" href="#mocking-a-dictionary-with-magicmock">MagicMock으로 딕셔너리 mocking</a></li>
<li><a class="reference internal" href="#mock-subclasses-and-their-attributes">Mock 하위 클래스와 그 속성들</a></li>
<li><a class="reference internal" href="#mocking-imports-with-patch-dict">patch.dict 임포트 Mocking</a></li>
<li><a class="reference internal" href="#tracking-order-of-calls-and-less-verbose-call-assertions">호출 순서와 적은 추가 정보 호출 어써션 추적하기</a></li>
<li><a class="reference internal" href="#more-complex-argument-matching">조금 더 복잡한 인자 매칭하기</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="unittest.mock.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest.mock</span></code> --- mock object library</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="2to3.html"
                        title="다음 장">2to3 - 파이썬 2에서 파이썬 3으로 자동 코드 변환</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="2to3.html" title="2to3 - 파이썬 2에서 파이썬 3으로 자동 코드 변환"
             >다음</a> |</li>
        <li class="right" >
          <a href="unittest.mock.html" title="unittest.mock --- mock object library"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >개발 도구</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.0.1 를 사용해서 만들었습니다.
    </div>

  </body>
</html>