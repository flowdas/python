
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ctypes --- 파이썬용 외부 함수 라이브러리 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="동시 실행" href="concurrency.html" />
    <link rel="prev" title="errno --- Standard errno system symbols" href="errno.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/library/ctypes.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="동시 실행"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="errno.html" title="errno --- Standard errno system symbols"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">일반 운영 체제 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-ctypes">
<span id="ctypes-a-foreign-function-library-for-python"></span><h1><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> --- 파이썬용 외부 함수 라이브러리<a class="headerlink" href="#module-ctypes" title="제목 주소">¶</a></h1>
<hr class="docutils" />
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 파이썬용 외부 함수(foreign function) 라이브러리입니다. C 호환 데이터형을 제공하며, DLL 또는 공유 라이브러리에 있는 함수를 호출할 수 있습니다. 이 라이브러리들을 순수 파이썬으로 감싸는 데 사용할 수 있습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">같은 목적으로 자주 사용되는 제삼자 라이브러리로 PyPy 팀에서 개발한
<a class="reference external" href="https://cffi.readthedocs.io/en/latest/">cffi</a>가 있습니다. CPython에서도 사용할 수 있고,
PyPy 에서는 대체로 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 에 비해 훨씬 높은 성능을 제공합니다.</p>
</div>
<div class="section" id="ctypes-tutorial">
<span id="ctypes-ctypes-tutorial"></span><h2>ctypes 자습서<a class="headerlink" href="#ctypes-tutorial" title="제목 주소">¶</a></h2>
<p>참고: 이 자습서의 코드 샘플은 <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>를 사용하여 실제로 작동하는지 확인합니다. 일부 코드 샘플은 리눅스, 윈도우 또는 맥 OS X에서 다르게 동작하므로, 주석에 doctest 지시문이 포함되어 있습니다.</p>
<p>참고: 일부 코드 샘플은 ctypes <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 형을 참조합니다. <code class="docutils literal notranslate"><span class="pre">sizeof(long)</span> <span class="pre">==</span> <span class="pre">sizeof(int)</span></code>인 플랫폼에서, 이는 <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a>의 별칭입니다. 따라서 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>를 기대할 때 <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a>가 인쇄되더라도 혼란스러워 하지 않아도됩니다 --- 이 것들은 실제로 같은 형입니다.</p>
<div class="section" id="loading-dynamic-link-libraries">
<span id="ctypes-loading-dynamic-link-libraries"></span><h3>동적 링크 라이브러리 로드하기<a class="headerlink" href="#loading-dynamic-link-libraries" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 동적 링크 라이브러리 로드를 위해 <em>cdll</em>을, 그리고 윈도우에서는 <em>windll</em> 및 <em>oledll</em> 객체를, 노출합니다.</p>
<p>이 객체의 어트리뷰트를 액세스하여 라이브러리를 로드합니다. <em>cdll</em>은 표준 <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 호출 규칙을 사용하는 함수를 내보내는 라이브러리를 로드하는 반면, <em>windll</em> 라이브러리는 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 호출 규칙을 사용하여 함수를 호출합니다. <em>oledll</em> 또한 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 호출 규칙을 사용하고, 함수가 윈도우 <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> 에러 코드를 반환한다고 가정합니다. 에러 코드는 함수 호출이 실패 할 때 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> 예외를 자동으로 발생시키는 데 사용됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>윈도우 에러는 <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a>를 일으켜왔습니다. 이제는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 별칭입니다.</p>
</div>
<p>다음은 윈도우 용 예제입니다. <code class="docutils literal notranslate"><span class="pre">msvcrt</span></code>는 대부분 표준 C 함수가 포함 된 MS 표준 C 라이브러리며, cdecl 호출 규칙을 사용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">)</span>  
<span class="go">&lt;WinDLL &#39;kernel32&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">)</span>      
<span class="go">&lt;CDLL &#39;msvcrt&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span>      
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>윈도우는 일반적인 <code class="docutils literal notranslate"><span class="pre">.dll</span></code> 파일 접미사를 자동으로 추가합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">cdll.msvcrt</span></code>를 통해 표준 C 라이브러리에 액세스하면 파이썬에서 사용되는 라이브러리와 호환되지 않는 오래된 라이브러리 버전이 사용됩니다. 가능하면 파이썬 자체의 기능을 사용하거나, <code class="docutils literal notranslate"><span class="pre">msvcrt</span></code> 모듈을 임포트해서 사용하십시오.</p>
</div>
<p>리눅스에서, 라이브러리를 로드하기위해서는 확장자를 <em>포함하는</em> 파일명을 지정해야하므로, 어트리뷰트 액세스를 사용하여 라이브러리를 로드 할 수 없습니다. dll 로더의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadLibrary()</span></code> 메서드를 사용하거나 CDLL의 생성자를 호출하여 인스턴스를 만들어 라이브러리를 로드해야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>  
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>       
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span>                           
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="accessing-functions-from-loaded-dlls">
<span id="ctypes-accessing-functions-from-loaded-dlls"></span><h3>로드된 dll에서 함수에 액세스하기<a class="headerlink" href="#accessing-functions-from-loaded-dlls" title="제목 주소">¶</a></h3>
<p>함수는 dll 객체의 어트리뷰트로 액세스됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">)</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">MyOwnFunction</span><span class="p">)</span>     
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">239</span>, in <span class="n">__getattr__</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function &#39;MyOwnFunction&#39; not found</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">kernel32</span></code> 와 <code class="docutils literal notranslate"><span class="pre">user32</span></code>와 같은 win32 시스템 dll은 종종 ANSI뿐만 아니라 UNICODE 버전의 함수를 내보냅니다. UNICODE 버전은 이름에 <code class="docutils literal notranslate"><span class="pre">W</span></code>가 추가 된 상태로 내보내지며, ANSI 버전은 이름에 <code class="docutils literal notranslate"><span class="pre">A</span></code>가 추가되어 내보내집니다. 지정된 모듈 이름의 <em>모듈 핸들</em>을 반환하는 win32 <code class="docutils literal notranslate"><span class="pre">GetModuleHandle</span></code> 함수는, 다음과 같은 C 프로토타입을 가지며, UNICODE가 정의되어 있는지에 따라 그 중 하나를 <code class="docutils literal notranslate"><span class="pre">GetModuleHandle</span></code>로 노출하기위해 매크로가 사용됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">ANSI</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleA</span><span class="p">(</span><span class="n">LPCSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
<span class="o">/*</span> <span class="n">UNICODE</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleW</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
</pre></div>
</div>
<p><em>windll</em>는 마술적으로 이 중 하나를 선택하려고 하지 않으므로, <code class="docutils literal notranslate"><span class="pre">GetModuleHandleA</span></code> 나 <code class="docutils literal notranslate"><span class="pre">GetModuleHandleW</span></code>를 명시적으로 지정하여 필요한 버전에 액세스해야하고, 그런 다음 각각 바이트열이나 문자열 객체로 호출해야 합니다.</p>
<p>때때로, dll은 <code class="docutils literal notranslate"><span class="pre">&quot;??2&#64;YAPAXI&#64;Z&quot;</span></code>와 같은 유효한 파이썬 식별자가 아닌 이름으로 함수를 내 보냅니다. 이 때는 <a class="reference internal" href="functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a>를 사용하여 함수를 조회해야합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">getattr</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">,</span> <span class="s2">&quot;??2@YAPAXI@Z&quot;</span><span class="p">)</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>윈도우에서, 일부 dll은 이름이 아니라 서수(ordinal)로 함수를 내 보냅니다. 이 함수는 서수로 dll 객체를 인덱싱하여 액세스 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">310</span>, in <span class="n">__getitem__</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function ordinal 0 not found</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="calling-functions">
<span id="ctypes-calling-functions"></span><h3>함수 호출하기<a class="headerlink" href="#calling-functions" title="제목 주소">¶</a></h3>
<p>다른 파이썬 콜러블처럼 이 함수를 호출 할 수 있습니다. 이 예제에서는 시스템 시간을 유닉스 에포크부터의 초로 반환하는 <code class="docutils literal notranslate"><span class="pre">time()</span></code> 함수와 win32 모듈 핸들을 반환하는 <code class="docutils literal notranslate"><span class="pre">GetModuleHandleA()</span></code> 함수를 사용합니다.</p>
<p>이 예는 NULL 포인터로 두 함수를 호출합니다 (<code class="docutils literal notranslate"><span class="pre">None</span></code>을 NULL 포인터로 사용해야합니다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>  
<span class="go">1150640792</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)))</span>  
<span class="go">0x1d000000</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">유효하지 않은 수의 인자가 전달 된 것을 감지하면, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 함수를 호출 한 후 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킬 수 있습니다. 이 동작에 의존하지 않아야합니다. 3.6.2에서 폐지되었으며, 3.7에서 제거될 것입니다.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 호출 규칙을 사용하여 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 함수를 호출하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생하고, 그 반대도 마찬가지입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with not enough arguments (4 bytes missing)</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">msvcrt</span><span class="o">.</span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;spam&quot;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with too many arguments (4 bytes in excess)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>올바른 호출 규칙을 찾으려면 C 헤더 파일이나 호출 할 함수에 대한 설명서를 살펴 봐야합니다.</p>
<p>윈도우에서, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 함수가 유효하지 않은 인자 값을 사용하여 호출 될 때, 일반적인 보호 오류로 인한 충돌을 방지하기 위해 win32 구조적 예외 처리를 사용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">OSError</span>: <span class="n">exception: access violation reading 0x00000020</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>그러나, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>로 파이썬을 충돌시킬 수 있는 방법이 많으므로, 어쨌든 주의해야합니다. <a class="reference internal" href="faulthandler.html#module-faulthandler" title="faulthandler: Dump the Python traceback."><code class="xref py py-mod docutils literal notranslate"><span class="pre">faulthandler</span></code></a> 모듈은 충돌을 디버깅하는 데 도움이 될 수 있습니다 (예를 들어, 오류가 있는 C 라이브러리 호출로 인한 세그먼트 오류).</p>
<p><code class="docutils literal notranslate"><span class="pre">None</span></code>, 정수, 바이트열 객체 및 (유니코드) 문자열은 이러한 함수 호출에서 매개 변수로 직접 사용할 수 있는 유일한 파이썬 자체의 객체입니다. <code class="docutils literal notranslate"><span class="pre">None</span></code>는 C <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 포인터로 전달되고, 바이트열 객체와 문자열은 데이터가 저장된 메모리 블록에 대한 포인터로 전달됩니다 (<code class="xref c c-type docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> 이나 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span> <span class="pre">*</span></code>). 파이썬 정수는 플랫폼의 기본 C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> 형으로 전달되며, 그 값은 C 형에 맞게 마스크됩니다.</p>
<p>다른 매개 변수 형으로 함수를 호출하기 전에, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 데이터 형에 대해 더 알아야합니다.</p>
</div>
<div class="section" id="fundamental-data-types">
<span id="ctypes-fundamental-data-types"></span><h3>기본 데이터형<a class="headerlink" href="#fundamental-data-types" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 많은 기본적인 C 호환 데이터형을 정의합니다.:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="46%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ctypes 형</th>
<th class="head">C 형</th>
<th class="head">파이썬 형</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_bool" title="ctypes.c_bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_bool</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">_Bool</span></code></td>
<td>bool (1)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code></td>
<td>1-문자 바이트열 객체</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code></td>
<td>1-문자 문자열</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_byte</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ubyte</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_short</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">short</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ushort</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">long</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulong</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longlong</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">__int64</span></code> 나 <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulonglong</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">__int64</span></code> 나 <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_size_t" title="ctypes.c_size_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_size_t</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ssize_t" title="ctypes.c_ssize_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ssize_t</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">ssize_t</span></code> 나 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_float" title="ctypes.c_float"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_float</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">float</span></code></td>
<td>float</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">double</span></code></td>
<td>float</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_longdouble" title="ctypes.c_longdouble"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longdouble</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">double</span></code></td>
<td>float</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> (NUL 종료됨)</td>
<td>바이트열 객체나 <code class="docutils literal notranslate"><span class="pre">None</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar_p</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span> <span class="pre">*</span></code> (NUL 종료됨)</td>
<td>문자열이나 <code class="docutils literal notranslate"><span class="pre">None</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code></td>
<td>int 나 <code class="docutils literal notranslate"><span class="pre">None</span></code></td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li>생성자는 논릿값을 가진 모든 객체를 받아들입니다.</li>
</ol>
<p>이 모든 형은 올바른 형과 값의 선택적 초기화자로 호출해서 만들어질 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c_int</span><span class="p">()</span>
<span class="go">c_long(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_wchar_p</span><span class="p">(</span><span class="s2">&quot;Hello, World&quot;</span><span class="p">)</span>
<span class="go">c_wchar_p(140018365411392)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_ushort</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">c_ushort(65533)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>이러한 형은 가변이므로, 값을 나중에 변경할 수도 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(42)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">-99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>, <a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar_p</span></code></a> 및 <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a> 포인터 형의 인스턴스에 새 값을 대입하면 포인터가 가리키는 <em>메모리 위치</em>가 변경됩니다, 메모리 블록의 <em>내용이 아닙니다</em> (당연히 아닙니다, 파이썬 바이트열 객체는 불변입니다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hello, World&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span> <span class="o">=</span> <span class="n">c_wchar_p</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>
<span class="go">c_wchar_p(139966785747344)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hello World</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;Hi, there&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>              <span class="c1"># 메모리 위치가 변경되었습니다</span>
<span class="go">c_wchar_p(139966783348904)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hi, there</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>                <span class="c1"># 원래 객체는 변경되지 않습니다</span>
<span class="go">Hello, World</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>그러나, 이 것들을 가변 메모리에 대한 포인터를 예상하는 함수에 전달하지 않도록 주의해야합니다. 가변 메모리 블록이 필요하다면, ctypes에는 다양한 방법으로 이를 만드는 <a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> 함수가 있습니다. 현재 메모리 블록 내용은 <code class="docutils literal notranslate"><span class="pre">raw</span></code> 프로퍼티를 사용하여 액세스(또는 변경)할 수 있습니다; NUL 종료 문자열로 액세스하려면 <code class="docutils literal notranslate"><span class="pre">value</span></code> 프로퍼티를 사용하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>            <span class="c1"># 3바이트 버퍼를 만들고, NUL 바이트로 초기화합니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">3 b&#39;\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>     <span class="c1"># NUL 종료 문자열을 포함하는 버퍼를 만듭니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">6 b&#39;Hello\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">b&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># 10바이트 버퍼를 만듭니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hello\x00\x00\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hi\x00lo\x00\x00\x00\x00\x00&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">NUL 종료 문자열로 액세스한다는 것은 메모리의 내용을 NULL 종료 문자열로 해석한다는 뜻입니다. 따라서,
<code class="docutils literal notranslate"><span class="pre">value</span></code> 프로퍼티는 문자열의 끝을 나타내는 NULL 을 포함하지 않는 바이트열을 줍니다. 반면, 임의의 메모리
블록으로 해석하는 <code class="docutils literal notranslate"><span class="pre">raw</span></code> 프로퍼티는 메모리에 담긴 모든 바이트를 제공하기 때문에, NUL을 포함하는 바이트열을
돌려줍니다.</p>
</div>
<p><a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> 함수는 이전 ctypes 배포에 있는 <code class="xref py py-func docutils literal notranslate"><span class="pre">c_string()</span></code> 함수뿐만 아니라 <code class="xref py py-func docutils literal notranslate"><span class="pre">c_buffer()</span></code> 함수(아직 별칭으로 사용할 수 있습니다)를 대체합니다. C 형 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code>의 유니코드 문자를 포함하는 가변 메모리 블록을 생성하려면 <a class="reference internal" href="#ctypes.create_unicode_buffer" title="ctypes.create_unicode_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_unicode_buffer()</span></code></a> 함수를 사용하십시오.</p>
</div>
<div class="section" id="calling-functions-continued">
<span id="ctypes-calling-functions-continued"></span><h3>함수 호출하기, 계속<a class="headerlink" href="#calling-functions-continued" title="제목 주소">¶</a></h3>
<p>printf는 <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>이 <em>아니라</em> 실제 표준 출력으로 인쇄하므로, 이 예제는 콘솔 프롬프트에서만 작동하고 <em>IDLE</em> 이나 <em>PythonWin</em>에서는 작동하지 않음에 유의하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, %S</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mf">42.5</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: exceptions.TypeError: Don&#39;t know how to convert parameter 2</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>이전에 언급했듯이, 정수, 문자열 및 바이트열 객체를 제외한 모든 파이썬 형은 필요한 C 데이터 형으로 변환 될 수 있도록 해당하는 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 형으로 래핑되어야합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;An int </span><span class="si">%d</span><span class="s2">, a double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="mf">3.14</span><span class="p">))</span>
<span class="go">An int 1234, a double 3.140000</span>
<span class="go">31</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="calling-functions-with-your-own-custom-data-types">
<span id="ctypes-calling-functions-with-own-custom-data-types"></span><h3>사용자 정의 데이터형을 사용하여 함수 호출하기<a class="headerlink" href="#calling-functions-with-your-own-custom-data-types" title="제목 주소">¶</a></h3>
<p>또한 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 인자 변환을 사용자 정의하여 사용자 고유 클래스의 인스턴스를 함수 인자로 사용할 수 있습니다. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 어트리뷰트를 찾고, 이를 함수 인자로 사용합니다. 물론 정수, 문자열 또는 바이트열 중 하나 여야합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bottles</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_as_parameter_</span> <span class="o">=</span> <span class="n">number</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bottles</span> <span class="o">=</span> <span class="n">Bottles</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bottles</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 인스턴스 변수에 인스턴스의 데이터를 저장하지 않으려면, <a class="reference internal" href="functions.html#property" title="property"><code class="xref py py-class docutils literal notranslate"><span class="pre">property</span></code></a>를 정의하여 요청시 어트리뷰트를 사용할 수있게 할 수 있습니다.</p>
</div>
<div class="section" id="specifying-the-required-argument-types-function-prototypes">
<span id="ctypes-specifying-required-argument-types"></span><h3>필수 인자 형 (함수 프로토타입) 지정하기<a class="headerlink" href="#specifying-the-required-argument-types-function-prototypes" title="제목 주소">¶</a></h3>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 어트리뷰트를 설정하여 DLL에서 내 보낸 함수의 필수 인자 형을 지정할 수 있습니다.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code>는 C 데이터 형의 시퀀스 여야합니다 (<code class="docutils literal notranslate"><span class="pre">printf</span></code> 함수는 포맷 문자열에 따라 개수와 형이 다른 매개 변수를 받아들이기 때문에, 여기서는 좋은 예가 아닐 수 있습니다. 반면에 이 기능을 실험하기에 매우 편리하기도 합니다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">c_double</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;String &#39;</span><span class="si">%s</span><span class="s2">&#39;, Int </span><span class="si">%d</span><span class="s2">, Double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">)</span>
<span class="go">String &#39;Hi&#39;, Int 10, Double 2.200000</span>
<span class="go">37</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>포맷을 지정하면 호환되지 않는 인자 형으로 부터 보호하고(C 함수의 프로토타입 처럼), 유효한 형으로 인자를 변환하려고 시도합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: exceptions.TypeError: wrong type</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">X 2 3.000000</span>
<span class="go">13</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>함수 호출에 전달하는 여러분 자신의 클래스를 정의했으면, <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 시퀀스에서 해당 클래스를 사용할 수 있도록, <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> 클래스 메서드를 구현해야합니다. <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> 클래스 메서드는 함수 호출에 전달 된 파이썬 객체를받습니다. 형 검사나 이 객체가 수용 가능한지 확인하는 데 필요한 모든 작업을 수행 한 다음, 객체 자체나 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 어트리뷰트나 무엇이건 이 경우에 C 함수 인자로 전달되길 원하는 것을 반환해야합니다. 다시 말하지만, 결과는 정수, 문자열, 바이트열, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 인스턴스 또는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 어트리뷰트가 있는 객체 여야 합니다.</p>
</div>
<div class="section" id="return-types">
<span id="ctypes-return-types"></span><h3>반환 형<a class="headerlink" href="#return-types" title="제목 주소">¶</a></h3>
<p>기본적으로 함수는 C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> 형을 반환한다고 가정합니다. 다른 반환 형은 함수 객체의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 어트리뷰트를 설정하여 지정할 수 있습니다.</p>
<p>다음은 더 고급 예제입니다. <code class="docutils literal notranslate"><span class="pre">strchr</span></code> 함수를 사용하는데, 문자열 포인터와 char을 기대하고, 문자열에 대한 포인터를 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">strchr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>  
<span class="go">8059983</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>    <span class="c1"># c_char_p is a pointer to a string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>
<span class="go">b&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)))</span>
<span class="go">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>위의 <code class="docutils literal notranslate"><span class="pre">ord(&quot;x&quot;)</span></code> 호출을 피하려면, <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 어트리뷰트를 설정할 수 있으며, 두 번째 인자는 한글자 파이썬 바이트열 객체에서 C char 로 변환됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;def&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: exceptions.TypeError: one character string expected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>외부 함수가 정수를 반환하면, 콜러블 파이썬 객체(예를 들어, 함수나 클래스)를 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 어트리뷰트로 사용할 수도 있습니다. 콜러블은 C 함수가 리턴하는 <em>정수</em>로 호출되며, 이 호출의 결과는 함수 호출의 결과로 사용됩니다. 이것은 에러 반환 값을 검사하고 자동으로 예외를 발생시키는 데 유용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span> <span class="o">=</span> <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">ValidHandle</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">value</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ValidHandle</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  
<span class="go">486539264</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="s2">&quot;something silly&quot;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n">ValidHandle</span>
<span class="gr">OSError</span>: <span class="n">[Errno 126] The specified module could not be found.</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">WinError</span></code>는 윈도우 <code class="docutils literal notranslate"><span class="pre">FormatMessage()</span></code> api를 호출하여 에러 코드의 문자열 표현을 가져오고, 예외를 <em>반환하는</em> 함수입니다. <code class="docutils literal notranslate"><span class="pre">WinError</span></code>는 선택적 에러 코드 매개 변수를 취합니다, 제공하지 않으면 <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a>를 호출하여 에러 코드를 가져옵니다.</p>
<p>훨씬 더 강력한 에러 검사 메커니즘을 <code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code> 어트리뷰트를 통해 사용할 수 있음에 유의하십시오; 자세한 내용은 레퍼런스 설명서를 참조하십시오.</p>
</div>
<div class="section" id="passing-pointers-or-passing-parameters-by-reference">
<span id="ctypes-passing-pointers"></span><h3>포인터 전달하기 (또는: 참조로 매개 변수 전달하기)<a class="headerlink" href="#passing-pointers-or-passing-parameters-by-reference" title="제목 주소">¶</a></h3>
<p>때때로 C api 함수는 매개 변수로 데이터 형을 가리키는 <em>포인터</em>를 기대합니다, 아마도 해당 위치에 쓰기 위해서, 또는 데이터가 너무 커서 값으로 전달할 수 없어서. 이것은 <em>참조로 매개 변수 전달하기</em>로 알려져 있기도 합니다.</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 매개 변수를 참조로 전달하는 데 사용되는 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> 함수를 내 보냅니다. 같은 효과를 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 함수로도 얻을 수 있습니다. 하지만 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a>는 실제 포인터 객체를 생성하기 때문에 더 많은 작업을 수행하므로, 파이썬 자체에서 포인터 객체가 필요하지 않으면 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a>를 사용하는 것이 더 빠릅니다.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">c_float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\000</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">0 0.0 b&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">sscanf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;1 3.14 Hello&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">byref</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">byref</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">s</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">1 3.1400001049 b&#39;Hello&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="structures-and-unions">
<span id="ctypes-structures-unions"></span><h3>구조체와 공용체<a class="headerlink" href="#structures-and-unions" title="제목 주소">¶</a></h3>
<p>구조체와 공용체는 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 모듈에 정의 된 <a class="reference internal" href="#ctypes.Structure" title="ctypes.Structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Structure</span></code></a> 와 <a class="reference internal" href="#ctypes.Union" title="ctypes.Union"><code class="xref py py-class docutils literal notranslate"><span class="pre">Union</span></code></a> 베이스 클래스에서 파생되어야합니다. 각 서브 클래스는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 어트리뷰트를 정의해야합니다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code>는 <em>필드 이름</em> 과 <em>필드 형</em>을 포함하는 <em>2-튜플</em>의 리스트여야합니다.</p>
<p>필드 형은 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>와 같은 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 형이거나 다른 파생된 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 형(구조체, 공용체, 배열, 포인터)이어야합니다.</p>
<p>다음은 <em>x</em> 및 <em>y</em>라는 두 개의 정수가 포함 된 POINT 구조체의 간단한 예제이며, 생성자에서 구조체를 초기화하는 방법도 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">10 20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">too many initializers</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>그러나, 훨씬 복잡한 구조를 만들 수 있습니다. 구조체는 필드 형으로 구조체를 사용하여 다른 구조체를 포함 할 수 있습니다.</p>
<p>다음은 <em>upperleft</em> 및 <em>lowerright</em>라는 두 개의 POINT를 포함하는 RECT 구조체입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;upperleft&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;lowerright&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>중첩된 구조체는 여러 가지 방법으로 생성자에서 초기화 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>필드 <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">디스크립터</span></a>는 <em>클래스</em>에서 조회할 수 있습니다. 유용한 정보를 제공 할 수 있기 때문에 디버깅에 유용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">POINT</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0, size=4&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">POINT</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=4, size=4&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition warning" id="ctypes-structureunion-alignment-byte-order">
<p class="first admonition-title">경고</p>
<p class="last"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 비트 필드가 있는 공용체나 구조체를 값으로 함수에 전달할 수 없습니다. 32비트 x86에서 작동할 수 있지만, 일반적으로 작동은 라이브러리가 보증하지 않습니다. 비트 필드가 있는 공용체와 구조체는 항상 포인터로 함수에 전달되어야합니다.</p>
</div>
</div>
<div class="section" id="structure-union-alignment-and-byte-order">
<h3>구조체/공용체 정렬과 바이트 순서<a class="headerlink" href="#structure-union-alignment-and-byte-order" title="제목 주소">¶</a></h3>
<p>기본적으로, Structure와 Union 필드는 C 컴파일러와 같은 방식으로 정렬됩니다. 서브 클래스 정의에서 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code> 클래스 어트리뷰트를 지정하면, 이 동작을 재정의할 수 있습니다. 이 값은 양의 정수로 설정해야하고, 필드의 최대 정렬을 지정합니다. 이것은 MSVC에서 <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">pack(n)</span></code>가 수행하는 것입니다.</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 구조체와 공용체에 기본(native) 바이트 순서를 사용합니다. 기본이 아닌 바이트 순서로 구조체를 만들려면 <a class="reference internal" href="#ctypes.BigEndianStructure" title="ctypes.BigEndianStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">BigEndianStructure</span></code></a>, <a class="reference internal" href="#ctypes.LittleEndianStructure" title="ctypes.LittleEndianStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">LittleEndianStructure</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BigEndianUnion</span></code> 및 <code class="xref py py-class docutils literal notranslate"><span class="pre">LittleEndianUnion</span></code> 베이스 클래스 중 하나를 사용할 수 있습니다. 이러한 클래스들은 포인터 필드를 포함 할 수 없습니다.</p>
</div>
<div class="section" id="bit-fields-in-structures-and-unions">
<span id="ctypes-bit-fields-in-structures-unions"></span><h3>구조체와 공용체의 비트 필드<a class="headerlink" href="#bit-fields-in-structures-and-unions" title="제목 주소">¶</a></h3>
<p>비트 필드를 포함하는 구조체와 공용체를 만드는 것이 가능합니다. 비트 필드는 정수 필드에만 가능하며, 비트 폭은 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 튜플의 세 번째 항목으로 지정됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Int</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;first_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;second_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">first_16</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0:0, bits=16&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">second_16</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0:16, bits=16&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="arrays">
<span id="ctypes-arrays"></span><h3>배열<a class="headerlink" href="#arrays" title="제목 주소">¶</a></h3>
<p>배열은 같은 형의 고정 된 수의 인스턴스를 포함하는 시퀀스입니다.</p>
<p>배열 형을 만드는 데 권장되는 방법은 데이터 형에 양의 정수를 곱하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">TenPointsArrayType</span> <span class="o">=</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">10</span>
</pre></div>
</div>
<p>다음은 다소 인공적인 데이터 형의 예입니다. 다른 항목들과 함께 4개의 POINT를 포함하는 구조체입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyStruct</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">c_float</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;point_array&quot;</span><span class="p">,</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">()</span><span class="o">.</span><span class="n">point_array</span><span class="p">))</span>
<span class="go">4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>인스턴스는 클래스를 호출하는 일반적인 방법으로 만들어집니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="n">TenPointsArrayType</span><span class="p">()</span>
<span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>위 코드는 배열 내용이 0으로 초기화되기 때문에, 일련의 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">0</span></code> 줄을 인쇄합니다.</p>
<p>올바른 형의 초기화자를 지정할 수도 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TenIntegers</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">TenIntegers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
<span class="go">&lt;c_long_Array_10 object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ii</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 2 3 4 5 6 7 8 9 10</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="pointers">
<span id="ctypes-pointers"></span><h3>포인터<a class="headerlink" href="#pointers" title="제목 주소">¶</a></h3>
<p>포인터 인스턴스는 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 형에 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 함수를 호출해서 만듭니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>포인터 인스턴스는 포인터가 가리키는 객체(위에서는 <code class="docutils literal notranslate"><span class="pre">i</span></code> 객체)를 반환하는 <a class="reference internal" href="#ctypes._Pointer.contents" title="ctypes._Pointer.contents"><code class="xref py py-attr docutils literal notranslate"><span class="pre">contents</span></code></a> 어트리뷰트를 가집니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(42)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>에는 OOR(원래 객체 반환, original object return)이 없다는 것에 유의하십시오. 어트리뷰트를 가져올 때마다 (동등하지만) 새로운 객체를 만듭니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">i</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>다른 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 인스턴스를 포인터의 contents 어트리뷰트에 대입하면 포인터는 이 인스턴스가 저장되어있는 메모리 위치를 가리키게됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(99)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>포인터 인스턴스는 정수로도 인덱싱 할 수 있습니다.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>정수 인덱스에 대입하면 가리키고 있는 값이 바뀝니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(99)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">22</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(22)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>0이 아닌 인덱스를 사용할 수도 있지만, C에서와 마찬가지로 자신이하고 있는 일을 알아야합니다: 임의의 메모리 위치를 액세스하거나 변경할 수 있습니다. 일반적으로 C 함수에서 포인터를 받고, 포인터가 실제로 단일 항목 대신 배열을 가리키는 것을 <em>알</em> 때만 이 기능을 사용합니다.</p>
<p>장막 뒤에서, <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 함수는 단순히 포인터 인스턴스를 만드는 것 이상을 수행합니다. 먼저 포인터 <em>형</em>을 만들어야합니다. 이것은 임의의 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 형을 받아들이고, 새로운 형을 반환하는 <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a> 함수로 수행됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span>
<span class="go">&lt;class &#39;ctypes.LP_c_long&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">expected c_long instead of int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at 0x...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>인자없이 포인터 형을 호출하면 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 포인터가 만들어집니다. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 포인터는 <code class="docutils literal notranslate"><span class="pre">False</span></code> 논릿값을 갖습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">null_ptr</span><span class="p">))</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 포인터를 역참조(dereference)할 때 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>인지 확인합니다 (하지만 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이 아닌 잘못된 포인터를 역참조하면 파이썬을 충돌시킵니다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="type-conversions">
<span id="ctypes-type-conversions"></span><h3>형 변환<a class="headerlink" href="#type-conversions" title="제목 주소">¶</a></h3>
<p>일반적으로, ctypes는 엄격한 형 검사를 수행합니다. 이는 함수의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 목록에 <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code>가 있거나, 구조체 멤버 필드의 형이 그런 형이라면, 정확히 같은 형의 인스턴스 만 허용됨을 뜻합니다. 이 규칙에는 ctypes가 다른 객체를 허용하는 몇 가지 예외가 있습니다. 예를 들어, 포인터 형 대신 호환 가능한 배열 인스턴스를 전달할 수 있습니다. 따라서 <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code>의 경우, ctype은 c_int 배열을 허용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_int</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>또한, 함수 인자가 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code>에 포인터 형(가령 <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code>)으로 명시적으로 선언 되면, 대상형(이 경우 <code class="docutils literal notranslate"><span class="pre">c_int</span></code>)의 객체를 함수에 전달할 수 있습니다. 이 때 ctypes는 필요한 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> 변환을 자동으로 적용합니다.</p>
<p>POINTER 형 필드를 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>로 설정하려면, <code class="docutils literal notranslate"><span class="pre">None</span></code>을 대입할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="kc">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>경우에 따라 호환되지 않는 형의 인스턴스가 있을 수 있습니다. C에서는, 한 형을 다른 형으로 강제 변환(cast) 할 수 있습니다. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 같은 방식으로 사용할 수있는 <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 함수를 제공합니다. 위에 정의 된 <code class="docutils literal notranslate"><span class="pre">Bar</span></code> 구조체는 <code class="docutils literal notranslate"><span class="pre">values</span></code> 필드에 대해 <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> 포인터나 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 배열을 받아들이지만 다른 형의 인스턴스는 허용하지 않습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">incompatible types, c_byte_Array_4 instance instead of LP_c_long instance</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>이럴 때, <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 함수가 편리합니다.</p>
<p><a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 함수는 ctypes 인스턴스를 다른 ctypes 데이터 형에 대한 포인터로 변환하는 데 사용할 수 있습니다. <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a>는 두 개의 매개 변수, 어떤 종류의 포인터로 변환 될 수 있는 ctypes 객체와 ctypes 포인터 형을 받아들입니다. 첫 번째 인자와 동일한 메모리 블록을 참조하는 두 번째 인자의 인스턴스를 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at ...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>따라서, <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">Bar</span></code> 구조체의 <code class="docutils literal notranslate"><span class="pre">values</span></code> 필드에 대입하는 데 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">((</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)(),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="incomplete-types">
<span id="ctypes-incomplete-types"></span><h3>불완전한 형<a class="headerlink" href="#incomplete-types" title="제목 주소">¶</a></h3>
<p><em>불완전한 형</em>은 멤버가 아직 지정되지 않은 구조체, 공용체 또는 배열입니다. C에서, 이 것들은 나중에 정의되는 전방 선언(forward declaration)에 의해 지정됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">cell</span><span class="p">;</span> <span class="o">/*</span> <span class="n">forward</span> <span class="n">declaration</span> <span class="o">*/</span>

<span class="n">struct</span> <span class="n">cell</span> <span class="p">{</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="n">struct</span> <span class="n">cell</span> <span class="o">*</span><span class="nb">next</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>ctypes 코드로 그대로 옮기면 이렇게 되지만, 작동하지는 않습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">cell</span>
<span class="gr">NameError</span>: <span class="n">name &#39;cell&#39; is not defined</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>새 <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">cell</span></code>은 클래스 문 자체에서 사용할 수 없기 때문입니다. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>에서는, <code class="docutils literal notranslate"><span class="pre">cell</span></code> 클래스를 정의한 다음, class 문 뒤에서 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 어트리뷰트를 설정할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>해 봅시다. 우리는 두 개의 <code class="docutils literal notranslate"><span class="pre">cell</span></code> 인스턴스를 만들고, 서로를 가리키도록 한 다음, 마지막으로 포인터 체인을 몇 번 따라 갑니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;bar&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">c1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">foo bar foo bar foo bar foo bar</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="callback-functions">
<span id="ctypes-callback-functions"></span><h3>콜백 함수<a class="headerlink" href="#callback-functions" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 파이썬 콜러블로부터 C 에서 호출 가능한 함수 포인터를 만들 수 있습니다. 이들은 때로 <em>콜백 함수(callback functions)</em>라고 불립니다.</p>
<p>먼저, 콜백 함수를 위한 클래스를 만들어야합니다. 클래스는 호출 규칙, 반환형 및 이 함수가 받는 인자의 수와 형을 알고 있습니다.</p>
<p><a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a> 팩토리 함수는 <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 호출 규칙을 사용하여 콜백 함수의 형을 만듭니다. 윈도우에서, <a class="reference internal" href="#ctypes.WINFUNCTYPE" title="ctypes.WINFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">WINFUNCTYPE()</span></code></a> 팩토리 함수는 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 호출 규칙을 사용하여 콜백 함수 형을 만듭니다.</p>
<p>이러한 팩토리 함수는 모두 첫 번째 인자로 결과 형을, 나머지 인자로 콜백 함수가 기대하는 인자 형들로 호출됩니다.</p>
<p>콜백 함수의 도움을 받아 항목을 정렬하는 데 사용되는 표준 C 라이브러리의 <code class="xref c c-func docutils literal notranslate"><span class="pre">qsort()</span></code> 함수를 사용하는 예제를 제시합니다. <code class="xref c c-func docutils literal notranslate"><span class="pre">qsort()</span></code>는 정수 배열을 정렬하는 데 사용될 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">IntArray5</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ia</span> <span class="o">=</span> <span class="n">IntArray5</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">qsort</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">qsort()</span></code>는 정렬 할 데이터에 대한 포인터, 데이터 배열의 항목 수, 항목 하나의 크기 및 비교 함수에 대한 포인터인 콜백으로 호출해야합니다. 콜백은 항목에 대한 두 개의 포인터로 호출되며, 첫 번째 항목이 두 번째 항목보다 작으면 음의 정수를, 같으면 0을, 그렇지 않으면 양수 정수를 반환해야합니다.</p>
<p>따라서 콜백 함수는 정수에 대한 포인터들을 받고 정수를 반환해야합니다. 먼저 콜백 함수를 위한 <code class="docutils literal notranslate"><span class="pre">형</span></code>을 만듭니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CMPFUNC</span> <span class="o">=</span> <span class="n">CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>시작하기 위해, 전달 된 값을 보여주는 간단한 콜백이 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">0</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmp_func</span> <span class="o">=</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>결과:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">cmp_func</span><span class="p">)</span>  
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>이제 실제로 두 항목을 비교하여 유용한 결과를 반환 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">))</span> 
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>쉽게 확인할 수 있듯이, 배열은 이제 정렬되었습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ia</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 5 7 33 99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>함수 팩토리는 데코레이터 팩토리로 사용할 수 있으므로, 다음과 같이 작성할 수도 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p>C 코드에서 사용되는 동안 <a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a> 객체에 대한 참조를 유지해야합니다. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>가 참조를 유지하지는 않으며, 여러분이 하지 않는다면 가비지 수집 되어, 콜백이 발생할 때 프로그램이 충돌할 수 있습니다.</p>
<p class="last">또한, 콜백 함수가 파이썬 제어 바깥에서 만들어진 스레드(예를 들어, 콜백을 호출하는 외부 코드)에서 호출되면, ctypes는 모든 호출에 대해 새로운 더미 파이썬 스레드를 만듭니다. 이 동작은 대부분 적합하지만, <a class="reference internal" href="threading.html#threading.local" title="threading.local"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.local</span></code></a>에 저장된 값은, 같은 C 스레드에서 호출되는 여러 콜백에서 살아남을 수 <em>없음</em>을 뜻합니다.</p>
</div>
</div>
<div class="section" id="accessing-values-exported-from-dlls">
<span id="ctypes-accessing-values-exported-from-dlls"></span><h3>dll에서 내 보낸 값을 액세스하기<a class="headerlink" href="#accessing-values-exported-from-dlls" title="제목 주소">¶</a></h3>
<p>일부 공유 라이브러리는 함수를 내보낼 뿐만 아니라 변수도 내 보냅니다. 파이썬 라이브러리 자체에 있는 예는 <a class="reference internal" href="../c-api/init.html#c.Py_OptimizeFlag" title="Py_OptimizeFlag"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_OptimizeFlag</span></code></a> 인데, 시작시 주어진 <a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 이나 <a class="reference internal" href="../using/cmdline.html#cmdoption-oo"><code class="xref std std-option docutils literal notranslate"><span class="pre">-OO</span></code></a> 플래그에 따라 , 0, 1 또는 2로 설정된 정수입니다.</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 형의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">in_dll()</span></code> 클래스 메서드를 사용하여 이와 같은 값을 액세스할 수 있습니다. <em>pythonapi</em>는 파이썬 C API에 대한 액세스를 제공하는 미리 정의 된 심볼입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">opt_flag</span> <span class="o">=</span> <span class="n">c_int</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;Py_OptimizeFlag&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">opt_flag</span><span class="p">)</span>
<span class="go">c_long(0)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>인터프리터가 <a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a>로 시작되면, 예는 <code class="docutils literal notranslate"><span class="pre">c_long(1)</span></code>를, <a class="reference internal" href="../using/cmdline.html#cmdoption-oo"><code class="xref std std-option docutils literal notranslate"><span class="pre">-OO</span></code></a>가 지정되면 <code class="docutils literal notranslate"><span class="pre">c_long(2)</span></code>를 인쇄합니다.</p>
<p>포인터의 사용법도 보여주는 확장 예제는 파이썬이 내 보낸 <a class="reference internal" href="../c-api/import.html#c.PyImport_FrozenModules" title="PyImport_FrozenModules"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyImport_FrozenModules</span></code></a> 포인터에 액세스합니다.</p>
<p>해당 값에 대한 문서를 인용하면:</p>
<blockquote>
<div>이 포인터는 멤버가 모두 <em>NULL</em> 이나 0인 것으로 끝나는 <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">_frozen</span></code> 레코드 배열을 가리키도록 초기화됩니다. 프로즌 모듈이 임포트될 때, 이 테이블에서 검색됩니다. 제삼자 코드는 동적으로 만들어진 프로즌 모듈의 컬렉션을 제공하기 위해 이 것을 조작할 수 있습니다.</div></blockquote>
<p>따라서, 이 포인터를 조작하는 것이 유용 할 수도 있습니다. 예제 크기를 제한하기 위해, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>로 이 테이블을 읽는 방법만 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">struct_frozen</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;code&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_ubyte</span><span class="p">)),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">_frozen</span></code> 데이터 형을 정의했으므로, 테이블에 대한 포인터를 얻을 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">FrozenTable</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">struct_frozen</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">FrozenTable</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;PyImport_FrozenModules&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">table</span></code>이 <code class="docutils literal notranslate"><span class="pre">struct_frozen</span></code> 레코드의 배열에 대한 <code class="docutils literal notranslate"><span class="pre">포인터</span></code>이므로, 이터레이션할 수 있습니다. 하지만 포인터는 크기가 없기 때문에 루프를 종료하는 방법이 필요합니다. 조만간 액세스 위반 등으로 인해 충돌이 발생할 수 있으므로, NULL 엔트리가 발견되자마자 루프에서 벗어나는 것이 좋습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">break</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">),</span> <span class="n">item</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">_frozen_importlib 31764</span>
<span class="go">_frozen_importlib_external 41499</span>
<span class="go">__hello__ 161</span>
<span class="go">__phello__ -161</span>
<span class="go">__phello__.spam 161</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>표준 파이썬이 프로즌 모듈과 프로즌 패키지(음수 size 멤버로 표시됨)를 가지고 있다는 사실은 잘 알려져 있지 않으며, 테스트 용으로 만 사용됩니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">__hello__</span></code>를 시도해보십시오.</p>
</div>
<div class="section" id="surprises">
<span id="ctypes-surprises"></span><h3>의외의 것들<a class="headerlink" href="#surprises" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>에는 여러분이 기대하는 것과 실제로 일어나는 것이 다른 가장자리가 있습니다.</p>
<p>다음 예제를 고려해보십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">1 2 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 이제 두 포인터를 스왑합니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">3 4 3 4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>흠. 아마도 마지막 문장이 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">1</span> <span class="pre">2</span></code>를 인쇄 할 것으로 기대했을겁니다. 어떻게 된 걸까요? 위의 <code class="docutils literal notranslate"><span class="pre">rc.a,</span> <span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">rc.b,</span> <span class="pre">rc.a</span></code> 줄의 단계는 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">temp0</span><span class="p">,</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">temp0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">temp0</span></code> 과 <code class="docutils literal notranslate"><span class="pre">temp1</span></code>은 여전히 위의 <code class="docutils literal notranslate"><span class="pre">rc</span></code> 객체의 내부 버퍼를 사용하는 객체입니다. 따라서 <code class="docutils literal notranslate"><span class="pre">rc.a</span> <span class="pre">=</span> <span class="pre">temp0</span></code>를 실행하면 <code class="docutils literal notranslate"><span class="pre">temp0</span></code>의 버퍼 내용이 <code class="docutils literal notranslate"><span class="pre">rc</span></code>의 버퍼로 복사됩니다. 이것은, 결과적으로 <code class="docutils literal notranslate"><span class="pre">temp1</span></code>의 내용을 변경합니다. 따라서 마지막 대입인 <code class="docutils literal notranslate"><span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">temp1</span></code>은 기대하는 효과를 주지 못합니다.</p>
<p>Structure, Union 및 Array에서 서브 객체를 가져 오는 것은 서브 객체를 <em>복사</em>하지 않고, 대신 루트 객체의 하부 버퍼에 액세스하는 래퍼 객체를 가져온다는 점에 유의하십시오.</p>
<p>예상과 다른 행동을하는 또 다른 예는 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">c_char_p</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;abc def ghi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">&#39;abc def ghi&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">False</span></code>를 인쇄하는 이유는 무엇일까요? ctypes 인스턴스는 메모리 블록과 메모리 내용에 액세스하는 어떤 <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">디스크립터</span></a>를 포함하는 객체입니다. 메모리 블록에 파이썬 객체를 저장하면 객체 자체를 저장하지 않고, 대신 객체의 <code class="docutils literal notranslate"><span class="pre">내용</span></code>을 저장합니다. 내용에 다시 액세스하면 매번 새로운 파이썬 객체가 생성됩니다!</p>
</div>
<div class="section" id="variable-sized-data-types">
<span id="ctypes-variable-sized-data-types"></span><h3>가변 크기 데이터 형<a class="headerlink" href="#variable-sized-data-types" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 가변 크기 배열과 구조체에 대한 일부 지원을 제공합니다.</p>
<p><a class="reference internal" href="#ctypes.resize" title="ctypes.resize"><code class="xref py py-func docutils literal notranslate"><span class="pre">resize()</span></code></a> 함수는 기존 ctypes 객체의 메모리 버퍼 크기를 바꾸는 데 사용할 수 있습니다. 이 함수는 객체를 첫 번째 인자로 가져오고, 바이트 단위의 요청 된 크기를 두 번째 인자로 가져옵니다. 메모리 블록을 객체 형이 지정하는 원래 메모리 블록보다 작게 만들 수 없습니다. 시도하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_short</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">minimum size is 8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>훌륭합니다, 하지만 이 배열에 포함된 추가 요소에 어떻게 액세스 할 수 있습니까? 형은 여전히 4개의 요소만 알고 있으므로, 다른 요소에 액세스하면 에러가 발생합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[:]</span>
<span class="go">[0, 0, 0, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">IndexError</span>: <span class="n">invalid index</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>에서 가변 크기 데이터 형을 사용하는 또 다른 방법은, 파이썬의 동적 특성을 사용하고 필요한 크기가 이미 알려진 후 매번 데이터 형을 (재)정의하는 것입니다.</p>
</div>
</div>
<div class="section" id="ctypes-reference">
<span id="ctypes-ctypes-reference"></span><h2>ctypes 레퍼런스<a class="headerlink" href="#ctypes-reference" title="제목 주소">¶</a></h2>
<div class="section" id="finding-shared-libraries">
<span id="ctypes-finding-shared-libraries"></span><h3>공유 라이브러리 찾기<a class="headerlink" href="#finding-shared-libraries" title="제목 주소">¶</a></h3>
<p>컴파일 언어로 프로그래밍할 때, 공유 라이브러리는 프로그램을 컴파일/링크 할 때와 프로그램을 실행할 때 액세스됩니다.</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> 함수의 목적은 컴파일러나 실행 시간 로더가 하는 것과 비슷한 방식으로 라이브러리를 찾는 것입니다 (여러 버전의 공유 라이브러리가 있는 플랫폼에서는 가장 최근의 것을 로드해야합니다). 반면에 ctypes 라이브러리 로더는 프로그램이 실행될 때 처럼 동작하고, 실행 시간 로더를 직접 호출합니다.</p>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.util</span></code> 모듈은 로드할 라이브러리를 판별하는 데 도움이되는 함수를 제공합니다.</p>
<dl class="data">
<dt>
<code class="descclassname">ctypes.util.</code><code class="descname">find_library</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></dt>
<dd><p>라이브러리를 찾아서 경로명을 반환하려고 시도합니다. <em>name</em>은 <em>lib</em> 같은 접두사, <code class="docutils literal notranslate"><span class="pre">.so</span></code>, <code class="docutils literal notranslate"><span class="pre">.dylib</span></code> 또는 버전 번호와 같은 접미사가 없는 라이브러리 이름입니다 (이것은 posix 링커 옵션 <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code>에 사용되는 양식입니다). 라이브러리를 찾을 수 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</dd></dl>

<p>정확한 기능은 시스템에 따라 다릅니다.</p>
<p>리눅스에서, <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code>는 외부 프로그램(<code class="docutils literal notranslate"><span class="pre">/sbin/ldconfig</span></code>, <code class="docutils literal notranslate"><span class="pre">gcc</span></code>, <code class="docutils literal notranslate"><span class="pre">objdump</span></code> 및 <code class="docutils literal notranslate"><span class="pre">ld</span></code>)을 실행하여 라이브러리 파일을 찾으려고합니다. 라이브러리 파일의 파일명을 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>리눅스에서, 다른 수단으로 라이브러리를 찾을 수 없으면, 라이브러리 검색시 환경 변수 <code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code>의 값이 사용됩니다.</p>
</div>
<p>여기 예제가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="k">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;libm.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;libc.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;libbz2.so.1.0&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>OS X에서, <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code>는 라이브러리를 찾기위해 미리 정의된 몇 가지 명명 체계와 경로를 시도하고 성공하면 전체 경로명을 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="k">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libc.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libm.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libbz2.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;AGL&quot;</span><span class="p">)</span>
<span class="go">&#39;/System/Library/Frameworks/AGL.framework/AGL&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>윈도우에서, <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code>는 시스템 검색 경로를 따라 검색하고 전체 경로명을 반환하지만, 미리 정의 된 명명 체계가 없으므로 <code class="docutils literal notranslate"><span class="pre">find_library(&quot;c&quot;)</span></code>와 같은 호출은 실패하고 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<p>공유 라이브러리를 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>로 래핑하려면, 실행 시간에 라이브러리를 찾기위해 <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code>를 사용하기보다, 개발 시점에 공유 라이브러리 이름을 확인하고 래퍼 모듈에 하드코딩하 것이 더 좋을 수 있습니다.</p>
</div>
<div class="section" id="loading-shared-libraries">
<span id="ctypes-loading-shared-libraries"></span><h3>공유 라이브러리 로드하기<a class="headerlink" href="#loading-shared-libraries" title="제목 주소">¶</a></h3>
<p>공유 라이브러리를 파이썬 프로세스에 로드하는 방법에는 여러 가지가 있습니다. 한 가지 방법은 다음 클래스 중 하나의 인스턴스를 만드는 것입니다:</p>
<dl class="class">
<dt id="ctypes.CDLL">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">CDLL</code><span class="sig-paren">(</span><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CDLL" title="정의 주소">¶</a></dt>
<dd><p>이 클래스의 인스턴스는 로드된 공유 라이브러리를 나타냅니다. 이 라이브러리의 함수는 표준 C 호출 규칙을 사용하며, <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>를 반환한다고 가정합니다.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.OleDLL">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">OleDLL</code><span class="sig-paren">(</span><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.OleDLL" title="정의 주소">¶</a></dt>
<dd><p>윈도우 전용: 이 클래스의 인스턴스는 로드된 공유 라이브러리를 나타내며, 이 라이브러리의 함수는 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 호출 규칙을 사용하고, 윈도우 특정 <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><code class="xref py py-class docutils literal notranslate"><span class="pre">HRESULT</span></code></a> 코드를 반환한다고 가정합니다. <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><code class="xref py py-class docutils literal notranslate"><span class="pre">HRESULT</span></code></a> 값에는 함수 호출이 실패했는지 또는 성공했는지와 추가 에러 코드를 지정하는 정보가 들어 있습니다. 반환 값이 실패를 알리면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a>가 자동으로 발생합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a>를 발생시켰었습니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="ctypes.WinDLL">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">WinDLL</code><span class="sig-paren">(</span><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinDLL" title="정의 주소">¶</a></dt>
<dd><p>윈도우 전용: 이 클래스의 인스턴스는 로드된 공유 라이브러리를 나타내며, 이 라이브러리의 함수는 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 호출 규칙을 사용하고, 기본적으로 <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>를 반환한다고 가정합니다.</p>
<p>윈도우 CE에서는 오직 표준 호출 규칙만 사용됩니다. 편의상 <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a> 와 <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a>은 이 플랫폼에서 표준 호출 규칙을 사용합니다.</p>
</dd></dl>

<p>파이썬 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">전역 인터프리터 록</span></a>은 이 라이브러리들이 내보낸 함수를 호출하기 전에 해제되고 나중에 다시 획득됩니다.</p>
<dl class="class">
<dt id="ctypes.PyDLL">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">PyDLL</code><span class="sig-paren">(</span><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PyDLL" title="정의 주소">¶</a></dt>
<dd><p>이 클래스의 인스턴스는 <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> 인스턴스처럼 동작합니다. 단, 파이썬 GIL이 함수 호출 중에 릴리스되지 <em>않고</em>, 함수 실행 후 파이썬 에러 플래그가 확인된다는 점만 다릅니다. 에러 플래그가 설정되면 파이썬 예외가 발생합니다.</p>
<p>따라서, 이것은 파이썬 C API 함수를 직접 호출하는 경우에만 유용합니다.</p>
</dd></dl>

<p>이러한 모든 클래스는 공유 라이브러리의 경로명인 적어도 하나의 인자를 사용하여 인스턴스를 만들 수 있습니다. 이미 로드된 공유 라이브러리에 대한 기존 핸들이 있으면, 이를 <code class="docutils literal notranslate"><span class="pre">handle</span></code> 이라고 이름 붙은 매개 변수로 전달할 수 있습니다. 그렇지 않으면 하부 플랫폼의 <code class="docutils literal notranslate"><span class="pre">dlopen</span></code> 이나 <code class="docutils literal notranslate"><span class="pre">LoadLibrary</span></code> 함수를 사용하여 라이브러리를 프로세스에 로드하고 이에 대한 핸들을 확보합니다.</p>
<p><em>mode</em> 매개 변수는 라이브러리가 로드되는 방법을 지정하는 데 사용될 수 있습니다. 자세한 내용은, <em class="manpage">dlopen(3)</em> 매뉴얼 페이지를 참조하십시오. 윈도우에서는, <em>mode</em>가 무시됩니다. posix 시스템에서는 RTLD_NOW가 항상 추가되며 구성 할 수 없습니다.</p>
<p><em>use_errno</em> 매개 변수를 참으로 설정하면 시스템 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 에러 번호에 안전하게 액세스할 수 있는 ctypes 메커니즘을 활성화합니다. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 시스템 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 변수의 스레드 로컬 사본을 유지합니다; <code class="docutils literal notranslate"><span class="pre">use_errno=True</span></code>로 만든 외부 함수를 호출하면 함수 호출 전에 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 값이 ctypes 내부 복사본과 스왑되며 함수 호출 직후에도 마찬가지 작업을 합니다.</p>
<p><a class="reference internal" href="#ctypes.get_errno" title="ctypes.get_errno"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.get_errno()</span></code></a> 함수는 ctypes 내부 사본의 값을 반환하고, <a class="reference internal" href="#ctypes.set_errno" title="ctypes.set_errno"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.set_errno()</span></code></a> 함수는 ctypes 내부 사본을 새 값으로 변경하고 이전 값을 반환합니다.</p>
<p><em>use_last_error</em> 매개 변수를 참으로 설정하면, <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a> 와 <code class="xref py py-func docutils literal notranslate"><span class="pre">SetLastError()</span></code> 윈도우 API 함수에서 관리하는 윈도우 에러 코드에 대해 같은 메커니즘을 활성화합니다. <a class="reference internal" href="#ctypes.get_last_error" title="ctypes.get_last_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.get_last_error()</span></code></a> 와 <a class="reference internal" href="#ctypes.set_last_error" title="ctypes.set_last_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.set_last_error()</span></code></a>는 윈도우 에러 코드의 ctypes 내부 사본을 요청하고 변경하는 데 사용됩니다.</p>
<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">RTLD_GLOBAL</code></dt>
<dd><p><em>mode</em> 매개 변수에 사용하는 플래그. 이 플래그를 사용할 수 없는 플랫폼에서는, 정수 0으로 정의됩니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">RTLD_LOCAL</code></dt>
<dd><p><em>mode</em> 매개 변수에 사용하는 플래그. 이 플래그를 사용할 수 없는 플랫폼에서는, <em>RTLD_GLOBAL</em>과 같습니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">DEFAULT_MODE</code></dt>
<dd><p>공유 라이브러리를 로드하는 데 사용되는 기본 모드. OSX 10.3에서는 <em>RTLD_GLOBAL</em>이고, 그렇지 않으면 <em>RTLD_LOCAL</em>과 같습니다.</p>
</dd></dl>

<p>이 클래스들의 인스턴스는 공개 메서드가 없습니다. 공유 라이브러리가 내보낸 함수는 어트리뷰트나 인덱스로 액세스 할 수 있습니다. 어트리뷰트를 통해 함수에 액세스하면 결과가 캐시되므로 반복적으로 액세스할 때 매번 같은 객체가 반환됨에 유의하십시오. 반면에 인덱스를 통해 액세스하면 매번 새로운 객체가 반환됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">CDLL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>  <span class="c1"># On Linux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">libc</span><span class="o">.</span><span class="n">time</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p>다음 공개 어트리뷰트를 사용할 수 있습니다. 내보낸 함수 이름과의 충돌을 피하기위해 이름은 밑줄로 시작합니다:</p>
<dl class="attribute">
<dt id="ctypes.PyDLL._handle">
<code class="descclassname">PyDLL.</code><code class="descname">_handle</code><a class="headerlink" href="#ctypes.PyDLL._handle" title="정의 주소">¶</a></dt>
<dd><p>라이브러리에 액세스하는 데 사용되는 시스템 핸들.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.PyDLL._name">
<code class="descclassname">PyDLL.</code><code class="descname">_name</code><a class="headerlink" href="#ctypes.PyDLL._name" title="정의 주소">¶</a></dt>
<dd><p>생성자에서 전달 된 라이브러리의 이름.</p>
</dd></dl>

<p>공유 라이브러리는 <a class="reference internal" href="#ctypes.LibraryLoader" title="ctypes.LibraryLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">LibraryLoader</span></code></a> 클래스의 인스턴스인 사전 작성된 객체 중 하나를 사용하여 로드 할 수도 있습니다. 로더의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadLibrary()</span></code> 메서드를 호출하거나 로더 인스턴스의 어트리뷰트로 라이브러리를 조회합니다.</p>
<dl class="class">
<dt id="ctypes.LibraryLoader">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">LibraryLoader</code><span class="sig-paren">(</span><em>dlltype</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader" title="정의 주소">¶</a></dt>
<dd><p>공유 라이브러리를 로드하는 클래스. <em>dlltype</em>은 <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a>, <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a>, <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a> 또는 <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a> 형 중 하나여야 합니다.</p>
<p><a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>에는 특수한 동작이 있습니다: 라이브러리 로더 인스턴스의 어트리뷰트를 액세스하여 공유 라이브러리를 로드 할 수 있게합니다. 결과는 캐시되므로 반복되는 어트리뷰트 액세스는 매번 같은 라이브러리를 반환합니다.</p>
<dl class="method">
<dt id="ctypes.LibraryLoader.LoadLibrary">
<code class="descname">LoadLibrary</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader.LoadLibrary" title="정의 주소">¶</a></dt>
<dd><p>공유 라이브러리를 프로세스에 로드하고 반환합니다. 이 메서드는 항상 라이브러리의 새 인스턴스를 반환합니다.</p>
</dd></dl>

</dd></dl>

<p>다음과 같은 사전 작성된 로더를 사용할 수 있습니다:</p>
<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">cdll</code></dt>
<dd><p><a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> 인스턴스를 만듭니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">windll</code></dt>
<dd><p>윈도우 전용: <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a> 인스턴스를 만듭니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">oledll</code></dt>
<dd><p>윈도우 전용: <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a> 인스턴스를 만듭니다.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">pydll</code></dt>
<dd><p><a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a> 인스턴스를 만듭니다.</p>
</dd></dl>

<p>C 파이썬 API에 직접 액세스하기 위해, 바로 사용할 수 있는 파이썬 공유 라이브러리 객체가 제공됩니다:</p>
<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">pythonapi</code></dt>
<dd><p>파이썬 C API 함수를 어트리뷰트로 노출시키는 <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a>의 인스턴스. 이 모든 함수는 C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>를 반환한다고 가정하는데, 물론 항상 옳지는 않습니다. 그런 함수를 사용하려면 올바른 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 어트리뷰트를 대입해야합니다.</p>
</dd></dl>

</div>
<div class="section" id="foreign-functions">
<span id="ctypes-foreign-functions"></span><h3>외부 함수<a class="headerlink" href="#foreign-functions" title="제목 주소">¶</a></h3>
<p>이전 섹션에서 설명한 것처럼, 외부 함수는 로드 된 공유 라이브러리의 어트리뷰트로 액세스 할 수 있습니다. 이런 방식으로 만들어진 함수 객체는 기본적으로 임의의 개수의 인자를 허용하고, 임의의 ctypes 데이터 인스턴스를 인자로 받아들이고, 라이브러리 로더에 의해 지정된 기본 결과형을 반환합니다. 이 것들은 내부 클래스의 인스턴스입니다:</p>
<dl class="class">
<dt id="ctypes._FuncPtr">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">_FuncPtr</code><a class="headerlink" href="#ctypes._FuncPtr" title="정의 주소">¶</a></dt>
<dd><p>C 호출 가능한 외부 함수의 베이스 클래스.</p>
<p>외부 함수의 인스턴스는 C 호환 데이터 형이기도 합니다; C 함수 포인터를 나타냅니다.</p>
<p>이 동작은 외부 함수 객체의 특수 어트리뷰트에 대입하여 사용자 정의 할 수 있습니다.</p>
<dl class="attribute">
<dt id="ctypes._FuncPtr.restype">
<code class="descname">restype</code><a class="headerlink" href="#ctypes._FuncPtr.restype" title="정의 주소">¶</a></dt>
<dd><p>ctypes 형을 대입하여 외부 함수의 결과형을 지정합니다. 아무 것도 반환하지 않는 함수인 <code class="xref c c-type docutils literal notranslate"><span class="pre">void</span></code>는 <code class="docutils literal notranslate"><span class="pre">None</span></code>를 사용하십시오.</p>
<p>ctypes 형이 아닌 콜러블 파이썬 객체를 대입 할 수 있습니다. 이 때 함수는 C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>를 반환한다고 가정하고, 이 콜러블 객체는 이 정수로 호출되어, 사후 처리나 에러 검사를 허용합니다. 이 기능을 사용하는 것은 폐지되었습니다. 더 유연한 사후 처리나 에러 검사를 위해, ctypes 데이터형을 <a class="reference internal" href="#ctypes._FuncPtr.restype" title="ctypes._FuncPtr.restype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code></a>로 사용하고, 콜러블을 <a class="reference internal" href="#ctypes._FuncPtr.errcheck" title="ctypes._FuncPtr.errcheck"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code></a> 어트리뷰트에 대입하십시오.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._FuncPtr.argtypes">
<code class="descname">argtypes</code><a class="headerlink" href="#ctypes._FuncPtr.argtypes" title="정의 주소">¶</a></dt>
<dd><p>ctypes 형의 튜플을 대입하여 함수가 받아들이는 인자 형을 지정합니다. <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 호출 규칙을 사용하는 함수는 이 튜플의 길이와 같은 수의 인자로만 호출 할 수 있습니다; C 호출 규칙을 사용하는 함수는 추가적인 지정되지 않은 인자도 허용합니다.</p>
<p>외부 함수가 호출 될 때, 각 실제 인자는 <a class="reference internal" href="#ctypes._FuncPtr.argtypes" title="ctypes._FuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 튜플의 항목의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> 클래스 메서드에 전달됩니다. 이 메서드는 실제 인자를 외부 함수가 받아들이는 객체에 맞출 수 있습니다. 예를 들어, <a class="reference internal" href="#ctypes._FuncPtr.argtypes" title="ctypes._FuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 튜플의 <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> 항목은 ctypes 변환 규칙을 사용하여 인자로 전달 된 문자열을 바이트열 객체로 변환합니다.</p>
<p>새로운 기능: 이제 ctypes 형이 아닌 항목을 argtypes에 넣을 수 있습니다. 하지만 각 항목에는 인자로 사용할 수 있는 값(정수, 문자열, ctypes 인스턴스)을 반환하는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> 메서드가 있어야합니다. 이를 통해 사용자 정의 객체를 함수 매개 변수로 맞출 수 있는 어댑터를 정의 할 수 있습니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._FuncPtr.errcheck">
<code class="descname">errcheck</code><a class="headerlink" href="#ctypes._FuncPtr.errcheck" title="정의 주소">¶</a></dt>
<dd><p>이 어트리뷰트에 파이썬 함수나 다른 콜러블를 대입합니다. 콜러블은 3개 이상의 인자로 호출됩니다:</p>
<dl class="function">
<dt>
<code class="descname">callable</code><span class="sig-paren">(</span><em>result</em>, <em>func</em>, <em>arguments</em><span class="sig-paren">)</span></dt>
<dd><p><em>result</em>는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 어트리뷰트에 지정된대로 외부 함수가 반환하는 것입니다.</p>
<p><em>func</em>는 외부 함수 객체 자체이며, 같은 콜러블 객체를 재 사용하여 여러 함수의 결과를 확인하거나 사후 처리 할 수 있도록합니다.</p>
<p><em>arguments</em>는 원래 함수 호출에 전달 된 매개 변수를 포함하는 튜플입니다. 사용 된 인자에 따라 동작을 특수화 할 수 있도록합니다.</p>
</dd></dl>

<p>이 함수가 반환하는 객체는 외부 함수 호출에서 반환되지만, 결과 값을 확인하고 외부 함수 호출이 실패하면 예외를 발생시킬 수도 있습니다.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="ctypes.ArgumentError">
<em class="property">exception </em><code class="descclassname">ctypes.</code><code class="descname">ArgumentError</code><a class="headerlink" href="#ctypes.ArgumentError" title="정의 주소">¶</a></dt>
<dd><p>외부 함수 호출이 전달 된 인자 중 하나를 변환 할 수 없을 때 발생하는 예외.</p>
</dd></dl>

</div>
<div class="section" id="function-prototypes">
<span id="ctypes-function-prototypes"></span><h3>함수 프로토타입<a class="headerlink" href="#function-prototypes" title="제목 주소">¶</a></h3>
<p>함수 프로토타입의 인스턴스를 만들어서 외부 함수를 만들 수도 있습니다. 함수 프로토타입은 C의 함수 프로토타입과 비슷합니다; 구현을 정의하지 않고 함수(반환형, 인자형, 호출 규칙)를 설명합니다. 팩토리 함수는 원하는 결과형과 함수의 인자형들로 호출되어야하며, 데코레이터 팩토리로 사용되어 <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code> 문법을 통해 함수에 적용될 수 있습니다. 예제는 <a class="reference internal" href="#ctypes-callback-functions"><span class="std std-ref">콜백 함수</span></a>를 참조하십시오.</p>
<dl class="function">
<dt id="ctypes.CFUNCTYPE">
<code class="descclassname">ctypes.</code><code class="descname">CFUNCTYPE</code><span class="sig-paren">(</span><em>restype</em>, <em>*argtypes</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CFUNCTYPE" title="정의 주소">¶</a></dt>
<dd><p>반환된 함수 프로토타입은 표준 C 호출 규칙을 사용하는 함수를 만듭니다. 이 함수는 호출 중에 GIL을 해제합니다. <em>use_errno</em>를 참으로 설정하면, 시스템 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 변수의 ctypes 내부 복사본이 호출 전후에 실제 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 값과 교환됩니다; <em>use_last_error</em>는 윈도우 에러 코드에 대해 같은 일을 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.WINFUNCTYPE">
<code class="descclassname">ctypes.</code><code class="descname">WINFUNCTYPE</code><span class="sig-paren">(</span><em>restype</em>, <em>*argtypes</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WINFUNCTYPE" title="정의 주소">¶</a></dt>
<dd><p>윈도우 전용: 반환된 함수 프로토타입은 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 호출 규칙을 사용하는 함수를 만듭니다. 단 <a class="reference internal" href="#ctypes.WINFUNCTYPE" title="ctypes.WINFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">WINFUNCTYPE()</span></code></a>이 <a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a>과 같은 윈도우 CE는 예외입니다. 이 함수는 호출 중에 GIL을 해제합니다. <em>use_errno</em> 와 <em>use_last_error</em>는 위에서와 같은 의미를 갖습니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.PYFUNCTYPE">
<code class="descclassname">ctypes.</code><code class="descname">PYFUNCTYPE</code><span class="sig-paren">(</span><em>restype</em>, <em>*argtypes</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PYFUNCTYPE" title="정의 주소">¶</a></dt>
<dd><p>반환된 함수 프로토타입은 파이썬 호출 규칙을 사용하는 함수를 만듭니다. 이 함수는 호출 도중 GIL을 해제하지 <em>않습니다</em>.</p>
</dd></dl>

<p>이러한 팩토리 함수로 만들어진 함수 프로토타입은 호출의 매개 변수 형과 수에 따라 다른 방법으로 인스턴스를 만들 수 있습니다:</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="descname">prototype</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span></dt>
<dd><p>지정된 정수 주소에 있는 외부 함수를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">prototype</code><span class="sig-paren">(</span><em>callable</em><span class="sig-paren">)</span></dt>
<dd><p>파이썬 <em>callable</em>로 C 호출 가능 함수(콜백 함수)를 만듭니다.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">prototype</code><span class="sig-paren">(</span><em>func_spec</em><span class="optional">[</span>, <em>paramflags</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>공유 라이브러리가 내보낸 외부 함수를 반환합니다. <em>func_spec</em>은 2-튜플 <code class="docutils literal notranslate"><span class="pre">(name_or_ordinal,</span> <span class="pre">library)</span></code> 여야합니다. 첫 번째 항목은 내 보낸 함수의 문자열 이름이거나, 작은 정수로 표현된 내 보낸 함수의 서수(ordinal)입니다. 두 번째 항목은 공유 라이브러리 인스턴스입니다.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">prototype</code><span class="sig-paren">(</span><em>vtbl_index</em>, <em>name</em><span class="optional">[</span>, <em>paramflags</em><span class="optional">[</span>, <em>iid</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>COM 메서드를 호출 할 외부 함수를 반환합니다. <em>vtbl_index</em>는 가상 함수 테이블에 대한 인덱스이며, 작은 음이 아닌 정수입니다. <em>name</em>은 COM 메서드의 이름입니다. <em>iid</em>는 확장 에러보고에 사용되는 인터페이스 식별자를 가리키는 선택적 포인터입니다.</p>
<p>COM 메서드는 특별한 호출 규칙을 사용합니다: <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 튜플에 지정된 매개 변수 외에, 첫 번째 인자로 COM 인터페이스에 대한 포인터가 필요합니다.</p>
</dd></dl>

<p>선택적 <em>paramflags</em> 매개 변수는 위에 설명 된 기능보다 훨씬 많은 기능을 갖는 외부 함수 래퍼를 만듭니다.</p>
<p><em>paramflags</em>는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code>와 같은 길이의 튜플이어야합니다.</p>
<p>이 튜플의 각 항목에는 매개 변수에 대한 추가 정보가 들어 있으며, 한 개, 두 개 또는 세 개의 항목이 들어있는 튜플이어야합니다.</p>
<p>첫 번째 항목은 매개 변수의 방향 플래그 조합을 포함하는 정수입니다:</p>
<blockquote>
<div><dl class="docutils">
<dt>1</dt>
<dd>함수에 대한 입력 매개 변수를 지정합니다.</dd>
<dt>2</dt>
<dd>출력 매개 변수. 외부 함수가 값을 채웁니다.</dd>
<dt>4</dt>
<dd>기본값이 정수 0인 입력 매개 변수.</dd>
</dl>
</div></blockquote>
<p>선택적인 두 번째 항목은 문자열 매개 변수 이름입니다. 이것이 지정되면, 이름있는 매개 변수로 외부 함수를 호출 할 수 있습니다.</p>
<p>선택적 세 번째 항목은 이 매개 변수의 기본값입니다.</p>
</div></blockquote>
<p>이 예제는 기본값이 있는 매개 변수와 이름있는 인자를 지원하도록 윈도우 <code class="docutils literal notranslate"><span class="pre">MessageBoxW</span></code> 함수를 래핑하는 방법을 보여줍니다. 윈도우 헤더 파일의 C 선언은 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="nb">int</span> <span class="n">WINAPI</span>
<span class="n">MessageBoxW</span><span class="p">(</span>
    <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpText</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpCaption</span><span class="p">,</span>
    <span class="n">UINT</span> <span class="n">uType</span><span class="p">);</span>
</pre></div>
</div>
<p>다음은 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>로 래핑하는 방법입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.wintypes</span> <span class="k">import</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;Hi&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;caption&quot;</span><span class="p">,</span> <span class="s2">&quot;Hello from ctypes&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;flags&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;MessageBoxW&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
</pre></div>
</div>
<p>이제 <code class="docutils literal notranslate"><span class="pre">MessageBox</span></code> 외부 함수를 다음과 같이 호출 할 수 있습니다.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s2">&quot;Spam, spam, spam&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">&quot;foo bar&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>두 번째 예제는 출력 매개 변수를 보여줍니다. win32 <code class="docutils literal notranslate"><span class="pre">GetWindowRect</span></code> 함수는 지정된 창의 크기를 조회하는데, 호출자가 제공해야하는 <code class="docutils literal notranslate"><span class="pre">RECT</span></code> 구조체로 복사합니다. 다음은 C 선언입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="n">BOOL</span> <span class="n">WINAPI</span>
<span class="n">GetWindowRect</span><span class="p">(</span>
     <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
     <span class="n">LPRECT</span> <span class="n">lpRect</span><span class="p">);</span>
</pre></div>
</div>
<p>다음은 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>로 래핑하는 방법입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">POINTER</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span><span class="p">,</span> <span class="n">WinError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.wintypes</span> <span class="k">import</span> <span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">RECT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">RECT</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;lprect&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;GetWindowRect&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>출력 매개 변수가 있는 함수는, 하나 뿐이면 자동으로 출력 매개 변수 값을 반환하고, 여러 개면 출력 매개 변수 값을 포함하는 튜플을 반환하므로, GetWindowRect 함수는 이제 호출되면 RECT 인스턴스를 반환합니다.</p>
<p>출력 매개 변수는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code> 프로토콜과 결합하여 추가적인 출력 처리와 에러 검사를 수행 할 수 있습니다. win32 <code class="docutils literal notranslate"><span class="pre">GetWindowRect</span></code> api 함수는 성공이나 실패를 알리기 위해 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code>을 반환하므로, 이 함수는 에러 검사를 수행하고 API 호출이 실패했을 때 예외를 발생시킬 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">args</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code> 함수가 수신한 인자 튜플을 변경없이 반환하면, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 출력 매개 변수에 수행하는 일반 처리를 계속합니다. <code class="docutils literal notranslate"><span class="pre">RECT</span></code> 인스턴스 대신 창 좌표의 튜플을 반환하려면, 함수에서 필드를 조회해서 대신 반환하면 됩니다, 이 때는 일반 처리가 더는 수행되지 않습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">rc</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">right</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="utility-functions">
<span id="ctypes-utility-functions"></span><h3>유틸리티 함수<a class="headerlink" href="#utility-functions" title="제목 주소">¶</a></h3>
<dl class="function">
<dt id="ctypes.addressof">
<code class="descclassname">ctypes.</code><code class="descname">addressof</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.addressof" title="정의 주소">¶</a></dt>
<dd><p>메모리 버퍼의 주소를 정수로 반환합니다. <em>obj</em>는 ctypes 형의 인스턴스여야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.alignment">
<code class="descclassname">ctypes.</code><code class="descname">alignment</code><span class="sig-paren">(</span><em>obj_or_type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.alignment" title="정의 주소">¶</a></dt>
<dd><p>ctypes 형의 정렬 요구 사항을 반환합니다. <em>obj_or_type</em>는 ctypes 형이나 인스턴스여야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.byref">
<code class="descclassname">ctypes.</code><code class="descname">byref</code><span class="sig-paren">(</span><em>obj</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.byref" title="정의 주소">¶</a></dt>
<dd><p><em>obj</em>에 대한 경량 포인터를 반환합니다. <em>obj</em>는 ctypes 형의 인스턴스여야 합니다. <em>offset</em>의 기본값은 0이며, 내부 포인터 값에 더해질 정수여야 합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">byref(obj,</span> <span class="pre">offset)</span></code>는 이 C 코드에 해당합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<p>반환된 객체는 외부 함수 호출 매개 변수로만 사용할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">pointer(obj)</span></code>와 비슷하게 동작하지만, 월씬 빨리 만들어집니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.cast">
<code class="descclassname">ctypes.</code><code class="descname">cast</code><span class="sig-paren">(</span><em>obj</em>, <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.cast" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 C의 형변환 연산자와 유사합니다. <em>obj</em>와 같은 메모리 블록을 가리키는 <em>type</em> 형의 새 인스턴스를 반환합니다. <em>type</em>은 포인터 형이어야하며, <em>obj</em>는 포인터로 해석 될 수 있는 객체 여야합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.create_string_buffer">
<code class="descclassname">ctypes.</code><code class="descname">create_string_buffer</code><span class="sig-paren">(</span><em>init_or_size</em>, <em>size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_string_buffer" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 가변 문자 버퍼를 만듭니다. 반환된 객체는 <a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char</span></code></a>의 ctypes 배열입니다.</p>
<p><em>init_or_size</em>는 배열의 크기를 지정하는 정수거나 배열 항목을 초기화하는 데 사용될 바이트열 객체여야 합니다.</p>
<p>바이트열 객체가 첫 번째 인자로 지정되면, 버퍼의 길이는 이 객체의 길이보다 한 항목만큼 길어져서, 배열의 마지막 요소가 NUL 종료 문자가됩니다. 두 번째 인자로 정수를 전달하면 바이트열의 길이를 사용하지 않고 배열의 크기를 지정할 수있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.create_unicode_buffer">
<code class="descclassname">ctypes.</code><code class="descname">create_unicode_buffer</code><span class="sig-paren">(</span><em>init_or_size</em>, <em>size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_unicode_buffer" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 가변 유니코드 문자 버퍼를 만듭니다. 반환 된 객체는 <a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a>의 ctypes 배열입니다.</p>
<p><em>init_or_size</em>는 배열의 크기를 지정하는 정수거나 배열 항목을 초기화하는 데 사용될 문자열이어야합니다.</p>
<p>문자열이 첫 번째 인자로 지정되면, 버퍼의 길이는 문자열의 길이보다 한 항목만큼 길어져서, 배열의 마지막 요소가 NUL 종료 문자가됩니다. 두 번째 인자로 정수를 전달하면 문자열의 길이를 사용하지 않고 배열의 크기를 지정할 수있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.DllCanUnloadNow">
<code class="descclassname">ctypes.</code><code class="descname">DllCanUnloadNow</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllCanUnloadNow" title="정의 주소">¶</a></dt>
<dd><p>윈도우 전용: 이 함수는 ctypes로 프로세스 내부(in-process) COM 서버를 구현하게하는 훅입니다. _ctypes 확장 dll이 내보내는 DllCanUnloadNow 함수에서 호출됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.DllGetClassObject">
<code class="descclassname">ctypes.</code><code class="descname">DllGetClassObject</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllGetClassObject" title="정의 주소">¶</a></dt>
<dd><p>윈도우 전용: 이 함수는 ctypes로 프로세스 내부(in-process) COM 서버를 구현하게하는 훅입니다. <code class="docutils literal notranslate"><span class="pre">_ctypes</span></code> 확장 dll이 내보내는 DllGetClassObject 함수에서 호출됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.util.find_library">
<code class="descclassname">ctypes.util.</code><code class="descname">find_library</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_library" title="정의 주소">¶</a></dt>
<dd><p>라이브러리를 찾아서 경로명을 반환하려고 시도합니다. <em>name</em>은 <code class="docutils literal notranslate"><span class="pre">lib</span></code> 같은 접두사, <code class="docutils literal notranslate"><span class="pre">.so</span></code>, <code class="docutils literal notranslate"><span class="pre">.dylib</span></code> 또는 버전 번호와 같은 접미사가 없는 라이브러리 이름입니다 (이것은 posix 링커 옵션 <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code>에 사용되는 양식입니다). 라이브러리를 찾을 수 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<p>정확한 기능은 시스템에 따라 다릅니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.util.find_msvcrt">
<code class="descclassname">ctypes.util.</code><code class="descname">find_msvcrt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_msvcrt" title="정의 주소">¶</a></dt>
<dd><p>윈도우 전용: 파이썬과 확장 모듈이 사용하는 VC 런타임 라이브러리의 파일명을 반환합니다. 라이브러리의 이름을 판별 할 수 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다.</p>
<p>예를 들어, <code class="docutils literal notranslate"><span class="pre">free(void</span> <span class="pre">*)</span></code>에 대한 호출로 확장 모듈에 의해 할당된 메모리를 해제해야하면, 메모리를 할당한 것과 같은 라이브러리에 있는 함수를 사용하는 것이 중요합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.FormatError">
<code class="descclassname">ctypes.</code><code class="descname">FormatError</code><span class="sig-paren">(</span><span class="optional">[</span><em>code</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.FormatError" title="정의 주소">¶</a></dt>
<dd><p>윈도우 전용: 에러 코드 <em>code</em>의 텍스트 설명을 반환합니다. 에러 코드를 지정하지 않으면 윈도우 API 함수 GetLastError를 호출하여 마지막 에러 코드가 사용됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.GetLastError">
<code class="descclassname">ctypes.</code><code class="descname">GetLastError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.GetLastError" title="정의 주소">¶</a></dt>
<dd><p>윈도우 전용: 호출 스레드에서 윈도우가 설정한 마지막 에러 코드를 반환합니다. 이 함수는 윈도우 <cite>GetLastError()</cite> 함수를 직접 호출합니다. 에러 코드의 ctypes 내부 복사본을 반환하지 않습니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.get_errno">
<code class="descclassname">ctypes.</code><code class="descname">get_errno</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_errno" title="정의 주소">¶</a></dt>
<dd><p>호출하는 스레드에서 시스템 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 변수의 ctypes 내부 복사본의 현재 값을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.get_last_error">
<code class="descclassname">ctypes.</code><code class="descname">get_last_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_last_error" title="정의 주소">¶</a></dt>
<dd><p>윈도우 전용: 호출중인 스레드에서 시스템 <code class="xref py py-data docutils literal notranslate"><span class="pre">LastError</span></code> 변수의 ctypes 내부 복사본의 현재 값을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.memmove">
<code class="descclassname">ctypes.</code><code class="descname">memmove</code><span class="sig-paren">(</span><em>dst</em>, <em>src</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memmove" title="정의 주소">¶</a></dt>
<dd><p>표준 C memmove 라이브러리 함수와 같습니다: <em>count</em> 바이트를 <em>src</em>에서 <em>dst</em>로 복사합니다. <em>dst</em> 와 <em>src</em>는 정수이거나 포인터로 변환 할 수 있는 ctypes 인스턴스여야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.memset">
<code class="descclassname">ctypes.</code><code class="descname">memset</code><span class="sig-paren">(</span><em>dst</em>, <em>c</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memset" title="정의 주소">¶</a></dt>
<dd><p>표준 C memset 라이브러리 함수와 같습니다: 주소 <em>dst</em>의 메모리 블록을 값 <em>c</em>의 <em>count</em> 바이트로 채웁니다. <em>dst</em>는 주소를 지정하는 정수거나 ctypes 인스턴스여야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.POINTER">
<code class="descclassname">ctypes.</code><code class="descname">POINTER</code><span class="sig-paren">(</span><em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.POINTER" title="정의 주소">¶</a></dt>
<dd><p>이 팩토리 함수는 새로운 ctypes 포인터 형을 만들고 반환합니다. 포인터 형은 캐시되고 내부적으로 재사용되므로, 이 함수를 반복적으로 호출하는 것은 저렴합니다. <em>type</em>는 ctypes 형이어야합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.pointer">
<code class="descclassname">ctypes.</code><code class="descname">pointer</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.pointer" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <em>obj</em>를 가리키는 새 포인터 인스턴스를 만듭니다. 반환된 객체는 형 <code class="docutils literal notranslate"><span class="pre">POINTER(type(obj))</span></code>입니다.</p>
<p>참고 사항: 객체에 대한 포인터를 단지 외부 함수 호출로 전달하려면 훨씬 빠른 <code class="docutils literal notranslate"><span class="pre">byref(obj)</span></code>를 사용해야합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.resize">
<code class="descclassname">ctypes.</code><code class="descname">resize</code><span class="sig-paren">(</span><em>obj</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.resize" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <em>obj</em>의 내부 메모리 버퍼의 크기를 조정합니다. <em>obj</em>는 ctypes 형의 인스턴스 여야합니다. <code class="docutils literal notranslate"><span class="pre">sizeof(type(obj))</span></code>로 주어지는 객체 형의 원래 크기보다 버퍼를 작게 만들 수는 없지만, 버퍼를 확대 할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.set_errno">
<code class="descclassname">ctypes.</code><code class="descname">set_errno</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_errno" title="정의 주소">¶</a></dt>
<dd><p>호출중인 스레드의 시스템 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 변수의 ctypes 내부 복사본의 현재 값을 <em>value</em>로 설정하고 이전 값을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.set_last_error">
<code class="descclassname">ctypes.</code><code class="descname">set_last_error</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_last_error" title="정의 주소">¶</a></dt>
<dd><p>윈도우 전용: 호출중인 스레드의 시스템 <code class="xref py py-data docutils literal notranslate"><span class="pre">LastError</span></code> 변수의 ctypes 내부 복사본의 현재 값을 <em>value</em>로 설정하고 이전 값을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.sizeof">
<code class="descclassname">ctypes.</code><code class="descname">sizeof</code><span class="sig-paren">(</span><em>obj_or_type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.sizeof" title="정의 주소">¶</a></dt>
<dd><p>ctypes 형이나 인스턴스 메모리 버퍼의 크기를 바이트 단위로 반환합니다. C <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> 연산자와 같은 일을 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.string_at">
<code class="descclassname">ctypes.</code><code class="descname">string_at</code><span class="sig-paren">(</span><em>address</em>, <em>size=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.string_at" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 메모리 주소 <em>address</em>에서 시작하는 C 문자열을 바이트열 객체로 반환합니다. size가 지정되면 크기로 사용되며, 그렇지 않으면 문자열은 0으로 종료된다고 가정합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.WinError">
<code class="descclassname">ctypes.</code><code class="descname">WinError</code><span class="sig-paren">(</span><em>code=None</em>, <em>descr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinError" title="정의 주소">¶</a></dt>
<dd><p>윈도우 전용: 이 함수는 아마도 ctypes에서 가장 이름을 잘못 붙인 것입니다. OSError의 인스턴스를 만듭니다. <em>code</em>를 지정하지 않으면, 에러 코드를 판별하기 위해 <code class="docutils literal notranslate"><span class="pre">GetLastError</span></code>가 호출됩니다. <em>descr</em>가 지정되지 않으면, 에러에 대한 텍스트 설명을 얻기 위해 <a class="reference internal" href="#ctypes.FormatError" title="ctypes.FormatError"><code class="xref py py-func docutils literal notranslate"><span class="pre">FormatError()</span></code></a>가 호출됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a>의 인스턴스를 만들어왔습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ctypes.wstring_at">
<code class="descclassname">ctypes.</code><code class="descname">wstring_at</code><span class="sig-paren">(</span><em>address</em>, <em>size=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.wstring_at" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 메모리 주소 <em>address</em>에서 시작하는 광폭(wide) 문자열을 문자열로 반환합니다. <em>size</em>가 지정되면, 문자열의 문자 수로 사용되며, 그렇지 않으면 문자열은 0으로 종료된다고 가정합니다.</p>
</dd></dl>

</div>
<div class="section" id="data-types">
<span id="ctypes-data-types"></span><h3>데이터 형<a class="headerlink" href="#data-types" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="ctypes._CData">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">_CData</code><a class="headerlink" href="#ctypes._CData" title="정의 주소">¶</a></dt>
<dd><p>이 비공개 클래스는 모든 ctypes 데이터 형의 공통 베이스 클래스입니다. 무엇보다도, 모든 ctypes 형 인스턴스에는 C 호환 데이터를 보관하는 메모리 블록이 포함됩니다; 메모리 블록의 주소는 <a class="reference internal" href="#ctypes.addressof" title="ctypes.addressof"><code class="xref py py-func docutils literal notranslate"><span class="pre">addressof()</span></code></a> 도우미 함수에 의해 반환됩니다. 다른 인스턴스 변수는 <a class="reference internal" href="#ctypes._CData._objects" title="ctypes._CData._objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_objects</span></code></a>로 노출됩니다; 여기에는 메모리 블록에 포인터가 포함되어있을 때, 살려둘 필요가 있는 다른 파이썬 객체가 포함되어 있습니다.</p>
<p>ctypes 데이터 형의 공통 메서드, 이 것들은 모두 클래스 메서드입니다 (정확히 말하면, <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">메타 클래스</span></a>의 메서드입니다):</p>
<dl class="method">
<dt id="ctypes._CData.from_buffer">
<code class="descname">from_buffer</code><span class="sig-paren">(</span><em>source</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer" title="정의 주소">¶</a></dt>
<dd><p>This method returns a ctypes instance that shares the buffer of the
<em>source</em> object.  The <em>source</em> object must support the writeable buffer
interface.  The optional <em>offset</em> parameter specifies an offset into the
source buffer in bytes; the default is zero.  If the source buffer is not
large enough a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised.</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_buffer_copy">
<code class="descname">from_buffer_copy</code><span class="sig-paren">(</span><em>source</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer_copy" title="정의 주소">¶</a></dt>
<dd><p>This method creates a ctypes instance, copying the buffer from the
<em>source</em> object buffer which must be readable.  The optional <em>offset</em>
parameter specifies an offset into the source buffer in bytes; the default
is zero.  If the source buffer is not large enough a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is
raised.</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_address">
<code class="descname">from_address</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_address" title="정의 주소">¶</a></dt>
<dd><p>This method returns a ctypes type instance using the memory specified by
<em>address</em> which must be an integer.</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_param">
<code class="descname">from_param</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_param" title="정의 주소">¶</a></dt>
<dd><p>This method adapts <em>obj</em> to a ctypes type.  It is called with the actual
object used in a foreign function call when the type is present in the
foreign function's <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> tuple; it must return an object that
can be used as a function call parameter.</p>
<p>All ctypes data types have a default implementation of this classmethod
that normally returns <em>obj</em> if that is an instance of the type.  Some
types accept other objects as well.</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.in_dll">
<code class="descname">in_dll</code><span class="sig-paren">(</span><em>library</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.in_dll" title="정의 주소">¶</a></dt>
<dd><p>This method returns a ctypes type instance exported by a shared
library. <em>name</em> is the name of the symbol that exports the data, <em>library</em>
is the loaded shared library.</p>
</dd></dl>

<p>Common instance variables of ctypes data types:</p>
<dl class="attribute">
<dt id="ctypes._CData._b_base_">
<code class="descname">_b_base_</code><a class="headerlink" href="#ctypes._CData._b_base_" title="정의 주소">¶</a></dt>
<dd><p>Sometimes ctypes data instances do not own the memory block they contain,
instead they share part of the memory block of a base object.  The
<a class="reference internal" href="#ctypes._CData._b_base_" title="ctypes._CData._b_base_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_b_base_</span></code></a> read-only member is the root ctypes object that owns the
memory block.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._CData._b_needsfree_">
<code class="descname">_b_needsfree_</code><a class="headerlink" href="#ctypes._CData._b_needsfree_" title="정의 주소">¶</a></dt>
<dd><p>This read-only variable is true when the ctypes data instance has
allocated the memory block itself, false otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._CData._objects">
<code class="descname">_objects</code><a class="headerlink" href="#ctypes._CData._objects" title="정의 주소">¶</a></dt>
<dd><p>This member is either <code class="docutils literal notranslate"><span class="pre">None</span></code> or a dictionary containing Python objects
that need to be kept alive so that the memory block contents is kept
valid.  This object is only exposed for debugging; never modify the
contents of this dictionary.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ctypes-fundamental-data-types-2">
<span id="id1"></span><h3>기본 데이터형<a class="headerlink" href="#ctypes-fundamental-data-types-2" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="ctypes._SimpleCData">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">_SimpleCData</code><a class="headerlink" href="#ctypes._SimpleCData" title="정의 주소">¶</a></dt>
<dd><p>This non-public class is the base class of all fundamental ctypes data
types. It is mentioned here because it contains the common attributes of the
fundamental ctypes data types.  <a class="reference internal" href="#ctypes._SimpleCData" title="ctypes._SimpleCData"><code class="xref py py-class docutils literal notranslate"><span class="pre">_SimpleCData</span></code></a> is a subclass of
<a class="reference internal" href="#ctypes._CData" title="ctypes._CData"><code class="xref py py-class docutils literal notranslate"><span class="pre">_CData</span></code></a>, so it inherits their methods and attributes. ctypes data
types that are not and do not contain pointers can now be pickled.</p>
<p>Instances have a single attribute:</p>
<dl class="attribute">
<dt id="ctypes._SimpleCData.value">
<code class="descname">value</code><a class="headerlink" href="#ctypes._SimpleCData.value" title="정의 주소">¶</a></dt>
<dd><p>This attribute contains the actual value of the instance. For integer and
pointer types, it is an integer, for character types, it is a single
character bytes object or string, for character pointer types it is a
Python bytes object or string.</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">value</span></code> attribute is retrieved from a ctypes instance, usually
a new object is returned each time.  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> does <em>not</em> implement
original object return, always a new object is constructed.  The same is
true for all other ctypes object instances.</p>
</dd></dl>

</dd></dl>

<p>Fundamental data types, when returned as foreign function call results, or, for
example, by retrieving structure field members or array items, are transparently
converted to native Python types.  In other words, if a foreign function has a
<code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> of <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>, you will always receive a Python bytes
object, <em>not</em> a <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> instance.</p>
<p>Subclasses of fundamental data types do <em>not</em> inherit this behavior. So, if a
foreign functions <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> is a subclass of <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a>, you will
receive an instance of this subclass from the function call. Of course, you can
get the value of the pointer by accessing the <code class="docutils literal notranslate"><span class="pre">value</span></code> attribute.</p>
<p>These are the fundamental ctypes data types:</p>
<dl class="class">
<dt id="ctypes.c_byte">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_byte</code><a class="headerlink" href="#ctypes.c_byte" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">char</span></code> datatype, and interprets the value as
small integer.  The constructor accepts an optional integer initializer; no
overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_char">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_char</code><a class="headerlink" href="#ctypes.c_char" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code> datatype, and interprets the value as a single
character.  The constructor accepts an optional string initializer, the
length of the string must be exactly one character.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_char_p">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_char_p</code><a class="headerlink" href="#ctypes.c_char_p" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> datatype when it points to a zero-terminated
string.  For a general character pointer that may also point to binary data,
<code class="docutils literal notranslate"><span class="pre">POINTER(c_char)</span></code> must be used.  The constructor accepts an integer
address, or a bytes object.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_double">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_double</code><a class="headerlink" href="#ctypes.c_double" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">double</span></code> datatype.  The constructor accepts an
optional float initializer.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_longdouble">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_longdouble</code><a class="headerlink" href="#ctypes.c_longdouble" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">double</span></code> datatype.  The constructor accepts an
optional float initializer.  On platforms where <code class="docutils literal notranslate"><span class="pre">sizeof(long</span> <span class="pre">double)</span> <span class="pre">==</span>
<span class="pre">sizeof(double)</span></code> it is an alias to <a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_float">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_float</code><a class="headerlink" href="#ctypes.c_float" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">float</span></code> datatype.  The constructor accepts an
optional float initializer.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int</code><a class="headerlink" href="#ctypes.c_int" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.  On platforms
where <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> it is an alias to <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int8">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int8</code><a class="headerlink" href="#ctypes.c_int8" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 8-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_byte</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int16">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int16</code><a class="headerlink" href="#ctypes.c_int16" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 16-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_short</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int32">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int32</code><a class="headerlink" href="#ctypes.c_int32" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 32-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int64">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int64</code><a class="headerlink" href="#ctypes.c_int64" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 64-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longlong</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_long">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_long</code><a class="headerlink" href="#ctypes.c_long" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_longlong">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_longlong</code><a class="headerlink" href="#ctypes.c_longlong" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">long</span></code> datatype.  The constructor accepts
an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_short">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_short</code><a class="headerlink" href="#ctypes.c_short" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">short</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_size_t">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_size_t</code><a class="headerlink" href="#ctypes.c_size_t" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code> datatype.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ssize_t">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ssize_t</code><a class="headerlink" href="#ctypes.c_ssize_t" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">ssize_t</span></code> datatype.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ubyte">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ubyte</code><a class="headerlink" href="#ctypes.c_ubyte" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code> datatype, it interprets the value as
small integer.  The constructor accepts an optional integer initializer; no
overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint</code><a class="headerlink" href="#ctypes.c_uint" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.  On platforms
where <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> it is an alias for <a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulong</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint8">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint8</code><a class="headerlink" href="#ctypes.c_uint8" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 8-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ubyte</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint16">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint16</code><a class="headerlink" href="#ctypes.c_uint16" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 16-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ushort</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint32">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint32</code><a class="headerlink" href="#ctypes.c_uint32" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 32-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint64">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint64</code><a class="headerlink" href="#ctypes.c_uint64" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 64-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulonglong</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ulong">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ulong</code><a class="headerlink" href="#ctypes.c_ulong" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ulonglong">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ulonglong</code><a class="headerlink" href="#ctypes.c_ulonglong" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> datatype.  The constructor
accepts an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ushort">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ushort</code><a class="headerlink" href="#ctypes.c_ushort" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code> datatype.  The constructor accepts
an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_void_p">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_void_p</code><a class="headerlink" href="#ctypes.c_void_p" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> type.  The value is represented as integer.
The constructor accepts an optional integer initializer.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_wchar">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_wchar</code><a class="headerlink" href="#ctypes.c_wchar" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> datatype, and interprets the value as a
single character unicode string.  The constructor accepts an optional string
initializer, the length of the string must be exactly one character.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_wchar_p">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_wchar_p</code><a class="headerlink" href="#ctypes.c_wchar_p" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span> <span class="pre">*</span></code> datatype, which must be a pointer to a
zero-terminated wide character string.  The constructor accepts an integer
address, or a string.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_bool">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_bool</code><a class="headerlink" href="#ctypes.c_bool" title="정의 주소">¶</a></dt>
<dd><p>Represent the C <code class="xref c c-type docutils literal notranslate"><span class="pre">bool</span></code> datatype (more accurately, <code class="xref c c-type docutils literal notranslate"><span class="pre">_Bool</span></code> from
C99).  Its value can be <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>, and the constructor accepts any object
that has a truth value.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.HRESULT">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">HRESULT</code><a class="headerlink" href="#ctypes.HRESULT" title="정의 주소">¶</a></dt>
<dd><p>Windows only: Represents a <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> value, which contains success or
error information for a function or method call.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.py_object">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">py_object</code><a class="headerlink" href="#ctypes.py_object" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> datatype.  Calling this without an
argument creates a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> pointer.</p>
</dd></dl>

<p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.wintypes</span></code> module provides quite some other Windows specific
data types, for example <code class="xref c c-type docutils literal notranslate"><span class="pre">HWND</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">WPARAM</span></code>, or <code class="xref c c-type docutils literal notranslate"><span class="pre">DWORD</span></code>.  Some
useful structures like <code class="xref c c-type docutils literal notranslate"><span class="pre">MSG</span></code> or <code class="xref c c-type docutils literal notranslate"><span class="pre">RECT</span></code> are also defined.</p>
</div>
<div class="section" id="structured-data-types">
<span id="ctypes-structured-data-types"></span><h3>Structured data types<a class="headerlink" href="#structured-data-types" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="ctypes.Union">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">Union</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Union" title="정의 주소">¶</a></dt>
<dd><p>Abstract base class for unions in native byte order.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.BigEndianStructure">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">BigEndianStructure</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.BigEndianStructure" title="정의 주소">¶</a></dt>
<dd><p>Abstract base class for structures in <em>big endian</em> byte order.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.LittleEndianStructure">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">LittleEndianStructure</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LittleEndianStructure" title="정의 주소">¶</a></dt>
<dd><p>Abstract base class for structures in <em>little endian</em> byte order.</p>
</dd></dl>

<p>Structures with non-native byte order cannot contain pointer type fields, or any
other data types containing pointer type fields.</p>
<dl class="class">
<dt id="ctypes.Structure">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">Structure</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Structure" title="정의 주소">¶</a></dt>
<dd><p>Abstract base class for structures in <em>native</em> byte order.</p>
<p>Concrete structure and union types must be created by subclassing one of these
types, and at least define a <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> class variable. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> will
create <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>s which allow reading and writing the fields by direct
attribute accesses.  These are the</p>
<dl class="attribute">
<dt id="ctypes.Structure._fields_">
<code class="descname">_fields_</code><a class="headerlink" href="#ctypes.Structure._fields_" title="정의 주소">¶</a></dt>
<dd><p>A sequence defining the structure fields.  The items must be 2-tuples or
3-tuples.  The first item is the name of the field, the second item
specifies the type of the field; it can be any ctypes data type.</p>
<p>For integer type fields like <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>, a third optional item can be
given.  It must be a small positive integer defining the bit width of the
field.</p>
<p>Field names must be unique within one structure or union.  This is not
checked, only one field can be accessed when names are repeated.</p>
<p>It is possible to define the <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> class variable <em>after</em> the
class statement that defines the Structure subclass, this allows creating
data types that directly or indirectly reference themselves:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">List</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">List</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;pnext&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">List</span><span class="p">)),</span>
                 <span class="o">...</span>
                <span class="p">]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> class variable must, however, be defined before the
type is first used (an instance is created, <a class="reference internal" href="#ctypes.sizeof" title="ctypes.sizeof"><code class="xref py py-func docutils literal notranslate"><span class="pre">sizeof()</span></code></a> is called on it,
and so on).  Later assignments to the <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> class variable will
raise an AttributeError.</p>
<p>It is possible to defined sub-subclasses of structure types, they inherit
the fields of the base class plus the <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> defined in the
sub-subclass, if any.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.Structure._pack_">
<code class="descname">_pack_</code><a class="headerlink" href="#ctypes.Structure._pack_" title="정의 주소">¶</a></dt>
<dd><p>An optional small integer that allows overriding the alignment of
structure fields in the instance.  <a class="reference internal" href="#ctypes.Structure._pack_" title="ctypes.Structure._pack_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code></a> must already be defined
when <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> is assigned, otherwise it will have no effect.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.Structure._anonymous_">
<code class="descname">_anonymous_</code><a class="headerlink" href="#ctypes.Structure._anonymous_" title="정의 주소">¶</a></dt>
<dd><p>An optional sequence that lists the names of unnamed (anonymous) fields.
<a class="reference internal" href="#ctypes.Structure._anonymous_" title="ctypes.Structure._anonymous_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_anonymous_</span></code></a> must be already defined when <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> is
assigned, otherwise it will have no effect.</p>
<p>The fields listed in this variable must be structure or union type fields.
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> will create descriptors in the structure type that allows
accessing the nested fields directly, without the need to create the
structure or union field.</p>
<p>Here is an example type (Windows):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">_U</span><span class="p">(</span><span class="n">Union</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;lptdesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">TYPEDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;lpadesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">ARRAYDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;hreftype&quot;</span><span class="p">,</span> <span class="n">HREFTYPE</span><span class="p">)]</span>

<span class="k">class</span> <span class="nc">TYPEDESC</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_anonymous_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">,)</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="n">_U</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;vt&quot;</span><span class="p">,</span> <span class="n">VARTYPE</span><span class="p">)]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">TYPEDESC</span></code> structure describes a COM data type, the <code class="docutils literal notranslate"><span class="pre">vt</span></code> field
specifies which one of the union fields is valid.  Since the <code class="docutils literal notranslate"><span class="pre">u</span></code> field
is defined as anonymous field, it is now possible to access the members
directly off the TYPEDESC instance. <code class="docutils literal notranslate"><span class="pre">td.lptdesc</span></code> and <code class="docutils literal notranslate"><span class="pre">td.u.lptdesc</span></code>
are equivalent, but the former is faster since it does not need to create
a temporary union instance:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">td</span> <span class="o">=</span> <span class="n">TYPEDESC</span><span class="p">()</span>
<span class="n">td</span><span class="o">.</span><span class="n">vt</span> <span class="o">=</span> <span class="n">VT_PTR</span>
<span class="n">td</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
<span class="n">td</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<p>It is possible to defined sub-subclasses of structures, they inherit the
fields of the base class.  If the subclass definition has a separate
<a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> variable, the fields specified in this are appended to the
fields of the base class.</p>
<p>Structure and union constructors accept both positional and keyword
arguments.  Positional arguments are used to initialize member fields in the
same order as they are appear in <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>.  Keyword arguments in the
constructor are interpreted as attribute assignments, so they will initialize
<a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> with the same name, or create new attributes for names not
present in <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="arrays-and-pointers">
<span id="ctypes-arrays-pointers"></span><h3>Arrays and pointers<a class="headerlink" href="#arrays-and-pointers" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="ctypes.Array">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">Array</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Array" title="정의 주소">¶</a></dt>
<dd><p>Abstract base class for arrays.</p>
<p>The recommended way to create concrete array types is by multiplying any
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> data type with a positive integer.  Alternatively, you can subclass
this type and define <a class="reference internal" href="#ctypes.Array._length_" title="ctypes.Array._length_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_length_</span></code></a> and <a class="reference internal" href="#ctypes.Array._type_" title="ctypes.Array._type_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_type_</span></code></a> class variables.
Array elements can be read and written using standard
subscript and slice accesses; for slice reads, the resulting object is
<em>not</em> itself an <a class="reference internal" href="#ctypes.Array" title="ctypes.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>.</p>
<dl class="attribute">
<dt id="ctypes.Array._length_">
<code class="descname">_length_</code><a class="headerlink" href="#ctypes.Array._length_" title="정의 주소">¶</a></dt>
<dd><p>A positive integer specifying the number of elements in the array.
Out-of-range subscripts result in an <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>. Will be
returned by <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.Array._type_">
<code class="descname">_type_</code><a class="headerlink" href="#ctypes.Array._type_" title="정의 주소">¶</a></dt>
<dd><p>Specifies the type of each element in the array.</p>
</dd></dl>

<p>Array subclass constructors accept positional arguments, used to
initialize the elements in order.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes._Pointer">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">_Pointer</code><a class="headerlink" href="#ctypes._Pointer" title="정의 주소">¶</a></dt>
<dd><p>Private, abstract base class for pointers.</p>
<p>Concrete pointer types are created by calling <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a> with the
type that will be pointed to; this is done automatically by
<a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a>.</p>
<p>If a pointer points to an array, its elements can be read and
written using standard subscript and slice accesses.  Pointer objects
have no size, so <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> will raise <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.  Negative
subscripts will read from the memory <em>before</em> the pointer (as in C), and
out-of-range subscripts will probably crash with an access violation (if
you're lucky).</p>
<dl class="attribute">
<dt id="ctypes._Pointer._type_">
<code class="descname">_type_</code><a class="headerlink" href="#ctypes._Pointer._type_" title="정의 주소">¶</a></dt>
<dd><p>Specifies the type pointed to.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._Pointer.contents">
<code class="descname">contents</code><a class="headerlink" href="#ctypes._Pointer.contents" title="정의 주소">¶</a></dt>
<dd><p>Returns the object to which to pointer points.  Assigning to this
attribute changes the pointer to point to the assigned object.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">ctypes</span></code> --- 파이썬용 외부 함수 라이브러리</a><ul>
<li><a class="reference internal" href="#ctypes-tutorial">ctypes 자습서</a><ul>
<li><a class="reference internal" href="#loading-dynamic-link-libraries">동적 링크 라이브러리 로드하기</a></li>
<li><a class="reference internal" href="#accessing-functions-from-loaded-dlls">로드된 dll에서 함수에 액세스하기</a></li>
<li><a class="reference internal" href="#calling-functions">함수 호출하기</a></li>
<li><a class="reference internal" href="#fundamental-data-types">기본 데이터형</a></li>
<li><a class="reference internal" href="#calling-functions-continued">함수 호출하기, 계속</a></li>
<li><a class="reference internal" href="#calling-functions-with-your-own-custom-data-types">사용자 정의 데이터형을 사용하여 함수 호출하기</a></li>
<li><a class="reference internal" href="#specifying-the-required-argument-types-function-prototypes">필수 인자 형 (함수 프로토타입) 지정하기</a></li>
<li><a class="reference internal" href="#return-types">반환 형</a></li>
<li><a class="reference internal" href="#passing-pointers-or-passing-parameters-by-reference">포인터 전달하기 (또는: 참조로 매개 변수 전달하기)</a></li>
<li><a class="reference internal" href="#structures-and-unions">구조체와 공용체</a></li>
<li><a class="reference internal" href="#structure-union-alignment-and-byte-order">구조체/공용체 정렬과 바이트 순서</a></li>
<li><a class="reference internal" href="#bit-fields-in-structures-and-unions">구조체와 공용체의 비트 필드</a></li>
<li><a class="reference internal" href="#arrays">배열</a></li>
<li><a class="reference internal" href="#pointers">포인터</a></li>
<li><a class="reference internal" href="#type-conversions">형 변환</a></li>
<li><a class="reference internal" href="#incomplete-types">불완전한 형</a></li>
<li><a class="reference internal" href="#callback-functions">콜백 함수</a></li>
<li><a class="reference internal" href="#accessing-values-exported-from-dlls">dll에서 내 보낸 값을 액세스하기</a></li>
<li><a class="reference internal" href="#surprises">의외의 것들</a></li>
<li><a class="reference internal" href="#variable-sized-data-types">가변 크기 데이터 형</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctypes-reference">ctypes 레퍼런스</a><ul>
<li><a class="reference internal" href="#finding-shared-libraries">공유 라이브러리 찾기</a></li>
<li><a class="reference internal" href="#loading-shared-libraries">공유 라이브러리 로드하기</a></li>
<li><a class="reference internal" href="#foreign-functions">외부 함수</a></li>
<li><a class="reference internal" href="#function-prototypes">함수 프로토타입</a></li>
<li><a class="reference internal" href="#utility-functions">유틸리티 함수</a></li>
<li><a class="reference internal" href="#data-types">데이터 형</a></li>
<li><a class="reference internal" href="#ctypes-fundamental-data-types-2">기본 데이터형</a></li>
<li><a class="reference internal" href="#structured-data-types">Structured data types</a></li>
<li><a class="reference internal" href="#arrays-and-pointers">Arrays and pointers</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="errno.html"
                        title="이전 장"><code class="docutils literal notranslate"><span class="pre">errno</span></code> --- Standard errno system symbols</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="concurrency.html"
                        title="다음 장">동시 실행</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="동시 실행"
             >다음</a> |</li>
        <li class="right" >
          <a href="errno.html" title="errno --- Standard errno system symbols"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >일반 운영 체제 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2018, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1 를 사용해서 만들었습니다.
    </div>

  </body>
</html>