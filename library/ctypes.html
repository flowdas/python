
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ctypes --- 파이썬용 외부 함수 라이브러리 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="동시 실행" href="concurrency.html" />
    <link rel="prev" title="errno --- Standard errno system symbols" href="errno.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/library/ctypes.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="동시 실행"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="errno.html" title="errno --- Standard errno system symbols"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">일반 운영 체제 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-ctypes">
<span id="ctypes-a-foreign-function-library-for-python"></span><h1><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> --- 파이썬용 외부 함수 라이브러리<a class="headerlink" href="#module-ctypes" title="제목 주소">¶</a></h1>
<hr class="docutils" />
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 파이썬용 외부 함수(foreign function) 라이브러리입니다. C 호환 데이터형을 제공하며, DLL 또는 공유 라이브러리에 있는 함수를 호출할 수 있습니다. 이 라이브러리들을 순수 파이썬으로 감싸는 데 사용할 수 있습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">같은 목적으로 자주 사용되는 제삼자 라이브러리로 PyPy 팀에서 개발한
<a class="reference external" href="https://cffi.readthedocs.io/en/latest/">cffi</a>가 있습니다. CPython에서도 사용할 수 있고,
PyPy 에서는 대체로 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 에 비해 훨씬 높은 성능을 제공합니다.</p>
</div>
<div class="section" id="ctypes-tutorial">
<span id="ctypes-ctypes-tutorial"></span><h2>ctypes 자습서<a class="headerlink" href="#ctypes-tutorial" title="제목 주소">¶</a></h2>
<p>참고: 이 자습서의 코드 샘플은 <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>를 사용하여 실제로 작동하는지 확인합니다. 일부 코드 샘플은 리눅스, 윈도우 또는 맥 OS X에서 다르게 동작하므로, 주석에 doctest 지시문이 포함되어 있습니다.</p>
<p>참고: 일부 코드 샘플은 ctypes <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 형을 참조합니다. <code class="docutils literal notranslate"><span class="pre">sizeof(long)</span> <span class="pre">==</span> <span class="pre">sizeof(int)</span></code>인 플랫폼에서, 이는 <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a>의 별칭입니다. 따라서 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>를 기대할 때 <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a>가 인쇄되더라도 혼란스러워 하지 않아도됩니다 --- 이 것들은 실제로 같은 형입니다.</p>
<div class="section" id="loading-dynamic-link-libraries">
<span id="ctypes-loading-dynamic-link-libraries"></span><h3>동적 링크 라이브러리 로드하기<a class="headerlink" href="#loading-dynamic-link-libraries" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 동적 링크 라이브러리 로드를 위해 <em>cdll</em>을, 그리고 윈도우에서는 <em>windll</em> 및 <em>oledll</em> 객체를, 노출합니다.</p>
<p>이 객체의 어트리뷰트를 액세스하여 라이브러리를 로드합니다. <em>cdll</em>은 표준 <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 호출 규칙을 사용하는 함수를 내보내는 라이브러리를 로드하는 반면, <em>windll</em> 라이브러리는 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 호출 규칙을 사용하여 함수를 호출합니다. <em>oledll</em> 또한 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 호출 규칙을 사용하고, 함수가 윈도우 <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> 에러 코드를 반환한다고 가정합니다. 에러 코드는 함수 호출이 실패 할 때 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> 예외를 자동으로 발생시키는 데 사용됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>윈도우 에러는 <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a>를 일으켜왔습니다. 이제는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 별칭입니다.</p>
</div>
<p>다음은 윈도우 용 예제입니다. <code class="docutils literal notranslate"><span class="pre">msvcrt</span></code>는 대부분 표준 C 함수가 포함 된 MS 표준 C 라이브러리며, cdecl 호출 규칙을 사용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">)</span>  
<span class="go">&lt;WinDLL &#39;kernel32&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">)</span>      
<span class="go">&lt;CDLL &#39;msvcrt&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span>      
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>윈도우는 일반적인 <code class="docutils literal notranslate"><span class="pre">.dll</span></code> 파일 접미사를 자동으로 추가합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">cdll.msvcrt</span></code>를 통해 표준 C 라이브러리에 액세스하면 파이썬에서 사용되는 라이브러리와 호환되지 않는 오래된 라이브러리 버전이 사용됩니다. 가능하면 파이썬 자체의 기능을 사용하거나, <code class="docutils literal notranslate"><span class="pre">msvcrt</span></code> 모듈을 임포트해서 사용하십시오.</p>
</div>
<p>리눅스에서, 라이브러리를 로드하기위해서는 확장자를 <em>포함하는</em> 파일명을 지정해야하므로, 어트리뷰트 액세스를 사용하여 라이브러리를 로드 할 수 없습니다. dll 로더의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadLibrary()</span></code> 메서드를 사용하거나 CDLL의 생성자를 호출하여 인스턴스를 만들어 라이브러리를 로드해야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>  
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>       
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span>                           
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="accessing-functions-from-loaded-dlls">
<span id="ctypes-accessing-functions-from-loaded-dlls"></span><h3>로드된 dll에서 함수에 액세스하기<a class="headerlink" href="#accessing-functions-from-loaded-dlls" title="제목 주소">¶</a></h3>
<p>함수는 dll 객체의 어트리뷰트로 액세스됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">)</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">MyOwnFunction</span><span class="p">)</span>     
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">239</span>, in <span class="n">__getattr__</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function &#39;MyOwnFunction&#39; not found</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">kernel32</span></code> 와 <code class="docutils literal notranslate"><span class="pre">user32</span></code>와 같은 win32 시스템 dll은 종종 ANSI뿐만 아니라 UNICODE 버전의 함수를 내보냅니다. UNICODE 버전은 이름에 <code class="docutils literal notranslate"><span class="pre">W</span></code>가 추가 된 상태로 내보내지며, ANSI 버전은 이름에 <code class="docutils literal notranslate"><span class="pre">A</span></code>가 추가되어 내보내집니다. 지정된 모듈 이름의 <em>모듈 핸들</em>을 반환하는 win32 <code class="docutils literal notranslate"><span class="pre">GetModuleHandle</span></code> 함수는, 다음과 같은 C 프로토타입을 가지며, UNICODE가 정의되어 있는지에 따라 그 중 하나를 <code class="docutils literal notranslate"><span class="pre">GetModuleHandle</span></code>로 노출하기위해 매크로가 사용됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">ANSI</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleA</span><span class="p">(</span><span class="n">LPCSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
<span class="o">/*</span> <span class="n">UNICODE</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleW</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
</pre></div>
</div>
<p><em>windll</em>는 마술적으로 이 중 하나를 선택하려고 하지 않으므로, <code class="docutils literal notranslate"><span class="pre">GetModuleHandleA</span></code> 나 <code class="docutils literal notranslate"><span class="pre">GetModuleHandleW</span></code>를 명시적으로 지정하여 필요한 버전에 액세스해야하고, 그런 다음 각각 바이트열이나 문자열 객체로 호출해야 합니다.</p>
<p>때때로, dll은 <code class="docutils literal notranslate"><span class="pre">&quot;??2&#64;YAPAXI&#64;Z&quot;</span></code>와 같은 유효한 파이썬 식별자가 아닌 이름으로 함수를 내 보냅니다. 이 때는 <a class="reference internal" href="functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a>를 사용하여 함수를 조회해야합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">getattr</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">,</span> <span class="s2">&quot;??2@YAPAXI@Z&quot;</span><span class="p">)</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>윈도우에서, 일부 dll은 이름이 아니라 서수(ordinal)로 함수를 내 보냅니다. 이 함수는 서수로 dll 객체를 인덱싱하여 액세스 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">310</span>, in <span class="n">__getitem__</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function ordinal 0 not found</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="calling-functions">
<span id="ctypes-calling-functions"></span><h3>함수 호출하기<a class="headerlink" href="#calling-functions" title="제목 주소">¶</a></h3>
<p>다른 파이썬 콜러블처럼 이 함수를 호출 할 수 있습니다. 이 예제에서는 시스템 시간을 유닉스 에포크부터의 초로 반환하는 <code class="docutils literal notranslate"><span class="pre">time()</span></code> 함수와 win32 모듈 핸들을 반환하는 <code class="docutils literal notranslate"><span class="pre">GetModuleHandleA()</span></code> 함수를 사용합니다.</p>
<p>이 예는 NULL 포인터로 두 함수를 호출합니다 (<code class="docutils literal notranslate"><span class="pre">None</span></code>을 NULL 포인터로 사용해야합니다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>  
<span class="go">1150640792</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)))</span>  
<span class="go">0x1d000000</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">유효하지 않은 수의 인자가 전달 된 것을 감지하면, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 함수를 호출 한 후 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>를 발생시킬 수 있습니다. 이 동작에 의존하지 않아야합니다. 3.6.2에서 폐지되었으며, 3.7에서 제거될 것입니다.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 호출 규칙을 사용하여 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 함수를 호출하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생하고, 그 반대도 마찬가지입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with not enough arguments (4 bytes missing)</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">msvcrt</span><span class="o">.</span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;spam&quot;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with too many arguments (4 bytes in excess)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>올바른 호출 규칙을 찾으려면 C 헤더 파일이나 호출 할 함수에 대한 설명서를 살펴 봐야합니다.</p>
<p>윈도우에서, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 함수가 유효하지 않은 인자 값을 사용하여 호출 될 때, 일반적인 보호 오류로 인한 충돌을 방지하기 위해 win32 구조적 예외 처리를 사용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">OSError</span>: <span class="n">exception: access violation reading 0x00000020</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>그러나, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>로 파이썬을 충돌시킬 수 있는 방법이 많으므로, 어쨌든 주의해야합니다. <a class="reference internal" href="faulthandler.html#module-faulthandler" title="faulthandler: Dump the Python traceback."><code class="xref py py-mod docutils literal notranslate"><span class="pre">faulthandler</span></code></a> 모듈은 충돌을 디버깅하는 데 도움이 될 수 있습니다 (예를 들어, 오류가 있는 C 라이브러리 호출로 인한 세그먼트 오류).</p>
<p><code class="docutils literal notranslate"><span class="pre">None</span></code>, 정수, 바이트열 객체 및 (유니코드) 문자열은 이러한 함수 호출에서 매개 변수로 직접 사용할 수 있는 유일한 파이썬 자체의 객체입니다. <code class="docutils literal notranslate"><span class="pre">None</span></code>는 C <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 포인터로 전달되고, 바이트열 객체와 문자열은 데이터가 저장된 메모리 블록에 대한 포인터로 전달됩니다 (<code class="xref c c-type docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> 이나 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span> <span class="pre">*</span></code>). 파이썬 정수는 플랫폼의 기본 C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> 형으로 전달되며, 그 값은 C 형에 맞게 마스크됩니다.</p>
<p>다른 매개 변수 형으로 함수를 호출하기 전에, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 데이터 형에 대해 더 알아야합니다.</p>
</div>
<div class="section" id="fundamental-data-types">
<span id="ctypes-fundamental-data-types"></span><h3>기본 데이터형<a class="headerlink" href="#fundamental-data-types" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 많은 기본적인 C 호환 데이터형을 정의합니다.:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="46%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ctypes 형</th>
<th class="head">C 형</th>
<th class="head">파이썬 형</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_bool" title="ctypes.c_bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_bool</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">_Bool</span></code></td>
<td>bool (1)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code></td>
<td>1-문자 바이트열 객체</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code></td>
<td>1-문자 문자열</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_byte</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ubyte</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_short</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">short</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ushort</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">long</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulong</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longlong</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">__int64</span></code> 나 <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulonglong</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">__int64</span></code> 나 <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_size_t" title="ctypes.c_size_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_size_t</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code></td>
<td>int</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_ssize_t" title="ctypes.c_ssize_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ssize_t</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">ssize_t</span></code> 나 <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></td>
<td>int</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_float" title="ctypes.c_float"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_float</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">float</span></code></td>
<td>float</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">double</span></code></td>
<td>float</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_longdouble" title="ctypes.c_longdouble"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longdouble</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">double</span></code></td>
<td>float</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> (NUL 종료됨)</td>
<td>바이트열 객체나 <code class="docutils literal notranslate"><span class="pre">None</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar_p</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span> <span class="pre">*</span></code> (NUL 종료됨)</td>
<td>문자열이나 <code class="docutils literal notranslate"><span class="pre">None</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a></td>
<td><code class="xref c c-type docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code></td>
<td>int 나 <code class="docutils literal notranslate"><span class="pre">None</span></code></td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li>생성자는 논릿값을 가진 모든 객체를 받아들입니다.</li>
</ol>
<p>이 모든 형은 올바른 형과 값의 선택적 초기화자로 호출해서 만들어질 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c_int</span><span class="p">()</span>
<span class="go">c_long(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_wchar_p</span><span class="p">(</span><span class="s2">&quot;Hello, World&quot;</span><span class="p">)</span>
<span class="go">c_wchar_p(140018365411392)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_ushort</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">c_ushort(65533)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>이러한 형은 가변이므로, 값을 나중에 변경할 수도 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(42)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">-99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>, <a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar_p</span></code></a> 및 <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a> 포인터 형의 인스턴스에 새 값을 대입하면 포인터가 가리키는 <em>메모리 위치</em>가 변경됩니다, 메모리 블록의 <em>내용이 아닙니다</em> (당연히 아닙니다, 파이썬 바이트열 객체는 불변입니다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hello, World&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span> <span class="o">=</span> <span class="n">c_wchar_p</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>
<span class="go">c_wchar_p(139966785747344)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hello World</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;Hi, there&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>              <span class="c1"># 메모리 위치가 변경되었습니다</span>
<span class="go">c_wchar_p(139966783348904)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hi, there</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>                <span class="c1"># 원래 객체는 변경되지 않습니다</span>
<span class="go">Hello, World</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>그러나, 이 것들을 가변 메모리에 대한 포인터를 예상하는 함수에 전달하지 않도록 주의해야합니다. 가변 메모리 블록이 필요하다면, ctypes에는 다양한 방법으로 이를 만드는 <a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> 함수가 있습니다. 현재 메모리 블록 내용은 <code class="docutils literal notranslate"><span class="pre">raw</span></code> 프로퍼티를 사용하여 액세스(또는 변경)할 수 있습니다; NUL 종료 문자열로 액세스하려면 <code class="docutils literal notranslate"><span class="pre">value</span></code> 프로퍼티를 사용하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>            <span class="c1"># 3바이트 버퍼를 만들고, NUL 바이트로 초기화합니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">3 b&#39;\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>     <span class="c1"># NUL 종료 문자열을 포함하는 버퍼를 만듭니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">6 b&#39;Hello\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">b&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># 10바이트 버퍼를 만듭니다</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hello\x00\x00\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hi\x00lo\x00\x00\x00\x00\x00&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">NUL 종료 문자열로 액세스한다는 것은 메모리의 내용을 NULL 종료 문자열로 해석한다는 뜻입니다. 따라서,
<code class="docutils literal notranslate"><span class="pre">value</span></code> 프로퍼티는 문자열의 끝을 나타내는 NULL 을 포함하지 않는 바이트열을 줍니다. 반면, 임의의 메모리
블록으로 해석하는 <code class="docutils literal notranslate"><span class="pre">raw</span></code> 프로퍼티는 메모리에 담긴 모든 바이트를 제공하기 때문에, NUL을 포함하는 바이트열을
돌려줍니다.</p>
</div>
<p><a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> 함수는 이전 ctypes 배포에 있는 <code class="xref py py-func docutils literal notranslate"><span class="pre">c_string()</span></code> 함수뿐만 아니라 <code class="xref py py-func docutils literal notranslate"><span class="pre">c_buffer()</span></code> 함수(아직 별칭으로 사용할 수 있습니다)를 대체합니다. C 형 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code>의 유니코드 문자를 포함하는 가변 메모리 블록을 생성하려면 <a class="reference internal" href="#ctypes.create_unicode_buffer" title="ctypes.create_unicode_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_unicode_buffer()</span></code></a> 함수를 사용하십시오.</p>
</div>
<div class="section" id="calling-functions-continued">
<span id="ctypes-calling-functions-continued"></span><h3>함수 호출하기, 계속<a class="headerlink" href="#calling-functions-continued" title="제목 주소">¶</a></h3>
<p>printf는 <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>이 <em>아니라</em> 실제 표준 출력으로 인쇄하므로, 이 예제는 콘솔 프롬프트에서만 작동하고 <em>IDLE</em> 이나 <em>PythonWin</em>에서는 작동하지 않음에 유의하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, %S</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mf">42.5</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: exceptions.TypeError: Don&#39;t know how to convert parameter 2</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>이전에 언급했듯이, 정수, 문자열 및 바이트열 객체를 제외한 모든 파이썬 형은 필요한 C 데이터 형으로 변환 될 수 있도록 해당하는 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 형으로 래핑되어야합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;An int </span><span class="si">%d</span><span class="s2">, a double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="mf">3.14</span><span class="p">))</span>
<span class="go">An int 1234, a double 3.140000</span>
<span class="go">31</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="calling-functions-with-your-own-custom-data-types">
<span id="ctypes-calling-functions-with-own-custom-data-types"></span><h3>사용자 정의 데이터형을 사용하여 함수 호출하기<a class="headerlink" href="#calling-functions-with-your-own-custom-data-types" title="제목 주소">¶</a></h3>
<p>또한 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 인자 변환을 사용자 정의하여 사용자 고유 클래스의 인스턴스를 함수 인자로 사용할 수 있습니다. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 어트리뷰트를 찾고, 이를 함수 인자로 사용합니다. 물론 정수, 문자열 또는 바이트열 중 하나 여야합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bottles</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_as_parameter_</span> <span class="o">=</span> <span class="n">number</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bottles</span> <span class="o">=</span> <span class="n">Bottles</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bottles</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 인스턴스 변수에 인스턴스의 데이터를 저장하지 않으려면, <a class="reference internal" href="functions.html#property" title="property"><code class="xref py py-class docutils literal notranslate"><span class="pre">property</span></code></a>를 정의하여 요청시 어트리뷰트를 사용할 수있게 할 수 있습니다.</p>
</div>
<div class="section" id="specifying-the-required-argument-types-function-prototypes">
<span id="ctypes-specifying-required-argument-types"></span><h3>필수 인자 형 (함수 프로토타입) 지정하기<a class="headerlink" href="#specifying-the-required-argument-types-function-prototypes" title="제목 주소">¶</a></h3>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 어트리뷰트를 설정하여 DLL에서 내 보낸 함수의 필수 인자 형을 지정할 수 있습니다.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code>는 C 데이터 형의 시퀀스 여야합니다 (<code class="docutils literal notranslate"><span class="pre">printf</span></code> 함수는 포맷 문자열에 따라 개수와 형이 다른 매개 변수를 받아들이기 때문에, 여기서는 좋은 예가 아닐 수 있습니다. 반면에 이 기능을 실험하기에 매우 편리하기도 합니다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">c_double</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;String &#39;</span><span class="si">%s</span><span class="s2">&#39;, Int </span><span class="si">%d</span><span class="s2">, Double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">)</span>
<span class="go">String &#39;Hi&#39;, Int 10, Double 2.200000</span>
<span class="go">37</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>포맷을 지정하면 호환되지 않는 인자 형으로 부터 보호하고(C 함수의 프로토타입 처럼), 유효한 형으로 인자를 변환하려고 시도합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: exceptions.TypeError: wrong type</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">X 2 3.000000</span>
<span class="go">13</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>함수 호출에 전달하는 여러분 자신의 클래스를 정의했으면, <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 시퀀스에서 해당 클래스를 사용할 수 있도록, <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> 클래스 메서드를 구현해야합니다. <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> 클래스 메서드는 함수 호출에 전달 된 파이썬 객체를받습니다. 형 검사나 이 객체가 수용 가능한지 확인하는 데 필요한 모든 작업을 수행 한 다음, 객체 자체나 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 어트리뷰트나 무엇이건 이 경우에 C 함수 인자로 전달되길 원하는 것을 반환해야합니다. 다시 말하지만, 결과는 정수, 문자열, 바이트열, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 인스턴스 또는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 어트리뷰트가 있는 객체 여야 합니다.</p>
</div>
<div class="section" id="return-types">
<span id="ctypes-return-types"></span><h3>반환 형<a class="headerlink" href="#return-types" title="제목 주소">¶</a></h3>
<p>기본적으로 함수는 C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> 형을 반환한다고 가정합니다. 다른 반환 형은 함수 객체의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 어트리뷰트를 설정하여 지정할 수 있습니다.</p>
<p>다음은 더 고급 예제입니다. <code class="docutils literal notranslate"><span class="pre">strchr</span></code> 함수를 사용하는데, 문자열 포인터와 char을 기대하고, 문자열에 대한 포인터를 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">strchr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>  
<span class="go">8059983</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>    <span class="c1"># c_char_p is a pointer to a string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>
<span class="go">b&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)))</span>
<span class="go">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>위의 <code class="docutils literal notranslate"><span class="pre">ord(&quot;x&quot;)</span></code> 호출을 피하려면, <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 어트리뷰트를 설정할 수 있으며, 두 번째 인자는 한글자 파이썬 바이트열 객체에서 C char 로 변환됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;def&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: exceptions.TypeError: one character string expected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>외부 함수가 정수를 반환하면, 콜러블 파이썬 객체(예를 들어, 함수나 클래스)를 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 어트리뷰트로 사용할 수도 있습니다. 콜러블은 C 함수가 리턴하는 <em>정수</em>로 호출되며, 이 호출의 결과는 함수 호출의 결과로 사용됩니다. 이것은 에러 반환 값을 검사하고 자동으로 예외를 발생시키는 데 유용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span> <span class="o">=</span> <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">ValidHandle</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">value</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ValidHandle</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  
<span class="go">486539264</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="s2">&quot;something silly&quot;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n">ValidHandle</span>
<span class="gr">OSError</span>: <span class="n">[Errno 126] The specified module could not be found.</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">WinError</span></code>는 윈도우 <code class="docutils literal notranslate"><span class="pre">FormatMessage()</span></code> api를 호출하여 에러 코드의 문자열 표현을 가져오고, 예외를 <em>반환하는</em> 함수입니다. <code class="docutils literal notranslate"><span class="pre">WinError</span></code>는 선택적 에러 코드 매개 변수를 취합니다, 제공하지 않으면 <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a>를 호출하여 에러 코드를 가져옵니다.</p>
<p>훨씬 더 강력한 에러 검사 메커니즘을 <code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code> 어트리뷰트를 통해 사용할 수 있음에 유의하십시오; 자세한 내용은 레퍼런스 설명서를 참조하십시오.</p>
</div>
<div class="section" id="passing-pointers-or-passing-parameters-by-reference">
<span id="ctypes-passing-pointers"></span><h3>포인터 전달하기 (또는: 참조로 매개 변수 전달하기)<a class="headerlink" href="#passing-pointers-or-passing-parameters-by-reference" title="제목 주소">¶</a></h3>
<p>때때로 C api 함수는 매개 변수로 데이터 형을 가리키는 <em>포인터</em>를 기대합니다, 아마도 해당 위치에 쓰기 위해서, 또는 데이터가 너무 커서 값으로 전달할 수 없어서. 이것은 <em>참조로 매개 변수 전달하기</em>로 알려져 있기도 합니다.</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 매개 변수를 참조로 전달하는 데 사용되는 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> 함수를 내 보냅니다. 같은 효과를 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 함수로도 얻을 수 있습니다. 하지만 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a>는 실제 포인터 객체를 생성하기 때문에 더 많은 작업을 수행하므로, 파이썬 자체에서 포인터 객체가 필요하지 않으면 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a>를 사용하는 것이 더 빠릅니다.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">c_float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\000</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">0 0.0 b&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">sscanf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;1 3.14 Hello&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">byref</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">byref</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">s</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">1 3.1400001049 b&#39;Hello&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="structures-and-unions">
<span id="ctypes-structures-unions"></span><h3>구조체와 공용체<a class="headerlink" href="#structures-and-unions" title="제목 주소">¶</a></h3>
<p>구조체와 공용체는 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 모듈에 정의 된 <a class="reference internal" href="#ctypes.Structure" title="ctypes.Structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Structure</span></code></a> 와 <a class="reference internal" href="#ctypes.Union" title="ctypes.Union"><code class="xref py py-class docutils literal notranslate"><span class="pre">Union</span></code></a> 베이스 클래스에서 파생되어야합니다. 각 서브 클래스는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 어트리뷰트를 정의해야합니다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code>는 <em>필드 이름</em> 과 <em>필드 형</em>을 포함하는 <em>2-튜플</em>의 리스트여야합니다.</p>
<p>필드 형은 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>와 같은 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 형이거나 다른 파생된 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 형(구조체, 공용체, 배열, 포인터)이어야합니다.</p>
<p>다음은 <em>x</em> 및 <em>y</em>라는 두 개의 정수가 포함 된 POINT 구조체의 간단한 예제이며, 생성자에서 구조체를 초기화하는 방법도 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">10 20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">too many initializers</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>그러나, 훨씬 복잡한 구조를 만들 수 있습니다. 구조체는 필드 형으로 구조체를 사용하여 다른 구조체를 포함 할 수 있습니다.</p>
<p>다음은 <em>upperleft</em> 및 <em>lowerright</em>라는 두 개의 POINT를 포함하는 RECT 구조체입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;upperleft&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;lowerright&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>중첩된 구조체는 여러 가지 방법으로 생성자에서 초기화 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>필드 <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">디스크립터</span></a>는 <em>클래스</em>에서 조회할 수 있습니다. 유용한 정보를 제공 할 수 있기 때문에 디버깅에 유용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">POINT</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0, size=4&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">POINT</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=4, size=4&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition warning" id="ctypes-structureunion-alignment-byte-order">
<p class="first admonition-title">경고</p>
<p class="last"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 비트 필드가 있는 공용체나 구조체를 값으로 함수에 전달할 수 없습니다. 32비트 x86에서 작동할 수 있지만, 일반적으로 작동은 라이브러리가 보증하지 않습니다. 비트 필드가 있는 공용체와 구조체는 항상 포인터로 함수에 전달되어야합니다.</p>
</div>
</div>
<div class="section" id="structure-union-alignment-and-byte-order">
<h3>구조체/공용체 정렬과 바이트 순서<a class="headerlink" href="#structure-union-alignment-and-byte-order" title="제목 주소">¶</a></h3>
<p>기본적으로, Structure와 Union 필드는 C 컴파일러와 같은 방식으로 정렬됩니다. 서브 클래스 정의에서 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code> 클래스 어트리뷰트를 지정하면, 이 동작을 재정의할 수 있습니다. 이 값은 양의 정수로 설정해야하고, 필드의 최대 정렬을 지정합니다. 이것은 MSVC에서 <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">pack(n)</span></code>가 수행하는 것입니다.</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>는 구조체와 공용체에 기본(native) 바이트 순서를 사용합니다. 기본이 아닌 바이트 순서로 구조체를 만들려면 <a class="reference internal" href="#ctypes.BigEndianStructure" title="ctypes.BigEndianStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">BigEndianStructure</span></code></a>, <a class="reference internal" href="#ctypes.LittleEndianStructure" title="ctypes.LittleEndianStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">LittleEndianStructure</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BigEndianUnion</span></code> 및 <code class="xref py py-class docutils literal notranslate"><span class="pre">LittleEndianUnion</span></code> 베이스 클래스 중 하나를 사용할 수 있습니다. 이러한 클래스들은 포인터 필드를 포함 할 수 없습니다.</p>
</div>
<div class="section" id="bit-fields-in-structures-and-unions">
<span id="ctypes-bit-fields-in-structures-unions"></span><h3>구조체와 공용체의 비트 필드<a class="headerlink" href="#bit-fields-in-structures-and-unions" title="제목 주소">¶</a></h3>
<p>비트 필드를 포함하는 구조체와 공용체를 만드는 것이 가능합니다. 비트 필드는 정수 필드에만 가능하며, 비트 폭은 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 튜플의 세 번째 항목으로 지정됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Int</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;first_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;second_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">first_16</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0:0, bits=16&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">second_16</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0:16, bits=16&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="arrays">
<span id="ctypes-arrays"></span><h3>배열<a class="headerlink" href="#arrays" title="제목 주소">¶</a></h3>
<p>배열은 같은 형의 고정 된 수의 인스턴스를 포함하는 시퀀스입니다.</p>
<p>배열 형을 만드는 데 권장되는 방법은 데이터 형에 양의 정수를 곱하는 것입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">TenPointsArrayType</span> <span class="o">=</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">10</span>
</pre></div>
</div>
<p>Here is an example of a somewhat artificial data type, a structure containing 4
POINTs among other stuff:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyStruct</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">c_float</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;point_array&quot;</span><span class="p">,</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">()</span><span class="o">.</span><span class="n">point_array</span><span class="p">))</span>
<span class="go">4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Instances are created in the usual way, by calling the class:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="n">TenPointsArrayType</span><span class="p">()</span>
<span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>The above code print a series of <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">0</span></code> lines, because the array contents is
initialized to zeros.</p>
<p>Initializers of the correct type can also be specified:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TenIntegers</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">TenIntegers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
<span class="go">&lt;c_long_Array_10 object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ii</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 2 3 4 5 6 7 8 9 10</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="pointers">
<span id="ctypes-pointers"></span><h3>Pointers<a class="headerlink" href="#pointers" title="제목 주소">¶</a></h3>
<p>Pointer instances are created by calling the <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> function on a
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> type:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Pointer instances have a <a class="reference internal" href="#ctypes._Pointer.contents" title="ctypes._Pointer.contents"><code class="xref py py-attr docutils literal notranslate"><span class="pre">contents</span></code></a> attribute which
returns the object to which the pointer points, the <code class="docutils literal notranslate"><span class="pre">i</span></code> object above:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(42)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> does not have OOR (original object return), it constructs a
new, equivalent object each time you retrieve an attribute:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">i</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Assigning another <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> instance to the pointer's contents attribute
would cause the pointer to point to the memory location where this is stored:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(99)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Pointer instances can also be indexed with integers:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Assigning to an integer index changes the pointed to value:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(99)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">22</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(22)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>It is also possible to use indexes different from 0, but you must know what
you're doing, just as in C: You can access or change arbitrary memory locations.
Generally you only use this feature if you receive a pointer from a C function,
and you <em>know</em> that the pointer actually points to an array instead of a single
item.</p>
<p>Behind the scenes, the <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> function does more than simply create
pointer instances, it has to create pointer <em>types</em> first. This is done with the
<a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a> function, which accepts any <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> type, and returns a
new type:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span>
<span class="go">&lt;class &#39;ctypes.LP_c_long&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">expected c_long instead of int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at 0x...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Calling the pointer type without an argument creates a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer.
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointers have a <code class="docutils literal notranslate"><span class="pre">False</span></code> boolean value:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">null_ptr</span><span class="p">))</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> checks for <code class="docutils literal notranslate"><span class="pre">NULL</span></code> when dereferencing pointers (but dereferencing
invalid non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointers would crash Python):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="type-conversions">
<span id="ctypes-type-conversions"></span><h3>Type conversions<a class="headerlink" href="#type-conversions" title="제목 주소">¶</a></h3>
<p>Usually, ctypes does strict type checking.  This means, if you have
<code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> list of a function or as the type of
a member field in a structure definition, only instances of exactly the same
type are accepted.  There are some exceptions to this rule, where ctypes accepts
other objects.  For example, you can pass compatible array instances instead of
pointer types.  So, for <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code>, ctypes accepts an array of c_int:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_int</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>In addition, if a function argument is explicitly declared to be a pointer type
(such as <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code>) in <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code>, an object of the pointed
type (<code class="docutils literal notranslate"><span class="pre">c_int</span></code> in this case) can be passed to the function.  ctypes will apply
the required <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> conversion in this case automatically.</p>
<p>To set a POINTER type field to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, you can assign <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="kc">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Sometimes you have instances of incompatible types.  In C, you can cast one type
into another type.  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> provides a <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> function which can be
used in the same way.  The <code class="docutils literal notranslate"><span class="pre">Bar</span></code> structure defined above accepts
<code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> pointers or <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> arrays for its <code class="docutils literal notranslate"><span class="pre">values</span></code> field,
but not instances of other types:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">incompatible types, c_byte_Array_4 instance instead of LP_c_long instance</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>For these cases, the <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> function is handy.</p>
<p>The <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> function can be used to cast a ctypes instance into a pointer
to a different ctypes data type.  <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> takes two parameters, a ctypes
object that is or can be converted to a pointer of some kind, and a ctypes
pointer type.  It returns an instance of the second argument, which references
the same memory block as the first argument:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at ...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>So, <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> can be used to assign to the <code class="docutils literal notranslate"><span class="pre">values</span></code> field of <code class="docutils literal notranslate"><span class="pre">Bar</span></code> the
structure:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">((</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)(),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="incomplete-types">
<span id="ctypes-incomplete-types"></span><h3>Incomplete Types<a class="headerlink" href="#incomplete-types" title="제목 주소">¶</a></h3>
<p><em>Incomplete Types</em> are structures, unions or arrays whose members are not yet
specified. In C, they are specified by forward declarations, which are defined
later:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">cell</span><span class="p">;</span> <span class="o">/*</span> <span class="n">forward</span> <span class="n">declaration</span> <span class="o">*/</span>

<span class="n">struct</span> <span class="n">cell</span> <span class="p">{</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="n">struct</span> <span class="n">cell</span> <span class="o">*</span><span class="nb">next</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The straightforward translation into ctypes code would be this, but it does not
work:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">cell</span>
<span class="gr">NameError</span>: <span class="n">name &#39;cell&#39; is not defined</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>because the new <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">cell</span></code> is not available in the class statement itself.
In <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>, we can define the <code class="docutils literal notranslate"><span class="pre">cell</span></code> class and set the <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code>
attribute later, after the class statement:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Lets try it. We create two instances of <code class="docutils literal notranslate"><span class="pre">cell</span></code>, and let them point to each
other, and finally follow the pointer chain a few times:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;bar&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">c1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">foo bar foo bar foo bar foo bar</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="callback-functions">
<span id="ctypes-callback-functions"></span><h3>Callback functions<a class="headerlink" href="#callback-functions" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> allows creating C callable function pointers from Python callables.
These are sometimes called <em>callback functions</em>.</p>
<p>First, you must create a class for the callback function. The class knows the
calling convention, the return type, and the number and types of arguments this
function will receive.</p>
<p>The <a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a> factory function creates types for callback functions
using the <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> calling convention. On Windows, the <a class="reference internal" href="#ctypes.WINFUNCTYPE" title="ctypes.WINFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">WINFUNCTYPE()</span></code></a>
factory function creates types for callback functions using the <code class="docutils literal notranslate"><span class="pre">stdcall</span></code>
calling convention.</p>
<p>Both of these factory functions are called with the result type as first
argument, and the callback functions expected argument types as the remaining
arguments.</p>
<p>I will present an example here which uses the standard C library's
<code class="xref c c-func docutils literal notranslate"><span class="pre">qsort()</span></code> function, that is used to sort items with the help of a callback
function.  <code class="xref c c-func docutils literal notranslate"><span class="pre">qsort()</span></code> will be used to sort an array of integers:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">IntArray5</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ia</span> <span class="o">=</span> <span class="n">IntArray5</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">qsort</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">qsort()</span></code> must be called with a pointer to the data to sort, the number of
items in the data array, the size of one item, and a pointer to the comparison
function, the callback. The callback will then be called with two pointers to
items, and it must return a negative integer if the first item is smaller than
the second, a zero if they are equal, and a positive integer otherwise.</p>
<p>So our callback function receives pointers to integers, and must return an
integer. First we create the <code class="docutils literal notranslate"><span class="pre">type</span></code> for the callback function:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CMPFUNC</span> <span class="o">=</span> <span class="n">CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>To get started, here is a simple callback that shows the values it gets
passed:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">0</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmp_func</span> <span class="o">=</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>The result:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">cmp_func</span><span class="p">)</span>  
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Now we can actually compare the two items and return a useful result:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">))</span> 
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>As we can easily check, our array is sorted now:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ia</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 5 7 33 99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>The function factories can be used as decorator factories, so we may as well
write:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p>Make sure you keep references to <a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a> objects as long as they
are used from C code. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> doesn't, and if you don't, they may be
garbage collected, crashing your program when a callback is made.</p>
<p class="last">Also, note that if the callback function is called in a thread created
outside of Python's control (e.g. by the foreign code that calls the
callback), ctypes creates a new dummy Python thread on every invocation. This
behavior is correct for most purposes, but it means that values stored with
<a class="reference internal" href="threading.html#threading.local" title="threading.local"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.local</span></code></a> will <em>not</em> survive across different callbacks, even when
those calls are made from the same C thread.</p>
</div>
</div>
<div class="section" id="accessing-values-exported-from-dlls">
<span id="ctypes-accessing-values-exported-from-dlls"></span><h3>Accessing values exported from dlls<a class="headerlink" href="#accessing-values-exported-from-dlls" title="제목 주소">¶</a></h3>
<p>Some shared libraries not only export functions, they also export variables. An
example in the Python library itself is the <a class="reference internal" href="../c-api/init.html#c.Py_OptimizeFlag" title="Py_OptimizeFlag"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_OptimizeFlag</span></code></a>, an integer
set to 0, 1, or 2, depending on the <a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> or <a class="reference internal" href="../using/cmdline.html#cmdoption-oo"><code class="xref std std-option docutils literal notranslate"><span class="pre">-OO</span></code></a> flag given on
startup.</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> can access values like this with the <code class="xref py py-meth docutils literal notranslate"><span class="pre">in_dll()</span></code> class methods of
the type.  <em>pythonapi</em> is a predefined symbol giving access to the Python C
api:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">opt_flag</span> <span class="o">=</span> <span class="n">c_int</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;Py_OptimizeFlag&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">opt_flag</span><span class="p">)</span>
<span class="go">c_long(0)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>If the interpreter would have been started with <a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a>, the sample would
have printed <code class="docutils literal notranslate"><span class="pre">c_long(1)</span></code>, or <code class="docutils literal notranslate"><span class="pre">c_long(2)</span></code> if <a class="reference internal" href="../using/cmdline.html#cmdoption-oo"><code class="xref std std-option docutils literal notranslate"><span class="pre">-OO</span></code></a> would have been
specified.</p>
<p>An extended example which also demonstrates the use of pointers accesses the
<a class="reference internal" href="../c-api/import.html#c.PyImport_FrozenModules" title="PyImport_FrozenModules"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyImport_FrozenModules</span></code></a> pointer exported by Python.</p>
<p>Quoting the docs for that value:</p>
<blockquote>
<div>This pointer is initialized to point to an array of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">_frozen</span></code>
records, terminated by one whose members are all <em>NULL</em> or zero.  When a frozen
module is imported, it is searched in this table.  Third-party code could play
tricks with this to provide a dynamically created collection of frozen modules.</div></blockquote>
<p>So manipulating this pointer could even prove useful. To restrict the example
size, we show only how this table can be read with <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">struct_frozen</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;code&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_ubyte</span><span class="p">)),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>We have defined the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">_frozen</span></code> data type, so we can get the pointer
to the table:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">FrozenTable</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">struct_frozen</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">FrozenTable</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;PyImport_FrozenModules&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">table</span></code> is a <code class="docutils literal notranslate"><span class="pre">pointer</span></code> to the array of <code class="docutils literal notranslate"><span class="pre">struct_frozen</span></code> records, we
can iterate over it, but we just have to make sure that our loop terminates,
because pointers have no size. Sooner or later it would probably crash with an
access violation or whatever, so it's better to break out of the loop when we
hit the NULL entry:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">break</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">),</span> <span class="n">item</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">_frozen_importlib 31764</span>
<span class="go">_frozen_importlib_external 41499</span>
<span class="go">__hello__ 161</span>
<span class="go">__phello__ -161</span>
<span class="go">__phello__.spam 161</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>The fact that standard Python has a frozen module and a frozen package
(indicated by the negative size member) is not well known, it is only used for
testing. Try it out with <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">__hello__</span></code> for example.</p>
</div>
<div class="section" id="surprises">
<span id="ctypes-surprises"></span><h3>Surprises<a class="headerlink" href="#surprises" title="제목 주소">¶</a></h3>
<p>There are some edges in <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> where you might expect something other
than what actually happens.</p>
<p>Consider the following example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">1 2 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># now swap the two points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">3 4 3 4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Hm. We certainly expected the last statement to print <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">1</span> <span class="pre">2</span></code>. What
happened? Here are the steps of the <code class="docutils literal notranslate"><span class="pre">rc.a,</span> <span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">rc.b,</span> <span class="pre">rc.a</span></code> line above:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">temp0</span><span class="p">,</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">temp0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">temp0</span></code> and <code class="docutils literal notranslate"><span class="pre">temp1</span></code> are objects still using the internal buffer of
the <code class="docutils literal notranslate"><span class="pre">rc</span></code> object above. So executing <code class="docutils literal notranslate"><span class="pre">rc.a</span> <span class="pre">=</span> <span class="pre">temp0</span></code> copies the buffer
contents of <code class="docutils literal notranslate"><span class="pre">temp0</span></code> into <code class="docutils literal notranslate"><span class="pre">rc</span></code> 's buffer.  This, in turn, changes the
contents of <code class="docutils literal notranslate"><span class="pre">temp1</span></code>. So, the last assignment <code class="docutils literal notranslate"><span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">temp1</span></code>, doesn't have
the expected effect.</p>
<p>Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays
doesn't <em>copy</em> the sub-object, instead it retrieves a wrapper object accessing
the root-object's underlying buffer.</p>
<p>Another example that may behave different from what one would expect is this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">c_char_p</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;abc def ghi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">&#39;abc def ghi&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Why is it printing <code class="docutils literal notranslate"><span class="pre">False</span></code>?  ctypes instances are objects containing a memory
block plus some <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>s accessing the contents of the memory.
Storing a Python object in the memory block does not store the object itself,
instead the <code class="docutils literal notranslate"><span class="pre">contents</span></code> of the object is stored.  Accessing the contents again
constructs a new Python object each time!</p>
</div>
<div class="section" id="variable-sized-data-types">
<span id="ctypes-variable-sized-data-types"></span><h3>Variable-sized data types<a class="headerlink" href="#variable-sized-data-types" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> provides some support for variable-sized arrays and structures.</p>
<p>The <a class="reference internal" href="#ctypes.resize" title="ctypes.resize"><code class="xref py py-func docutils literal notranslate"><span class="pre">resize()</span></code></a> function can be used to resize the memory buffer of an
existing ctypes object.  The function takes the object as first argument, and
the requested size in bytes as the second argument.  The memory block cannot be
made smaller than the natural memory block specified by the objects type, a
<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised if this is tried:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_short</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">minimum size is 8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>This is nice and fine, but how would one access the additional elements
contained in this array?  Since the type still only knows about 4 elements, we
get errors accessing other elements:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[:]</span>
<span class="go">[0, 0, 0, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">IndexError</span>: <span class="n">invalid index</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Another way to use variable-sized data types with <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> is to use the
dynamic nature of Python, and (re-)define the data type after the required size
is already known, on a case by case basis.</p>
</div>
</div>
<div class="section" id="ctypes-reference">
<span id="ctypes-ctypes-reference"></span><h2>ctypes reference<a class="headerlink" href="#ctypes-reference" title="제목 주소">¶</a></h2>
<div class="section" id="finding-shared-libraries">
<span id="ctypes-finding-shared-libraries"></span><h3>Finding shared libraries<a class="headerlink" href="#finding-shared-libraries" title="제목 주소">¶</a></h3>
<p>When programming in a compiled language, shared libraries are accessed when
compiling/linking a program, and when the program is run.</p>
<p>The purpose of the <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> function is to locate a library in a way
similar to what the compiler or runtime loader does (on platforms with several
versions of a shared library the most recent should be loaded), while the ctypes
library loaders act like when a program is run, and call the runtime loader
directly.</p>
<p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.util</span></code> module provides a function which can help to determine
the library to load.</p>
<dl class="data">
<dt>
<code class="descclassname">ctypes.util.</code><code class="descname">find_library</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></dt>
<dd><p>Try to find a library and return a pathname.  <em>name</em> is the library name without
any prefix like <em>lib</em>, suffix like <code class="docutils literal notranslate"><span class="pre">.so</span></code>, <code class="docutils literal notranslate"><span class="pre">.dylib</span></code> or version number (this
is the form used for the posix linker option <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code>).  If no library can
be found, returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<p>The exact functionality is system dependent.</p>
<p>On Linux, <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> tries to run external programs
(<code class="docutils literal notranslate"><span class="pre">/sbin/ldconfig</span></code>, <code class="docutils literal notranslate"><span class="pre">gcc</span></code>, <code class="docutils literal notranslate"><span class="pre">objdump</span></code> and <code class="docutils literal notranslate"><span class="pre">ld</span></code>) to find the library file.
It returns the filename of the library file.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>On Linux, the value of the environment variable <code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> is used
when searching for libraries, if a library cannot be found by any other means.</p>
</div>
<p>Here are some examples:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="k">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;libm.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;libc.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;libbz2.so.1.0&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>On OS X, <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> tries several predefined naming schemes and paths
to locate the library, and returns a full pathname if successful:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="k">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libc.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libm.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libbz2.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;AGL&quot;</span><span class="p">)</span>
<span class="go">&#39;/System/Library/Frameworks/AGL.framework/AGL&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>On Windows, <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> searches along the system search path, and
returns the full pathname, but since there is no predefined naming scheme a call
like <code class="docutils literal notranslate"><span class="pre">find_library(&quot;c&quot;)</span></code> will fail and return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>If wrapping a shared library with <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>, it <em>may</em> be better to determine
the shared library name at development time, and hardcode that into the wrapper
module instead of using <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> to locate the library at runtime.</p>
</div>
<div class="section" id="loading-shared-libraries">
<span id="ctypes-loading-shared-libraries"></span><h3>Loading shared libraries<a class="headerlink" href="#loading-shared-libraries" title="제목 주소">¶</a></h3>
<p>There are several ways to load shared libraries into the Python process.  One
way is to instantiate one of the following classes:</p>
<dl class="class">
<dt id="ctypes.CDLL">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">CDLL</code><span class="sig-paren">(</span><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CDLL" title="정의 주소">¶</a></dt>
<dd><p>Instances of this class represent loaded shared libraries. Functions in these
libraries use the standard C calling convention, and are assumed to return
<code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.OleDLL">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">OleDLL</code><span class="sig-paren">(</span><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.OleDLL" title="정의 주소">¶</a></dt>
<dd><p>Windows only: Instances of this class represent loaded shared libraries,
functions in these libraries use the <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> calling convention, and are
assumed to return the windows specific <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><code class="xref py py-class docutils literal notranslate"><span class="pre">HRESULT</span></code></a> code.  <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><code class="xref py py-class docutils literal notranslate"><span class="pre">HRESULT</span></code></a>
values contain information specifying whether the function call failed or
succeeded, together with additional error code.  If the return value signals a
failure, an <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> is automatically raised.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a> used to be raised.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="ctypes.WinDLL">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">WinDLL</code><span class="sig-paren">(</span><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinDLL" title="정의 주소">¶</a></dt>
<dd><p>Windows only: Instances of this class represent loaded shared libraries,
functions in these libraries use the <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> calling convention, and are
assumed to return <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> by default.</p>
<p>On Windows CE only the standard calling convention is used, for convenience the
<a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a> and <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a> use the standard calling convention on this
platform.</p>
</dd></dl>

<p>The Python <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a> is released before calling any
function exported by these libraries, and reacquired afterwards.</p>
<dl class="class">
<dt id="ctypes.PyDLL">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">PyDLL</code><span class="sig-paren">(</span><em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PyDLL" title="정의 주소">¶</a></dt>
<dd><p>Instances of this class behave like <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> instances, except that the
Python GIL is <em>not</em> released during the function call, and after the function
execution the Python error flag is checked. If the error flag is set, a Python
exception is raised.</p>
<p>Thus, this is only useful to call Python C api functions directly.</p>
</dd></dl>

<p>All these classes can be instantiated by calling them with at least one
argument, the pathname of the shared library.  If you have an existing handle to
an already loaded shared library, it can be passed as the <code class="docutils literal notranslate"><span class="pre">handle</span></code> named
parameter, otherwise the underlying platforms <code class="docutils literal notranslate"><span class="pre">dlopen</span></code> or <code class="docutils literal notranslate"><span class="pre">LoadLibrary</span></code>
function is used to load the library into the process, and to get a handle to
it.</p>
<p>The <em>mode</em> parameter can be used to specify how the library is loaded.  For
details, consult the <em class="manpage">dlopen(3)</em> manpage.  On Windows, <em>mode</em> is
ignored.  On posix systems, RTLD_NOW is always added, and is not
configurable.</p>
<p>The <em>use_errno</em> parameter, when set to true, enables a ctypes mechanism that
allows accessing the system <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> error number in a safe way.
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> maintains a thread-local copy of the systems <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a>
variable; if you call foreign functions created with <code class="docutils literal notranslate"><span class="pre">use_errno=True</span></code> then the
<a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> value before the function call is swapped with the ctypes private
copy, the same happens immediately after the function call.</p>
<p>The function <a class="reference internal" href="#ctypes.get_errno" title="ctypes.get_errno"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.get_errno()</span></code></a> returns the value of the ctypes private
copy, and the function <a class="reference internal" href="#ctypes.set_errno" title="ctypes.set_errno"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.set_errno()</span></code></a> changes the ctypes private copy
to a new value and returns the former value.</p>
<p>The <em>use_last_error</em> parameter, when set to true, enables the same mechanism for
the Windows error code which is managed by the <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">SetLastError()</span></code> Windows API functions; <a class="reference internal" href="#ctypes.get_last_error" title="ctypes.get_last_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.get_last_error()</span></code></a> and
<a class="reference internal" href="#ctypes.set_last_error" title="ctypes.set_last_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.set_last_error()</span></code></a> are used to request and change the ctypes private
copy of the windows error code.</p>
<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">RTLD_GLOBAL</code></dt>
<dd><p>Flag to use as <em>mode</em> parameter.  On platforms where this flag is not available,
it is defined as the integer zero.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">RTLD_LOCAL</code></dt>
<dd><p>Flag to use as <em>mode</em> parameter.  On platforms where this is not available, it
is the same as <em>RTLD_GLOBAL</em>.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">DEFAULT_MODE</code></dt>
<dd><p>The default mode which is used to load shared libraries.  On OSX 10.3, this is
<em>RTLD_GLOBAL</em>, otherwise it is the same as <em>RTLD_LOCAL</em>.</p>
</dd></dl>

<p>Instances of these classes have no public methods.  Functions exported by the
shared library can be accessed as attributes or by index.  Please note that
accessing the function through an attribute caches the result and therefore
accessing it repeatedly returns the same object each time.  On the other hand,
accessing it through an index returns a new object each time:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">CDLL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>  <span class="c1"># On Linux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">libc</span><span class="o">.</span><span class="n">time</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The following public attributes are available, their name starts with an
underscore to not clash with exported function names:</p>
<dl class="attribute">
<dt id="ctypes.PyDLL._handle">
<code class="descclassname">PyDLL.</code><code class="descname">_handle</code><a class="headerlink" href="#ctypes.PyDLL._handle" title="정의 주소">¶</a></dt>
<dd><p>The system handle used to access the library.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.PyDLL._name">
<code class="descclassname">PyDLL.</code><code class="descname">_name</code><a class="headerlink" href="#ctypes.PyDLL._name" title="정의 주소">¶</a></dt>
<dd><p>The name of the library passed in the constructor.</p>
</dd></dl>

<p>Shared libraries can also be loaded by using one of the prefabricated objects,
which are instances of the <a class="reference internal" href="#ctypes.LibraryLoader" title="ctypes.LibraryLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">LibraryLoader</span></code></a> class, either by calling the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadLibrary()</span></code> method, or by retrieving the library as attribute of the
loader instance.</p>
<dl class="class">
<dt id="ctypes.LibraryLoader">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">LibraryLoader</code><span class="sig-paren">(</span><em>dlltype</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader" title="정의 주소">¶</a></dt>
<dd><p>Class which loads shared libraries.  <em>dlltype</em> should be one of the
<a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a>, <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a>, <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a>, or <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a> types.</p>
<p><a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> has special behavior: It allows loading a shared library by
accessing it as attribute of a library loader instance.  The result is cached,
so repeated attribute accesses return the same library each time.</p>
<dl class="method">
<dt id="ctypes.LibraryLoader.LoadLibrary">
<code class="descname">LoadLibrary</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader.LoadLibrary" title="정의 주소">¶</a></dt>
<dd><p>Load a shared library into the process and return it.  This method always
returns a new instance of the library.</p>
</dd></dl>

</dd></dl>

<p>These prefabricated library loaders are available:</p>
<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">cdll</code></dt>
<dd><p>Creates <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> instances.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">windll</code></dt>
<dd><p>Windows only: Creates <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a> instances.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">oledll</code></dt>
<dd><p>Windows only: Creates <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a> instances.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">pydll</code></dt>
<dd><p>Creates <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a> instances.</p>
</dd></dl>

<p>For accessing the C Python api directly, a ready-to-use Python shared library
object is available:</p>
<dl class="data">
<dt>
<code class="descclassname">ctypes.</code><code class="descname">pythonapi</code></dt>
<dd><p>An instance of <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a> that exposes Python C API functions as
attributes.  Note that all these functions are assumed to return C
<code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>, which is of course not always the truth, so you have to assign
the correct <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> attribute to use these functions.</p>
</dd></dl>

</div>
<div class="section" id="foreign-functions">
<span id="ctypes-foreign-functions"></span><h3>Foreign functions<a class="headerlink" href="#foreign-functions" title="제목 주소">¶</a></h3>
<p>As explained in the previous section, foreign functions can be accessed as
attributes of loaded shared libraries.  The function objects created in this way
by default accept any number of arguments, accept any ctypes data instances as
arguments, and return the default result type specified by the library loader.
They are instances of a private class:</p>
<dl class="class">
<dt id="ctypes._FuncPtr">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">_FuncPtr</code><a class="headerlink" href="#ctypes._FuncPtr" title="정의 주소">¶</a></dt>
<dd><p>Base class for C callable foreign functions.</p>
<p>Instances of foreign functions are also C compatible data types; they
represent C function pointers.</p>
<p>This behavior can be customized by assigning to special attributes of the
foreign function object.</p>
<dl class="attribute">
<dt id="ctypes._FuncPtr.restype">
<code class="descname">restype</code><a class="headerlink" href="#ctypes._FuncPtr.restype" title="정의 주소">¶</a></dt>
<dd><p>Assign a ctypes type to specify the result type of the foreign function.
Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for <code class="xref c c-type docutils literal notranslate"><span class="pre">void</span></code>, a function not returning anything.</p>
<p>It is possible to assign a callable Python object that is not a ctypes
type, in this case the function is assumed to return a C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>, and
the callable will be called with this integer, allowing further
processing or error checking.  Using this is deprecated, for more flexible
post processing or error checking use a ctypes data type as
<a class="reference internal" href="#ctypes._FuncPtr.restype" title="ctypes._FuncPtr.restype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code></a> and assign a callable to the <a class="reference internal" href="#ctypes._FuncPtr.errcheck" title="ctypes._FuncPtr.errcheck"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code></a> attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._FuncPtr.argtypes">
<code class="descname">argtypes</code><a class="headerlink" href="#ctypes._FuncPtr.argtypes" title="정의 주소">¶</a></dt>
<dd><p>Assign a tuple of ctypes types to specify the argument types that the
function accepts.  Functions using the <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> calling convention can
only be called with the same number of arguments as the length of this
tuple; functions using the C calling convention accept additional,
unspecified arguments as well.</p>
<p>When a foreign function is called, each actual argument is passed to the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> class method of the items in the <a class="reference internal" href="#ctypes._FuncPtr.argtypes" title="ctypes._FuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a>
tuple, this method allows adapting the actual argument to an object that
the foreign function accepts.  For example, a <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> item in
the <a class="reference internal" href="#ctypes._FuncPtr.argtypes" title="ctypes._FuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> tuple will convert a string passed as argument into
a bytes object using ctypes conversion rules.</p>
<p>New: It is now possible to put items in argtypes which are not ctypes
types, but each item must have a <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> method which returns a
value usable as argument (integer, string, ctypes instance).  This allows
defining adapters that can adapt custom objects as function parameters.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._FuncPtr.errcheck">
<code class="descname">errcheck</code><a class="headerlink" href="#ctypes._FuncPtr.errcheck" title="정의 주소">¶</a></dt>
<dd><p>Assign a Python function or another callable to this attribute. The
callable will be called with three or more arguments:</p>
<dl class="function">
<dt>
<code class="descname">callable</code><span class="sig-paren">(</span><em>result</em>, <em>func</em>, <em>arguments</em><span class="sig-paren">)</span></dt>
<dd><p><em>result</em> is what the foreign function returns, as specified by the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> attribute.</p>
<p><em>func</em> is the foreign function object itself, this allows reusing the
same callable object to check or post process the results of several
functions.</p>
<p><em>arguments</em> is a tuple containing the parameters originally passed to
the function call, this allows specializing the behavior on the
arguments used.</p>
</dd></dl>

<p>The object that this function returns will be returned from the
foreign function call, but it can also check the result value
and raise an exception if the foreign function call failed.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="ctypes.ArgumentError">
<em class="property">exception </em><code class="descclassname">ctypes.</code><code class="descname">ArgumentError</code><a class="headerlink" href="#ctypes.ArgumentError" title="정의 주소">¶</a></dt>
<dd><p>This exception is raised when a foreign function call cannot convert one of the
passed arguments.</p>
</dd></dl>

</div>
<div class="section" id="function-prototypes">
<span id="ctypes-function-prototypes"></span><h3>Function prototypes<a class="headerlink" href="#function-prototypes" title="제목 주소">¶</a></h3>
<p>Foreign functions can also be created by instantiating function prototypes.
Function prototypes are similar to function prototypes in C; they describe a
function (return type, argument types, calling convention) without defining an
implementation.  The factory functions must be called with the desired result
type and the argument types of the function, and can be used as decorator
factories, and as such, be applied to functions through the <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code> syntax.
See <a class="reference internal" href="#ctypes-callback-functions"><span class="std std-ref">Callback functions</span></a> for examples.</p>
<dl class="function">
<dt id="ctypes.CFUNCTYPE">
<code class="descclassname">ctypes.</code><code class="descname">CFUNCTYPE</code><span class="sig-paren">(</span><em>restype</em>, <em>*argtypes</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CFUNCTYPE" title="정의 주소">¶</a></dt>
<dd><p>The returned function prototype creates functions that use the standard C
calling convention.  The function will release the GIL during the call.  If
<em>use_errno</em> is set to true, the ctypes private copy of the system
<a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> variable is exchanged with the real <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> value before
and after the call; <em>use_last_error</em> does the same for the Windows error
code.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.WINFUNCTYPE">
<code class="descclassname">ctypes.</code><code class="descname">WINFUNCTYPE</code><span class="sig-paren">(</span><em>restype</em>, <em>*argtypes</em>, <em>use_errno=False</em>, <em>use_last_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WINFUNCTYPE" title="정의 주소">¶</a></dt>
<dd><p>Windows only: The returned function prototype creates functions that use the
<code class="docutils literal notranslate"><span class="pre">stdcall</span></code> calling convention, except on Windows CE where
<a class="reference internal" href="#ctypes.WINFUNCTYPE" title="ctypes.WINFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">WINFUNCTYPE()</span></code></a> is the same as <a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a>.  The function will
release the GIL during the call.  <em>use_errno</em> and <em>use_last_error</em> have the
same meaning as above.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.PYFUNCTYPE">
<code class="descclassname">ctypes.</code><code class="descname">PYFUNCTYPE</code><span class="sig-paren">(</span><em>restype</em>, <em>*argtypes</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PYFUNCTYPE" title="정의 주소">¶</a></dt>
<dd><p>The returned function prototype creates functions that use the Python calling
convention.  The function will <em>not</em> release the GIL during the call.</p>
</dd></dl>

<p>Function prototypes created by these factory functions can be instantiated in
different ways, depending on the type and number of the parameters in the call:</p>
<blockquote>
<div><dl class="function">
<dt>
<code class="descname">prototype</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a foreign function at the specified address which must be an integer.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">prototype</code><span class="sig-paren">(</span><em>callable</em><span class="sig-paren">)</span></dt>
<dd><p>Create a C callable function (a callback function) from a Python <em>callable</em>.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">prototype</code><span class="sig-paren">(</span><em>func_spec</em><span class="optional">[</span>, <em>paramflags</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Returns a foreign function exported by a shared library. <em>func_spec</em> must
be a 2-tuple <code class="docutils literal notranslate"><span class="pre">(name_or_ordinal,</span> <span class="pre">library)</span></code>. The first item is the name of
the exported function as string, or the ordinal of the exported function
as small integer.  The second item is the shared library instance.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descname">prototype</code><span class="sig-paren">(</span><em>vtbl_index</em>, <em>name</em><span class="optional">[</span>, <em>paramflags</em><span class="optional">[</span>, <em>iid</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Returns a foreign function that will call a COM method. <em>vtbl_index</em> is
the index into the virtual function table, a small non-negative
integer. <em>name</em> is name of the COM method. <em>iid</em> is an optional pointer to
the interface identifier which is used in extended error reporting.</p>
<p>COM methods use a special calling convention: They require a pointer to
the COM interface as first argument, in addition to those parameters that
are specified in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> tuple.</p>
</dd></dl>

<p>The optional <em>paramflags</em> parameter creates foreign function wrappers with much
more functionality than the features described above.</p>
<p><em>paramflags</em> must be a tuple of the same length as <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code>.</p>
<p>Each item in this tuple contains further information about a parameter, it must
be a tuple containing one, two, or three items.</p>
<p>The first item is an integer containing a combination of direction
flags for the parameter:</p>
<blockquote>
<div><dl class="docutils">
<dt>1</dt>
<dd>Specifies an input parameter to the function.</dd>
<dt>2</dt>
<dd>Output parameter.  The foreign function fills in a value.</dd>
<dt>4</dt>
<dd>Input parameter which defaults to the integer zero.</dd>
</dl>
</div></blockquote>
<p>The optional second item is the parameter name as string.  If this is specified,
the foreign function can be called with named parameters.</p>
<p>The optional third item is the default value for this parameter.</p>
</div></blockquote>
<p>This example demonstrates how to wrap the Windows <code class="docutils literal notranslate"><span class="pre">MessageBoxW</span></code> function so
that it supports default parameters and named arguments. The C declaration from
the windows header file is this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="nb">int</span> <span class="n">WINAPI</span>
<span class="n">MessageBoxW</span><span class="p">(</span>
    <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpText</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpCaption</span><span class="p">,</span>
    <span class="n">UINT</span> <span class="n">uType</span><span class="p">);</span>
</pre></div>
</div>
<p>Here is the wrapping with <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.wintypes</span> <span class="k">import</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;Hi&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;caption&quot;</span><span class="p">,</span> <span class="s2">&quot;Hello from ctypes&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;flags&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;MessageBoxW&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">MessageBox</span></code> foreign function can now be called in these ways:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s2">&quot;Spam, spam, spam&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">&quot;foo bar&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>A second example demonstrates output parameters.  The win32 <code class="docutils literal notranslate"><span class="pre">GetWindowRect</span></code>
function retrieves the dimensions of a specified window by copying them into
<code class="docutils literal notranslate"><span class="pre">RECT</span></code> structure that the caller has to supply.  Here is the C declaration:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="n">BOOL</span> <span class="n">WINAPI</span>
<span class="n">GetWindowRect</span><span class="p">(</span>
     <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
     <span class="n">LPRECT</span> <span class="n">lpRect</span><span class="p">);</span>
</pre></div>
</div>
<p>Here is the wrapping with <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">POINTER</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span><span class="p">,</span> <span class="n">WinError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.wintypes</span> <span class="k">import</span> <span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">RECT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">RECT</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;lprect&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;GetWindowRect&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Functions with output parameters will automatically return the output parameter
value if there is a single one, or a tuple containing the output parameter
values when there are more than one, so the GetWindowRect function now returns a
RECT instance, when called.</p>
<p>Output parameters can be combined with the <code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code> protocol to do
further output processing and error checking.  The win32 <code class="docutils literal notranslate"><span class="pre">GetWindowRect</span></code> api
function returns a <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> to signal success or failure, so this function could
do the error checking, and raises an exception when the api call failed:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">args</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>If the <code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code> function returns the argument tuple it receives
unchanged, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> continues the normal processing it does on the output
parameters.  If you want to return a tuple of window coordinates instead of a
<code class="docutils literal notranslate"><span class="pre">RECT</span></code> instance, you can retrieve the fields in the function and return them
instead, the normal processing will no longer take place:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">rc</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">right</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="utility-functions">
<span id="ctypes-utility-functions"></span><h3>Utility functions<a class="headerlink" href="#utility-functions" title="제목 주소">¶</a></h3>
<dl class="function">
<dt id="ctypes.addressof">
<code class="descclassname">ctypes.</code><code class="descname">addressof</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.addressof" title="정의 주소">¶</a></dt>
<dd><p>Returns the address of the memory buffer as integer.  <em>obj</em> must be an
instance of a ctypes type.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.alignment">
<code class="descclassname">ctypes.</code><code class="descname">alignment</code><span class="sig-paren">(</span><em>obj_or_type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.alignment" title="정의 주소">¶</a></dt>
<dd><p>Returns the alignment requirements of a ctypes type. <em>obj_or_type</em> must be a
ctypes type or instance.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.byref">
<code class="descclassname">ctypes.</code><code class="descname">byref</code><span class="sig-paren">(</span><em>obj</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.byref" title="정의 주소">¶</a></dt>
<dd><p>Returns a light-weight pointer to <em>obj</em>, which must be an instance of a
ctypes type.  <em>offset</em> defaults to zero, and must be an integer that will be
added to the internal pointer value.</p>
<p><code class="docutils literal notranslate"><span class="pre">byref(obj,</span> <span class="pre">offset)</span></code> corresponds to this C code:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<p>The returned object can only be used as a foreign function call parameter.
It behaves similar to <code class="docutils literal notranslate"><span class="pre">pointer(obj)</span></code>, but the construction is a lot faster.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.cast">
<code class="descclassname">ctypes.</code><code class="descname">cast</code><span class="sig-paren">(</span><em>obj</em>, <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.cast" title="정의 주소">¶</a></dt>
<dd><p>This function is similar to the cast operator in C. It returns a new instance
of <em>type</em> which points to the same memory block as <em>obj</em>.  <em>type</em> must be a
pointer type, and <em>obj</em> must be an object that can be interpreted as a
pointer.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.create_string_buffer">
<code class="descclassname">ctypes.</code><code class="descname">create_string_buffer</code><span class="sig-paren">(</span><em>init_or_size</em>, <em>size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_string_buffer" title="정의 주소">¶</a></dt>
<dd><p>This function creates a mutable character buffer. The returned object is a
ctypes array of <a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char</span></code></a>.</p>
<p><em>init_or_size</em> must be an integer which specifies the size of the array, or a
bytes object which will be used to initialize the array items.</p>
<p>If a bytes object is specified as first argument, the buffer is made one item
larger than its length so that the last element in the array is a NUL
termination character. An integer can be passed as second argument which allows
specifying the size of the array if the length of the bytes should not be used.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.create_unicode_buffer">
<code class="descclassname">ctypes.</code><code class="descname">create_unicode_buffer</code><span class="sig-paren">(</span><em>init_or_size</em>, <em>size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_unicode_buffer" title="정의 주소">¶</a></dt>
<dd><p>This function creates a mutable unicode character buffer. The returned object is
a ctypes array of <a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a>.</p>
<p><em>init_or_size</em> must be an integer which specifies the size of the array, or a
string which will be used to initialize the array items.</p>
<p>If a string is specified as first argument, the buffer is made one item
larger than the length of the string so that the last element in the array is a
NUL termination character. An integer can be passed as second argument which
allows specifying the size of the array if the length of the string should not
be used.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.DllCanUnloadNow">
<code class="descclassname">ctypes.</code><code class="descname">DllCanUnloadNow</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllCanUnloadNow" title="정의 주소">¶</a></dt>
<dd><p>Windows only: This function is a hook which allows implementing in-process
COM servers with ctypes.  It is called from the DllCanUnloadNow function that
the _ctypes extension dll exports.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.DllGetClassObject">
<code class="descclassname">ctypes.</code><code class="descname">DllGetClassObject</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllGetClassObject" title="정의 주소">¶</a></dt>
<dd><p>Windows only: This function is a hook which allows implementing in-process
COM servers with ctypes.  It is called from the DllGetClassObject function
that the <code class="docutils literal notranslate"><span class="pre">_ctypes</span></code> extension dll exports.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.util.find_library">
<code class="descclassname">ctypes.util.</code><code class="descname">find_library</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_library" title="정의 주소">¶</a></dt>
<dd><p>Try to find a library and return a pathname.  <em>name</em> is the library name
without any prefix like <code class="docutils literal notranslate"><span class="pre">lib</span></code>, suffix like <code class="docutils literal notranslate"><span class="pre">.so</span></code>, <code class="docutils literal notranslate"><span class="pre">.dylib</span></code> or version
number (this is the form used for the posix linker option <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code>).  If
no library can be found, returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>The exact functionality is system dependent.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.util.find_msvcrt">
<code class="descclassname">ctypes.util.</code><code class="descname">find_msvcrt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_msvcrt" title="정의 주소">¶</a></dt>
<dd><p>Windows only: return the filename of the VC runtime library used by Python,
and by the extension modules.  If the name of the library cannot be
determined, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<p>If you need to free memory, for example, allocated by an extension module
with a call to the <code class="docutils literal notranslate"><span class="pre">free(void</span> <span class="pre">*)</span></code>, it is important that you use the
function in the same library that allocated the memory.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.FormatError">
<code class="descclassname">ctypes.</code><code class="descname">FormatError</code><span class="sig-paren">(</span><span class="optional">[</span><em>code</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.FormatError" title="정의 주소">¶</a></dt>
<dd><p>Windows only: Returns a textual description of the error code <em>code</em>.  If no
error code is specified, the last error code is used by calling the Windows
api function GetLastError.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.GetLastError">
<code class="descclassname">ctypes.</code><code class="descname">GetLastError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.GetLastError" title="정의 주소">¶</a></dt>
<dd><p>Windows only: Returns the last error code set by Windows in the calling thread.
This function calls the Windows <cite>GetLastError()</cite> function directly,
it does not return the ctypes-private copy of the error code.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.get_errno">
<code class="descclassname">ctypes.</code><code class="descname">get_errno</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_errno" title="정의 주소">¶</a></dt>
<dd><p>Returns the current value of the ctypes-private copy of the system
<a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> variable in the calling thread.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.get_last_error">
<code class="descclassname">ctypes.</code><code class="descname">get_last_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_last_error" title="정의 주소">¶</a></dt>
<dd><p>Windows only: returns the current value of the ctypes-private copy of the system
<code class="xref py py-data docutils literal notranslate"><span class="pre">LastError</span></code> variable in the calling thread.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.memmove">
<code class="descclassname">ctypes.</code><code class="descname">memmove</code><span class="sig-paren">(</span><em>dst</em>, <em>src</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memmove" title="정의 주소">¶</a></dt>
<dd><p>Same as the standard C memmove library function: copies <em>count</em> bytes from
<em>src</em> to <em>dst</em>. <em>dst</em> and <em>src</em> must be integers or ctypes instances that can
be converted to pointers.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.memset">
<code class="descclassname">ctypes.</code><code class="descname">memset</code><span class="sig-paren">(</span><em>dst</em>, <em>c</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memset" title="정의 주소">¶</a></dt>
<dd><p>Same as the standard C memset library function: fills the memory block at
address <em>dst</em> with <em>count</em> bytes of value <em>c</em>. <em>dst</em> must be an integer
specifying an address, or a ctypes instance.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.POINTER">
<code class="descclassname">ctypes.</code><code class="descname">POINTER</code><span class="sig-paren">(</span><em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.POINTER" title="정의 주소">¶</a></dt>
<dd><p>This factory function creates and returns a new ctypes pointer type. Pointer
types are cached and reused internally, so calling this function repeatedly is
cheap. <em>type</em> must be a ctypes type.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.pointer">
<code class="descclassname">ctypes.</code><code class="descname">pointer</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.pointer" title="정의 주소">¶</a></dt>
<dd><p>This function creates a new pointer instance, pointing to <em>obj</em>. The returned
object is of the type <code class="docutils literal notranslate"><span class="pre">POINTER(type(obj))</span></code>.</p>
<p>Note: If you just want to pass a pointer to an object to a foreign function
call, you should use <code class="docutils literal notranslate"><span class="pre">byref(obj)</span></code> which is much faster.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.resize">
<code class="descclassname">ctypes.</code><code class="descname">resize</code><span class="sig-paren">(</span><em>obj</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.resize" title="정의 주소">¶</a></dt>
<dd><p>This function resizes the internal memory buffer of <em>obj</em>, which must be an
instance of a ctypes type.  It is not possible to make the buffer smaller
than the native size of the objects type, as given by <code class="docutils literal notranslate"><span class="pre">sizeof(type(obj))</span></code>,
but it is possible to enlarge the buffer.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.set_errno">
<code class="descclassname">ctypes.</code><code class="descname">set_errno</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_errno" title="정의 주소">¶</a></dt>
<dd><p>Set the current value of the ctypes-private copy of the system <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a>
variable in the calling thread to <em>value</em> and return the previous value.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.set_last_error">
<code class="descclassname">ctypes.</code><code class="descname">set_last_error</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_last_error" title="정의 주소">¶</a></dt>
<dd><p>Windows only: set the current value of the ctypes-private copy of the system
<code class="xref py py-data docutils literal notranslate"><span class="pre">LastError</span></code> variable in the calling thread to <em>value</em> and return the
previous value.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.sizeof">
<code class="descclassname">ctypes.</code><code class="descname">sizeof</code><span class="sig-paren">(</span><em>obj_or_type</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.sizeof" title="정의 주소">¶</a></dt>
<dd><p>Returns the size in bytes of a ctypes type or instance memory buffer.
Does the same as the C <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> operator.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.string_at">
<code class="descclassname">ctypes.</code><code class="descname">string_at</code><span class="sig-paren">(</span><em>address</em>, <em>size=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.string_at" title="정의 주소">¶</a></dt>
<dd><p>This function returns the C string starting at memory address <em>address</em> as a bytes
object. If size is specified, it is used as size, otherwise the string is assumed
to be zero-terminated.</p>
</dd></dl>

<dl class="function">
<dt id="ctypes.WinError">
<code class="descclassname">ctypes.</code><code class="descname">WinError</code><span class="sig-paren">(</span><em>code=None</em>, <em>descr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinError" title="정의 주소">¶</a></dt>
<dd><p>Windows only: this function is probably the worst-named thing in ctypes. It
creates an instance of OSError.  If <em>code</em> is not specified,
<code class="docutils literal notranslate"><span class="pre">GetLastError</span></code> is called to determine the error code. If <em>descr</em> is not
specified, <a class="reference internal" href="#ctypes.FormatError" title="ctypes.FormatError"><code class="xref py py-func docutils literal notranslate"><span class="pre">FormatError()</span></code></a> is called to get a textual description of the
error.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>An instance of <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a> used to be created.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ctypes.wstring_at">
<code class="descclassname">ctypes.</code><code class="descname">wstring_at</code><span class="sig-paren">(</span><em>address</em>, <em>size=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.wstring_at" title="정의 주소">¶</a></dt>
<dd><p>This function returns the wide character string starting at memory address
<em>address</em> as a string.  If <em>size</em> is specified, it is used as the number of
characters of the string, otherwise the string is assumed to be
zero-terminated.</p>
</dd></dl>

</div>
<div class="section" id="data-types">
<span id="ctypes-data-types"></span><h3>Data types<a class="headerlink" href="#data-types" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="ctypes._CData">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">_CData</code><a class="headerlink" href="#ctypes._CData" title="정의 주소">¶</a></dt>
<dd><p>This non-public class is the common base class of all ctypes data types.
Among other things, all ctypes type instances contain a memory block that
hold C compatible data; the address of the memory block is returned by the
<a class="reference internal" href="#ctypes.addressof" title="ctypes.addressof"><code class="xref py py-func docutils literal notranslate"><span class="pre">addressof()</span></code></a> helper function. Another instance variable is exposed as
<a class="reference internal" href="#ctypes._CData._objects" title="ctypes._CData._objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_objects</span></code></a>; this contains other Python objects that need to be kept
alive in case the memory block contains pointers.</p>
<p>Common methods of ctypes data types, these are all class methods (to be
exact, they are methods of the <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">metaclass</span></a>):</p>
<dl class="method">
<dt id="ctypes._CData.from_buffer">
<code class="descname">from_buffer</code><span class="sig-paren">(</span><em>source</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer" title="정의 주소">¶</a></dt>
<dd><p>This method returns a ctypes instance that shares the buffer of the
<em>source</em> object.  The <em>source</em> object must support the writeable buffer
interface.  The optional <em>offset</em> parameter specifies an offset into the
source buffer in bytes; the default is zero.  If the source buffer is not
large enough a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised.</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_buffer_copy">
<code class="descname">from_buffer_copy</code><span class="sig-paren">(</span><em>source</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer_copy" title="정의 주소">¶</a></dt>
<dd><p>This method creates a ctypes instance, copying the buffer from the
<em>source</em> object buffer which must be readable.  The optional <em>offset</em>
parameter specifies an offset into the source buffer in bytes; the default
is zero.  If the source buffer is not large enough a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is
raised.</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_address">
<code class="descname">from_address</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_address" title="정의 주소">¶</a></dt>
<dd><p>This method returns a ctypes type instance using the memory specified by
<em>address</em> which must be an integer.</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.from_param">
<code class="descname">from_param</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_param" title="정의 주소">¶</a></dt>
<dd><p>This method adapts <em>obj</em> to a ctypes type.  It is called with the actual
object used in a foreign function call when the type is present in the
foreign function's <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> tuple; it must return an object that
can be used as a function call parameter.</p>
<p>All ctypes data types have a default implementation of this classmethod
that normally returns <em>obj</em> if that is an instance of the type.  Some
types accept other objects as well.</p>
</dd></dl>

<dl class="method">
<dt id="ctypes._CData.in_dll">
<code class="descname">in_dll</code><span class="sig-paren">(</span><em>library</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.in_dll" title="정의 주소">¶</a></dt>
<dd><p>This method returns a ctypes type instance exported by a shared
library. <em>name</em> is the name of the symbol that exports the data, <em>library</em>
is the loaded shared library.</p>
</dd></dl>

<p>Common instance variables of ctypes data types:</p>
<dl class="attribute">
<dt id="ctypes._CData._b_base_">
<code class="descname">_b_base_</code><a class="headerlink" href="#ctypes._CData._b_base_" title="정의 주소">¶</a></dt>
<dd><p>Sometimes ctypes data instances do not own the memory block they contain,
instead they share part of the memory block of a base object.  The
<a class="reference internal" href="#ctypes._CData._b_base_" title="ctypes._CData._b_base_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_b_base_</span></code></a> read-only member is the root ctypes object that owns the
memory block.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._CData._b_needsfree_">
<code class="descname">_b_needsfree_</code><a class="headerlink" href="#ctypes._CData._b_needsfree_" title="정의 주소">¶</a></dt>
<dd><p>This read-only variable is true when the ctypes data instance has
allocated the memory block itself, false otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._CData._objects">
<code class="descname">_objects</code><a class="headerlink" href="#ctypes._CData._objects" title="정의 주소">¶</a></dt>
<dd><p>This member is either <code class="docutils literal notranslate"><span class="pre">None</span></code> or a dictionary containing Python objects
that need to be kept alive so that the memory block contents is kept
valid.  This object is only exposed for debugging; never modify the
contents of this dictionary.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ctypes-fundamental-data-types-2">
<span id="id1"></span><h3>기본 데이터형<a class="headerlink" href="#ctypes-fundamental-data-types-2" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="ctypes._SimpleCData">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">_SimpleCData</code><a class="headerlink" href="#ctypes._SimpleCData" title="정의 주소">¶</a></dt>
<dd><p>This non-public class is the base class of all fundamental ctypes data
types. It is mentioned here because it contains the common attributes of the
fundamental ctypes data types.  <a class="reference internal" href="#ctypes._SimpleCData" title="ctypes._SimpleCData"><code class="xref py py-class docutils literal notranslate"><span class="pre">_SimpleCData</span></code></a> is a subclass of
<a class="reference internal" href="#ctypes._CData" title="ctypes._CData"><code class="xref py py-class docutils literal notranslate"><span class="pre">_CData</span></code></a>, so it inherits their methods and attributes. ctypes data
types that are not and do not contain pointers can now be pickled.</p>
<p>Instances have a single attribute:</p>
<dl class="attribute">
<dt id="ctypes._SimpleCData.value">
<code class="descname">value</code><a class="headerlink" href="#ctypes._SimpleCData.value" title="정의 주소">¶</a></dt>
<dd><p>This attribute contains the actual value of the instance. For integer and
pointer types, it is an integer, for character types, it is a single
character bytes object or string, for character pointer types it is a
Python bytes object or string.</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">value</span></code> attribute is retrieved from a ctypes instance, usually
a new object is returned each time.  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> does <em>not</em> implement
original object return, always a new object is constructed.  The same is
true for all other ctypes object instances.</p>
</dd></dl>

</dd></dl>

<p>Fundamental data types, when returned as foreign function call results, or, for
example, by retrieving structure field members or array items, are transparently
converted to native Python types.  In other words, if a foreign function has a
<code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> of <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>, you will always receive a Python bytes
object, <em>not</em> a <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> instance.</p>
<p>Subclasses of fundamental data types do <em>not</em> inherit this behavior. So, if a
foreign functions <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> is a subclass of <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a>, you will
receive an instance of this subclass from the function call. Of course, you can
get the value of the pointer by accessing the <code class="docutils literal notranslate"><span class="pre">value</span></code> attribute.</p>
<p>These are the fundamental ctypes data types:</p>
<dl class="class">
<dt id="ctypes.c_byte">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_byte</code><a class="headerlink" href="#ctypes.c_byte" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">char</span></code> datatype, and interprets the value as
small integer.  The constructor accepts an optional integer initializer; no
overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_char">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_char</code><a class="headerlink" href="#ctypes.c_char" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code> datatype, and interprets the value as a single
character.  The constructor accepts an optional string initializer, the
length of the string must be exactly one character.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_char_p">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_char_p</code><a class="headerlink" href="#ctypes.c_char_p" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> datatype when it points to a zero-terminated
string.  For a general character pointer that may also point to binary data,
<code class="docutils literal notranslate"><span class="pre">POINTER(c_char)</span></code> must be used.  The constructor accepts an integer
address, or a bytes object.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_double">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_double</code><a class="headerlink" href="#ctypes.c_double" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">double</span></code> datatype.  The constructor accepts an
optional float initializer.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_longdouble">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_longdouble</code><a class="headerlink" href="#ctypes.c_longdouble" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">double</span></code> datatype.  The constructor accepts an
optional float initializer.  On platforms where <code class="docutils literal notranslate"><span class="pre">sizeof(long</span> <span class="pre">double)</span> <span class="pre">==</span>
<span class="pre">sizeof(double)</span></code> it is an alias to <a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_float">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_float</code><a class="headerlink" href="#ctypes.c_float" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">float</span></code> datatype.  The constructor accepts an
optional float initializer.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int</code><a class="headerlink" href="#ctypes.c_int" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.  On platforms
where <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> it is an alias to <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int8">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int8</code><a class="headerlink" href="#ctypes.c_int8" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 8-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_byte</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int16">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int16</code><a class="headerlink" href="#ctypes.c_int16" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 16-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_short</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int32">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int32</code><a class="headerlink" href="#ctypes.c_int32" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 32-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_int64">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_int64</code><a class="headerlink" href="#ctypes.c_int64" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 64-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longlong</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_long">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_long</code><a class="headerlink" href="#ctypes.c_long" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_longlong">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_longlong</code><a class="headerlink" href="#ctypes.c_longlong" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">long</span></code> datatype.  The constructor accepts
an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_short">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_short</code><a class="headerlink" href="#ctypes.c_short" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">signed</span> <span class="pre">short</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_size_t">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_size_t</code><a class="headerlink" href="#ctypes.c_size_t" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code> datatype.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ssize_t">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ssize_t</code><a class="headerlink" href="#ctypes.c_ssize_t" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">ssize_t</span></code> datatype.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ubyte">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ubyte</code><a class="headerlink" href="#ctypes.c_ubyte" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code> datatype, it interprets the value as
small integer.  The constructor accepts an optional integer initializer; no
overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint</code><a class="headerlink" href="#ctypes.c_uint" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.  On platforms
where <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> it is an alias for <a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulong</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint8">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint8</code><a class="headerlink" href="#ctypes.c_uint8" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 8-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ubyte</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint16">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint16</code><a class="headerlink" href="#ctypes.c_uint16" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 16-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ushort</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint32">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint32</code><a class="headerlink" href="#ctypes.c_uint32" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 32-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_uint64">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_uint64</code><a class="headerlink" href="#ctypes.c_uint64" title="정의 주소">¶</a></dt>
<dd><p>Represents the C 64-bit <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulonglong</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ulong">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ulong</code><a class="headerlink" href="#ctypes.c_ulong" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ulonglong">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ulonglong</code><a class="headerlink" href="#ctypes.c_ulonglong" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> datatype.  The constructor
accepts an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_ushort">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_ushort</code><a class="headerlink" href="#ctypes.c_ushort" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code> datatype.  The constructor accepts
an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_void_p">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_void_p</code><a class="headerlink" href="#ctypes.c_void_p" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> type.  The value is represented as integer.
The constructor accepts an optional integer initializer.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_wchar">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_wchar</code><a class="headerlink" href="#ctypes.c_wchar" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> datatype, and interprets the value as a
single character unicode string.  The constructor accepts an optional string
initializer, the length of the string must be exactly one character.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_wchar_p">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_wchar_p</code><a class="headerlink" href="#ctypes.c_wchar_p" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span> <span class="pre">*</span></code> datatype, which must be a pointer to a
zero-terminated wide character string.  The constructor accepts an integer
address, or a string.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.c_bool">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">c_bool</code><a class="headerlink" href="#ctypes.c_bool" title="정의 주소">¶</a></dt>
<dd><p>Represent the C <code class="xref c c-type docutils literal notranslate"><span class="pre">bool</span></code> datatype (more accurately, <code class="xref c c-type docutils literal notranslate"><span class="pre">_Bool</span></code> from
C99).  Its value can be <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>, and the constructor accepts any object
that has a truth value.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.HRESULT">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">HRESULT</code><a class="headerlink" href="#ctypes.HRESULT" title="정의 주소">¶</a></dt>
<dd><p>Windows only: Represents a <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> value, which contains success or
error information for a function or method call.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.py_object">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">py_object</code><a class="headerlink" href="#ctypes.py_object" title="정의 주소">¶</a></dt>
<dd><p>Represents the C <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> datatype.  Calling this without an
argument creates a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code></a> pointer.</p>
</dd></dl>

<p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.wintypes</span></code> module provides quite some other Windows specific
data types, for example <code class="xref c c-type docutils literal notranslate"><span class="pre">HWND</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">WPARAM</span></code>, or <code class="xref c c-type docutils literal notranslate"><span class="pre">DWORD</span></code>.  Some
useful structures like <code class="xref c c-type docutils literal notranslate"><span class="pre">MSG</span></code> or <code class="xref c c-type docutils literal notranslate"><span class="pre">RECT</span></code> are also defined.</p>
</div>
<div class="section" id="structured-data-types">
<span id="ctypes-structured-data-types"></span><h3>Structured data types<a class="headerlink" href="#structured-data-types" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="ctypes.Union">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">Union</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Union" title="정의 주소">¶</a></dt>
<dd><p>Abstract base class for unions in native byte order.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.BigEndianStructure">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">BigEndianStructure</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.BigEndianStructure" title="정의 주소">¶</a></dt>
<dd><p>Abstract base class for structures in <em>big endian</em> byte order.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes.LittleEndianStructure">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">LittleEndianStructure</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LittleEndianStructure" title="정의 주소">¶</a></dt>
<dd><p>Abstract base class for structures in <em>little endian</em> byte order.</p>
</dd></dl>

<p>Structures with non-native byte order cannot contain pointer type fields, or any
other data types containing pointer type fields.</p>
<dl class="class">
<dt id="ctypes.Structure">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">Structure</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Structure" title="정의 주소">¶</a></dt>
<dd><p>Abstract base class for structures in <em>native</em> byte order.</p>
<p>Concrete structure and union types must be created by subclassing one of these
types, and at least define a <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> class variable. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> will
create <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>s which allow reading and writing the fields by direct
attribute accesses.  These are the</p>
<dl class="attribute">
<dt id="ctypes.Structure._fields_">
<code class="descname">_fields_</code><a class="headerlink" href="#ctypes.Structure._fields_" title="정의 주소">¶</a></dt>
<dd><p>A sequence defining the structure fields.  The items must be 2-tuples or
3-tuples.  The first item is the name of the field, the second item
specifies the type of the field; it can be any ctypes data type.</p>
<p>For integer type fields like <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>, a third optional item can be
given.  It must be a small positive integer defining the bit width of the
field.</p>
<p>Field names must be unique within one structure or union.  This is not
checked, only one field can be accessed when names are repeated.</p>
<p>It is possible to define the <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> class variable <em>after</em> the
class statement that defines the Structure subclass, this allows creating
data types that directly or indirectly reference themselves:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">List</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">List</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;pnext&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">List</span><span class="p">)),</span>
                 <span class="o">...</span>
                <span class="p">]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> class variable must, however, be defined before the
type is first used (an instance is created, <a class="reference internal" href="#ctypes.sizeof" title="ctypes.sizeof"><code class="xref py py-func docutils literal notranslate"><span class="pre">sizeof()</span></code></a> is called on it,
and so on).  Later assignments to the <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> class variable will
raise an AttributeError.</p>
<p>It is possible to defined sub-subclasses of structure types, they inherit
the fields of the base class plus the <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> defined in the
sub-subclass, if any.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.Structure._pack_">
<code class="descname">_pack_</code><a class="headerlink" href="#ctypes.Structure._pack_" title="정의 주소">¶</a></dt>
<dd><p>An optional small integer that allows overriding the alignment of
structure fields in the instance.  <a class="reference internal" href="#ctypes.Structure._pack_" title="ctypes.Structure._pack_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code></a> must already be defined
when <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> is assigned, otherwise it will have no effect.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.Structure._anonymous_">
<code class="descname">_anonymous_</code><a class="headerlink" href="#ctypes.Structure._anonymous_" title="정의 주소">¶</a></dt>
<dd><p>An optional sequence that lists the names of unnamed (anonymous) fields.
<a class="reference internal" href="#ctypes.Structure._anonymous_" title="ctypes.Structure._anonymous_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_anonymous_</span></code></a> must be already defined when <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> is
assigned, otherwise it will have no effect.</p>
<p>The fields listed in this variable must be structure or union type fields.
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> will create descriptors in the structure type that allows
accessing the nested fields directly, without the need to create the
structure or union field.</p>
<p>Here is an example type (Windows):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">_U</span><span class="p">(</span><span class="n">Union</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;lptdesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">TYPEDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;lpadesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">ARRAYDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;hreftype&quot;</span><span class="p">,</span> <span class="n">HREFTYPE</span><span class="p">)]</span>

<span class="k">class</span> <span class="nc">TYPEDESC</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_anonymous_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">,)</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="n">_U</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;vt&quot;</span><span class="p">,</span> <span class="n">VARTYPE</span><span class="p">)]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">TYPEDESC</span></code> structure describes a COM data type, the <code class="docutils literal notranslate"><span class="pre">vt</span></code> field
specifies which one of the union fields is valid.  Since the <code class="docutils literal notranslate"><span class="pre">u</span></code> field
is defined as anonymous field, it is now possible to access the members
directly off the TYPEDESC instance. <code class="docutils literal notranslate"><span class="pre">td.lptdesc</span></code> and <code class="docutils literal notranslate"><span class="pre">td.u.lptdesc</span></code>
are equivalent, but the former is faster since it does not need to create
a temporary union instance:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">td</span> <span class="o">=</span> <span class="n">TYPEDESC</span><span class="p">()</span>
<span class="n">td</span><span class="o">.</span><span class="n">vt</span> <span class="o">=</span> <span class="n">VT_PTR</span>
<span class="n">td</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
<span class="n">td</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<p>It is possible to defined sub-subclasses of structures, they inherit the
fields of the base class.  If the subclass definition has a separate
<a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> variable, the fields specified in this are appended to the
fields of the base class.</p>
<p>Structure and union constructors accept both positional and keyword
arguments.  Positional arguments are used to initialize member fields in the
same order as they are appear in <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>.  Keyword arguments in the
constructor are interpreted as attribute assignments, so they will initialize
<a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> with the same name, or create new attributes for names not
present in <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="arrays-and-pointers">
<span id="ctypes-arrays-pointers"></span><h3>Arrays and pointers<a class="headerlink" href="#arrays-and-pointers" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="ctypes.Array">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">Array</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Array" title="정의 주소">¶</a></dt>
<dd><p>Abstract base class for arrays.</p>
<p>The recommended way to create concrete array types is by multiplying any
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> data type with a positive integer.  Alternatively, you can subclass
this type and define <a class="reference internal" href="#ctypes.Array._length_" title="ctypes.Array._length_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_length_</span></code></a> and <a class="reference internal" href="#ctypes.Array._type_" title="ctypes.Array._type_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_type_</span></code></a> class variables.
Array elements can be read and written using standard
subscript and slice accesses; for slice reads, the resulting object is
<em>not</em> itself an <a class="reference internal" href="#ctypes.Array" title="ctypes.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>.</p>
<dl class="attribute">
<dt id="ctypes.Array._length_">
<code class="descname">_length_</code><a class="headerlink" href="#ctypes.Array._length_" title="정의 주소">¶</a></dt>
<dd><p>A positive integer specifying the number of elements in the array.
Out-of-range subscripts result in an <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>. Will be
returned by <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes.Array._type_">
<code class="descname">_type_</code><a class="headerlink" href="#ctypes.Array._type_" title="정의 주소">¶</a></dt>
<dd><p>Specifies the type of each element in the array.</p>
</dd></dl>

<p>Array subclass constructors accept positional arguments, used to
initialize the elements in order.</p>
</dd></dl>

<dl class="class">
<dt id="ctypes._Pointer">
<em class="property">class </em><code class="descclassname">ctypes.</code><code class="descname">_Pointer</code><a class="headerlink" href="#ctypes._Pointer" title="정의 주소">¶</a></dt>
<dd><p>Private, abstract base class for pointers.</p>
<p>Concrete pointer types are created by calling <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a> with the
type that will be pointed to; this is done automatically by
<a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a>.</p>
<p>If a pointer points to an array, its elements can be read and
written using standard subscript and slice accesses.  Pointer objects
have no size, so <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> will raise <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.  Negative
subscripts will read from the memory <em>before</em> the pointer (as in C), and
out-of-range subscripts will probably crash with an access violation (if
you're lucky).</p>
<dl class="attribute">
<dt id="ctypes._Pointer._type_">
<code class="descname">_type_</code><a class="headerlink" href="#ctypes._Pointer._type_" title="정의 주소">¶</a></dt>
<dd><p>Specifies the type pointed to.</p>
</dd></dl>

<dl class="attribute">
<dt id="ctypes._Pointer.contents">
<code class="descname">contents</code><a class="headerlink" href="#ctypes._Pointer.contents" title="정의 주소">¶</a></dt>
<dd><p>Returns the object to which to pointer points.  Assigning to this
attribute changes the pointer to point to the assigned object.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">ctypes</span></code> --- 파이썬용 외부 함수 라이브러리</a><ul>
<li><a class="reference internal" href="#ctypes-tutorial">ctypes 자습서</a><ul>
<li><a class="reference internal" href="#loading-dynamic-link-libraries">동적 링크 라이브러리 로드하기</a></li>
<li><a class="reference internal" href="#accessing-functions-from-loaded-dlls">로드된 dll에서 함수에 액세스하기</a></li>
<li><a class="reference internal" href="#calling-functions">함수 호출하기</a></li>
<li><a class="reference internal" href="#fundamental-data-types">기본 데이터형</a></li>
<li><a class="reference internal" href="#calling-functions-continued">함수 호출하기, 계속</a></li>
<li><a class="reference internal" href="#calling-functions-with-your-own-custom-data-types">사용자 정의 데이터형을 사용하여 함수 호출하기</a></li>
<li><a class="reference internal" href="#specifying-the-required-argument-types-function-prototypes">필수 인자 형 (함수 프로토타입) 지정하기</a></li>
<li><a class="reference internal" href="#return-types">반환 형</a></li>
<li><a class="reference internal" href="#passing-pointers-or-passing-parameters-by-reference">포인터 전달하기 (또는: 참조로 매개 변수 전달하기)</a></li>
<li><a class="reference internal" href="#structures-and-unions">구조체와 공용체</a></li>
<li><a class="reference internal" href="#structure-union-alignment-and-byte-order">구조체/공용체 정렬과 바이트 순서</a></li>
<li><a class="reference internal" href="#bit-fields-in-structures-and-unions">구조체와 공용체의 비트 필드</a></li>
<li><a class="reference internal" href="#arrays">배열</a></li>
<li><a class="reference internal" href="#pointers">Pointers</a></li>
<li><a class="reference internal" href="#type-conversions">Type conversions</a></li>
<li><a class="reference internal" href="#incomplete-types">Incomplete Types</a></li>
<li><a class="reference internal" href="#callback-functions">Callback functions</a></li>
<li><a class="reference internal" href="#accessing-values-exported-from-dlls">Accessing values exported from dlls</a></li>
<li><a class="reference internal" href="#surprises">Surprises</a></li>
<li><a class="reference internal" href="#variable-sized-data-types">Variable-sized data types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctypes-reference">ctypes reference</a><ul>
<li><a class="reference internal" href="#finding-shared-libraries">Finding shared libraries</a></li>
<li><a class="reference internal" href="#loading-shared-libraries">Loading shared libraries</a></li>
<li><a class="reference internal" href="#foreign-functions">Foreign functions</a></li>
<li><a class="reference internal" href="#function-prototypes">Function prototypes</a></li>
<li><a class="reference internal" href="#utility-functions">Utility functions</a></li>
<li><a class="reference internal" href="#data-types">Data types</a></li>
<li><a class="reference internal" href="#ctypes-fundamental-data-types-2">기본 데이터형</a></li>
<li><a class="reference internal" href="#structured-data-types">Structured data types</a></li>
<li><a class="reference internal" href="#arrays-and-pointers">Arrays and pointers</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="errno.html"
                        title="이전 장"><code class="docutils literal notranslate"><span class="pre">errno</span></code> --- Standard errno system symbols</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="concurrency.html"
                        title="다음 장">동시 실행</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="동시 실행"
             >다음</a> |</li>
        <li class="right" >
          <a href="errno.html" title="errno --- Standard errno system symbols"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >일반 운영 체제 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2018, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1 를 사용해서 만들었습니다.
    </div>

  </body>
</html>