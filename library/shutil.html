
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>shutil --- 고수준 파일 연산 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="데이터 지속성" href="persistence.html" />
    <link rel="prev" title="linecache --- 텍스트 줄에 대한 무작위 액세스" href="linecache.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/shutil.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="persistence.html" title="데이터 지속성"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="linecache.html" title="linecache --- 텍스트 줄에 대한 무작위 액세스"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="filesys.html" accesskey="U">파일과 디렉터리 액세스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-shutil">
<span id="shutil-high-level-file-operations"></span><h1><a class="reference internal" href="#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> --- 고수준 파일 연산<a class="headerlink" href="#module-shutil" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/shutil.py">Lib/shutil.py</a></p>
<hr class="docutils" id="index-0" />
<p><a class="reference internal" href="#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> 모듈은 파일과 파일 모음에 대한 여러 가지 고수준 연산을 제공합니다. 특히, 파일 복사와 삭제를 지원하는 함수가 제공됩니다. 개별 파일에 대한 연산에 대해서는, <a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> 모듈도 참조하십시오.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>더 고수준의 파일 복사 함수(<a class="reference internal" href="#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copy()</span></code></a>, <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copy2()</span></code></a>)조차도 모든 파일 메타 데이터를 복사할 수는 없습니다.</p>
<p>POSIX 플랫폼에서, 이는 ACL뿐만 아니라 파일 소유자와 그룹이 유실됨을 의미합니다. Mac OS에서는, 리소스 포크(resource fork)와 기타 메타 데이터가 사용되지 않습니다. 이는 리소스가 손실되고 파일 유형과 작성자 코드가 올바르지 않음을 의미합니다. 윈도우에서는, 파일 소유자, ACL 및 대체 데이터 스트림(alternate data streams)이 복사되지 않습니다.</p>
</div>
<div class="section" id="directory-and-files-operations">
<span id="file-operations"></span><h2>디렉터리와 파일 연산<a class="headerlink" href="#directory-and-files-operations" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="shutil.copyfileobj">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">copyfileobj</code><span class="sig-paren">(</span><em class="sig-param">fsrc</em>, <em class="sig-param">fdst</em><span class="optional">[</span>, <em class="sig-param">length</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#shutil.copyfileobj" title="정의 주소">¶</a></dt>
<dd><p>파일류 객체 <em>fsrc</em>의 내용을 파일류 객체 <em>fdst</em>에 복사합니다. 주어지면, 정수 <em>length</em>는 버퍼 크기입니다. 특히, 음의 <em>length</em> 값은 청크 단위로 소스 데이터를 반복하지 않고 데이터를 복사하는 것을 의미합니다; 기본적으로 제어되지 않은 메모리 소비를 피하고자 데이터를 청크로 읽습니다. <em>fsrc</em> 객체의 현재 파일 위치가 0이 아니면, 현재 파일 위치에서 파일 끝까지의 내용만 복사됨에 유의하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="shutil.copyfile">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">copyfile</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em>, <em class="sig-param">*</em>, <em class="sig-param">follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.copyfile" title="정의 주소">¶</a></dt>
<dd><p>가능한 가장 효율적인 방법으로 이름이 <em>src</em> 인 파일의 내용을 (메타 데이터 없이) 이름이 <em>dst</em> 인 파일에 복사하고 <em>dst</em>를 반환합니다. <em>src</em>와 <em>dst</em>는 경로류 객체나 문자열로 지정된 경로 이름입니다.</p>
<p><em>dst</em>는 완전한 대상 파일 이름이어야 합니다; 대상 디렉터리 경로를 허용하는 복사는 <a class="reference internal" href="#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy()</span></code></a>를 참조하십시오. <em>src</em>와 <em>dst</em>가 같은 파일을 지정하면, <a class="reference internal" href="#shutil.SameFileError" title="shutil.SameFileError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SameFileError</span></code></a>가 발생합니다.</p>
<p>대상 위치는 쓰기 가능해야 합니다; 그렇지 않으면, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 예외가 발생합니다. <em>dst</em>가 이미 존재하면, 교체됩니다. 문자나 블록 장치 및 파이프와 같은 특수 파일은 이 함수로 복사할 수 없습니다.</p>
<p><em>follow_symlinks</em>가 거짓이고 <em>src</em>가 심볼릭 링크이면, <em>src</em>가 가리키는 파일을 복사하는 대신 새 심볼릭 링크가 만들어집니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copyfile</span></code>을 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>예전에는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a>를 발생시켰습니다. <em>follow_symlinks</em> 인자가 추가되었습니다. 이제 <em>dst</em>를 반환합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="#shutil.Error" title="shutil.Error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Error</span></code></a> 대신 <a class="reference internal" href="#shutil.SameFileError" title="shutil.SameFileError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SameFileError</span></code></a>를 발생시킵니다. 후자는 전자의 서브 클래스라서, 이 변경은 이전 버전과 호환됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>파일을 더 효율적으로 복사하기 위해 플랫폼별 빠른 복사(fast-copy) 시스템 호출을 내부적으로 사용할 수 있습니다. <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">플랫폼 의존적 효율적인 복사 연산</span></a> 섹션을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="exception">
<dt id="shutil.SameFileError">
<em class="property">exception </em><code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">SameFileError</code><a class="headerlink" href="#shutil.SameFileError" title="정의 주소">¶</a></dt>
<dd><p>이 예외는 <a class="reference internal" href="#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyfile()</span></code></a>의 소스와 대상이 같은 파일일 때 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="shutil.copymode">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">copymode</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em>, <em class="sig-param">*</em>, <em class="sig-param">follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.copymode" title="정의 주소">¶</a></dt>
<dd><p><em>src</em>에서 <em>dst</em>로 권한 비트를 복사합니다. 파일 내용, 소유자 및 그룹은 영향을 받지 않습니다. <em>src</em>와 <em>dst</em>는 경로류 객체나 문자열로 지정된 경로 이름입니다. <em>follow_symlinks</em>가 거짓이고 <em>src</em>와 <em>dst</em>가 모두 심볼릭 링크이면, <a class="reference internal" href="#shutil.copymode" title="shutil.copymode"><code class="xref py py-func docutils literal notranslate"><span class="pre">copymode()</span></code></a>는 (가리키는 파일이 아니라) <em>dst</em> 자체의 모드를 수정하려고 시도합니다. 이 기능이 모든 플랫폼에서 사용 가능한 것은 아닙니다; 자세한 내용은 <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a>을 참조하십시오. <a class="reference internal" href="#shutil.copymode" title="shutil.copymode"><code class="xref py py-func docutils literal notranslate"><span class="pre">copymode()</span></code></a>가 로컬 플랫폼에서 심볼릭 링크를 수정할 수 없고, 그렇게 하도록 요청받으면, 아무것도 하지 않고 반환합니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copymode</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><em>follow_symlinks</em> 인자가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="shutil.copystat">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">copystat</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em>, <em class="sig-param">*</em>, <em class="sig-param">follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.copystat" title="정의 주소">¶</a></dt>
<dd><p>권한 비트, 마지막 액세스 시간, 마지막 수정 시간 및 플래그를 <em>src</em>에서 <em>dst</em>로 복사합니다. 리눅스에서 <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a>은 가능하면 &quot;확장 어트리뷰트(extended attributes)&quot;도 복사합니다. 파일 내용, 소유자 및 그룹은 영향을 받지 않습니다. <em>src</em>와 <em>dst</em>는 경로류 객체나 문자열로 지정된 경로 이름입니다.</p>
<p><em>follow_symlinks</em>가 거짓이고 <em>src</em>와 <em>dst</em>가 모두 심볼릭 링크를 참조하면, <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a>은 심볼릭 링크가 참조하는 파일이 아닌 심볼릭 링크 자체에 대해 작동합니다 - <em>src</em> 심볼릭 링크에서 정보를 읽고, <em>dst</em> 심볼릭 링크로 정보를 씁니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>모든 플랫폼이 심볼릭 링크를 검사하고 수정할 수 있는 기능을 제공하지는 않습니다. 파이썬 자체는 어떤 기능이 로컬에서 사용 가능한지 알려줄 수 있습니다.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">os.chmod</span> <span class="pre">in</span> <span class="pre">os.supports_follow_symlinks</span></code>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a>은 심볼릭 링크의 권한 비트를 수정할 수 있습니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">os.utime</span> <span class="pre">in</span> <span class="pre">os.supports_follow_symlinks</span></code>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a>은 심볼릭 링크의 마지막 액세스와 수정 시간을 수정할 수 있습니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">os.chflags</span> <span class="pre">in</span> <span class="pre">os.supports_follow_symlinks</span></code>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a>은 심볼릭 링크의 플래그를 수정할 수 있습니다. (<code class="docutils literal notranslate"><span class="pre">os.chflags</span></code>가 모든 플랫폼에서 사용 가능한 것은 아닙니다.)</p></li>
</ul>
<p>이 기능 중 일부나 전부를 사용할 수 없는 플랫폼에서, 심볼릭 링크를 수정하라는 요청을 하면, <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a>은 가능한 모든 것들을 복사합니다. <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a>은 절대 실패를 반환하지 않습니다.</p>
<p>자세한 내용은 <a class="reference internal" href="os.html#os.supports_follow_symlinks" title="os.supports_follow_symlinks"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.supports_follow_symlinks</span></code></a>를 참조하십시오.</p>
</div>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copystat</span></code>을 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><em>follow_symlinks</em> 인자와 리눅스 확장 어트리뷰트 지원을 추가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="shutil.copy">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em>, <em class="sig-param">*</em>, <em class="sig-param">follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.copy" title="정의 주소">¶</a></dt>
<dd><p>파일 <em>src</em>를 파일이나 디렉터리 <em>dst</em>에 복사합니다. <em>src</em>와 <em>dst</em>는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>나 문자열이어야 합니다. <em>dst</em>가 디렉터리를 지정하면, 파일은 <em>src</em>의 기본 파일명을 사용하여 <em>dst</em>로 복사됩니다. 새로 만든 파일의 경로를 반환합니다.</p>
<p><em>follow_symlinks</em>가 거짓이고, <em>src</em>가 심볼릭 링크이면, <em>dst</em>는 심볼릭 링크로 만들어집니다. <em>follow_symlinks</em>가 참이고 <em>src</em>가 심볼릭 링크이면, <em>dst</em>는 <em>src</em>가 참조하는 파일의 사본이 됩니다.</p>
<p><a class="reference internal" href="#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy()</span></code></a>는 파일 데이터와 파일의 권한 모드(<a class="reference internal" href="os.html#os.chmod" title="os.chmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.chmod()</span></code></a>를 참조하십시오)를 복사합니다. 파일의 생성과 수정 시간과 같은 다른 메타 데이터는 유지되지 않습니다. 원본의 모든 파일 메타 데이터를 유지하려면 대신 <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a>를 사용하십시오.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copyfile</span></code>을 발생시킵니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copymode</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><em>follow_symlinks</em> 인자가 추가되었습니다. 이제 새로 만든 파일의 경로를 반환합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>파일을 더 효율적으로 복사하기 위해 플랫폼별 빠른 복사(fast-copy) 시스템 호출을 내부적으로 사용할 수 있습니다. <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">플랫폼 의존적 효율적인 복사 연산</span></a> 섹션을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="shutil.copy2">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">copy2</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em>, <em class="sig-param">*</em>, <em class="sig-param">follow_symlinks=True</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.copy2" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a>가 파일 메타 데이터 보존도 시도한다는 점을 제외하고는 <a class="reference internal" href="#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy()</span></code></a>와 동일합니다.</p>
<p><em>follow_symlinks</em>가 거짓이고, <em>src</em>가 심볼릭 링크이면, <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a>는 <em>src</em> 심볼릭 링크의 모든 메타 데이터를 새로 만들어진 <em>dst</em> 심볼릭 링크로 복사하려고 시도합니다. 그러나, 이 기능이 모든 플랫폼에서 사용 가능한 것은 아닙니다. 이 기능의 일부나 전부를 사용할 수 없는 플랫폼에서, <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a>는 가능한 모든 메타 데이터를 보존합니다; <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a>는 파일 메타 데이터를 보존할 수 없다는 이유로 예외를 발생시키지 않습니다.</p>
<p><a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a>는 <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a>을 사용하여 파일 메타 데이터를 복사합니다. 심볼릭 링크 메타 데이터 수정을 위한 플랫폼 지원에 대한 자세한 정보는 <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a>을 참조하십시오.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copyfile</span></code>을 발생시킵니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copystat</span></code>을 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><em>follow_symlinks</em> 인자를 추가하고, 확장 파일 시스템 어트리뷰트도 복사하려고 합니다 (현재 리눅스만 해당합니다). 이제 새로 만든 파일의 경로를 반환합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>파일을 더 효율적으로 복사하기 위해 플랫폼별 빠른 복사(fast-copy) 시스템 호출을 내부적으로 사용할 수 있습니다. <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">플랫폼 의존적 효율적인 복사 연산</span></a> 섹션을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="shutil.ignore_patterns">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">ignore_patterns</code><span class="sig-paren">(</span><em class="sig-param">*patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.ignore_patterns" title="정의 주소">¶</a></dt>
<dd><p>이 팩토리 함수는 <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a>의 <em>ignore</em> 인자를 위한 콜러블 함수로 사용할 수 있는 함수를 만드는데, 제공된 glob 스타일 <em>patterns</em> 중 하나와 일치하는 파일과 디렉터리를 무시하도록 합니다. 아래 예를 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="shutil.copytree">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">copytree</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em>, <em class="sig-param">symlinks=False</em>, <em class="sig-param">ignore=None</em>, <em class="sig-param">copy_function=copy2</em>, <em class="sig-param">ignore_dangling_symlinks=False</em>, <em class="sig-param">dirs_exist_ok=False</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.copytree" title="정의 주소">¶</a></dt>
<dd><p><em>src</em>를 루트로 하는 전체 디렉터리 트리를 <em>dst</em>라는 디렉터리에 재귀적으로 복사하고 대상 디렉터리를 반환합니다. <em>dirs_exist_ok</em>는 <em>dst</em>나 누락된 부모 디렉터리가 이미 존재할 때 예외를 발생시킬지를 나타냅니다.</p>
<p>디렉터리의 권한과 시간은 <a class="reference internal" href="#shutil.copystat" title="shutil.copystat"><code class="xref py py-func docutils literal notranslate"><span class="pre">copystat()</span></code></a>으로 복사되고, 개별 파일은 <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a>를 사용하여 복사됩니다.</p>
<p><em>symlinks</em>가 참이면, 소스 트리의 심볼릭 링크가 새 트리에서 심볼릭 링크로 표시되고 플랫폼이 허용하는 한 원래 링크의 메타 데이터가 복사됩니다; 거짓이거나 생략되면, 링크된 파일의 내용과 메타 데이터가 새 트리에 복사됩니다.</p>
<p><em>symlinks</em>가 거짓이면, 심볼릭 링크가 가리키는 파일이 존재하지 않으면, 복사 과정 종료 시 발생하는 <a class="reference internal" href="#shutil.Error" title="shutil.Error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Error</span></code></a> 예외의 에러 리스트에 예외가 추가됩니다. 이 예외를 침묵시키려면 선택적 <em>ignore_dangling_symlinks</em> 플래그를 참으로 설정할 수 있습니다. 이 옵션은 <a class="reference internal" href="os.html#os.symlink" title="os.symlink"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.symlink()</span></code></a>를 지원하지 않는 플랫폼에는 영향을 미치지 않음에 주목하십시오.</p>
<p><em>ignore</em>가 주어지면, <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a>가 방문하는 디렉터리와 <a class="reference internal" href="os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a>가 반환한 이 디렉터리 내용의 리스트를 인자로 수신하는 콜러블 이어야 합니다. <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a>는 재귀적으로 호출되기 때문에, 복사되는 디렉터리마다 <em>ignore</em> 콜러블이 한 번 호출됩니다. 콜러블은 현재 디렉터리에 상대적인 디렉터리와 파일 이름의 시퀀스를 반환해야 합니다 (즉, 두 번째 인자에 있는 항목의 부분집합); 이 이름들은 복사 과정에서 무시됩니다. <a class="reference internal" href="#shutil.ignore_patterns" title="shutil.ignore_patterns"><code class="xref py py-func docutils literal notranslate"><span class="pre">ignore_patterns()</span></code></a>를 사용하여 glob 스타일 패턴을 기반으로 이름을 무시하는 콜러블을 만들 수 있습니다.</p>
<p>예외가 발생하면, 이유 리스트와 함께 <a class="reference internal" href="#shutil.Error" title="shutil.Error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Error</span></code></a>가 발생합니다.</p>
<p><em>copy_function</em>이 제공되면, 각 파일을 복사하는 데 사용되는 콜러블 이어야 합니다. 소스 경로와 대상 경로를 인자로 호출됩니다. 기본적으로, <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a>가 사용되지만, 같은 서명을 지원하는 (<a class="reference internal" href="#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy()</span></code></a>와 같은) 모든 함수를 사용할 수 있습니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.copytree</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><em>symlinks</em>가 거짓일 때 메타 데이터를 복사합니다. 이제 <em>dst</em>를 반환합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>사용자 정의 복사 함수를 제공할 수 있도록 <em>copy_function</em> 인자를 추가했습니다. <em>symlinks</em>가 거짓일 때 연결이 끊긴(dangling) 심볼릭 링크 에러를 침묵시키도록 <em>ignore_dangling_symlinks</em> 인자를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>파일을 더 효율적으로 복사하기 위해 플랫폼별 빠른 복사(fast-copy) 시스템 호출을 내부적으로 사용할 수 있습니다. <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">플랫폼 의존적 효율적인 복사 연산</span></a> 섹션을 참조하십시오.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가: </span><em>dirs_exist_ok</em> 매개 변수.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="shutil.rmtree">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">rmtree</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">ignore_errors=False</em>, <em class="sig-param">onerror=None</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.rmtree" title="정의 주소">¶</a></dt>
<dd><p id="index-1">전체 디렉터리 트리를 삭제합니다; <em>path</em>는 디렉터리를 가리켜야 합니다 (하지만 디렉터리에 대한 심볼릭 링크는 아닙니다). <em>ignore_errors</em>가 참이면, 삭제 실패로 인한 에러는 무시됩니다; 거짓이거나 생략되면, 이러한 에러는 <em>onerror</em>로 지정된 처리기를 호출하여 처리하거나, 생략하면 예외가 발생합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>필요한 fd 기반 함수를 지원하는 플랫폼에서는 기본적으로 <a class="reference internal" href="#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal notranslate"><span class="pre">rmtree()</span></code></a>의 심볼릭 링크 공격 방지 버전이 사용됩니다. 다른 플랫폼에서는, <a class="reference internal" href="#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal notranslate"><span class="pre">rmtree()</span></code></a> 구현이 심볼릭 링크 공격에 취약합니다: 적절한 타이밍과 상황에 따라, 공격자는 파일 시스템에서 심볼릭 링크를 조작하여 다른 방법으로는 액세스할 수 없는 파일을 삭제할 수 있습니다. 응용 프로그램은 <a class="reference internal" href="#shutil.rmtree.avoids_symlink_attacks" title="shutil.rmtree.avoids_symlink_attacks"><code class="xref py py-data docutils literal notranslate"><span class="pre">rmtree.avoids_symlink_attacks</span></code></a> 함수 어트리뷰트를 사용하여 어떤 버전이 사용되는지 판별할 수 있습니다.</p>
</div>
<p><em>onerror</em>가 제공되면, 세 가지 매개 변수를 받아들이는 콜러블 이어야 합니다: <em>function</em>, <em>path</em> 및 <em>excinfo</em>.</p>
<p>첫 번째 매개 변수 <em>function</em>은 예외를 발생시킨 함수입니다; 플랫폼과 구현에 따라 다릅니다. 두 번째 매개 변수 <em>path</em>는 <em>function</em>에 전달된 경로 이름입니다. 세 번째 매개 변수 <em>excinfo</em>는 <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>가 반환한 예외 정보입니다. <em>onerror</em>에 의해 발생한 예외는 포착되지 않습니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">path</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.rmtree</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>플랫폼이 fd 기반 함수를 지원하면 자동으로 사용되는 심볼릭 링크 공격 방지 버전을 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>윈도우에서, 정션(junction)을 제거하기 전에 더는 디렉터리 정션의 내용을 삭제하지 않습니다.</p>
</div>
<dl class="attribute">
<dt id="shutil.rmtree.avoids_symlink_attacks">
<code class="sig-prename descclassname">rmtree.</code><code class="sig-name descname">avoids_symlink_attacks</code><a class="headerlink" href="#shutil.rmtree.avoids_symlink_attacks" title="정의 주소">¶</a></dt>
<dd><p>현재 플랫폼과 구현이 <a class="reference internal" href="#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal notranslate"><span class="pre">rmtree()</span></code></a>의 심볼릭 링크 공격 방지 버전을 제공하는지를 나타냅니다. 현재 이것은 fd 기반 디렉터리 액세스 함수를 지원하는 플랫폼에서만 참입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="shutil.move">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">move</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em>, <em class="sig-param">copy_function=copy2</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.move" title="정의 주소">¶</a></dt>
<dd><p>파일이나 디렉터리(<em>src</em>)를 다른 위치(<em>dst</em>)로 재귀적으로 옮기고 대상을 반환합니다.</p>
<p>대상이 기존 디렉터리이면, <em>src</em>가 해당 디렉터리 내로 이동됩니다. 대상이 이미 존재하지만, 디렉터리가 아니면, <a class="reference internal" href="os.html#os.rename" title="os.rename"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.rename()</span></code></a> 의미에 따라 덮어쓸 수 있습니다.</p>
<p>대상이 현재 파일 시스템에 있으면, <a class="reference internal" href="os.html#os.rename" title="os.rename"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.rename()</span></code></a>이 사용됩니다. 그렇지 않으면, <em>copy_function</em>을 사용하여 <em>src</em>를 <em>dst</em>로 복사한 다음 제거합니다. 심볼릭 링크의 경우, <em>src</em>의 대상을 가리키는 새 심볼릭 링크가 <em>dst</em>나 그 안에 만들어지고 <em>src</em>가 제거됩니다.</p>
<p><em>copy_function</em>이 제공되면, <em>src</em>와 <em>dst</em> 두 개의 인자를 취하는 콜러블 이어야 하며, <a class="reference internal" href="os.html#os.rename" title="os.rename"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.rename()</span></code></a>을 사용할 수 없을 때 <em>src</em>를 <em>dst</em>로 복사하는 데 사용됩니다. 소스가 디렉터리이면, <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a>가 호출되고 <code class="xref py py-func docutils literal notranslate"><span class="pre">copy_function()</span></code>을 전달합니다. 기본 <em>copy_function</em>은 <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a>입니다. <em>copy_function</em>으로 <a class="reference internal" href="#shutil.copy" title="shutil.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy()</span></code></a>를 사용하면 메타 데이터를 복사하지 않는 비용을 지불하는 대신 메타 데이터도 복사할 때 실패하는 이동이 성공할 수 있습니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">src</span></code>, <code class="docutils literal notranslate"><span class="pre">dst</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.move</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>외부 파일 시스템에 대한 명시적 심볼릭 링크 처리를 추가하여, GNU <strong class="program">mv</strong>의 동작에 맞게 조정했습니다. 이제 <em>dst</em>를 반환합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><em>copy_function</em> 키워드 인자를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>파일을 더 효율적으로 복사하기 위해 플랫폼별 빠른 복사(fast-copy) 시스템 호출을 내부적으로 사용할 수 있습니다. <a class="reference internal" href="#shutil-platform-dependent-efficient-copy-operations"><span class="std std-ref">플랫폼 의존적 효율적인 복사 연산</span></a> 섹션을 참조하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span><em>src</em>와 <em>dst</em> 모두에 대해 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="shutil.disk_usage">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">disk_usage</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.disk_usage" title="정의 주소">¶</a></dt>
<dd><p>지정된 경로(path)에 대한 디스크 사용량 통계를 <em>total</em>, <em>used</em> 및 <em>free</em> 어트리뷰트를 갖는 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a>로 반환합니다. 이들은 바이트 단위의 총, 사용된, 여유 공간의 양입니다. <em>path</em>는 파일이나 디렉터리일 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>윈도우에서, <em>path</em>는 이제 파일이나 디렉터리일 수 있습니다.</p>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스, 윈도우.</p>
</dd></dl>

<dl class="function">
<dt id="shutil.chown">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">chown</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">user=None</em>, <em class="sig-param">group=None</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.chown" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>path</em>의 소유자 <em>user</em> 및/또는 <em>group</em>을 변경합니다.</p>
<p><em>user</em>는 시스템 사용자 이름이나 uid 일 수 있습니다; <em>group</em>도 마찬가지입니다. 최소한 하나의 인자가 필요합니다.</p>
<p>하부 함수인 <a class="reference internal" href="os.html#os.chown" title="os.chown"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.chown()</span></code></a>도 참조하십시오.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">path</span></code>, <code class="docutils literal notranslate"><span class="pre">user</span></code>, <code class="docutils literal notranslate"><span class="pre">group</span></code>으로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.chown</span></code>을 발생시킵니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="shutil.which">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">which</code><span class="sig-paren">(</span><em class="sig-param">cmd</em>, <em class="sig-param">mode=os.F_OK | os.X_OK</em>, <em class="sig-param">path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.which" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>cmd</em>가 호출되면 실행될 실행 파일의 경로를 반환합니다. 아무런 <em>cmd</em>도 호출되지 않을 것이라면, <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<p><em>mode</em>는 <a class="reference internal" href="os.html#os.access" title="os.access"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.access()</span></code></a>에 전달되는 권한 마스크입니다, 기본적으로 파일이 존재하고 실행 가능한지를 판단합니다.</p>
<p><em>path</em>를 지정하지 않으면, <a class="reference internal" href="os.html#os.environ" title="os.environ"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.environ()</span></code></a>의 결과가 사용되어, &quot;PATH&quot; 값이나 <a class="reference internal" href="os.html#os.defpath" title="os.defpath"><code class="xref py py-attr docutils literal notranslate"><span class="pre">os.defpath</span></code></a>의 폴 백을 반환합니다.</p>
<p>윈도우에서, 기본값을 사용하건 여러분 스스로 제공한 값을 사용하건 현재 디렉터리가 항상 <em>path</em> 앞에 추가됩니다, 이는 실행 파일을 찾을 때 명령 셸이 사용하는 동작입니다. 또한, <em>path</em>에서 <em>cmd</em>를 찾을 때, <code class="docutils literal notranslate"><span class="pre">PATHEXT</span></code> 환경 변수가 확인됩니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">shutil.which(&quot;python&quot;)</span></code>을 호출하면, <a class="reference internal" href="#shutil.which" title="shutil.which"><code class="xref py py-func docutils literal notranslate"><span class="pre">which()</span></code></a>는 <code class="docutils literal notranslate"><span class="pre">PATHEXT</span></code>를 검색하여 <em>path</em> 디렉터리에서 <code class="docutils literal notranslate"><span class="pre">python.exe</span></code>를 찾아야 한다는 것을 알 수 있습니다. 예를 들어, 윈도우에서:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">shutil</span><span class="o">.</span><span class="n">which</span><span class="p">(</span><span class="s2">&quot;python&quot;</span><span class="p">)</span>
<span class="go">&#39;C:\\Python33\\python.EXE&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>이제 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 형을 받아들입니다. <em>cmd</em> 형이 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>이면 결과 형도 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>입니다.</p>
</div>
</dd></dl>

<dl class="exception">
<dt id="shutil.Error">
<em class="property">exception </em><code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">Error</code><a class="headerlink" href="#shutil.Error" title="정의 주소">¶</a></dt>
<dd><p>이 예외는 다중 파일 연산 중에 발생한 예외를 수집합니다. <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a>의 경우, 예외 인자는 3-튜플(<em>srcname</em>, <em>dstname</em>, <em>exception</em>)의 리스트입니다.</p>
</dd></dl>

<div class="section" id="platform-dependent-efficient-copy-operations">
<span id="shutil-platform-dependent-efficient-copy-operations"></span><h3>플랫폼 의존적 효율적인 복사 연산<a class="headerlink" href="#platform-dependent-efficient-copy-operations" title="제목 주소">¶</a></h3>
<p>파이썬 3.8부터 파일 복사를 수반하는 모든 함수(<a class="reference internal" href="#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyfile()</span></code></a>, <a class="reference internal" href="copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-func docutils literal notranslate"><span class="pre">copy()</span></code></a>, <a class="reference internal" href="#shutil.copy2" title="shutil.copy2"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy2()</span></code></a>, <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a> 및 <a class="reference internal" href="#shutil.move" title="shutil.move"><code class="xref py py-func docutils literal notranslate"><span class="pre">move()</span></code></a>)는 파일을 더 효율적으로 복사하기 위해 플랫폼별 &quot;빠른 복사(fast-copy)&quot; 시스템 호출을 사용할 수 있습니다 (<a class="reference external" href="https://bugs.python.org/issue33671">bpo-33671</a>을 참조하십시오). &quot;빠른 복사&quot;는 복사 연산이 커널 내에서 발생하여, &quot;<code class="docutils literal notranslate"><span class="pre">outfd.write(infd.read())</span></code>&quot;와 같이 파이썬에서 사용자 공간 버퍼 사용을 피함을 의미합니다.</p>
<p>macOS에서는 <a class="reference external" href="http://www.manpagez.com/man/3/copyfile/">fcopyfile</a>이 (메타 데이터가 아닌) 파일 내용을 복사하는 데 사용됩니다.</p>
<p>리눅스에서는 <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.sendfile()</span></code></a>이 사용됩니다.</p>
<p>윈도우에서는 <a class="reference internal" href="#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copyfile()</span></code></a>이 더 큰 기본 버퍼 크기(64 KiB 대신 1 MiB)를 사용하고 <a class="reference internal" href="#shutil.copyfileobj" title="shutil.copyfileobj"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copyfileobj()</span></code></a>의 <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-func docutils literal notranslate"><span class="pre">memoryview()</span></code></a> 기반 변형이 사용됩니다.</p>
<p>빠른 복사 연산이 실패하고 대상 파일에 아무런 데이터도 기록되지 않았으면 shutil은 내부적으로 덜 효율적인 <a class="reference internal" href="#shutil.copyfileobj" title="shutil.copyfileobj"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyfileobj()</span></code></a> 함수를 사용하여 조용히 폴 백 됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경.</span></p>
</div>
</div>
<div class="section" id="copytree-example">
<span id="shutil-copytree-example"></span><h3>copytree 예<a class="headerlink" href="#copytree-example" title="제목 주소">¶</a></h3>
<p>이 예제는 위에서 설명한 <a class="reference internal" href="#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a> 함수의 독스트링이 생략된 구현입니다. 이 모듈에서 제공하는 다른 많은 함수를 예시합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">copytree</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">symlinks</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="n">srcname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">dstname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">symlinks</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">islink</span><span class="p">(</span><span class="n">srcname</span><span class="p">):</span>
                <span class="n">linkto</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">readlink</span><span class="p">(</span><span class="n">srcname</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">linkto</span><span class="p">,</span> <span class="n">dstname</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">srcname</span><span class="p">):</span>
                <span class="n">copytree</span><span class="p">(</span><span class="n">srcname</span><span class="p">,</span> <span class="n">dstname</span><span class="p">,</span> <span class="n">symlinks</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">copy2</span><span class="p">(</span><span class="n">srcname</span><span class="p">,</span> <span class="n">dstname</span><span class="p">)</span>
            <span class="c1"># XXX 장치, 소켓 등은?</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">why</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">srcname</span><span class="p">,</span> <span class="n">dstname</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">why</span><span class="p">)))</span>
        <span class="c1"># 다른 파일을 계속 진행할 수 있도록 재귀적 copytree에서 에러를 잡습니다</span>
        <span class="k">except</span> <span class="n">Error</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">copystat</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">why</span><span class="p">:</span>
        <span class="c1"># 윈도우에서 파일 액세스 시간을 복사할 수 없습니다</span>
        <span class="k">if</span> <span class="n">why</span><span class="o">.</span><span class="n">winerror</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">why</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#shutil.ignore_patterns" title="shutil.ignore_patterns"><code class="xref py py-func docutils literal notranslate"><span class="pre">ignore_patterns()</span></code></a> 도우미를 사용하는 다른 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">shutil</span> <span class="k">import</span> <span class="n">copytree</span><span class="p">,</span> <span class="n">ignore_patterns</span>

<span class="n">copytree</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore_patterns</span><span class="p">(</span><span class="s1">&#39;*.pyc&#39;</span><span class="p">,</span> <span class="s1">&#39;tmp*&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>이것은 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 파일과 이름이 <code class="docutils literal notranslate"><span class="pre">tmp</span></code>로 시작하는 파일이나 디렉터리를 제외한 모든 것을 복사합니다.</p>
<p>로깅 호출을 추가하기 위해 <em>ignore</em> 인자를 사용하는 또 다른 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">shutil</span> <span class="k">import</span> <span class="n">copytree</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="k">def</span> <span class="nf">_logpath</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Working in </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[]</span>   <span class="c1"># 아무것도 무시되지 않습니다</span>

<span class="n">copytree</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">_logpath</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="rmtree-example">
<span id="shutil-rmtree-example"></span><h3>rmtree 예<a class="headerlink" href="#rmtree-example" title="제목 주소">¶</a></h3>
<p>이 예는 윈도우에서 일부 파일에 읽기 전용 비트가 설정된 디렉터리 트리를 삭제하는 방법을 보여줍니다. onerror 콜백을 사용하여 읽기 전용 비트를 지우고 삭제를 다시 시도합니다. 후속 실패는 전파됩니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">stat</span>
<span class="kn">import</span> <span class="nn">shutil</span>

<span class="k">def</span> <span class="nf">remove_readonly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
    <span class="s2">&quot;읽기 전용 비트를 지우고 삭제를 다시 시도합니다&quot;</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IWRITE</span><span class="p">)</span>
    <span class="n">func</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

<span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">onerror</span><span class="o">=</span><span class="n">remove_readonly</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="archiving-operations">
<span id="id1"></span><h2>아카이브 연산<a class="headerlink" href="#archiving-operations" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><em>xztar</em> 형식에 대한 지원이 추가되었습니다.</p>
</div>
<p>압축 및 아카이브 된 파일을 만들고 읽는 고수준 유틸리티도 제공됩니다. 이들은 <a class="reference internal" href="zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a>과 <a class="reference internal" href="tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 모듈에 의존합니다.</p>
<dl class="function">
<dt id="shutil.make_archive">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">make_archive</code><span class="sig-paren">(</span><em class="sig-param">base_name</em>, <em class="sig-param">format</em><span class="optional">[</span>, <em class="sig-param">root_dir</em><span class="optional">[</span>, <em class="sig-param">base_dir</em><span class="optional">[</span>, <em class="sig-param">verbose</em><span class="optional">[</span>, <em class="sig-param">dry_run</em><span class="optional">[</span>, <em class="sig-param">owner</em><span class="optional">[</span>, <em class="sig-param">group</em><span class="optional">[</span>, <em class="sig-param">logger</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#shutil.make_archive" title="정의 주소">¶</a></dt>
<dd><p>아카이브 파일(가령 zip이나 tar)을 만들고 이름을 반환합니다.</p>
<p><em>base_name</em>은 만들 파일의 이름인데, 경로를 포함하고 형식별 확장자는 제외합니다. <em>format</em>은 아카이브 형식입니다: &quot;zip&quot; (<a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 모듈을 사용할 수 있으면), &quot;tar&quot;, &quot;gztar&quot; (<a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 모듈을 사용할 수 있으면), &quot;bztar&quot; (<a class="reference internal" href="bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a> 모듈을 사용할 수 있으면) 또는 &quot;xztar&quot; (<a class="reference internal" href="lzma.html#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lzma</span></code></a> 모듈을 사용할 수 있으면) 중 하나.</p>
<p><em>root_dir</em>은 아카이브의 루트 디렉터리가 될 디렉터리입니다, 아카이브의 모든 경로는 이것에 상대적입니다; 예를 들어, 보통 아카이브를 만들기 전에 <em>root_dir</em>로 chdir 합니다.</p>
<p><em>base_dir</em>은 아카이브를 시작할 디렉터리입니다; 즉, <em>base_dir</em>은 아카이브에 있는 모든 파일과 디렉터리의 공통 접두사가 됩니다. <em>base_dir</em>은 <em>root_dir</em>에 상대적으로 제공되어야 합니다. <em>base_dir</em>과 <em>root_dir</em>을 함께 사용하는 방법은 <a class="reference internal" href="#shutil-archiving-example-with-basedir"><span class="std std-ref">base_dir을 사용한 아카이브 예</span></a>를 참조하십시오.</p>
<p><em>root_dir</em>과 <em>base_dir</em>은 모두 현재 디렉터리가 기본값입니다.</p>
<p><em>dry_run</em>이 참이면, 아카이브가 만들어지지 않지만, 실행될 연산이 <em>logger</em>에 로그 됩니다.</p>
<p>tar 아카이브를 만들 때 <em>owner와 *group</em>이 사용됩니다. 기본적으로, 현재 소유자와 그룹을 사용합니다.</p>
<p><em>logger</em>는 <span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0282"><strong>PEP 282</strong></a>와 호환되는 객체여야 합니다, 일반적으로 <a class="reference internal" href="logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Logger</span></code></a>의 인스턴스.</p>
<p><em>verbose</em> 인자는 사용되지 않으며 폐지되었습니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">base_name</span></code>, <code class="docutils literal notranslate"><span class="pre">format</span></code>, <code class="docutils literal notranslate"><span class="pre">root_dir</span></code>, <code class="docutils literal notranslate"><span class="pre">base_dir</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.make_archive</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><code class="docutils literal notranslate"><span class="pre">format=&quot;tar&quot;</span></code>로 만들어진 아카이브에 기존 GNU 형식 대신 최신 pax (POSIX.1-2001) 형식이 사용됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="shutil.get_archive_formats">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">get_archive_formats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#shutil.get_archive_formats" title="정의 주소">¶</a></dt>
<dd><p>아카이브에 지원되는 형식의 리스트를 반환합니다. 반환된 시퀀스의 각 요소는 튜플 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">description)</span></code>입니다.</p>
<p>기본적으로 <a class="reference internal" href="#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a>은 다음 형식을 제공합니다:</p>
<ul class="simple">
<li><p><em>zip</em>: ZIP 파일 (<a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 모듈을 사용할 수 있으면).</p></li>
<li><p><em>tar</em>: 압축되지 않은 tar 파일. 새 아카이브에 POSIX.1-2001 pax 형식을 사용합니다.</p></li>
<li><p><em>gztar</em>: gzip 된 tar 파일 (<a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 모듈을 사용할 수 있으면).</p></li>
<li><p><em>bztar</em>: bzip2 된 tar 파일 (<a class="reference internal" href="bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a> 모듈을 사용할 수 있으면).</p></li>
<li><p><em>xztar</em>: xz 된 tar 파일 (<a class="reference internal" href="lzma.html#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lzma</span></code></a> 모듈을 사용할 수 있으면).</p></li>
</ul>
<p><a class="reference internal" href="#shutil.register_archive_format" title="shutil.register_archive_format"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_archive_format()</span></code></a>을 사용하여, 새 형식을 등록하거나 기존 형식에 대해 여러분 자신의 아카이버를 제공할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="shutil.register_archive_format">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">register_archive_format</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">function</em><span class="optional">[</span>, <em class="sig-param">extra_args</em><span class="optional">[</span>, <em class="sig-param">description</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#shutil.register_archive_format" title="정의 주소">¶</a></dt>
<dd><p><em>name</em> 형식을 위한 아카이버를 등록합니다.</p>
<p><em>function</em>은 아카이브를 만드는 데 사용되는 콜러블입니다. 콜러블은 만들 파일의 <em>base_name</em>과 그 뒤에 아카이브를 시작할 <em>base_dir</em>(기본값은 <a class="reference internal" href="os.html#os.curdir" title="os.curdir"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.curdir</span></code></a>)를 받습니다. 추가 인자는 키워드 인자로 전달됩니다: <em>owner</em>, <em>group</em>, <em>dry_run</em> 및 <em>logger</em> (<a class="reference internal" href="#shutil.make_archive" title="shutil.make_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_archive()</span></code></a>로 전달됩니다).</p>
<p>주어지면, <em>extra_args</em>는 아카이버 콜러블이 사용될 때 추가 키워드 인자로 사용되는 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> 쌍의 시퀀스입니다.</p>
<p><em>description</em>은 아카이버 목록을 반환하는 <a class="reference internal" href="#shutil.get_archive_formats" title="shutil.get_archive_formats"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_archive_formats()</span></code></a>에서 사용됩니다. 기본값은 빈 문자열입니다.</p>
</dd></dl>

<dl class="function">
<dt id="shutil.unregister_archive_format">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">unregister_archive_format</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.unregister_archive_format" title="정의 주소">¶</a></dt>
<dd><p>지원되는 형식 리스트에서 <em>name</em> 아카이브 형식을 제거합니다.</p>
</dd></dl>

<dl class="function">
<dt id="shutil.unpack_archive">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">unpack_archive</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="optional">[</span>, <em class="sig-param">extract_dir</em><span class="optional">[</span>, <em class="sig-param">format</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#shutil.unpack_archive" title="정의 주소">¶</a></dt>
<dd><p>아카이브를 풉니다. <em>filename</em>은 아카이브의 전체 경로입니다.</p>
<p><em>extract_dir</em>은 아카이브가 풀리는 대상 디렉터리의 이름입니다. 제공되지 않으면, 현재 작업 디렉터리가 사용됩니다.</p>
<p><em>format</em>은 아카이브 형식입니다: &quot;zip&quot;, &quot;tar&quot;, &quot;gztar&quot;, &quot;bztar&quot; 또는 &quot;xztar&quot; 중 하나. 또는 <a class="reference internal" href="#shutil.register_unpack_format" title="shutil.register_unpack_format"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_unpack_format()</span></code></a>으로 등록된 다른 형식. 제공되지 않으면, <a class="reference internal" href="#shutil.unpack_archive" title="shutil.unpack_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">unpack_archive()</span></code></a>는 아카이브 파일 이름 확장자를 사용하여 그 확장자에 대한 아카이브 해제기가 등록되었는지 확인합니다. 아무것도 발견되지 않으면, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">filename</span></code>, <code class="docutils literal notranslate"><span class="pre">extract_dir</span></code>, <code class="docutils literal notranslate"><span class="pre">format</span></code>으로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">shutil.unpack_archive</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>filename</em>과 <em>extract_dir</em>에 대해 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="shutil.register_unpack_format">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">register_unpack_format</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">extensions</em>, <em class="sig-param">function</em><span class="optional">[</span>, <em class="sig-param">extra_args</em><span class="optional">[</span>, <em class="sig-param">description</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#shutil.register_unpack_format" title="정의 주소">¶</a></dt>
<dd><p>아카이브 해제기를 등록합니다. <em>name</em>은 형식의 이름이고 <em>extensions</em>는 형식에 해당하는 확장자의 리스트입니다, 가령 Zip 파일의 경우 <code class="docutils literal notranslate"><span class="pre">.zip</span></code>.</p>
<p><em>function</em>은 아카이브를 푸는 데 사용되는 콜러블입니다. 콜러블은 아카이브의 경로와 그 뒤로 아카이브를 추출해야 하는 디렉터리를 받습니다.</p>
<p>제공되면, <em>extra_args</em>는 키워드 인자로 콜러블에 전달되는 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> 튜플의 시퀀스입니다.</p>
<p><em>description</em>은 형식을 설명하기 위해 제공될 수 있으며, <a class="reference internal" href="#shutil.get_unpack_formats" title="shutil.get_unpack_formats"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_unpack_formats()</span></code></a> 함수에 의해 반환됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="shutil.unregister_unpack_format">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">unregister_unpack_format</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.unregister_unpack_format" title="정의 주소">¶</a></dt>
<dd><p>아카이브 해제 형식을 등록 취소합니다. <em>name</em>은 형식의 이름입니다.</p>
</dd></dl>

<dl class="function">
<dt id="shutil.get_unpack_formats">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">get_unpack_formats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#shutil.get_unpack_formats" title="정의 주소">¶</a></dt>
<dd><p>아카이브 해제를 위해 등록된 모든 형식의 리스트를 반환합니다. 반환된 시퀀스의 각 요소는 튜플 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">extensions,</span> <span class="pre">description)</span></code>입니다.</p>
<p>기본적으로 <a class="reference internal" href="#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a>은 다음 형식을 제공합니다:</p>
<ul class="simple">
<li><p><em>zip</em>: ZIP 파일 (압축된 파일의 해제는 해당 모듈을 사용할 수 있을 때만 작동합니다).</p></li>
<li><p><em>tar</em>: 압축되지 않은 tar 파일.</p></li>
<li><p><em>gztar</em>: gzip 된 tar 파일 (<a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 모듈을 사용할 수 있으면).</p></li>
<li><p><em>bztar</em>: bzip2 된 tar 파일 (<a class="reference internal" href="bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a> 모듈을 사용할 수 있으면).</p></li>
<li><p><em>xztar</em>: xz 된 tar 파일 (<a class="reference internal" href="lzma.html#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lzma</span></code></a> 모듈을 사용할 수 있으면).</p></li>
</ul>
<p><a class="reference internal" href="#shutil.register_unpack_format" title="shutil.register_unpack_format"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_unpack_format()</span></code></a>을 사용하여, 새 형식을 등록하거나 기존 형식에 대한 여러분 자신의 아카이브 해제기를 제공할 수 있습니다.</p>
</dd></dl>

<div class="section" id="archiving-example">
<span id="shutil-archiving-example"></span><h3>아카이브 예<a class="headerlink" href="#archiving-example" title="제목 주소">¶</a></h3>
<p>이 예에서는, 사용자의 <code class="file docutils literal notranslate"><span class="pre">.ssh</span></code> 디렉터리에 있는 모든 파일을 포함하는 gzip 된 tar 파일 아카이브를 만듭니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shutil</span> <span class="k">import</span> <span class="n">make_archive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">archive_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">,</span> <span class="s1">&#39;myarchive&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">,</span> <span class="s1">&#39;.ssh&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">make_archive</span><span class="p">(</span><span class="n">archive_name</span><span class="p">,</span> <span class="s1">&#39;gztar&#39;</span><span class="p">,</span> <span class="n">root_dir</span><span class="p">)</span>
<span class="go">&#39;/Users/tarek/myarchive.tar.gz&#39;</span>
</pre></div>
</div>
<p>결과 아카이브에는 다음이 포함됩니다:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tar -tzvf /Users/tarek/myarchive.tar.gz
<span class="go">drwx------ tarek/staff       0 2010-02-01 16:23:40 ./</span>
<span class="go">-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys</span>
<span class="go">-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config</span>
<span class="go">-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa</span>
<span class="go">-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub</span>
<span class="go">-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa</span>
<span class="go">-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub</span>
<span class="go">-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts</span>
</pre></div>
</div>
</div>
<div class="section" id="archiving-example-with-base-dir">
<span id="shutil-archiving-example-with-basedir"></span><h3><em>base_dir</em>을 사용한 아카이브 예<a class="headerlink" href="#archiving-example-with-base-dir" title="제목 주소">¶</a></h3>
<p>이 예에서는, <a class="reference internal" href="#shutil-archiving-example">위의 예</a>와 유사하게, <a class="reference internal" href="#shutil.make_archive" title="shutil.make_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_archive()</span></code></a>를 사용하는 방법을 보여 주지만, 이번에는 <em>base_dir</em>을 사용합니다. 이제 다음 디렉터리 구조가 있습니다:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tree tmp
<span class="go">tmp</span>
<span class="go">└── root</span>
<span class="go">    └── structure</span>
<span class="go">        ├── content</span>
<span class="go">            └── please_add.txt</span>
<span class="go">        └── do_not_add.txt</span>
</pre></div>
</div>
<p>최종 아카이브에는, <code class="file docutils literal notranslate"><span class="pre">please_add.txt</span></code>가 포함되어야 하지만, <code class="file docutils literal notranslate"><span class="pre">do_not_add.txt</span></code>는 포함되지 않아야 합니다. 따라서 다음을 사용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">shutil</span> <span class="k">import</span> <span class="n">make_archive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">archive_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">,</span> <span class="s1">&#39;myarchive&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">make_archive</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">archive_name</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;tar&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">root_dir</span><span class="o">=</span><span class="s1">&#39;tmp/root&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">base_dir</span><span class="o">=</span><span class="s1">&#39;structure/content&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&#39;/Users/tarek/my_archive.tar&#39;</span>
</pre></div>
</div>
<p>결과 아카이브에 파일을 나열하면 다음과 같습니다:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m tarfile -l /Users/tarek/myarchive.tar
<span class="go">structure/content/</span>
<span class="go">structure/content/please_add.txt</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="querying-the-size-of-the-output-terminal">
<h2>출력 터미널의 크기 조회하기<a class="headerlink" href="#querying-the-size-of-the-output-terminal" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="shutil.get_terminal_size">
<code class="sig-prename descclassname">shutil.</code><code class="sig-name descname">get_terminal_size</code><span class="sig-paren">(</span><em class="sig-param">fallback=(columns</em>, <em class="sig-param">lines)</em><span class="sig-paren">)</span><a class="headerlink" href="#shutil.get_terminal_size" title="정의 주소">¶</a></dt>
<dd><p>터미널 창의 크기를 가져옵니다.</p>
<p>두 차원 각각에 대해, 환경 변수 <code class="docutils literal notranslate"><span class="pre">COLUMNS</span></code>와 <code class="docutils literal notranslate"><span class="pre">LINES</span></code>가 각각 확인됩니다. 변수가 정의되고 값이 양의 정수이면 사용됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">COLUMNS</span></code>나 <code class="docutils literal notranslate"><span class="pre">LINES</span></code>가 정의되지 않으면 (이것이 일반적입니다), <a class="reference internal" href="os.html#os.get_terminal_size" title="os.get_terminal_size"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.get_terminal_size()</span></code></a>를 호출하여 <a class="reference internal" href="sys.html#sys.__stdout__" title="sys.__stdout__"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.__stdout__</span></code></a>에 연결된 터미널을 조회합니다.</p>
<p>시스템이 조회를 지원하지 않거나, 터미널에 연결되어 있지 않기 때문에 터미널 크기를 성공적으로 조회할 수 없으면, <code class="docutils literal notranslate"><span class="pre">fallback</span></code> 매개 변수에 제공된 값이 사용됩니다. <code class="docutils literal notranslate"><span class="pre">fallback</span></code>의 기본값은 많은 터미널 에뮬레이터에서 사용하는 기본 크기인 <code class="docutils literal notranslate"><span class="pre">(80,</span> <span class="pre">24)</span></code>입니다.</p>
<p>반환된 값은 <a class="reference internal" href="os.html#os.terminal_size" title="os.terminal_size"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.terminal_size</span></code></a> 형의 네임드 튜플입니다.</p>
<p>참조: The Single UNIX Specification, Version 2, <a class="reference external" href="http://pubs.opengroup.org/onlinepubs/7908799/xbd/envvar.html#tag_002_003">Other Environment Variables</a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code> --- 고수준 파일 연산</a><ul>
<li><a class="reference internal" href="#directory-and-files-operations">디렉터리와 파일 연산</a><ul>
<li><a class="reference internal" href="#platform-dependent-efficient-copy-operations">플랫폼 의존적 효율적인 복사 연산</a></li>
<li><a class="reference internal" href="#copytree-example">copytree 예</a></li>
<li><a class="reference internal" href="#rmtree-example">rmtree 예</a></li>
</ul>
</li>
<li><a class="reference internal" href="#archiving-operations">아카이브 연산</a><ul>
<li><a class="reference internal" href="#archiving-example">아카이브 예</a></li>
<li><a class="reference internal" href="#archiving-example-with-base-dir"><em>base_dir</em>을 사용한 아카이브 예</a></li>
</ul>
</li>
<li><a class="reference internal" href="#querying-the-size-of-the-output-terminal">출력 터미널의 크기 조회하기</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="linecache.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">linecache</span></code> --- 텍스트 줄에 대한 무작위 액세스</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="persistence.html"
                        title="다음 장">데이터 지속성</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="persistence.html" title="데이터 지속성"
             >다음</a> |</li>
        <li class="right" >
          <a href="linecache.html" title="linecache --- 텍스트 줄에 대한 무작위 액세스"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="filesys.html" >파일과 디렉터리 액세스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>