
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>email.message.Message: compat32 API를 사용하여 이메일 메시지 표현하기 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="email.mime: 처음부터 이메일과 MIME 객체 만들기" href="email.mime.html" />
    <link rel="prev" title="email: 예제" href="email.examples.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/email.compat32-message.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="email.mime.html" title="email.mime: 처음부터 이메일과 MIME 객체 만들기"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="email.examples.html" title="email: 예제"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >인터넷 데이터 처리</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 전자 메일과 MIME 처리 패키지</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="email-message-message-representing-an-email-message-using-the-compat32-api">
<span id="compat32-message"></span><h1><a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message.Message</span></code></a>: <a class="reference internal" href="email.policy.html#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-data docutils literal notranslate"><span class="pre">compat32</span></code></a> API를 사용하여 이메일 메시지 표현하기<a class="headerlink" href="#email-message-message-representing-an-email-message-using-the-compat32-api" title="제목 주소">¶</a></h1>
<p><a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 클래스는 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 클래스와 매우 유사지만, 이 클래스에 의해 추가된 메서드가 없고, 다른 특정 메서드의 기본 동작이 약간 다릅니다. 또한 <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 클래스에서 지원하지만 레거시 코드를 다루지 않는 한 권장되지 않는 일부 메서드도 여기에서 설명합니다.</p>
<p>두 클래스의 철학과 구조는 그 외에는 같습니다.</p>
<p>이 문서는 기본 (<a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>의 경우) 정책 <a class="reference internal" href="email.policy.html#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Compat32</span></code></a>의 동작을 설명합니다. 다른 정책을 사용하려면, <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 클래스를 대신 사용해야합니다.</p>
<p>이메일 메시지는 <em>헤더(headers)</em>와 <em>페이로드(payload)</em>로 구성됩니다. 헤더는 <span class="target" id="index-23"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5233.html"><strong>RFC 5233</strong></a> 스타일 이름과 값이어야하며, 필드 이름과 값은 콜론으로 구분됩니다. 콜론은 필드 이름이나 필드 값의 일부가 아닙니다. 페이로드는 간단한 텍스트 메시지, 바이너리 객체 또는 각각 자체 헤더 집합과 자체 페이로드가 있는 서브 메시지의 구조화된 시퀀스 일 수 있습니다. 후자의 페이로드 유형은 <em class="mimetype">multipart/*</em>나 <em class="mimetype">message/rfc822</em>와 같은 MIME 유형을 가진 메시지로 표시됩니다.</p>
<p><a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 객체가 제공하는 개념 모델은 헤더의 순서 있는 딕셔너리이면서, 헤더의 특수 정보에 액세스하고, 페이로드에 액세스하고, 메시지의 직렬화된 버전을 생성하고, 객체 트리를 재귀적으로 탐색하기위한 추가 메서드가 제공되는 것입니다. 중복 헤더가 지원되지만 특수한 메서드를 사용하여 액세스해야함에 유의하십시오.</p>
<p><a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 의사 딕셔너리는 헤더 이름으로 인덱싱되며, ASCII 값이어야 합니다. 딕셔너리의 값은 ASCII 문자만 포함해야하는 문자열입니다; 비 ASCII 입력에 대한 특수 처리가 있지만, 항상 올바른 결과를 생성하지는 않습니다. 헤더는 대소 문자를 유지하면서 저장되고 반환되지만, 필드 이름은 대소 문자를 구분하지 않고 일치합니다. <em>Unix-From</em> 헤더나 <code class="docutils literal notranslate"><span class="pre">From_</span></code> 헤더라고도 하는 단일 봉투 헤더가 있을 수도 있습니다. <em>페이로드(payload)</em>는 단순 메시지 객체의 경우는 문자열이나 바이트열이고, MIME 컨테이너 문서(예를 들어 <em class="mimetype">multipart/*</em>와 <em class="mimetype">message/rfc822</em>)의 경우는 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 객체의 리스트입니다.</p>
<p><a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 클래스의 메서드는 다음과 같습니다:</p>
<dl class="class">
<dt id="email.message.Message">
<em class="property">class </em><code class="sig-prename descclassname">email.message.</code><code class="sig-name descname">Message</code><span class="sig-paren">(</span><em class="sig-param">policy=compat32</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message" title="정의 주소">¶</a></dt>
<dd><p><em>policy</em>가 지정되면 (<a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 클래스의 인스턴스여야 합니다) 메시지 표현을 갱신하고 직렬화하기 위해 지정된 규칙을 사용합니다. <em>policy</em>가 설정되지 않으면, <a class="reference internal" href="email.policy.html#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">compat32</span></code></a> 정책을 사용하는데, 파이썬 3.2 버전의 email 패키지와의 과거 호환성을 유지합니다. 자세한 내용은 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 설명서를 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><em>policy</em> 키워드 인자가 추가되었습니다.</p>
</div>
<dl class="method">
<dt id="email.message.Message.as_string">
<code class="sig-name descname">as_string</code><span class="sig-paren">(</span><em class="sig-param">unixfrom=False</em>, <em class="sig-param">maxheaderlen=0</em>, <em class="sig-param">policy=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.as_string" title="정의 주소">¶</a></dt>
<dd><p>평활화된 전체 메시지를 문자열로 반환합니다. 선택적 <em>unixfrom</em>이 참이면, 봉투 헤더가 반환된 문자열에 포함됩니다. <em>unixfrom</em>의 기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code>입니다. 이전 버전과의 호환성을 위해, <em>maxheaderlen</em>의 기본값이 <code class="docutils literal notranslate"><span class="pre">0</span></code>이라서 다른 값을 원하면 명시적으로 재정의해야합니다 (정책에서 <em>max_line_length</em>에 지정된 값은 이 메서드가 무시합니다). <em>policy</em> 인자는 메시지 인스턴스에서 얻은 기본 정책을 대체하는 데 사용될 수 있습니다. 지정된 <em>policy</em>가 <code class="docutils literal notranslate"><span class="pre">Generator</span></code>로 전달되므로, 메서드에서 생성된 일부 포매팅을 제어하는 데 사용할 수 있습니다.</p>
<p>문자열로의 변환을 완료하기 위해 기본값을 채워야하면 메시지 평활화는 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>에 대한 변경을 유발할 수 있습니다 (예를 들어, MIME 경계가 생성되거나 수정될 수 있습니다).</p>
<p>이 메서드는 편의상 제공되며 원하는 방식으로 메시지를 항상 포맷하지는 않음에 유의하십시오. 예를 들어, 기본적으로 유닉스 mbox 형식에 필요한 <code class="docutils literal notranslate"><span class="pre">From</span></code>으로 시작하는 줄을 맹글링(mangling)하지 않습니다. 유연성을 높이려면, <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> 인스턴스를 인스턴스화하고 그 것의 <a class="reference internal" href="email.generator.html#email.generator.Generator.flatten" title="email.generator.Generator.flatten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flatten()</span></code></a> 메서드를 직접 사용하십시오. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">email.generator</span> <span class="k">import</span> <span class="n">Generator</span>
<span class="n">fp</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">mangle_from_</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxheaderlen</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
</pre></div>
</div>
<p>메시지 객체가 RFC 표준에 따라 인코딩되지 않은 바이너리 데이터를 포함하면, 비 호환 데이터는 유니코드 &quot;unknown character&quot; 코드 포인트로 대체됩니다. (<a class="reference internal" href="#email.message.Message.as_bytes" title="email.message.Message.as_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_bytes()</span></code></a>와 <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a>도 참조하십시오.)</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><em>policy</em> 키워드 인자가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__str__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#email.message.Message.as_string" title="email.message.Message.as_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_string()</span></code></a>과 동등합니다. <code class="docutils literal notranslate"><span class="pre">str(msg)</span></code>가 포맷된 메시지를 포함하는 문자열을 생성할 수 있도록 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.as_bytes">
<code class="sig-name descname">as_bytes</code><span class="sig-paren">(</span><em class="sig-param">unixfrom=False</em>, <em class="sig-param">policy=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.as_bytes" title="정의 주소">¶</a></dt>
<dd><p>평활화된 전체 메시지를 바이트열 객체로 반환합니다. 선택적 <em>unixfrom</em>이 참이면, 봉투 헤더가 반환된 문자열에 포함됩니다. <em>unixfrom</em>의 기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code>입니다. <em>policy</em> 인자는 메시지 인스턴스에서 얻은 기본 정책을 대체하는 데 사용될 수 있습니다. 지정된 <em>policy</em>가 <code class="docutils literal notranslate"><span class="pre">BytesGenerator</span></code>로 전달되므로, 메서드에서 생성된 일부 포매팅을 제어하는 데 사용할 수 있습니다.</p>
<p>문자열로의 변환을 완료하기 위해 기본값을 채워야하면 메시지 평활화는 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>에 대한 변경을 유발할 수 있습니다 (예를 들어, MIME 경계가 생성되거나 수정될 수 있습니다).</p>
<p>이 메서드는 편의상 제공되며 원하는 방식으로 메시지를 항상 포맷하지는 않음에 유의하십시오. 예를 들어, 기본적으로 유닉스 mbox 형식에 필요한 <code class="docutils literal notranslate"><span class="pre">From</span></code>으로 시작하는 줄을 맹글링(mangling)하지 않습니다. 유연성을 높이려면, <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a> 인스턴스를 인스턴스화하고 그 것의 <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator.flatten" title="email.generator.BytesGenerator.flatten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flatten()</span></code></a> 메서드를 직접 사용하십시오. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">BytesIO</span>
<span class="kn">from</span> <span class="nn">email.generator</span> <span class="k">import</span> <span class="n">BytesGenerator</span>
<span class="n">fp</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">BytesGenerator</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">mangle_from_</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxheaderlen</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.__bytes__">
<code class="sig-name descname">__bytes__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__bytes__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#email.message.Message.as_bytes" title="email.message.Message.as_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_bytes()</span></code></a>와 동등합니다. <code class="docutils literal notranslate"><span class="pre">bytes(msg)</span></code>가 포맷된 메시지를 포함하는 바이트열 객체를 생성할 수 있도록 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.is_multipart">
<code class="sig-name descname">is_multipart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.is_multipart" title="정의 주소">¶</a></dt>
<dd><p>메시지의 페이로드가 서브-<a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 객체의 리스트이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다. <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환할 때, 페이로드는 문자열 객체(CTE로 인코딩된 바이너리 페이로드일 수 있습니다)여야 합니다. (<code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환하는 <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a>가 반드시 &quot;msg.get_content_maintype() == 'multipart'&quot; 가 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환한다는 것을 의미하지는 않습니다. 예를 들어, <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">message/rfc822</span></code> 유형일 때, <code class="docutils literal notranslate"><span class="pre">is_multipart</span></code>는 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.set_unixfrom">
<code class="sig-name descname">set_unixfrom</code><span class="sig-paren">(</span><em class="sig-param">unixfrom</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_unixfrom" title="정의 주소">¶</a></dt>
<dd><p>메시지의 봉투 헤더를 (문자열이어야 하는) <em>unixfrom</em>으로 설정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_unixfrom">
<code class="sig-name descname">get_unixfrom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_unixfrom" title="정의 주소">¶</a></dt>
<dd><p>메시지의 봉투 헤더를 반환합니다. 봉투 헤더가 설정되지 않았으면 기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.attach">
<code class="sig-name descname">attach</code><span class="sig-paren">(</span><em class="sig-param">payload</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.attach" title="정의 주소">¶</a></dt>
<dd><p>지정된 <em>payload</em>를 현재 페이로드에 추가합니다. 호출 전에는 페이로드가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이나 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 객체의 리스트여야 합니다. 호출 후에는 페이로드가 항상 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 객체의 리스트입니다. 페이로드를 스칼라 객체(예를 들어 문자열)로 설정하려면, <a class="reference internal" href="#email.message.Message.set_payload" title="email.message.Message.set_payload"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_payload()</span></code></a>를 대신 사용하십시오.</p>
<p>이것은 레거시 메서드입니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 클래스에서 해당 기능은 <a class="reference internal" href="email.message.html#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a>와 관련 <code class="docutils literal notranslate"><span class="pre">make</span></code>와 <code class="docutils literal notranslate"><span class="pre">add</span></code> 메서드로 대체됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_payload">
<code class="sig-name descname">get_payload</code><span class="sig-paren">(</span><em class="sig-param">i=None</em>, <em class="sig-param">decode=False</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_payload" title="정의 주소">¶</a></dt>
<dd><p>현재 페이로드를 반환합니다. <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면 <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 객체의 리스트이고, <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면 문자열입니다. 페이로드가 리스트이고 리스트 객체를 변경하면, 메시지의 페이로드를 제자리에서 수정하는 것입니다.</p>
<p>선택적 인자 <em>i</em>를 사용하면, <a class="reference internal" href="#email.message.Message.get_payload" title="email.message.Message.get_payload"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_payload()</span></code></a>는 <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>일 때, 페이로드의 <em>i</em> 번째 요소를 0부터 세어 반환합니다. <em>i</em>가 0보다 작거나 페이로드의 항목 수보다 크거나 같으면 <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>가 발생합니다. 페이로드가 문자열이고 (즉 <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>) <em>i</em>가 제공되면, <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생합니다.</p>
<p>선택적 <em>decode</em>는 <em class="mailheader">Content-Transfer-Encoding</em> 헤더에 따라 페이로드를 디코딩해야하는지를 나타내는 플래그입니다. <code class="docutils literal notranslate"><span class="pre">True</span></code>이고 메시지가 멀티 파트가 아닐 때, 이 헤더 값이 <code class="docutils literal notranslate"><span class="pre">quoted-printable</span></code>이나 <code class="docutils literal notranslate"><span class="pre">base64</span></code>이면 페이로드가 디코딩됩니다. 다른 인코딩이 사용되거나 <em class="mailheader">Content-Transfer-Encoding</em> 헤더가 누락되면, 페이로드는 그대로 (디코딩되지 않고) 반환됩니다. 모든 경우에 반환 된 값은 바이너리 데이터입니다. 메시지가 멀티 파트이고 <em>decode</em> 플래그가 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다. 페이로드가 base64이고 완벽하게 구성되지 않았으면 (패딩 누락, base64 알파벳 이외의 문자), 메시지의 결함 프로퍼티에 적절한 결함이 추가됩니다 (각각 <code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidBase64PaddingDefect</span></code>나 <code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidBase64CharactersDefect</span></code>).</p>
<p><em>decode</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>(기본값)일 때 본문은 <em class="mailheader">Content-Transfer-Encoding</em>를 디코딩하지 않고 문자열로 반환됩니다. 그러나, <em class="mailheader">Content-Transfer-Encoding</em>가 8비트 인 경우, <code class="docutils literal notranslate"><span class="pre">replace</span></code> 에러 처리기로, <em class="mailheader">Content-Type</em> 헤더에 지정된 <code class="docutils literal notranslate"><span class="pre">charset</span></code>을 사용하여 원래 바이트를 디코딩하려고 시도합니다. <code class="docutils literal notranslate"><span class="pre">charset</span></code>이 지정되지 않았거나 email 패키지가 <code class="docutils literal notranslate"><span class="pre">charset</span></code>을 인식하지 못하면, 본문은 기본 ASCII 문자 집합을 사용하여 디코딩됩니다.</p>
<p>이것은 레거시 메서드입니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 클래스에서는 해당 기능이 <a class="reference internal" href="email.message.html#email.message.EmailMessage.get_content" title="email.message.EmailMessage.get_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content()</span></code></a>와 <a class="reference internal" href="email.message.html#email.message.EmailMessage.iter_parts" title="email.message.EmailMessage.iter_parts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iter_parts()</span></code></a>로 대체되었습니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.set_payload">
<code class="sig-name descname">set_payload</code><span class="sig-paren">(</span><em class="sig-param">payload</em>, <em class="sig-param">charset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_payload" title="정의 주소">¶</a></dt>
<dd><p>전체 메시지 객체의 페이로드를 <em>payload</em>로 설정합니다. 페이로드 불변량(invariants)을 보장하는 것은 고객의 책임입니다. 선택적 <em>charset</em>은 메시지의 기본 문자 집합을 설정합니다; 자세한 내용은 <a class="reference internal" href="#email.message.Message.set_charset" title="email.message.Message.set_charset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_charset()</span></code></a>을 참조하십시오.</p>
<p>이것은 레거시 메서드입니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 클래스에서는 해당 기능이 <a class="reference internal" href="email.message.html#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a>로 대체되었습니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.set_charset">
<code class="sig-name descname">set_charset</code><span class="sig-paren">(</span><em class="sig-param">charset</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_charset" title="정의 주소">¶</a></dt>
<dd><p>페이로드의 문자 집합을 <em>charset</em>으로 설정합니다. 이는 <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a> 인스턴스 (<a class="reference internal" href="email.charset.html#module-email.charset" title="email.charset: Character Sets"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.charset</span></code></a>을 참조하십시오), 문자 집합의 이름을 지정하는 문자열 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>일 수 있습니다. 문자열이면, <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a> 인스턴스로 변환됩니다. <em>charset</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, <code class="docutils literal notranslate"><span class="pre">charset</span></code> 매개 변수가 <em class="mailheader">Content-Type</em> 헤더에서 제거됩니다 (그렇지 않으면 메시지가 수정되지 않습니다). 그외의 경우는 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 생성합니다.</p>
<p>기존 <em class="mailheader">MIME-Version</em> 헤더가 없으면 추가됩니다. 기존 <em class="mailheader">Content-Type</em> 헤더가 없으면, <em class="mimetype">text/plain</em> 값으로 추가됩니다. <em class="mailheader">Content-Type</em> 헤더가 존재하는지에 관계없이, <code class="docutils literal notranslate"><span class="pre">charset</span></code> 매개 변수는 <em>charset.output_charset</em>으로 설정됩니다. <em>charset.input_charset</em>과 <em>charset.output_charset</em>이 다르면, 페이로드가 <em>output_charset</em>으로 다시 인코딩됩니다. 기존 <em class="mailheader">Content-Transfer-Encoding</em> 헤더가 없으면, 필요하면 지정된 <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a>을 사용하여 페이로드가 전송 인코딩되고(transfer-encoded), 적절한 값을 가진 헤더가 추가됩니다. <em class="mailheader">Content-Transfer-Encoding</em> 헤더가 이미 존재하면, 페이로드는 해당 <em class="mailheader">Content-Transfer-Encoding</em>을 사용하여 이미 올바르게 인코딩 된 것으로 가정하며 수정하지 않습니다.</p>
<p>이것은 레거시 메서드입니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 클래스에서 해당 기능은 <code class="xref py py-meth docutils literal notranslate"><span class="pre">email.emailmessage.EmailMessage.set_content()</span></code> 메서드의 <em>charset</em> 매개 변수로 대체됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_charset">
<code class="sig-name descname">get_charset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_charset" title="정의 주소">¶</a></dt>
<dd><p>메시지 페이로드와 연관된 <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a> 인스턴스를 반환합니다.</p>
<p>이것은 레거시 메서드입니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 클래스에서는 항상 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</dd></dl>

<p>다음 메서드는 메시지의 <span class="target" id="index-24"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html"><strong>RFC 2822</strong></a> 헤더에 액세스하기위한 매핑과 유사한 인터페이스를 구현합니다. 이 메서드들과 일반적인 매핑 (즉, 딕셔너리) 인터페이스 사이에는 의미 상 차이가 있습니다. 예를 들어, 딕셔너리에는 중복 키가 없지만, 여기에는 중복 메시지 헤더가 있을 수 있습니다. 또한, 딕셔너리에서는 <a class="reference internal" href="#email.message.Message.keys" title="email.message.Message.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code></a>가 반환하는 키의 순서가 보장되지 않지만, <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 객체에서는 헤더가 항상 원래 메시지에 나타나거나 나중에 메시지에 추가된 순서대로 반환됩니다. 삭제한 후 다시 추가 된 헤더는 항상 헤더 리스트의 끝에 추가됩니다.</p>
<p>이러한 의미 상 차이는 의도적이며 최대한의 편의를 위해 편향되어 있습니다.</p>
<p>모든 경우에, 메시지에 존재하는 봉투 헤더는 매핑 인터페이스에 포함되지 않습니다.</p>
<p>바이트열에서 생성 된 모델에서, (RFC에 반하여) 비 ASCII 바이트를 포함하는 헤더 값은, 이 인터페이스를 통해 꺼낼 때, 문자 집합이 <cite>unknown-8bit</cite>인 <a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> 객체로 표시됩니다.</p>
<dl class="method">
<dt id="email.message.Message.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__len__" title="정의 주소">¶</a></dt>
<dd><p>중복을 포함하여, 총 헤더 수를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.__contains__">
<code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__contains__" title="정의 주소">¶</a></dt>
<dd><p>메시지 객체에 <em>name</em>이라는 이름의 필드가 있으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다. 대소 문자를 구분하지 않고 일치하며 <em>name</em>은 후행 콜론을 포함하지 않아야합니다. <code class="docutils literal notranslate"><span class="pre">in</span></code> 연산자에 사용됩니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="s1">&#39;message-id&#39;</span> <span class="ow">in</span> <span class="n">myMessage</span><span class="p">:</span>
   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Message-ID:&#39;</span><span class="p">,</span> <span class="n">myMessage</span><span class="p">[</span><span class="s1">&#39;message-id&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__getitem__" title="정의 주소">¶</a></dt>
<dd><p>명명된 헤더 필드의 값을 반환합니다. <em>name</em>은 콜론 필드 구분자를 포함하지 않아야합니다. 헤더가 없으면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다; <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>는 절대 발생하지 않습니다.</p>
<p>이름이 지정된 필드가 메시지 헤더에 두 번 이상 나타나면, 해당 필드 값 중 정확히 어떤 필드 값이 반환되는지 정의되지 않습니다. 기존의 모든 명명된 헤더의 값을 가져 오려면 <a class="reference internal" href="#email.message.Message.get_all" title="email.message.Message.get_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_all()</span></code></a> 메서드를 사용하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.__setitem__">
<code class="sig-name descname">__setitem__</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">val</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__setitem__" title="정의 주소">¶</a></dt>
<dd><p>메시지에 필드 이름이 <em>name</em>이고 값이 <em>val</em>인 헤더를 추가합니다. 필드는 메시지의 기존 필드 끝에 추가됩니다.</p>
<p>이것이 같은 이름을 가진 기존 헤더를 덮어 쓰거나 삭제하지 <em>않음에</em> 유의하십시오. 새 헤더가 메시지에 필드 이름이 <em>name</em>인 유일한 헤더가 되도록 하려면, 먼저 필드를 삭제하십시오. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">del</span> <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">]</span>
<span class="n">msg</span><span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Python roolz!&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.__delitem__">
<code class="sig-name descname">__delitem__</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__delitem__" title="정의 주소">¶</a></dt>
<dd><p>메시지 헤더에서 이름이 <em>name</em>인 모든 필드를 삭제합니다. 명명된 필드가 헤더에 없어도 예외가 발생하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.keys">
<code class="sig-name descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.keys" title="정의 주소">¶</a></dt>
<dd><p>메시지 해더의 모든 필드 이름의 리스트를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.values">
<code class="sig-name descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.values" title="정의 주소">¶</a></dt>
<dd><p>메시지의 모든 필드 값의 리스트를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.items">
<code class="sig-name descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.items" title="정의 주소">¶</a></dt>
<dd><p>메시지의 모든 필드 헤더와 값을 포함하는 2-튜플의 리스트를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">failobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get" title="정의 주소">¶</a></dt>
<dd><p>명명된 헤더 필드의 값을 반환합니다. 명명된 헤더가 없으면 선택적 <em>failobj</em>가 반환된다는 점을 제외하고는 <a class="reference internal" href="#email.message.Message.__getitem__" title="email.message.Message.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>과 동일합니다 (기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다).</p>
</dd></dl>

<p>몇 가지 유용한 추가 메서드가 있습니다:</p>
<dl class="method">
<dt id="email.message.Message.get_all">
<code class="sig-name descname">get_all</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">failobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_all" title="정의 주소">¶</a></dt>
<dd><p><em>name</em>이라는 필드의 모든 값 리스트를 반환합니다. 메시지에 이런 이름의 헤더가 없으면, <em>failobj</em>가 반환됩니다 (기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다).</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.add_header">
<code class="sig-name descname">add_header</code><span class="sig-paren">(</span><em class="sig-param">_name</em>, <em class="sig-param">_value</em>, <em class="sig-param">**_params</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.add_header" title="정의 주소">¶</a></dt>
<dd><p>확장된 헤더 설정. 이 메서드는 추가 헤더 매개 변수가 키워드 인자로 제공될 수 있다는 점을 제외하고는 <a class="reference internal" href="#email.message.Message.__setitem__" title="email.message.Message.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>과 유사합니다. <em>_name</em>은 추가할 헤더 필드이고 <em>_value</em>는 헤더의 <em>기본(primary)</em> 값입니다.</p>
<p>키워드 인자 딕셔너리 <em>_params</em>의 각 항목에 대해, 키는 매개 변수 이름으로 사용되며, 밑줄은 대시로 변환됩니다 (대시는 파이썬 식별자에로 유효하지 않기 때문입니다). 일반적으로, 값이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면 매개 변수가 <code class="docutils literal notranslate"><span class="pre">key=&quot;value&quot;</span></code>로 추가되며, <code class="docutils literal notranslate"><span class="pre">None</span></code>이면 키만 추가됩니다. 값에 ASCII가 아닌 문자가 포함 되면, <code class="docutils literal notranslate"><span class="pre">(CHARSET,</span> <span class="pre">LANGUAGE,</span> <span class="pre">VALUE)</span></code> 형식으로 3-튜플로 지정할 수 있습니다. 여기서 <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code>은 값을 인코딩하는 데 사용할 문자 집합의 이름을 지정하는 문자열이고, <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code>는 일반적으로 <code class="docutils literal notranslate"><span class="pre">None</span></code>이나 빈 문자열(다른 가능성에 대해서는 <span class="target" id="index-25"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2231.html"><strong>RFC 2231</strong></a>를 참조하십시오)로 설정될 수 있고, <code class="docutils literal notranslate"><span class="pre">VALUE</span></code>는 비 ASCII 코드 포인트를 포함하는 문자열 값입니다. 3-튜플이 전달되지 않고 값에 ASCII가 아닌 문자가 포함되면, <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code>으로 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code>을 <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code>로 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 사용하여 <span class="target" id="index-26"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2231.html"><strong>RFC 2231</strong></a> 형식으로 자동 인코딩됩니다.</p>
<p>예를 들면 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Content-Disposition&#39;</span><span class="p">,</span> <span class="s1">&#39;attachment&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;bud.gif&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>이것은 다음과 같은 헤더를 추가합니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Content</span><span class="o">-</span><span class="n">Disposition</span><span class="p">:</span> <span class="n">attachment</span><span class="p">;</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;bud.gif&quot;</span>
</pre></div>
</div>
<p>비 ASCII 문자의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Content-Disposition&#39;</span><span class="p">,</span> <span class="s1">&#39;attachment&#39;</span><span class="p">,</span>
               <span class="n">filename</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;iso-8859-1&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;Fußballer.ppt&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>이것은 다음을 생성합니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Content</span><span class="o">-</span><span class="n">Disposition</span><span class="p">:</span> <span class="n">attachment</span><span class="p">;</span> <span class="n">filename</span><span class="o">*=</span><span class="s2">&quot;iso-8859-1&#39;&#39;Fu%DFballer.ppt&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.replace_header">
<code class="sig-name descname">replace_header</code><span class="sig-paren">(</span><em class="sig-param">_name</em>, <em class="sig-param">_value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.replace_header" title="정의 주소">¶</a></dt>
<dd><p>헤더를 교체합니다. 헤더 순서와 필드 이름 대소 문자를 유지하면서, 메시지에서 <em>_name</em>과 일치하는 첫 번째로 발견된 헤더를 교체합니다. 일치하는 헤더가 없으면, <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>가 발생합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_content_type">
<code class="sig-name descname">get_content_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_type" title="정의 주소">¶</a></dt>
<dd><p>메시지의 콘텐츠 유형을 반환합니다. 반환된 문자열은 <em class="mimetype">maintype/subtype</em> 형식의 소문자로 강제 변환됩니다. 메시지에 <em class="mailheader">Content-Type</em> 헤더가 없으면 <a class="reference internal" href="#email.message.Message.get_default_type" title="email.message.Message.get_default_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_default_type()</span></code></a>에서 제공하는 기본 유형이 반환됩니다. <span class="target" id="index-27"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a>에 따르면, 메시지는 항상 기본 유형을 가지므로, <a class="reference internal" href="#email.message.Message.get_content_type" title="email.message.Message.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a>는 항상 값을 반환합니다.</p>
<p><span class="target" id="index-28"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a>는 메시지가 <em class="mimetype">multipart/digest</em> 컨테이너 안에 등장(이 경우 기본 유형은 <em class="mimetype">message/rfc822</em>가 됩니다)하지 않는 한 기본 유형을 <em class="mimetype">text/plain</em>으로 정의합니다. <em class="mailheader">Content-Type</em> 헤더에 유효하지 않은 유형 명세가 있으면, <span class="target" id="index-29"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a>는 기본 유형이 <em class="mimetype">text/plain</em>으로 지정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_content_maintype">
<code class="sig-name descname">get_content_maintype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_maintype" title="정의 주소">¶</a></dt>
<dd><p>메시지의 주 콘텐츠 유형을 반환합니다. 이것은 <a class="reference internal" href="#email.message.Message.get_content_type" title="email.message.Message.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a>가 반환하는 문자열의 <em class="mimetype">maintype</em> 부분입니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_content_subtype">
<code class="sig-name descname">get_content_subtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_subtype" title="정의 주소">¶</a></dt>
<dd><p>메시지의 부 콘텐츠 유형을 반환합니다. 이것은 <a class="reference internal" href="#email.message.Message.get_content_type" title="email.message.Message.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a>가 반환하는 문자열의 <em class="mimetype">subtype</em> 부분입니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_default_type">
<code class="sig-name descname">get_default_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_default_type" title="정의 주소">¶</a></dt>
<dd><p>기본 콘텐츠 유형을 반환합니다. <em class="mimetype">multipart/digest</em> 컨테이너의 서브 파트인 메시지를 제외하고, 대부분의 메시지는 기본 콘텐츠 유형이 <em class="mimetype">text/plain</em>입니다. 이러한 서브 파트는 기본 콘텐츠 유형이 <em class="mimetype">message/rfc822</em>입니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.set_default_type">
<code class="sig-name descname">set_default_type</code><span class="sig-paren">(</span><em class="sig-param">ctype</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_default_type" title="정의 주소">¶</a></dt>
<dd><p>기본 콘텐츠 유형을 설정합니다. <em>ctype</em>은 <em class="mimetype">text/plain</em>이나 <em class="mimetype">message/rfc822</em>여야하지만 강제하지는 않습니다. 기본 콘텐츠 유형은 <em class="mailheader">Content-Type</em> 헤더에 저장되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_params">
<code class="sig-name descname">get_params</code><span class="sig-paren">(</span><em class="sig-param">failobj=None</em>, <em class="sig-param">header='content-type'</em>, <em class="sig-param">unquote=True</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_params" title="정의 주소">¶</a></dt>
<dd><p>메시지의 <em class="mailheader">Content-Type</em> 매개 변수를 리스트로 반환합니다. 반환된 리스트의 요소는 <code class="docutils literal notranslate"><span class="pre">'='</span></code> 부호로 분할된 키/값 쌍의 2-튜플입니다. <code class="docutils literal notranslate"><span class="pre">'='</span></code>의 왼쪽은 키이고 오른쪽은 값입니다. 매개 변수에 <code class="docutils literal notranslate"><span class="pre">'='</span></code> 부호가 없으면 값은 빈 문자열이고, 그렇지 않으면 값은 <a class="reference internal" href="#email.message.Message.get_param" title="email.message.Message.get_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_param()</span></code></a>에 설명된대로이며 선택적 <em>unquote</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>(기본값)이면 인용되지 않습니다.</p>
<p>선택적 <em>failobj</em>는 <em class="mailheader">Content-Type</em> 헤더가 없을 때 반환할 객체입니다. 선택적 <em>header</em>는 <em class="mailheader">Content-Type</em> 대신 검색할 헤더입니다.</p>
<p>이것은 레거시 메서드입니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 클래스에서 해당 기능은 헤더 액세스 메서드가 반환한 개별 헤더 객체의 <em>params</em> 프로퍼티로 대체됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_param">
<code class="sig-name descname">get_param</code><span class="sig-paren">(</span><em class="sig-param">param</em>, <em class="sig-param">failobj=None</em>, <em class="sig-param">header='content-type'</em>, <em class="sig-param">unquote=True</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_param" title="정의 주소">¶</a></dt>
<dd><p><em class="mailheader">Content-Type</em> 헤더의 매개 변수 <em>param</em>의 값을 문자열로 반환합니다. 메시지에 <em class="mailheader">Content-Type</em> 헤더가 없거나 그러한 매개 변수가 없으면, <em>failobj</em>가 반환됩니다 (기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다).</p>
<p>선택적 <em>header</em>가 제공되면, <em class="mailheader">Content-Type</em> 대신 사용할 메시지 헤더를 지정합니다.</p>
<p>매개 변수 키는 항상 대소 문자를 구분하지 않고 비교됩니다. 반환 값은 문자열이거나, 매개 변수가 <span class="target" id="index-30"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2231.html"><strong>RFC 2231</strong></a>로 인코딩되었으면 3-튜플일 수 있습니다. 3-튜플일 때, 값의 요소는 <code class="docutils literal notranslate"><span class="pre">(CHARSET,</span> <span class="pre">LANGUAGE,</span> <span class="pre">VALUE)</span></code> 형식입니다. <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code>과 <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code>는 모두 <code class="docutils literal notranslate"><span class="pre">None</span></code>일 수 있으며, 이 경우 <code class="docutils literal notranslate"><span class="pre">VALUE</span></code>가 <code class="docutils literal notranslate"><span class="pre">us-ascii</span></code> 문자 집합으로 인코딩된 것으로 간주해야함에 유의하십시오. 일반적으로 <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code>를 무시할 수 있습니다.</p>
<p>응용 프로그램이 <span class="target" id="index-31"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2231.html"><strong>RFC 2231</strong></a>로 매개 변수가 인코딩되었는지를 신경 쓰지 않으면, <a class="reference internal" href="email.utils.html#email.utils.collapse_rfc2231_value" title="email.utils.collapse_rfc2231_value"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.collapse_rfc2231_value()</span></code></a>를 호출하면서 <a class="reference internal" href="#email.message.Message.get_param" title="email.message.Message.get_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_param()</span></code></a>의 반환 값을 전달하여 매개 변수 값을 축소할 수 있습니다. 이것은 값이 튜플이면 적절하게 디코딩된 유니코드 문자열을 반환하고, 그렇지 않으면 원래 문자열을 인용 없이 반환합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">rawparam</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="n">param</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">collapse_rfc2231_value</span><span class="p">(</span><span class="n">rawparam</span><span class="p">)</span>
</pre></div>
</div>
<p>모든 경우에, <em>unquote</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 설정되어 있지 않으면, 매개 변수 값(반환 된 문자열이나 3 튜플의 <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> 항목)은 항상 인용되지 않습니다.</p>
<p>이것은 레거시 메서드입니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 클래스에서 해당 기능은 헤더 액세스 메서드가 반환한 개별 헤더 객체의 <em>params</em> 프로퍼티로 대체됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.set_param">
<code class="sig-name descname">set_param</code><span class="sig-paren">(</span><em class="sig-param">param</em>, <em class="sig-param">value</em>, <em class="sig-param">header='Content-Type'</em>, <em class="sig-param">requote=True</em>, <em class="sig-param">charset=None</em>, <em class="sig-param">language=''</em>, <em class="sig-param">replace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_param" title="정의 주소">¶</a></dt>
<dd><p><em class="mailheader">Content-Type</em> 헤더에서 매개 변수를 설정합니다. 매개 변수가 이미 헤더에 존재하면, 해당 값은 <em>value</em>로 대체됩니다. 이 메시지에 대해 <em class="mailheader">Content-Type</em> 헤더가 아직 정의되지 않았으면, <em class="mimetype">text/plain</em>로 설정되고 <span class="target" id="index-32"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html"><strong>RFC 2045</strong></a>에 따라 새 매개 변수 값이 추가됩니다.</p>
<p>선택적 <em>header</em>는 <em class="mailheader">Content-Type</em>의 대체 헤더를 지정하며, 선택적 <em>requote</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>(기본값은 <code class="docutils literal notranslate"><span class="pre">True</span></code>)가 아닌 한 모든 매개 변수가 필요에 따라 인용됩니다.</p>
<p>선택적 <em>charset</em>이 지정되면, 매개 변수는 <span class="target" id="index-33"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2231.html"><strong>RFC 2231</strong></a>에 따라 인코딩됩니다. 선택적 <em>language</em>는 RFC 2231 언어를 지정하며, 기본값은 빈 문자열입니다. <em>charset</em>과 <em>language</em>는 모두 문자열이어야합니다.</p>
<p><em>replace</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>(기본값)이면 헤더가 헤더 리스트의 끝으로 이동합니다. <em>replace</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, 헤더는 제자리에서 갱신됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">replace</span></code> 키워드가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.del_param">
<code class="sig-name descname">del_param</code><span class="sig-paren">(</span><em class="sig-param">param</em>, <em class="sig-param">header='content-type'</em>, <em class="sig-param">requote=True</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.del_param" title="정의 주소">¶</a></dt>
<dd><p><em class="mailheader">Content-Type</em> 헤더에서 지정된 매개 변수를 완전히 제거합니다. 매개 변수나 그 값 없이 헤더가 다시 작성됩니다. <em>requote</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>(기본값은 <code class="docutils literal notranslate"><span class="pre">True</span></code>)가 아닌 한 모든 값이 필요에 따라 인용됩니다. 선택적 <em>header</em>는 <em class="mailheader">Content-Type</em>의 대체 헤더를 지정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.set_type">
<code class="sig-name descname">set_type</code><span class="sig-paren">(</span><em class="sig-param">type</em>, <em class="sig-param">header='Content-Type'</em>, <em class="sig-param">requote=True</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_type" title="정의 주소">¶</a></dt>
<dd><p><em class="mailheader">Content-Type</em> 헤더의 주 유형과 부 유형을 설정합니다. <em>type</em>은 <em class="mimetype">maintype/subtype</em> 형식의 문자열이어야합니다, 그렇지 않으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p>이 메서드는 모든 매개 변수를 그대로 유지하면서 <em class="mailheader">Content-Type</em> 헤더를 대체합니다. <em>requote</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, 기존 헤더의 인용을 그대로 두고, 그렇지 않으면 매개 변수가 인용됩니다 (기본값).</p>
<p><em>header</em> 인자에 대체 헤더를 지정할 수 있습니다. <em class="mailheader">Content-Type</em> 헤더가 설정될 때 <em class="mailheader">MIME-Version</em> 헤더도 추가됩니다.</p>
<p>이것은 레거시 메서드입니다. <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> 클래스에서 해당 기능은 <code class="docutils literal notranslate"><span class="pre">make_</span></code>와 <code class="docutils literal notranslate"><span class="pre">add_</span></code> 메서드로 대체됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_filename">
<code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param">failobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_filename" title="정의 주소">¶</a></dt>
<dd><p>Return the value of the <code class="docutils literal notranslate"><span class="pre">filename</span></code> parameter of the
<em class="mailheader">Content-Disposition</em> header of the message.  If the header
does not have a <code class="docutils literal notranslate"><span class="pre">filename</span></code> parameter, this method falls back to looking
for the <code class="docutils literal notranslate"><span class="pre">name</span></code> parameter on the <em class="mailheader">Content-Type</em> header.  If
neither is found, or the header is missing, then <em>failobj</em> is returned.
The returned string will always be unquoted as per
<a class="reference internal" href="email.utils.html#email.utils.unquote" title="email.utils.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.unquote()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_boundary">
<code class="sig-name descname">get_boundary</code><span class="sig-paren">(</span><em class="sig-param">failobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_boundary" title="정의 주소">¶</a></dt>
<dd><p>Return the value of the <code class="docutils literal notranslate"><span class="pre">boundary</span></code> parameter of the
<em class="mailheader">Content-Type</em> header of the message, or <em>failobj</em> if either
the header is missing, or has no <code class="docutils literal notranslate"><span class="pre">boundary</span></code> parameter.  The returned
string will always be unquoted as per <a class="reference internal" href="email.utils.html#email.utils.unquote" title="email.utils.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.unquote()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.set_boundary">
<code class="sig-name descname">set_boundary</code><span class="sig-paren">(</span><em class="sig-param">boundary</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_boundary" title="정의 주소">¶</a></dt>
<dd><p>Set the <code class="docutils literal notranslate"><span class="pre">boundary</span></code> parameter of the <em class="mailheader">Content-Type</em> header to
<em>boundary</em>.  <a class="reference internal" href="#email.message.Message.set_boundary" title="email.message.Message.set_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_boundary()</span></code></a> will always quote <em>boundary</em> if
necessary.  A <a class="reference internal" href="email.errors.html#email.errors.HeaderParseError" title="email.errors.HeaderParseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HeaderParseError</span></code></a> is raised if the
message object has no <em class="mailheader">Content-Type</em> header.</p>
<p>Note that using this method is subtly different than deleting the old
<em class="mailheader">Content-Type</em> header and adding a new one with the new
boundary via <a class="reference internal" href="#email.message.Message.add_header" title="email.message.Message.add_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_header()</span></code></a>, because <a class="reference internal" href="#email.message.Message.set_boundary" title="email.message.Message.set_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_boundary()</span></code></a> preserves
the order of the <em class="mailheader">Content-Type</em> header in the list of
headers. However, it does <em>not</em> preserve any continuation lines which may
have been present in the original <em class="mailheader">Content-Type</em> header.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_content_charset">
<code class="sig-name descname">get_content_charset</code><span class="sig-paren">(</span><em class="sig-param">failobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_charset" title="정의 주소">¶</a></dt>
<dd><p>Return the <code class="docutils literal notranslate"><span class="pre">charset</span></code> parameter of the <em class="mailheader">Content-Type</em> header,
coerced to lower case.  If there is no <em class="mailheader">Content-Type</em> header, or if
that header has no <code class="docutils literal notranslate"><span class="pre">charset</span></code> parameter, <em>failobj</em> is returned.</p>
<p>Note that this method differs from <a class="reference internal" href="#email.message.Message.get_charset" title="email.message.Message.get_charset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_charset()</span></code></a> which returns the
<a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a> instance for the default encoding of the message body.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_charsets">
<code class="sig-name descname">get_charsets</code><span class="sig-paren">(</span><em class="sig-param">failobj=None</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_charsets" title="정의 주소">¶</a></dt>
<dd><p>Return a list containing the character set names in the message.  If the
message is a <em class="mimetype">multipart</em>, then the list will contain one element
for each subpart in the payload, otherwise, it will be a list of length 1.</p>
<p>Each item in the list will be a string which is the value of the
<code class="docutils literal notranslate"><span class="pre">charset</span></code> parameter in the <em class="mailheader">Content-Type</em> header for the
represented subpart.  However, if the subpart has no
<em class="mailheader">Content-Type</em> header, no <code class="docutils literal notranslate"><span class="pre">charset</span></code> parameter, or is not of
the <em class="mimetype">text</em> main MIME type, then that item in the returned list
will be <em>failobj</em>.</p>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.get_content_disposition">
<code class="sig-name descname">get_content_disposition</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_disposition" title="정의 주소">¶</a></dt>
<dd><p>Return the lowercased value (without parameters) of the message's
<em class="mailheader">Content-Disposition</em> header if it has one, or <code class="docutils literal notranslate"><span class="pre">None</span></code>.  The
possible values for this method are <em>inline</em>, <em>attachment</em> or <code class="docutils literal notranslate"><span class="pre">None</span></code>
if the message follows <span class="target" id="index-11"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2183.html"><strong>RFC 2183</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="email.message.Message.walk">
<code class="sig-name descname">walk</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.walk" title="정의 주소">¶</a></dt>
<dd><p>The <a class="reference internal" href="#email.message.Message.walk" title="email.message.Message.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a> method is an all-purpose generator which can be used to
iterate over all the parts and subparts of a message object tree, in
depth-first traversal order.  You will typically use <a class="reference internal" href="#email.message.Message.walk" title="email.message.Message.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a> as the
iterator in a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop; each iteration returns the next subpart.</p>
<p>Here's an example that prints the MIME type of every part of a multipart
message structure:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">walk</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">get_content_type</span><span class="p">())</span>
<span class="go">multipart/report</span>
<span class="go">text/plain</span>
<span class="go">message/delivery-status</span>
<span class="go">text/plain</span>
<span class="go">text/plain</span>
<span class="go">message/rfc822</span>
<span class="go">text/plain</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">walk</span></code> iterates over the subparts of any part where
<a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, even though
<code class="docutils literal notranslate"><span class="pre">msg.get_content_maintype()</span> <span class="pre">==</span> <span class="pre">'multipart'</span></code> may return <code class="docutils literal notranslate"><span class="pre">False</span></code>.  We
can see this in our example by making use of the <code class="docutils literal notranslate"><span class="pre">_structure</span></code> debug
helper function:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">walk</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">get_content_maintype</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;multipart&#39;</span><span class="p">,</span>
<span class="gp">... </span>          <span class="n">part</span><span class="o">.</span><span class="n">is_multipart</span><span class="p">())</span>
<span class="go">True True</span>
<span class="go">False False</span>
<span class="go">False True</span>
<span class="go">False False</span>
<span class="go">False False</span>
<span class="go">False True</span>
<span class="go">False False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_structure</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="go">multipart/report</span>
<span class="go">    text/plain</span>
<span class="go">    message/delivery-status</span>
<span class="go">        text/plain</span>
<span class="go">        text/plain</span>
<span class="go">    message/rfc822</span>
<span class="go">        text/plain</span>
</pre></div>
</div>
<p>Here the <code class="docutils literal notranslate"><span class="pre">message</span></code> parts are not <code class="docutils literal notranslate"><span class="pre">multiparts</span></code>, but they do contain
subparts. <code class="docutils literal notranslate"><span class="pre">is_multipart()</span></code> returns <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">walk</span></code> descends
into the subparts.</p>
</dd></dl>

<p><a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> objects can also optionally contain two instance attributes,
which can be used when generating the plain text of a MIME message.</p>
<dl class="attribute">
<dt id="email.message.Message.preamble">
<code class="sig-name descname">preamble</code><a class="headerlink" href="#email.message.Message.preamble" title="정의 주소">¶</a></dt>
<dd><p>The format of a MIME document allows for some text between the blank line
following the headers, and the first multipart boundary string. Normally,
this text is never visible in a MIME-aware mail reader because it falls
outside the standard MIME armor.  However, when viewing the raw text of
the message, or when viewing the message in a non-MIME aware reader, this
text can become visible.</p>
<p>The <em>preamble</em> attribute contains this leading extra-armor text for MIME
documents.  When the <a class="reference internal" href="email.parser.html#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> discovers some text
after the headers but before the first boundary string, it assigns this
text to the message's <em>preamble</em> attribute.  When the
<a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> is writing out the plain text
representation of a MIME message, and it finds the
message has a <em>preamble</em> attribute, it will write this text in the area
between the headers and the first boundary.  See <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code></a> and
<a class="reference internal" href="email.generator.html#module-email.generator" title="email.generator: Generate flat text email messages from a message structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.generator</span></code></a> for details.</p>
<p>Note that if the message object has no preamble, the <em>preamble</em> attribute
will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.message.Message.epilogue">
<code class="sig-name descname">epilogue</code><a class="headerlink" href="#email.message.Message.epilogue" title="정의 주소">¶</a></dt>
<dd><p>The <em>epilogue</em> attribute acts the same way as the <em>preamble</em> attribute,
except that it contains text that appears between the last boundary and
the end of the message.</p>
<p>You do not need to set the epilogue to the empty string in order for the
<a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> to print a newline at the end of the
file.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.message.Message.defects">
<code class="sig-name descname">defects</code><a class="headerlink" href="#email.message.Message.defects" title="정의 주소">¶</a></dt>
<dd><p>The <em>defects</em> attribute contains a list of all the problems found when
parsing this message.  See <a class="reference internal" href="email.errors.html#module-email.errors" title="email.errors: The exception classes used by the email package."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.errors</span></code></a> for a detailed description
of the possible parsing defects.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>이전 항목</h4>
  <p class="topless"><a href="email.examples.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code>: 예제</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="email.mime.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.mime</span></code>: 처음부터 이메일과 MIME 객체 만들기</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="email.mime.html" title="email.mime: 처음부터 이메일과 MIME 객체 만들기"
             >다음</a> |</li>
        <li class="right" >
          <a href="email.examples.html" title="email: 예제"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >인터넷 데이터 처리</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> --- 전자 메일과 MIME 처리 패키지</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>