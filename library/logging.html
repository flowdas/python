
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>16.6. logging --- 파이썬 로깅 시설 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="16.7. logging.config --- Logging configuration" href="logging.config.html" />
    <link rel="prev" title="16.5. getopt --- C-style parser for command line options" href="getopt.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="http://python.flowdas.com/library/logging.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="logging.config.html" title="16.7. logging.config --- Logging configuration"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="getopt.html" title="16.5. getopt --- C-style parser for command line options"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">16. 일반 운영 체제 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-logging">
<span id="logging-logging-facility-for-python"></span><h1>16.6. <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> --- 파이썬 로깅 시설<a class="headerlink" href="#module-logging" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/logging/__init__.py">Lib/logging/__init__.py</a></p>
<div class="sidebar" id="index-0">
<p class="first sidebar-title">Important</p>
<p>이 페이지는 API 레퍼런스 정보를 담고있습니다. 자습서 정보 및 고급 주제에 대한 설명은 다음을 참조하십시오.</p>
<ul class="last simple">
<li><a class="reference internal" href="../howto/logging.html#logging-basic-tutorial"><span class="std std-ref">기초 자습서</span></a></li>
<li><a class="reference internal" href="../howto/logging.html#logging-advanced-tutorial"><span class="std std-ref">고급 자습서</span></a></li>
<li><a class="reference internal" href="../howto/logging-cookbook.html#logging-cookbook"><span class="std std-ref">로깅 요리책</span></a></li>
</ul>
</div>
<hr class="docutils" />
<p>이 모듈은 응용 프로그램과 라이브러리를 위한 유연한 이벤트 로깅 시스템을 구현하는 함수와 클래스를 정의합니다.</p>
<p>표준 라이브러리 모듈로 로깅 API를 제공하는 것의 주요 이점은, 모든 파이썬 모듈이 로깅에 참여할 수 있어서, 응용 프로그램 로그에 여러분 자신의 메시지를 제삼자 모듈의 메시지와 통합할 수 있다는 것입니다.</p>
<p>이 모듈은 많은 기능과 유연성을 제공합니다. 로깅에 익숙하지 않다면, 감을 잡는 가장 좋은 방법은 자습서를 보는 것입니다 (오른쪽 링크를 참조하세요).</p>
<p>모듈에 의해 정의된 기본 클래스와 그 기능은 다음과 같습니다.</p>
<ul class="simple">
<li>로거는 응용 프로그램 코드가 직접 사용하는 인터페이스를 노출합니다.</li>
<li>처리기는 (로거가 만든) 로그 레코드를 적절한 목적지로 보냅니다.</li>
<li>필터는 출력할 로그 레코드를 결정하기위한 더 세분화된 기능을 제공합니다.</li>
<li>포매터는 최종 출력에서 ​​로그 레코드의 배치를 지정합니다.</li>
</ul>
<div class="section" id="logger-objects">
<span id="logger"></span><h2>16.6.1. 로거 객체<a class="headerlink" href="#logger-objects" title="제목 주소">¶</a></h2>
<p>로거에는 다음과 같은 어트리뷰트와 메서드가 있습니다. 로거는 결코 직접적으로 인스턴스를 만드는일 없이, 항상 모듈 수준의 함수 <code class="docutils literal"><span class="pre">logging.getLogger(name)</span></code> 를 거치는 것에 주의하십시오. 같은 이름(name)으로 <a class="reference internal" href="#logging.getLogger" title="logging.getLogger"><code class="xref py py-func docutils literal"><span class="pre">getLogger()</span></code></a> 를 여러번 호출해도 항상 같은 로거 객체에 대한 참조를 돌려줍니다.</p>
<p><code class="docutils literal"><span class="pre">name</span></code> 은 잠재적으로 <code class="docutils literal"><span class="pre">foo.bar.baz</span></code> 와 같이 마침표로 구분 된 계층적 값입니다 (하지만 그냥 간단한 <code class="docutils literal"><span class="pre">foo</span></code> 도 가능합니다). 계층적 목록에서 더 아래쪽에 있는 로거는 목록에서 상위에 있는 로거의 자식입니다. 예를 들어, 이름이 <code class="docutils literal"><span class="pre">foo</span></code> 인 로거가 주어지면, <code class="docutils literal"><span class="pre">foo.bar</span></code>, <code class="docutils literal"><span class="pre">foo.bar.baz</span></code>, 그리고 <code class="docutils literal"><span class="pre">foo.bam</span></code> 의 이름을 가진 로거는 모두 <code class="docutils literal"><span class="pre">foo</span></code> 의 자손입니다. 로거 이름 계층 구조는 파이썬 패키지 계층 구조와 비슷하며, <code class="docutils literal"><span class="pre">logging.getLogger(__name__)</span></code> 를 사용하여 모듈 단위로 로거를 구성하는 경우는 패키지 계층 구조와 같아집니다. 왜냐하면, 모듈에서, <code class="docutils literal"><span class="pre">__name__</span></code> 은 파이썬 패키지 이름 공간의 모듈 이름이기 때문입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><code class="docutils literal"><span class="pre">logging.getLogger(__name__)</span></code> 에 관한 설명은 <a class="reference internal" href="../howto/logging.html#logging-advanced-tutorial"><span class="std std-ref">고급 로깅 ​​자습서</span></a>
를 참고하세요.</p>
</div>
<dl class="class">
<dt id="logging.Logger">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">Logger</code><a class="headerlink" href="#logging.Logger" title="정의 주소">¶</a></dt>
<dd><dl class="attribute">
<dt id="logging.Logger.propagate">
<code class="descname">propagate</code><a class="headerlink" href="#logging.Logger.propagate" title="정의 주소">¶</a></dt>
<dd><p>이 어트리뷰트가 참으로 평가되면, 이 로거에 로그 된 이벤트는 이 로거에 첨부 된 처리기뿐 아니라 상위 계층 (조상) 로거의 처리기로 전달됩니다. 메시지는 조상 로거의 처리기에 직접 전달됩니다 - 조상 로거의 수준이나 필터는 고려하지 않습니다.</p>
<p>이 값이 거짓으로 평가되면, 로깅 메시지가 조상 로거의 처리기로 전달되지 않습니다.</p>
<p>생성자는 이 어트리뷰트를 <code class="docutils literal"><span class="pre">True</span></code> 로 설정합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">로거 <em>와</em> 하나 이상의 조상에 처리기를 중복해서 연결하면, 같은 레코드를 여러 번 출력할 수 있습니다. 일반적으로, 하나 이상의 로거에 처리기를 붙일 필요는 없습니다. 로거 계층에서 가장 높은 적절한 로거에 처리기를 연결하면, propagate 설정이 <code class="docutils literal"><span class="pre">True</span></code> 로 남아있는 모든 자식 로거들이 로그하는 모든 이벤트를 보게됩니다. 일반적인 시나리오는 루트 로거에만 처리기를 연결하고, 전파가 나머지를 처리하도록하는 것입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.setLevel">
<code class="descname">setLevel</code><span class="sig-paren">(</span><em>level</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.setLevel" title="정의 주소">¶</a></dt>
<dd><p>이 로거의 수준 경계를 <em>level</em> 로 설정합니다. <em>level</em> 보다 덜 심각한 로깅 메시지는 무시됩니다; 심각도 <em>level</em> 이상의 로깅 메시지는, 처리기 수준이 <em>level</em> 보다 높은 심각도 수준으로 설정되지 않는 한, 이 로거에 연결된 처리기에 의해 출력됩니다.</p>
<p>로거가 만들어질 때, 수준은 <code class="xref py py-const docutils literal"><span class="pre">NOTSET</span></code> (로거가 루트 로거 일 때는 모든 메시지를 처리하게하고, 로거가 루트 로거가 아니면 모든 메시지를 부모에게 위임하도록 합니다) 으로 설정됩니다. 루트 로거는 수준 <code class="xref py py-const docutils literal"><span class="pre">WARNING</span></code> 으로 만들어짐에 유의하세요.</p>
<p>'부모에게 위임' 이라는 말은, 로거 수준이 NOTSET 인 경우, NOTSET 이외의 수준을 갖는 조상이 발견되거나 루트에 도달 할 때까지 조상 로거 체인을 탐색함을 의미합니다.</p>
<p>NOTSET 이외의 수준을 갖는 조상이 발견되면, 그 조상의 수준을 조상 검색이 시작된 로거의 유효 수준으로 간주하여, 로깅 이벤트를 처리할지를 결정하는 데 사용됩니다.</p>
<p>루트에 도달하면, 그리고 루트가 NOTSET 수준을 갖고 있으면, 모든 메시지가 처리됩니다. 그렇지 않으면 루트 수준이 유효 수준으로 사용됩니다.</p>
<p>수준의 목록은 <a class="reference internal" href="#levels"><span class="std std-ref">로깅 수준</span></a> 를 보세요.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><em>level</em> 매개 변수는 이제 <code class="xref py py-const docutils literal"><span class="pre">INFO</span></code> 와 같은 정수 상수 대신 'INFO' 와 같은 수준의 문자열 표현을 허용합니다. 그러나 수준은 내부적으로 정수로 저장되며, <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal"><span class="pre">getEffectiveLevel()</span></code></a> 및 <a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal"><span class="pre">isEnabledFor()</span></code></a> 와 같은 메서드는 정수를 반환하거나 정수가 전달되기를 기대합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.isEnabledFor">
<code class="descname">isEnabledFor</code><span class="sig-paren">(</span><em>lvl</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.isEnabledFor" title="정의 주소">¶</a></dt>
<dd><p>심각도 <em>lvl</em> 의 메시지가 이 로거에서 처리될지를 알려줍니다. 이 메서드는 먼저 <code class="docutils literal"><span class="pre">logging.disable(lvl)</span></code> 에 의해 설정된 모듈 수준의 수준을 확인한 다음, <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal"><span class="pre">getEffectiveLevel()</span></code></a> 로 확인되는 로거의 유효 수준을 검사합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.getEffectiveLevel">
<code class="descname">getEffectiveLevel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.getEffectiveLevel" title="정의 주소">¶</a></dt>
<dd><p>이 로거의 유효 수준을 알려줍니다. <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal"><span class="pre">setLevel()</span></code></a> 을 사용하여 <code class="xref py py-const docutils literal"><span class="pre">NOTSET</span></code> 이외의 값이 설정되면, 그 값이 반환됩니다. 그렇지 않으면, <code class="xref py py-const docutils literal"><span class="pre">NOTSET</span></code> 이외의 값이 발견 될 때까지 루트를 향해 계층 구조를 탐색하고, 그 값이 반환됩니다. 반환되는 값은 정수이며, 일반적으로 <code class="xref py py-const docutils literal"><span class="pre">logging.DEBUG</span></code>, <code class="xref py py-const docutils literal"><span class="pre">logging.INFO</span></code> 등 중 하나입니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.getChild">
<code class="descname">getChild</code><span class="sig-paren">(</span><em>suffix</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.getChild" title="정의 주소">¶</a></dt>
<dd><p>접미사에 의해 결정되는, 이 로거의 자손 로거를 반환합니다. 그러므로, <code class="docutils literal"><span class="pre">logging.getLogger('abc').getChild('def.ghi')</span></code> 는 <code class="docutils literal"><span class="pre">logging.getLogger('abc.def.ghi')</span></code> 와 같은 로거를 반환합니다. 이것은 편의 메서드인데, 부모 로거가 리터럴 문자열이 아닌 이름(가령 <code class="docutils literal"><span class="pre">__name__</span></code>)을 사용하여 명명될 때 유용합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.debug">
<code class="descname">debug</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.debug" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 수준 <code class="xref py py-const docutils literal"><span class="pre">DEBUG</span></code> 메시지를 로그합니다. <em>msg</em> 는 메시지 포맷 문자열이고, <em>args</em> 는 문자열 포매팅 연산자를 사용하여 <em>msg</em> 에 병합되는 인자입니다. (이는 포맷 문자열에 키워드를 사용하고 인자로 하나의 딕셔너리를 전달할 수 있음을 의미합니다.)</p>
<p><em>kwargs</em> 에서 검사되는 세 개의 키워드 인자가 있습니다: <em>exc_info</em>, <em>stack_info</em> 및 <em>extra</em>.</p>
<p><em>exc_info</em> 가 거짓으로 평가되지 않으면, 로깅 메시지에 예외 정보가 추가됩니다. 예외 튜플 (<a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></code></a> 에 의해 반환되는 형식) 또는 예외 인스턴스가 제공되면 사용됩니다. 그렇지 않으면 예외 정보를 얻기 위해 <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></code></a> 를 호출합니다.</p>
<p>두 번째 선택적 키워드 인자는 <em>stack_info</em> 이며, 기본값은 <code class="docutils literal"><span class="pre">False</span></code> 입니다. 참이면, 실제 로깅 호출을 포함하는 스택 정보가 로깅 메시지에 추가됩니다. 이것은 <em>exc_info</em> 를 지정할 때 표시되는 것과 같은 스택 정보가 아닙니다: 전자(<em>stack_info</em>)는 스택의 맨 아래에서 현재 스레드의 로깅 호출까지의 스택 프레임이며, 후자(<em>exc_info</em>)는 예외가 일어난 후에 예외 처리기를 찾으면서 되감기된 스택 프레임에 대한 정보입니다.</p>
<p><em>exc_info</em> 와는 독립적으로 <em>stack_info</em> 를 지정할 수 있습니다. 예를 들어 예외가 발생하지 않은 경우에도 코드의 특정 지점에 어떻게 도달했는지 보여줄 수 있습니다. 스택 프레임은 다음과 같은 헤더 행 다음에 인쇄됩니다:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>Stack (most recent call last):
</pre></div>
</div>
<p>예외 프레임을 표시 할 때 사용되는 <code class="docutils literal"><span class="pre">Traceback</span> <span class="pre">(most</span> <span class="pre">recent</span> <span class="pre">call</span> <span class="pre">last):</span></code> 을 흉내내고 있습니다.</p>
<p>세 번째 키워드 인자는 <em>extra</em> 로, 로깅 이벤트 용으로 만들어진 LogRecord의 __dict__ 를 사용자 정의 어트리뷰트로 채우는 데 사용되는 딕셔너리을 전달할 수 있습니다. 이러한 사용자 정의 어트리뷰트은 원하는 대로 사용할 수 있습니다. 예를 들어, 로그 메시지에 포함시킬 수 있습니다. 예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">FORMAT</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%(asctime)-15s</span><span class="s1"> </span><span class="si">%(clientip)s</span><span class="s1"> </span><span class="si">%(user)-8s</span><span class="s1"> </span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">FORMAT</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;clientip&#39;</span><span class="p">:</span> <span class="s1">&#39;192.168.0.1&#39;</span><span class="p">,</span> <span class="s1">&#39;user&#39;</span><span class="p">:</span> <span class="s1">&#39;fbloggs&#39;</span><span class="p">}</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;tcpserver&#39;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Protocol problem: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;connection reset&#39;</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>는 이렇게 인쇄 할 것입니다</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
</pre></div>
</div>
<p><em>extra</em> 에 전달 된 딕셔너리의 키가, 로깅 시스템에서 사용하는 키와 충돌해서는 안됩니다. (어떤 키가 로깅 시스템에 의해 사용되는지에 대한 더 많은 정보는 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> 문서를 보십시오.)</p>
<p>로그 된 메시지에서 이러한 어트리뷰트를 사용하려면 몇 가지 주의를 기울여야합니다. 위의 예에서, 예를 들어, <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> 에 설정한 포맷 문자열은 LogRecord의 어트리뷰트 딕셔너리에 'clientip' 과 'user' 가 있을 것으로 기대하고 있습니다. 이 것들이 없는 경우 문자열 포매팅 예외가 발생하기 때문에 메시지가 기록되지 않습니다. 따라서 이 경우, 항상 이 키를 포함하는 <em>extra</em> 딕셔너리를 전달해야합니다.</p>
<p>성가신 일입니다만, 이 기능은 여러 문맥에서 같은 코드가 실행되고 관심있는 조건들(가령 원격 클라이언트 IP 주소와 인증된 사용자 이름)이 문맥에 따라 발생하는 다중 스레드 서버와 같은 특수한 상황을 위한 것입니다. 이런 상황에서는, 특수한 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> 가 특정한 <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal"><span class="pre">Handler</span></code></a> 와 함께 사용될 가능성이 높습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">로그에 문맥 정보를 추가하는 방법은 <a class="reference internal" href="../howto/logging-cookbook.html#context-info"><span class="std std-ref">로그 출력에 문맥 정보 추가</span></a> 에서 좀 더 자세히 설명합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span><em>stack_info</em> 매개 변수가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span><em>exc_info</em> 매개 변수는 이제 예외 인스턴스를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.info">
<code class="descname">info</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.info" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 수준 <code class="xref py py-const docutils literal"><span class="pre">INFO</span></code> 메시지를 로그합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal"><span class="pre">debug()</span></code></a> 처럼 해석됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.warning">
<code class="descname">warning</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.warning" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 수준 <code class="xref py py-const docutils literal"><span class="pre">WARNING</span></code> 메시지를 로그합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal"><span class="pre">debug()</span></code></a> 처럼 해석됩니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">기능적으로 <code class="docutils literal"><span class="pre">warning</span></code> 와 같은, 구식의 <code class="docutils literal"><span class="pre">warn</span></code> 메서드가 있습니다. <code class="docutils literal"><span class="pre">warn</span></code> 은 폐지되었으므로 사용하지 마십시오 - 대신 <code class="docutils literal"><span class="pre">warning</span></code> 을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.error">
<code class="descname">error</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.error" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 수준 <code class="xref py py-const docutils literal"><span class="pre">ERROR</span></code> 메시지를 로그합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal"><span class="pre">debug()</span></code></a> 처럼 해석됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.critical">
<code class="descname">critical</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.critical" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 수준 <code class="xref py py-const docutils literal"><span class="pre">CRITICAL</span></code> 메시지를 로그합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal"><span class="pre">debug()</span></code></a> 처럼 해석됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.log">
<code class="descname">log</code><span class="sig-paren">(</span><em>lvl</em>, <em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.log" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 정수 수준 <em>lvl</em> 로 메시지를 로깅합니다. 다른 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal"><span class="pre">debug()</span></code></a> 처럼 해석됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.exception">
<code class="descname">exception</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.exception" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 수준 <code class="xref py py-const docutils literal"><span class="pre">ERROR</span></code> 메시지를 로그합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal"><span class="pre">debug()</span></code></a> 처럼 해석됩니다. 예외 정보가 로깅 메시지에 추가됩니다. 이 메서드는 예외 처리기에서만 호출해야합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.addFilter">
<code class="descname">addFilter</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.addFilter" title="정의 주소">¶</a></dt>
<dd><p>지정된 필터 <em>filter</em> 를 이 로거에 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.removeFilter">
<code class="descname">removeFilter</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.removeFilter" title="정의 주소">¶</a></dt>
<dd><p>이 로거에서 지정된 필터 <em>filter</em> 를 제거합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.filter" title="정의 주소">¶</a></dt>
<dd><p>이 로거의 필터를 레코드(record)에 적용하고 레코드가 처리 대상이면 참값을 반환합니다. 필터 중 어느 하나가 거짓 값을 반환 할 때까지 필터는 차례로 참조됩니다. 그 중 아무 것도 거짓 값을 반환하지 않으면 레코드가 처리됩니다 (처리기로 전달됩니다). 어느 하나가 거짓 값을 반환하면, 더 이상의 레코드 처리는 이루어지지 않습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 메서드는 레코드가 처리될 대상인지를 확인만 할뿐 처리기로 전달하지는 않습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.addHandler">
<code class="descname">addHandler</code><span class="sig-paren">(</span><em>hdlr</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.addHandler" title="정의 주소">¶</a></dt>
<dd><p>지정된 처리기 <em>hdlr</em> 를 이 로거에 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.removeHandler">
<code class="descname">removeHandler</code><span class="sig-paren">(</span><em>hdlr</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.removeHandler" title="정의 주소">¶</a></dt>
<dd><p>이 로거에서 지정된 처리기 <em>hdlr</em> 을 제거합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.findCaller">
<code class="descname">findCaller</code><span class="sig-paren">(</span><em>stack_info=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.findCaller" title="정의 주소">¶</a></dt>
<dd><p>호출자의 소스 파일 이름과 행 번호를 찾습니다. 파일 이름, 행 번호, 함수 이름 및 스택 정보를 4-요소 튜플로 반환합니다. 스택 정보는 <em>stack_info</em> 가 <code class="docutils literal"><span class="pre">True</span></code> 가 아니면 <code class="docutils literal"><span class="pre">None</span></code> 으로 반환됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 메서드가 제공하는 4-튜플은 <a class="reference internal" href="#logging.Logger.makeRecord" title="logging.Logger.makeRecord"><code class="xref py py-meth docutils literal"><span class="pre">makeRecord()</span></code></a> 메서드의 <em>fn</em>, <em>lno</em>, <em>func</em>, <em>sinfo</em> 매개 변수로 전달됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.handle" title="정의 주소">¶</a></dt>
<dd><p>이 로거와 그 조상(거짓값의 <em>propagate</em> 가 발견될 때까지)과 연관된 모든 처리기에 레코드를 전달하여 레코드를 처리합니다. 이 메서드는 로컬에서 만든 레코드 뿐만 아니라 소켓에서 받아서 언피클된 레코드를 처리하는데 사용됩니다. <a class="reference internal" href="#logging.Logger.filter" title="logging.Logger.filter"><code class="xref py py-meth docutils literal"><span class="pre">filter()</span></code></a> 를 사용하여 로거 수준 필터링을 적용합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">소켓을 통해 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> 인스턴스를 피클된 형태로 원격에서 전달받을 수 있습니다.
중앙 집중형 로그 서버를 구성할 때 사용되는 방법입니다. 이 경우 언피클해서 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a>
인스턴스를 만들게되는데, 이를 <a class="reference internal" href="#logging.Logger.handle" title="logging.Logger.handle"><code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code></a> 메서드로 처리하면됩니다.
예제 코드는 <a class="reference internal" href="../howto/logging-cookbook.html#network-logging"><span class="std std-ref">네트워크에서 로깅 이벤트 보내고 받기</span></a> 를 참고하세요.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.makeRecord">
<code class="descname">makeRecord</code><span class="sig-paren">(</span><em>name</em>, <em>lvl</em>, <em>fn</em>, <em>lno</em>, <em>msg</em>, <em>args</em>, <em>exc_info</em>, <em>func=None</em>, <em>extra=None</em>, <em>sinfo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.makeRecord" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 특수한 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> 인스턴스를 만들기 위해 서브 클래스에서 재정의할 수있는 팩토리 메서드입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 팩토리 메서드보다는 보통 <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal"><span class="pre">setLogRecordFactory()</span></code></a> 를 사용합니다.
자세한 내용은 <a class="reference internal" href="../howto/logging-cookbook.html#custom-logrecord"><span class="std std-ref">사용자 정의 LogRecord</span></a> 를 참고하세요.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.hasHandlers">
<code class="descname">hasHandlers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.hasHandlers" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 처리기가 구성되어 있는지 확인합니다. 이 로거의 처리기와 로거 계층의 부모를 찾습니다. 처리기가 발견되면 <code class="docutils literal"><span class="pre">True</span></code> 를 반환하고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code> 를 반환합니다. 이 메서드는 'propagate' 어트리뷰트가 거짓으로 설정된 로거가 발견 될 때 계층 구조 검색을 중지합니다 - 그 로거가 처리기가 있는지 검사하는 마지막 로거가됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>이제 로거는 피클되고 언피클될 수 있습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="logging-levels">
<span id="levels"></span><h2>16.6.2. 로깅 수준<a class="headerlink" href="#logging-levels" title="제목 주소">¶</a></h2>
<p>로깅 수준의 숫자 값은 다음 표에 나와 있습니다. 여러분 자신의 수준을 정의하고, 미리 정의 된 수준과 상대적인 특정 값을 갖도록 하려는 경우 필요합니다. 같은 숫자 값을 가진 수준을 정의하면 미리 정의 된 값을 덮어 씁니다; 미리 정의 된 이름이 유실됩니다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">수준</th>
<th class="head">숫자 값</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CRITICAL</span></code></td>
<td>50</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">ERROR</span></code></td>
<td>40</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">WARNING</span></code></td>
<td>30</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">INFO</span></code></td>
<td>20</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">DEBUG</span></code></td>
<td>10</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">NOTSET</span></code></td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="handler-objects">
<span id="handler"></span><h2>16.6.3. 처리기 객체<a class="headerlink" href="#handler-objects" title="제목 주소">¶</a></h2>
<p>처리기에는 다음과 같은 어트리뷰트와 메서드가 있습니다. <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal"><span class="pre">Handler</span></code></a> 는 절대로 직접 인스턴스로 만들어지지 않음에 주의하세요; 이 클래스는 보다 유용한 서브 클래스의 베이스가 됩니다. 그러나, 서브 클래스의 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> 메서드는 <a class="reference internal" href="#logging.Handler.__init__" title="logging.Handler.__init__"><code class="xref py py-meth docutils literal"><span class="pre">Handler.__init__()</span></code></a> 을 호출해야합니다.</p>
<dl class="class">
<dt id="logging.Handler">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">Handler</code><a class="headerlink" href="#logging.Handler" title="정의 주소">¶</a></dt>
<dd><dl class="method">
<dt id="logging.Handler.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>level=NOTSET</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.__init__" title="정의 주소">¶</a></dt>
<dd><p>수준을 설정하고, 필터 목록을 빈리스트로 설정하고, I/O 메커니즘에 대한 액세스를 직렬화하기 위해 (<a class="reference internal" href="#logging.Handler.createLock" title="logging.Handler.createLock"><code class="xref py py-meth docutils literal"><span class="pre">createLock()</span></code></a> 을 사용하여) 록을 생성함으로써 <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal"><span class="pre">Handler</span></code></a> 인스턴스를 초기화합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.createLock">
<code class="descname">createLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.createLock" title="정의 주소">¶</a></dt>
<dd><p>스레드 안전하지 않은 하부 I/O 기능에 대한 액세스를 직렬화하는 데 사용할 수 있는 스레드 록을 초기화합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">기본적으로 <a class="reference internal" href="threading.html#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal"><span class="pre">threading.RLock</span></code></a> 을 만듭니다. 재진입 가능한 록입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.acquire">
<code class="descname">acquire</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.acquire" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.Handler.createLock" title="logging.Handler.createLock"><code class="xref py py-meth docutils literal"><span class="pre">createLock()</span></code></a> 로 생성 된 스레드 록을 확보합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.release" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.Handler.acquire" title="logging.Handler.acquire"><code class="xref py py-meth docutils literal"><span class="pre">acquire()</span></code></a> 로 확보한 스레드 록을 반납합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.setLevel">
<code class="descname">setLevel</code><span class="sig-paren">(</span><em>level</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.setLevel" title="정의 주소">¶</a></dt>
<dd><p>이 처리기의 수준 경계를 <em>level</em> 로 설정합니다. <em>level</em> 보다 덜 심각한 로깅 메시지는 무시됩니다. 처리기가 만들어질 때, 수준은 <code class="xref py py-const docutils literal"><span class="pre">NOTSET</span></code> (모든 메시지가 처리되게 합니다) 으로 설정됩니다.</p>
<p>수준의 목록은 <a class="reference internal" href="#levels"><span class="std std-ref">로깅 수준</span></a> 를 보세요.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><em>level</em> 매개 변수는 이제 <code class="xref py py-const docutils literal"><span class="pre">INFO</span></code> 와 같은 정수 상수 대신 'INFO' 와 같은 수준 문자열 표현을 허용합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.setFormatter">
<code class="descname">setFormatter</code><span class="sig-paren">(</span><em>fmt</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.setFormatter" title="정의 주소">¶</a></dt>
<dd><p>이 처리기의 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> 를 <em>fmt</em> 로 설정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.addFilter">
<code class="descname">addFilter</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.addFilter" title="정의 주소">¶</a></dt>
<dd><p>지정된 필터 <em>filter</em> 를 이 처리기에 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.removeFilter">
<code class="descname">removeFilter</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.removeFilter" title="정의 주소">¶</a></dt>
<dd><p>이 처리기에서 지정된 필터 <em>filter</em> 를 제거합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.filter" title="정의 주소">¶</a></dt>
<dd><p>이 처리기의 필터를 레코드에 적용하고 레코드가 처리 대상인 경우 참값을 반환합니다. 필터 중 어느 하나가 거짓 값을 반환 할 때까지 필터는 차례로 확인됩니다. 그 중 아무 것도 거짓 값을 반환하지 않으면 레코드가 출력됩니다. 어느 하나가 거짓 값을 반환하면 처리기는 레코드를 출력하지 않습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 메서드는 레코드가 처리될 대상인지를 확인만 할뿐 실제 처리하지는 않습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.flush" title="정의 주소">¶</a></dt>
<dd><p>모든 로그 출력이 플러시되었음을 확실히합니다. 이 버전은 아무 것도 하지 않으며, 서브 클래스에 의해 구현됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.close" title="정의 주소">¶</a></dt>
<dd><p>처리기가 사용하는 자원을 정리합니다. 이 버전은 출력을 하지 않지만, <a class="reference internal" href="#logging.shutdown" title="logging.shutdown"><code class="xref py py-func docutils literal"><span class="pre">shutdown()</span></code></a> 이 호출 될 때 닫히는 처리기의 내부 목록에서 처리기를 제거합니다. 서브 클래스는 이것이 재정의된 <a class="reference internal" href="#logging.Handler.close" title="logging.Handler.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> 메서드에서 이 메서드를 호출해야합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.handle" title="정의 주소">¶</a></dt>
<dd><p>처리기에 추가된 필터에 따라 조건부로, 지정된 로깅 레코드를 출력합니다. 레코드의 실제 출력을 I/O 스레드 록의 확보/해제로 둘러쌉니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.handleError">
<code class="descname">handleError</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.handleError" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#logging.Handler.emit" title="logging.Handler.emit"><code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code></a> 호출 중에 예외가 발생할 때 처리기에서 호출됩니다. 모듈 수준 어트리뷰트 <code class="docutils literal"><span class="pre">raiseExceptions</span></code> 가 <code class="docutils literal"><span class="pre">False</span></code> 인 경우 예외는 조용히 무시됩니다. 이 동작은 대부분 로깅 시스템에서 원하는 방식입니다 - 대부분의 사용자는 로깅 시스템 자체의 에러에 관심이 없고, 응용 프로그램 에러에 더 관심이 있습니다. 그러나 원하는 경우, 사용자 정의 처리기로 바꿀 수 있습니다. 지정된 레코드는 예외가 발생할 때 처리되고 있던 레코드입니다. (<code class="docutils literal"><span class="pre">raiseExceptions</span></code> 의 기본값은 <code class="docutils literal"><span class="pre">True</span></code> 입니다. 개발 중에 더 유용합니다).</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><a class="reference internal" href="#logging.Handler.handleError" title="logging.Handler.handleError"><code class="xref py py-meth docutils literal"><span class="pre">handleError()</span></code></a> 를 호출하는 책임은 <a class="reference internal" href="#logging.Handler.emit" title="logging.Handler.emit"><code class="xref py py-meth docutils literal"><span class="pre">emit()</span></code></a> 구현에 있습니다.
<a class="reference internal" href="#logging.Handler.handle" title="logging.Handler.handle"><code class="xref py py-meth docutils literal"><span class="pre">handle()</span></code></a> 은 <a class="reference internal" href="#logging.Handler.handleError" title="logging.Handler.handleError"><code class="xref py py-meth docutils literal"><span class="pre">handleError()</span></code></a> 를 호출하지 않습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.format">
<code class="descname">format</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.format" title="정의 주소">¶</a></dt>
<dd><p>레코드를 포매팅 합니다 - 포매터가 설정된 경우 사용합니다. 그렇지 않으면 모듈의 기본 포매터를 사용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.emit" title="정의 주소">¶</a></dt>
<dd><p>지정된 로깅 레코드를 실제로 로깅하는 데 필요한 작업을 수행합니다. 이 버전은 서브 클래스에 의해 구현될 것으로 보고 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> 를 발생시킵니다.</p>
</dd></dl>

</dd></dl>

<p>표준으로 포함 된 처리기 목록은 <a class="reference internal" href="logging.handlers.html#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a> 를 참조하십시오.</p>
</div>
<div class="section" id="formatter-objects">
<span id="id1"></span><h2>16.6.4. 포매터 객체<a class="headerlink" href="#formatter-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> 객체는 다음과 같은 어트리뷰트과 메서드를 가지고 있습니다. 이들은 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> 를 (보통) 사람이나 외부 시스템이 해석 할 수 있는 문자열로 변환하는 역할을 합니다. 베이스 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> 는 포매팅 문자열을 지정할 수 있게 합니다. 아무 것도 지정하지 않으면, <code class="docutils literal"><span class="pre">'%(message)s'</span></code> 이 기본값으로 사용되는데, 단지 로깅 호출에서 제공된 메시지만 포함됩니다. 포맷된 출력에 추가 정보(가령 타임스탬프)를 넣으려면 계속 읽으십시오.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">어트리뷰트를 따로 명시하지 않아서 찾기 불편하지만, 본문에는 <code class="xref py py-attr docutils literal"><span class="pre">Formatter.converter</span></code>,
<code class="xref py py-attr docutils literal"><span class="pre">Formatter.default_time_format</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">Formatter.default_msec_format</span></code>
이 정의되어 있습니다.</p>
</div>
<p>포매터는 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> 어트리뷰트에 포함된 정보를 사용하는 포맷 문자열로 초기화될 수 있습니다 - 위에서 언급 한 기본값은 사용자의 메시지와 인자가 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> 의 <em>message</em> 어트리뷰트로 미리 포맷된다는 사실을 활용합니다. 이 포맷 문자열은 표준 파이썬 %-스타일 매핑 키를 포함합니다. 문자열 포맷팅에 대해서 더 많은 정보가 필요하면 <a class="reference internal" href="stdtypes.html#old-string-formatting"><span class="std std-ref">printf 스타일 문자열 포매팅</span></a> 를 보세요.</p>
<p><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> 에 있는 유용한 매핑 키는 <a class="reference internal" href="#logrecord-attributes"><span class="std std-ref">LogRecord attributes</span></a> 섹션에 있습니다.</p>
<dl class="class">
<dt id="logging.Formatter">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">Formatter</code><span class="sig-paren">(</span><em>fmt=None</em>, <em>datefmt=None</em>, <em>style='%'</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> 클래스의 새로운 인스턴스를 반환합니다. 인스턴스는 전체 메시지의 포맷 문자열과 메시지의 날짜/시간 부분에 대한 포맷 문자열로 초기화됩니다. <em>fmt</em> 가 지정되지 않으면 <code class="docutils literal"><span class="pre">'%(message)s'</span></code> 가 사용됩니다. <em>datefmt</em> 가 지정되지 않으면 <a class="reference internal" href="#logging.Formatter.formatTime" title="logging.Formatter.formatTime"><code class="xref py py-meth docutils literal"><span class="pre">formatTime()</span></code></a> 설명서에 기술된 포맷이 사용됩니다.</p>
<p><em>style</em> 매개 변수는 '%', '{' 또는 '$' 중 하나 일 수 있으며, 포맷 문자열이 데이터와 병합되는 방식을 결정합니다: %-포매팅, <a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal"><span class="pre">str.format()</span></code></a> 또는 <a class="reference internal" href="string.html#string.Template" title="string.Template"><code class="xref py py-class docutils literal"><span class="pre">string.Template</span></code></a> 중 하나를 사용합니다. 로그 메시지에 {- 와 $-포매팅을 사용하는 방법에 대한 자세한 내용은 <a class="reference internal" href="../howto/logging-cookbook.html#formatting-styles"><span class="std std-ref">응용 프로그램 전체에서 특정 포맷 스타일 사용하기</span></a> 을 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><em>style</em> 매개 변수가 추가되었습니다.</p>
</div>
<dl class="method">
<dt id="logging.Formatter.format">
<code class="descname">format</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.format" title="정의 주소">¶</a></dt>
<dd><p>레코드의 어트리뷰트 딕셔너리가 문자열 포매팅 연산의 피연산자로 사용됩니다. 결과 문자열을 반환합니다. 딕셔너리를 포맷하기 전에 몇 가지 준비 단계가 수행됩니다. 레코드의 <em>message</em> 어트리뷰트를 <em>msg</em> % <em>args</em> 를 사용하여 계산합니다. 포매팅 문자열에 <code class="docutils literal"><span class="pre">'(asctime)'</span></code> 이 들어 있으면, <a class="reference internal" href="#logging.Formatter.formatTime" title="logging.Formatter.formatTime"><code class="xref py py-meth docutils literal"><span class="pre">formatTime()</span></code></a> 이 호출되어 이벤트 시간을 포매팅합니다. 예외 정보가 있는 경우, <a class="reference internal" href="#logging.Formatter.formatException" title="logging.Formatter.formatException"><code class="xref py py-meth docutils literal"><span class="pre">formatException()</span></code></a> 을 사용하여 포매팅되고 메시지에 덧붙입니다. 포맷된 예외 정보는 <em>exc_text</em> 어트리뷰트에 캐시됩니다. 예외 정보를 피클해서 네트워크를 통해 전송할 수 있기 때문에 유용합니다만, 예외 정보의 포매팅을 사용자 정의하는 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> 서브 클래스가 두 개 이상 있는 경우 주의해야 합니다. 이 경우, 한 포매터가 포매팅을 완료 한 후 캐시 된 값을 지워서 그 이벤트를 처리하는 다음 포매터가 캐시 된 값을 사용하지 않고 새로 계산할 수 있도록 해야합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><em>exc_text</em> 는 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> 의 어트리뷰트입니다.</p>
</div>
<p>스택 정보가 있는 경우, 예외 정보 뒤에 덧붙입니다. 필요할 경우 <a class="reference internal" href="#logging.Formatter.formatStack" title="logging.Formatter.formatStack"><code class="xref py py-meth docutils literal"><span class="pre">formatStack()</span></code></a> 을 사용하여 변환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Formatter.formatTime">
<code class="descname">formatTime</code><span class="sig-paren">(</span><em>record</em>, <em>datefmt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.formatTime" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 포맷된 시간을 사용하려는 포매터에 의해 <a class="reference internal" href="functions.html#format" title="format"><code class="xref py py-meth docutils literal"><span class="pre">format()</span></code></a> 에서 호출되어야합니다. 이 메서드는 특정 요구 사항을 제공하기 위해 포매터에서 재정의 될 수 있지만, 기본 동작은 다음과 같습니다: <em>datefmt</em> (문자열) 이 지정된 경우, <a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal"><span class="pre">time.strftime()</span></code></a> 를 사용하여 레코드 생성 시간을 포매팅합니다. 그렇지 않으면 '%Y-%m-%d %H:%M:%S,uuu' 포맷이 사용됩니다. 여기서 uuu 부분은 밀리 초 값이고, 다른 문자들은 <a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal"><span class="pre">time.strftime()</span></code></a> 설명서를 따릅니다. 이 포맷의 표현된 시간의 예는 <code class="docutils literal"><span class="pre">2003-01-23</span> <span class="pre">00:29:50,411</span></code> 입니다. 결과 문자열이 반환됩니다.</p>
<p>이 함수는 사용자가 구성 할 수있는 함수를 사용하여 생성 시간을 튜플로 변환합니다. 기본적으로 <a class="reference internal" href="time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal"><span class="pre">time.localtime()</span></code></a> 이 사용됩니다; 특정 포매터 인스턴스에서 이를 변경하려면, <code class="docutils literal"><span class="pre">converter</span></code> 어트리뷰트을 <a class="reference internal" href="time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal"><span class="pre">time.localtime()</span></code></a> 또는 <a class="reference internal" href="time.html#time.gmtime" title="time.gmtime"><code class="xref py py-func docutils literal"><span class="pre">time.gmtime()</span></code></a> 과 같은 서명을 가진 함수로 설정하십시오. 모든 포매터를 변경하려면, 예를 들어 모든 로깅 시간을 GMT로 표시하려면, <code class="docutils literal"><span class="pre">Formatter</span></code> 클래스의 <code class="docutils literal"><span class="pre">converter</span></code> 어트리뷰트을 설정하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>예전에는, 기본 포맷이 다음과 같이 하드 코딩되었습니다: <code class="docutils literal"><span class="pre">2010-09-06</span> <span class="pre">22:38:15,292</span></code>. 쉼표 앞에있는 부분은 strptime 포맷 문자열(<code class="docutils literal"><span class="pre">'%Y-%m-%d</span> <span class="pre">%H:%M:%S'</span></code>)이며, 쉼표 뒤의 부분은 밀리 초 값입니다. strptime에 밀리 초 포맷 표시자가 없기 때문에, 밀리 초 값은 다른 포맷 문자열 <code class="docutils literal"><span class="pre">'%s,%03d'</span></code> 을 사용하여 추가됩니다 --- 이 두 포맷 문자열 모두 이 메서드에 하드 코드되었습니다. 이 변경으로, 이 문자열들은 클래스 수준 어트리뷰트로 정의되었고, 원하는 경우 인스턴스 수준에서 재정의 할 수 있습니다. 어트리뷰트 이름은 <code class="docutils literal"><span class="pre">default_time_format</span></code> (strptime 포맷 문자열) 과 <code class="docutils literal"><span class="pre">default_msec_format</span></code> (밀리 초 값 추가 용) 입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Formatter.formatException">
<code class="descname">formatException</code><span class="sig-paren">(</span><em>exc_info</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.formatException" title="정의 주소">¶</a></dt>
<dd><p>지정된 예외 정보(<a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></code></a> 에 의해 반환되는 표준 예외 튜플)를 문자열로 포맷합니다. 이 기본 구현은 <a class="reference internal" href="traceback.html#traceback.print_exception" title="traceback.print_exception"><code class="xref py py-func docutils literal"><span class="pre">traceback.print_exception()</span></code></a> 을 사용합니다. 결과 문자열이 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Formatter.formatStack">
<code class="descname">formatStack</code><span class="sig-paren">(</span><em>stack_info</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.formatStack" title="정의 주소">¶</a></dt>
<dd><p>지정된 스택 정보(<a class="reference internal" href="traceback.html#traceback.print_stack" title="traceback.print_stack"><code class="xref py py-func docutils literal"><span class="pre">traceback.print_stack()</span></code></a> 에 의해 반환된 문자열이지만 마지막 줄 바꿈이 제거됩니다)을 문자열로 포맷합니다. 이 기본 구현은 입력 값을 그대로 반환합니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="filter-objects">
<span id="filter"></span><h2>16.6.5. 필터 객체<a class="headerlink" href="#filter-objects" title="제목 주소">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Filters</span></code> can be used by <code class="docutils literal"><span class="pre">Handlers</span></code> and <code class="docutils literal"><span class="pre">Loggers</span></code> for more sophisticated
filtering than is provided by levels. The base filter class only allows events
which are below a certain point in the logger hierarchy. For example, a filter
initialized with 'A.B' will allow events logged by loggers 'A.B', 'A.B.C',
'A.B.C.D', 'A.B.D' etc. but not 'A.BB', 'B.A.B' etc. If initialized with the
empty string, all events are passed.</p>
<dl class="class">
<dt id="logging.Filter">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">Filter</code><span class="sig-paren">(</span><em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Filter" title="정의 주소">¶</a></dt>
<dd><p>Returns an instance of the <a class="reference internal" href="#logging.Filter" title="logging.Filter"><code class="xref py py-class docutils literal"><span class="pre">Filter</span></code></a> class. If <em>name</em> is specified, it
names a logger which, together with its children, will have its events allowed
through the filter. If <em>name</em> is the empty string, allows every event.</p>
<dl class="method">
<dt id="logging.Filter.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Filter.filter" title="정의 주소">¶</a></dt>
<dd><p>Is the specified record to be logged? Returns zero for no, nonzero for
yes. If deemed appropriate, the record may be modified in-place by this
method.</p>
</dd></dl>

</dd></dl>

<p>Note that filters attached to handlers are consulted before an event is
emitted by the handler, whereas filters attached to loggers are consulted
whenever an event is logged (using <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.info" title="logging.info"><code class="xref py py-meth docutils literal"><span class="pre">info()</span></code></a>,
etc.), before sending an event to handlers. This means that events which have
been generated by descendant loggers will not be filtered by a logger's filter
setting, unless the filter has also been applied to those descendant loggers.</p>
<p>You don't actually need to subclass <code class="docutils literal"><span class="pre">Filter</span></code>: you can pass any instance
which has a <code class="docutils literal"><span class="pre">filter</span></code> method with the same semantics.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>You don't need to create specialized <code class="docutils literal"><span class="pre">Filter</span></code> classes, or use other
classes with a <code class="docutils literal"><span class="pre">filter</span></code> method: you can use a function (or other
callable) as a filter. The filtering logic will check to see if the filter
object has a <code class="docutils literal"><span class="pre">filter</span></code> attribute: if it does, it's assumed to be a
<code class="docutils literal"><span class="pre">Filter</span></code> and its <a class="reference internal" href="#logging.Filter.filter" title="logging.Filter.filter"><code class="xref py py-meth docutils literal"><span class="pre">filter()</span></code></a> method is called. Otherwise, it's
assumed to be a callable and called with the record as the single
parameter. The returned value should conform to that returned by
<a class="reference internal" href="#logging.Filter.filter" title="logging.Filter.filter"><code class="xref py py-meth docutils literal"><span class="pre">filter()</span></code></a>.</p>
</div>
<p>Although filters are used primarily to filter records based on more
sophisticated criteria than levels, they get to see every record which is
processed by the handler or logger they're attached to: this can be useful if
you want to do things like counting how many records were processed by a
particular logger or handler, or adding, changing or removing attributes in
the LogRecord being processed. Obviously changing the LogRecord needs to be
done with some care, but it does allow the injection of contextual information
into logs (see <a class="reference internal" href="../howto/logging-cookbook.html#filters-contextual"><span class="std std-ref">문맥 정보 전달에 필터 사용하기</span></a>).</p>
</div>
<div class="section" id="logrecord-objects">
<span id="log-record"></span><h2>16.6.6. LogRecord Objects<a class="headerlink" href="#logrecord-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> instances are created automatically by the <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal"><span class="pre">Logger</span></code></a>
every time something is logged, and can be created manually via
<a class="reference internal" href="#logging.makeLogRecord" title="logging.makeLogRecord"><code class="xref py py-func docutils literal"><span class="pre">makeLogRecord()</span></code></a> (for example, from a pickled event received over the
wire).</p>
<dl class="class">
<dt id="logging.LogRecord">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">LogRecord</code><span class="sig-paren">(</span><em>name</em>, <em>level</em>, <em>pathname</em>, <em>lineno</em>, <em>msg</em>, <em>args</em>, <em>exc_info</em>, <em>func=None</em>, <em>sinfo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.LogRecord" title="정의 주소">¶</a></dt>
<dd><p>Contains all the information pertinent to the event being logged.</p>
<p>The primary information is passed in <code class="xref py py-attr docutils literal"><span class="pre">msg</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">args</span></code>, which
are combined using <code class="docutils literal"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">args</span></code> to create the <code class="xref py py-attr docutils literal"><span class="pre">message</span></code> field of the
record.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">매개 변수:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> -- The name of the logger used to log the event represented by
this LogRecord. Note that this name will always have this
value, even though it may be emitted by a handler attached to
a different (ancestor) logger.</li>
<li><strong>level</strong> -- The numeric level of the logging event (one of DEBUG, INFO etc.)
Note that this is converted to <em>two</em> attributes of the LogRecord:
<code class="docutils literal"><span class="pre">levelno</span></code> for the numeric value and <code class="docutils literal"><span class="pre">levelname</span></code> for the
corresponding level name.</li>
<li><strong>pathname</strong> -- The full pathname of the source file where the logging call
was made.</li>
<li><strong>lineno</strong> -- The line number in the source file where the logging call was
made.</li>
<li><strong>msg</strong> -- The event description message, possibly a format string with
placeholders for variable data.</li>
<li><strong>args</strong> -- Variable data to merge into the <em>msg</em> argument to obtain the
event description.</li>
<li><strong>exc_info</strong> -- An exception tuple with the current exception information,
or <code class="docutils literal"><span class="pre">None</span></code> if no exception information is available.</li>
<li><strong>func</strong> -- The name of the function or method from which the logging call
was invoked.</li>
<li><strong>sinfo</strong> -- A text string representing stack information from the base of
the stack in the current thread, up to the logging call.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="logging.LogRecord.getMessage">
<code class="descname">getMessage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.LogRecord.getMessage" title="정의 주소">¶</a></dt>
<dd><p>Returns the message for this <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> instance after merging any
user-supplied arguments with the message. If the user-supplied message
argument to the logging call is not a string, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> is called on it to
convert it to a string. This allows use of user-defined classes as
messages, whose <code class="docutils literal"><span class="pre">__str__</span></code> method can return the actual format string to
be used.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>The creation of a <code class="docutils literal"><span class="pre">LogRecord</span></code> has been made more configurable by
providing a factory which is used to create the record. The factory can be
set using <a class="reference internal" href="#logging.getLogRecordFactory" title="logging.getLogRecordFactory"><code class="xref py py-func docutils literal"><span class="pre">getLogRecordFactory()</span></code></a> and <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal"><span class="pre">setLogRecordFactory()</span></code></a>
(see this for the factory's signature).</p>
</div>
<p>This functionality can be used to inject your own values into a
LogRecord at creation time. You can use the following pattern:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">old_factory</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogRecordFactory</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">record_factory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">record</span> <span class="o">=</span> <span class="n">old_factory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">record</span><span class="o">.</span><span class="n">custom_attribute</span> <span class="o">=</span> <span class="mh">0xdecafbad</span>
    <span class="k">return</span> <span class="n">record</span>

<span class="n">logging</span><span class="o">.</span><span class="n">setLogRecordFactory</span><span class="p">(</span><span class="n">record_factory</span><span class="p">)</span>
</pre></div>
</div>
<p>With this pattern, multiple factories could be chained, and as long
as they don't overwrite each other's attributes or unintentionally
overwrite the standard attributes listed above, there should be no
surprises.</p>
</dd></dl>

</div>
<div class="section" id="logrecord-attributes">
<span id="id2"></span><h2>16.6.7. LogRecord attributes<a class="headerlink" href="#logrecord-attributes" title="제목 주소">¶</a></h2>
<p>The LogRecord has a number of attributes, most of which are derived from the
parameters to the constructor. (Note that the names do not always correspond
exactly between the LogRecord constructor parameters and the LogRecord
attributes.) These attributes can be used to merge data from the record into
the format string. The following table lists (in alphabetical order) the
attribute names, their meanings and the corresponding placeholder in a %-style
format string.</p>
<p>If you are using {}-formatting (<a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-func docutils literal"><span class="pre">str.format()</span></code></a>), you can use
<code class="docutils literal"><span class="pre">{attrname}</span></code> as the placeholder in the format string. If you are using
$-formatting (<a class="reference internal" href="string.html#string.Template" title="string.Template"><code class="xref py py-class docutils literal"><span class="pre">string.Template</span></code></a>), use the form <code class="docutils literal"><span class="pre">${attrname}</span></code>. In
both cases, of course, replace <code class="docutils literal"><span class="pre">attrname</span></code> with the actual attribute name
you want to use.</p>
<p>In the case of {}-formatting, you can specify formatting flags by placing them
after the attribute name, separated from it with a colon. For example: a
placeholder of <code class="docutils literal"><span class="pre">{msecs:03d}</span></code> would format a millisecond value of <code class="docutils literal"><span class="pre">4</span></code> as
<code class="docutils literal"><span class="pre">004</span></code>. Refer to the <a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal"><span class="pre">str.format()</span></code></a> documentation for full details on
the options available to you.</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="28%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute name</th>
<th class="head">Format</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>args</td>
<td>You shouldn't need to
format this yourself.</td>
<td>The tuple of arguments merged into <code class="docutils literal"><span class="pre">msg</span></code> to
produce <code class="docutils literal"><span class="pre">message</span></code>, or a dict whose values
are used for the merge (when there is only one
argument, and it is a dictionary).</td>
</tr>
<tr class="row-odd"><td>asctime</td>
<td><code class="docutils literal"><span class="pre">%(asctime)s</span></code></td>
<td>Human-readable time when the
<a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> was created.  By default
this is of the form '2003-07-08 16:49:45,896'
(the numbers after the comma are millisecond
portion of the time).</td>
</tr>
<tr class="row-even"><td>created</td>
<td><code class="docutils literal"><span class="pre">%(created)f</span></code></td>
<td>Time when the <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> was created
(as returned by <a class="reference internal" href="time.html#time.time" title="time.time"><code class="xref py py-func docutils literal"><span class="pre">time.time()</span></code></a>).</td>
</tr>
<tr class="row-odd"><td>exc_info</td>
<td>You shouldn't need to
format this yourself.</td>
<td>Exception tuple (à la <code class="docutils literal"><span class="pre">sys.exc_info</span></code>) or,
if no exception has occurred, <code class="docutils literal"><span class="pre">None</span></code>.</td>
</tr>
<tr class="row-even"><td>filename</td>
<td><code class="docutils literal"><span class="pre">%(filename)s</span></code></td>
<td>Filename portion of <code class="docutils literal"><span class="pre">pathname</span></code>.</td>
</tr>
<tr class="row-odd"><td>funcName</td>
<td><code class="docutils literal"><span class="pre">%(funcName)s</span></code></td>
<td>Name of function containing the logging call.</td>
</tr>
<tr class="row-even"><td>levelname</td>
<td><code class="docutils literal"><span class="pre">%(levelname)s</span></code></td>
<td>Text logging level for the message
(<code class="docutils literal"><span class="pre">'DEBUG'</span></code>, <code class="docutils literal"><span class="pre">'INFO'</span></code>, <code class="docutils literal"><span class="pre">'WARNING'</span></code>,
<code class="docutils literal"><span class="pre">'ERROR'</span></code>, <code class="docutils literal"><span class="pre">'CRITICAL'</span></code>).</td>
</tr>
<tr class="row-odd"><td>levelno</td>
<td><code class="docutils literal"><span class="pre">%(levelno)s</span></code></td>
<td>Numeric logging level for the message
(<code class="xref py py-const docutils literal"><span class="pre">DEBUG</span></code>, <code class="xref py py-const docutils literal"><span class="pre">INFO</span></code>,
<code class="xref py py-const docutils literal"><span class="pre">WARNING</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ERROR</span></code>,
<code class="xref py py-const docutils literal"><span class="pre">CRITICAL</span></code>).</td>
</tr>
<tr class="row-even"><td>lineno</td>
<td><code class="docutils literal"><span class="pre">%(lineno)d</span></code></td>
<td>Source line number where the logging call was
issued (if available).</td>
</tr>
<tr class="row-odd"><td>message</td>
<td><code class="docutils literal"><span class="pre">%(message)s</span></code></td>
<td>The logged message, computed as <code class="docutils literal"><span class="pre">msg</span> <span class="pre">%</span>
<span class="pre">args</span></code>. This is set when
<a class="reference internal" href="#logging.Formatter.format" title="logging.Formatter.format"><code class="xref py py-meth docutils literal"><span class="pre">Formatter.format()</span></code></a> is invoked.</td>
</tr>
<tr class="row-even"><td>module</td>
<td><code class="docutils literal"><span class="pre">%(module)s</span></code></td>
<td>Module (name portion of <code class="docutils literal"><span class="pre">filename</span></code>).</td>
</tr>
<tr class="row-odd"><td>msecs</td>
<td><code class="docutils literal"><span class="pre">%(msecs)d</span></code></td>
<td>Millisecond portion of the time when the
<a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> was created.</td>
</tr>
<tr class="row-even"><td>msg</td>
<td>You shouldn't need to
format this yourself.</td>
<td>The format string passed in the original
logging call. Merged with <code class="docutils literal"><span class="pre">args</span></code> to
produce <code class="docutils literal"><span class="pre">message</span></code>, or an arbitrary object
(see <a class="reference internal" href="../howto/logging.html#arbitrary-object-messages"><span class="std std-ref">임의의 객체를 메시지로 사용하기</span></a>).</td>
</tr>
<tr class="row-odd"><td>name</td>
<td><code class="docutils literal"><span class="pre">%(name)s</span></code></td>
<td>Name of the logger used to log the call.</td>
</tr>
<tr class="row-even"><td>pathname</td>
<td><code class="docutils literal"><span class="pre">%(pathname)s</span></code></td>
<td>Full pathname of the source file where the
logging call was issued (if available).</td>
</tr>
<tr class="row-odd"><td>process</td>
<td><code class="docutils literal"><span class="pre">%(process)d</span></code></td>
<td>Process ID (if available).</td>
</tr>
<tr class="row-even"><td>processName</td>
<td><code class="docutils literal"><span class="pre">%(processName)s</span></code></td>
<td>Process name (if available).</td>
</tr>
<tr class="row-odd"><td>relativeCreated</td>
<td><code class="docutils literal"><span class="pre">%(relativeCreated)d</span></code></td>
<td>Time in milliseconds when the LogRecord was
created, relative to the time the logging
module was loaded.</td>
</tr>
<tr class="row-even"><td>stack_info</td>
<td>You shouldn't need to
format this yourself.</td>
<td>Stack frame information (where available)
from the bottom of the stack in the current
thread, up to and including the stack frame
of the logging call which resulted in the
creation of this record.</td>
</tr>
<tr class="row-odd"><td>thread</td>
<td><code class="docutils literal"><span class="pre">%(thread)d</span></code></td>
<td>Thread ID (if available).</td>
</tr>
<tr class="row-even"><td>threadName</td>
<td><code class="docutils literal"><span class="pre">%(threadName)s</span></code></td>
<td>Thread name (if available).</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.1으로 변경: </span><em>processName</em> was added.</p>
</div>
</div>
<div class="section" id="loggeradapter-objects">
<span id="logger-adapter"></span><h2>16.6.8. LoggerAdapter Objects<a class="headerlink" href="#loggeradapter-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal"><span class="pre">LoggerAdapter</span></code></a> instances are used to conveniently pass contextual
information into logging calls. For a usage example, see the section on
<a class="reference internal" href="../howto/logging-cookbook.html#context-info"><span class="std std-ref">adding contextual information to your logging output</span></a>.</p>
<dl class="class">
<dt id="logging.LoggerAdapter">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">LoggerAdapter</code><span class="sig-paren">(</span><em>logger</em>, <em>extra</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.LoggerAdapter" title="정의 주소">¶</a></dt>
<dd><p>Returns an instance of <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal"><span class="pre">LoggerAdapter</span></code></a> initialized with an
underlying <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal"><span class="pre">Logger</span></code></a> instance and a dict-like object.</p>
<dl class="method">
<dt id="logging.LoggerAdapter.process">
<code class="descname">process</code><span class="sig-paren">(</span><em>msg</em>, <em>kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.LoggerAdapter.process" title="정의 주소">¶</a></dt>
<dd><p>Modifies the message and/or keyword arguments passed to a logging call in
order to insert contextual information. This implementation takes the object
passed as <em>extra</em> to the constructor and adds it to <em>kwargs</em> using key
'extra'. The return value is a (<em>msg</em>, <em>kwargs</em>) tuple which has the
(possibly modified) versions of the arguments passed in.</p>
</dd></dl>

</dd></dl>

<p>In addition to the above, <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal"><span class="pre">LoggerAdapter</span></code></a> supports the following
methods of <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal"><span class="pre">Logger</span></code></a>: <a class="reference internal" href="#logging.Logger.debug" title="logging.Logger.debug"><code class="xref py py-meth docutils literal"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.Logger.info" title="logging.Logger.info"><code class="xref py py-meth docutils literal"><span class="pre">info()</span></code></a>,
<a class="reference internal" href="#logging.Logger.warning" title="logging.Logger.warning"><code class="xref py py-meth docutils literal"><span class="pre">warning()</span></code></a>, <a class="reference internal" href="#logging.Logger.error" title="logging.Logger.error"><code class="xref py py-meth docutils literal"><span class="pre">error()</span></code></a>, <a class="reference internal" href="#logging.Logger.exception" title="logging.Logger.exception"><code class="xref py py-meth docutils literal"><span class="pre">exception()</span></code></a>,
<a class="reference internal" href="#logging.Logger.critical" title="logging.Logger.critical"><code class="xref py py-meth docutils literal"><span class="pre">critical()</span></code></a>, <a class="reference internal" href="#logging.Logger.log" title="logging.Logger.log"><code class="xref py py-meth docutils literal"><span class="pre">log()</span></code></a>, <a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal"><span class="pre">isEnabledFor()</span></code></a>,
<a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal"><span class="pre">getEffectiveLevel()</span></code></a>, <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal"><span class="pre">setLevel()</span></code></a> and
<a class="reference internal" href="#logging.Logger.hasHandlers" title="logging.Logger.hasHandlers"><code class="xref py py-meth docutils literal"><span class="pre">hasHandlers()</span></code></a>. These methods have the same signatures as their
counterparts in <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal"><span class="pre">Logger</span></code></a>, so you can use the two types of instances
interchangeably.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>The <a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal"><span class="pre">isEnabledFor()</span></code></a>, <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal"><span class="pre">getEffectiveLevel()</span></code></a>,
<a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal"><span class="pre">setLevel()</span></code></a> and <a class="reference internal" href="#logging.Logger.hasHandlers" title="logging.Logger.hasHandlers"><code class="xref py py-meth docutils literal"><span class="pre">hasHandlers()</span></code></a> methods were added
to <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal"><span class="pre">LoggerAdapter</span></code></a>.  These methods delegate to the underlying logger.</p>
</div>
</div>
<div class="section" id="thread-safety">
<h2>16.6.9. Thread Safety<a class="headerlink" href="#thread-safety" title="제목 주소">¶</a></h2>
<p>The logging module is intended to be thread-safe without any special work
needing to be done by its clients. It achieves this though using threading
locks; there is one lock to serialize access to the module's shared data, and
each handler also creates a lock to serialize access to its underlying I/O.</p>
<p>If you are implementing asynchronous signal handlers using the <a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal"><span class="pre">signal</span></code></a>
module, you may not be able to use logging from within such handlers. This is
because lock implementations in the <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">threading</span></code></a> module are not always
re-entrant, and so cannot be invoked from such signal handlers.</p>
</div>
<div class="section" id="module-level-functions">
<h2>16.6.10. Module-Level Functions<a class="headerlink" href="#module-level-functions" title="제목 주소">¶</a></h2>
<p>In addition to the classes described above, there are a number of module- level
functions.</p>
<dl class="function">
<dt id="logging.getLogger">
<code class="descclassname">logging.</code><code class="descname">getLogger</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLogger" title="정의 주소">¶</a></dt>
<dd><p>Return a logger with the specified name or, if name is <code class="docutils literal"><span class="pre">None</span></code>, return a
logger which is the root logger of the hierarchy. If specified, the name is
typically a dot-separated hierarchical name like <em>'a'</em>, <em>'a.b'</em> or <em>'a.b.c.d'</em>.
Choice of these names is entirely up to the developer who is using logging.</p>
<p>All calls to this function with a given name return the same logger instance.
This means that logger instances never need to be passed between different parts
of an application.</p>
</dd></dl>

<dl class="function">
<dt id="logging.getLoggerClass">
<code class="descclassname">logging.</code><code class="descname">getLoggerClass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLoggerClass" title="정의 주소">¶</a></dt>
<dd><p>Return either the standard <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal"><span class="pre">Logger</span></code></a> class, or the last class passed to
<a class="reference internal" href="#logging.setLoggerClass" title="logging.setLoggerClass"><code class="xref py py-func docutils literal"><span class="pre">setLoggerClass()</span></code></a>. This function may be called from within a new class
definition, to ensure that installing a customized <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal"><span class="pre">Logger</span></code></a> class will
not undo customizations already applied by other code. For example:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyLogger</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">getLoggerClass</span><span class="p">()):</span>
    <span class="c1"># ... override behaviour here</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.getLogRecordFactory">
<code class="descclassname">logging.</code><code class="descname">getLogRecordFactory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLogRecordFactory" title="정의 주소">¶</a></dt>
<dd><p>Return a callable which is used to create a <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span>This function has been provided, along with <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal"><span class="pre">setLogRecordFactory()</span></code></a>,
to allow developers more control over how the <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a>
representing a logging event is constructed.</p>
</div>
<p>See <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal"><span class="pre">setLogRecordFactory()</span></code></a> for more information about the how the
factory is called.</p>
</dd></dl>

<dl class="function">
<dt id="logging.debug">
<code class="descclassname">logging.</code><code class="descname">debug</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.debug" title="정의 주소">¶</a></dt>
<dd><p>Logs a message with level <code class="xref py py-const docutils literal"><span class="pre">DEBUG</span></code> on the root logger. The <em>msg</em> is the
message format string, and the <em>args</em> are the arguments which are merged into
<em>msg</em> using the string formatting operator. (Note that this means that you can
use keywords in the format string, together with a single dictionary argument.)</p>
<p>There are three keyword arguments in <em>kwargs</em> which are inspected: <em>exc_info</em>
which, if it does not evaluate as false, causes exception information to be
added to the logging message. If an exception tuple (in the format returned by
<a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></code></a>) is provided, it is used; otherwise, <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal"><span class="pre">sys.exc_info()</span></code></a>
is called to get the exception information.</p>
<p>두 번째 선택적 키워드 인자는 <em>stack_info</em> 이며, 기본값은 <code class="docutils literal"><span class="pre">False</span></code> 입니다. 참이면, 실제 로깅 호출을 포함하는 스택 정보가 로깅 메시지에 추가됩니다. 이것은 <em>exc_info</em> 를 지정할 때 표시되는 것과 같은 스택 정보가 아닙니다: 전자(<em>stack_info</em>)는 스택의 맨 아래에서 현재 스레드의 로깅 호출까지의 스택 프레임이며, 후자(<em>exc_info</em>)는 예외가 일어난 후에 예외 처리기를 찾으면서 되감기된 스택 프레임에 대한 정보입니다.</p>
<p><em>exc_info</em> 와는 독립적으로 <em>stack_info</em> 를 지정할 수 있습니다. 예를 들어 예외가 발생하지 않은 경우에도 코드의 특정 지점에 어떻게 도달했는지 보여줄 수 있습니다. 스택 프레임은 다음과 같은 헤더 행 다음에 인쇄됩니다:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>Stack (most recent call last):
</pre></div>
</div>
<p>예외 프레임을 표시 할 때 사용되는 <code class="docutils literal"><span class="pre">Traceback</span> <span class="pre">(most</span> <span class="pre">recent</span> <span class="pre">call</span> <span class="pre">last):</span></code> 을 흉내내고 있습니다.</p>
<p>The third optional keyword argument is <em>extra</em> which can be used to pass a
dictionary which is used to populate the __dict__ of the LogRecord created for
the logging event with user-defined attributes. These custom attributes can then
be used as you like. For example, they could be incorporated into logged
messages. For example:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">FORMAT</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%(asctime)-15s</span><span class="s1"> </span><span class="si">%(clientip)s</span><span class="s1"> </span><span class="si">%(user)-8s</span><span class="s1"> </span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">FORMAT</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;clientip&#39;</span><span class="p">:</span> <span class="s1">&#39;192.168.0.1&#39;</span><span class="p">,</span> <span class="s1">&#39;user&#39;</span><span class="p">:</span> <span class="s1">&#39;fbloggs&#39;</span><span class="p">}</span>
<span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Protocol problem: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;connection reset&#39;</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>would print something like:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
</pre></div>
</div>
<p><em>extra</em> 에 전달 된 딕셔너리의 키가, 로깅 시스템에서 사용하는 키와 충돌해서는 안됩니다. (어떤 키가 로깅 시스템에 의해 사용되는지에 대한 더 많은 정보는 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> 문서를 보십시오.)</p>
<p>로그 된 메시지에서 이러한 어트리뷰트를 사용하려면 몇 가지 주의를 기울여야합니다. 위의 예에서, 예를 들어, <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> 에 설정한 포맷 문자열은 LogRecord의 어트리뷰트 딕셔너리에 'clientip' 과 'user' 가 있을 것으로 기대하고 있습니다. 이 것들이 없는 경우 문자열 포매팅 예외가 발생하기 때문에 메시지가 기록되지 않습니다. 따라서 이 경우, 항상 이 키를 포함하는 <em>extra</em> 딕셔너리를 전달해야합니다.</p>
<p>성가신 일입니다만, 이 기능은 여러 문맥에서 같은 코드가 실행되고 관심있는 조건들(가령 원격 클라이언트 IP 주소와 인증된 사용자 이름)이 문맥에 따라 발생하는 다중 스레드 서버와 같은 특수한 상황을 위한 것입니다. 이런 상황에서는, 특수한 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> 가 특정한 <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal"><span class="pre">Handler</span></code></a> 와 함께 사용될 가능성이 높습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">로그에 문맥 정보를 추가하는 방법은 <a class="reference internal" href="../howto/logging-cookbook.html#context-info"><span class="std std-ref">로그 출력에 문맥 정보 추가</span></a> 에서 좀 더 자세히 설명합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span><em>stack_info</em> 매개 변수가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.info">
<code class="descclassname">logging.</code><code class="descname">info</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.info" title="정의 주소">¶</a></dt>
<dd><p>Logs a message with level <code class="xref py py-const docutils literal"><span class="pre">INFO</span></code> on the root logger. The arguments are
interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="logging.warning">
<code class="descclassname">logging.</code><code class="descname">warning</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.warning" title="정의 주소">¶</a></dt>
<dd><p>Logs a message with level <code class="xref py py-const docutils literal"><span class="pre">WARNING</span></code> on the root logger. The arguments
are interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal"><span class="pre">debug()</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">There is an obsolete function <code class="docutils literal"><span class="pre">warn</span></code> which is functionally
identical to <code class="docutils literal"><span class="pre">warning</span></code>. As <code class="docutils literal"><span class="pre">warn</span></code> is deprecated, please do not use
it - use <code class="docutils literal"><span class="pre">warning</span></code> instead.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.error">
<code class="descclassname">logging.</code><code class="descname">error</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.error" title="정의 주소">¶</a></dt>
<dd><p>Logs a message with level <code class="xref py py-const docutils literal"><span class="pre">ERROR</span></code> on the root logger. The arguments are
interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="logging.critical">
<code class="descclassname">logging.</code><code class="descname">critical</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.critical" title="정의 주소">¶</a></dt>
<dd><p>Logs a message with level <code class="xref py py-const docutils literal"><span class="pre">CRITICAL</span></code> on the root logger. The arguments
are interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="logging.exception">
<code class="descclassname">logging.</code><code class="descname">exception</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.exception" title="정의 주소">¶</a></dt>
<dd><p>Logs a message with level <code class="xref py py-const docutils literal"><span class="pre">ERROR</span></code> on the root logger. The arguments are
interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal"><span class="pre">debug()</span></code></a>. Exception info is added to the logging
message. This function should only be called from an exception handler.</p>
</dd></dl>

<dl class="function">
<dt id="logging.log">
<code class="descclassname">logging.</code><code class="descname">log</code><span class="sig-paren">(</span><em>level</em>, <em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.log" title="정의 주소">¶</a></dt>
<dd><p>Logs a message with level <em>level</em> on the root logger. The other arguments are
interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal"><span class="pre">debug()</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">The above module-level convenience functions, which delegate to the
root logger, call <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal"><span class="pre">basicConfig()</span></code></a> to ensure that at least one handler
is available. Because of this, they should <em>not</em> be used in threads,
in versions of Python earlier than 2.7.1 and 3.2, unless at least one
handler has been added to the root logger <em>before</em> the threads are
started. In earlier versions of Python, due to a thread safety shortcoming
in <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal"><span class="pre">basicConfig()</span></code></a>, this can (under rare circumstances) lead to
handlers being added multiple times to the root logger, which can in turn
lead to multiple messages for the same event.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.disable">
<code class="descclassname">logging.</code><code class="descname">disable</code><span class="sig-paren">(</span><em>lvl=CRITICAL</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.disable" title="정의 주소">¶</a></dt>
<dd><p>Provides an overriding level <em>lvl</em> for all loggers which takes precedence over
the logger's own level. When the need arises to temporarily throttle logging
output down across the whole application, this function can be useful. Its
effect is to disable all logging calls of severity <em>lvl</em> and below, so that
if you call it with a value of INFO, then all INFO and DEBUG events would be
discarded, whereas those of severity WARNING and above would be processed
according to the logger's effective level. If
<code class="docutils literal"><span class="pre">logging.disable(logging.NOTSET)</span></code> is called, it effectively removes this
overriding level, so that logging output again depends on the effective
levels of individual loggers.</p>
<p>Note that if you have defined any custom logging level higher than
<code class="docutils literal"><span class="pre">CRITICAL</span></code> (this is not recommended), you won't be able to rely on the
default value for the <em>lvl</em> parameter, but will have to explicitly supply a
suitable value.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>The <em>lvl</em> parameter was defaulted to level <code class="docutils literal"><span class="pre">CRITICAL</span></code>. See Issue
#28524 for more information about this change.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.addLevelName">
<code class="descclassname">logging.</code><code class="descname">addLevelName</code><span class="sig-paren">(</span><em>lvl</em>, <em>levelName</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.addLevelName" title="정의 주소">¶</a></dt>
<dd><p>Associates level <em>lvl</em> with text <em>levelName</em> in an internal dictionary, which is
used to map numeric levels to a textual representation, for example when a
<a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> formats a message. This function can also be used to define
your own levels. The only constraints are that all levels used must be
registered using this function, levels should be positive integers and they
should increase in increasing order of severity.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">If you are thinking of defining your own levels, please see the
section on <a class="reference internal" href="../howto/logging.html#custom-levels"><span class="std std-ref">사용자 정의 수준</span></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.getLevelName">
<code class="descclassname">logging.</code><code class="descname">getLevelName</code><span class="sig-paren">(</span><em>lvl</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLevelName" title="정의 주소">¶</a></dt>
<dd><p>Returns the textual representation of logging level <em>lvl</em>. If the level is one
of the predefined levels <code class="xref py py-const docutils literal"><span class="pre">CRITICAL</span></code>, <code class="xref py py-const docutils literal"><span class="pre">ERROR</span></code>, <code class="xref py py-const docutils literal"><span class="pre">WARNING</span></code>,
<code class="xref py py-const docutils literal"><span class="pre">INFO</span></code> or <code class="xref py py-const docutils literal"><span class="pre">DEBUG</span></code> then you get the corresponding string. If you
have associated levels with names using <a class="reference internal" href="#logging.addLevelName" title="logging.addLevelName"><code class="xref py py-func docutils literal"><span class="pre">addLevelName()</span></code></a> then the name you
have associated with <em>lvl</em> is returned. If a numeric value corresponding to one
of the defined levels is passed in, the corresponding string representation is
returned. Otherwise, the string 'Level %s' % lvl is returned.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">Levels are internally integers (as they need to be compared in the
logging logic). This function is used to convert between an integer level
and the level name displayed in the formatted log output by means of the
<code class="docutils literal"><span class="pre">%(levelname)s</span></code> format specifier (see <a class="reference internal" href="#logrecord-attributes"><span class="std std-ref">LogRecord attributes</span></a>).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>In Python versions earlier than 3.4, this function could also be passed a
text level, and would return the corresponding numeric value of the level.
This undocumented behaviour was considered a mistake, and was removed in
Python 3.4, but reinstated in 3.4.2 due to retain backward compatibility.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.makeLogRecord">
<code class="descclassname">logging.</code><code class="descname">makeLogRecord</code><span class="sig-paren">(</span><em>attrdict</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.makeLogRecord" title="정의 주소">¶</a></dt>
<dd><p>Creates and returns a new <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> instance whose attributes are
defined by <em>attrdict</em>. This function is useful for taking a pickled
<a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> attribute dictionary, sent over a socket, and reconstituting
it as a <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> instance at the receiving end.</p>
</dd></dl>

<dl class="function">
<dt id="logging.basicConfig">
<code class="descclassname">logging.</code><code class="descname">basicConfig</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.basicConfig" title="정의 주소">¶</a></dt>
<dd><p>Does basic configuration for the logging system by creating a
<a class="reference internal" href="logging.handlers.html#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal"><span class="pre">StreamHandler</span></code></a> with a default <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal"><span class="pre">Formatter</span></code></a> and adding it to the
root logger. The functions <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.info" title="logging.info"><code class="xref py py-func docutils literal"><span class="pre">info()</span></code></a>, <a class="reference internal" href="#logging.warning" title="logging.warning"><code class="xref py py-func docutils literal"><span class="pre">warning()</span></code></a>,
<a class="reference internal" href="#logging.error" title="logging.error"><code class="xref py py-func docutils literal"><span class="pre">error()</span></code></a> and <a class="reference internal" href="#logging.critical" title="logging.critical"><code class="xref py py-func docutils literal"><span class="pre">critical()</span></code></a> will call <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal"><span class="pre">basicConfig()</span></code></a> automatically
if no handlers are defined for the root logger.</p>
<p>This function does nothing if the root logger already has handlers
configured for it.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">This function should be called from the main thread
before other threads are started. In versions of Python prior to
2.7.1 and 3.2, if this function is called from multiple threads,
it is possible (in rare circumstances) that a handler will be added
to the root logger more than once, leading to unexpected results
such as messages being duplicated in the log.</p>
</div>
<p>The following keyword arguments are supported.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>filename</em></td>
<td>Specifies that a FileHandler be created,
using the specified filename, rather than a
StreamHandler.</td>
</tr>
<tr class="row-odd"><td><em>filemode</em></td>
<td>If <em>filename</em> is specified, open the file
in this <a class="reference internal" href="functions.html#filemodes"><span class="std std-ref">mode</span></a>. Defaults
to <code class="docutils literal"><span class="pre">'a'</span></code>.</td>
</tr>
<tr class="row-even"><td><em>format</em></td>
<td>Use the specified format string for the
handler.</td>
</tr>
<tr class="row-odd"><td><em>datefmt</em></td>
<td>Use the specified date/time format, as
accepted by <a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal"><span class="pre">time.strftime()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><em>style</em></td>
<td>If <em>format</em> is specified, use this style
for the format string. One of <code class="docutils literal"><span class="pre">'%'</span></code>,
<code class="docutils literal"><span class="pre">'{'</span></code> or <code class="docutils literal"><span class="pre">'$'</span></code> for <a class="reference internal" href="stdtypes.html#old-string-formatting"><span class="std std-ref">printf-style</span></a>,
<a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal"><span class="pre">str.format()</span></code></a> or
<a class="reference internal" href="string.html#string.Template" title="string.Template"><code class="xref py py-class docutils literal"><span class="pre">string.Template</span></code></a> respectively.
Defaults to <code class="docutils literal"><span class="pre">'%'</span></code>.</td>
</tr>
<tr class="row-odd"><td><em>level</em></td>
<td>Set the root logger level to the specified
<a class="reference internal" href="#levels"><span class="std std-ref">level</span></a>.</td>
</tr>
<tr class="row-even"><td><em>stream</em></td>
<td>Use the specified stream to initialize the
StreamHandler. Note that this argument is
incompatible with <em>filename</em> - if both
are present, a <code class="docutils literal"><span class="pre">ValueError</span></code> is raised.</td>
</tr>
<tr class="row-odd"><td><em>handlers</em></td>
<td>If specified, this should be an iterable of
already created handlers to add to the root
logger. Any handlers which don't already
have a formatter set will be assigned the
default formatter created in this function.
Note that this argument is incompatible
with <em>filename</em> or <em>stream</em> - if both
are present, a <code class="docutils literal"><span class="pre">ValueError</span></code> is raised.</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>The <em>style</em> argument was added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>The <em>handlers</em> argument was added. Additional checks were added to
catch situations where incompatible arguments are specified (e.g.
<em>handlers</em> together with <em>stream</em> or <em>filename</em>, or <em>stream</em>
together with <em>filename</em>).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.shutdown">
<code class="descclassname">logging.</code><code class="descname">shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.shutdown" title="정의 주소">¶</a></dt>
<dd><p>Informs the logging system to perform an orderly shutdown by flushing and
closing all handlers. This should be called at application exit and no
further use of the logging system should be made after this call.</p>
</dd></dl>

<dl class="function">
<dt id="logging.setLoggerClass">
<code class="descclassname">logging.</code><code class="descname">setLoggerClass</code><span class="sig-paren">(</span><em>klass</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.setLoggerClass" title="정의 주소">¶</a></dt>
<dd><p>Tells the logging system to use the class <em>klass</em> when instantiating a logger.
The class should define <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> such that only a name argument is
required, and the <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> should call <code class="xref py py-meth docutils literal"><span class="pre">Logger.__init__()</span></code>. This
function is typically called before any loggers are instantiated by applications
which need to use custom logger behavior.</p>
</dd></dl>

<dl class="function">
<dt id="logging.setLogRecordFactory">
<code class="descclassname">logging.</code><code class="descname">setLogRecordFactory</code><span class="sig-paren">(</span><em>factory</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.setLogRecordFactory" title="정의 주소">¶</a></dt>
<dd><p>Set a callable which is used to create a <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">매개 변수:</th><td class="field-body"><strong>factory</strong> -- The factory callable to be used to instantiate a log record.</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span>This function has been provided, along with <a class="reference internal" href="#logging.getLogRecordFactory" title="logging.getLogRecordFactory"><code class="xref py py-func docutils literal"><span class="pre">getLogRecordFactory()</span></code></a>, to
allow developers more control over how the <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal"><span class="pre">LogRecord</span></code></a> representing
a logging event is constructed.</p>
</div>
<p>The factory has the following signature:</p>
<p><code class="docutils literal"><span class="pre">factory(name,</span> <span class="pre">level,</span> <span class="pre">fn,</span> <span class="pre">lno,</span> <span class="pre">msg,</span> <span class="pre">args,</span> <span class="pre">exc_info,</span> <span class="pre">func=None,</span> <span class="pre">sinfo=None,</span> <span class="pre">**kwargs)</span></code></p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">name:</th><td class="field-body">The logger name.</td>
</tr>
<tr class="field-even field"><th class="field-name">level:</th><td class="field-body">The logging level (numeric).</td>
</tr>
<tr class="field-odd field"><th class="field-name">fn:</th><td class="field-body">The full pathname of the file where the logging call was made.</td>
</tr>
<tr class="field-even field"><th class="field-name">lno:</th><td class="field-body">The line number in the file where the logging call was made.</td>
</tr>
<tr class="field-odd field"><th class="field-name">msg:</th><td class="field-body">The logging message.</td>
</tr>
<tr class="field-even field"><th class="field-name">args:</th><td class="field-body">The arguments for the logging message.</td>
</tr>
<tr class="field-odd field"><th class="field-name">exc_info:</th><td class="field-body">An exception tuple, or <code class="docutils literal"><span class="pre">None</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">func:</th><td class="field-body">The name of the function or method which invoked the logging
call.</td>
</tr>
<tr class="field-odd field"><th class="field-name">sinfo:</th><td class="field-body">A stack traceback such as is provided by
<a class="reference internal" href="traceback.html#traceback.print_stack" title="traceback.print_stack"><code class="xref py py-func docutils literal"><span class="pre">traceback.print_stack()</span></code></a>, showing the call hierarchy.</td>
</tr>
<tr class="field-even field"><th class="field-name">kwargs:</th><td class="field-body">Additional keyword arguments.</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-level-attributes">
<h2>16.6.11. Module-Level Attributes<a class="headerlink" href="#module-level-attributes" title="제목 주소">¶</a></h2>
<dl class="attribute">
<dt id="logging.lastResort">
<code class="descclassname">logging.</code><code class="descname">lastResort</code><a class="headerlink" href="#logging.lastResort" title="정의 주소">¶</a></dt>
<dd><p>A &quot;handler of last resort&quot; is available through this attribute. This
is a <a class="reference internal" href="logging.handlers.html#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal"><span class="pre">StreamHandler</span></code></a> writing to <code class="docutils literal"><span class="pre">sys.stderr</span></code> with a level of
<code class="docutils literal"><span class="pre">WARNING</span></code>, and is used to handle logging events in the absence of any
logging configuration. The end result is to just print the message to
<code class="docutils literal"><span class="pre">sys.stderr</span></code>. This replaces the earlier error message saying that
&quot;no handlers could be found for logger XYZ&quot;. If you need the earlier
behaviour for some reason, <code class="docutils literal"><span class="pre">lastResort</span></code> can be set to <code class="docutils literal"><span class="pre">None</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="integration-with-the-warnings-module">
<h2>16.6.12. Integration with the warnings module<a class="headerlink" href="#integration-with-the-warnings-module" title="제목 주소">¶</a></h2>
<p>The <a class="reference internal" href="#logging.captureWarnings" title="logging.captureWarnings"><code class="xref py py-func docutils literal"><span class="pre">captureWarnings()</span></code></a> function can be used to integrate <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a>
with the <a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal"><span class="pre">warnings</span></code></a> module.</p>
<dl class="function">
<dt id="logging.captureWarnings">
<code class="descclassname">logging.</code><code class="descname">captureWarnings</code><span class="sig-paren">(</span><em>capture</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.captureWarnings" title="정의 주소">¶</a></dt>
<dd><p>This function is used to turn the capture of warnings by logging on and
off.</p>
<p>If <em>capture</em> is <code class="docutils literal"><span class="pre">True</span></code>, warnings issued by the <a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal"><span class="pre">warnings</span></code></a> module will
be redirected to the logging system. Specifically, a warning will be
formatted using <a class="reference internal" href="warnings.html#warnings.formatwarning" title="warnings.formatwarning"><code class="xref py py-func docutils literal"><span class="pre">warnings.formatwarning()</span></code></a> and the resulting string
logged to a logger named <code class="docutils literal"><span class="pre">'py.warnings'</span></code> with a severity of <code class="xref py py-const docutils literal"><span class="pre">WARNING</span></code>.</p>
<p>If <em>capture</em> is <code class="docutils literal"><span class="pre">False</span></code>, the redirection of warnings to the logging system
will stop, and warnings will be redirected to their original destinations
(i.e. those in effect before <code class="docutils literal"><span class="pre">captureWarnings(True)</span></code> was called).</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<dl class="last docutils">
<dt>모듈 <a class="reference internal" href="logging.config.html#module-logging.config" title="logging.config: Configuration of the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.config</span></code></a></dt>
<dd>logging 모듈용 구성 API.</dd>
<dt>모듈 <a class="reference internal" href="logging.handlers.html#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal"><span class="pre">logging.handlers</span></code></a></dt>
<dd>logging 모듈에 포함된 유용한 처리기.</dd>
<dt><span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0282"><strong>PEP 282</strong></a> - 로깅 시스템</dt>
<dd>The proposal which described this feature for inclusion in the Python standard
library.</dd>
<dt><a class="reference external" href="https://www.red-dove.com/python_logging.html">Original Python logging package</a></dt>
<dd>This is the original source for the <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> package.  The version of the
package available from this site is suitable for use with Python 1.5.2, 2.1.x
and 2.2.x, which do not include the <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal"><span class="pre">logging</span></code></a> package in the standard
library.</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">16.6. <code class="docutils literal"><span class="pre">logging</span></code> --- 파이썬 로깅 시설</a><ul>
<li><a class="reference internal" href="#logger-objects">16.6.1. 로거 객체</a></li>
<li><a class="reference internal" href="#logging-levels">16.6.2. 로깅 수준</a></li>
<li><a class="reference internal" href="#handler-objects">16.6.3. 처리기 객체</a></li>
<li><a class="reference internal" href="#formatter-objects">16.6.4. 포매터 객체</a></li>
<li><a class="reference internal" href="#filter-objects">16.6.5. 필터 객체</a></li>
<li><a class="reference internal" href="#logrecord-objects">16.6.6. LogRecord Objects</a></li>
<li><a class="reference internal" href="#logrecord-attributes">16.6.7. LogRecord attributes</a></li>
<li><a class="reference internal" href="#loggeradapter-objects">16.6.8. LoggerAdapter Objects</a></li>
<li><a class="reference internal" href="#thread-safety">16.6.9. Thread Safety</a></li>
<li><a class="reference internal" href="#module-level-functions">16.6.10. Module-Level Functions</a></li>
<li><a class="reference internal" href="#module-level-attributes">16.6.11. Module-Level Attributes</a></li>
<li><a class="reference internal" href="#integration-with-the-warnings-module">16.6.12. Integration with the warnings module</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="getopt.html"
                        title="이전 장">16.5. <code class="docutils literal"><span class="pre">getopt</span></code> --- C-style parser for command line options</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="logging.config.html"
                        title="다음 장">16.7. <code class="docutils literal"><span class="pre">logging.config</span></code> --- Logging configuration</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="logging.config.html" title="16.7. logging.config --- Logging configuration"
             >다음</a> |</li>
        <li class="right" >
          <a href="getopt.html" title="16.5. getopt --- C-style parser for command line options"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >16. 일반 운영 체제 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2018, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 를 사용해서 만들었습니다.
    </div>

  </body>
</html>