
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>logging --- 파이썬 로깅 시설 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="logging.config --- Logging configuration" href="logging.config.html" />
    <link rel="prev" title="getopt --- C-style parser for command line options" href="getopt.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/library/logging.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="logging.config.html" title="logging.config --- Logging configuration"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="getopt.html" title="getopt --- C-style parser for command line options"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">일반 운영 체제 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-logging">
<span id="logging-logging-facility-for-python"></span><h1><a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> --- 파이썬 로깅 시설<a class="headerlink" href="#module-logging" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/logging/__init__.py">Lib/logging/__init__.py</a></p>
<div class="sidebar" id="index-0">
<p class="first sidebar-title">Important</p>
<p>이 페이지는 API 레퍼런스 정보를 담고 있습니다. 자습서 정보 및 고급 주제에 대한 설명은 다음을 참조하십시오.</p>
<ul class="last simple">
<li><a class="reference internal" href="../howto/logging.html#logging-basic-tutorial"><span class="std std-ref">기초 자습서</span></a></li>
<li><a class="reference internal" href="../howto/logging.html#logging-advanced-tutorial"><span class="std std-ref">고급 자습서</span></a></li>
<li><a class="reference internal" href="../howto/logging-cookbook.html#logging-cookbook"><span class="std std-ref">로깅 요리책</span></a></li>
</ul>
</div>
<hr class="docutils" />
<p>이 모듈은 응용 프로그램과 라이브러리를 위한 유연한 이벤트 로깅 시스템을 구현하는 함수와 클래스를 정의합니다.</p>
<p>표준 라이브러리 모듈로 로깅 API를 제공하는 것의 주요 이점은, 모든 파이썬 모듈이 로깅에 참여할 수 있어서, 응용 프로그램 로그에 여러분 자신의 메시지를 제삼자 모듈의 메시지와 통합할 수 있다는 것입니다.</p>
<p>이 모듈은 많은 기능과 유연성을 제공합니다. 로깅에 익숙하지 않다면, 감을 잡는 가장 좋은 방법은 자습서를 보는 것입니다 (오른쪽 링크를 참조하세요).</p>
<p>모듈에 의해 정의된 기본 클래스와 그 기능은 다음과 같습니다.</p>
<ul class="simple">
<li>로거는 응용 프로그램 코드가 직접 사용하는 인터페이스를 노출합니다.</li>
<li>처리기는 (로거가 만든) 로그 레코드를 적절한 목적지로 보냅니다.</li>
<li>필터는 출력할 로그 레코드를 결정하기 위한 더 세분된 기능을 제공합니다.</li>
<li>포매터는 최종 출력에서 로그 레코드의 배치를 지정합니다.</li>
</ul>
<div class="section" id="logger-objects">
<span id="logger"></span><h2>Logger 객체<a class="headerlink" href="#logger-objects" title="제목 주소">¶</a></h2>
<p>로거에는 다음과 같은 어트리뷰트와 메서드가 있습니다. 로거는 결코 직접 인스턴스를 만드는 일 없이, 항상 모듈 수준의 함수 <code class="docutils literal notranslate"><span class="pre">logging.getLogger(name)</span></code> 를 거치는 것에 주의하십시오. 같은 이름(name)으로 <a class="reference internal" href="#logging.getLogger" title="logging.getLogger"><code class="xref py py-func docutils literal notranslate"><span class="pre">getLogger()</span></code></a> 를 여러 번 호출해도 항상 같은 로거 객체에 대한 참조를 돌려줍니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">name</span></code> 은 잠재적으로 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> 와 같이 마침표로 구분된 계층적 값입니다 (하지만 그냥 간단한 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 도 가능합니다). 계층적 목록에서 더 아래쪽에 있는 로거는 목록에서 상위에 있는 로거의 자식입니다. 예를 들어, 이름이 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 인 로거가 주어지면, <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>, <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>, 그리고 <code class="docutils literal notranslate"><span class="pre">foo.bam</span></code> 의 이름을 가진 로거는 모두 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 의 자손입니다. 로거 이름 계층 구조는 파이썬 패키지 계층 구조와 비슷하며, <code class="docutils literal notranslate"><span class="pre">logging.getLogger(__name__)</span></code> 를 사용하여 모듈 단위로 로거를 구성하는 경우는 패키지 계층 구조와 같아집니다. 왜냐하면, 모듈에서, <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 은 파이썬 패키지 이름 공간의 모듈 이름이기 때문입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">logging.getLogger(__name__)</span></code> 에 관한 설명은 <a class="reference internal" href="../howto/logging.html#logging-advanced-tutorial"><span class="std std-ref">고급 로깅 자습서</span></a>
를 참고하세요.</p>
</div>
<dl class="class">
<dt id="logging.Logger">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">Logger</code><a class="headerlink" href="#logging.Logger" title="정의 주소">¶</a></dt>
<dd><dl class="attribute">
<dt id="logging.Logger.propagate">
<code class="descname">propagate</code><a class="headerlink" href="#logging.Logger.propagate" title="정의 주소">¶</a></dt>
<dd><p>이 어트리뷰트가 참으로 평가되면, 이 로거에 로그 된 이벤트는 이 로거에 첨부된 처리기뿐 아니라 상위 계층 (조상) 로거의 처리기로 전달됩니다. 메시지는 조상 로거의 처리기에 직접 전달됩니다 - 조상 로거의 수준이나 필터는 고려하지 않습니다.</p>
<p>이 값이 거짓으로 평가되면, 로깅 메시지가 조상 로거의 처리기로 전달되지 않습니다.</p>
<p>생성자는 이 어트리뷰트를 <code class="docutils literal notranslate"><span class="pre">True</span></code> 로 설정합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">로거 <em>와</em> 하나 이상의 조상에 처리기를 중복해서 연결하면, 같은 레코드를 여러 번 출력할 수 있습니다. 일반적으로, 하나 이상의 로거에 처리기를 붙일 필요는 없습니다. 로거 계층에서 가장 높은 적절한 로거에 처리기를 연결하면, propagate 설정이 <code class="docutils literal notranslate"><span class="pre">True</span></code> 로 남아있는 모든 자식 로거들이 로그 하는 모든 이벤트를 보게 됩니다. 일반적인 시나리오는 루트 로거에만 처리기를 연결하고, 전파가 나머지를 처리하도록 하는 것입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.setLevel">
<code class="descname">setLevel</code><span class="sig-paren">(</span><em>level</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.setLevel" title="정의 주소">¶</a></dt>
<dd><p>이 로거의 수준 경계를 <em>level</em> 로 설정합니다. <em>level</em> 보다 덜 심각한 로깅 메시지는 무시됩니다; 심각도 <em>level</em> 이상의 로깅 메시지는, 처리기 수준이 <em>level</em> 보다 높은 심각도 수준으로 설정되지 않는 한, 이 로거에 연결된 처리기가 출력합니다.</p>
<p>로거가 만들어질 때, 수준은 <code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> (로거가 루트 로거 일 때는 모든 메시지를 처리하게 하고, 로거가 루트 로거가 아니면 모든 메시지를 부모에게 위임하도록 합니다) 으로 설정됩니다. 루트 로거는 수준 <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code>으로 만들어짐에 유의하세요.</p>
<p>'부모에게 위임'이라는 말은, 로거 수준이 NOTSET 인 경우, NOTSET 이외의 수준을 갖는 조상이 발견되거나 루트에 도달할 때까지 조상 로거 체인을 탐색함을 의미합니다.</p>
<p>NOTSET 이외의 수준을 갖는 조상이 발견되면, 그 조상의 수준을 조상 검색이 시작된 로거의 유효 수준으로 간주하여, 로깅 이벤트를 처리할지를 결정하는 데 사용됩니다.</p>
<p>루트에 도달하면, 그리고 루트가 NOTSET 수준을 갖고 있으면, 모든 메시지가 처리됩니다. 그렇지 않으면 루트 수준이 유효 수준으로 사용됩니다.</p>
<p>수준의 목록은 <a class="reference internal" href="#levels"><span class="std std-ref">로깅 수준</span></a>를 보세요.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><em>level</em> 매개 변수는 이제 <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code>와 같은 정수 상수 대신 'INFO'와 같은 수준의 문자열 표현을 허용합니다. 그러나 수준은 내부적으로 정수로 저장되며, <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a> 및 <a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isEnabledFor()</span></code></a>와 같은 메서드는 정수를 반환하거나 정수가 전달되기를 기대합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.isEnabledFor">
<code class="descname">isEnabledFor</code><span class="sig-paren">(</span><em>lvl</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.isEnabledFor" title="정의 주소">¶</a></dt>
<dd><p>심각도 <em>lvl</em> 의 메시지가 이 로거에서 처리될지를 알려줍니다. 이 메서드는 먼저 <code class="docutils literal notranslate"><span class="pre">logging.disable(lvl)</span></code> 에 의해 설정된 모듈 수준의 수준을 확인한 다음, <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a>로 확인되는 로거의 유효 수준을 검사합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.getEffectiveLevel">
<code class="descname">getEffectiveLevel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.getEffectiveLevel" title="정의 주소">¶</a></dt>
<dd><p>이 로거의 유효 수준을 알려줍니다. <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a> 을 사용하여 <code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> 이외의 값이 설정되면, 그 값이 반환됩니다. 그렇지 않으면, <code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> 이외의 값이 발견될 때까지 루트를 향해 계층 구조를 탐색하고, 그 값이 반환됩니다. 반환되는 값은 정수이며, 일반적으로 <code class="xref py py-const docutils literal notranslate"><span class="pre">logging.DEBUG</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">logging.INFO</span></code> 등 중 하나입니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.getChild">
<code class="descname">getChild</code><span class="sig-paren">(</span><em>suffix</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.getChild" title="정의 주소">¶</a></dt>
<dd><p>접미사에 의해 결정되는, 이 로거의 자손 로거를 반환합니다. 그러므로, <code class="docutils literal notranslate"><span class="pre">logging.getLogger('abc').getChild('def.ghi')</span></code> 는 <code class="docutils literal notranslate"><span class="pre">logging.getLogger('abc.def.ghi')</span></code> 와 같은 로거를 반환합니다. 이것은 편의 메서드인데, 부모 로거가 리터럴 문자열이 아닌 이름(가령 <code class="docutils literal notranslate"><span class="pre">__name__</span></code>)을 사용하여 명명될 때 유용합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.debug">
<code class="descname">debug</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.debug" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 수준 <code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code> 메시지를 로그 합니다. <em>msg</em> 는 메시지 포맷 문자열이고, <em>args</em> 는 문자열 포매팅 연산자를 사용하여 <em>msg</em> 에 병합되는 인자입니다. (이는 포맷 문자열에 키워드를 사용하고, 인자로 하나의 딕셔너리를 전달할 수 있음을 의미합니다.)</p>
<p><em>kwargs</em> 에서 검사되는 세 개의 키워드 인자가 있습니다: <em>exc_info</em>, <em>stack_info</em> 및 <em>extra</em>.</p>
<p><em>exc_info</em> 가 거짓으로 평가되지 않으면, 로깅 메시지에 예외 정보가 추가됩니다. 예외 튜플 (<a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 에 의해 반환되는 형식) 또는 예외 인스턴스가 제공되면 사용됩니다; 그렇지 않으면 예외 정보를 얻기 위해 <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 를 호출합니다.</p>
<p>두 번째 선택적 키워드 인자는 <em>stack_info</em> 이며, 기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code> 입니다. 참이면, 실제 로깅 호출을 포함하는 스택 정보가 로깅 메시지에 추가됩니다. 이것은 <em>exc_info</em> 를 지정할 때 표시되는 것과 같은 스택 정보가 아닙니다: 전자(<em>stack_info</em>)는 스택의 맨 아래에서 현재 스레드의 로깅 호출까지의 스택 프레임이며, 후자(<em>exc_info</em>)는 예외가 일어난 후에 예외 처리기를 찾으면서 되감은 스택 프레임에 대한 정보입니다.</p>
<p><em>exc_info</em> 와는 독립적으로 <em>stack_info</em> 를 지정할 수 있습니다. 예를 들어 예외가 발생하지 않은 경우에도 코드의 특정 지점에 어떻게 도달했는지 보여줄 수 있습니다. 스택 프레임은 다음과 같은 헤더 행 다음에 인쇄됩니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Stack (most recent call last):
</pre></div>
</div>
<p>예외 프레임을 표시할 때 사용되는 <code class="docutils literal notranslate"><span class="pre">Traceback</span> <span class="pre">(most</span> <span class="pre">recent</span> <span class="pre">call</span> <span class="pre">last):</span></code> 을 흉내 내고 있습니다.</p>
<p>세 번째 키워드 인자는 <em>extra</em> 로, 로깅 이벤트용으로 만들어진 LogRecord의 __dict__ 를 사용자 정의 어트리뷰트로 채우는 데 사용되는 딕셔너리를 전달할 수 있습니다. 이러한 사용자 정의 어트리뷰트는 원하는 대로 사용할 수 있습니다. 예를 들어, 로그 메시지에 포함할 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">FORMAT</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%(asctime)-15s</span><span class="s1"> </span><span class="si">%(clientip)s</span><span class="s1"> </span><span class="si">%(user)-8s</span><span class="s1"> </span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">FORMAT</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;clientip&#39;</span><span class="p">:</span> <span class="s1">&#39;192.168.0.1&#39;</span><span class="p">,</span> <span class="s1">&#39;user&#39;</span><span class="p">:</span> <span class="s1">&#39;fbloggs&#39;</span><span class="p">}</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;tcpserver&#39;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Protocol problem: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;connection reset&#39;</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>는 이렇게 인쇄할 것입니다</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
</pre></div>
</div>
<p><em>extra</em> 에 전달된 딕셔너리의 키가, 로깅 시스템에서 사용하는 키와 충돌해서는 안 됩니다. (어떤 키가 로깅 시스템에 의해 사용되는지에 대한 더 많은 정보는 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 문서를 보십시오.)</p>
<p>로그 된 메시지에서 이러한 어트리뷰트를 사용하려면 몇 가지 주의를 기울여야 합니다. 위의 예에서, 예를 들어, <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 에 설정한 포맷 문자열은 LogRecord의 어트리뷰트 딕셔너리에 'clientip' 과 'user' 가 있을 것으로 기대하고 있습니다. 이것들이 없는 경우 문자열 포매팅 예외가 발생하기 때문에 메시지가 기록되지 않습니다. 따라서 이 경우, 항상 이 키를 포함하는 <em>extra</em> 딕셔너리를 전달해야 합니다.</p>
<p>성가신 일입니다만, 이 기능은 여러 문맥에서 같은 코드가 실행되고 관심 있는 조건들(가령 원격 클라이언트 IP 주소와 인증된 사용자 이름)이 문맥에 따라 발생하는 다중 스레드 서버와 같은 특수한 상황을 위한 것입니다. 이런 상황에서는, 특수한 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 가 특정한 <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a>와 함께 사용될 가능성이 큽니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">로그에 문맥 정보를 추가하는 방법은 <a class="reference internal" href="../howto/logging-cookbook.html#context-info"><span class="std std-ref">로그 출력에 문맥 정보 추가</span></a> 에서 좀 더 자세히 설명합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span><em>stack_info</em> 매개 변수가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span><em>exc_info</em> 매개 변수는 이제 예외 인스턴스를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.info">
<code class="descname">info</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.info" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 수준 <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code> 메시지를 로그 합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>처럼 해석됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.warning">
<code class="descname">warning</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.warning" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 수준 <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code> 메시지를 로그 합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>처럼 해석됩니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">기능적으로 <code class="docutils literal notranslate"><span class="pre">warning</span></code> 와 같은, 구식의 <code class="docutils literal notranslate"><span class="pre">warn</span></code> 메서드가 있습니다. <code class="docutils literal notranslate"><span class="pre">warn</span></code> 은 폐지되었으므로 사용하지 마십시오 - 대신 <code class="docutils literal notranslate"><span class="pre">warning</span></code> 을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.error">
<code class="descname">error</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.error" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 수준 <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> 메시지를 로그 합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>처럼 해석됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.critical">
<code class="descname">critical</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.critical" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 수준 <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code> 메시지를 로그 합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>처럼 해석됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.log">
<code class="descname">log</code><span class="sig-paren">(</span><em>lvl</em>, <em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.log" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 정수 수준 <em>lvl</em> 로 메시지를 로그 합니다. 다른 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>처럼 해석됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.exception">
<code class="descname">exception</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.exception" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 수준 <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> 메시지를 로그 합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>처럼 해석됩니다. 예외 정보가 로깅 메시지에 추가됩니다. 이 메서드는 예외 처리기에서만 호출해야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.addFilter">
<code class="descname">addFilter</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.addFilter" title="정의 주소">¶</a></dt>
<dd><p>지정된 필터 <em>filter</em> 를 이 로거에 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.removeFilter">
<code class="descname">removeFilter</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.removeFilter" title="정의 주소">¶</a></dt>
<dd><p>이 로거에서 지정된 필터 <em>filter</em> 를 제거합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.filter" title="정의 주소">¶</a></dt>
<dd><p>이 로거의 필터를 레코드(record)에 적용하고 레코드가 처리 대상이면 참값을 반환합니다. 필터 중 어느 하나가 거짓 값을 반환할 때까지 필터는 차례로 참조됩니다. 그중 아무것도 거짓 값을 반환하지 않으면 레코드가 처리됩니다 (처리기로 전달됩니다). 어느 하나가 거짓 값을 반환하면, 더 이상의 레코드 처리는 이루어지지 않습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 메서드는 레코드가 처리될 대상인지를 확인만 할뿐 처리기로 전달하지는 않습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.addHandler">
<code class="descname">addHandler</code><span class="sig-paren">(</span><em>hdlr</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.addHandler" title="정의 주소">¶</a></dt>
<dd><p>지정된 처리기 <em>hdlr</em> 를 이 로거에 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.removeHandler">
<code class="descname">removeHandler</code><span class="sig-paren">(</span><em>hdlr</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.removeHandler" title="정의 주소">¶</a></dt>
<dd><p>이 로거에서 지정된 처리기 <em>hdlr</em> 을 제거합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.findCaller">
<code class="descname">findCaller</code><span class="sig-paren">(</span><em>stack_info=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.findCaller" title="정의 주소">¶</a></dt>
<dd><p>호출자의 소스 파일 이름과 행 번호를 찾습니다. 파일 이름, 행 번호, 함수 이름 및 스택 정보를 4-요소 튜플로 반환합니다. 스택 정보는 <em>stack_info</em> 가 <code class="docutils literal notranslate"><span class="pre">True</span></code> 가 아니면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 반환됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 메서드가 제공하는 4-튜플은 <a class="reference internal" href="#logging.Logger.makeRecord" title="logging.Logger.makeRecord"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makeRecord()</span></code></a> 메서드의 <em>fn</em>, <em>lno</em>, <em>func</em>, <em>sinfo</em> 매개 변수로 전달됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.handle" title="정의 주소">¶</a></dt>
<dd><p>이 로거와 그 조상(거짓 값의 <em>propagate</em> 가 발견될 때까지)과 연관된 모든 처리기에 레코드를 전달하여 레코드를 처리합니다. 이 메서드는 로컬에서 만든 레코드뿐만 아니라 소켓에서 받아서 언피클된 레코드를 처리하는 데 사용됩니다. <a class="reference internal" href="#logging.Logger.filter" title="logging.Logger.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 를 사용하여 로거 수준 필터링을 적용합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">소켓을 통해 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 인스턴스를 피클된 형태로 원격에서 전달받을 수 있습니다.
중앙 집중형 로그 서버를 구성할 때 사용되는 방법입니다. 이 경우 언피클해서 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>
인스턴스를 만들게되는데, 이를 <a class="reference internal" href="#logging.Logger.handle" title="logging.Logger.handle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle()</span></code></a> 메서드로 처리하면됩니다.
예제 코드는 <a class="reference internal" href="../howto/logging-cookbook.html#network-logging"><span class="std std-ref">네트워크에서 로깅 이벤트 보내고 받기</span></a> 를 참고하세요.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.makeRecord">
<code class="descname">makeRecord</code><span class="sig-paren">(</span><em>name</em>, <em>lvl</em>, <em>fn</em>, <em>lno</em>, <em>msg</em>, <em>args</em>, <em>exc_info</em>, <em>func=None</em>, <em>extra=None</em>, <em>sinfo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.makeRecord" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 특수한 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 인스턴스를 만들기 위해 서브 클래스에서 재정의할 수 있는 팩토리 메서드입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 팩토리 메서드보다는 보통 <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLogRecordFactory()</span></code></a> 를 사용합니다.
자세한 내용은 <a class="reference internal" href="../howto/logging-cookbook.html#custom-logrecord"><span class="std std-ref">사용자 정의 LogRecord</span></a> 를 참고하세요.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Logger.hasHandlers">
<code class="descname">hasHandlers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.hasHandlers" title="정의 주소">¶</a></dt>
<dd><p>이 로거에 처리기가 구성되어 있는지 확인합니다. 이 로거의 처리기와 로거 계층의 부모를 찾습니다. 처리기가 발견되면 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 반환하고, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 를 반환합니다. 이 메서드는 'propagate' 어트리뷰트가 거짓으로 설정된 로거가 발견될 때 계층 구조 검색을 중지합니다 - 그 로거가 처리기가 있는지 검사하는 마지막 로거가 됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>이제 로거는 피클 되고 언피클 될 수 있습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="logging-levels">
<span id="levels"></span><h2>로깅 수준<a class="headerlink" href="#logging-levels" title="제목 주소">¶</a></h2>
<p>로깅 수준의 숫자 값은 다음 표에 나와 있습니다. 여러분 자신의 수준을 정의하고, 미리 정의된 수준과 상대적인 특정 값을 갖도록 하려는 경우 필요합니다. 같은 숫자 값을 가진 수준을 정의하면 미리 정의된 값을 덮어씁니다; 미리 정의된 이름이 유실됩니다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">수준</th>
<th class="head">숫자 값</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">CRITICAL</span></code></td>
<td>50</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">ERROR</span></code></td>
<td>40</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">WARNING</span></code></td>
<td>30</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">INFO</span></code></td>
<td>20</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">DEBUG</span></code></td>
<td>10</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">NOTSET</span></code></td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="handler-objects">
<span id="handler"></span><h2>Handler 객체<a class="headerlink" href="#handler-objects" title="제목 주소">¶</a></h2>
<p>처리기에는 다음과 같은 어트리뷰트와 메서드가 있습니다. <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> 는 절대로 직접 인스턴스로 만들어지지 않음에 주의하세요; 이 클래스는 더욱 유용한 서브 클래스의 베이스가 됩니다. 그러나, 서브 클래스의 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드는 <a class="reference internal" href="#logging.Handler.__init__" title="logging.Handler.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Handler.__init__()</span></code></a> 을 호출해야 합니다.</p>
<dl class="class">
<dt id="logging.Handler">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">Handler</code><a class="headerlink" href="#logging.Handler" title="정의 주소">¶</a></dt>
<dd><dl class="method">
<dt id="logging.Handler.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>level=NOTSET</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.__init__" title="정의 주소">¶</a></dt>
<dd><p>수준을 설정하고, 필터 목록을 빈 리스트로 설정하고, I/O 메커니즘에 대한 액세스를 직렬화하기 위해 (<a class="reference internal" href="#logging.Handler.createLock" title="logging.Handler.createLock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">createLock()</span></code></a> 을 사용하여) 록을 생성함으로써 <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> 인스턴스를 초기화합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.createLock">
<code class="descname">createLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.createLock" title="정의 주소">¶</a></dt>
<dd><p>스레드 안전하지 않은 하부 I/O 기능에 대한 액세스를 직렬화하는 데 사용할 수 있는 스레드 록을 초기화합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">기본적으로 <a class="reference internal" href="threading.html#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.RLock</span></code></a> 을 만듭니다. 재진입 가능한 록입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.acquire">
<code class="descname">acquire</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.acquire" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.Handler.createLock" title="logging.Handler.createLock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">createLock()</span></code></a> 로 생성된 스레드 록을 확보합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.release" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.Handler.acquire" title="logging.Handler.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a>로 확보한 스레드 록을 반납합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.setLevel">
<code class="descname">setLevel</code><span class="sig-paren">(</span><em>level</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.setLevel" title="정의 주소">¶</a></dt>
<dd><p>이 처리기의 수준 경계를 <em>level</em> 로 설정합니다. <em>level</em> 보다 덜 심각한 로깅 메시지는 무시됩니다. 처리기가 만들어질 때, 수준은 <code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> (모든 메시지가 처리되게 합니다) 으로 설정됩니다.</p>
<p>수준의 목록은 <a class="reference internal" href="#levels"><span class="std std-ref">로깅 수준</span></a>를 보세요.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><em>level</em> 매개 변수는 이제 <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code>와 같은 정수 상수 대신 'INFO'와 같은 수준 문자열 표현을 허용합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.setFormatter">
<code class="descname">setFormatter</code><span class="sig-paren">(</span><em>fmt</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.setFormatter" title="정의 주소">¶</a></dt>
<dd><p>이 처리기의 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a>를 <em>fmt</em> 로 설정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.addFilter">
<code class="descname">addFilter</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.addFilter" title="정의 주소">¶</a></dt>
<dd><p>지정된 필터 <em>filter</em> 를 이 처리기에 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.removeFilter">
<code class="descname">removeFilter</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.removeFilter" title="정의 주소">¶</a></dt>
<dd><p>이 처리기에서 지정된 필터 <em>filter</em> 를 제거합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.filter" title="정의 주소">¶</a></dt>
<dd><p>이 처리기의 필터를 레코드에 적용하고 레코드가 처리 대상이면 참값을 반환합니다. 필터 중 어느 하나가 거짓 값을 반환할 때까지 필터는 차례로 확인됩니다. 그중 아무것도 거짓 값을 반환하지 않으면 레코드가 출력됩니다. 어느 하나가 거짓 값을 반환하면 처리기는 레코드를 출력하지 않습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 메서드는 레코드가 처리될 대상인지를 확인만 할뿐 실제 처리하지는 않습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.flush" title="정의 주소">¶</a></dt>
<dd><p>모든 로그 출력이 플러시 되었음을 확실히 합니다. 이 버전은 아무것도 하지 않으며, 서브 클래스에 의해 구현됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.close" title="정의 주소">¶</a></dt>
<dd><p>처리기가 사용하는 자원을 정리합니다. 이 버전은 출력하지 않지만, <a class="reference internal" href="#logging.shutdown" title="logging.shutdown"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutdown()</span></code></a> 이 호출 될 때 닫히는 처리기의 내부 목록에서 처리기를 제거합니다. 서브 클래스는 이것이 재정의된 <a class="reference internal" href="#logging.Handler.close" title="logging.Handler.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 메서드에서 이 메서드를 호출해야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.handle" title="정의 주소">¶</a></dt>
<dd><p>처리기에 추가된 필터에 따라 조건부로, 지정된 로깅 레코드를 출력합니다. 레코드의 실제 출력을 I/O 스레드 록의 확보/해제로 둘러쌉니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.handleError">
<code class="descname">handleError</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.handleError" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#logging.Handler.emit" title="logging.Handler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a> 호출 중에 예외가 발생할 때 처리기에서 호출됩니다. 모듈 수준 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">raiseExceptions</span></code> 가 <code class="docutils literal notranslate"><span class="pre">False</span></code> 인 경우 예외는 조용히 무시됩니다. 이 동작은 대부분 로깅 시스템에서 원하는 방식입니다 - 대부분 사용자는 로깅 시스템 자체의 에러에 관심이 없고, 응용 프로그램 에러에 더 관심이 있습니다. 그러나 원하는 경우, 사용자 정의 처리기로 바꿀 수 있습니다. 지정된 레코드는 예외가 발생할 때 처리되고 있던 레코드입니다. (<code class="docutils literal notranslate"><span class="pre">raiseExceptions</span></code> 의 기본값은 <code class="docutils literal notranslate"><span class="pre">True</span></code> 입니다. 개발 중에 더 유용합니다).</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><a class="reference internal" href="#logging.Handler.handleError" title="logging.Handler.handleError"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handleError()</span></code></a> 를 호출하는 책임은 <a class="reference internal" href="#logging.Handler.emit" title="logging.Handler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a> 구현에 있습니다.
<a class="reference internal" href="#logging.Handler.handle" title="logging.Handler.handle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle()</span></code></a> 은 <a class="reference internal" href="#logging.Handler.handleError" title="logging.Handler.handleError"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handleError()</span></code></a> 를 호출하지 않습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.format">
<code class="descname">format</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.format" title="정의 주소">¶</a></dt>
<dd><p>레코드를 포맷합니다 - 포매터가 설정된 경우 사용합니다. 그렇지 않으면 모듈의 기본 포매터를 사용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Handler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.emit" title="정의 주소">¶</a></dt>
<dd><p>지정된 로깅 레코드를 실제로 로그 하는 데 필요한 작업을 수행합니다. 이 버전은 서브 클래스에 의해 구현될 것으로 보고 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

</dd></dl>

<p>표준으로 포함된 처리기 목록은 <a class="reference internal" href="logging.handlers.html#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 를 참조하십시오.</p>
</div>
<div class="section" id="formatter-objects">
<span id="id1"></span><h2>Formatter 객체<a class="headerlink" href="#formatter-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 객체는 다음과 같은 어트리뷰트와 메서드를 가지고 있습니다. 이들은 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 를 (보통) 사람이나 외부 시스템이 해석 할 수 있는 문자열로 변환하는 역할을 합니다. 베이스 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 는 포매팅 문자열을 지정할 수 있게 합니다. 아무것도 지정하지 않으면, <code class="docutils literal notranslate"><span class="pre">'%(message)s'</span></code> 이 기본값으로 사용되는데, 단지 로깅 호출에서 제공된 메시지만 포함됩니다. 포맷된 출력에 추가 정보(가령 타임스탬프)를 넣으려면 계속 읽으십시오.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">어트리뷰트를 따로 명시하지 않아서 찾기 불편하지만, 본문에는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Formatter.converter</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">Formatter.default_time_format</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">Formatter.default_msec_format</span></code>
이 정의되어 있습니다.</p>
</div>
<p>포매터는 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 어트리뷰트에 포함된 정보를 사용하는 포맷 문자열로 초기화될 수 있습니다 - 위에서 언급 한 기본값은 사용자의 메시지와 인자가 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 의 <em>message</em> 어트리뷰트로 미리 포맷된다는 사실을 활용합니다. 이 포맷 문자열은 표준 파이썬 %-스타일 매핑 키를 포함합니다. 문자열 포매팅에 대해서 더 많은 정보가 필요하면 <a class="reference internal" href="stdtypes.html#old-string-formatting"><span class="std std-ref">printf 스타일 문자열 포매팅</span></a>를 보세요.</p>
<p><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 에 있는 유용한 매핑 키는 <a class="reference internal" href="#logrecord-attributes"><span class="std std-ref">LogRecord 어트리뷰트</span></a> 섹션에 있습니다.</p>
<dl class="class">
<dt id="logging.Formatter">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">Formatter</code><span class="sig-paren">(</span><em>fmt=None</em>, <em>datefmt=None</em>, <em>style='%'</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 클래스의 새로운 인스턴스를 반환합니다. 인스턴스는 전체 메시지의 포맷 문자열과 메시지의 날짜/시간 부분에 대한 포맷 문자열로 초기화됩니다. <em>fmt</em> 가 지정되지 않으면 <code class="docutils literal notranslate"><span class="pre">'%(message)s'</span></code> 가 사용됩니다. <em>datefmt</em> 가 지정되지 않으면 <a class="reference internal" href="#logging.Formatter.formatTime" title="logging.Formatter.formatTime"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatTime()</span></code></a> 설명서에 기술된 포맷이 사용됩니다.</p>
<p><em>style</em> 매개 변수는 '%', '{' 또는 '$' 중 하나일 수 있으며, 포맷 문자열이 데이터와 병합되는 방식을 결정합니다: %-포매팅, <a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 또는 <a class="reference internal" href="string.html#string.Template" title="string.Template"><code class="xref py py-class docutils literal notranslate"><span class="pre">string.Template</span></code></a> 중 하나를 사용합니다. 로그 메시지에 {- 와 $-포매팅을 사용하는 방법에 대한 자세한 내용은 <a class="reference internal" href="../howto/logging-cookbook.html#formatting-styles"><span class="std std-ref">응용 프로그램 전체에서 특정 포맷 스타일 사용하기</span></a>을 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><em>style</em> 매개 변수가 추가되었습니다.</p>
</div>
<dl class="method">
<dt id="logging.Formatter.format">
<code class="descname">format</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.format" title="정의 주소">¶</a></dt>
<dd><p>레코드의 어트리뷰트 딕셔너리가 문자열 포매팅 연산의 피연산자로 사용됩니다. 결과 문자열을 반환합니다. 딕셔너리를 포맷하기 전에 몇 가지 준비 단계가 수행됩니다. 레코드의 <em>message</em> 어트리뷰트를 <em>msg</em> % <em>args</em> 를 사용하여 계산합니다. 포매팅 문자열에 <code class="docutils literal notranslate"><span class="pre">'(asctime)'</span></code> 이 들어 있으면, <a class="reference internal" href="#logging.Formatter.formatTime" title="logging.Formatter.formatTime"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatTime()</span></code></a> 이 호출되어 이벤트 시간을 포매팅합니다. 예외 정보가 있는 경우, <a class="reference internal" href="#logging.Formatter.formatException" title="logging.Formatter.formatException"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatException()</span></code></a> 을 사용하여 포매팅 되고 메시지에 덧붙입니다. 포맷된 예외 정보는 <em>exc_text</em> 어트리뷰트에 캐시 됩니다. 예외 정보를 피클 해서 네트워크를 통해 전송할 수 있으므로 유용합니다만, 예외 정보의 포매팅을 사용자 정의하는 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 서브 클래스가 두 개 이상 있는 경우 주의해야 합니다. 이 경우, 한 포매터가 포매팅을 완료한 후 캐시 된 값을 지워서 그 이벤트를 처리하는 다음 포매터가 캐시 된 값을 사용하지 않고 새로 계산할 수 있도록 해야 합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><em>exc_text</em> 는 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 의 어트리뷰트입니다.</p>
</div>
<p>스택 정보가 있는 경우, 예외 정보 뒤에 덧붙입니다. 필요할 경우 <a class="reference internal" href="#logging.Formatter.formatStack" title="logging.Formatter.formatStack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatStack()</span></code></a> 을 사용하여 변환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Formatter.formatTime">
<code class="descname">formatTime</code><span class="sig-paren">(</span><em>record</em>, <em>datefmt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.formatTime" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 포맷된 시간을 사용하려는 포매터에 의해 <a class="reference internal" href="functions.html#format" title="format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">format()</span></code></a>에서 호출되어야 합니다. 이 메서드는 특정 요구 사항을 제공하기 위해 포매터에서 재정의될 수 있지만, 기본 동작은 다음과 같습니다: <em>datefmt</em>(문자열)이 지정된 경우, <a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strftime()</span></code></a> 를 사용하여 레코드 생성 시간을 포매팅합니다. 그렇지 않으면 '%Y-%m-%d %H:%M:%S,uuu' 포맷이 사용됩니다. 여기서 uuu 부분은 밀리 초 값이고, 다른 문자들은 <a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strftime()</span></code></a> 설명서를 따릅니다. 이 포맷의 표현된 시간의 예는 <code class="docutils literal notranslate"><span class="pre">2003-01-23</span> <span class="pre">00:29:50,411</span></code> 입니다. 결과 문자열이 반환됩니다.</p>
<p>이 함수는 사용자가 구성할 수 있는 함수를 사용하여 생성 시간을 튜플로 변환합니다. 기본적으로 <a class="reference internal" href="time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> 이 사용됩니다; 특정 포매터 인스턴스에서 이를 변경하려면, <code class="docutils literal notranslate"><span class="pre">converter</span></code> 어트리뷰트를 <a class="reference internal" href="time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> 또는 <a class="reference internal" href="time.html#time.gmtime" title="time.gmtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.gmtime()</span></code></a> 과 같은 서명을 가진 함수로 설정하십시오. 모든 포매터를 변경하려면, 예를 들어 모든 로깅 시간을 GMT로 표시하려면, <code class="docutils literal notranslate"><span class="pre">Formatter</span></code> 클래스의 <code class="docutils literal notranslate"><span class="pre">converter</span></code> 어트리뷰트를 설정하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>예전에는, 기본 포맷이 다음과 같이 하드 코딩되었습니다: <code class="docutils literal notranslate"><span class="pre">2010-09-06</span> <span class="pre">22:38:15,292</span></code>. 쉼표 앞에 있는 부분은 strptime 포맷 문자열(<code class="docutils literal notranslate"><span class="pre">'%Y-%m-%d</span> <span class="pre">%H:%M:%S'</span></code>)이며, 쉼표 뒤의 부분은 밀리 초 값입니다. strptime에 밀리 초 포맷 표시자가 없으므로, 밀리 초 값은 다른 포맷 문자열 <code class="docutils literal notranslate"><span class="pre">'%s,%03d'</span></code> 을 사용하여 추가됩니다 --- 이 두 포맷 문자열 모두 이 메서드에 하드 코드 되었습니다. 이 변경으로, 이 문자열들은 클래스 수준 어트리뷰트로 정의되었고, 원하는 경우 인스턴스 수준에서 재정의할 수 있습니다. 어트리뷰트 이름은 <code class="docutils literal notranslate"><span class="pre">default_time_format</span></code>(strptime 포맷 문자열)과 <code class="docutils literal notranslate"><span class="pre">default_msec_format</span></code>(밀리 초 값 추가용)입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.Formatter.formatException">
<code class="descname">formatException</code><span class="sig-paren">(</span><em>exc_info</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.formatException" title="정의 주소">¶</a></dt>
<dd><p>지정된 예외 정보(<a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 에 의해 반환되는 표준 예외 튜플)를 문자열로 포맷합니다. 이 기본 구현은 <a class="reference internal" href="traceback.html#traceback.print_exception" title="traceback.print_exception"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.print_exception()</span></code></a>을 사용합니다. 결과 문자열이 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.Formatter.formatStack">
<code class="descname">formatStack</code><span class="sig-paren">(</span><em>stack_info</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.formatStack" title="정의 주소">¶</a></dt>
<dd><p>지정된 스택 정보(<a class="reference internal" href="traceback.html#traceback.print_stack" title="traceback.print_stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.print_stack()</span></code></a> 에 의해 반환된 문자열이지만 마지막 줄 바꿈이 제거됩니다)을 문자열로 포맷합니다. 이 기본 구현은 입력 값을 그대로 반환합니다.</p>
</dd></dl>

</dd></dl>

<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p>본문에는 <a class="reference internal" href="#logging.BufferingFormatter" title="logging.BufferingFormatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferingFormatter</span></code></a> 가 빠져있습니다. 여기에 간단한 설명을 붙입니다.</p>
<dl class="last class">
<dt id="logging.BufferingFormatter">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">BufferingFormatter</code><span class="sig-paren">(</span><em>linefmt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.BufferingFormatter" title="정의 주소">¶</a></dt>
<dd><p>여러 레코드를 포맷하는데 적합한 포매터.</p>
<p><em>linefmt</em> 는 개별 레코드를 포맷하는데 사용될 포매터를 지정합니다. 지정하지 않으면 기본
포매터(<a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a>)가 사용됩니다.</p>
<dl class="method">
<dt id="logging.BufferingFormatter.format">
<code class="descname">format</code><span class="sig-paren">(</span><em>records</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.BufferingFormatter.format" title="정의 주소">¶</a></dt>
<dd><p>지정된 레코드들을 포맷하고 그 결과를 문자열로 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.BufferingFormatter.formatFooter">
<code class="descname">formatFooter</code><span class="sig-paren">(</span><em>records</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.BufferingFormatter.formatFooter" title="정의 주소">¶</a></dt>
<dd><p>지정된 레코드들의 바닥글 문자열을 반환합니다. 기본 구현은 빈 문자열을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.BufferingFormatter.formatHeader">
<code class="descname">formatHeader</code><span class="sig-paren">(</span><em>records</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.BufferingFormatter.formatHeader" title="정의 주소">¶</a></dt>
<dd><p>지정된 레코드들의 머릿글 문자열을 반환합니다. 기본 구현은 빈 문자열을 돌려줍니다.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="filter-objects">
<span id="filter"></span><h2>Filter 객체<a class="headerlink" href="#filter-objects" title="제목 주소">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Filter</span></code> 는 수준을 통해 제공되는 것보다 더 정교한 필터링을 위해 <code class="docutils literal notranslate"><span class="pre">Handler</span></code> 와 <code class="docutils literal notranslate"><span class="pre">Logger</span></code> 에 의해 사용될 수 있습니다. 베이스 필터 클래스는 로거 계층 구조의 특정 지점 아래에 있는 이벤트만 허용합니다. 예를 들어 'A.B'로 초기화된 필터는, 로거 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' 등이 로그 한 이벤트를 허용하지만, 'A.BB', 'B.A.B' 등은 허용하지 않습니다. 빈 문자열을 사용하면 모든 이벤트를 통과시킵니다.</p>
<dl class="class">
<dt id="logging.Filter">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">Filter</code><span class="sig-paren">(</span><em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Filter" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.Filter" title="logging.Filter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Filter</span></code></a> 클래스의 인스턴스를 반환합니다. <em>name</em> 을 제공하면, 필터를 통과하도록 허용할 로거(그 자식들도 포함합니다)의 이름을 지정합니다. <em>name</em> 이 빈 문자열이면, 모든 이벤트를 허용합니다.</p>
<dl class="method">
<dt id="logging.Filter.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Filter.filter" title="정의 주소">¶</a></dt>
<dd><p>지정된 레코드가 로그 됩니까? 아니라면 0을 반환하고, 그렇다면 0이 아닌 값을 반환합니다. 적절하다고 판단되면, 이 메서드는 해당 레코드를 수정할 수 있습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">필터가 레코드를 수정할 수 있도록 허용하기 때문에, 필터는 레코드에 문맥 정보를 주입하는데
사용될 수 있습니다.</p>
</div>
</dd></dl>

</dd></dl>

<p>처리기에 첨부된 필터는 이벤트를 처리기가 출력하기 전에 호출되는 반면, 로거에 첨부된 필터는 이벤트가 로깅될 때마다 (<a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.info" title="logging.info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code></a> 등) 처리기로 이벤트를 보내기 전에 호출됩니다. 이는 자손 로거가 만든 이벤트들은, 같은 필터가 자손들에게도 적용되지 않는 한, 로거의 필터 설정으로 필터링 되지 않는다는 것을 뜻합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">조상 로거로의 이벤트 확산은 로거에의한 필터링이 완료된 후에 이루어집니다. 확산될 때 이벤트는
조상 로거의 처리기들로 전달될 뿐, 조상 로거의 필터를 거치지는 않는다는 뜻입니다.</p>
</div>
<p>실제로 <code class="docutils literal notranslate"><span class="pre">Filter</span></code> 의 서브 클래스를 만들 필요는 없습니다: 같은 의미가 있는 <code class="docutils literal notranslate"><span class="pre">filter</span></code> 메서드를 가진 인스턴스는 무엇이건 전달할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>특수한 <code class="docutils literal notranslate"><span class="pre">Filter</span></code> 클래스를 만들거나 <code class="docutils literal notranslate"><span class="pre">filter</span></code> 메서드를 가진 다른 클래스를 사용할 필요가 없습니다: 함수(또는 다른 콜러블)를 필터로 사용할 수 있습니다. 필터링 로직은 필터 객체가 <code class="docutils literal notranslate"><span class="pre">filter</span></code> 어트리뷰트를 가졌는지 확인합니다: 만약 있다면 <code class="docutils literal notranslate"><span class="pre">Filter</span></code> 라고 가정하고 <a class="reference internal" href="#logging.Filter.filter" title="logging.Filter.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 메서드를 호출합니다. 그렇지 않으면 콜러블이라고 가정하고 레코드를 단일 매개 변수로 호출합니다. 반환된 값은 <a class="reference internal" href="#logging.Filter.filter" title="logging.Filter.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 가 반환하는 값과 같은 의미를 지녀야 합니다.</p>
</div>
<p>필터는 수준보다 정교한 기준에 따라 레코드를 필터링하는 데 주로 사용되지만, 필터가 첨부되는 처리기나 로거에서 처리되는 모든 레코드를 볼 수 있습니다: 이 특성은, 특정 로거나 처리기가 얼마나 많은 레코드를 처리하는지 센다거나, 처리 중인 LogRecord에 어트리뷰트를 추가, 변경, 삭제하려고 할 때 유용합니다. 당연히, LogRecord를 변경하는 것은 주의를 필요로 하는 일이지만, 로그에 문맥 정보를 주입하는 것을 허용합니다 (<a class="reference internal" href="../howto/logging-cookbook.html#filters-contextual"><span class="std std-ref">문맥 정보 전달에 필터 사용하기</span></a>를 보세요).</p>
</div>
<div class="section" id="logrecord-objects">
<span id="log-record"></span><h2>LogRecord 객체<a class="headerlink" href="#logrecord-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 인스턴스는 뭔가 로깅 될 때마다 <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 에 의해 자동으로 생성되며, <a class="reference internal" href="#logging.makeLogRecord" title="logging.makeLogRecord"><code class="xref py py-func docutils literal notranslate"><span class="pre">makeLogRecord()</span></code></a>를 통해 수동으로 생성될 수 있습니다 (예를 들어, 네트워크에서 수신된 피클 된 이벤트의 경우).</p>
<dl class="class">
<dt id="logging.LogRecord">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">LogRecord</code><span class="sig-paren">(</span><em>name</em>, <em>level</em>, <em>pathname</em>, <em>lineno</em>, <em>msg</em>, <em>args</em>, <em>exc_info</em>, <em>func=None</em>, <em>sinfo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.LogRecord" title="정의 주소">¶</a></dt>
<dd><p>로그 되는 이벤트와 관련된 모든 정보를 담고 있습니다.</p>
<p>주요 정보는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">msg</span></code>와 <code class="xref py py-attr docutils literal notranslate"><span class="pre">args</span></code> 로 전달되며, <code class="docutils literal notranslate"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">args</span></code> 를 사용하여 병합되어 레코드의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">message</span></code> 필드를 만듭니다.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">매개 변수:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> -- 이 LogRecord가 나타내는 이벤트를 로그 하는데 사용된 로거의 이름. 이 이름은 다른 (조상) 로거에 첨부된 처리기가 출력하더라도 항상 이 값을 갖습니다.</li>
<li><strong>level</strong> -- 로깅 이벤트의 숫자 수준 (DEBUG, INFO 등). 이 값은 LogRecord의 <em>두</em> 어트리뷰트로 변환됩니다: 숫자 값을 위한 <code class="docutils literal notranslate"><span class="pre">levelno</span></code> 와 해당 수준 이름을 위한 <code class="docutils literal notranslate"><span class="pre">levelname</span></code>.</li>
<li><strong>pathname</strong> -- 로깅 호출이 발생한 소스 파일의 전체 경로명.</li>
<li><strong>lineno</strong> -- 로깅 호출이 발생한 소스 파일의 행 번호.</li>
<li><strong>msg</strong> -- 이벤트 설명 메시지. 변수 데이터를 위한 자리 표시자가 있는 포맷 문자열일 수 있습니다.</li>
<li><strong>args</strong> -- 이벤트 설명을 얻기 위해 <em>msg</em> 인자에 병합할 변수 데이터.</li>
<li><strong>exc_info</strong> -- 현재의 예외 정보를 가지는 예외 튜플. 예외 정보가 없는 경우는 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다.</li>
<li><strong>func</strong> -- 로깅 호출을 호출한 함수 또는 메서드의 이름.</li>
<li><strong>sinfo</strong> -- 현재 스레드에서 스택의 바닥부터 로깅 호출까지의 스택 정보를 나타내는 텍스트 문자열.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="logging.LogRecord.getMessage">
<code class="descname">getMessage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.LogRecord.getMessage" title="정의 주소">¶</a></dt>
<dd><p>사용자가 제공 한 인자를 메시지와 병합한 후, 이 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 인스턴스에 대한 메시지를 반환합니다. 로깅 호출에 제공된 사용자 제공 메시지 인자가 문자열이 아닌 경우, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 이 호출되어 문자열로 변환됩니다. 이렇게 해서 사용자 정의 클래스를 메시지로 사용할 수 있도록 하는데, 그 클래스의 <code class="docutils literal notranslate"><span class="pre">__str__</span></code> 메서드는 사용할 실제 포맷 문자열을 반환 할 수 있습니다.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>레코드를 생성하는 데 사용되는 팩토리를 제공함으로써, <code class="docutils literal notranslate"><span class="pre">LogRecord</span></code> 의 생성을 더 구성할 수 있게 만들었습니다. 팩토리는 <a class="reference internal" href="#logging.getLogRecordFactory" title="logging.getLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">getLogRecordFactory()</span></code></a>와 <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLogRecordFactory()</span></code></a> (팩토리의 서명은 이곳을 참조하십시오) 를 사용하여 설정할 수 있습니다.</p>
</div>
<p>이 기능은 LogRecord 생성 시에 여러분 자신의 값을 주입하는데 사용할 수 있습니다. 다음과 같은 패턴을 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">old_factory</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogRecordFactory</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">record_factory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">record</span> <span class="o">=</span> <span class="n">old_factory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">record</span><span class="o">.</span><span class="n">custom_attribute</span> <span class="o">=</span> <span class="mh">0xdecafbad</span>
    <span class="k">return</span> <span class="n">record</span>

<span class="n">logging</span><span class="o">.</span><span class="n">setLogRecordFactory</span><span class="p">(</span><span class="n">record_factory</span><span class="p">)</span>
</pre></div>
</div>
<p>이 패턴을 사용하면 여러 팩토리를 체인으로 묶을 수 있으며, 서로의 어트리뷰트를 덮어쓰거나 위에 나열된 표준 어트리뷰트를 실수로 덮어쓰지 않는 한 놀랄만한 일이 일어나지는 않아야 합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이 패턴을 사용할 경우, 체인에 참여하는 팩토리의 순서는 임포트 순서에 영향을 받습니다. 임포트 순서를
정확히 제어할 수 없는 경우가 많기 때문에, 여러 팩토리가 조작하는 어트리뷰트들이 독립적이지 않다면
예상하지 못한 일이 일어날 수 있습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="logrecord-attributes">
<span id="id2"></span><h2>LogRecord 어트리뷰트<a class="headerlink" href="#logrecord-attributes" title="제목 주소">¶</a></h2>
<p>LogRecord에는 많은 어트리뷰트가 있으며, 대부분 어트리뷰트는 생성자의 매개 변수에서 옵니다. (LogRecord 생성자 매개 변수와 LogRecord 어트리뷰트의 이름이 항상 정확하게 일치하는 것은 아닙니다.) 이러한 어트리뷰트를 사용하여 레코드의 데이터를 포맷 문자열로 병합 할 수 있습니다. 다음 표는 어트리뷰트 이름, 의미와 해당 자리 표시자를 %-스타일 포맷 문자열로 (알파벳 순서로) 나열합니다.</p>
<p>{}-포매팅(<a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-func docutils literal notranslate"><span class="pre">str.format()</span></code></a>)을 사용한다면, <code class="docutils literal notranslate"><span class="pre">{attrname}</span></code> 을 포맷 문자열의 자리 표시자로 사용할 수 있습니다. $-포매팅(<a class="reference internal" href="string.html#string.Template" title="string.Template"><code class="xref py py-class docutils literal notranslate"><span class="pre">string.Template</span></code></a>)을 사용하고 있다면, <code class="docutils literal notranslate"><span class="pre">${attrname}</span></code> 형식을 사용하십시오. 두 경우 모두, 물론, <code class="docutils literal notranslate"><span class="pre">attrname</span></code> 을 사용하려는 실제 어트리뷰트 이름으로 대체하십시오.</p>
<p>{}-포매팅의 경우, 어트리뷰트 이름 다음에 콜론(:)으로 구분하여 포매팅 플래그를 지정할 수 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">{msecs:03d}</span></code> 자리 표시자는 밀리 초 값 <code class="docutils literal notranslate"><span class="pre">4</span></code> 를 <code class="docutils literal notranslate"><span class="pre">004</span></code> 로 포맷합니다. 사용할 수 있는 옵션에 대한 자세한 내용은 <a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 설명서를 참조하십시오.</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="28%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">어트리뷰트 이름</th>
<th class="head">포맷</th>
<th class="head">설명</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>args</td>
<td>직접 포맷할 필요는 없습니다.</td>
<td><code class="docutils literal notranslate"><span class="pre">message</span></code> 를 생성하기 위해 <code class="docutils literal notranslate"><span class="pre">msg</span></code> 에 병합되는 인자의 튜플. 또는 (인자가 하나뿐이고 딕셔너리일 때) 병합을 위해 값이 사용되는 딕셔너리.</td>
</tr>
<tr class="row-odd"><td>asctime</td>
<td><code class="docutils literal notranslate"><span class="pre">%(asctime)s</span></code></td>
<td>사람이 읽을 수 있는, <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 가 생성된 시간. 기본적으로 '2003-07-08 16:49:45,896' 형식입니다 (쉼표 뒤의 숫자는 밀리 초 부분입니다).</td>
</tr>
<tr class="row-even"><td>created</td>
<td><code class="docutils literal notranslate"><span class="pre">%(created)f</span></code></td>
<td><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 가 생성된 시간 (<a class="reference internal" href="time.html#time.time" title="time.time"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.time()</span></code></a> 이 반환하는 시간).</td>
</tr>
<tr class="row-odd"><td>exc_info</td>
<td>직접 포맷할 필요는 없습니다.</td>
<td>예외 튜플 (<code class="docutils literal notranslate"><span class="pre">sys.exc_info</span></code> 에서 제공) 또는, 예외가 발생하지 않았다면, <code class="docutils literal notranslate"><span class="pre">None</span></code>.</td>
</tr>
<tr class="row-even"><td>filename</td>
<td><code class="docutils literal notranslate"><span class="pre">%(filename)s</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">pathname</span></code> 의 파일명 부분.</td>
</tr>
<tr class="row-odd"><td>funcName</td>
<td><code class="docutils literal notranslate"><span class="pre">%(funcName)s</span></code></td>
<td>로깅 호출을 포함하는 함수의 이름.</td>
</tr>
<tr class="row-even"><td>levelname</td>
<td><code class="docutils literal notranslate"><span class="pre">%(levelname)s</span></code></td>
<td>메시지의 텍스트 로깅 수준 (<code class="docutils literal notranslate"><span class="pre">'DEBUG'</span></code>, <code class="docutils literal notranslate"><span class="pre">'INFO'</span></code>, <code class="docutils literal notranslate"><span class="pre">'WARNING'</span></code>, <code class="docutils literal notranslate"><span class="pre">'ERROR'</span></code>, <code class="docutils literal notranslate"><span class="pre">'CRITICAL'</span></code>).</td>
</tr>
<tr class="row-odd"><td>levelno</td>
<td><code class="docutils literal notranslate"><span class="pre">%(levelno)s</span></code></td>
<td>메시지의 숫자 로깅 수준 (<code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code>).</td>
</tr>
<tr class="row-even"><td>lineno</td>
<td><code class="docutils literal notranslate"><span class="pre">%(lineno)d</span></code></td>
<td>로깅 호출이 일어난 소스 행 번호 (사용 가능한 경우).</td>
</tr>
<tr class="row-odd"><td>message</td>
<td><code class="docutils literal notranslate"><span class="pre">%(message)s</span></code></td>
<td>로그 된 메시지. <code class="docutils literal notranslate"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">args</span></code> 로 계산됩니다. <a class="reference internal" href="#logging.Formatter.format" title="logging.Formatter.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Formatter.format()</span></code></a> 이 호출 될 때 설정됩니다.</td>
</tr>
<tr class="row-even"><td>module</td>
<td><code class="docutils literal notranslate"><span class="pre">%(module)s</span></code></td>
<td>모듈 (<code class="docutils literal notranslate"><span class="pre">filename</span></code> 의 이름 부분).</td>
</tr>
<tr class="row-odd"><td>msecs</td>
<td><code class="docutils literal notranslate"><span class="pre">%(msecs)d</span></code></td>
<td><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 가 생성된 시간의 밀리 초 부분.</td>
</tr>
<tr class="row-even"><td>msg</td>
<td>직접 포맷할 필요는 없습니다.</td>
<td>원래 로깅 호출에서 전달된 포맷 문자열. <code class="docutils literal notranslate"><span class="pre">args</span></code> 와 병합하여 <code class="docutils literal notranslate"><span class="pre">message</span></code> 를 만듭니다. 또는 임의의 객체 (<a class="reference internal" href="../howto/logging.html#arbitrary-object-messages"><span class="std std-ref">임의의 객체를 메시지로 사용하기</span></a> 를 보세요).</td>
</tr>
<tr class="row-odd"><td>name</td>
<td><code class="docutils literal notranslate"><span class="pre">%(name)s</span></code></td>
<td>로깅 호출에 사용된 로거의 이름.</td>
</tr>
<tr class="row-even"><td>pathname</td>
<td><code class="docutils literal notranslate"><span class="pre">%(pathname)s</span></code></td>
<td>로깅 호출이 일어난 소스 파일의 전체 경로명 (사용 가능한 경우).</td>
</tr>
<tr class="row-odd"><td>process</td>
<td><code class="docutils literal notranslate"><span class="pre">%(process)d</span></code></td>
<td>프로세스 ID (사용 가능한 경우).</td>
</tr>
<tr class="row-even"><td>processName</td>
<td><code class="docutils literal notranslate"><span class="pre">%(processName)s</span></code></td>
<td>프로세스 이름 (사용 가능한 경우).</td>
</tr>
<tr class="row-odd"><td>relativeCreated</td>
<td><code class="docutils literal notranslate"><span class="pre">%(relativeCreated)d</span></code></td>
<td>logging 모듈이 로드된 시간을 기준으로 LogRecord가 생성된 시간 (밀리 초).</td>
</tr>
<tr class="row-even"><td>stack_info</td>
<td>직접 포맷할 필요는 없습니다.</td>
<td>현재 스레드의 스택 바닥에서 이 레코드를 생성한 로깅 호출의 스택 프레임까지의 스택 프레임 정보 (사용 가능한 경우).</td>
</tr>
<tr class="row-odd"><td>thread</td>
<td><code class="docutils literal notranslate"><span class="pre">%(thread)d</span></code></td>
<td>스레드 ID (사용 가능한 경우).</td>
</tr>
<tr class="row-even"><td>threadName</td>
<td><code class="docutils literal notranslate"><span class="pre">%(threadName)s</span></code></td>
<td>스레드 이름 (사용 가능한 경우).</td>
</tr>
</tbody>
</table>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p><code class="docutils literal notranslate"><span class="pre">module</span></code> 은 <code class="docutils literal notranslate"><span class="pre">filename</span></code> 에서 확장자를 제외한 부분을 뜻합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">processName</span></code> 은 <a class="reference internal" href="multiprocessing.html#multiprocessing.Process.name" title="multiprocessing.Process.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">multiprocessing.Process.name</span></code></a> 의 값입니다.
<code class="docutils literal notranslate"><span class="pre">logging.logProcesses</span> <span class="pre">=</span> <span class="pre">False</span></code> 하면 그 이후로 <code class="docutils literal notranslate"><span class="pre">process</span></code> 는 제공되지 않습니다.
<code class="docutils literal notranslate"><span class="pre">logging.logMultiprocessing</span> <span class="pre">=</span> <span class="pre">False</span></code> 하면 그 이후로 <code class="docutils literal notranslate"><span class="pre">processName</span></code> 은 제공되지 않습니다.</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">threadName</span></code> 은 <a class="reference internal" href="threading.html#threading.Thread.name" title="threading.Thread.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">threading.Thread.name</span></code></a> 의 값입니다.
<code class="docutils literal notranslate"><span class="pre">logging.logThreads</span> <span class="pre">=</span> <span class="pre">False</span></code> 하면 그 이후로 <code class="docutils literal notranslate"><span class="pre">thread</span></code> 는 제공되지 않습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.1으로 변경: </span><em>processName</em> 이 추가되었습니다.</p>
</div>
</div>
<div class="section" id="loggeradapter-objects">
<span id="logger-adapter"></span><h2>LoggerAdapter 객체<a class="headerlink" href="#loggeradapter-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> 인스턴스는 문맥 정보를 로깅 호출에 편리하게 전달하는 데 사용됩니다. 사용 예는, <a class="reference internal" href="../howto/logging-cookbook.html#context-info"><span class="std std-ref">로그 출력에 문맥 정보 추가</span></a> 섹션을 참조하십시오.</p>
<dl class="class">
<dt id="logging.LoggerAdapter">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">LoggerAdapter</code><span class="sig-paren">(</span><em>logger</em>, <em>extra</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.LoggerAdapter" title="정의 주소">¶</a></dt>
<dd><p>하부 <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 인스턴스와 딕셔너리 류 객체로 초기화된 <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> 의 인스턴스를 반환합니다.</p>
<dl class="method">
<dt id="logging.LoggerAdapter.process">
<code class="descname">process</code><span class="sig-paren">(</span><em>msg</em>, <em>kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.LoggerAdapter.process" title="정의 주소">¶</a></dt>
<dd><p>문맥 정보를 삽입하기 위해 로깅 호출에 전달된 메시지 와 키워드 인자를 수정합니다. 이 구현은 생성자에 <em>extra</em> 로 전달된 객체를 가져와서 'extra' 키를 사용하여 <em>kwargs</em> 에 추가합니다. 반환 값은 전달된 인자의 (수정된) 버전을 담은 (<em>msg</em>, <em>kwargs</em>) 튜플입니다.</p>
</dd></dl>

</dd></dl>

<p>위의 것에 더해, <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> 는 다음과 같은 <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 의 메서드를 지원합니다: <a class="reference internal" href="#logging.Logger.debug" title="logging.Logger.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.Logger.info" title="logging.Logger.info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code></a>, <a class="reference internal" href="#logging.Logger.warning" title="logging.Logger.warning"><code class="xref py py-meth docutils literal notranslate"><span class="pre">warning()</span></code></a>, <a class="reference internal" href="#logging.Logger.error" title="logging.Logger.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a>, <a class="reference internal" href="#logging.Logger.exception" title="logging.Logger.exception"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exception()</span></code></a>, <a class="reference internal" href="#logging.Logger.critical" title="logging.Logger.critical"><code class="xref py py-meth docutils literal notranslate"><span class="pre">critical()</span></code></a>, <a class="reference internal" href="#logging.Logger.log" title="logging.Logger.log"><code class="xref py py-meth docutils literal notranslate"><span class="pre">log()</span></code></a>, <a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isEnabledFor()</span></code></a>, <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a>, <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a>, <a class="reference internal" href="#logging.Logger.hasHandlers" title="logging.Logger.hasHandlers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hasHandlers()</span></code></a>. 이 메서드들은 <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 에 있는 것과 똑같은 서명을 가지므로, 두 형의 인스턴스를 바꿔쓸 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isEnabledFor()</span></code></a>, <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a>, <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a> 그리고 <a class="reference internal" href="#logging.Logger.hasHandlers" title="logging.Logger.hasHandlers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hasHandlers()</span></code></a> 메서드가 <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> 에 추가되었습니다. 이 메서드는 하부 로거로 위임합니다.</p>
</div>
</div>
<div class="section" id="thread-safety">
<h2>스레드 안전성<a class="headerlink" href="#thread-safety" title="제목 주소">¶</a></h2>
<p>로깅 모듈은 클라이언트가 특별한 주의를 기울이지 않아도 스레드 안전하도록 만들어졌습니다. 이렇게 하려고 threading 록을 사용합니다; 모듈의 공유 데이터에 대한 액세스를 직렬화하는 록이 하나 있고, 각 처리기 또한 하부 I/O에 대한 액세스를 직렬화하는 록을 만듭니다.</p>
<p><a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 모듈을 사용하여 비동기 시그널 처리기를 구현한다면, 그 처리기 내에서는 logging을 사용할 수 없을 수도 있습니다. 이는 <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 모듈의 록 구현이 언제나 재진입할 수 있지는 않아서 그러한 시그널 처리기에서 호출할 수 없기 때문입니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">logging 모듈이 사용하고 있는 <a class="reference internal" href="threading.html#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.RLock</span></code></a> 이 시그널에 안전하지 않다는 내용입니다만,
이는 파이썬으로 구현된 버전에만 해당하는 내용입니다. 최근의 파이썬 버전에서 사용되는
<a class="reference internal" href="threading.html#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.RLock</span></code></a> 의 C 구현은 시그널에 안전합니다.</p>
</div>
</div>
<div class="section" id="module-level-functions">
<h2>모듈 수준 함수<a class="headerlink" href="#module-level-functions" title="제목 주소">¶</a></h2>
<p>위에서 설명한 클래스 외에도 많은 모듈 수준 함수가 있습니다.</p>
<dl class="function">
<dt id="logging.getLogger">
<code class="descclassname">logging.</code><code class="descname">getLogger</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLogger" title="정의 주소">¶</a></dt>
<dd><p>지정된 이름(name)의 로거를 돌려주거나, name이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 인 경우, 계층의 루트 로거인 로거를 돌려줍니다. 지정된 경우, name은 일반적으로 <em>'a'</em>, <em>'a.b'</em> 또는 <em>'a.b.c.d'</em> 와 같이 점으로 구분된 계층적 이름입니다. 이 이름의 선택은 전적으로 logging을 사용하는 개발자에게 달려 있습니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이름을 자유롭게 선택할 수 있지만, 계층을 구분하는데 점(.)대신 다른 기호를 사용할 수는 없습니다.</p>
</div>
<p>같은 이름으로 이 함수를 여러 번 호출하면 모두 같은 로거 인스턴스를 반환합니다. 이것은 응용 프로그램의 다른 부분 간에 로거 인스턴스를 전달할 필요가 없다는 것을 뜻합니다.</p>
</dd></dl>

<dl class="function">
<dt id="logging.getLoggerClass">
<code class="descclassname">logging.</code><code class="descname">getLoggerClass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLoggerClass" title="정의 주소">¶</a></dt>
<dd><p>표준 <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 클래스를 반환하거나, <a class="reference internal" href="#logging.setLoggerClass" title="logging.setLoggerClass"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLoggerClass()</span></code></a> 에 전달된 마지막 클래스를 반환합니다. 이 함수는 새 클래스 정의 내에서 호출하여, 사용자 정의 <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 클래스를 설치할 때 다른 코드가 이미 적용한 사용자 정의를 취소하지 않도록 할 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyLogger</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">getLoggerClass</span><span class="p">()):</span>
    <span class="c1"># ... 여기에서 동작을 재정의 합니다</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.getLogRecordFactory">
<code class="descclassname">logging.</code><code class="descname">getLogRecordFactory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLogRecordFactory" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 를 생성하는 데 사용되는 콜러블을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span>이 함수는 <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLogRecordFactory()</span></code></a>와 함께 제공되어, 개발자가 로깅 이벤트를 나타내는 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 가 만들어지는 방법을 더욱 잘 제어 할 수 있도록 합니다.</p>
</div>
<p>팩토리가 어떻게 호출되는지에 대한 더 자세한 정보는 <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLogRecordFactory()</span></code></a>를 보세요.</p>
</dd></dl>

<dl class="function">
<dt id="logging.debug">
<code class="descclassname">logging.</code><code class="descname">debug</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.debug" title="정의 주소">¶</a></dt>
<dd><p>루트 로거에 수준 <code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code> 메시지를 로그 합니다. <em>msg</em> 는 메시지 포맷 문자열이고, <em>args</em> 는 문자열 포매팅 연산자를 사용하여 <em>msg</em> 에 병합되는 인자입니다. (이는 포맷 문자열에 키워드를 사용하고, 인자로 하나의 딕셔너리를 전달할 수 있음을 의미합니다.)</p>
<p><em>kwargs</em> 에서 검사되는 세 개의 키워드 인자가 있습니다: <em>exc_info</em> 가 거짓으로 평가되지 않으면, 로깅 메시지에 예외 정보가 추가됩니다. 예외 튜플(<a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 에 의해 반환되는 형식)이나 예외 인스턴스가 제공되면 사용됩니다; 그렇지 않으면 예외 정보를 얻기 위해 <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 를 호출합니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last"><em>exc_info</em> 로 예외 인스턴스를 전달할 수도 있습니다.</p>
</div>
<p>두 번째 선택적 키워드 인자는 <em>stack_info</em> 이며, 기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code> 입니다. 참이면, 실제 로깅 호출을 포함하는 스택 정보가 로깅 메시지에 추가됩니다. 이것은 <em>exc_info</em> 를 지정할 때 표시되는 것과 같은 스택 정보가 아닙니다: 전자(<em>stack_info</em>)는 스택의 맨 아래에서 현재 스레드의 로깅 호출까지의 스택 프레임이며, 후자(<em>exc_info</em>)는 예외가 일어난 후에 예외 처리기를 찾으면서 되감은 스택 프레임에 대한 정보입니다.</p>
<p><em>exc_info</em> 와는 독립적으로 <em>stack_info</em> 를 지정할 수 있습니다. 예를 들어 예외가 발생하지 않은 경우에도 코드의 특정 지점에 어떻게 도달했는지 보여줄 수 있습니다. 스택 프레임은 다음과 같은 헤더 행 다음에 인쇄됩니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Stack (most recent call last):
</pre></div>
</div>
<p>예외 프레임을 표시할 때 사용되는 <code class="docutils literal notranslate"><span class="pre">Traceback</span> <span class="pre">(most</span> <span class="pre">recent</span> <span class="pre">call</span> <span class="pre">last):</span></code> 을 흉내 내고 있습니다.</p>
<p>세 번째 선택적 키워드 인자는 <em>extra</em> 로, 로깅 이벤트용으로 만들어진 LogRecord의 __dict__ 를 사용자 정의 어트리뷰트로 채우는 데 사용되는 딕셔너리를 전달할 수 있습니다. 이러한 사용자 정의 어트리뷰트는 원하는 대로 사용할 수 있습니다. 예를 들어, 로그 메시지에 포함할 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">FORMAT</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%(asctime)-15s</span><span class="s1"> </span><span class="si">%(clientip)s</span><span class="s1"> </span><span class="si">%(user)-8s</span><span class="s1"> </span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">FORMAT</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;clientip&#39;</span><span class="p">:</span> <span class="s1">&#39;192.168.0.1&#39;</span><span class="p">,</span> <span class="s1">&#39;user&#39;</span><span class="p">:</span> <span class="s1">&#39;fbloggs&#39;</span><span class="p">}</span>
<span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Protocol problem: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;connection reset&#39;</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>는 이렇게 인쇄할 것입니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
</pre></div>
</div>
<p><em>extra</em> 에 전달된 딕셔너리의 키가, 로깅 시스템에서 사용하는 키와 충돌해서는 안 됩니다. (어떤 키가 로깅 시스템에 의해 사용되는지에 대한 더 많은 정보는 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 문서를 보십시오.)</p>
<p>로그 된 메시지에서 이러한 어트리뷰트를 사용하려면 몇 가지 주의를 기울여야 합니다. 위의 예에서, 예를 들어, <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 에 설정한 포맷 문자열은 LogRecord의 어트리뷰트 딕셔너리에 'clientip' 과 'user' 가 있을 것으로 기대하고 있습니다. 이것들이 없는 경우 문자열 포매팅 예외가 발생하기 때문에 메시지가 기록되지 않습니다. 따라서 이 경우, 항상 이 키를 포함하는 <em>extra</em> 딕셔너리를 전달해야 합니다.</p>
<p>성가신 일입니다만, 이 기능은 여러 문맥에서 같은 코드가 실행되고 관심 있는 조건들(가령 원격 클라이언트 IP 주소와 인증된 사용자 이름)이 문맥에 따라 발생하는 다중 스레드 서버와 같은 특수한 상황을 위한 것입니다. 이런 상황에서는, 특수한 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 가 특정한 <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a>와 함께 사용될 가능성이 큽니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">로그에 문맥 정보를 추가하는 방법은 <a class="reference internal" href="../howto/logging-cookbook.html#context-info"><span class="std std-ref">로그 출력에 문맥 정보 추가</span></a> 에서 좀 더 자세히 설명합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span><em>stack_info</em> 매개 변수가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.info">
<code class="descclassname">logging.</code><code class="descname">info</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.info" title="정의 주소">¶</a></dt>
<dd><p>루트 로거에 수준 <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code> 메시지를 로그 합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>처럼 해석됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="logging.warning">
<code class="descclassname">logging.</code><code class="descname">warning</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.warning" title="정의 주소">¶</a></dt>
<dd><p>루트 로거에 수준 <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code> 메시지를 로그 합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>처럼 해석됩니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">기능적으로 <code class="docutils literal notranslate"><span class="pre">warning</span></code> 와 같은, 구식의 <code class="docutils literal notranslate"><span class="pre">warn</span></code> 함수가 있습니다. <code class="docutils literal notranslate"><span class="pre">warn</span></code> 은 폐지되었으므로 사용하지 마십시오 - 대신 <code class="docutils literal notranslate"><span class="pre">warning</span></code> 을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.error">
<code class="descclassname">logging.</code><code class="descname">error</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.error" title="정의 주소">¶</a></dt>
<dd><p>루트 로거에 수준 <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> 메시지를 로그 합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>처럼 해석됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="logging.critical">
<code class="descclassname">logging.</code><code class="descname">critical</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.critical" title="정의 주소">¶</a></dt>
<dd><p>루트 로거에 수준 <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code> 메시지를 로그 합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>처럼 해석됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="logging.exception">
<code class="descclassname">logging.</code><code class="descname">exception</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.exception" title="정의 주소">¶</a></dt>
<dd><p>루트 로거에 수준 <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> 메시지를 로그 합니다. 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>처럼 해석됩니다. 예외 정보가 로깅 메시지에 추가됩니다. 이 메서드는 예외 처리기에서만 호출해야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="logging.log">
<code class="descclassname">logging.</code><code class="descname">log</code><span class="sig-paren">(</span><em>level</em>, <em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.log" title="정의 주소">¶</a></dt>
<dd><p>루트 로거에 수준 <em>level</em> 의 메시지를 로그 합니다. 다른 인자는 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>처럼 해석됩니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">위의 루트 로거에 위임하는 모듈 수준 편의 함수는 적어도 하나의 처리기를 사용할 수 있도록 <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">basicConfig()</span></code></a>를 호출합니다. 이 때문에, 스레드가 시작되기 <em>전에</em> 적어도 하나의 처리기가 루트 로거에 추가되지 않는 한, 2.7.1 및 3.2 이전의 파이썬 버전에서는 스레드에서 이 함수들을 사용하지 <em>않아야</em> 합니다. 이전 버전의 파이썬에서는, <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">basicConfig()</span></code></a> 의 스레드 안전성 결함으로 인해 (드물긴 하지만) 처리기가 루트 로거에 여러 번 추가될 수 있으며, 같은 이벤트가 여러 번 기록되는 것으로 이어질 수 있습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.disable">
<code class="descclassname">logging.</code><code class="descname">disable</code><span class="sig-paren">(</span><em>lvl=CRITICAL</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.disable" title="정의 주소">¶</a></dt>
<dd><p>모든 로거의 수준을 <em>lvl</em> 로 오버라이드합니다. 로거 자체 수준보다 우선합니다. 전체 응용 프로그램에서 로깅 출력을 일시적으로 억제해야 할 필요가 생길 때 이 함수가 유용합니다. 그 효과는 심각도 <em>lvl</em> 및 그 밑의 모든 로깅 호출을 무효화시킵니다. 따라서 INFO 값으로 호출하면 모든 INFO 및 DEBUG 이벤트는 삭제되지만, WARNING 이상의 심각도는 로거의 유효 수준에 따라 처리됩니다. <code class="docutils literal notranslate"><span class="pre">logging.disable(logging.NOTSET)</span></code> 이 호출되면, 이 오버라이딩 수준을 실질적으로 제거하므로, 로깅 출력은 다시 개별 로거의 유효 수준에 따르게 됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">CRITICAL</span></code> 보다 더 높은 사용자 정의 로깅 수준을 정의했다면 (권장하지 않습니다), <em>lvl</em> 매개 변수의 기본값에 의존할 수 없고 적절한 값을 명시적으로 제공해야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>lvl</em> 매개 변수의 기본값은 수준 <code class="docutils literal notranslate"><span class="pre">CRITICAL</span></code> 입니다. 이 변경 사항에 대한 자세한 내용은 이슈 #28524를 참조하십시오.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p class="last">이전 버전에서는 기본값이 없었습니다.</p>
</div>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.addLevelName">
<code class="descclassname">logging.</code><code class="descname">addLevelName</code><span class="sig-paren">(</span><em>lvl</em>, <em>levelName</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.addLevelName" title="정의 주소">¶</a></dt>
<dd><p>내부 딕셔너리에 수준 <em>lvl</em> 을 텍스트 <em>levelName</em> 과 연결합니다. 이 딕셔너리는 숫자 수준을 텍스트 표현으로 매핑하는데 (예를 들어, <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 가 메시지를 포매팅할 때) 사용됩니다. 이 기능을 사용해서 여러분 자신의 수준을 정의할 수도 있습니다. 제약 조건은, 사용되는 모든 수준이 이 함수를 사용하여 등록되어야 하고, 수준은 양의 정수이어야 하며, 심각도가 높아질수록 값이 커져야 한다는 것입니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">자신만의 수준을 정의할 생각이라면 <a class="reference internal" href="../howto/logging.html#custom-levels"><span class="std std-ref">사용자 정의 수준</span></a> 섹션을 보십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.getLevelName">
<code class="descclassname">logging.</code><code class="descname">getLevelName</code><span class="sig-paren">(</span><em>lvl</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLevelName" title="정의 주소">¶</a></dt>
<dd><p>로깅 수준 <em>lvl</em> 의 텍스트 표현을 반환합니다. 수준이 미리 정의된 수준 <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code> 또는 <code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code> 중 하나면 해당 문자열을 얻게 됩니다. <a class="reference internal" href="#logging.addLevelName" title="logging.addLevelName"><code class="xref py py-func docutils literal notranslate"><span class="pre">addLevelName()</span></code></a>을 사용하여 수준과 이름을 연관 지었다면, <em>lvl</em> 과 연결된 이름이 반환됩니다. 정의된 수준 중 하나에 해당하는 숫자 값이 전달되면, 해당 문자열 표현이 반환됩니다. 그렇지 않으면 문자열 'Level %s' % lvl 이 반환됩니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">수준은 (로깅 로직에서 비교해야 하므로) 내부적으로 정수입니다. 이 함수는 장수 수준과 <code class="docutils literal notranslate"><span class="pre">%(levelname)s</span></code> 포맷 지정자(<a class="reference internal" href="#logrecord-attributes"><span class="std std-ref">LogRecord 어트리뷰트</span></a>를 보세요)로 포맷된 로그 출력에 표시된 이름 간의 변환에 사용됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>3.4 이전의 파이썬 버전에서, 이 함수로 텍스트 수준을 전달할 수 있고, 해당 수준의 숫자 값을 반환합니다. 이 문서로 만들어지지 않은 동작은 실수로 간주하여, 파이썬 3.4에서 제거되었습니다. 하지만 이전 버전과의 호환성을 유지하기 위해 3.4.2에서 복원되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.makeLogRecord">
<code class="descclassname">logging.</code><code class="descname">makeLogRecord</code><span class="sig-paren">(</span><em>attrdict</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.makeLogRecord" title="정의 주소">¶</a></dt>
<dd><p>어트리뷰트가 <em>attrdict</em> 로 정의된 새로운 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 인스턴스를 만들어서 반환합니다. 이 함수는 피클 된 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 어트리뷰트 딕셔너리를 소켓으로 보내고, 수신 단에서 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 인스턴스로 재구성할 때 유용합니다.</p>
</dd></dl>

<dl class="function">
<dt id="logging.basicConfig">
<code class="descclassname">logging.</code><code class="descname">basicConfig</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.basicConfig" title="정의 주소">¶</a></dt>
<dd><p>기본 <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a>로 <a class="reference internal" href="logging.handlers.html#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a> 를 생성하고 루트 로거에 추가하여 로깅 시스템의 기본 구성을 수행합니다. 함수 <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.info" title="logging.info"><code class="xref py py-func docutils literal notranslate"><span class="pre">info()</span></code></a>, <a class="reference internal" href="#logging.warning" title="logging.warning"><code class="xref py py-func docutils literal notranslate"><span class="pre">warning()</span></code></a>, <a class="reference internal" href="#logging.error" title="logging.error"><code class="xref py py-func docutils literal notranslate"><span class="pre">error()</span></code></a> 그리고 <a class="reference internal" href="#logging.critical" title="logging.critical"><code class="xref py py-func docutils literal notranslate"><span class="pre">critical()</span></code></a>은 루트 로거에 처리기가 정의되어 있지 않으면 자동으로 <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">basicConfig()</span></code></a>를 호출합니다.</p>
<p>이 함수는 루트 로거에 이미 처리기가 구성되어있는 경우 아무 작업도 수행하지 않습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 함수는 다른 스레드가 시작되기 전에 메인 스레드에서 호출되어야 합니다. 2.7.1과 3.2 이전의 파이썬 버전에서, 이 함수를 여러 스레드에서 호출하면, (드문 경우지만) 처리기가 두 번 이상 루트 로거에 추가되어, 로그에 메시지가 중복되는 것과 같은 예기치 않은 결과가 발생할 수 있습니다.</p>
</div>
<p>다음 키워드 인자가 지원됩니다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">포맷</th>
<th class="head">설명</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>filename</em></td>
<td>StreamHandler 대신 지정된 파일명을 사용해 FileHandler를 만들도록 지정합니다.</td>
</tr>
<tr class="row-odd"><td><em>filemode</em></td>
<td><em>filename</em> 이 지정되었으면, 이 <a class="reference internal" href="functions.html#filemodes"><span class="std std-ref">모드</span></a> 로 파일을 엽니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 입니다.</td>
</tr>
<tr class="row-even"><td><em>format</em></td>
<td>처리기에 지정된 포맷 문자열을 사용합니다.</td>
</tr>
<tr class="row-odd"><td><em>datefmt</em></td>
<td><a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strftime()</span></code></a> 에서 허용하는 방식대로 지정된 날짜/시간 포맷을 사용합니다.</td>
</tr>
<tr class="row-even"><td><em>style</em></td>
<td><em>format</em> 을 지정하면, 포맷 문자열에 이 스타일을 사용합니다. <code class="docutils literal notranslate"><span class="pre">'%'</span></code>, <code class="docutils literal notranslate"><span class="pre">'{'</span></code>, <code class="docutils literal notranslate"><span class="pre">'$'</span></code> 중 하나인데 각각 <a class="reference internal" href="stdtypes.html#old-string-formatting"><span class="std std-ref">printf 스타일</span></a>, <a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a>, <a class="reference internal" href="string.html#string.Template" title="string.Template"><code class="xref py py-class docutils literal notranslate"><span class="pre">string.Template</span></code></a> 에 대응됩니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">'%'</span></code> 입니다.</td>
</tr>
<tr class="row-odd"><td><em>level</em></td>
<td>루트 로거의 수준을 지정된 <a class="reference internal" href="#levels"><span class="std std-ref">수준</span></a> 으로 설정합니다.</td>
</tr>
<tr class="row-even"><td><em>stream</em></td>
<td>StreamHandler의 초기화에 지정된 스트림을 사용합니다. 이 인자는 <em>filename</em> 과 호환되지 않습니다 - 둘 다 있으면 <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> 가 발생합니다.</td>
</tr>
<tr class="row-odd"><td><em>handlers</em></td>
<td>지정된 경우, 루트 로거에 추가할 이미 만들어진 처리기의 이터러블이어야 합니다. 아직 포매터 세트가 없는 처리기에는 이 함수에서 만들어진 기본 포매터가 지정됩니다. 이 인자는 <em>filename</em> 또는 <em>stream</em> 과 호환되지 않습니다 - 둘 다 있으면 <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> 가 발생합니다.</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><em>style</em> 인자가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><em>handlers</em> 인자가 추가되었습니다. 호환되지 않는 인자(예를 들어, <em>handlers</em> 를 <em>stream</em> 이나 <em>filename</em> 과 함께 쓰거나, <em>stream</em> 을 <em>filename</em> 과 함께 쓰는 경우)가 있는 상황을 파악하기 위한 검사가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.shutdown">
<code class="descclassname">logging.</code><code class="descname">shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.shutdown" title="정의 주소">¶</a></dt>
<dd><p>로깅 시스템에 모든 처리기를 플러시하고 닫아서 순차적인 종료를 수행하도록 알립니다. 응용 프로그램 종료 시 호출되어야 하고, 이 호출 후에는 로깅 시스템을 더는 사용하지 않아야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="logging.setLoggerClass">
<code class="descclassname">logging.</code><code class="descname">setLoggerClass</code><span class="sig-paren">(</span><em>klass</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.setLoggerClass" title="정의 주소">¶</a></dt>
<dd><p>로거의 인스턴스를 만들 때 <em>klass</em> 클래스를 사용하도록 로깅 시스템에 지시합니다. 클래스는 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 을 정의해야 하는데, name만 필수 인자로 요구하고, <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Logger.__init__()</span></code> 을 호출해야 합니다. 이 함수는 일반적으로 사용자 정의된 로거 동작이 필요한 응용 프로그램에서 로거의 인스턴스가 만들어지기 전에 호출됩니다.</p>
<div class="admonition-flowdas admonition">
<p class="first admonition-title">flowdas</p>
<p>이 문서에 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Logger.__init__()</span></code> 의 서명이 나오지는 않지만, 이런식으로 하면됩니다:</p>
<div class="last highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyLogger</span><span class="p">(</span><span class="n">Logger</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.setLogRecordFactory">
<code class="descclassname">logging.</code><code class="descname">setLogRecordFactory</code><span class="sig-paren">(</span><em>factory</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.setLogRecordFactory" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 를 만드는데 사용되는 콜러블을 설정합니다.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">매개 변수:</th><td class="field-body"><strong>factory</strong> -- 로그 레코드의 인스턴스를 만드는데 사용되는 팩토리 콜러블.</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span>이 함수는 <a class="reference internal" href="#logging.getLogRecordFactory" title="logging.getLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">getLogRecordFactory()</span></code></a>와 함께 제공되어, 개발자가 로깅 이벤트를 나타내는 <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 가 만들어지는 방법을 더욱 잘 제어 할 수 있도록 합니다.</p>
</div>
<p>팩토리의 서명은 다음과 같습니다:</p>
<p><code class="docutils literal notranslate"><span class="pre">factory(name,</span> <span class="pre">level,</span> <span class="pre">fn,</span> <span class="pre">lno,</span> <span class="pre">msg,</span> <span class="pre">args,</span> <span class="pre">exc_info,</span> <span class="pre">func=None,</span> <span class="pre">sinfo=None,</span> <span class="pre">**kwargs)</span></code></p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">name:</th><td class="field-body">로거 이름.</td>
</tr>
<tr class="field-even field"><th class="field-name">level:</th><td class="field-body">로깅 수준 (숫자).</td>
</tr>
<tr class="field-odd field"><th class="field-name">fn:</th><td class="field-body">로깅 호출이 이루어진 파일의 전체 경로명.</td>
</tr>
<tr class="field-even field"><th class="field-name">lno:</th><td class="field-body">로깅 호출이 이루어진 파일의 행 번호.</td>
</tr>
<tr class="field-odd field"><th class="field-name">msg:</th><td class="field-body">로깅 메시지</td>
</tr>
<tr class="field-even field"><th class="field-name">args:</th><td class="field-body">로깅 메시지에 대한 인자.</td>
</tr>
<tr class="field-odd field"><th class="field-name">exc_info:</th><td class="field-body">예외 튜플 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">func:</th><td class="field-body">로깅 호출을 호출한 함수 또는 메서드의 이름</td>
</tr>
<tr class="field-odd field"><th class="field-name">sinfo:</th><td class="field-body"><a class="reference internal" href="traceback.html#traceback.print_stack" title="traceback.print_stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.print_stack()</span></code></a> 가 제공하는 것과 같은 스택 트레이스백. 호출 계층 구조를 보여줍니다.</td>
</tr>
<tr class="field-even field"><th class="field-name">kwargs:</th><td class="field-body">추가 키워드 인자.</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-level-attributes">
<h2>모듈 수준 어트리뷰트<a class="headerlink" href="#module-level-attributes" title="제목 주소">¶</a></h2>
<dl class="attribute">
<dt id="logging.lastResort">
<code class="descclassname">logging.</code><code class="descname">lastResort</code><a class="headerlink" href="#logging.lastResort" title="정의 주소">¶</a></dt>
<dd><p>&quot;최후 수단 처리기&quot; 는 이 어트리뷰트를 통해 제공됩니다. 이것은 <code class="docutils literal notranslate"><span class="pre">WARNING</span></code> 수준으로 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> 에 쓰는 <a class="reference internal" href="logging.handlers.html#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a> 이고, 로깅 구성이 없을 때 로깅 이벤트를 처리하는 데 사용됩니다. 최종 결과는 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> 에 메시지를 출력하기만 하는 것입니다. 이것이 예전의 &quot;no handlers could be found for logger XYZ&quot; 라는 에러 메시지를 대체합니다. 어떤 이유로 이전 동작이 필요하면 <code class="docutils literal notranslate"><span class="pre">lastResort</span></code> 를 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="integration-with-the-warnings-module">
<h2>warnings 모듈과의 통합<a class="headerlink" href="#integration-with-the-warnings-module" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#logging.captureWarnings" title="logging.captureWarnings"><code class="xref py py-func docutils literal notranslate"><span class="pre">captureWarnings()</span></code></a> 함수는 <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a>을 <a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> 모듈과 통합하는데 사용될 수 있습니다.</p>
<dl class="function">
<dt id="logging.captureWarnings">
<code class="descclassname">logging.</code><code class="descname">captureWarnings</code><span class="sig-paren">(</span><em>capture</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.captureWarnings" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 logging 이 경고를 캡처하는 것을 켜고 끄는 데 사용됩니다.</p>
<p><em>capture</em> 가 <code class="docutils literal notranslate"><span class="pre">True</span></code> 면, <a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> 모듈에 의해 발행된 경고는 로깅 시스템으로 리디렉션됩니다. 특히, 경고는 <a class="reference internal" href="warnings.html#warnings.formatwarning" title="warnings.formatwarning"><code class="xref py py-func docutils literal notranslate"><span class="pre">warnings.formatwarning()</span></code></a> 을 사용하여 포맷되고, 결과 문자열을 <code class="docutils literal notranslate"><span class="pre">'py.warnings'</span></code> 라는 이름의 로거에 심각도 <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code>으로 로그 합니다.</p>
<p><em>capture</em> 가 <code class="docutils literal notranslate"><span class="pre">False</span></code> 면, 로깅 시스템으로의 경고 리디렉션은 멈추고, 경고는 원래 목적지(즉, <code class="docutils literal notranslate"><span class="pre">captureWarnings(True)</span></code> 가 호출되기 전에 적용되던 곳)로 리디렉션됩니다.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<dl class="last docutils">
<dt>모듈 <a class="reference internal" href="logging.config.html#module-logging.config" title="logging.config: Configuration of the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code></a></dt>
<dd>logging 모듈용 구성 API.</dd>
<dt>모듈 <a class="reference internal" href="logging.handlers.html#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a></dt>
<dd>logging 모듈에 포함된 유용한 처리기.</dd>
<dt><span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0282"><strong>PEP 282</strong></a> - 로깅 시스템</dt>
<dd>파이썬 표준 라이브러리에 포함하기 위해 이 기능을 설명한 제안.</dd>
<dt><a class="reference external" href="https://www.red-dove.com/python_logging.html">원본 파이썬 로깅 패키지</a></dt>
<dd><a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 패키지의 원래 소스입니다. 이 사이트에서 제공되는 패키지 버전은 표준 라이브러리에 <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 패키지를 포함하지 않는 파이썬 1.5.2, 2.1.x 및 2.2.x에서 사용하기에 적합합니다.</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">logging</span></code> --- 파이썬 로깅 시설</a><ul>
<li><a class="reference internal" href="#logger-objects">Logger 객체</a></li>
<li><a class="reference internal" href="#logging-levels">로깅 수준</a></li>
<li><a class="reference internal" href="#handler-objects">Handler 객체</a></li>
<li><a class="reference internal" href="#formatter-objects">Formatter 객체</a></li>
<li><a class="reference internal" href="#filter-objects">Filter 객체</a></li>
<li><a class="reference internal" href="#logrecord-objects">LogRecord 객체</a></li>
<li><a class="reference internal" href="#logrecord-attributes">LogRecord 어트리뷰트</a></li>
<li><a class="reference internal" href="#loggeradapter-objects">LoggerAdapter 객체</a></li>
<li><a class="reference internal" href="#thread-safety">스레드 안전성</a></li>
<li><a class="reference internal" href="#module-level-functions">모듈 수준 함수</a></li>
<li><a class="reference internal" href="#module-level-attributes">모듈 수준 어트리뷰트</a></li>
<li><a class="reference internal" href="#integration-with-the-warnings-module">warnings 모듈과의 통합</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="getopt.html"
                        title="이전 장"><code class="docutils literal notranslate"><span class="pre">getopt</span></code> --- C-style parser for command line options</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="logging.config.html"
                        title="다음 장"><code class="docutils literal notranslate"><span class="pre">logging.config</span></code> --- Logging configuration</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="logging.config.html" title="logging.config --- Logging configuration"
             >다음</a> |</li>
        <li class="right" >
          <a href="getopt.html" title="getopt --- C-style parser for command line options"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >일반 운영 체제 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1 를 사용해서 만들었습니다.
    </div>

  </body>
</html>