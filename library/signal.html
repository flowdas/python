
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>signal --- 비동기 이벤트에 대한 처리기 설정 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="mmap --- 메모리 맵 파일 지원" href="mmap.html" />
    <link rel="prev" title="asynchat --- Asynchronous socket command/response handler" href="asynchat.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/signal.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="mmap.html" title="mmap --- 메모리 맵 파일 지원"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="asynchat.html" title="asynchat --- Asynchronous socket command/response handler"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" accesskey="U">네트워킹과 프로세스 간 통신</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-signal">
<span id="signal-set-handlers-for-asynchronous-events"></span><h1><a class="reference internal" href="#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> --- 비동기 이벤트에 대한 처리기 설정<a class="headerlink" href="#module-signal" title="제목 주소">¶</a></h1>
<hr class="docutils" />
<p>이 모듈은 파이썬에서 시그널 처리기를 사용하는 메커니즘을 제공합니다.</p>
<div class="section" id="general-rules">
<h2>일반 규칙<a class="headerlink" href="#general-rules" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a> 함수는 시그널이 수신될 때 실행될 사용자 정의 처리기를 정의하도록 합니다. 소수의 기본 처리기가 설치됩니다: <a class="reference internal" href="#signal.SIGPIPE" title="signal.SIGPIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGPIPE</span></code></a>는 무시되고 (그래서 파이프와 소켓에 대한 쓰기 에러는 일반 파이썬 예외로 보고될 수 있습니다) <a class="reference internal" href="#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGINT</span></code></a>는 부모 프로세스가 변경하지 않았다면 <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 예외로 번역됩니다.</p>
<p>일단 설정되면, 특정 시그널에 대한 처리기는 명시적으로 재설정 될 때까지 (파이썬은 하부 구현과 관계없이 BSD 스타일 인터페이스를 흉내 냅니다) 설치된 상태로 유지됩니다. <a class="reference internal" href="#signal.SIGCHLD" title="signal.SIGCHLD"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGCHLD</span></code></a>에 대한 처리기는 예외인데, 하부 구현을 따릅니다.</p>
<div class="section" id="execution-of-python-signal-handlers">
<h3>파이썬 시그널 처리기의 실행<a class="headerlink" href="#execution-of-python-signal-handlers" title="제목 주소">¶</a></h3>
<p>파이썬 시그널 처리기는 저수준 (C) 시그널 처리기 내에서 실행되지 않습니다. 대신, 저수준 시그널 처리기는 <a class="reference internal" href="../glossary.html#term-virtual-machine"><span class="xref std std-term">가상 기계</span></a>에게 나중에 (예를 들어 다음 <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">바이트 코드</span></a> 명령에서) 해당 파이썬 시그널 처리기를 실행하도록 지시하는 플래그를 설정합니다. 결과는 다음과 같습니다:</p>
<ul class="simple">
<li><p>C 코드에서의 유효하지 않은 연산으로 인해 발생하는 <a class="reference internal" href="#signal.SIGFPE" title="signal.SIGFPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGFPE</span></code></a>나 <a class="reference internal" href="#signal.SIGSEGV" title="signal.SIGSEGV"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGSEGV</span></code></a>와 같은 동기 에러를 잡는 것은 그리 의미가 없습니다. 파이썬은 시그널 처리기에서 C 코드로 돌아오는데, 같은 시그널을 다시 발생시켜서, 파이썬이 멈출 것입니다. 파이썬 3.3부터는, <a class="reference internal" href="faulthandler.html#module-faulthandler" title="faulthandler: Dump the Python traceback."><code class="xref py py-mod docutils literal notranslate"><span class="pre">faulthandler</span></code></a> 모듈을 사용하여 동기 에러를 보고할 수 있습니다.</p></li>
<li><p>C로만 구현된 오래 실행되는 계산(가령 커다란 텍스트 본문에 대한 정규식 일치)은 수신된 시그널에 상관없이 임의의 시간 동안 중단없이 실행될 수 있습니다. 계산이 끝나면 파이썬 시그널 처리기가 호출됩니다.</p></li>
</ul>
</div>
<div class="section" id="signals-and-threads">
<span id="id1"></span><h3>시그널과 스레드<a class="headerlink" href="#signals-and-threads" title="제목 주소">¶</a></h3>
<p>파이썬 시그널 처리기는 시그널이 다른 스레드에서 수신될 때도 항상 메인 인터프리터의 메인 파이썬 스레드에서 실행됩니다. 이는 시그널을 스레드 간 통신 수단으로 사용할 수 없음을 의미합니다. 대신 <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 모듈의 동기화 프리미티브를 사용할 수 있습니다.</p>
<p>게다가, 메인 인터프리터의 메인 스레드만 새로운 시그널 처리기를 설정할 수 있습니다.</p>
</div>
</div>
<div class="section" id="module-contents">
<h2>모듈 내용<a class="headerlink" href="#module-contents" title="제목 주소">¶</a></h2>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이하에 열거된 시그널 (SIG*), 처리기 (<a class="reference internal" href="#signal.SIG_DFL" title="signal.SIG_DFL"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIG_DFL</span></code></a>, <a class="reference internal" href="#signal.SIG_IGN" title="signal.SIG_IGN"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIG_IGN</span></code></a>) 및 sigmask (<a class="reference internal" href="#signal.SIG_BLOCK" title="signal.SIG_BLOCK"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIG_BLOCK</span></code></a>, <a class="reference internal" href="#signal.SIG_UNBLOCK" title="signal.SIG_UNBLOCK"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIG_UNBLOCK</span></code></a>, <a class="reference internal" href="#signal.SIG_SETMASK" title="signal.SIG_SETMASK"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIG_SETMASK</span></code></a>) 관련 상수는 <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">열거형</span></code></a>으로 바뀌었습니다. <a class="reference internal" href="#signal.getsignal" title="signal.getsignal"><code class="xref py py-func docutils literal notranslate"><span class="pre">getsignal()</span></code></a>, <a class="reference internal" href="#signal.pthread_sigmask" title="signal.pthread_sigmask"><code class="xref py py-func docutils literal notranslate"><span class="pre">pthread_sigmask()</span></code></a>, <a class="reference internal" href="#signal.sigpending" title="signal.sigpending"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigpending()</span></code></a> 및 <a class="reference internal" href="#signal.sigwait" title="signal.sigwait"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigwait()</span></code></a> 함수는 사람이 읽을 수 있는 <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">열거형</span></code></a>을 반환합니다.</p>
</div>
<p><a class="reference internal" href="#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 모듈에 정의된 변수는 다음과 같습니다:</p>
<dl class="data">
<dt id="signal.SIG_DFL">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIG_DFL</code><a class="headerlink" href="#signal.SIG_DFL" title="정의 주소">¶</a></dt>
<dd><p>이것은 두 가지 표준 시그널 처리 옵션 중 하나입니다; 단순히 시그널의 기본 기능을 수행합니다. 예를 들어, 대부분의 시스템에서 <code class="xref py py-const docutils literal notranslate"><span class="pre">SIGQUIT</span></code>의 기본 동작은 코어를 덤프하고 종료하는 것이지만, <a class="reference internal" href="#signal.SIGCHLD" title="signal.SIGCHLD"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGCHLD</span></code></a>의 기본 동작은 단순히 무시하는 것입니다.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIG_IGN">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIG_IGN</code><a class="headerlink" href="#signal.SIG_IGN" title="정의 주소">¶</a></dt>
<dd><p>이것은 주어진 시그널을 무시하는 또 다른 표준 시그널 처리기입니다.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGABRT">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGABRT</code><a class="headerlink" href="#signal.SIGABRT" title="정의 주소">¶</a></dt>
<dd><p><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/abort(3)">abort(3)</a></em>로 부터의 중단 시그널.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGALRM">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGALRM</code><a class="headerlink" href="#signal.SIGALRM" title="정의 주소">¶</a></dt>
<dd><p><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/alarm(2)">alarm(2)</a></em>로 부터의 타이머 시그널.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGBREAK">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGBREAK</code><a class="headerlink" href="#signal.SIGBREAK" title="정의 주소">¶</a></dt>
<dd><p>키보드 인터럽트 (CTRL + BREAK).</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 윈도우.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGBUS">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGBUS</code><a class="headerlink" href="#signal.SIGBUS" title="정의 주소">¶</a></dt>
<dd><p>버스 에러 (메모리 액세스 불량).</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGCHLD">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGCHLD</code><a class="headerlink" href="#signal.SIGCHLD" title="정의 주소">¶</a></dt>
<dd><p>자식 프로세스가 중지되었거나 종료되었습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGCLD">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGCLD</code><a class="headerlink" href="#signal.SIGCLD" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#signal.SIGCHLD" title="signal.SIGCHLD"><code class="xref py py-data docutils literal notranslate"><span class="pre">SIGCHLD</span></code></a>에 대한 별칭.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGCONT">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGCONT</code><a class="headerlink" href="#signal.SIGCONT" title="정의 주소">¶</a></dt>
<dd><p>현재 중지되었으면 프로세스를 재개합니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGFPE">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGFPE</code><a class="headerlink" href="#signal.SIGFPE" title="정의 주소">¶</a></dt>
<dd><p>부동 소수점 예외. 예를 들어, 0으로 나누기.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p>나누기나 모듈로 연산의 두 번째 인자가 0이면 <a class="reference internal" href="exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a>가 발생합니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="signal.SIGHUP">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGHUP</code><a class="headerlink" href="#signal.SIGHUP" title="정의 주소">¶</a></dt>
<dd><p>제어 터미널이 끊어졌거나 제어 프로세스가 죽었습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGILL">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGILL</code><a class="headerlink" href="#signal.SIGILL" title="정의 주소">¶</a></dt>
<dd><p>잘못된 명령어.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGINT">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGINT</code><a class="headerlink" href="#signal.SIGINT" title="정의 주소">¶</a></dt>
<dd><p>키보드 인터럽트 (CTRL + C).</p>
<p>기본 액션은 <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>를 발생시키는 것입니다.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGKILL">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGKILL</code><a class="headerlink" href="#signal.SIGKILL" title="정의 주소">¶</a></dt>
<dd><p>킬 시그널.</p>
<p>잡거나, 차단하거나, 무시할 수 없습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGPIPE">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGPIPE</code><a class="headerlink" href="#signal.SIGPIPE" title="정의 주소">¶</a></dt>
<dd><p>끊어진 파이프: 판독기가 없는 파이프에 쓰기.</p>
<p>기본 동작은 시그널을 무시하는 것입니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGSEGV">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGSEGV</code><a class="headerlink" href="#signal.SIGSEGV" title="정의 주소">¶</a></dt>
<dd><p>세그먼테이션 오류: 유효하지 않은 메모리 참조.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGTERM">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGTERM</code><a class="headerlink" href="#signal.SIGTERM" title="정의 주소">¶</a></dt>
<dd><p>종료 시그널.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGUSR1">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGUSR1</code><a class="headerlink" href="#signal.SIGUSR1" title="정의 주소">¶</a></dt>
<dd><p>사용자 정의 시그널 1.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGUSR2">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGUSR2</code><a class="headerlink" href="#signal.SIGUSR2" title="정의 주소">¶</a></dt>
<dd><p>사용자 정의 시그널 2.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIGWINCH">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIGWINCH</code><a class="headerlink" href="#signal.SIGWINCH" title="정의 주소">¶</a></dt>
<dd><p>창 크기 조정 시그널.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</dd></dl>

<dl class="data">
<dt>
<code class="sig-name descname">SIG*</code></dt>
<dd><p>모든 시그널 번호는 기호적으로 정의됩니다. 예를 들어, 행업(hangup) 시그널은 <a class="reference internal" href="#signal.SIGHUP" title="signal.SIGHUP"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGHUP</span></code></a>으로 정의됩니다; 변수 이름은 <code class="docutils literal notranslate"><span class="pre">&lt;signal.h&gt;</span></code>에 있는 C 프로그램에서 사용되는 이름과 동일합니다. '<code class="xref c c-func docutils literal notranslate"><span class="pre">signal()</span></code>'에 대한 유닉스 매뉴얼 페이지는 존재하는 시그널을 나열합니다 (일부 시스템에서는 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/signal(2)">signal(2)</a></em>이고, 다른 시스템에서는 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/signal(7)">signal(7)</a></em>입니다). 모든 시스템이 같은 시그널 이름 집합을 정의하는 것은 아님에 유의하십시오; 시스템에서 정의한 이름만 이 모듈에서 정의합니다.</p>
</dd></dl>

<dl class="data">
<dt id="signal.CTRL_C_EVENT">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">CTRL_C_EVENT</code><a class="headerlink" href="#signal.CTRL_C_EVENT" title="정의 주소">¶</a></dt>
<dd><p><kbd class="kbd docutils literal notranslate">Ctrl+C</kbd> 키 입력 이벤트에 해당하는 시그널. 이 시그널은 <a class="reference internal" href="os.html#os.kill" title="os.kill"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.kill()</span></code></a>에서만 사용할 수 있습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 윈도우.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="signal.CTRL_BREAK_EVENT">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">CTRL_BREAK_EVENT</code><a class="headerlink" href="#signal.CTRL_BREAK_EVENT" title="정의 주소">¶</a></dt>
<dd><p><kbd class="kbd docutils literal notranslate">Ctrl+Break</kbd> 키 입력 이벤트에 해당하는 시그널. 이 시그널은 <a class="reference internal" href="os.html#os.kill" title="os.kill"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.kill()</span></code></a>에서만 사용할 수 있습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 윈도우.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="signal.NSIG">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">NSIG</code><a class="headerlink" href="#signal.NSIG" title="정의 주소">¶</a></dt>
<dd><p>가장 높은 시그널 번호보다 하나 큰 값.</p>
</dd></dl>

<dl class="data">
<dt id="signal.ITIMER_REAL">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">ITIMER_REAL</code><a class="headerlink" href="#signal.ITIMER_REAL" title="정의 주소">¶</a></dt>
<dd><p>간격 타이머(interval timer)를 실시간으로 감소시키고, 만료 시 <a class="reference internal" href="#signal.SIGALRM" title="signal.SIGALRM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGALRM</span></code></a>을 전달합니다.</p>
</dd></dl>

<dl class="data">
<dt id="signal.ITIMER_VIRTUAL">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">ITIMER_VIRTUAL</code><a class="headerlink" href="#signal.ITIMER_VIRTUAL" title="정의 주소">¶</a></dt>
<dd><p>프로세스가 실행 중일 때만 간격 타이머(interval timer)를 감소시키고, 만료 시 SIGVTALRM을 전달합니다.</p>
</dd></dl>

<dl class="data">
<dt id="signal.ITIMER_PROF">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">ITIMER_PROF</code><a class="headerlink" href="#signal.ITIMER_PROF" title="정의 주소">¶</a></dt>
<dd><p>프로세스가 실행될 때와 시스템이 프로세스를 대신하여 실행될 때 간격 타이머(interval timer)를 감소시킵니다. ITIMER_VIRTUAL과 함께 사용되어, 이 타이머는 일반적으로 사용자와 커널 공간에서 응용 프로그램이 소비한 시간을 프로파일링하는 데 사용됩니다. 만료 시 SIGPROF를 전달합니다.</p>
</dd></dl>

<dl class="data">
<dt id="signal.SIG_BLOCK">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIG_BLOCK</code><a class="headerlink" href="#signal.SIG_BLOCK" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#signal.pthread_sigmask" title="signal.pthread_sigmask"><code class="xref py py-func docutils literal notranslate"><span class="pre">pthread_sigmask()</span></code></a>의 <em>how</em> 매개 변수에 가능한 값으로 시그널이 차단됨을 나타냅니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="signal.SIG_UNBLOCK">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIG_UNBLOCK</code><a class="headerlink" href="#signal.SIG_UNBLOCK" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#signal.pthread_sigmask" title="signal.pthread_sigmask"><code class="xref py py-func docutils literal notranslate"><span class="pre">pthread_sigmask()</span></code></a>의 <em>how</em> 매개 변수에 가능한 값으로 시그널이 차단 해제됨을 나타냅니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="signal.SIG_SETMASK">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">SIG_SETMASK</code><a class="headerlink" href="#signal.SIG_SETMASK" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#signal.pthread_sigmask" title="signal.pthread_sigmask"><code class="xref py py-func docutils literal notranslate"><span class="pre">pthread_sigmask()</span></code></a>의 <em>how</em> 매개 변수에 가능한 값으로 시그널 마스크가 교체됨을 나타냅니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<p><a class="reference internal" href="#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 모듈은 하나의 예외를 정의합니다:</p>
<dl class="exception">
<dt id="signal.ItimerError">
<em class="property">exception </em><code class="sig-prename descclassname">signal.</code><code class="sig-name descname">ItimerError</code><a class="headerlink" href="#signal.ItimerError" title="정의 주소">¶</a></dt>
<dd><p>하부 <a class="reference internal" href="#signal.setitimer" title="signal.setitimer"><code class="xref py py-func docutils literal notranslate"><span class="pre">setitimer()</span></code></a>나 <a class="reference internal" href="#signal.getitimer" title="signal.getitimer"><code class="xref py py-func docutils literal notranslate"><span class="pre">getitimer()</span></code></a> 구현으로부터의 에러를 알리기 위해 발생합니다. 유효하지 않은 간격 타이머나 음의 시간이 <a class="reference internal" href="#signal.setitimer" title="signal.setitimer"><code class="xref py py-func docutils literal notranslate"><span class="pre">setitimer()</span></code></a>에 전달되면 이 에러가 예상됩니다. 이 에러는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 서브 형입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가: </span>이 에러는 <a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a>의 서브 형이었습니다, 이제는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 별칭입니다.</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 모듈은 다음 함수를 정의합니다:</p>
<dl class="function">
<dt id="signal.alarm">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">alarm</code><span class="sig-paren">(</span><em class="sig-param">time</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.alarm" title="정의 주소">¶</a></dt>
<dd><p><em>time</em>이 0이 아니면, 이 함수는 <a class="reference internal" href="#signal.SIGALRM" title="signal.SIGALRM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGALRM</span></code></a> 시그널이 <em>time</em> 초 내에 프로세스로 전송되도록 요청합니다. 이전에 예약된 알람은 취소됩니다 (임의의 시간에 오직 하나의 알람만 예약될 수 있습니다). 반환된 값은 이전에 설정된 알람이 전달되기까지 남은 초(seconds)입니다. <em>time</em>이 0이면, 알람이 예약되지 않고, 예약된 알람이 취소됩니다. 반환 값이 0이면, 현재 예약된 알람이 없습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스. 자세한 내용은 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/alarm(2)">alarm(2)</a></em>를 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="signal.getsignal">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">getsignal</code><span class="sig-paren">(</span><em class="sig-param">signalnum</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.getsignal" title="정의 주소">¶</a></dt>
<dd><p>시그널 <em>signalnum</em>에 대한 현재 시그널 처리기를 반환합니다. 반환된 값은 콜러블 파이썬 객체이거나, 특수 값 <a class="reference internal" href="#signal.SIG_IGN" title="signal.SIG_IGN"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIG_IGN</span></code></a>, <a class="reference internal" href="#signal.SIG_DFL" title="signal.SIG_DFL"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIG_DFL</span></code></a> 중 하나이거나 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>일 수 있습니다. 여기서 <a class="reference internal" href="#signal.SIG_IGN" title="signal.SIG_IGN"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIG_IGN</span></code></a>은 시그널이 이전에 무시되었음을 의미하고, <a class="reference internal" href="#signal.SIG_DFL" title="signal.SIG_DFL"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIG_DFL</span></code></a>은 시그널을 처리하는 기본 방법이 이전에 사용 중임을 의미하고, <code class="docutils literal notranslate"><span class="pre">None</span></code>은 이전 시그널 처리기가 파이썬에서 설치되지 않았음을 의미합니다.</p>
</dd></dl>

<dl class="function">
<dt id="signal.strsignal">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">strsignal</code><span class="sig-paren">(</span><em class="sig-param">signalnum</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.strsignal" title="정의 주소">¶</a></dt>
<dd><p>시그널 <em>signalnum</em>의 시스템 설명을 반환합니다, 가령 &quot;Interrupt&quot;, &quot;Segmentation fault&quot;, 등. 시그널이 인식되지 않으면 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="signal.valid_signals">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">valid_signals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#signal.valid_signals" title="정의 주소">¶</a></dt>
<dd><p>이 플랫폼에서 유효한 시그널 번호 집합을 반환합니다. 일부 시그널이 시스템에서 내부 용으로 예약되었으면 <code class="docutils literal notranslate"><span class="pre">range(1,</span> <span class="pre">NSIG)</span></code>보다 작을 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="signal.pause">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">pause</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#signal.pause" title="정의 주소">¶</a></dt>
<dd><p>시그널이 수신될 때까지 프로세스를 휴면 상태로 만듭니다; 그런 다음 적절한 처리기가 호출됩니다. 아무것도 반환하지 않습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스. 자세한 내용은 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/signal(2)">signal(2)</a></em>를 참조하십시오.</p>
<p><a class="reference internal" href="#signal.sigwait" title="signal.sigwait"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigwait()</span></code></a>, <a class="reference internal" href="#signal.sigwaitinfo" title="signal.sigwaitinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigwaitinfo()</span></code></a>, <a class="reference internal" href="#signal.sigtimedwait" title="signal.sigtimedwait"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigtimedwait()</span></code></a> 및 <a class="reference internal" href="#signal.sigpending" title="signal.sigpending"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigpending()</span></code></a>도 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="signal.raise_signal">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">raise_signal</code><span class="sig-paren">(</span><em class="sig-param">signum</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.raise_signal" title="정의 주소">¶</a></dt>
<dd><p>호출하는 프로세스에 시그널을 보냅니다. 아무것도 반환하지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="signal.pidfd_send_signal">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">pidfd_send_signal</code><span class="sig-paren">(</span><em class="sig-param">pidfd</em>, <em class="sig-param">sig</em>, <em class="sig-param">siginfo=None</em>, <em class="sig-param">flags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.pidfd_send_signal" title="정의 주소">¶</a></dt>
<dd><p>파일 기술자 <em>pidfd</em>가 참조하는 프로세스로 시그널 <em>sig</em>를 보냅니다. 파이썬은 현재 <em>siginfo</em> 매개 변수를 지원하지 않습니다; <code class="docutils literal notranslate"><span class="pre">None</span></code>이어야 합니다. <em>flags</em> 인자는 향후 확장을 위해 제공됩니다; 현재는 플래그 값이 정의되어 있지 않습니다.</p>
<p>자세한 내용은 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/pidfd_send_signal(2)">pidfd_send_signal(2)</a></em> 매뉴얼 페이지를 참조하십시오.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 리눅스 5.1+</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="signal.pthread_kill">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">pthread_kill</code><span class="sig-paren">(</span><em class="sig-param">thread_id</em>, <em class="sig-param">signalnum</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.pthread_kill" title="정의 주소">¶</a></dt>
<dd><p>시그널 <em>signalnum</em>을 호출자와 같은 프로세스의 다른 스레드인 스레드 <em>thread_id</em>로 보냅니다. 대상 스레드는 임의의 (파이썬이거나 아닌) 코드를 실행 중일 수 있습니다. 그러나, 대상 스레드가 파이썬 인터프리터를 실행 중이면, 파이썬 시그널 처리기는 <a class="reference internal" href="#signals-and-threads"><span class="std std-ref">메인 인터프리터의 메인 스레드에서 실행</span></a>됩니다. 따라서, 특정 파이썬 스레드에 시그널을 보내는 것의 유일한 용도는 실행 중인 시스템 호출이 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a>로 실패하도록 하는 것입니다.</p>
<p><em>thread_id</em>에 적합한 값을 얻으려면 <a class="reference internal" href="threading.html#threading.get_ident" title="threading.get_ident"><code class="xref py py-func docutils literal notranslate"><span class="pre">threading.get_ident()</span></code></a> 나 <a class="reference internal" href="threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Thread</span></code></a> 객체의 <a class="reference internal" href="threading.html#threading.Thread.ident" title="threading.Thread.ident"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ident</span></code></a> 어트리뷰트를 사용하십시오.</p>
<p><em>signalnum</em>이 0이면, 시그널이 전송되지 않지만, 여전히 에러 검사가 수행됩니다; 대상 스레드가 여전히 실행 중인지 확인하는 데 사용할 수 있습니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">thread_id</span></code>, <code class="docutils literal notranslate"><span class="pre">signalnum</span></code>으로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">signal.pthread_kill</span></code>을 발생시킵니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스. 자세한 내용은 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/pthread_kill(3)">pthread_kill(3)</a></em>을 참조하십시오.</p>
<p><a class="reference internal" href="os.html#os.kill" title="os.kill"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.kill()</span></code></a>도 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="signal.pthread_sigmask">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">pthread_sigmask</code><span class="sig-paren">(</span><em class="sig-param">how</em>, <em class="sig-param">mask</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.pthread_sigmask" title="정의 주소">¶</a></dt>
<dd><p>호출하는 스레드의 시그널 마스크를 가져오거나 변경하거나 가져오면서 변경합니다. 시그널 마스크는 호출자에게 현재 배달이 차단된 시그널 집합입니다. 이전 시그널 마스크를 시그널 집합으로 반환합니다.</p>
<p>호출의 동작은 다음과 같이 <em>how</em> 값에 따라 다릅니다.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#signal.SIG_BLOCK" title="signal.SIG_BLOCK"><code class="xref py py-data docutils literal notranslate"><span class="pre">SIG_BLOCK</span></code></a>: 차단된 시그널 집합은 현재 집합과 <em>mask</em> 인자의 합집합입니다.</p></li>
<li><p><a class="reference internal" href="#signal.SIG_UNBLOCK" title="signal.SIG_UNBLOCK"><code class="xref py py-data docutils literal notranslate"><span class="pre">SIG_UNBLOCK</span></code></a>: <em>mask</em>에 있는 시그널이 차단된 시그널의 현재 집합에서 제거됩니다. 차단되지 않은 시그널을 차단 해제하려고 시도할 수 있습니다.</p></li>
<li><p><a class="reference internal" href="#signal.SIG_SETMASK" title="signal.SIG_SETMASK"><code class="xref py py-data docutils literal notranslate"><span class="pre">SIG_SETMASK</span></code></a>: 차단된 시그널 집합이 <em>mask</em> 인자로 설정됩니다.</p></li>
</ul>
<p><em>mask</em>는 시그널 번호 집합입니다 (예를 들어 {<a class="reference internal" href="#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a>, <a class="reference internal" href="#signal.SIGTERM" title="signal.SIGTERM"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGTERM</span></code></a>}). 모든 시그널을 포함한 전체 마스크를 얻으려면 <a class="reference internal" href="#signal.valid_signals" title="signal.valid_signals"><code class="xref py py-func docutils literal notranslate"><span class="pre">valid_signals()</span></code></a>를 사용하십시오.</p>
<p>예를 들어, <code class="docutils literal notranslate"><span class="pre">signal.pthread_sigmask(signal.SIG_BLOCK,</span> <span class="pre">[])</span></code>은 호출하는 스레드의 시그널 마스크를 읽습니다.</p>
<p><a class="reference internal" href="#signal.SIGKILL" title="signal.SIGKILL"><code class="xref py py-data docutils literal notranslate"><span class="pre">SIGKILL</span></code></a>과 <code class="xref py py-data docutils literal notranslate"><span class="pre">SIGSTOP</span></code>은 차단할 수 없습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스. 자세한 내용은 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/sigprocmask(3)">sigprocmask(3)</a></em>과 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/pthread_sigmask(3)">pthread_sigmask(3)</a></em>을 참조하십시오.</p>
<p><a class="reference internal" href="#signal.pause" title="signal.pause"><code class="xref py py-func docutils literal notranslate"><span class="pre">pause()</span></code></a>, <a class="reference internal" href="#signal.sigpending" title="signal.sigpending"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigpending()</span></code></a> 및 <a class="reference internal" href="#signal.sigwait" title="signal.sigwait"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigwait()</span></code></a>도 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="signal.setitimer">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">setitimer</code><span class="sig-paren">(</span><em class="sig-param">which</em>, <em class="sig-param">seconds</em>, <em class="sig-param">interval=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.setitimer" title="정의 주소">¶</a></dt>
<dd><p><em>seconds</em>(<a class="reference internal" href="#signal.alarm" title="signal.alarm"><code class="xref py py-func docutils literal notranslate"><span class="pre">alarm()</span></code></a>과 달리 float가 허용됩니다) 이후에 그리고 (<em>interval</em>이 0이 아니면) 그 후로 <em>interval</em> 초마다 발사(fire)하도록 <em>which</em>로 지정된 간격 타이머(<a class="reference internal" href="#signal.ITIMER_REAL" title="signal.ITIMER_REAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.ITIMER_REAL</span></code></a>, <a class="reference internal" href="#signal.ITIMER_VIRTUAL" title="signal.ITIMER_VIRTUAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.ITIMER_VIRTUAL</span></code></a> 또는 <a class="reference internal" href="#signal.ITIMER_PROF" title="signal.ITIMER_PROF"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.ITIMER_PROF</span></code></a> 중 하나)를 설정합니다. <em>which</em>로 지정된 간격 타이머는 <em>seconds</em>를 0으로 설정하여 지울 수 있습니다.</p>
<p>간격 타이머가 발사(fire)하면, 시그널이 프로세스로 전송됩니다. 전송된 시그널은 사용 중인 타이머에 따라 다릅니다; <a class="reference internal" href="#signal.ITIMER_REAL" title="signal.ITIMER_REAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.ITIMER_REAL</span></code></a>은 <a class="reference internal" href="#signal.SIGALRM" title="signal.SIGALRM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGALRM</span></code></a>을, <a class="reference internal" href="#signal.ITIMER_VIRTUAL" title="signal.ITIMER_VIRTUAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.ITIMER_VIRTUAL</span></code></a>은 <code class="xref py py-const docutils literal notranslate"><span class="pre">SIGVTALRM</span></code>을, <a class="reference internal" href="#signal.ITIMER_PROF" title="signal.ITIMER_PROF"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.ITIMER_PROF</span></code></a>는 <code class="xref py py-const docutils literal notranslate"><span class="pre">SIGPROF</span></code>를 전달합니다.</p>
<p>이전 값은 튜플로 반환됩니다: (지연, 간격).</p>
<p>유효하지 않은 간격 타이머를 전달하려고 하면 <a class="reference internal" href="#signal.ItimerError" title="signal.ItimerError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ItimerError</span></code></a>가 발생합니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="signal.getitimer">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">getitimer</code><span class="sig-paren">(</span><em class="sig-param">which</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.getitimer" title="정의 주소">¶</a></dt>
<dd><p><em>which</em>로 지정된 주어진 간격 타이머의 현재 값을 반환합니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스.</p>
</dd></dl>

<dl class="function">
<dt id="signal.set_wakeup_fd">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">set_wakeup_fd</code><span class="sig-paren">(</span><em class="sig-param">fd</em>, <em class="sig-param">*</em>, <em class="sig-param">warn_on_full_buffer=True</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.set_wakeup_fd" title="정의 주소">¶</a></dt>
<dd><p>웨이크업 파일 기술자를 <em>fd</em>로 설정합니다. 시그널이 수신되면 시그널 번호는 단일 바이트로 fd에 기록됩니다. 라이브러리에서 poll이나 select 호출을 깨워서, 시그널을 완전히 처리하는 데 사용될 수 있습니다.</p>
<p>이전 웨이크업 fd가 반환됩니다 (또는 파일 기술자 웨이크업이 활성화되지 않았으면 -1). <em>fd</em>가 -1이면, 파일 기술자 웨이크업이 비활성화됩니다. -1이 아니면, <em>fd</em>는 비 블로킹이어야 합니다. poll이나 select를 다시 호출하기 전에 <em>fd</em>에서 바이트를 제거하는 것은 라이브러리의 책임입니다.</p>
<p>스레드가 활성화되었을 때, 이 함수는 <a class="reference internal" href="#signals-and-threads"><span class="std std-ref">메인 인터프리터의 메인 스레드</span></a>에서만 호출할 수 있습니다; 다른 스레드에서 호출하려고 하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 예외가 발생합니다.</p>
<p>이 함수를 사용하는 일반적인 두 가지 방법이 있습니다. 두 방법 모두, 시그널이 도착할 때 깨어나기 위해 fd를 사용하지만, <em>어떤</em> 시그널이나 시그널들이 도착했는지 판단하는 방법이 다릅니다.</p>
<p>첫 번째 방법에서는, fd의 버퍼에서 데이터를 읽고, 바이트 값이 시그널 번호를 제공합니다. 이것은 간단합니다만, 드물게 문제가 될 수 있습니다: 일반적으로 fd에는 제한된 버퍼 공간이 있으며, 너무 많은 시그널이 너무 빨리 도착하면, 버퍼가 가득 차고, 일부 시그널이 손실될 수 있습니다. 이 방법을 사용하면, 시그널이 손실될 때 최소한 stderr에 경고가 인쇄되도록 <code class="docutils literal notranslate"><span class="pre">warn_on_full_buffer=True</span></code>를 설정해야 합니다.</p>
<p>두 번째 방법에서는, 오직 웨이크업만을 위해 웨이크업 fd를 사용하고, 실제 바이트 값은 무시합니다. 이 경우, 우리가 신경 쓰는 것은 fd의 버퍼가 비어 있는지 비어 있지 않은지 입니다; 가득 찬 버퍼는 전혀 문제를 가리키지 않습니다. 이 방법을 사용하면, 사용자가 가짜 경고 메시지로 혼동되지 않도록 <code class="docutils literal notranslate"><span class="pre">warn_on_full_buffer=False</span></code>를 설정해야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>윈도우에서, 이 함수는 이제 소켓 핸들도 지원합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><code class="docutils literal notranslate"><span class="pre">warn_on_full_buffer</span></code> 매개 변수를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="signal.siginterrupt">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">siginterrupt</code><span class="sig-paren">(</span><em class="sig-param">signalnum</em>, <em class="sig-param">flag</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.siginterrupt" title="정의 주소">¶</a></dt>
<dd><p>시스템 호출 재시작 동작을 변경합니다: <em>flag</em>가 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>이면, 시그널 <em>signalnum</em>에 의해 인터럽트 될 때 시스템 호출이 다시 시작되고, 그렇지 않으면 시스템 호출이 중단됩니다. 아무것도 반환하지 않습니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스. 자세한 내용은 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/siginterrupt(3)">siginterrupt(3)</a></em>을 참조하십시오.</p>
<p><a class="reference internal" href="#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-func docutils literal notranslate"><span class="pre">signal()</span></code></a>로 시그널 처리기를 설치하면 주어진 시그널에 대해 <em>flag</em> 값을 참으로 <code class="xref c c-func docutils literal notranslate"><span class="pre">siginterrupt()</span></code>를 묵시적으로 호출하여 재시작 동작을 인터럽트 가능으로 재설정합니다.</p>
</dd></dl>

<dl class="function">
<dt id="signal.signal">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">signal</code><span class="sig-paren">(</span><em class="sig-param">signalnum</em>, <em class="sig-param">handler</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.signal" title="정의 주소">¶</a></dt>
<dd><p>시그널 <em>signalnum</em>의 처리기를 함수 <em>handler</em>로 설정합니다. <em>handler</em>는 두 개의 인자(아래를 참조하십시오)를  취하는 콜러블 파이썬 객체, 또는 특수 값 <a class="reference internal" href="#signal.SIG_IGN" title="signal.SIG_IGN"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIG_IGN</span></code></a>이나 <a class="reference internal" href="#signal.SIG_DFL" title="signal.SIG_DFL"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIG_DFL</span></code></a> 중 하나일 수 있습니다. 이전 시그널 처리기가 반환됩니다 (위의 <a class="reference internal" href="#signal.getsignal" title="signal.getsignal"><code class="xref py py-func docutils literal notranslate"><span class="pre">getsignal()</span></code></a> 설명을 참조하십시오). (자세한 내용은 유닉스 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/signal(2)">signal(2)</a></em>를 참조하십시오.)</p>
<p>스레드가 활성화되었을 때, 이 함수는 <a class="reference internal" href="#signals-and-threads"><span class="std std-ref">메인 인터프리터의 메인 스레드</span></a>에서만 호출할 수 있습니다; 다른 스레드에서 호출하려고 하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 예외가 발생합니다.</p>
<p><em>handler</em>는 두 개의 인자로 호출됩니다: 시그널 번호와 현재 스택 프레임 (<code class="docutils literal notranslate"><span class="pre">None</span></code>이나 프레임 객체; 프레임 객체에 대한 설명은, <a class="reference internal" href="../reference/datamodel.html#frame-objects"><span class="std std-ref">형 계층에 있는 설명</span></a>을 참조하거나 <a class="reference internal" href="inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 모듈의 어트리뷰트 설명을 참조하십시오).</p>
<p>윈도우에서, <a class="reference internal" href="#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-func docutils literal notranslate"><span class="pre">signal()</span></code></a>은 <a class="reference internal" href="#signal.SIGABRT" title="signal.SIGABRT"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGABRT</span></code></a>, <a class="reference internal" href="#signal.SIGFPE" title="signal.SIGFPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGFPE</span></code></a>, <a class="reference internal" href="#signal.SIGILL" title="signal.SIGILL"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGILL</span></code></a>, <a class="reference internal" href="#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGINT</span></code></a>, <a class="reference internal" href="#signal.SIGSEGV" title="signal.SIGSEGV"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGSEGV</span></code></a>, <a class="reference internal" href="#signal.SIGTERM" title="signal.SIGTERM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGTERM</span></code></a> 또는 <a class="reference internal" href="#signal.SIGBREAK" title="signal.SIGBREAK"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGBREAK</span></code></a>로만 호출 할 수 있습니다. 다른 경우에는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 모든 시스템이 같은 시그널 이름 집합을 정의하는 것은 아님에 유의하십시오; 시그널 이름이 <code class="docutils literal notranslate"><span class="pre">SIG*</span></code> 모듈 수준 상수로 정의되지 않으면 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>가 발생합니다.</p>
</dd></dl>

<dl class="function">
<dt id="signal.sigpending">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">sigpending</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#signal.sigpending" title="정의 주소">¶</a></dt>
<dd><p>호출하는 스레드로 전달 계류 중인 시그널 집합을 검사합니다 (즉, 차단된 동안 발생한 시그널). 계류 중인 시그널 집합을 반환합니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스. 자세한 내용은 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/sigpending(2)">sigpending(2)</a></em>를 참조하십시오.</p>
<p><a class="reference internal" href="#signal.pause" title="signal.pause"><code class="xref py py-func docutils literal notranslate"><span class="pre">pause()</span></code></a>, <a class="reference internal" href="#signal.pthread_sigmask" title="signal.pthread_sigmask"><code class="xref py py-func docutils literal notranslate"><span class="pre">pthread_sigmask()</span></code></a> 및 <a class="reference internal" href="#signal.sigwait" title="signal.sigwait"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigwait()</span></code></a>도 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="signal.sigwait">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">sigwait</code><span class="sig-paren">(</span><em class="sig-param">sigset</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.sigwait" title="정의 주소">¶</a></dt>
<dd><p>시그널 집합 <em>sigset</em>에 지정된 시그널 중 하나가 전달될 때까지 호출하는 스레드의 실행을 일시 중단합니다. 이 함수는 시그널을 받아들이고 (계류 중인 시그널 목록에서 제거합니다), 시그널 번호를 반환합니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스. 자세한 내용은 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/sigwait(3)">sigwait(3)</a></em>을 참조하십시오.</p>
<p><a class="reference internal" href="#signal.pause" title="signal.pause"><code class="xref py py-func docutils literal notranslate"><span class="pre">pause()</span></code></a>, <a class="reference internal" href="#signal.pthread_sigmask" title="signal.pthread_sigmask"><code class="xref py py-func docutils literal notranslate"><span class="pre">pthread_sigmask()</span></code></a>, <a class="reference internal" href="#signal.sigpending" title="signal.sigpending"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigpending()</span></code></a>, <a class="reference internal" href="#signal.sigwaitinfo" title="signal.sigwaitinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigwaitinfo()</span></code></a> 및 <a class="reference internal" href="#signal.sigtimedwait" title="signal.sigtimedwait"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigtimedwait()</span></code></a>도 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="signal.sigwaitinfo">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">sigwaitinfo</code><span class="sig-paren">(</span><em class="sig-param">sigset</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.sigwaitinfo" title="정의 주소">¶</a></dt>
<dd><p>시그널 집합 <em>sigset</em>에 지정된 시그널 중 하나가 전달될 때까지 호출하는 스레드의 실행을 일시 중단합니다. 이 함수는 시그널을 받아들이고 계류 중인 시그널 목록에서 제거합니다. <em>sigset</em>의 시그널 중 하나가 이미 호출하는 스레드에 대해 계류 중이면, 함수는 해당 시그널에 대한 정보와 함께 즉시 반환합니다. 전달된 시그널에 대해 시그널 처리기가 호출되지 않습니다. 이 함수는 <em>sigset</em>에 없는 시그널에 의해 중단되면 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a>를 발생시킵니다.</p>
<p>반환 값은 <code class="xref c c-type docutils literal notranslate"><span class="pre">siginfo_t</span></code> 구조체에 포함된 데이터, 즉 <code class="xref py py-attr docutils literal notranslate"><span class="pre">si_signo</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">si_code</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">si_errno</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">si_pid</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">si_uid</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">si_status</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">si_band</span></code>를 표현하는 객체입니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스. 자세한 내용은 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/sigwaitinfo(2)">sigwaitinfo(2)</a></em>를 참조하십시오.</p>
<p><a class="reference internal" href="#signal.pause" title="signal.pause"><code class="xref py py-func docutils literal notranslate"><span class="pre">pause()</span></code></a>, <a class="reference internal" href="#signal.sigwait" title="signal.sigwait"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigwait()</span></code></a> 및 <a class="reference internal" href="#signal.sigtimedwait" title="signal.sigtimedwait"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigtimedwait()</span></code></a>도 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이 함수는 이제 <em>sigset</em>에 없는 시그널에 의해 중단되고 시그널 처리기가 예외를 발생시키지 않으면 재시도됩니다 (이유는 <span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하십시오).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="signal.sigtimedwait">
<code class="sig-prename descclassname">signal.</code><code class="sig-name descname">sigtimedwait</code><span class="sig-paren">(</span><em class="sig-param">sigset</em>, <em class="sig-param">timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#signal.sigtimedwait" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#signal.sigwaitinfo" title="signal.sigwaitinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigwaitinfo()</span></code></a>와 유사하지만, 시간제한을 지정하는 추가 <em>timeout</em> 인자를 취합니다. <em>timeout</em>이 <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>으로 지정되면, 폴링이 수행됩니다. 시간제한 초과가 발생하면 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환합니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: 유닉스. 자세한 내용은 매뉴얼 페이지 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/sigtimedwait(2)">sigtimedwait(2)</a></em>를 참조하십시오.</p>
<p><a class="reference internal" href="#signal.pause" title="signal.pause"><code class="xref py py-func docutils literal notranslate"><span class="pre">pause()</span></code></a>, <a class="reference internal" href="#signal.sigwait" title="signal.sigwait"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigwait()</span></code></a> 및 <a class="reference internal" href="#signal.sigwaitinfo" title="signal.sigwaitinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">sigwaitinfo()</span></code></a>도 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이 함수는 이제 <em>sigset</em>에 없는 시그널에 의해 중단되고 시그널 처리기가 예외를 발생시키지 않으면 다시 계산된 <em>timeout</em>으로 재시도됩니다 (이유는 <span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>를 참조하십시오).</p>
</div>
</dd></dl>

</div>
<div class="section" id="example">
<span id="signal-example"></span><h2>예<a class="headerlink" href="#example" title="제목 주소">¶</a></h2>
<p>다음은 최소한의 예제 프로그램입니다. <a class="reference internal" href="#signal.alarm" title="signal.alarm"><code class="xref py py-func docutils literal notranslate"><span class="pre">alarm()</span></code></a> 함수를 사용하여 파일을 여는 데 대기하는 시간을 제한합니다; 이것은 파일이 켜져 있지 않을 수 있는 직렬 장치를 위한 파일일 때 유용하며, 일반적으로 <a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a>이 무기한 정지됩니다. 해결책은 파일을 열기 전에 5초 알람을 설정하는 것입니다; 작업이 너무 오래 걸리면, 알람 시그널이 전송되고, 처리기가 예외를 발생시킵니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">signal</span><span class="o">,</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Signal handler called with signal&#39;</span><span class="p">,</span> <span class="n">signum</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t open device!&quot;</span><span class="p">)</span>

<span class="c1"># 시그널 처리기와 5초 알람을 설정합니다</span>
<span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGALRM</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
<span class="n">signal</span><span class="o">.</span><span class="n">alarm</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># 이 open()은 무기한 멈출 수 있습니다</span>
<span class="n">fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;/dev/ttyS0&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDWR</span><span class="p">)</span>

<span class="n">signal</span><span class="o">.</span><span class="n">alarm</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>          <span class="c1"># 알람을 비활성화합니다</span>
</pre></div>
</div>
</div>
<div class="section" id="note-on-sigpipe">
<h2>SIGPIPE에 대한 참고 사항<a class="headerlink" href="#note-on-sigpipe" title="제목 주소">¶</a></h2>
<p>프로그램의 출력을 <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/head(1)">head(1)</a></em>와 같은 도구로 파이핑 하면 표준 출력의 수신기가 일찍 닫힐 때 여러분의 프로세스로 <a class="reference internal" href="#signal.SIGPIPE" title="signal.SIGPIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGPIPE</span></code></a> 시그널이 전송됩니다. 이것은 <code class="code docutils literal notranslate"><span class="pre">BrokenPipeError:</span> <span class="pre">[Errno</span> <span class="pre">32]</span> <span class="pre">Broken</span> <span class="pre">pipe</span></code>와 같은 예외를 일으킵니다. 이 경우를 처리하려면, 다음과 같이 이 예외를 포착하도록 진입점을 감싸십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># 큰 출력을 시뮬레이션합니다 (여러분의 코드가 이 루프를 대체합니다)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
        <span class="c1"># 이 try 블록 내부에 있는 동안 SIGPIPE를 강제로 트리거 하기 위해</span>
        <span class="c1"># 여기에서 출력을 플러시 합니다.</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">BrokenPipeError</span><span class="p">:</span>
        <span class="c1"># 파이썬은 종료 시 표준 스트림을 플러시 합니다; 종료 시 또 다른 BrokenPipeError를</span>
        <span class="c1"># 피하고자 나머지 출력을 devnull 로 리디렉션 합니다</span>
        <span class="n">devnull</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">devnull</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_WRONLY</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">dup2</span><span class="p">(</span><span class="n">devnull</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># EPIPE에 대해 파이썬은 에러 코드 1로 종료합니다</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="exceptions.html#BrokenPipeError" title="BrokenPipeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenPipeError</span></code></a>를 피하고자 <a class="reference internal" href="#signal.SIGPIPE" title="signal.SIGPIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGPIPE</span></code></a>의 배치를 <a class="reference internal" href="#signal.SIG_DFL" title="signal.SIG_DFL"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIG_DFL</span></code></a>로 설정하지 마십시오. 그렇게 하면 프로그램이 여전히 쓰고 있는 동안 소켓 연결이 중단될 때마다 프로그램이 예기치 않게 종료되도록 합니다.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code> --- 비동기 이벤트에 대한 처리기 설정</a><ul>
<li><a class="reference internal" href="#general-rules">일반 규칙</a><ul>
<li><a class="reference internal" href="#execution-of-python-signal-handlers">파이썬 시그널 처리기의 실행</a></li>
<li><a class="reference internal" href="#signals-and-threads">시그널과 스레드</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-contents">모듈 내용</a></li>
<li><a class="reference internal" href="#example">예</a></li>
<li><a class="reference internal" href="#note-on-sigpipe">SIGPIPE에 대한 참고 사항</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="asynchat.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asynchat</span></code> --- Asynchronous socket command/response handler</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="mmap.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mmap</span></code> --- 메모리 맵 파일 지원</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="mmap.html" title="mmap --- 메모리 맵 파일 지원"
             >다음</a> |</li>
        <li class="right" >
          <a href="asynchat.html" title="asynchat --- Asynchronous socket command/response handler"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2021, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2021, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>