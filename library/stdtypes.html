
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>4. 내장형 &#8212; Python 3.6.5 documentation</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.5 documentation에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="5. Built-in Exceptions" href="exceptions.html" />
    <link rel="prev" title="3. 내장 상수" href="constants.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="http://python.flowdas.com/library/stdtypes.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="exceptions.html" title="5. Built-in Exceptions"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="constants.html" title="3. 내장 상수"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 표준 라이브러리</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="built-in-types">
<span id="bltin-types"></span><h1>4. 내장형<a class="headerlink" href="#built-in-types" title="제목 주소">¶</a></h1>
<p>다음 섹션에서는 인터프리터에 내장된 표준형에 관해 설명합니다.</p>
<p id="index-0">기본 내장 유형은 숫자, 시퀀스, 매핑, 클래스, 인스턴스 및 예외입니다.</p>
<p>일부 컬렉션 클래스는 가변입니다. 제자리에서 멤버를 추가, 삭제 또는 재배치하고 특정 항목을 반환하지 않는 메서드는 컬렉션 인스턴스 자체를 반환하지 않고 <code class="docutils literal"><span class="pre">None</span></code> 을 반환합니다.</p>
<p>일부 연산들은 여러 객체 형에서 지원됩니다; 특히 사실상 모든 객체를 비교하고, 논리값을 검사하고, (<a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 함수 또는 약간 다른 <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> 함수를 사용해서) 문자열로 변환할 수 있습니다. 두 번째 함수는 <a class="reference internal" href="functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> 함수로 객체를 쓸 때 묵시적으로 사용됩니다.</p>
<div class="section" id="truth-value-testing">
<span id="truth"></span><h2>4.1. 논리값 검사<a class="headerlink" href="#truth-value-testing" title="제목 주소">¶</a></h2>
<p id="index-1">모든 객체는 논리값을 검사할 수 있는데, <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> 또는 <a class="reference internal" href="../reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal"><span class="pre">while</span></code></a> 조건 또는 다음에 나오는 논리 연산의 피연산자로 사용될 수 있도록 합니다.</p>
<p id="index-2">기본적으로 객체는 클래스가 그 객체에 대해 호출될 때 <code class="docutils literal"><span class="pre">False</span></code> 를 돌려주는 <a class="reference internal" href="../reference/datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal"><span class="pre">__bool__()</span></code></a> 메서드나 0을 돌려주는 <a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> 메서드를 정의하지 않는 한 참으로 간주합니다. <a class="footnote-reference" href="#id12" id="id1">[1]</a> 여기에 거짓으로 간주하는 대부분의 내장 객체들이 있습니다:</p>
<blockquote>
<div></div></blockquote>
<ul class="simple" id="index-3">
<li>거짓으로 정의된 상수: <code class="docutils literal"><span class="pre">None</span></code> 과 <code class="docutils literal"><span class="pre">False</span></code>.</li>
<li>모든 숫자 형들의 영: <code class="docutils literal"><span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">0.0</span></code>, <code class="docutils literal"><span class="pre">0j</span></code>, <code class="docutils literal"><span class="pre">Decimal(0)</span></code>, <code class="docutils literal"><span class="pre">Fraction(0,</span> <span class="pre">1)</span></code></li>
<li>빈 시퀀스와 컬렉션: <code class="docutils literal"><span class="pre">''</span></code>, <code class="docutils literal"><span class="pre">()</span></code>, <code class="docutils literal"><span class="pre">[]</span></code>, <code class="docutils literal"><span class="pre">{}</span></code>, <code class="docutils literal"><span class="pre">set()</span></code>, <code class="docutils literal"><span class="pre">range(0)</span></code></li>
</ul>
<p id="index-4">논리값을 돌려주는 연산과 내장 함수는 달리 명시하지 않는 한 항상 거짓의 경우 <code class="docutils literal"><span class="pre">0</span></code> 이나 <code class="docutils literal"><span class="pre">False</span></code> 를, 참이면 <code class="docutils literal"><span class="pre">1</span></code> 이나 <code class="docutils literal"><span class="pre">True</span></code> 를 돌려줍니다. (중요한 예외: 논리 연산 <code class="docutils literal"><span class="pre">or</span></code> 와 <code class="docutils literal"><span class="pre">and</span></code> 는 항상 피연산자 중 하나를 돌려줍니다.)</p>
</div>
<div class="section" id="boolean-operations-and-or-not">
<span id="boolean"></span><h2>4.2. 논리 연산 --- <a class="reference internal" href="../reference/expressions.html#and"><code class="xref std std-keyword docutils literal"><span class="pre">and</span></code></a>, <a class="reference internal" href="../reference/expressions.html#or"><code class="xref std std-keyword docutils literal"><span class="pre">or</span></code></a>, <a class="reference internal" href="../reference/expressions.html#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a><a class="headerlink" href="#boolean-operations-and-or-not" title="제목 주소">¶</a></h2>
<p id="index-5">이것들은 우선순위에 따라 오름차순으로 정렬된 논리 연산들입니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="62%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산</th>
<th class="head">결과</th>
<th class="head">노트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code></td>
<td><em>x</em> 가 거짓이면 <em>y</em>, 그렇지 않으면 <em>x</em></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code></td>
<td><em>x*가 거짓이면 *x</em>, 그렇지 않으면 <em>y</em></td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">not</span> <span class="pre">x</span></code></td>
<td><em>x</em> 가 거짓이면 <code class="docutils literal"><span class="pre">True</span></code>, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code></td>
<td>(3)</td>
</tr>
</tbody>
</table>
<p id="index-6">노트:</p>
<ol class="arabic simple">
<li>이것은 단락-회로 연산자이므로 첫 번째 인자가 거짓일 때만 두 번째의 값을 구합니다.</li>
<li>이것은 단락-회로 연산자이므로 첫 번째 인자가 참일 때만 두 번째의 값을 구합니다.</li>
<li><code class="docutils literal"><span class="pre">not</span></code> 은 비논리 연산자들보다 낮은 우선순위를 갖습니다. 그래서, <code class="docutils literal"><span class="pre">not</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code> 는 <code class="docutils literal"><span class="pre">not</span> <span class="pre">(a</span> <span class="pre">==</span> <span class="pre">b)</span></code> 로 해석되고, <code class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">not</span> <span class="pre">b</span></code> 는 문법 오류입니다.</li>
</ol>
</div>
<div class="section" id="comparisons">
<span id="stdcomparisons"></span><h2>4.3. 비교<a class="headerlink" href="#comparisons" title="제목 주소">¶</a></h2>
<p id="index-7">파이썬에는 8가지 비교 연산이 있습니다. 이들 모두는 같은 우선순위를 가집니다 (논리 연산보다는 높습니다). 비교는 임의로 연결될 수 있습니다; 예를 들어 <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> 는 <em>y</em> 의 값을 한 번만 구한다는 점을 제외하고는 <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> 와 동등합니다 (하지만 두 경우 모두 <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> 가 거짓으로 밝혀지면 <em>z</em> 의 값을 구하지 않습니다).</p>
<p>이 표는 비교 연산을 요약합니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산</th>
<th class="head">뜻</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&lt;</span></code></td>
<td>엄격히 작다</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;=</span></code></td>
<td>작거나 같다</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&gt;</span></code></td>
<td>엄격히 크다</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&gt;=</span></code></td>
<td>크거나 같다</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">==</span></code></td>
<td>같다</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">!=</span></code></td>
<td>같지 않다</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">is</span></code></td>
<td>객체 아이덴티티</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></td>
<td>부정된 객체 아이덴티티</td>
</tr>
</tbody>
</table>
<p id="index-8">서로 다른 숫자 형을 제외하고는 서로 다른 형의 객체들은 같다고 비교되지 않습니다. 더 나아가, 어떤 형들은 (예를 들어, 함수 객체) 그 형의 모든 두 객체가 다르다고 비교되는 비교의 축약적인 개념만을 지원합니다. <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code> 연산자들은 복소수를 다른 내장 숫자 형과 비교할 때, 객체들이 비교될 수 없는 다른 형일 때, 정의된 순서가 없을 때 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 예외를 일으킵니다.</p>
<p id="index-9">클래스의 같지 않은 인스턴스들은 그 클래스가 <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> 메서드를 정의하지 않는 이상 보통 같지 않다고 비교됩니다.</p>
<p>클래스가 <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal"><span class="pre">__le__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal"><span class="pre">__gt__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal"><span class="pre">__ge__()</span></code></a> 메서드들을 충분히 정의하지 않는 이상, 클래스의 인스턴스들은 같은 클래스의 다른 인스턴스나 다른 형의 객체와의 순서가 정해지지 않습니다 (일반적으로, 여러분이 비교 연산자의 관습적인 의미를 원한다면 <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a> 와 <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> 만으로 충분합니다).</p>
<p><a class="reference internal" href="../reference/expressions.html#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a> 와 <a class="reference internal" href="../reference/expressions.html#is-not"><code class="xref std std-keyword docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></a> 연산자의 동작은 사용자 정의할 수 없습니다; 또한 임의의 두 객체에 적용할 수 있으며 예외를 발생시키지 않습니다.</p>
<p id="index-10">같은 문법적 우선순위를 갖는 두 개의 연산, <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 과 <a class="reference internal" href="../reference/expressions.html#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a>, 은 (아래에 나오는) 시퀀스 형에서만 지원됩니다.</p>
</div>
<div class="section" id="numeric-types-int-float-complex">
<span id="typesnumeric"></span><h2>4.4. 숫자 형 --- <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a><a class="headerlink" href="#numeric-types-int-float-complex" title="제목 주소">¶</a></h2>
<p id="index-11">세 가지 다른 숫자 형이 있습니다: <em class="dfn">정수 (integers)</em>, <em class="dfn">실수 (floating point numbers)</em>, <em class="dfn">복소수 (complex numbers)</em>. 또한 논리형은 정수의 하위 유형입니다. 정수는 무제한의 정밀도를 갖습니다. 실수는 보통 C의 <code class="xref c c-type docutils literal"><span class="pre">double</span></code>을 사용해서 구현됩니다; 프로그램이 실행되고 있는 기계의 부동 소수점 숫자의 정밀도와 내부 표현에 관한 정보는 <a class="reference internal" href="sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal"><span class="pre">sys.float_info</span></code></a>에서 얻을 수 있습니다. 복소수는 각각 실수로 표현되는 실수부와 허수부를 가집니다. 복소수 <em>z</em> 에서 이들 부분을 추출하려면 <code class="docutils literal"><span class="pre">z.real</span></code> 과 <code class="docutils literal"><span class="pre">z.imag</span></code> 를 사용하십시오. (표준 라이브러리는 추가적인 숫자 형들을 포함하는데, <a class="reference internal" href="fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal"><span class="pre">fractions</span></code></a>는 유리수를, <a class="reference internal" href="decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> 은 사용자가 정의할 수 있는 정밀도로 부동 소수점 숫자를 다룹니다.)</p>
<p id="index-12">숫자는 숫자 리터럴 또는 내장 함수와 연산자의 결과로 만들어집니다. 꾸밈없는 정수 리터럴(16진수, 8진수, 2진수 포함)은 정수를 만듭니다. 소수점 또는 지수 기호가 포함된 숫자 리터럴은 실수를 만듭니다. 숫자 리터럴에 <code class="docutils literal"><span class="pre">'j'</span></code> 나 <code class="docutils literal"><span class="pre">'J'</span></code> 를 덧붙이면 허수 (실수부가 0인 복소수) 가 만들어지는데, 정수나 실수에 더해서 실수부와 허수부가 있는 복소수를 만들 수 있습니다.</p>
<p id="index-13">파이썬은 혼합 산술을 완벽하게 지원합니다: 이항 산술 연산자가 다른 숫자 형의 피연산자를 가질 때, &quot;더 좁은&quot; 형의 피연산자는 다른 피연산자의 형으로 넓혀집니다. 정수는 실수보다 좁고, 실수는 복소수보다 좁습니다. 혼합형 숫자 사이의 비교는 같은 규칙을 사용합니다. <a class="footnote-reference" href="#id13" id="id2">[2]</a> 생성자 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a>, <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a>를 특정 형의 숫자를 만드는데 사용할 수 있습니다.</p>
<p>(복소수를 제외한) 모든 숫자 형은 다음과 같은 연산들을 지원하는데, 우선순위에 따라 오름차순 정렬되어 있습니다 (모든 숫자 연산은 비교 연산보다 높은 우선순위를 갖습니다):</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="40%" />
<col width="11%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산</th>
<th class="head">결과</th>
<th class="head">노트</th>
<th class="head">전체 문서</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 합</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 차</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 곱</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 몫</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">//</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 정수로 내림한 몫</td>
<td>(1)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code></td>
<td><code class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> 의 나머지</td>
<td>(2)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">-x</span></code></td>
<td>음의 <em>x</em></td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">+x</span></code></td>
<td><em>x</em> 그대로</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">abs(x)</span></code></td>
<td><em>x</em> 의 절댓값 또는 크기</td>
<td>&#160;</td>
<td><a class="reference internal" href="functions.html#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">int(x)</span></code></td>
<td>정수로 변환된 <em>x</em></td>
<td>(3)(6)</td>
<td><a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">float(x)</span></code></td>
<td>실수로 변환된 <em>x</em></td>
<td>(4)(6)</td>
<td><a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">complex(re,</span> <span class="pre">im)</span></code></td>
<td>실수부 <em>re</em> 와 허수부 <em>im</em> 으로 구성된 복소수. <em>im</em> 의 기본값은 0입니다.</td>
<td>(6)</td>
<td><a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">c.conjugate()</span></code></td>
<td>복소수 <em>c</em> 의 켤레</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">divmod(x,</span> <span class="pre">y)</span></code></td>
<td>쌍 <code class="docutils literal"><span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y,</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y)</span></code></td>
<td>(2)</td>
<td><a class="reference internal" href="functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span></code></td>
<td><em>x</em> 의 <em>y</em> 거듭제곱</td>
<td>(5)</td>
<td><a class="reference internal" href="functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">y</span></code></td>
<td><em>x</em> 의 <em>y</em> 거듭제곱</td>
<td>(5)</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p id="index-14">노트:</p>
<ol class="arabic">
<li><p class="first">정수 나눗셈이라고 도합니다. 결괏값의 형이 꼭 int 일 필요는 없지만, 결괏값은 항상 정수입니다. 결과는 항상 음의 무한대를 향해 내림 됩니다: <code class="docutils literal"><span class="pre">1//2</span></code> 는 <code class="docutils literal"><span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">(-1)//2</span></code> 는 <code class="docutils literal"><span class="pre">-1</span></code>, <code class="docutils literal"><span class="pre">1//(-2)</span></code> 는 <code class="docutils literal"><span class="pre">-1</span></code>, <code class="docutils literal"><span class="pre">(-1)//(-2)</span></code> 는 <code class="docutils literal"><span class="pre">0</span></code> 입니다.</p>
</li>
<li><p class="first">복소수에는 사용할 수 없습니다. 적절한 경우 <a class="reference internal" href="functions.html#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a>를 사용하여 실수로 변환하십시오.</p>
</li>
<li><p id="index-15">실수에서 정수로의 변환은 C에서처럼 반올림이나 자름이 발생할 수 있습니다; 잘 정의된 변환을 위해서는 <a class="reference internal" href="math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal"><span class="pre">math.floor()</span></code></a> 와 <a class="reference internal" href="math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal"><span class="pre">math.ceil()</span></code></a> 함수를 보십시오.</p>
</li>
<li><p class="first">float는 또한 숫자가 아님(NaN)과 양 또는 음의 무한대를 나타내는 문자열 &quot;nan&quot;과 접두사 &quot;+&quot; 나 &quot;-&quot; 가 선택적으로 붙을 수 있는 &quot;inf&quot;를 받아들입니다.</p>
</li>
<li><p class="first">파이썬은 프로그래밍 언어들에서 흔히 그렇듯이, 있는 것처럼 <code class="docutils literal"><span class="pre">pow(0,</span> <span class="pre">0)</span></code> 와 <code class="docutils literal"><span class="pre">0</span> <span class="pre">**</span> <span class="pre">0</span></code> 이 <code class="docutils literal"><span class="pre">1</span></code> 이 되도록 정의합니다.</p>
</li>
<li><p class="first">받아들여지는 숫자 리터럴은 <code class="docutils literal"><span class="pre">0</span></code> 에서 <code class="docutils literal"><span class="pre">9</span></code> 까지 또는 모든 동등한 유니코드들을 (<code class="docutils literal"><span class="pre">Nd</span></code> 속성을 가진 코드 포인트들) 포함합니다.</p>
<p><code class="docutils literal"><span class="pre">Nd</span></code> 속성을 가진 코드 포인트의 전체 목록을 보려면 <a class="reference external" href="http://www.unicode.org/Public/9.0.0/ucd/extracted/DerivedNumericType.txt">http://www.unicode.org/Public/9.0.0/ucd/extracted/DerivedNumericType.txt</a> 를 보십시오.</p>
</li>
</ol>
<p>모든 <a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal"><span class="pre">numbers.Real</span></code></a> 형 (<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 와 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>) 은 또한 다음과 같은 연산들을 포함합니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산</th>
<th class="head">결과</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal"><span class="pre">math.trunc(x)</span></code></a></td>
<td><em>x</em> 는 <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a> 로 잘립니다</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="functions.html#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round(x[,</span>
<span class="pre">n])</span></code></a></td>
<td><em>x</em> 를 <em>n</em> 자리로 반올림하는데, 절반 값은 짝수로 반올림합니다. <em>n</em> 을 생략하면 기본값은 0입니다.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal"><span class="pre">math.floor(x)</span></code></a></td>
<td>가장 큰 <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a> &lt;= <em>x</em></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal"><span class="pre">math.ceil(x)</span></code></a></td>
<td>가장 작은 <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a> &gt;= <em>x</em></td>
</tr>
</tbody>
</table>
<p>추가적인 숫자 연산은 <a class="reference internal" href="math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal"><span class="pre">math</span></code></a>와 <a class="reference internal" href="cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal"><span class="pre">cmath</span></code></a> 모듈을 보십시오.</p>
<div class="section" id="bitwise-operations-on-integer-types">
<span id="bitstring-ops"></span><h3>4.4.1. 정수 형에 대한 비트 연산<a class="headerlink" href="#bitwise-operations-on-integer-types" title="제목 주소">¶</a></h3>
<p id="index-16">비트 연산은 정수에 대해서만 의미가 있습니다. 음수는 2의 보수 값으로 처리됩니다 (이는 연산 중에 오버플로가 발생하지 않도록 충분한 비트가 있다고 가정합니다).</p>
<p>이진 비트 연산의 우선순위는 모두 숫자 연산보다 낮고 비교보다 높습니다; 일항 연산 <code class="docutils literal"><span class="pre">~</span></code> 은 다른 일항 연산들 (<code class="docutils literal"><span class="pre">+</span></code> 와 <code class="docutils literal"><span class="pre">-</span></code>) 과 같은 우선순위를 가집니다.</p>
<p>이 표는 비트 연산을 나열하는데, 우선순위에 따라 오름차순으로 정렬되어 있습니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="59%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산</th>
<th class="head">결과</th>
<th class="head">노트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">|</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 비트별 <em class="dfn">or</em></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">^</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 비트별 <em class="dfn">배타적 or (exclusive or)</em></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">&amp;</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 비트별 <em class="dfn">and</em></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">n</span></code></td>
<td><em>x</em> 를 <em>n</em> 비트만큼 왼쪽으로 시프트</td>
<td>(1)(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">n</span></code></td>
<td><em>x</em> 를 <em>n</em> 비트만큼 오른쪽으로 시프트</td>
<td>(1)(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">~x</span></code></td>
<td><em>x</em> 의 비트 반전</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>노트:</p>
<ol class="arabic simple">
<li>음의 시프트 수는 허락되지 않고 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</li>
<li><em>n</em> 비트만큼의 왼쪽 시프트는 오버플로 검사 없이 <code class="docutils literal"><span class="pre">pow(2,</span> <span class="pre">n)</span></code> 를 곱하는 것과 동등합니다.</li>
<li><em>n</em> 비트만큼 오른쪽으로 시프트 하는 것은 오버플로 검사 없이 <code class="docutils literal"><span class="pre">pow(2,</span> <span class="pre">n)</span></code> 로 나누는 것과 동등합니다.</li>
</ol>
</div>
<div class="section" id="additional-methods-on-integer-types">
<h3>4.4.2. 정수 형에 대한 추가 메서드<a class="headerlink" href="#additional-methods-on-integer-types" title="제목 주소">¶</a></h3>
<p>int 형은 <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">numbers.Integral</span></code></a> <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">추상 베이스 클래스</span></a> 를 구현합니다. 또한, 몇 가지 메서드를 더 제공합니다:</p>
<dl class="method">
<dt id="int.bit_length">
<code class="descclassname">int.</code><code class="descname">bit_length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#int.bit_length" title="정의 주소">¶</a></dt>
<dd><p>부호와 선행 0을 제외하고, 이진수로 정수를 나타내는 데 필요한 비트 수를 돌려줍니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">&#39;-0b100101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<p>좀 더 정확하게 말하자면, <code class="docutils literal"><span class="pre">x</span></code> 가 0이 아니면, <code class="docutils literal"><span class="pre">x.bit_length()</span></code> 는 <code class="docutils literal"><span class="pre">2**(k-1)</span> <span class="pre">&lt;=</span> <span class="pre">abs(x)</span> <span class="pre">&lt;</span> <span class="pre">2**k</span></code> 를 만족하는 유일한 양의 정수 <code class="docutils literal"><span class="pre">k</span></code> 입니다. 동등하게, <code class="docutils literal"><span class="pre">abs(x)</span></code> 가 정확하게 반올림된 로그값을 가질 만큼 아주 작으면, <code class="docutils literal"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">int(log(abs(x),</span> <span class="pre">2))</span></code> 가 됩니다. <code class="docutils literal"><span class="pre">x</span></code> 가 0이면, <code class="docutils literal"><span class="pre">x.bit_length()</span></code> 는 <code class="docutils literal"><span class="pre">0</span></code> 을 돌려줍니다.</p>
<p>다음 코드와 동등합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bit_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>       <span class="c1"># binary representation:  bin(-37) --&gt; &#39;-0b100101&#39;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;-0b&#39;</span><span class="p">)</span> <span class="c1"># remove leading zeros and minus sign</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>       <span class="c1"># len(&#39;100101&#39;) --&gt; 6</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="int.to_bytes">
<code class="descclassname">int.</code><code class="descname">to_bytes</code><span class="sig-paren">(</span><em>length</em>, <em>byteorder</em>, <em>*</em>, <em>signed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#int.to_bytes" title="정의 주소">¶</a></dt>
<dd><p>정수를 나타내는 바이트의 배열을 돌려줍니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x04\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">b&#39;\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;little&#39;</span><span class="p">)</span>
<span class="go">b&#39;\xe8\x03&#39;</span>
</pre></div>
</div>
<p>정수는 <em>length</em> 바이트를 사용하여 표현됩니다. 정수가 주어진 바이트 수로 표현할 수 없는 경우 An <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> 를 일으킵니다.</p>
<p><em>byteorder</em> 인자는 정수를 나타내는 데 사용되는 바이트 순서를 결정합니다. <em>byteorder</em> 가 <code class="docutils literal"><span class="pre">&quot;big&quot;</span></code> 인 경우, 최상위 바이트는 바이트 배열의 처음에 있습니다. <em>byteorder</em> 가 <code class="docutils literal"><span class="pre">&quot;little&quot;</span></code> 인 경우, 최상위 바이트는 바이트 배열의 끝에 있습니다. 호스트 시스템의 기본 바이트 순서를 요청하려면 바이트 순서 값으로 <a class="reference internal" href="sys.html#sys.byteorder" title="sys.byteorder"><code class="xref py py-data docutils literal"><span class="pre">sys.byteorder</span></code></a> 를 사용하십시오.</p>
<p><em>signed</em> 인자는 정수를 표현하는데 2의 보수가 사용되는지를 결정합니다. <em>signed</em> 가 <code class="docutils literal"><span class="pre">False</span></code> 이고 음의 정수가 주어지면, <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> 가 일어납니다. <em>signed</em> 의 기본값은 <code class="docutils literal"><span class="pre">False</span></code> 입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="int.from_bytes">
<em class="property">classmethod </em><code class="descclassname">int.</code><code class="descname">from_bytes</code><span class="sig-paren">(</span><em>bytes</em>, <em>byteorder</em>, <em>*</em>, <em>signed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#int.from_bytes" title="정의 주소">¶</a></dt>
<dd><p>주어진 바이트 배열로 표현되는 정수를 돌려줍니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x10</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x10</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;little&#39;</span><span class="p">)</span>
<span class="go">4096</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xfc\x00</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">-1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xfc\x00</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">64512</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">([</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">16711680</span>
</pre></div>
</div>
<p>인자 <em>bytes</em> 는 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a> 이거나 바이트를 생성하는 이터러블이어야 합니다.</p>
<p><em>byteorder</em> 인자는 정수를 나타내는 데 사용되는 바이트 순서를 결정합니다. <em>byteorder</em> 가 <code class="docutils literal"><span class="pre">&quot;big&quot;</span></code> 인 경우, 최상위 바이트는 바이트 배열의 처음에 있습니다. <em>byteorder</em> 가 <code class="docutils literal"><span class="pre">&quot;little&quot;</span></code> 인 경우, 최상위 바이트는 바이트 배열의 끝에 있습니다. 호스트 시스템의 기본 바이트 순서를 요청하려면 바이트 순서 값으로 <a class="reference internal" href="sys.html#sys.byteorder" title="sys.byteorder"><code class="xref py py-data docutils literal"><span class="pre">sys.byteorder</span></code></a> 를 사용하십시오.</p>
<p><em>signed</em> 인자는 정수를 표현하는데 2의 보수가 사용되는지를 나타냅니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="additional-methods-on-float">
<h3>4.4.3. 실수에 대한 추가 메서드<a class="headerlink" href="#additional-methods-on-float" title="제목 주소">¶</a></h3>
<p>float 형은 <a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal"><span class="pre">numbers.Real</span></code></a> <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">추상 베이스 클래스</span></a> 를 구현합니다. 또한, float는 다음과 같은 추가 메서드를 갖습니다.</p>
<dl class="method">
<dt id="float.as_integer_ratio">
<code class="descclassname">float.</code><code class="descname">as_integer_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.as_integer_ratio" title="정의 주소">¶</a></dt>
<dd><p>비율이 원래 float와 정확히 같고 양의 분모를 갖는 정수 쌍을 돌려줍니다. 무한대에는 <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> 를, NaN 에는 a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="float.is_integer">
<code class="descclassname">float.</code><code class="descname">is_integer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.is_integer" title="정의 주소">¶</a></dt>
<dd><p>float 인스턴스가 정숫값을 가진 유한이면 <code class="docutils literal"><span class="pre">True</span></code> 를, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code> 를 돌려줍니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<p>두 가지 메서드가 16진수 문자열과의 변환을 지원합니다. 파이썬의 float는 내부적으로 이진수로 저장되기 때문에 float를 <em>십진수</em> 문자열로 또는 그 반대로 변환하는 것은 보통 반올림 오류를 수반합니다. 이에 반해, 16진수 문자열은 부동 소수점 숫자의 정확한 표현과 지정을 가능하게 합니다. 이것은 디버깅 및 수치 작업에 유용할 수 있습니다.</p>
<dl class="method">
<dt id="float.hex">
<code class="descclassname">float.</code><code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.hex" title="정의 주소">¶</a></dt>
<dd><p>부동 소수점의 16진수 문자열 표현을 돌려줍니다. 유한 부동 소수점의 경우, 이 표현은 항상 선행하는 <code class="docutils literal"><span class="pre">0x</span></code> 와 후행하는 <code class="docutils literal"><span class="pre">p</span></code> 와 지수를 포함합니다.</p>
</dd></dl>

<dl class="classmethod">
<dt id="float.fromhex">
<em class="property">classmethod </em><code class="descclassname">float.</code><code class="descname">fromhex</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#float.fromhex" title="정의 주소">¶</a></dt>
<dd><p>16진수 문자열 <em>s</em> 로 표현되는 float를 돌려주는 클래스 메서드. 문자열 <em>s</em> 는 앞뒤 공백을 가질 수 있습니다.</p>
</dd></dl>

<p><a class="reference internal" href="#float.hex" title="float.hex"><code class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></code></a> 는 인스턴스 메서드인 반면, <a class="reference internal" href="#float.fromhex" title="float.fromhex"><code class="xref py py-meth docutils literal"><span class="pre">float.fromhex()</span></code></a> 는 클래스 메서드임에 주의하세요.</p>
<p>16진수 문자열은 다음과 같은 형식을 취합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="p">[</span><span class="s1">&#39;0x&#39;</span><span class="p">]</span> <span class="n">integer</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span> <span class="n">fraction</span><span class="p">]</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span> <span class="n">exponent</span><span class="p">]</span>
</pre></div>
</div>
<p>선택적인 <code class="docutils literal"><span class="pre">sign</span></code> 은 <code class="docutils literal"><span class="pre">+</span></code> 나 <code class="docutils literal"><span class="pre">-</span></code> 가 될 수 있고, <code class="docutils literal"><span class="pre">integer</span></code> 와 <code class="docutils literal"><span class="pre">fraction</span></code> 은 16진수 문자열이고, <code class="docutils literal"><span class="pre">exponent</span></code> 는 선택적인 선행 부호가 붙을 수 있는 십진수입니다. 대소 문자는 중요하지 않으며 integer 나 fraction 중 어느 하나에 적어도 하나의 16진수가 있어야 합니다. 이 문법은 C99 표준의 6.4.4.2 절에 지정된 문법과 비슷하며, 자바 1.5 이상에서 사용되는 문법과도 비슷합니다. 특히, <a class="reference internal" href="#float.hex" title="float.hex"><code class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></code></a> 의 출력은 C 또는 자바 코드에서 16진수의 부동 소수점 리터럴로 사용할 수 있으며, C의 <code class="docutils literal"><span class="pre">%a</span></code> 포맷 문자나 자바의 <code class="docutils literal"><span class="pre">Double.toHexString</span></code> 가 만들어내는 16진수 문자열은 <a class="reference internal" href="#float.fromhex" title="float.fromhex"><code class="xref py py-meth docutils literal"><span class="pre">float.fromhex()</span></code></a> 가 받아들입니다.</p>
<p>지수는 16진수가 아닌 십진수로 쓰이고, 숫자에 곱해지는 2의 거듭제곱을 제공한다는 점에 유의하십시오. 예를 들어, 16진수 문자열 <code class="docutils literal"><span class="pre">0x3.a7p10</span></code> 는 부동 소수점 숫자 <code class="docutils literal"><span class="pre">(3</span> <span class="pre">+</span> <span class="pre">10./16</span> <span class="pre">+</span> <span class="pre">7./16**2)</span> <span class="pre">*</span> <span class="pre">2.0**10</span></code> 또는 <code class="docutils literal"><span class="pre">3740.0</span></code> 를 나타냅니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;0x3.a7p10&#39;</span><span class="p">)</span>
<span class="go">3740.0</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">3740.0</span></code> 에 역변환을 적용하면 같은 숫자를 나타내는 다른 16진수 문자열을 얻을 수 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">hex</span><span class="p">(</span><span class="mf">3740.0</span><span class="p">)</span>
<span class="go">&#39;0x1.d380000000000p+11&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="hashing-of-numeric-types">
<span id="numeric-hash"></span><h3>4.4.4. 숫자 형의 해싱<a class="headerlink" href="#hashing-of-numeric-types" title="제목 주소">¶</a></h3>
<p>숫자 <code class="docutils literal"><span class="pre">x</span></code> 와 <code class="docutils literal"><span class="pre">y</span></code>, 서로 다른 형이어도 됩니다, 에 대하여, <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 면 항상 <code class="docutils literal"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code> 일 것이 요구됩니다 (자세한 내용은 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> 메서드 도큐멘테이션을 보세요). 다양한 숫자 형(<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code></a>, <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal"><span class="pre">fractions.Fraction</span></code></a> 포함)들의 구현의 편의성과 효율 때문에, 파이썬의 숫자 형의 해시는 단일한 수학 함수에 기반을 두고 있고, 이 함수는 임의의 유리수에 대해 정의되어서 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 와 <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal"><span class="pre">fractions.Fraction</span></code></a> 의 모든 인스턴스, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>와 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code></a> 의 모든 유한 인스턴스에 적용됩니다. 본질에서, 이 함수는 고정 소수 <code class="docutils literal"><span class="pre">P</span></code> 에 대해 모듈로 <code class="docutils literal"><span class="pre">P</span></code> 환원(reduction modulo <code class="docutils literal"><span class="pre">P</span></code>)으로 주어집니다. <code class="docutils literal"><span class="pre">P</span></code> 의 값은 <a class="reference internal" href="sys.html#sys.hash_info" title="sys.hash_info"><code class="xref py py-data docutils literal"><span class="pre">sys.hash_info</span></code></a> 의 <code class="xref py py-attr docutils literal"><span class="pre">modulus</span></code> 어트리뷰트로 파이썬에 제공됩니다.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> 현재, 사용되는 소수는 32-비트 C long을 가진 기계에서는 <code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">2**31</span> <span class="pre">-</span> <span class="pre">1</span></code> 이고, 64-비트 C long을 가진 기계에서는 <code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">2**61</span> <span class="pre">-</span> <span class="pre">1</span></code> 입니다.</p>
</div>
<p>다음은 규칙에 대한 세부 사항입니다:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> 이 음이 아닌 유리수이고 <code class="docutils literal"><span class="pre">n</span></code> 이 <code class="docutils literal"><span class="pre">P</span></code> 로 나뉘지 않는다면, <code class="docutils literal"><span class="pre">hash(x)</span></code> 를 <code class="docutils literal"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">invmod(n,</span> <span class="pre">P)</span> <span class="pre">%</span> <span class="pre">P</span></code> 로 정의합니다. 여기서 <code class="docutils literal"><span class="pre">invmod(n,</span> <span class="pre">P)</span></code> 는 <code class="docutils literal"><span class="pre">n</span></code> 의 모듈로 <code class="docutils literal"><span class="pre">P</span></code> 역수를 줍니다.</li>
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> 이 음이 아닌 유리수이고 <code class="docutils literal"><span class="pre">n</span></code> 이 <code class="docutils literal"><span class="pre">P</span></code> 나뉘면 (하지만 <code class="docutils literal"><span class="pre">m</span></code> 은 나뉘지 않으면) <code class="docutils literal"><span class="pre">n</span></code> 은 모듈로 <code class="docutils literal"><span class="pre">P</span></code> 역수를 가지지 않고 위의 규칙은 적용되지 않습니다; 이 경우 <code class="docutils literal"><span class="pre">hash(x)</span></code> 를 상숫값 <code class="docutils literal"><span class="pre">sys.hash_info.inf</span></code> 로 정의합니다.</li>
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> 이 음의 유리수이면 <code class="docutils literal"><span class="pre">hash(x)</span></code> 를 <code class="docutils literal"><span class="pre">-hash(-x)</span></code> 로 정의합니다. 얻어진 해시가 <code class="docutils literal"><span class="pre">-1</span></code> 이면 <code class="docutils literal"><span class="pre">-2</span></code> 로 바꿉니다.</li>
<li>특별한 값 <code class="docutils literal"><span class="pre">sys.hash_info.inf</span></code>, <code class="docutils literal"><span class="pre">-sys.hash_info.inf</span></code>, <code class="docutils literal"><span class="pre">sys.hash_info.nan</span></code> 은 각각 무한대, 음의 무한대, nan 으로 사용됩니다. (모든 해시 가능 nan 은 같은 해시값을 가집니다.)</li>
<li>복소수(<a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a>) <code class="docutils literal"><span class="pre">z</span></code> 의 경우, <code class="docutils literal"><span class="pre">hash(z.real)</span> <span class="pre">+</span> <span class="pre">sys.hash_info.imag</span> <span class="pre">*</span> <span class="pre">hash(z.imag)</span></code> 를 계산하여 실수부와 허수부의 해시값을 결합하는데, <code class="docutils literal"><span class="pre">2**sys.hash_info.width</span></code> 의 모듈로로 환원해서 <code class="docutils literal"><span class="pre">range(-2**(sys.hash_info.width</span> <span class="pre">-</span> <span class="pre">1),</span> <span class="pre">2**(sys.hash_info.width</span> <span class="pre">-</span> <span class="pre">1))</span></code> 범위에 들어가도록 만듭니다. 다시 한번, 결과가 <code class="docutils literal"><span class="pre">-1</span></code> 이라면 <code class="docutils literal"><span class="pre">-2</span></code> 로 바꿉니다.</li>
</ul>
<p>위의 규칙을 명확히 하기 위해, 여기에 유리수, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a> 의 해시를 계산하는, 내장 해시와 동등한, 파이썬 코드를 예시합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">hash_fraction</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a rational number m / n.</span>

<span class="sd">    Assumes m and n are integers, with n positive.</span>
<span class="sd">    Equivalent to hash(fractions.Fraction(m, n)).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">modulus</span>
    <span class="c1"># Remove common factors of P.  (Unnecessary if m and n already coprime.)</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">//</span> <span class="n">P</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="n">P</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Fermat&#39;s Little Theorem: pow(n, P-1, P) is 1, so</span>
        <span class="c1"># pow(n, P-2, P) gives the inverse of n modulo P.</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">%</span> <span class="n">P</span><span class="p">)</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">P</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="o">%</span> <span class="n">P</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="n">hash_value</span>
    <span class="k">if</span> <span class="n">hash_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">hash_value</span>

<span class="k">def</span> <span class="nf">hash_float</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a float x.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">elif</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hash_fraction</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">hash_complex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a complex number z.&quot;&quot;&quot;</span>

    <span class="n">hash_value</span> <span class="o">=</span> <span class="n">hash_float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">hash_float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
    <span class="c1"># do a signed reduction modulo 2**sys.hash_info.width</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">hash_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&amp;</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hash_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">hash_value</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="iterator-types">
<span id="typeiter"></span><h2>4.5. 이터레이터 형<a class="headerlink" href="#iterator-types" title="제목 주소">¶</a></h2>
<p id="index-17">파이썬은 컨테이너에 대한 이터레이션 개념을 지원합니다. 이것은 두 개의 메서드를 사용해서 구현됩니다; 이것들은 사용자 정의 클래스가 이터레이션을 지원할 수 있도록 하는 데 사용됩니다. 아래에서 더 자세히 설명할 시퀀스는 항상 이터레이션 메서드를 지원합니다.</p>
<p>컨테이너 객체가 이터레이션 지원을 제공하려면 한가지 메서드를 정의할 필요가 있습니다.:</p>
<dl class="method">
<dt id="container.__iter__">
<code class="descclassname">container.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#container.__iter__" title="정의 주소">¶</a></dt>
<dd><p>이터레이터 객체를 돌려줍니다. 이 객체는 아래에서 설명하는 이터레이터 프로토콜을 지원해야 합니다. 컨테이너가 여러 유형의 이터레이션을 지원하는 경우, 이터레이션 유형에 대한 이터레이터를 구체적으로 요구하는 추가 메서드를 제공할 수 있습니다. (여러 형태의 이터레이션을 지원하는 객체의 예로 너비 우선과 깊이 우선 탐색을 모두 지원하는 트리 구조를 들 수 있습니다.) 이 메서드는 파이썬/C API에서 파이썬 객체를 위한 구조체의 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a> 슬롯에 대응합니다.</p>
</dd></dl>

<p>이터레이터 객체 자체는 다음과 같은 두 가지 메서드를 지원해야 하는데, 둘이 함께 <em class="dfn">이터레이터 프로토콜 (iterator protocol)</em> 를 이룹니다.:</p>
<dl class="method">
<dt id="iterator.__iter__">
<code class="descclassname">iterator.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iterator.__iter__" title="정의 주소">¶</a></dt>
<dd><p>이터레이터 객체 자신을 돌려줍니다. 이는 <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 와 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 문에 컨테이너와 이터레이터 모두 사용될 수 있게 하는 데 필요합니다. 이 메서드는 파이썬/C API에서 파이썬 객체를 위한 구조체의 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a> 슬롯에 대응합니다.</p>
</dd></dl>

<dl class="method">
<dt id="iterator.__next__">
<code class="descclassname">iterator.</code><code class="descname">__next__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iterator.__next__" title="정의 주소">¶</a></dt>
<dd><p>컨테이너의 다음 항목을 돌려줍니다. 더 항목이 없으면 <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 예외를 일으킵니다. 이 메서드는 파이썬/C API에서 파이썬 객체를 위한 구조체의 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal"><span class="pre">tp_iternext</span></code></a> 슬롯에 대응합니다.</p>
</dd></dl>

<p>파이썬은 일반적이거나 특정한 시퀀스 형, 딕셔너리, 기타 더 특화된 형태에 대한 이터레이션을 지원하기 위해 여러 이터레이터 객체를 정의합니다. 이터레이터 프로토콜의 구현을 넘어서 개별적인 형이 중요하지는 않습니다.</p>
<p>일단 이터레이터의 <a class="reference internal" href="#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> 메서드가 <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 를 일으키면, 그 이후의 호출에 대해서도 같이 동작해야 합니다. 이 속성을 따르지 않는 구현은 망가진 것으로 간주합니다.</p>
<div class="section" id="generator-types">
<span id="id3"></span><h3>4.5.1. 제너레이터 형<a class="headerlink" href="#generator-types" title="제목 주소">¶</a></h3>
<p>파이썬의 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a> 는 이터레이터 프로토콜을 구현하는 편리한 방법을 제공합니다. 컨테이너 객체의 <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> 메서드가 제너레이터로 구현되면, <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> 와 <a class="reference internal" href="../reference/expressions.html#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> 메서드를 제공하는 이터레이터 객체(기술적으로, 제너레이터 객체)를 자동으로 돌려줍니다. 제너레이터에 대한 더 자세한 정보는 <a class="reference internal" href="../reference/expressions.html#yieldexpr"><span class="std std-ref">일드 표현식 도큐멘테이션</span></a> 에서 찾을 수 있습니다.</p>
</div>
</div>
<div class="section" id="sequence-types-list-tuple-range">
<span id="typesseq"></span><h2>4.6. 시퀀스 형 --- <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a><a class="headerlink" href="#sequence-types-list-tuple-range" title="제목 주소">¶</a></h2>
<p>세 가지 기본 시퀀스 형이 있습니다: 리스트, 튜플, 범위 객체. <a class="reference internal" href="#binaryseq"><span class="std std-ref">바이너리 데이터</span></a> 와 <a class="reference internal" href="#textseq"><span class="std std-ref">텍스트 문자열</span></a> 의 처리를 위해 추가된 시퀀스 형들은 별도의 섹션에서 설명합니다.</p>
<div class="section" id="common-sequence-operations">
<span id="typesseq-common"></span><h3>4.6.1. 공통 시퀀스 연산<a class="headerlink" href="#common-sequence-operations" title="제목 주소">¶</a></h3>
<p id="index-18">다음 표의 연산들은 대부분의 가변과 불변 시퀀스에서 지원됩니다. 사용자 정의 시퀀스에서 이 연산들을 올바르게 구현하기 쉽게 하려고 <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sequence</span></code></a> ABC가 제공됩니다.</p>
<p>이 표는 우선순위에 따라 오름차순으로 시퀀스 연산들을 나열합니다. 표에서, <em>s</em> 와 <em>t</em> 는 같은 형의 시퀀스고, <em>n</em>, <em>i</em>, <em>j</em>, <em>k</em> 는 정수이고, <em>x</em> 는 <em>s</em> 가 요구하는 형과 값 제한을 만족하는 임의의 객체입니다.</p>
<p><code class="docutils literal"><span class="pre">in</span></code> 과 <code class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></code> 연산은 비교 연산과 우선순위가 같습니다. <code class="docutils literal"><span class="pre">+</span></code> (이어 붙이기)와 <code class="docutils literal"><span class="pre">*</span></code> (반복) 연산은 대응하는 숫자 연산과 같은 우선순위를 갖습니다. <a class="footnote-reference" href="#id14" id="id4">[3]</a></p>
<table border="1" class="docutils" id="index-19">
<colgroup>
<col width="38%" />
<col width="47%" />
<col width="15%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산</th>
<th class="head">결과</th>
<th class="head">노트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code></td>
<td><em>s</em> 의 항목 중 하나가 <em>x</em> 와 같으면 <code class="docutils literal"><span class="pre">True</span></code>, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code></td>
<td><em>s</em> 의 항목 중 하나가 <em>x</em> 와 같으면 <code class="docutils literal"><span class="pre">False</span></code>, 그렇지 않으면 <code class="docutils literal"><span class="pre">True</span></code></td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s</span> <span class="pre">+</span> <span class="pre">t</span></code></td>
<td><em>s</em> 와 <em>t</em> 의 이어 붙이기</td>
<td>(6)(7)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n</span></code> 또는 <code class="docutils literal"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">s</span></code></td>
<td><em>s</em> 를 그 자신에 <em>n</em> 번 더하는 것과 같습니다</td>
<td>(2)(7)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s[i]</span></code></td>
<td><em>s</em> 의 <em>i</em> 번째 항목, 0에서 시작합니다</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s[i:j]</span></code></td>
<td><em>s</em> 의 <em>i</em> 에서 <em>j</em> 까지의 슬라이스</td>
<td>(3)(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s[i:j:k]</span></code></td>
<td><em>s</em> 의 <em>i</em> 에서 <em>j</em> 까지 스텝 <em>k</em> 의 슬라이스</td>
<td>(3)(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">len(s)</span></code></td>
<td><em>s</em> 의 길이</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">min(s)</span></code></td>
<td><em>s</em> 의 가장 작은 항목</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">max(s)</span></code></td>
<td><em>s</em> 의 가장 큰 항목</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.index(x[,</span> <span class="pre">i[,</span> <span class="pre">j]])</span></code></td>
<td>(인덱스 <em>i</em> 또는 그 이후에, 인덱스 <em>j</em> 전에 등장하는) <em>s</em> 의 첫 번째 <em>x</em> 의 인덱스</td>
<td>(8)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.count(x)</span></code></td>
<td><em>s</em> 등장하는 <em>x</em> 의 총수</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>같은 형의 시퀀스는 비교를 지원합니다. 특히, 튜플과 리스트는 대응하는 항목들을 사전적으로 비교합니다. 이것은 같다고 비교되기 위해서는, 모든 항목이 같다고 비교되고, 두 시퀀스의 형과 길이가 같아야 함을 의미합니다. (자세한 내용은 언어 레퍼런스의 <a class="reference internal" href="../reference/expressions.html#comparisons"><span class="std std-ref">비교</span></a>를 참조하십시오.)</p>
<p>노트:</p>
<ol class="arabic">
<li><p class="first"><code class="docutils literal"><span class="pre">in</span></code> 과 <code class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></code> 연산은 일반적으로 단순한 포함 검사를 위해서만 사용되지만, 몇몇 특수한 시퀀스 (<a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 같은) 들은 서브 시퀀스 검사에 사용하기도 합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;gg&quot;</span> <span class="ow">in</span> <span class="s2">&quot;eggs&quot;</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p class="first"><em>n</em> 의 값이 <code class="docutils literal"><span class="pre">0</span></code> 보다 작으면 <code class="docutils literal"><span class="pre">0</span></code> 으로 처리됩니다 (<em>s</em> 와 같은 형의 빈 시퀀스가 됩니다). 시퀀스 <em>s</em> 의 항목들이 복사되지 않음에 주의해야 합니다; 그들은 여러 번 참조됩니다. 이것은 종종 새 파이썬 프로그래머들을 괴롭힙니다; 이 코드를 살펴보세요:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[], [], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [3], [3]]</span>
</pre></div>
</div>
<p>무슨 일이 일어났는가 하면, <code class="docutils literal"><span class="pre">[[]]</span></code> 는 빈 리스트를 포함하는 길이 1인 리스트인데, <code class="docutils literal"><span class="pre">[[]]</span> <span class="pre">*</span> <span class="pre">3</span></code> 의 세 항목은 모두 같은 빈 리스트를 참조합니다. <code class="docutils literal"><span class="pre">lists</span></code> 의 어느 항목을 수정하더라도 이 하나의 리스트를 수정하게 됩니다. 서로 다른 리스트들을 포함하는 리스트는 이런 식으로 만들 수 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [5], [7]]</span>
</pre></div>
</div>
<p>더 자세한 설명은 FAQ 항목 <a class="reference internal" href="../faq/programming.html#faq-multidimensional-list"><span class="std std-ref">How do I create a multidimensional list?</span></a>에서 얻을 수 있습니다.</p>
</li>
<li><p class="first"><em>i</em> 또는 <em>j</em> 가 음수인 경우, 인덱스는 시퀀스 <em>s</em> 의 끝에 상대적입니다: <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">i</span></code> 이나 <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">j</span></code> 로 치환됩니다. 하지만 <code class="docutils literal"><span class="pre">-0</span></code> 은 여전히 <code class="docutils literal"><span class="pre">0</span></code> 입니다.</p>
</li>
<li><p class="first"><em>i</em> 에서 <em>j</em> 까지의 <em>s</em> 의 슬라이스는 <code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">j</span></code> 를 만족하는 인덱스 <em>k</em> 의 항목들로 구성된 시퀀스로 정의됩니다. <em>i</em> 또는 <em>j</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 크면 <code class="docutils literal"><span class="pre">len(s)</span></code> 을 사용합니다. <em>i</em> 가 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이라면 <code class="docutils literal"><span class="pre">0</span></code> 을 사용합니다. <em>j</em> 가 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이면 <code class="docutils literal"><span class="pre">len(s)</span></code> 을 사용합니다. <em>i</em> 가 <em>j</em> 보다 크거나 같으면 빈 슬라이스가 됩니다.</p>
</li>
<li><p class="first">스텝 <em>k</em> 가 있는 <em>i</em> 에서 <em>j</em> 까지의 슬라이스는 <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">(j-i)/k</span></code> 를 만족하는 인덱스 <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code> 의 항목들로 구성된 시퀀스로 정의됩니다. 다시 말하면, 인덱스는 <code class="docutils literal"><span class="pre">i</span></code>, <code class="docutils literal"><span class="pre">i+k</span></code>, <code class="docutils literal"><span class="pre">i+2*k</span></code>, <code class="docutils literal"><span class="pre">i+3*k</span></code> 등이며 <em>j</em> 에 도달할 때 멈춥니다 (하지만 절대 <em>j</em> 를 포함하지는 않습니다). <em>k</em> 가 양수면 <em>i</em> 와 <em>j</em> 는 더 큰 경우 <code class="docutils literal"><span class="pre">len(s)</span></code> 로 줄어듭니다. <em>k</em> 가 음수면, <em>i</em> 와 <em>j</em> 는 더 큰 경우 <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">-</span> <span class="pre">1</span></code> 로 줄어듭니다. <em>i</em> 또는 <em>j</em> 가 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이면, 그것들은 &quot;끝&quot; 값이 됩니다 (끝은 <em>k</em> 의 부호에 따라 달라집니다). <em>k</em> 는 0일 수 없음에 주의하세요. <em>k</em> 가 <code class="docutils literal"><span class="pre">None</span></code> 이면 <code class="docutils literal"><span class="pre">1</span></code> 로 취급됩니다.</p>
</li>
<li><p class="first">불변 시퀀스를 이어 붙이면 항상 새로운 객체가 생성됩니다. 이것은 반복적으로 이어붙이기를 해서 시퀀스를 만들 때 실행 시간이 시퀀스의 총 길이의 제곱에 비례한다는 뜻입니다. 선형 실행 시간 비용을 얻으려면 아래 대안 중 하나로 전환해야 합니다:</p>
<ul class="simple">
<li><a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 객체를 이어붙이기를 한다면, 리스트를 만들고 마지막에 <a class="reference internal" href="#str.join" title="str.join"><code class="xref py py-meth docutils literal"><span class="pre">str.join()</span></code></a> 을 사용하거나 <a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a> 인스턴스에 쓰고 완료될 때 값을 꺼낼 수 있습니다</li>
<li><a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체를 연결하는 경우 비슷하게 <a class="reference internal" href="#bytes.join" title="bytes.join"><code class="xref py py-meth docutils literal"><span class="pre">bytes.join()</span></code></a> 또는 <a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></code></a> 를 사용하거나, <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 객체를 사용하여 제자리에서 이어붙이기를 할 수 있습니다. <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 객체는 가변이고 효율적인 과할당(overallocation) 메커니즘을 가지고 있습니다.</li>
<li><a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> 객체를 이어붙이기를 한다면, 대신 <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>를 extend 하십시오.</li>
<li>다른 형의 경우 관련 클래스 문서를 조사하십시오.</li>
</ul>
</li>
<li><p class="first">일부 시퀀스 형 (예를 들어 <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a>)은 특정 패턴을 따르는 항목 시퀀스 만 지원하기 때문에 시퀀스 이어붙이기나 반복을 지원하지 않습니다.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">index</span></code> raises <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> when <em>x</em> is not found in <em>s</em>.
Not all implementations support passing the additional arguments <em>i</em> and <em>j</em>.
These arguments allow efficient searching of subsections of the sequence. Passing
the extra arguments is roughly equivalent to using <code class="docutils literal"><span class="pre">s[i:j].index(x)</span></code>, only
without copying any data and with the returned index being relative to
the start of the sequence rather than the start of the slice.</p>
</li>
</ol>
</div>
<div class="section" id="immutable-sequence-types">
<span id="typesseq-immutable"></span><h3>4.6.2. 불변 시퀀스 형<a class="headerlink" href="#immutable-sequence-types" title="제목 주소">¶</a></h3>
<p id="index-20">불변 시퀀스 형이 일반적으로 구현하지만, 가변 시퀀스 형에서는 구현되지 않는 연산은 내장 <a class="reference internal" href="functions.html#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a> 에 대한 지원입니다.</p>
<p>이 지원은 <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> 인스턴스와 같은 불변 시퀀스를 <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> 키로 사용하고 <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> 및 <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> 인스턴스에 저장할 수 있도록 합니다.</p>
<p>해시 불가능 값을 포함하는 불변 시퀀스를 해시 하려고 하면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 를 일으킵니다.</p>
</div>
<div class="section" id="mutable-sequence-types">
<span id="typesseq-mutable"></span><h3>4.6.3. 가변 시퀀스 형<a class="headerlink" href="#mutable-sequence-types" title="제목 주소">¶</a></h3>
<p id="index-21">다음 표의 연산들은 가변 시퀀스 형에 정의되어 있습니다. 사용자 정의 시퀀스에서 이 연산들을 올바르게 구현하기 쉽게 하려고 <a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.MutableSequence</span></code></a> ABC가 제공됩니다.</p>
<p>표에서 <em>s</em> 는 가변 시퀀스 형의 인스턴스이고, <em>t</em> 는 임의의 이터러블 객체이며, <em>x</em> 는 <em>s</em> 가 요구하는 형 및 값 제한을 충족시키는 임의의 객체입니다 (예를 들어, <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 는 값 제한 <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">255</span></code> 를 만족하는 정수만 받아들입니다.</p>
<table border="1" class="docutils" id="index-22">
<colgroup>
<col width="36%" />
<col width="39%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산</th>
<th class="head">결과</th>
<th class="head">노트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s[i]</span> <span class="pre">=</span> <span class="pre">x</span></code></td>
<td><em>s</em> 의 항목 <em>i</em> 를 <em>x</em> 로 대체합니다</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">t</span></code></td>
<td><em>i</em> 에서 <em>j</em> 까지의 <em>s</em> 슬라이스가 이터러블 <em>t</em> 의 내용으로 대체됩니다</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">del</span> <span class="pre">s[i:j]</span></code></td>
<td><code class="docutils literal"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">[]</span></code> 와 같습니다</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s[i:j:k]</span> <span class="pre">=</span> <span class="pre">t</span></code></td>
<td><code class="docutils literal"><span class="pre">s[i:j:k]</span></code> 의 항목들이 <em>t</em> 의 항목들로 대체됩니다</td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">del</span> <span class="pre">s[i:j:k]</span></code></td>
<td>리스트에서 <code class="docutils literal"><span class="pre">s[i:j:k]</span></code> 의 항목들을 제거합니다</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.append(x)</span></code></td>
<td>시퀀스의 끝에 <em>x</em> 를 추가합니다 (<code class="docutils literal"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">[x]</span></code> 와 같습니다)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.clear()</span></code></td>
<td><code class="docutils literal"><span class="pre">s</span></code> 에서 모든 항목을 제거합니다 (<code class="docutils literal"><span class="pre">del</span> <span class="pre">s[:]</span></code> 와 같습니다)</td>
<td>(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.copy()</span></code></td>
<td><code class="docutils literal"><span class="pre">s</span></code> 의 얕은 복사본을 만듭니다 (<code class="docutils literal"><span class="pre">s[:]</span></code> 와 같습니다)</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.extend(t)</span></code> 또는 <code class="docutils literal"><span class="pre">s</span> <span class="pre">+=</span> <span class="pre">t</span></code></td>
<td><em>t</em> 의 내용으로 <em>s</em> 를 확장합니다 (대부분 <code class="docutils literal"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">t</span></code> 와 같습니다)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s</span> <span class="pre">*=</span> <span class="pre">n</span></code></td>
<td>내용이 <em>n</em> 번 반복되도록 <em>s</em> 를 갱신합니다</td>
<td>(6)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.insert(i,</span> <span class="pre">x)</span></code></td>
<td><em>x</em> 를 <em>s</em> 의 <em>i</em> 로 주어진 인덱스에 삽입합니다 (<code class="docutils literal"><span class="pre">s[i:i]</span> <span class="pre">=</span> <span class="pre">[x]</span></code> 와 같습니다)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.pop([i])</span></code></td>
<td><em>i</em> 에 있는 항목을 꺼냄과 동시에 <em>s</em> 에서 제거합니다</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.remove(x)</span></code></td>
<td><code class="docutils literal"><span class="pre">s[i]</span> <span class="pre">==</span> <span class="pre">x</span></code> 가 되는 첫 번째 항목을 <em>s</em> 에서 제거합니다</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.reverse()</span></code></td>
<td>제자리에서 <em>s</em> 의 항목들의 순서를 뒤집습니다</td>
<td>(4)</td>
</tr>
</tbody>
</table>
<p>노트:</p>
<ol class="arabic">
<li><p class="first"><em>t</em> 는 교체할 슬라이스와 길이가 같아야 합니다.</p>
</li>
<li><p class="first">선택적 인자 <em>i</em> 의 기본값은 <code class="docutils literal"><span class="pre">-1</span></code> 입니다. 그래서 기본적으로 마지막 항목이 제거되면서 반환됩니다.</p>
</li>
<li><p class="first"><em>x</em> 가 <em>s</em> 에서 발견되지 않으면 <code class="docutils literal"><span class="pre">remove</span></code> 는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
</li>
<li><p class="first">큰 시퀀스를 뒤집을 때 공간 절약을 위해 <code class="xref py py-meth docutils literal"><span class="pre">reverse()</span></code> 메서드는 제자리에서 시퀀스를 수정합니다. 부작용으로 작동한다는 것을 사용자에게 상기시키기 위해 뒤집힌 시퀀스를 돌려주지 않습니다.</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code>와 <code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code> 는 슬라이싱 연산을 지원하지 않는 (<a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> 와 <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> 같은) 가변 컨테이너들의 인터페이스와 일관성을 유지하기 위해 포함됩니다</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code>와 <code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code> 메서드.</p>
</div>
</li>
<li><p class="first"><em>n</em> 값은 정수이거나, <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> 를 구현하는 객체입니다. <em>n</em> 이 0 이거나 음수면 시퀀스를 지웁니다. 시퀀스의 항목들은 복사되지 않습니다; <a class="reference internal" href="#typesseq-common"><span class="std std-ref">공통 시퀀스 연산</span></a>에서 <code class="docutils literal"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n</span></code> 를 위해 설명한 것처럼 여러 번 참조됩니다.</p>
</li>
</ol>
</div>
<div class="section" id="lists">
<span id="typesseq-list"></span><h3>4.6.4. 리스트<a class="headerlink" href="#lists" title="제목 주소">¶</a></h3>
<p id="index-23">리스트는 가변 시퀀스로, 일반적으로 등질 항목들의 모음을 저장하는 데 사용됩니다 (정확한 유사도는 응용 프로그램마다 다를 수 있습니다).</p>
<dl class="class">
<dt id="list">
<em class="property">class </em><code class="descname">list</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#list" title="정의 주소">¶</a></dt>
<dd><p>리스트는 여러 가지 방법으로 만들 수 있습니다:</p>
<ul class="simple">
<li>꺾쇠괄호를 사용하여 빈 리스트를 표시하기: <code class="docutils literal"><span class="pre">[]</span></code></li>
<li>꺾쇠괄호를 사용하여 쉼표로 항목 구분하기: <code class="docutils literal"><span class="pre">[a]</span></code>, <code class="docutils literal"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c]</span></code></li>
<li>리스트 컴프리헨션 사용하기: <code class="docutils literal"><span class="pre">[x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">iterable]</span></code></li>
<li>형 생성자를 사용하기: <code class="docutils literal"><span class="pre">list()</span></code> 또는 <code class="docutils literal"><span class="pre">list(iterable)</span></code></li>
</ul>
<p>생성자는 항목들과 그 순서가 <em>iterable</em> 과 같은 리스트를 만듭니다. <em>iterable</em> 은 시퀀스, 이터레이션을 지원하는 컨테이너, 이터레이터 객체가 될 수 있습니다. <em>iterable</em> 이 이미 리스트라면, <code class="docutils literal"><span class="pre">iterable[:]</span></code> 과 비슷하게 복사본을 만들어서 반환합니다. 예를 들어, <code class="docutils literal"><span class="pre">list('abc')</span></code> 는 <code class="docutils literal"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code> 를 반환하고 <code class="docutils literal"><span class="pre">list(</span> <span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span> <span class="pre">)</span></code> 는 <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> 를 반환합니다. 인자가 주어지지 않으면, 생성자는 새로운 빈 리스트인 <code class="docutils literal"><span class="pre">[]</span></code> 을 만듭니다.</p>
<p>다른 많은 연산도 리스트를 만드는데, 내장 <a class="reference internal" href="functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a> 도 그런 것 중 하나다.</p>
<p>리스트는 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">공통</span></a> 과 <a class="reference internal" href="#typesseq-mutable"><span class="std std-ref">가변</span></a> 시퀀스 연산들을 모두 구현합니다. 또한, 리스트는 다음과 같은 추가 메서드를 제공합니다:</p>
<dl class="method">
<dt id="list.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>*</em>, <em>key=None</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#list.sort" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 항목 간의 <code class="docutils literal"><span class="pre">&lt;</span></code> 비교만 사용하여 리스트를 제자리에서 정렬합니다. 예외는 억제되지 않습니다 - 비교 연산이 실패하면 전체 정렬 연산이 실패합니다 (리스트는 부분적으로 수정된 상태로 남아있게 됩니다).</p>
<p><a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code></a> 는 키워드로만 전달할 수 있는 두 개의 인자를 받아들입니다 (<a class="reference internal" href="../glossary.html#keyword-only-parameter"><span class="std std-ref">키워드-전용 인자</span></a>):</p>
<p><em>key</em> 는 인자 하나를 받아들이는 함수를 지정하는데, 각 리스트 요소에서 비교 키를 추출하는 데 사용됩니다 (예들 들어, <code class="docutils literal"><span class="pre">key=str.lower</span></code>). 리스트의 각 항목에 해당하는 키는 한 번만 계산된 후 전체 정렬 프로세스에 사용됩니다. 기본값 <code class="docutils literal"><span class="pre">None</span></code> 은 리스트 항목들이 별도의 키값을 계산하지 않고 직접 정렬된다는 것을 의미합니다.</p>
<p><a class="reference internal" href="functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal"><span class="pre">functools.cmp_to_key()</span></code></a> 유틸리티는 2.x 스타일 <em>cmp</em> 함수를 <em>key</em> 함수로 변환하는 데 사용할 수 있습니다.</p>
<p><em>reverse</em> 는 논리값입니다. <code class="docutils literal"><span class="pre">True</span></code> 로 설정되면, 각 비교가 역전된 것처럼 리스트 요소들이 정렬됩니다.</p>
<p>이 메서드는 큰 시퀀스를 정렬할 때 공간 절약을 위해 시퀀스를 제자리에서 수정합니다. 부작용으로 작동한다는 것을 사용자에게 상기시키기 위해 정렬된 시퀀스를 돌려주지 않습니다 (새 정렬 된 리스트 인스턴스를 명시적으로 요청하려면 <a class="reference internal" href="functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a>를 사용하십시오).</p>
<p><a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code></a> 메서드는 안정적임이 보장됩니다. 정렬은 같다고 비교되는 요소들의 상대적 순서를 변경하지 않으면 안정적입니다 --- 이는 여러 번 정렬하는 데 유용합니다 (예를 들어, 부서별로 정렬한 후에 급여 등급으로 정렬).</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> 리스트가 정렬되는 동안, 리스트를 변경하려고 할 때의, 또는 관찰하려고 할 때조차, 효과는 정의되지 않습니다. 파이썬의 C 구현은 그동안 리스트를 비어있는 것으로 보이게 하고, 정렬 중에 리스트가 변경되었음을 감지할 수 있다면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tuples">
<span id="typesseq-tuple"></span><h3>4.6.5. 튜플<a class="headerlink" href="#tuples" title="제목 주소">¶</a></h3>
<p id="index-24">튜플은 불변 시퀀스인데, 보통 이질적인 데이터의 모음을 저장하는 데 사용됩니다 (예를 들어, 내장 <a class="reference internal" href="functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal"><span class="pre">enumerate()</span></code></a> 가 만드는 2-튜플). 튜플은 등질적인 데이터의 불변 시퀀스가 필요한 경우에도 사용됩니다 (예를 들어, <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> 이나 <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> 인스턴스에 저장하고자 하는 경우).</p>
<dl class="class">
<dt id="tuple">
<em class="property">class </em><code class="descname">tuple</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#tuple" title="정의 주소">¶</a></dt>
<dd><p>튜플은 여러 가지 방법으로 만들 수 있습니다:</p>
<ul class="simple">
<li>괄호를 사용하여 빈 튜플을 나타내기: <code class="docutils literal"><span class="pre">()</span></code></li>
<li>단일 항목 튜플을 위해 끝에 쉼표를 붙이기: <code class="docutils literal"><span class="pre">a,</span></code> 또는 <code class="docutils literal"><span class="pre">(a,)</span></code></li>
<li>항목을 쉼표로 구분하기: <code class="docutils literal"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c</span></code> 또는``(a, b, c)``</li>
<li>내장 <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-func docutils literal"><span class="pre">tuple()</span></code></a> 사용하기: <code class="docutils literal"><span class="pre">tuple()</span></code> 또는 <code class="docutils literal"><span class="pre">tuple(iterable)</span></code></li>
</ul>
<p>생성자는 항목들과 그 순서가 <em>iterable</em> 과 같은 튜플을 만듭니다. <em>iterable</em> 은 시퀀스, 이터레이션을 지원하는 컨테이너, 이터레이터 객체가 될 수 있습니다. <em>iterable</em> 이 이미 튜플이라면 변경되지 않은 상태로 반환됩니다. 예를 들어 <code class="docutils literal"><span class="pre">tuple('abc')</span></code> 는 <code class="docutils literal"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'c')</span></code> 를 반환하고, <code class="docutils literal"><span class="pre">tuple(</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span> <span class="pre">)</span></code> 는 <code class="docutils literal"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code> 을 반환합니다. 인자가 주어지지 않으면, 생성자는 새로운 빈 튜플인 <code class="docutils literal"><span class="pre">()</span></code> 을 만듭니다.</p>
<p>튜플을 만드는 것은 실제로는 괄호가 아닌 쉼표임에 유의하십시오. 괄호는 빈 튜플의 경우를 제외하고는 선택적이거나 문법상의 모호함을 피하고자 필요합니다. 예를 들어, <code class="docutils literal"><span class="pre">f(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> 는 3개의 인자를 가진 함수 호출이지만, <code class="docutils literal"><span class="pre">f((a,</span> <span class="pre">b,</span> <span class="pre">c))</span></code> 는 하나의 인자로 3-튜플을 갖는 함수 호출입니다.</p>
<p>튜플은 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">공통</span></a> 시퀀스 연산을 모두 구현합니다.</p>
</dd></dl>

<p>이름에 의한 액세스가 인덱스에 의한 액세스보다 더 명확한 이질적 데이터 컬렉션의 경우, <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal"><span class="pre">collections.namedtuple()</span></code></a> 이 단순한 튜플 객체보다 더 적절한 선택일 수 있습니다.</p>
</div>
<div class="section" id="ranges">
<span id="typesseq-range"></span><h3>4.6.6. 범위<a class="headerlink" href="#ranges" title="제목 주소">¶</a></h3>
<p id="index-25"><a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a> 형은 숫자의 불변 시퀀스를 나타내며 <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 루프에서 특정 횟수만큼 반복하는 데 흔히 사용됩니다.</p>
<dl class="class">
<dt id="range">
<em class="property">class </em><code class="descname">range</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span><a class="headerlink" href="#range" title="정의 주소">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">range</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>범위 생성자에 대해 인자는 정수여야 합니다 (내장 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 또는 <code class="docutils literal"><span class="pre">__index__</span></code> 특수 메서드를 구현하는 임의의 객체). <em>step</em> 인자가 생략되면 기본값 <code class="docutils literal"><span class="pre">1</span></code> 이 사용됩니다. <em>start</em> 인자가 생략되면 기본값 <code class="docutils literal"><span class="pre">0</span></code> 이 사용됩니다. <em>step</em> 이 0이면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
<p>양수 <em>step</em> 의 경우, 범위 <code class="docutils literal"><span class="pre">r</span></code> 의 내용은 식 <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">step*i</span></code> 에 의해 결정됩니다. 이때 <code class="docutils literal"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> 이고 <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">&lt;</span> <span class="pre">stop</span></code> 입니다.</p>
<p>음수 <em>step</em> 의 경우, 범위의 내용은 여전히 식 <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">step*i</span></code> 에 의해 결정되지만, 제약 조건은 <code class="docutils literal"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> 과 <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">&gt;</span> <span class="pre">stop</span></code> 이 됩니다.</p>
<p><code class="docutils literal"><span class="pre">r[0]</span></code> 제약 조건을 만족시키지 않으면 범위 객체는 비게 됩니다. 범위는 음의 인덱스를 지원하지만, 이는 시퀀스의 끝에서부터 양의 인덱스만큼 떨어진 인덱스로 해석됩니다.</p>
<p><a class="reference internal" href="sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal"><span class="pre">sys.maxsize</span></code></a> 보다 큰 절댓값을 포함하는 범위는 허용되지만, (<a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> 과 같은) 일부 기능은 <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> 를 발생시킬 수 있습니다.</p>
<p>범위 예제:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">[0, 5, 10, 15, 20, 25]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[0, 3, 6, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>범위는 이어 붙이기와 반복을 제외한 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">공통</span></a> 시퀀스 연산을 모두 구현합니다 (범위 객체는 엄격한 패턴을 따르는 시퀀스 만 나타낼 수 있는데 반복과 이어 붙이기는 보통 그 패턴을 위반한다는 사실에 기인합니다).</p>
<dl class="attribute">
<dt id="range.start">
<code class="descname">start</code><a class="headerlink" href="#range.start" title="정의 주소">¶</a></dt>
<dd><p><em>start</em> 파라미터의 값 (또는 파라미터가 제공되지 않으면 <code class="docutils literal"><span class="pre">0</span></code>)</p>
</dd></dl>

<dl class="attribute">
<dt id="range.stop">
<code class="descname">stop</code><a class="headerlink" href="#range.stop" title="정의 주소">¶</a></dt>
<dd><p><em>stop</em> 파라미터의 값</p>
</dd></dl>

<dl class="attribute">
<dt id="range.step">
<code class="descname">step</code><a class="headerlink" href="#range.step" title="정의 주소">¶</a></dt>
<dd><p><em>step</em> 파라미터의 값 (또는 파라미터가 제공되지 않으면 <code class="docutils literal"><span class="pre">1</span></code>)</p>
</dd></dl>

</dd></dl>

<p>정규 <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> 나 <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> 에 비해 <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a> 형의 장점은 <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a> 객체는 표현하는 범위의 크기에 무관하게 항상 같은 (작은) 양의 메모리를 사용한다는 것입니다 (<code class="docutils literal"><span class="pre">start</span></code>, <code class="docutils literal"><span class="pre">stop</span></code>, <code class="docutils literal"><span class="pre">step</span></code> 값만을 저장하고, 필요에 따라 개별 항목과 하위 범위를 계산하기 때문입니다).</p>
<p>범위 객체는 <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sequence</span></code></a> ABC를 구현하고, 포함 검사, 요소 인덱스 검색, 슬라이싱, 음수 인덱스 지원과 같은 기능을 제공합니다 (<a class="reference internal" href="#typesseq"><span class="std std-ref">시퀀스 형 --- list, tuple, range</span></a> 를 보세요):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span>
<span class="go">range(0, 20, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">11</span> <span class="ow">in</span> <span class="n">r</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">10</span> <span class="ow">in</span> <span class="n">r</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">range(0, 10, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">18</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">==</span></code> 나 <code class="docutils literal"><span class="pre">!=</span></code> 로 범위 객체가 같은지 검사하면 시퀀스처럼 비교합니다. 즉, 두 범위 객체가 같은 시퀀스의 값을 나타낼 때 같다고 취급됩니다. (같다고 비교되는 두 개의 범위 객체가 서로 다른 <a class="reference internal" href="#range.start" title="range.start"><code class="xref py py-attr docutils literal"><span class="pre">start</span></code></a>, <a class="reference internal" href="#range.stop" title="range.stop"><code class="xref py py-attr docutils literal"><span class="pre">stop</span></code></a>, <a class="reference internal" href="#range.step" title="range.step"><code class="xref py py-attr docutils literal"><span class="pre">step</span></code></a> 어트리뷰트를 가질 수 있음에 주의하세요. 예를 들어, <code class="docutils literal"><span class="pre">range(0)</span> <span class="pre">==</span> <span class="pre">range(2,</span> <span class="pre">1,</span> <span class="pre">3)</span></code> 또는 <code class="docutils literal"><span class="pre">range(0,</span> <span class="pre">3,</span> <span class="pre">2)</span> <span class="pre">==</span> <span class="pre">range(0,</span> <span class="pre">4,</span> <span class="pre">2)</span></code>.)</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>시퀀스 ABC를 구현합니다. <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 객체의 포함 검사는 모든 항목을 이터레이트하는 대신 상수 시간으로 수행됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>(객체 아이덴티티에 기반을 두는 대신) 범위 객체가 정의하는 값들의 시퀀스에 기반을 둔 비교를 위해 '==' 와 '!=' 를 정의합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><a class="reference internal" href="#range.start" title="range.start"><code class="xref py py-attr docutils literal"><span class="pre">start</span></code></a>, <a class="reference internal" href="#range.stop" title="range.stop"><code class="xref py py-attr docutils literal"><span class="pre">stop</span></code></a>, <a class="reference internal" href="#range.step" title="range.step"><code class="xref py py-attr docutils literal"><span class="pre">step</span></code></a> 어트리뷰트.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<ul class="last simple">
<li><a class="reference external" href="http://code.activestate.com/recipes/579000/">linspace recipe</a> 에서는 부동 소수점 응용 프로그램에 적합한 범위의 지연된 버전을 구현하는 방법을 보여줍니다.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="text-sequence-type-str">
<span id="textseq"></span><span id="index-26"></span><h2>4.7. 텍스트 시퀀스 형 --- <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a><a class="headerlink" href="#text-sequence-type-str" title="제목 주소">¶</a></h2>
<p>파이썬의 텍스트 데이터는 <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, 또는 <em class="dfn">문자열 (strings)</em>, 객체를 사용하여 처리됩니다. 문자열은 유니코드 코드 포인트의 불변 <a class="reference internal" href="#typesseq"><span class="std std-ref">시퀀스</span></a> 입니다. 문자열 리터럴은 다양한 방법으로 작성됩니다:</p>
<ul class="simple">
<li>작은따옴표: <code class="docutils literal"><span class="pre">'&quot;큰&quot;</span> <span class="pre">따옴표를</span> <span class="pre">담을</span> <span class="pre">수</span> <span class="pre">있습니다'</span></code></li>
<li>큰따옴표: <code class="docutils literal"><span class="pre">&quot;'작은'</span> <span class="pre">따옴표를</span> <span class="pre">담을</span> <span class="pre">수</span> <span class="pre">있습니다&quot;</span></code>.</li>
<li>삼중 따옴표: <code class="docutils literal"><span class="pre">'''세</span> <span class="pre">개의</span> <span class="pre">작은따옴표'''</span></code>, <code class="docutils literal"><span class="pre">&quot;&quot;&quot;세</span> <span class="pre">개의</span> <span class="pre">큰따옴표&quot;&quot;&quot;</span></code></li>
</ul>
<p>삼중 따옴표로 묶인 문자열은 여러 줄에 걸쳐있을 수 있습니다 - 연관된 모든 공백이 문자열 리터럴에 포함됩니다.</p>
<p>단일 표현식의 일부이고 그 들 사이에 공백만 있는 문자열 리터럴은 묵시적으로 단일 문자열 리터럴로 변환됩니다. 즉, <code class="docutils literal"><span class="pre">(&quot;spam</span> <span class="pre">&quot;</span> <span class="pre">&quot;eggs&quot;)</span> <span class="pre">==</span> <span class="pre">&quot;spam</span> <span class="pre">eggs&quot;</span></code>.</p>
<p>지원되는 이스케이프 시퀀스와 대부분의 이스케이프 시퀀스 처리를 비활성화하는 <code class="docutils literal"><span class="pre">r</span></code> (&quot;날&quot;) 접두어를 포함하여 문자열 리터럴의 다양한 형식에 대한 자세한 내용은 <a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">문자열과 바이트열 리터럴</span></a> 을 참조하십시오.</p>
<p>문자열은 <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 생성자를 사용하여 다른 객체로부터 만들어질 수도 있습니다.</p>
<p>별도의 &quot;문자&quot; 형이 없으므로 문자열을 인덱싱하면 길이가 1인 문자열이 생성됩니다. 즉, 비어 있지 않은 문자열 <em>s</em> 의 경우, <code class="docutils literal"><span class="pre">s[0]</span> <span class="pre">==</span> <span class="pre">s[0:1]</span></code> 입니다.</p>
<p id="index-27">또한, 가변 문자열형은 없지만, 여러 단편으로부터 문자열을 효율적으로 구성하는데 <a class="reference internal" href="#str.join" title="str.join"><code class="xref py py-meth docutils literal"><span class="pre">str.join()</span></code></a> 또는 <a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a> 를 사용할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>파이썬 2시리즈와의 하위 호환성을 위해서, <code class="docutils literal"><span class="pre">u</span></code> 접두어가 문자열 리터럴에 다시 한번 허용됩니다. 문자열 리터럴의 의미에 영향을 미치지 않으며 <code class="docutils literal"><span class="pre">r</span></code> 접두사와 결합 될 수 없습니다.</p>
</div>
<span class="target" id="index-28"></span><dl class="class">
<dt id="str">
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=''</em><span class="sig-paren">)</span><a class="headerlink" href="#str" title="정의 주소">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=b''</em>, <em>encoding='utf-8'</em>, <em>errors='strict'</em><span class="sig-paren">)</span></dt>
<dd><p><em>object</em> 의 <a class="reference internal" href="#textseq"><span class="std std-ref">문자열</span></a> 버전을 돌려줍니다. <em>object</em> 가 제공되지 않으면, 빈 문자열을 돌려줍니다. 그렇지 않으면, <code class="docutils literal"><span class="pre">str()</span></code> 의 동작은 <em>encoding</em> 또는 <em>errors</em> 가 주어졌는지에 따라 달라지는데, 다음과 같습니다.</p>
<p><em>encoding</em> 과 <em>errors</em> 모두 주어지지 않으면, <code class="docutils literal"><span class="pre">str(object)</span></code> 는 <a class="reference internal" href="../reference/datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal"><span class="pre">object.__str__()</span></code></a> 를 돌려주는데, <em>object</em> 의 &quot;비형식적&quot; 또는 멋지게 인쇄 가능한 문자열 표현입니다. 문자열 객체의 경우, 이것은 문자열 자신입니다. 만약 <em>object</em> 가 <a class="reference internal" href="../reference/datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal"><span class="pre">__str__()</span></code></a> 메서드를 가지고 있지 않다면, <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a>은 대신 <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-meth docutils literal"><span class="pre">repr(object)</span></code></a> 를 돌려줍니다.</p>
<p id="index-29"><em>encoding</em> 또는 <em>errors</em> 중 적어도 하나가 주어지면, <em>object</em> 는 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> (예, <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 또는 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>) 이어야 합니다. 이 경우, <em>object</em> 가 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> (또는 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>) 객체이면, <code class="docutils literal"><span class="pre">str(bytes,</span> <span class="pre">encoding,</span> <span class="pre">errors)</span></code> 는 <a class="reference internal" href="#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode(encoding,</span> <span class="pre">errors)</span></code></a> 와 동등합니다. 그 이외의 경우, <a class="reference internal" href="#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode()</span></code></a> 호출 전에 버퍼 객체의 하부 바이트열 객체를 얻습니다. 버퍼 객체에 대한 정보는 <a class="reference internal" href="#binaryseq"><span class="std std-ref">바이너리 시퀀스 형 --- bytes, bytearray, memoryview</span></a>와 <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">Buffer Protocol</span></a> 를 보십시오.</p>
<p><em>encoding</em> 또는 <em>errors</em> 인자 없이 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체를 <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> 에 전달하는 것은 비형식적 문자열 표현을 반환하는 첫 번째 상황에 해당합니다 (파이썬 명령행 옵션 <a class="reference internal" href="../using/cmdline.html#cmdoption-b"><code class="xref std std-option docutils literal"><span class="pre">-b</span></code></a> 도 보십시오). 예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Zoot!&#39;</span><span class="p">)</span>
<span class="go">&quot;b&#39;Zoot!&#39;&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">str</span></code> 클래스와 그 메서드에 대한 더 자세한 정보는 <a class="reference internal" href="#textseq"><span class="std std-ref">텍스트 시퀀스 형 --- str</span></a>와 아래의 <a class="reference internal" href="#string-methods"><span class="std std-ref">문자열 메서드</span></a> 섹션을 보십시오. 포맷된 문자열을 출력하려면 <a class="reference internal" href="../reference/lexical_analysis.html#f-strings"><span class="std std-ref">포맷 문자열 리터럴</span></a> 및 <a class="reference internal" href="string.html#formatstrings"><span class="std std-ref">Format String Syntax</span></a> 섹션을 참조하십시오. 또한, <a class="reference internal" href="text.html#stringservices"><span class="std std-ref">Text Processing Services</span></a> 섹션을 보십시오.</p>
</dd></dl>

<div class="section" id="string-methods">
<span id="index-30"></span><span id="id5"></span><h3>4.7.1. 문자열 메서드<a class="headerlink" href="#string-methods" title="제목 주소">¶</a></h3>
<p id="index-31">문자열은 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">공통</span></a> 시퀀스 연산들을 모두 구현하고, 아래에 기술된 추가적인 메서드도 구현합니다.</p>
<p>문자열은 또한 두 가지 스타일의 문자열 포매팅을 지원합니다. 하나는 큰 폭의 유연성과 사용자 지정을 제공하고 (참조 <a class="reference internal" href="#str.format" title="str.format"><code class="xref py py-meth docutils literal"><span class="pre">str.format()</span></code></a>, <a class="reference internal" href="string.html#formatstrings"><span class="std std-ref">Format String Syntax</span></a>, <a class="reference internal" href="string.html#string-formatting"><span class="std std-ref">Custom String Formatting</span></a>을 참조하세요) 다른 하나는 C <code class="docutils literal"><span class="pre">printf</span></code> 스타일에 기반을 두는데, 더 좁은 범위의 형을 처리하고 올바르게 사용하기는 다소 어렵지만, 처리할 수 있는 경우에는 종종 더 빠릅니다 (<a class="reference internal" href="#old-string-formatting"><span class="std std-ref">printf 스타일 문자열 포매팅</span></a>).</p>
<p>표준 라이브러리의 <a class="reference internal" href="text.html#textservices"><span class="std std-ref">Text Processing Services</span></a> 섹션은 다양한 텍스트 관련 유틸리티를 (<a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> 모듈의 정규식 지원을 포함합니다) 제공하는 많은 다른 모듈들을 다룹니다.</p>
<dl class="method">
<dt id="str.capitalize">
<code class="descclassname">str.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.capitalize" title="정의 주소">¶</a></dt>
<dd><p>첫 문자가 대문자이고 나머지가 소문자인 문자열의 복사본을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.casefold">
<code class="descclassname">str.</code><code class="descname">casefold</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.casefold" title="정의 주소">¶</a></dt>
<dd><p>케이스 폴딩 된 문자열을 반환합니다. 케이스 폴딩 된 문자열은 대소문자를 무시한 매칭에 사용될 수 있습니다.</p>
<p>케이스 폴딩은 소문자로 변환하는 것과 비슷하지만 문자열의 모든 케이스 구분을 제거하기 때문에 보다 공격적입니다. 예를 들어, 독일어 소문자 <code class="docutils literal"><span class="pre">'ß'</span></code> 는 <code class="docutils literal"><span class="pre">&quot;ss&quot;</span></code> 와 동등합니다. 이미 소문자이므로 <a class="reference internal" href="#str.lower" title="str.lower"><code class="xref py py-meth docutils literal"><span class="pre">lower()</span></code></a> 는 <code class="docutils literal"><span class="pre">'ß'</span></code> 에 아무런 영향을 미치지 않습니다; <a class="reference internal" href="#str.casefold" title="str.casefold"><code class="xref py py-meth docutils literal"><span class="pre">casefold()</span></code></a> 는 <code class="docutils literal"><span class="pre">&quot;ss&quot;</span></code> 로 변환합니다.</p>
<p>케이스 폴딩 알고리즘은 유니코드 표준의 섹션 3.13 에 설명되어 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.center">
<code class="descclassname">str.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.center" title="정의 주소">¶</a></dt>
<dd><p>길이 <em>width</em> 인 문자열의 가운데에 정렬한 값을 돌려줍니다. 지정된 <em>fillchar</em> (기본값은 ASCII 스페이스)을 사용하여 채웁니다. <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 문자열이 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.count">
<code class="descclassname">str.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.count" title="정의 주소">¶</a></dt>
<dd><p>범위 [<em>start</em>, <em>end</em>] 에서 서브 스트링 <em>sub</em> 가 중첩되지 않고 등장하는 횟수를 돌려줍니다. 선택적 인자 <em>start</em> 와 <em>end</em> 는 슬라이스 표기법으로 해석됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.encode">
<code class="descclassname">str.</code><code class="descname">encode</code><span class="sig-paren">(</span><em>encoding=&quot;utf-8&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#str.encode" title="정의 주소">¶</a></dt>
<dd><p>문자열의 바이트열 객체로 인코딩된 버전을 돌려줍니다. 기본 인코딩은 <code class="docutils literal"><span class="pre">'utf-8'</span></code> 입니다. <em>errors</em> 는 다른 오류 처리 방식을 설정하기 위해 제공될 수 있습니다. <em>errors</em> 의 기본값은 <code class="docutils literal"><span class="pre">'strict'</span></code> 인데, 인코딩 오류가 있으면 <a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> 를 일으키라는 뜻입니다. 다른 가능한 값은 <code class="docutils literal"><span class="pre">'ignore'</span></code>, <code class="docutils literal"><span class="pre">'replace'</span></code>, <code class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></code>, <code class="docutils literal"><span class="pre">'backslashreplace'</span></code> 와 <a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></code></a> 를 통해 등록된 다른 이름들입니다. <a class="reference internal" href="codecs.html#error-handlers"><span class="std std-ref">Error Handlers</span></a>를 보세요. 가능한 인코딩의 목록을 보려면 <a class="reference internal" href="codecs.html#standard-encodings"><span class="std std-ref">Standard Encodings</span></a> 섹션을 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.1으로 변경: </span>키워드 인자 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.endswith">
<code class="descclassname">str.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.endswith" title="정의 주소">¶</a></dt>
<dd><p>문자열이 지정된 <em>suffix</em> 로 끝나면 <code class="docutils literal"><span class="pre">True</span></code> 를 돌려주고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code> 를 돌려줍니다. <em>suffix</em> 는 찾고자 하는 접미사들의 튜플이 될 수도 있습니다. 선택적 <em>start</em> 가 제공되면 그 위치에서 검사를 시작합니다. 선택적 <em>end</em> 를 사용하면 해당 위치에서 비교를 중단합니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.expandtabs">
<code class="descclassname">str.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span><a class="headerlink" href="#str.expandtabs" title="정의 주소">¶</a></dt>
<dd><p>모든 탭 문자들을 현재의 열과 주어진 탭 크기에 따라 하나나 그 이상의 스페이스로 치환한 문자열의 복사본을 돌려줍니다. 탭 위치는 <em>tabsize</em> 문자마다 발생합니다 (기본값은 8이고, 열 0, 8, 16 등에 탭 위치를 지정합니다). 문자열을 확장하기 위해 현재 열이 0으로 설정되고 문자열을 문자 단위로 검사합니다. 문자가 탭 (<code class="docutils literal"><span class="pre">\t</span></code>) 이면, 현재 열이 다음 탭 위치와 같아질 때까지 하나 이상의 스페이스 문자가 삽입됩니다. (탭 문자 자체는 복사되지 않습니다.) 문자가 개행 문자 (<code class="docutils literal"><span class="pre">\n</span></code>) 또는 캐리지 리턴 (<code class="docutils literal"><span class="pre">\r</span></code>) 이면 복사되고 현재 열은 0으로 재설정됩니다. 다른 문자는 변경되지 않고 복사되고 현재 열은 인쇄할 때 문자가 어떻게 표시되는지에 관계없이 1씩 증가합니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
<span class="go">&#39;01      012     0123    01234&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;01  012 0123    01234&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.find">
<code class="descclassname">str.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.find" title="정의 주소">¶</a></dt>
<dd><p>서브 스트링 <em>sub</em> 가 슬라이스 <code class="docutils literal"><span class="pre">s[start:end]</span></code> 내에 등장하는 가장 작은 문자열의 인덱스를 돌려줍니다. 선택적 인자 <em>start</em> 와 <em>end</em> 는 슬라이스 표기법으로 해석됩니다. <em>sub</em> 가 없으면 <code class="docutils literal"><span class="pre">-1</span></code> 을 돌려줍니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p><a class="reference internal" href="#str.find" title="str.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a> 메서드는 <em>sub</em> 의 위치를 ​​알아야 할 경우에만 사용해야 합니다. <em>sub</em> 가 서브 스트링인지 확인하려면 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 연산자를 사용하십시오:</p>
<div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Py&#39;</span> <span class="ow">in</span> <span class="s1">&#39;Python&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.format">
<code class="descclassname">str.</code><code class="descname">format</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#str.format" title="정의 주소">¶</a></dt>
<dd><p>문자열 포맷 연산을 수행합니다. 이 메서드가 호출되는 문자열은 리터럴 텍스트나 중괄호 <code class="docutils literal"><span class="pre">{}</span></code> 로 구분된 치환 필드를 포함할 수 있습니다. 각 치환 필드는 위치 인자의 숫자 인덱스나 키워드 인자의 이름을 가질 수 있습니다. 각 치환 필드를 해당 인자의 문자열 값으로 치환한 문자열의 사본을 돌려줍니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;The sum of 1 + 2 is </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;The sum of 1 + 2 is 3&#39;</span>
</pre></div>
</div>
<p>포맷 문자열에 지정할 수 있는 다양한 포맷 옵션에 대한 설명은 <a class="reference internal" href="string.html#formatstrings"><span class="std std-ref">Format String Syntax</span></a> 을 참조하십시오.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">When formatting a number (<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>
and subclasses) with the <code class="docutils literal"><span class="pre">n</span></code> type (ex: <code class="docutils literal"><span class="pre">'{:n}'.format(1234)</span></code>), the
function sets temporarily the <code class="docutils literal"><span class="pre">LC_CTYPE</span></code> locale to the <code class="docutils literal"><span class="pre">LC_NUMERIC</span></code>
locale to decode <code class="docutils literal"><span class="pre">decimal_point</span></code> and <code class="docutils literal"><span class="pre">thousands_sep</span></code> fields of
<code class="xref c c-func docutils literal"><span class="pre">localeconv()</span></code> if they are non-ASCII or longer than 1 byte, and the
<code class="docutils literal"><span class="pre">LC_NUMERIC</span></code> locale is different than the <code class="docutils literal"><span class="pre">LC_CTYPE</span></code> locale. This
temporary change affects other threads.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6.5으로 변경: </span>When formatting a number with the <code class="docutils literal"><span class="pre">n</span></code> type, the function sets
temporarily the <code class="docutils literal"><span class="pre">LC_CTYPE</span></code> locale to the <code class="docutils literal"><span class="pre">LC_NUMERIC</span></code> locale in some
cases.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.format_map">
<code class="descclassname">str.</code><code class="descname">format_map</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#str.format_map" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">str.format(**mapping)</span></code> 과 비슷하지만, <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>로 복사되지 않고 <code class="docutils literal"><span class="pre">mapping</span></code> 을 직접 사용합니다. 예를 들어 <code class="docutils literal"><span class="pre">mapping</span></code> 이 dict 서브 클래스면 유용합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Default</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">key</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1"> was born in </span><span class="si">{country}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format_map</span><span class="p">(</span><span class="n">Default</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Guido&#39;</span><span class="p">))</span>
<span class="go">&#39;Guido was born in country&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.index">
<code class="descclassname">str.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.index" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#str.find" title="str.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a> 과 비슷하지만, 서브 스트링을 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.isalnum">
<code class="descclassname">str.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isalnum" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 문자가 알파벳과 숫자이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 문자 <code class="docutils literal"><span class="pre">c</span></code> 는 다음 중 하나가 <code class="docutils literal"><span class="pre">True</span></code> 를 반환하면 알파벳이거나 숫자입니다: <code class="docutils literal"><span class="pre">c.isalpha()</span></code>, <code class="docutils literal"><span class="pre">c.isdecimal()</span></code>, <code class="docutils literal"><span class="pre">c.isdigit()</span></code>, <code class="docutils literal"><span class="pre">c.isnumeric()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="str.isalpha">
<code class="descclassname">str.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isalpha" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 문자가 알파벳이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 알파벳 문자는 유니코드 문자 데이터베이스에서 &quot;Letter&quot;로 정의된 문자입니다. 즉, 일반 범주 속성이 &quot;Lm&quot;, &quot;Lt&quot;, &quot;Lu&quot;, &quot;Ll&quot;, &quot;Lo&quot; 중 하나인 문자입니다. 이것은 유니코드 표준에서 정의된 &quot;Alphabetic&quot; 속성과 다름에 주의하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="str.isdecimal">
<code class="descclassname">str.</code><code class="descname">isdecimal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isdecimal" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 문자가 십진수 문자이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 십진수 문자는 십진법으로 숫자를 구성할 때 사용될 수 있는 문자들입니다. 예를 들어, U+0660, ARABIC-INDIC DIGIT ZERO. 형식적으로 십진수 문자는 유니코드 일반 범주 &quot;Nd&quot; 에 속하는 문자입니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.isdigit">
<code class="descclassname">str.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isdigit" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 문자가 디짓이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 디짓에는 십진수 문자와 호환성 위 첨자 숫자와 같은 특수 처리가 필요한 숫자가 포함됩니다. 여기에는 카로슈티 숫자처럼 십진법으로 숫자를 구성할 때 사용될 수 없는 것들이 포함됩니다. 형식적으로, 디짓은 속성값이 Numeric_Type=Digit 또는 Numeric_Type=Decimal인 문자입니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.isidentifier">
<code class="descclassname">str.</code><code class="descname">isidentifier</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isidentifier" title="정의 주소">¶</a></dt>
<dd><p>문자열이 섹션 section <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">식별자와 키워드</span></a> 의 언어 정의에 따른 유효한 식별자면 참을 돌려줍니다.</p>
<p><a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal"><span class="pre">def</span></code></a> 나 <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a>와 같은 예약 식별자를 검사하려면 <a class="reference internal" href="keyword.html#keyword.iskeyword" title="keyword.iskeyword"><code class="xref py py-func docutils literal"><span class="pre">keyword.iskeyword()</span></code></a> 를 사용하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="str.islower">
<code class="descclassname">str.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.islower" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 케이스 문자가 <a class="footnote-reference" href="#id15" id="id6">[4]</a> 소문자이고, 적어도 하나의 케이스 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.isnumeric">
<code class="descclassname">str.</code><code class="descname">isnumeric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isnumeric" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 문자가 숫자이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 숫자는 디짓과 유니코드 숫자 값 속성을 갖는 모든 문자를 포함합니다. 예를 들어, U+2155, VULGAR FRACTION ONE FIFTH. 형식적으로, 숫자는 속성 값이 Numeric_Type=Digit, Numeric_Type=Decimal, Numeric_Type=Numeric인 문자입니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.isprintable">
<code class="descclassname">str.</code><code class="descname">isprintable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isprintable" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 문자가 인쇄할 수 있거나 문자열이 비어있으면 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 인쇄할 수 없는 문자는 유니코드 문자 데이터베이스에 &quot;Other&quot; 또는 &quot;Separator&quot;로 정의된 문자입니다. ASCII 스페이스 (0x20) 는 예외인데, 인쇄 가능한 것으로 간주합니다. (이 문맥에서, 인쇄 가능한 문자는 문자열에 <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 을 호출했을 때 이스케이프 되지 않아야 하는 것들입니다. <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a> 또는 <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></code></a> 로 출력되는 문자열의 처리에 영향을 주지 않습니다.)</p>
</dd></dl>

<dl class="method">
<dt id="str.isspace">
<code class="descclassname">str.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isspace" title="정의 주소">¶</a></dt>
<dd><p>문자열 내에 공백 문자만 있고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 공백 문자는 유니코드 문자 데이터베이스에서 &quot;Other&quot; 나 &quot;Separator&quot;로 정의되고 양방향 속성이 &quot;WS&quot;, &quot;B&quot;, &quot;S&quot; 중 하나인 문자입니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.istitle">
<code class="descclassname">str.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.istitle" title="정의 주소">¶</a></dt>
<dd><p>문자열이 제목 케이스 문자열이고 하나 이상의 문자가 있는 경우 참을 돌려줍니다. 예를 들어 대문자 앞에는 케이스 없는 문자만 올 수 있고 소문자는 케이스 문자 뒤에만 올 수 있습니다. 그렇지 않은 경우는 거짓을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.isupper">
<code class="descclassname">str.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isupper" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 케이스 문자가 <a class="footnote-reference" href="#id15" id="id7">[4]</a> 대문자이고, 적어도 하나의 케이스 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.join">
<code class="descclassname">str.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#str.join" title="정의 주소">¶</a></dt>
<dd><p><em>iterable</em> 의 문자열들을 이어 붙인 문자열을 돌려줍니다. <em>iterable</em> 에 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체나 기타 문자열이 아닌 값이 있으면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 를 일으킵니다. 요소들 사이의 구분자는 이 메서드를 제공하는 문자열입니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.ljust">
<code class="descclassname">str.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.ljust" title="정의 주소">¶</a></dt>
<dd><p>왼쪽으로 정렬된 문자열을 길이 <em>width</em> 인 문자열로 돌려줍니다. 지정된 <em>fillchar</em> (기본값은 ASCII 스페이스)을 사용하여 채웁니다. <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 문자열이 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.lower">
<code class="descclassname">str.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.lower" title="정의 주소">¶</a></dt>
<dd><p>모든 케이스 문자 <a class="footnote-reference" href="#id15" id="id8">[4]</a> 가 소문자로 변환된 문자열의 복사본을 돌려줍니다.</p>
<p>사용되는 소문자 변환 알고리즘은 유니코드 표준의 섹션 3.13에 설명되어 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.lstrip">
<code class="descclassname">str.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.lstrip" title="정의 주소">¶</a></dt>
<dd><p>선행 문자가 제거된 문자열의 복사본을 돌려줍니다. <em>chars</em> 인자는 제거할 문자 집합을 지정하는 문자열입니다. 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이라면, <em>chars</em> 인자의 기본값은 공백을 제거하도록 합니다. <em>chars</em> 인자는 접두사가 아닙니다; 모든 값 조합이 제거됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">&#39;spacious   &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">&#39;example.com&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="str.maketrans">
<em class="property">static </em><code class="descclassname">str.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>x</em><span class="optional">[</span>, <em>y</em><span class="optional">[</span>, <em>z</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.maketrans" title="정의 주소">¶</a></dt>
<dd><p>이 정적 메서드는 <a class="reference internal" href="#str.translate" title="str.translate"><code class="xref py py-meth docutils literal"><span class="pre">str.translate()</span></code></a> 에 사용할 수 있는 변환표를 돌려줍니다.</p>
<p>인자가 하나만 있으면 유니코드 포인트 (정수) 또는 문자 (길이가 1인 문자열)를 유니코드 포인트, 문자열 (임의 길이) 또는 <code class="docutils literal"><span class="pre">None</span></code> 으로 매핑하는 딕셔너리여야 합니다. 문자 키는 유니코드 포인트로 변환됩니다.</p>
<p>인자가 두 개면 길이가 같은 문자열이어야 하며, 결과 딕셔너리에서, x의 각 문자는 y의 같은 위치에 있는 문자로 대응됩니다. 세 번째의 인자가 있는 경우, 문자열이어야 하는데 각 문자가 <code class="docutils literal"><span class="pre">None</span></code> 으로 대응되는 결과를 줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.partition">
<code class="descclassname">str.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#str.partition" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 가 처음 나타나는 위치에서 문자열을 나누고, 구분자 앞에 있는 부분, 구분자 자체, 구분자 뒤에 오는 부분으로 구성된 3-튜플을 돌려줍니다. 구분자가 발견되지 않으면, 문자열 자신과 그 뒤를 따르는 두 개의 빈 문자열로 구성된 3-튜플을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.replace">
<code class="descclassname">str.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.replace" title="정의 주소">¶</a></dt>
<dd><p>모든 서브 스트링 <em>old</em> 가 <em>new</em> 로 치환된 문자열의 복사본을 돌려줍니다. 선택적 인자 <em>count</em> 가 주어지면, 앞의 <em>count</em> 개만 치환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.rfind">
<code class="descclassname">str.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rfind" title="정의 주소">¶</a></dt>
<dd><p>서브 스트링 <em>sub</em> 가 <code class="docutils literal"><span class="pre">s[start:end]</span></code> 내에 등장하는 가장 큰 문자열의 인덱스를 돌려줍니다. 선택적 인자 <em>start</em> 와 <em>end</em> 는 슬라이스 표기법으로 해석됩니다. 실패하면 <code class="docutils literal"><span class="pre">-1</span></code> 을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.rindex">
<code class="descclassname">str.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rindex" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#str.rfind" title="str.rfind"><code class="xref py py-meth docutils literal"><span class="pre">rfind()</span></code></a>와 비슷하지만, 서브 스트링 <em>sub</em> 를 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.rjust">
<code class="descclassname">str.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rjust" title="정의 주소">¶</a></dt>
<dd><p>오른쪽으로 정렬된 문자열을 길이 <em>width</em> 인 문자열로 돌려줍니다. 지정된 <em>fillchar</em> (기본값은 ASCII 스페이스)을 사용하여 채웁니다. <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 문자열이 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.rpartition">
<code class="descclassname">str.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#str.rpartition" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 가 마지막으로 나타나는 위치에서 문자열을 나누고, 구분자 앞에 있는 부분, 구분자 자체, 구분자 뒤에 오는 부분으로 구성된 3-튜플을 돌려줍니다. 구분자가 발견되지 않으면, 두 개의 빈 문자열과 그 뒤를 따르는 문자열 자신으로 구성된 3-튜플을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.rsplit">
<code class="descclassname">str.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#str.rsplit" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를 돌려줍니다. <em>maxsplit</em> 이 주어지면 가장 오른쪽에서 최대 <em>maxsplit</em> 번의 분할이 수행됩니다. <em>sep</em> 이 지정되지 않거나 <code class="docutils literal"><span class="pre">None</span></code> 이면, 구분자로 모든 공백 문자가 사용됩니다. 오른쪽에서 분리하는 것을 제외하면, <a class="reference internal" href="#str.rsplit" title="str.rsplit"><code class="xref py py-meth docutils literal"><span class="pre">rsplit()</span></code></a>는 아래에서 자세히 설명될 <a class="reference internal" href="#str.split" title="str.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a>처럼 동작합니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.rstrip">
<code class="descclassname">str.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rstrip" title="정의 주소">¶</a></dt>
<dd><p>후행 문자가 제거된 문자열의 복사본을 돌려줍니다. <em>chars</em> 인자는 제거할 문자 집합을 지정하는 문자열입니다. 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이라면, <em>chars</em> 인자의 기본값은 공백을 제거하도록 합니다. <em>chars</em> 인자는 접미사가 아닙니다; 모든 값 조합이 제거됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">&#39;   spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;mississippi&#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;ipz&#39;</span><span class="p">)</span>
<span class="go">&#39;mississ&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.split">
<code class="descclassname">str.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#str.split" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를 돌려줍니다. <em>maxsplit</em> 이 주어지면 최대 <em>maxsplit</em> 번의 분할이 수행됩니다 (따라서, 리스트는 최대 <code class="docutils literal"><span class="pre">maxsplit+1</span></code> 개의 요소를 가지게 됩니다). <em>maxsplit</em> 이 지정되지 않았거나 <code class="docutils literal"><span class="pre">-1</span></code> 이라면 분할 수에 제한이 없습니다 (가능한 모든 분할이 만들어집니다).</p>
<p><em>sep</em> 이 주어지면, 연속된 구분자는 묶이지 않고 빈 문자열을 구분하는 것으로 간주합니다 (예를 들어, <code class="docutils literal"><span class="pre">'1,,2'.split(',')</span></code> 는 <code class="docutils literal"><span class="pre">['1',</span> <span class="pre">'',</span> <span class="pre">'2']</span></code> 를 돌려줍니다). <em>sep</em> 인자는 여러 문자로 구성될 수 있습니다 (예를 들어, <code class="docutils literal"><span class="pre">'1&lt;&gt;2&lt;&gt;3'.split('&lt;&gt;')</span></code> 는 <code class="docutils literal"><span class="pre">['1',</span> <span class="pre">'2',</span> <span class="pre">'3']</span></code> 를 돌려줍니다). 지정된 구분자로 빈 문자열을 나누면 <code class="docutils literal"><span class="pre">['']</span></code> 를 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2,3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,,3,&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;&#39;, &#39;3&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p><em>sep</em> 이 지정되지 않거나 <code class="docutils literal"><span class="pre">None</span></code> 이면, 다른 분할 알고리즘이 적용됩니다: 연속된 공백 문자는 단일한 구분자로 간주하고, 문자열이 선행이나 후행 공백을 포함해도 결과는 시작과 끝에 빈 문자열을 포함하지 않습니다. 결과적으로, 빈 문자열이나 공백만으로 구성된 문자열을 <code class="docutils literal"><span class="pre">None</span></code> 구분자로 나누면 <code class="docutils literal"><span class="pre">[]</span></code> 를 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2 3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   1   2   3   &#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="index-32"></span><dl class="method">
<dt id="str.splitlines">
<code class="descclassname">str.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><span class="optional">[</span><em>keepends</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.splitlines" title="정의 주소">¶</a></dt>
<dd><p>줄 경계에서 나눈 문자열의 줄 리스트를 돌려줍니다. <em>keepends</em> 가 참으로 주어지지 않는 한 결과 리스트에 줄 바꿈은 포함되지 않습니다.</p>
<p>이 메서드는 다음 줄 경계에서 나눕니다. 특히, 경계는 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">유니버설 줄 넘김</span></a> 을 포함합니다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">표현</th>
<th class="head">설명</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\n</span></code></td>
<td>줄 넘김</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\r</span></code></td>
<td>캐리지 리턴</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\r\n</span></code></td>
<td>캐리지 리턴 + 줄 넘김</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\v</span></code> 또는 <code class="docutils literal"><span class="pre">\x0b</span></code></td>
<td>수직 탭</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\f</span></code> 또는 <code class="docutils literal"><span class="pre">\x0c</span></code></td>
<td>폼 피드</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\x1c</span></code></td>
<td>파일 구분자</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\x1d</span></code></td>
<td>그룹 구분자</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\x1e</span></code></td>
<td>레코드 구분자</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\x85</span></code></td>
<td>다음 줄 (C1 제어 코드)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\u2028</span></code></td>
<td>줄 구분자</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\u2029</span></code></td>
<td>문단 구분자</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><code class="docutils literal"><span class="pre">\v</span></code> 와 <code class="docutils literal"><span class="pre">\f</span></code> 를 줄 경계 목록에 추가했습니다.</p>
</div>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[&#39;ab c&#39;, &#39;&#39;, &#39;de fg&#39;, &#39;kl&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[&#39;ab c\n&#39;, &#39;\n&#39;, &#39;de fg\r&#39;, &#39;kl\r\n&#39;]</span>
</pre></div>
</div>
<p>구분자 문자열 <em>sep</em> 이 주어졌을 때 <a class="reference internal" href="#str.split" title="str.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> 와 달리, 이 메서드는 빈 문자열에 대해서 빈 리스트를 돌려주고, 마지막 줄 바꿈은 새 줄을 만들지 않습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;One line</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[&#39;One line&#39;]</span>
</pre></div>
</div>
<p>비교해 보면, <code class="docutils literal"><span class="pre">split('\n')</span></code> 는 이렇게 됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Two lines</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;Two lines&#39;, &#39;&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.startswith">
<code class="descclassname">str.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.startswith" title="정의 주소">¶</a></dt>
<dd><p>문자열이 지정된 <em>prefix</em> 로 시작하면 <code class="docutils literal"><span class="pre">True</span></code> 를 돌려주고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code> 를 돌려줍니다. <em>prefix</em> 는 찾고자 하는 접두사들의 튜플이 될 수도 있습니다. 선택적 <em>start</em> 가 제공되면 그 위치에서 검사를 시작합니다. 선택적 <em>end</em> 를 사용하면 해당 위치에서 비교를 중단합니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.strip">
<code class="descclassname">str.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.strip" title="정의 주소">¶</a></dt>
<dd><p>선행과 후행 문자가 제거된 문자열의 복사본을 돌려줍니다. <em>chars</em> 인자는 제거할 문자 집합을 지정하는 문자열입니다. 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이라면, <em>chars</em> 인자의 기본값은 공백을 제거하도록 합니다. <em>chars</em> 인자는 접두사나 접미사가 아닙니다; 모든 값 조합이 제거됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">&#39;spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">&#39;example&#39;</span>
</pre></div>
</div>
<p>가장 바깥쪽의 선행 또는 후행 <em>chars</em> 인자 값들이 문자열에서 제거됩니다. 문자는 <em>chars</em> 에 있는 문자 집합에 포함되지 않은 문자에 도달할 때까지 맨 앞에서 제거됩니다. 끝에서도 유사한 동작이 수행됩니다. 예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">comment_string</span> <span class="o">=</span> <span class="s1">&#39;#....... Section 3.2.1 Issue #32 .......&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comment_string</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;.#! &#39;</span><span class="p">)</span>
<span class="go">&#39;Section 3.2.1 Issue #32&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.swapcase">
<code class="descclassname">str.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.swapcase" title="정의 주소">¶</a></dt>
<dd><p>대문자를 소문자로, 그 반대로 마찬가지로 변환 한 문자열의 복사본을 돌려줍니다. <code class="docutils literal"><span class="pre">s.swapcase().swapcase()</span> <span class="pre">==</span> <span class="pre">s</span></code> 가 반드시 성립하지 않음에 주의하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="str.title">
<code class="descclassname">str.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.title" title="정의 주소">¶</a></dt>
<dd><p>단어가 대문자로 시작하고 나머지 문자는 소문자가 되도록 문자열의 제목 케이스 버전을 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>이 알고리즘은 단어를 글자들의 연속으로 보는 간단한 언어 독립적 정의를 사용합니다. 이 정의는 여러 상황에서 작동하지만, 축약과 소유의 아포스트로피가 단어 경계를 형성한다는 것을 의미하고, 이는 원하는 결과가 아닐 수도 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;they&#39;re bill&#39;s friends from the UK&quot;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">&quot;They&#39;Re Bill&#39;S Friends From The Uk&quot;</span>
</pre></div>
</div>
<p>정규식을 사용하여 아포스트로피에 대한 해결 방법을 구성할 수 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">titlecase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[A-Za-z]+(&#39;[A-Za-z]+)?&quot;</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="k">lambda</span> <span class="n">mo</span><span class="p">:</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span>
<span class="gp">... </span>                             <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
<span class="gp">... </span>                  <span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">titlecase</span><span class="p">(</span><span class="s2">&quot;they&#39;re bill&#39;s friends.&quot;</span><span class="p">)</span>
<span class="go">&quot;They&#39;re Bill&#39;s Friends.&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.translate">
<code class="descclassname">str.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em><span class="sig-paren">)</span><a class="headerlink" href="#str.translate" title="정의 주소">¶</a></dt>
<dd><p>각 문자를 지정된 변환표를 사용해 매핑한 문자열의 복사본을 돌려줍니다. table은 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> 을 통한 인덱싱을 구현하는 객체여야 하는데, 보통 <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">매핑</span></a> 이나 <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">시퀀스</span></a> 입니다. 유니코드 포인트 (정수)로 인덱싱할 때, table 객체는 다음 중 하나를 수행할 수 있습니다: 그 문자를 하나 이상의 다른 문자들로 매핑하기 위해 유니코드 포인트나 문자열을 돌려줍니다; 결과 문자열에서 그 문자를 제거하기 위해 <code class="docutils literal"><span class="pre">None</span></code> 을 돌려줍니다; 그 문자를 자기 자신으로 매핑하기 위해 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a> 예외를 일으킵니다.</p>
<p><a class="reference internal" href="#str.maketrans" title="str.maketrans"><code class="xref py py-meth docutils literal"><span class="pre">str.maketrans()</span></code></a> 를 사용하여 다른 형식의 문자 대 문자 매핑으로 부터 변환 맵을 만들 수 있습니다.</p>
<p>커스텀 문자 매핑에 대한 보다 유연한 접근법은 <a class="reference internal" href="codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a> 모듈을 참고하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="str.upper">
<code class="descclassname">str.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.upper" title="정의 주소">¶</a></dt>
<dd><p>모든 케이스 문자 <a class="footnote-reference" href="#id15" id="id9">[4]</a> 가 대문자로 변환된 문자열의 복사본을 돌려줍니다. <code class="docutils literal"><span class="pre">s</span></code> 가 케이스 없는 문자를 포함하거나 결과 문자의 유니코드 범주가 &quot;Lu&quot; (Letter, 대문자) 가 아닌 경우, 예를 들어 &quot;Lt&quot; (Letter, 제목 케이스), <code class="docutils literal"><span class="pre">str.upper().isupper()</span></code> 가 <code class="docutils literal"><span class="pre">False</span></code> 일 수 있음에 주의하십시오.</p>
<p>사용되는 대문자 변환 알고리즘은 유니코드 표준의 섹션 3.13에 설명되어 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.zfill">
<code class="descclassname">str.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#str.zfill" title="정의 주소">¶</a></dt>
<dd><p>길이가 <em>width</em> 인 문자열을 만들기 위해 ASCII <code class="docutils literal"><span class="pre">'0'</span></code> 문자를 왼쪽에 채운 문자열의 복사본을 돌려줍니다. 선행 부호 접두어(<code class="docutils literal"><span class="pre">'+'</span></code>/<code class="docutils literal"><span class="pre">'-'</span></code>)는 부호 문자의 앞이 아니라 <em>뒤</em> 에 채워 넣는 것으로 처리됩니다. <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 문자열을 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;00042&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;-42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;-0042&#39;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="printf-style-string-formatting">
<span id="old-string-formatting"></span><h3>4.7.2. <code class="docutils literal"><span class="pre">printf</span></code> 스타일 문자열 포매팅<a class="headerlink" href="#printf-style-string-formatting" title="제목 주소">¶</a></h3>
<div class="admonition note" id="index-33">
<p class="first admonition-title">주석</p>
<p class="last">여기에 설명된 포맷 연산은 여러 가지 일반적인 오류를 (예를 들어 튜플과 딕셔너리를 올바르게 표시하지 못하는 것) 유발하는 다양한 문제점들이 있습니다. 새 <a class="reference internal" href="../reference/lexical_analysis.html#f-strings"><span class="std std-ref">포맷 문자열 리터럴</span></a> 나 <a class="reference internal" href="#str.format" title="str.format"><code class="xref py py-meth docutils literal"><span class="pre">str.format()</span></code></a> 인터페이스를 사용하면 이러한 오류를 피할 수 있습니다. 이 대안들은 또한 텍스트 포매팅에 더욱 강력하고 유연하며 확장 가능한 접근법을 제공합니다.</p>
</div>
<p>문자열 객체는 한가지 고유한 내장 연산을 갖고 있습니다: <code class="docutils literal"><span class="pre">%</span></code> 연산자 (모듈로). 이것은 문자열 <em>포매팅</em> 또는 <em>치환</em> 연산자라고도 합니다. <code class="docutils literal"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">values</span></code> 가 주어질 때 (<em>format</em> 은 문자열입니다), <em>format</em> 내부의 <code class="docutils literal"><span class="pre">%</span></code> 변환 명세는 0개 이상의 <em>values​​</em> 의 요소로 대체됩니다. 이 효과는 C 언어에서 <code class="xref c c-func docutils literal"><span class="pre">sprintf()</span></code>를 사용하는 것과 비슷합니다.</p>
<p><em>format</em> 이 하나의 인자를 요구하면, <em>values​​</em> 는 하나의 비 튜플 객체 일 수 있습니다. <a class="footnote-reference" href="#id16" id="id10">[5]</a> 그렇지 않으면, <em>values​​</em> 는 format 문자열이 지정하는 항목의 수와 같은 튜플이거나 단일 매핑 객체 (예를 들어, 딕셔너리) 이어야 합니다.</p>
<p>변환 명세는 두 개 이상의 문자를 포함하며 다음과 같은 구성 요소들을 포함하는데, 반드시 이 순서대로 나와야 합니다:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">'%'</span></code> 문자: 명세의 시작을 나타냅니다.</li>
<li>매핑 키 (선택 사항): 괄호로 둘러싸인 문자들의 시퀀스로 구성됩니다 (예를 들어, <code class="docutils literal"><span class="pre">(somename)</span></code>).</li>
<li>변환 플래그 (선택 사항): 일부 변환 유형의 결과에 영향을 줍니다.</li>
<li>최소 필드 폭 (선택 사항): <code class="docutils literal"><span class="pre">'*'</span></code> (애스터리스크) 로 지정하면, 실제 폭은 <em>values</em> 튜플의 다음 요소에서 읽히고, 변환할 객체는 최소 필드 폭과 선택적 정밀도 뒤에 옵니다.</li>
<li>정밀도 (선택 사항): <code class="docutils literal"><span class="pre">'.'</span></code> (점) 다음에 정밀도가 옵니다. <code class="docutils literal"><span class="pre">'*'</span></code> (애스터리스크) 로 지정하면, 실제 정밀도는 <em>values</em> 튜플의 다음 요소에서 읽히고, 변환할 값은 정밀도 뒤에 옵니다.</li>
<li>길이 수정자 (선택 사항).</li>
<li>변환 유형.</li>
</ol>
<p>오른쪽 인자가 딕셔너리 (또는 다른 매핑 형) 인 경우, 문자열에 있는 변환 명세는 <em>반드시</em> <code class="docutils literal"><span class="pre">'%'</span></code> 문자 바로 뒤에 그 딕셔너리의 매핑 키를 괄호로 둘러싼 형태로 포함해야 합니다. 매핑 키는 포맷할 값을 매핑으로 부터 선택합니다. 예를 들어:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(language)s</span><span class="s1"> has </span><span class="si">%(number)03d</span><span class="s1"> quote types.&#39;</span> <span class="o">%</span>
<span class="gp">... </span>      <span class="p">{</span><span class="s1">&#39;language&#39;</span><span class="p">:</span> <span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">Python has 002 quote types.</span>
</pre></div>
</div>
<p>이 경우 <code class="docutils literal"><span class="pre">*</span></code> 지정자를 사용할 수 없습니다 (순차적인 파라미터 목록이 필요하기 때문입니다).</p>
<p>변환 플래그 문자는 다음과 같습니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">플래그</th>
<th class="head">뜻</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'#'</span></code></td>
<td>값 변환에 &quot;대체 형식&quot; (아래에 정의되어있습니다) 을 사용합니다.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'0'</span></code></td>
<td>변환은 숫자 값의 경우 0으로 채웁니다.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'-'</span></code></td>
<td>변환된 값은 왼쪽으로 정렬됩니다 (둘 다 주어지면 <code class="docutils literal"><span class="pre">'0'</span></code> 변환보다 우선 합니다).</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></code></td>
<td>(스페이스) 부호 있는 변환 때문에 만들어진 양수 앞에 빈칸을 남겨둡니다 (음수면 빈 문자열입니다).</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'+'</span></code></td>
<td>부호 문자 (<code class="docutils literal"><span class="pre">'+'</span></code> or <code class="docutils literal"><span class="pre">'-'</span></code>) 가 변환 앞에 놓입니다 (<code class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></code> 플래그에 우선합니다).</td>
</tr>
</tbody>
</table>
<p>길이 수정자 (<code class="docutils literal"><span class="pre">h</span></code>, <code class="docutils literal"><span class="pre">l</span></code>, <code class="docutils literal"><span class="pre">L</span></code>) 를 제공할 수는 있지만, 파이썬에서 필요하지 않기 때문에 무시됩니다 -- 예를 들어 <code class="docutils literal"><span class="pre">%ld</span></code> 는 <code class="docutils literal"><span class="pre">%d</span></code> 와 같습니다.</p>
<p>변환 유형은 다음과 같습니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="74%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">변환</th>
<th class="head">뜻</th>
<th class="head">노트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'d'</span></code></td>
<td>부호 있는 정수 십진 표기.</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'i'</span></code></td>
<td>부호 있는 정수 십진 표기.</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'o'</span></code></td>
<td>부호 있는 8진수 값.</td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'u'</span></code></td>
<td>쓸데없는 유형 -- <code class="docutils literal"><span class="pre">'d'</span></code> 와 같습니다.</td>
<td>(6)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'x'</span></code></td>
<td>부호 있는 16진수 (소문자).</td>
<td>(2)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'X'</span></code></td>
<td>부호 있는 16진수 (대문자).</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'e'</span></code></td>
<td>부동 소수점 지수 형식 (소문자).</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'E'</span></code></td>
<td>부동 소수점 지수 형식 (대문자).</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'f'</span></code></td>
<td>부동 소수점 십진수 형식.</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'F'</span></code></td>
<td>부동 소수점 십진수 형식.</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'g'</span></code></td>
<td>부동 소수점 형식. 지수가 -4보다 작거나 정밀도 보다 작지 않으면 소문자 지수형식을 사용하고, 그렇지 않으면 십진수 형식을 사용합니다.</td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'G'</span></code></td>
<td>부동 소수점 형식. 지수가 -4보다 작거나 정밀도 보다 작지 않으면 대문자 지수형식을 사용하고, 그렇지 않으면 십진수 형식을 사용합니다.</td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'c'</span></code></td>
<td>단일 문자 (정수 또는 길이 1인 문자열을 허용합니다).</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'r'</span></code></td>
<td>문자열 (<a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a>을 사용하여 파이썬 객체를 변환합니다).</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'s'</span></code></td>
<td>문자열 (<a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> 을 사용하여 파이썬 객체를 변환합니다).</td>
<td>(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'a'</span></code></td>
<td>문자열 (<a class="reference internal" href="functions.html#ascii" title="ascii"><code class="xref py py-func docutils literal"><span class="pre">ascii()</span></code></a> 를 사용하여 파이썬 객체를 변환합니다).</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'%'</span></code></td>
<td>인자는 변환되지 않고, 결과에 <code class="docutils literal"><span class="pre">'%'</span></code> 문자가 표시됩니다.</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>노트:</p>
<ol class="arabic">
<li><p class="first">대체 형식은 첫 번째 숫자 앞에 선행 8진수 지정자 (<code class="docutils literal"><span class="pre">'0o'</span></code>)를 삽입합니다.</p>
</li>
<li><p class="first">대체 형식은 첫 번째 숫자 앞에 선행 <code class="docutils literal"><span class="pre">'0x'</span></code> 또는 <code class="docutils literal"><span class="pre">'0X'</span></code> (<code class="docutils literal"><span class="pre">'x'</span></code> 나 <code class="docutils literal"><span class="pre">'X'</span></code> 유형 중 어느 것을 사용하느냐에 따라 달라집니다) 를 삽입합니다.</p>
</li>
<li><p class="first">대체 형식은 그 뒤에 숫자가 나오지 않더라도 항상 소수점을 포함합니다.</p>
<p>정밀도는 소수점 이하 자릿수를 결정하며 기본값은 6입니다.</p>
</li>
<li><p class="first">대체 형식은 결과에 항상 소수점을 포함하고 뒤에 오는 0은 제거되지 않습니다.</p>
<p>정밀도는 소수점 앞뒤의 유효 자릿수를 결정하며 기본값은 6입니다.</p>
</li>
<li><p class="first">정밀도가 <code class="docutils literal"><span class="pre">N</span></code> 이라면, 출력은 <code class="docutils literal"><span class="pre">N</span></code> 문자로 잘립니다.</p>
</li>
<li><p class="first"><span class="target" id="index-58"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a>을 참조하세요.</p>
</li>
</ol>
<p>파이썬 문자열은 명시적인 길이를 가지고 있으므로, <code class="docutils literal"><span class="pre">%s</span></code> 변환은 문자열의 끝이 <code class="docutils literal"><span class="pre">'\0'</span></code> 이라고 가정하지 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.1으로 변경: </span>절댓값이 1e50 을 넘는 숫자에 대한 <code class="docutils literal"><span class="pre">%f</span></code> 변환은 더는 <code class="docutils literal"><span class="pre">%g</span></code> 변환으로 대체되지 않습니다.</p>
</div>
</div>
</div>
<div class="section" id="binary-sequence-types-bytes-bytearray-memoryview">
<span id="binaryseq"></span><span id="index-35"></span><h2>4.8. 바이너리 시퀀스 형 --- <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>, <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a><a class="headerlink" href="#binary-sequence-types-bytes-bytearray-memoryview" title="제목 주소">¶</a></h2>
<p id="index-36">바이너리 데이터를 조작하기 위한 핵심 내장형은 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 와 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 입니다. 이것들은 <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> 에 의해 지원되는데, 다른 바이너리 객체들의 메모리에 복사 없이 접근하기 위해 <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">버퍼 프로토콜</span></a> 을 사용합니다.</p>
<p><a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal"><span class="pre">array</span></code></a> 모듈은 32-비트 정수와 IEEE754 배정도 부동 소수점 같은 기본 데이터형의 효율적인 저장을 지원합니다.</p>
<div class="section" id="bytes-objects">
<span id="typebytes"></span><h3>4.8.1. 바이트열 객체<a class="headerlink" href="#bytes-objects" title="제목 주소">¶</a></h3>
<p id="index-37">바이트열 객체는 단일 바이트들의 불변 시퀀스입니다. 많은 주요 바이너리 프로토콜이 ASCII 텍스트 인코딩을 기반으로 하므로, 바이트열 객체는 ASCII 호환 데이터로 작업 할 때만 유효한 여러 가지 메서드를 제공하며 다양한 다른 방법으로 문자열 객체와 밀접한 관련이 있습니다.</p>
<dl class="class">
<dt id="bytes">
<em class="property">class </em><code class="descname">bytes</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes" title="정의 주소">¶</a></dt>
<dd><p>첫째로, 바이트열 리터럴의 문법은 문자열 리터럴과 거의 같지만 <code class="docutils literal"><span class="pre">b</span></code> 접두사가 추가된다는 점이 다릅니다.:</p>
<ul class="simple">
<li>작은따옴표: <code class="docutils literal"><span class="pre">b'still</span> <span class="pre">allows</span> <span class="pre">embedded</span> <span class="pre">&quot;double&quot;</span> <span class="pre">quotes'</span></code></li>
<li>큰따옴표: <code class="docutils literal"><span class="pre">b&quot;still</span> <span class="pre">allows</span> <span class="pre">embedded</span> <span class="pre">'single'</span> <span class="pre">quotes&quot;</span></code>.</li>
<li>삼중 따옴표: <code class="docutils literal"><span class="pre">b'''3</span> <span class="pre">single</span> <span class="pre">quotes'''</span></code>, <code class="docutils literal"><span class="pre">b&quot;&quot;&quot;3</span> <span class="pre">double</span> <span class="pre">quotes&quot;&quot;&quot;</span></code></li>
</ul>
<p>바이트열 리터럴에는 ASCII 문자만 허용됩니다 (선언된 소스 코드 인코딩과 관계없습니다). 127 보다 큰 바이너리 값은 적절한 이스케이프 시퀀스를 사용하여 바이트열 리터럴에 입력해야 합니다.</p>
<p>문자열 리터럴의 경우와 마찬가지로 바이트열 리터럴은 이스케이프 시퀀스 처리를 비활성화하기 위해 <code class="docutils literal"><span class="pre">r</span></code> 접두사를 사용할 수도 있습니다. 지원되는 이스케이프 시퀀스를 포함하여 바이트열 리터럴의 다양한 형식에 대한 자세한 내용은 <a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">문자열과 바이트열 리터럴</span></a> 을 참조하십시오.</p>
<p>바이트열 리터럴과 그 표현은 ASCII 텍스트를 기반으로 하지만, 바이트열 객체는 실제로는 정수의 불변 시퀀스처럼 동작하고, 시퀀스의 각 값은 <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> 이 되도록 제한됩니다 (이 제한을 위반하려고 시도하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다). 이것은 많은 바이너리 형식이 ASCII 기반 요소를 포함하고 일부 텍스트 지향 알고리즘으로 유용하게 조작될 수 있지만, 임의의 바이너리 데이터에 일반적으로 적용될 수는 없음을 강조하기 위한 것입니다 (텍스트 처리 알고리즘을 맹목적으로 ASCII 호환이 아닌 바이너리 데이터 형식에 적용하면 대개 데이터 손상으로 이어집니다).</p>
<p>리터럴 형식 외에도, 바이트열 객체는 여러 가지 다른 방법으로 만들 수 있습니다.:</p>
<ul class="simple">
<li>지정된 길이의 0으로 채워진 바이트열 객체: <code class="docutils literal"><span class="pre">bytes(10)</span></code></li>
<li>정수의 이터러블로부터: <code class="docutils literal"><span class="pre">bytes(range(20))</span></code></li>
<li>버퍼 프로토콜을 통해 기존 바이너리 데이터 복사: <code class="docutils literal"><span class="pre">bytes(obj)</span></code></li>
</ul>
<p>내장 <a class="reference internal" href="functions.html#func-bytes"><span class="std std-ref">bytes</span></a> 도 참조하세요.</p>
<p>2개의 16진수는 정확히 하나의 바이트에 대응하기 때문에 16진수는 바이너리 데이터를 설명하는 데 일반적으로 사용되는 형식입니다. 따라서, 바이트열 형은 그 형식의 데이터를 읽는 추가의 클래스 메서드를 갖습니다:</p>
<dl class="classmethod">
<dt id="bytes.fromhex">
<em class="property">classmethod </em><code class="descname">fromhex</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.fromhex" title="정의 주소">¶</a></dt>
<dd><p>이 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 클래스 메서드는 주어진 문자열 객체를 디코딩해서 바이트열 객체를 돌려줍니다. 문자열은 바이트 당 두 개의 16진수가 포함되어야 하며 ASCII 공백은 무시됩니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;2Ef0 F1f2  &#39;</span><span class="p">)</span>
<span class="go">b&#39;.\xf0\xf1\xf2&#39;</span>
</pre></div>
</div>
</dd></dl>

<p>바이트열 객체를 16진수 표현으로 변환하기 위한 역변환 함수가 있습니다.</p>
<dl class="method">
<dt id="bytes.hex">
<code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.hex" title="정의 주소">¶</a></dt>
<dd><p>인스턴스의 바이트마다 2 자릿수의 16진수로 표현한 문자열 객체를 돌려줍니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xf0\xf1\xf2</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;f0f1f2&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<p>바이트열 객체는 정수의 시퀀스(튜플과 유사)이기 때문에, 바이트열 객체 <em>b</em> 에 대해서, <code class="docutils literal"><span class="pre">b[0]</span></code> 는 정수가 됩니다. 반면, <code class="docutils literal"><span class="pre">b[0:1]</span></code> 는 길이 1인 바이트열 객체가 됩니다. (이것은 인덱싱과 슬라이싱 모두 길이 1인 문자열을 생성하는 텍스트 문자열과 대조됩니다)</p>
<p>바이트열 객체의 표현은 리터럴 형식 (<code class="docutils literal"><span class="pre">b'...'</span></code>) 을 사용하는데, 종종 <code class="docutils literal"><span class="pre">bytes([46,</span> <span class="pre">46,</span> <span class="pre">46])</span></code> 보다 유용하기 때문입니다. <code class="docutils literal"><span class="pre">list(b)</span></code> 를 사용하면 바이트열 객체를 항상 정수 리스트로 변환할 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">파이썬 2.x 사용자에게: 파이썬 2.x 시리즈에서는 8-비트 문자열(2.x가 내장 바이너리 데이터형에 제공하는 가장 가까운 것)과 유니코드 문자열 간의 다양한 묵시적 변환이 허용되었습니다. 이는 파이썬이 원래 8-비트 텍스트만 지원했으며 유니코드 텍스트는 나중에 추가된 사실을 반영하는 하위 호환성 해결책입니다. 파이썬 3.x 에서, 이러한 묵시적 변환은 사라졌습니다 - 8-비트 바이너리 데이터와 유니코드 텍스트 간의 변환은 반드시 명시적이어야 하며 바이트열과 문자열 객체는 항상 다르다고 비교됩니다.</p>
</div>
</div>
<div class="section" id="bytearray-objects">
<span id="typebytearray"></span><h3>4.8.2. 바이트 배열 객체<a class="headerlink" href="#bytearray-objects" title="제목 주소">¶</a></h3>
<p id="index-38"><a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 객체는 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체의 가변형입니다.</p>
<dl class="class">
<dt id="bytearray">
<em class="property">class </em><code class="descname">bytearray</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray" title="정의 주소">¶</a></dt>
<dd><p>바이트 배열 객체에 대한 전용 리터럴 문법은 없으며 항상 생성자를 호출하여 만듭니다:</p>
<ul class="simple">
<li>빈 인스턴스 만들기: <code class="docutils literal"><span class="pre">bytearray()</span></code></li>
<li>주어진 길이의 0으로 채워진 인스턴스 만들기: <code class="docutils literal"><span class="pre">bytearray(10)</span></code></li>
<li>정수의 이터러블로부터: <code class="docutils literal"><span class="pre">bytearray(range(20))</span></code></li>
<li>버퍼 프로토콜을 통해 기존 바이너리 데이터 복사: <code class="docutils literal"><span class="pre">bytearray(b'Hi!')</span></code></li>
</ul>
<p>바이트 배열 객체는 가변이기 때문에, <a class="reference internal" href="#bytes-methods"><span class="std std-ref">바이트열 과 바이트 배열 연산</span></a> 에 설명되어있는 공통 바이트열과 바이트 배열 연산에 더해, <a class="reference internal" href="#typesseq-mutable"><span class="std std-ref">가변</span></a> 시퀀스 연산도 지원합니다.</p>
<p>내장 <a class="reference internal" href="functions.html#func-bytearray"><span class="std std-ref">bytearray</span></a> 도 참조하세요.</p>
<p>2개의 16진수는 정확히 하나의 바이트에 대응하기 때문에 16진수는 바이너리 데이터를 설명하는 데 일반적으로 사용되는 형식입니다. 따라서, 바이트 배열형은 그 형식의 데이터를 읽는 추가의 클래스 메서드를 갖습니다:</p>
<dl class="classmethod">
<dt id="bytearray.fromhex">
<em class="property">classmethod </em><code class="descname">fromhex</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.fromhex" title="정의 주소">¶</a></dt>
<dd><p>이 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 클래스 메서드는 주어진 문자열 객체를 디코딩해서 바이트 배열 객체를 돌려줍니다. 문자열은 바이트 당 두 개의 16진수가 포함되어야 하며 ASCII 공백은 무시됩니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;2Ef0 F1f2  &#39;</span><span class="p">)</span>
<span class="go">bytearray(b&#39;.\xf0\xf1\xf2&#39;)</span>
</pre></div>
</div>
</dd></dl>

<p>바이트 배열 객체를 16진수 표현으로 변환하기 위한 역변환 함수가 있습니다.</p>
<dl class="method">
<dt id="bytearray.hex">
<code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.hex" title="정의 주소">¶</a></dt>
<dd><p>인스턴스의 바이트마다 2 자릿수의 16진수로 표현한 문자열 객체를 돌려줍니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xf0\xf1\xf2</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;f0f1f2&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<p>바이트 배열 객체는 정수의 시퀀스(리스트와 유사)이기 때문에, 바이트 배열 객체 <em>b</em> 에 대해서, <code class="docutils literal"><span class="pre">b[0]</span></code> 는 정수가 됩니다. 반면, <code class="docutils literal"><span class="pre">b[0:1]</span></code> 는 길이 1인 바이트 배열 객체가 됩니다. (이것은 인덱싱과 슬라이싱 모두 길이 1인 문자열을 생성하는 텍스트 문자열과 대조됩니다)</p>
<p>바이트 배열 객체의 표현은 바이트열 리터럴 형식 (<code class="docutils literal"><span class="pre">bytearray(b'...')</span></code>) 을 사용하는데, 종종 <code class="docutils literal"><span class="pre">bytearray([46,</span> <span class="pre">46,</span> <span class="pre">46])</span></code> 보다 유용하기 때문입니다. <code class="docutils literal"><span class="pre">list(b)</span></code> 를 사용하면 바이트 배열 객체를 항상 정수 리스트로 변환할 수 있습니다.</p>
</div>
<div class="section" id="bytes-and-bytearray-operations">
<span id="bytes-methods"></span><h3>4.8.3. 바이트열 과 바이트 배열 연산<a class="headerlink" href="#bytes-and-bytearray-operations" title="제목 주소">¶</a></h3>
<p id="index-39">바이트열와 바이트 배열 객체는 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">공통</span></a> 시퀀스 연산을 지원합니다. 이것들은 같은 형의 피연산자뿐만 아니라 모든 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>와 상호 운용됩니다. 이러한 유연성으로 인해, 오류 없이 작업을 자유롭게 혼합할 수 있습니다. 그러나, 결과의 반환형은 피연산자의 순서에 따라 달라질 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p>바이트열 및 바이트 배열 객체의 메서드는 인자로 문자열을 받아들이지 않습니다, 문자열의 메서드가 바이트열을 인자로 허용하지 않는 것과 마찬가지입니다. 예를 들어, 다음과 같이 작성해야 합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;abc&quot;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>그리고:</p>
<div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;abc&quot;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>일부 바이트열 및 바이트 배열 연산은 ASCII 호환 바이너리 형식을 가정하므로, 임의의 바이너리 데이터로 작업 할 때는 피해야 합니다. 이러한 제한 사항은 아래에서 다룹니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이러한 ASCII 기반 연산을 사용하여 ASCII 기반 형식으로 저장되지 않은 바이너리 데이터를 조작하면 데이터가 손상될 수 있습니다.</p>
</div>
<p>바이트열 및 바이트 배열 객체에 대한 다음 메서드는 임의의 바이너리 데이터와 함께 사용할 수 있습니다.</p>
<dl class="method">
<dt id="bytes.count">
<code class="descclassname">bytes.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.count" title="정의 주소">¶</a></dt>
<dt id="bytearray.count">
<code class="descclassname">bytearray.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.count" title="정의 주소">¶</a></dt>
<dd><p>범위 [<em>start</em>, <em>end</em>] 에서 서브 시퀀스 <em>sub</em> 가 중첩되지 않고 등장하는 횟수를 돌려줍니다. 선택적 인자 <em>start</em> 와 <em>end</em> 는 슬라이스 표기법으로 해석됩니다.</p>
<p>검색할 서브 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 또는 0에서 255 사이의 정수일 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>서브 시퀀스로 0에서 255 사이의 정수도 허용합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.decode">
<code class="descclassname">bytes.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>encoding=&quot;utf-8&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.decode" title="정의 주소">¶</a></dt>
<dt id="bytearray.decode">
<code class="descclassname">bytearray.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>encoding=&quot;utf-8&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.decode" title="정의 주소">¶</a></dt>
<dd><p>주어진 바이트열로부터 디코딩된 문자열을 돌려줍니다. 기본 인코딩은 <code class="docutils literal"><span class="pre">'utf-8'</span></code> 입니다. <em>errors</em> 는 다른 오류 처리 방식을 설정하기 위해 제공될 수 있습니다. <em>errors</em> 의 기본값은 <code class="docutils literal"><span class="pre">'strict'</span></code> 인데, 인코딩 오류가 있으면 <a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> 를 일으키라는 뜻입니다. 다른 가능한 값은 <code class="docutils literal"><span class="pre">'ignore'</span></code>, <code class="docutils literal"><span class="pre">'replace'</span></code> 와 <a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></code></a> 를 통해 등록된 다른 이름들입니다. <a class="reference internal" href="codecs.html#error-handlers"><span class="std std-ref">Error Handlers</span></a>를 보세요. 가능한 인코딩의 목록을 보려면 <a class="reference internal" href="codecs.html#standard-encodings"><span class="std std-ref">Standard Encodings</span></a> 섹션을 참조하십시오.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><em>encoding</em> 인자를 <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 에 전달하면 임시 바이트열이나 바이트 배열 객체를 만들 필요 없이 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 를 직접 디코딩할 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.1으로 변경: </span>키워드 인자 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.endswith">
<code class="descclassname">bytes.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.endswith" title="정의 주소">¶</a></dt>
<dt id="bytearray.endswith">
<code class="descclassname">bytearray.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.endswith" title="정의 주소">¶</a></dt>
<dd><p>바이너리 데이터가 지정된 <em>suffix</em> 로 끝나면 <code class="docutils literal"><span class="pre">True</span></code> 를 돌려주고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code> 를 돌려줍니다. <em>suffix</em> 는 찾고자 하는 접미사들의 튜플이 될 수도 있습니다. 선택적 <em>start</em> 가 제공되면 그 위치에서 검사를 시작합니다. 선택적 <em>end</em> 를 사용하면 해당 위치에서 비교를 중단합니다.</p>
<p>검색할 접미사(들)는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.find">
<code class="descclassname">bytes.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.find" title="정의 주소">¶</a></dt>
<dt id="bytearray.find">
<code class="descclassname">bytearray.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.find" title="정의 주소">¶</a></dt>
<dd><p>서브 시퀀스 <em>sub</em> 가 슬라이스 <code class="docutils literal"><span class="pre">s[start:end]</span></code> 내에 등장하는 가장 작은 데이터의 인덱스를 돌려줍니다. 선택적 인자 <em>start</em> 와 <em>end</em> 는 슬라이스 표기법으로 해석됩니다. <em>sub</em> 가 없으면 <code class="docutils literal"><span class="pre">-1</span></code> 을 돌려줍니다.</p>
<p>검색할 서브 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 또는 0에서 255 사이의 정수일 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p><a class="reference internal" href="#bytes.find" title="bytes.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a> 메서드는 <em>sub</em> 의 위치를 ​​알아야 할 경우에만 사용해야 합니다. <em>sub</em> 가 서브 시퀀스인지 여부를 확인하려면 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 연산자를 사용하십시오:</p>
<div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Py&#39;</span> <span class="ow">in</span> <span class="sa">b</span><span class="s1">&#39;Python&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>서브 시퀀스로 0에서 255 사이의 정수도 허용합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.index">
<code class="descclassname">bytes.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.index" title="정의 주소">¶</a></dt>
<dt id="bytearray.index">
<code class="descclassname">bytearray.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.index" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#bytes.find" title="bytes.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a> 과 비슷하지만, 서브 시퀀스를 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
<p>검색할 서브 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 또는 0에서 255 사이의 정수일 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>서브 시퀀스로 0에서 255 사이의 정수도 허용합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.join">
<code class="descclassname">bytes.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.join" title="정의 주소">¶</a></dt>
<dt id="bytearray.join">
<code class="descclassname">bytearray.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.join" title="정의 주소">¶</a></dt>
<dd><p><em>iterable</em> 의 바이너리 데이터 시퀀스들을 이어 붙이기 한 바이트열 또는 바이트 배열 객체를 돌려줍니다. <em>iterable</em> 에 <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 객체나 기타 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 가 아닌 값이 있으면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 를 일으킵니다. 요소들 사이의 구분자는 이 메서드를 제공하는 바이트열 이나 바이트 배열 객체입니다.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="bytes.maketrans">
<em class="property">static </em><code class="descclassname">bytes.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>from</em>, <em>to</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.maketrans" title="정의 주소">¶</a></dt>
<dt id="bytearray.maketrans">
<em class="property">static </em><code class="descclassname">bytearray.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>from</em>, <em>to</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.maketrans" title="정의 주소">¶</a></dt>
<dd><p>이 정적 메서드는 <a class="reference internal" href="#bytes.translate" title="bytes.translate"><code class="xref py py-meth docutils literal"><span class="pre">bytes.translate()</span></code></a> 에 사용할 수 있는 변환표를 돌려주는데, <em>from</em> 에 있는 문자를 <em>to</em> 의 같은 위치에 있는 문자로 매핑합니다; <em>from</em> 과 <em>to</em> 는 모두 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 여야 하고 길이가 같아야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.partition">
<code class="descclassname">bytes.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.partition" title="정의 주소">¶</a></dt>
<dt id="bytearray.partition">
<code class="descclassname">bytearray.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.partition" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 가 처음 나타나는 위치에서 시퀀스를 나누고, 구분자 앞에 있는 부분, 구분자 자체, 구분자 뒤에 오는 부분으로 구성된 3-튜플을 돌려줍니다. 구분자가 발견되지 않으면, 원래 시퀀스의 복사본과 그 뒤를 따르는 두 개의 빈 바이트열 또는 바이트 배열 객체로 구성된 3-튜플을 돌려줍니다.</p>
<p>검색할 구분자는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.replace">
<code class="descclassname">bytes.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.replace" title="정의 주소">¶</a></dt>
<dt id="bytearray.replace">
<code class="descclassname">bytearray.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.replace" title="정의 주소">¶</a></dt>
<dd><p>모든 서브 시퀀스 <em>old</em> 가 <em>new</em> 로 치환된 시퀀스의 복사본을 돌려줍니다. 선택적 인자 <em>count</em> 가 주어지면, 앞의 <em>count</em> 개만 치환됩니다.</p>
<p>검색할 서브 시퀀스와 그 대체물은 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rfind">
<code class="descclassname">bytes.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rfind" title="정의 주소">¶</a></dt>
<dt id="bytearray.rfind">
<code class="descclassname">bytearray.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rfind" title="정의 주소">¶</a></dt>
<dd><p>서브 시퀀스 <em>sub</em> 가 <code class="docutils literal"><span class="pre">s[start:end]</span></code> 내에 등장하는 가장 큰 시퀀스의 인덱스를 돌려줍니다. 선택적 인자 <em>start</em> 와 <em>end</em> 는 슬라이스 표기법으로 해석됩니다. 실패하면 <code class="docutils literal"><span class="pre">-1</span></code> 을 돌려줍니다.</p>
<p>검색할 서브 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 또는 0에서 255 사이의 정수일 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>서브 시퀀스로 0에서 255 사이의 정수도 허용합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rindex">
<code class="descclassname">bytes.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rindex" title="정의 주소">¶</a></dt>
<dt id="bytearray.rindex">
<code class="descclassname">bytearray.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rindex" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#bytes.rfind" title="bytes.rfind"><code class="xref py py-meth docutils literal"><span class="pre">rfind()</span></code></a> 와 비슷하지만, 서브 시퀀스 <em>sub</em> 를 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
<p>검색할 서브 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 또는 0에서 255 사이의 정수일 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>서브 시퀀스로 0에서 255 사이의 정수도 허용합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rpartition">
<code class="descclassname">bytes.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rpartition" title="정의 주소">¶</a></dt>
<dt id="bytearray.rpartition">
<code class="descclassname">bytearray.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rpartition" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 가 마지막으로 나타나는 위치에서 시퀀스를 나누고, 구분자 앞에 있는 부분, 구분자 자체, 구분자 뒤에 오는 부분으로 구성된 3-튜플을 돌려줍니다. 구분자가 발견되지 않으면, 두 개의 빈 바이트열 또는 바이트 배열 객체와 그 뒤를 따르는 원래 시퀀스의 복사본으로 구성된 3-튜플을 돌려줍니다.</p>
<p>검색할 구분자는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.startswith">
<code class="descclassname">bytes.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.startswith" title="정의 주소">¶</a></dt>
<dt id="bytearray.startswith">
<code class="descclassname">bytearray.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.startswith" title="정의 주소">¶</a></dt>
<dd><p>바이너리 데이터가 지정된 <em>prefix</em> 로 시작하면 <code class="docutils literal"><span class="pre">True</span></code> 를 돌려주고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code> 를 돌려줍니다. <em>prefix</em> 는 찾고자 하는 접두사들의 튜플이 될 수도 있습니다. 선택적 <em>start</em> 가 제공되면 그 위치에서 검사를 시작합니다. 선택적 <em>end</em> 를 사용하면 해당 위치에서 비교를 중단합니다.</p>
<p>검색할 접두사(들)는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.translate">
<code class="descclassname">bytes.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em>, <em>delete=b''</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.translate" title="정의 주소">¶</a></dt>
<dt id="bytearray.translate">
<code class="descclassname">bytearray.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em>, <em>delete=b''</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.translate" title="정의 주소">¶</a></dt>
<dd><p>생략 가능한 인자 <em>delete</em> 의 모든 바이트를 제거하고, 나머지 바이트들을 주어진 변환표로 매핑한 바이트열이나 바이트 배열 객체의 복사본을 돌려줍니다. table은 길이 256인 바이트열 객체이어야 합니다.</p>
<p><a class="reference internal" href="#bytes.maketrans" title="bytes.maketrans"><code class="xref py py-func docutils literal"><span class="pre">bytes.maketrans()</span></code></a> 메서드를 사용하여 변환표를 만들 수 있습니다.</p>
<p>문자를 지우기만 하는 변환에는 <em>table</em> 인자를 <code class="docutils literal"><span class="pre">None</span></code> 으로 설정하십시오:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;read this short text&#39;</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;aeiou&#39;</span><span class="p">)</span>
<span class="go">b&#39;rd ths shrt txt&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>이제 <em>delete</em> 는 키워드 인자로 지원됩니다.</p>
</div>
</dd></dl>

<p>바이트열 및 바이트 배열 객체에 대한 다음 메서드는 ASCII 호환 바이너리 형식의 사용을 가정하는 기본 동작을 갖지만, 적절한 인자를 전달하여 임의의 바이너리 데이터와 함께 사용할 수 있습니다. 이 섹션의 바이트 배열 메서드는 모두 제자리에서 작동하지 않고 대신 새로운 객체를 생성함에 주의하십시오.</p>
<dl class="method">
<dt id="bytes.center">
<code class="descclassname">bytes.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.center" title="정의 주소">¶</a></dt>
<dt id="bytearray.center">
<code class="descclassname">bytearray.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.center" title="정의 주소">¶</a></dt>
<dd><p>길이 <em>width</em> 인 시퀀스의 가운데에 정렬한 객체의 복사본을 돌려줍니다. 지정된 <em>fillbyte</em> (기본값은 ASCII 스페이스)를 사용하여 채웁니다. <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체의 경우, <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 시퀀스가 반환됩니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.ljust">
<code class="descclassname">bytes.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.ljust" title="정의 주소">¶</a></dt>
<dt id="bytearray.ljust">
<code class="descclassname">bytearray.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.ljust" title="정의 주소">¶</a></dt>
<dd><p>왼쪽으로 정렬된 객체의 복사본을 길이 <em>width</em> 인 시퀀스로 돌려줍니다. 지정된 <em>fillbyte</em> (기본값은 ASCII 스페이스)을 사용하여 채웁니다. <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체의 경우, <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 시퀀스가 반환됩니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.lstrip">
<code class="descclassname">bytes.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.lstrip" title="정의 주소">¶</a></dt>
<dt id="bytearray.lstrip">
<code class="descclassname">bytearray.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.lstrip" title="정의 주소">¶</a></dt>
<dd><p>선행 바이트가 제거된 시퀀스의 복사본을 돌려줍니다. <em>chars</em> 인자는 제거할 바이트 집합을 지정하는 바이너리 시퀀스입니다 - 이름은 이 메서드가 보통 ASCII 문자와 사용된다는 사실을 반영합니다. 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이라면, <em>chars</em> 인자의 기본값은 ASCII 공백을 제거하도록 합니다. <em>chars</em> 인자는 접두사가 아닙니다; 모든 값 조합이 제거됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">b&#39;spacious   &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">b&#39;example.com&#39;</span>
</pre></div>
</div>
<p>제거할 바이트 값의 바이너리 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rjust">
<code class="descclassname">bytes.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rjust" title="정의 주소">¶</a></dt>
<dt id="bytearray.rjust">
<code class="descclassname">bytearray.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rjust" title="정의 주소">¶</a></dt>
<dd><p>오른쪽으로 정렬된 객체의 복사본을 길이 <em>width</em> 인 시퀀스로 돌려줍니다. 지정된 <em>fillbyte</em> (기본값은 ASCII 스페이스)를 사용하여 채웁니다. <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체의 경우, <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 시퀀스가 반환됩니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rsplit">
<code class="descclassname">bytes.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rsplit" title="정의 주소">¶</a></dt>
<dt id="bytearray.rsplit">
<code class="descclassname">bytearray.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rsplit" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 을 구분자 시퀀스로 사용하여 바이너리 시퀀스를 같은 형의 서브 시퀀스로 나눕니다. <em>maxsplit</em> 이 주어지면 가장 오른쪽에서 최대 <em>maxsplit</em> 번의 분할이 수행됩니다. <em>sep</em> 이 지정되지 않거나 <code class="docutils literal"><span class="pre">None</span></code> 이면, ASCII 공백 문자만으로 이루어진 모든 서브 시퀀스는 구분자입니다. 오른쪽에서 분리하는 것을 제외하면, <a class="reference internal" href="#bytearray.rsplit" title="bytearray.rsplit"><code class="xref py py-meth docutils literal"><span class="pre">rsplit()</span></code></a>는 아래에서 자세히 설명될 <a class="reference internal" href="#bytearray.split" title="bytearray.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a>처럼 동작합니다.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.rstrip">
<code class="descclassname">bytes.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rstrip" title="정의 주소">¶</a></dt>
<dt id="bytearray.rstrip">
<code class="descclassname">bytearray.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rstrip" title="정의 주소">¶</a></dt>
<dd><p>지정된 후행 바이트가 제거된 시퀀스의 복사본을 돌려줍니다. <em>chars</em> 인자는 제거할 바이트 집합을 지정하는 바이너리 시퀀스입니다 - 이름은 이 메서드가 보통 ASCII 문자와 사용된다는 사실을 반영합니다. 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이라면, <em>chars</em> 인자의 기본값은 ASCII 공백을 제거하도록 합니다. <em>chars</em> 인자는 접미사가 아닙니다; 모든 값 조합이 제거됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">b&#39;   spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;mississippi&#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ipz&#39;</span><span class="p">)</span>
<span class="go">b&#39;mississ&#39;</span>
</pre></div>
</div>
<p>제거할 바이트 값의 바이너리 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.split">
<code class="descclassname">bytes.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.split" title="정의 주소">¶</a></dt>
<dt id="bytearray.split">
<code class="descclassname">bytearray.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.split" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 를 구분자 시퀀스로 사용하여 바이너리 시퀀스를 같은 형의 서브 시퀀스로 나눕니다. <em>maxsplit</em> 이 지정되고 음수가 아닌 경우, 최대 <em>maxsplit</em> 분할이 수행됩니다 (따라서, 리스트는 최대 <code class="docutils literal"><span class="pre">maxsplit+1</span></code> 개의 요소를 가지게 됩니다). <em>maxsplit</em> 이 지정되지 않았거나 <code class="docutils literal"><span class="pre">-1</span></code> 이라면 분할 수에 제한이 없습니다 (가능한 모든 분할이 만들어집니다).</p>
<p><em>sep</em> 이 주어지면, 연속된 구분자는 묶이지 않고 빈 서브 시퀀스를 구분하는 것으로 간주합니다 (예를 들어, <code class="docutils literal"><span class="pre">b'1,,2'.split(b',')</span></code> 는 <code class="docutils literal"><span class="pre">[b'1',</span> <span class="pre">b'',</span> <span class="pre">b'2']</span></code> 를 돌려줍니다). <em>sep</em> 인자는 멀티바이트 시퀀스로 구성될 수 있습니다 (예를 들어, <code class="docutils literal"><span class="pre">b'1&lt;&gt;2&lt;&gt;3'.split(b'&lt;&gt;')</span></code> 는 <code class="docutils literal"><span class="pre">[b'1',</span> <span class="pre">b'2',</span> <span class="pre">b'3']</span></code> 를 돌려줍니다). 지정된 구분자로 빈 시퀀스를 나누면, 나누는 객체의 형에 따라 <code class="docutils literal"><span class="pre">[b'']</span></code> 나 <code class="docutils literal"><span class="pre">[bytearray(b'')]</span></code> 를 돌려줍니다. <em>sep</em> 인자는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2,3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,,3,&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;&#39;, b&#39;3&#39;, b&#39;&#39;]</span>
</pre></div>
</div>
<p><em>sep</em> 이 지정되지 않거나 <code class="docutils literal"><span class="pre">None</span></code> 이면, 다른 분할 알고리즘이 적용됩니다: 연속된 ASCII 공백 문자는 단일한 구분자로 간주하고, 시퀀스가 선행이나 후행 공백을 포함해도 결과는 시작과 끝에 빈 시퀀스를 포함하지 않습니다. 결과적으로, 빈 시퀀스나 ASCII 공백만으로 구성된 시퀀스를 <code class="docutils literal"><span class="pre">None</span></code> 구분자로 나누면 <code class="docutils literal"><span class="pre">[]</span></code> 를 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2 3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   1   2   3   &#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.strip">
<code class="descclassname">bytes.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.strip" title="정의 주소">¶</a></dt>
<dt id="bytearray.strip">
<code class="descclassname">bytearray.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.strip" title="정의 주소">¶</a></dt>
<dd><p>선행과 후행 바이트가 제거된 시퀀스의 복사본을 돌려줍니다. <em>chars</em> 인자는 제거할 바이트 집합을 지정하는 바이너리 시퀀스입니다 - 이름은 이 메서드가 보통 ASCII 문자와 사용된다는 사실을 반영합니다. 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이라면, <em>chars</em> 인자의 기본값은 ASCII 공백을 제거하도록 합니다. <em>chars</em> 인자는 접두사나 접미사가 아닙니다; 모든 값 조합이 제거됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">b&#39;spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">b&#39;example&#39;</span>
</pre></div>
</div>
<p>제거할 바이트 값의 바이너리 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<p>바이트열 및 바이트 배열 객체에 대한 다음 메서드는 ASCII 호환 바이너리 형식의 사용을 가정하며 임의의 바이너리 데이터에 적용하면 안 됩니다. 이 섹션의 바이트 배열 메서드는 모두 제자리에서 작동하지 <em>않고</em> 대신 새로운 객체를 생성합니다.</p>
<dl class="method">
<dt id="bytes.capitalize">
<code class="descclassname">bytes.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.capitalize" title="정의 주소">¶</a></dt>
<dt id="bytearray.capitalize">
<code class="descclassname">bytearray.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.capitalize" title="정의 주소">¶</a></dt>
<dd><p>각 바이트가 ASCII 문자로 해석되고 첫 번째 바이트는 대문자로, 나머지는 소문자로 만든 시퀀스의 복사본을 돌려줍니다. ASCII 바이트가 아닌 값들은 변경되지 않고 전달됩니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.expandtabs">
<code class="descclassname">bytes.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.expandtabs" title="정의 주소">¶</a></dt>
<dt id="bytearray.expandtabs">
<code class="descclassname">bytearray.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.expandtabs" title="정의 주소">¶</a></dt>
<dd><p>모든 ASCII 탭 문자들을 현재의 열과 주어진 탭 크기에 따라 하나나 그 이상의 ASCII 스페이스로 치환한 시퀀스의 복사본을 돌려줍니다. 탭 위치는 <em>tabsize</em> 바이트마다 발생합니다 (기본값은 8이고, 열 0, 8, 16 등에 탭 위치를 지정합니다). 시퀀스를 확장하기 위해 현재 열이 0으로 설정되고 시퀀스를 바이트 단위로 검사합니다. 바이트가 ASCII 탭 문자 (<code class="docutils literal"><span class="pre">b'\t'</span></code>) 이면, 현재 열이 다음 탭 위치와 같아질 때까지 하나 이상의 스페이스 문자가 삽입됩니다. (탭 문자 자체는 복사되지 않습니다.) 현재 바이트가 ASCII 개행 문자 (<code class="docutils literal"><span class="pre">b'\n'</span></code>) 또는 캐리지 리턴 (<code class="docutils literal"><span class="pre">b'\r'</span></code>) 이면 복사되고 현재 열은 0으로 재설정됩니다. 다른 바이트는 변경되지 않고 복사되고 현재 열은 인쇄할 때 바이트가 어떻게 표시되는지에 관계없이 1씩 증가합니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
<span class="go">b&#39;01      012     0123    01234&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">b&#39;01  012 0123    01234&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isalnum">
<code class="descclassname">bytes.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isalnum" title="정의 주소">¶</a></dt>
<dt id="bytearray.isalnum">
<code class="descclassname">bytearray.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isalnum" title="정의 주소">¶</a></dt>
<dd><p>시퀀스의 모든 바이트가 알파벳 ASCII 문자 또는 ASCII 십진수이고 시퀀스가 ​​비어 있지 않으면 참을 돌려주고 그렇지 않으면 거짓을 돌려줍니다. 알파벳 ASCII 문자는, 시퀀스 <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> 에 있는 바이트 값입니다. ASCII 십진수는 시퀀스 <code class="docutils literal"><span class="pre">b'0123456789'</span></code> 에 있는 바이트 값입니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc1&#39;</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABC abc1&#39;</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isalpha">
<code class="descclassname">bytes.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isalpha" title="정의 주소">¶</a></dt>
<dt id="bytearray.isalpha">
<code class="descclassname">bytearray.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isalpha" title="정의 주소">¶</a></dt>
<dd><p>시퀀스의 모든 바이트가 알파벳 ASCII 문자이고 시퀀스가 ​​비어 있지 않으면 참을 돌려주고 그렇지 않으면 거짓을 돌려줍니다. 알파벳 ASCII 문자는, 시퀀스 <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> 에 있는 바이트 값입니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc&#39;</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc1&#39;</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isdigit">
<code class="descclassname">bytes.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isdigit" title="정의 주소">¶</a></dt>
<dt id="bytearray.isdigit">
<code class="descclassname">bytearray.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isdigit" title="정의 주소">¶</a></dt>
<dd><p>시퀀스의 모든 바이트가 ASCII 십진수이며 시퀀스가 ​​비어 있지 않으면 참을 돌려주고 그렇지 않으면 거짓을 돌려줍니다. ASCII 십진수는 시퀀스 <code class="docutils literal"><span class="pre">b'0123456789'</span></code> 에 있는 바이트 값입니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1234&#39;</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1.23&#39;</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.islower">
<code class="descclassname">bytes.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.islower" title="정의 주소">¶</a></dt>
<dt id="bytearray.islower">
<code class="descclassname">bytearray.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.islower" title="정의 주소">¶</a></dt>
<dd><p>시퀀스에 적어도 하나의 ASCII 소문자가 있고, ASCII 대문자가 없으면 참을, 그렇지 않으면 거짓을 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;hello world&#39;</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>ASCII 소문자는 시퀀스 <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code> 에 있는 바이트 값입니다. ASCII 대문자는, 시퀀스 <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> 에 있는 바이트 값입니다.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.isspace">
<code class="descclassname">bytes.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isspace" title="정의 주소">¶</a></dt>
<dt id="bytearray.isspace">
<code class="descclassname">bytearray.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isspace" title="정의 주소">¶</a></dt>
<dd><p>시퀀스의 모든 바이트가 ASCII 공백이고, 시퀀스가 ​​비어 있지 않으면 참을 돌려주고 그렇지 않으면 거짓을 돌려줍니다. ASCII 공백 문자는 시퀀스 <code class="docutils literal"><span class="pre">b'</span> <span class="pre">\t\n\r\x0b\f'</span></code>(스페이스, 탭, 줄 바꿈, 캐리지 리턴, 수직 탭, 폼 피드)에 있는 바이트 값입니다.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.istitle">
<code class="descclassname">bytes.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.istitle" title="정의 주소">¶</a></dt>
<dt id="bytearray.istitle">
<code class="descclassname">bytearray.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.istitle" title="정의 주소">¶</a></dt>
<dd><p>시퀀스가 ASCII 제목 케이스고 시퀀스가 비어있지 않으면 참을 돌려주고 그렇지 않으면 거짓을 돌려줍니다. &quot;제목 케이스&quot; 의 정의에 대한 자세한 내용은 <a class="reference internal" href="#bytes.title" title="bytes.title"><code class="xref py py-meth docutils literal"><span class="pre">bytes.title()</span></code></a> 을 참조하십시오.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">istitle</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">istitle</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isupper">
<code class="descclassname">bytes.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isupper" title="정의 주소">¶</a></dt>
<dt id="bytearray.isupper">
<code class="descclassname">bytearray.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isupper" title="정의 주소">¶</a></dt>
<dd><p>시퀀스에 적어도 하나의 ASCII 대문자가 있고, ASCII 소문자가 없으면 참을, 그렇지 않으면 거짓을 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;HELLO WORLD&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>ASCII 소문자는 시퀀스 <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code> 에 있는 바이트 값입니다. ASCII 대문자는, 시퀀스 <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> 에 있는 바이트 값입니다.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.lower">
<code class="descclassname">bytes.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.lower" title="정의 주소">¶</a></dt>
<dt id="bytearray.lower">
<code class="descclassname">bytearray.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.lower" title="정의 주소">¶</a></dt>
<dd><p>모든 ASCII 대문자를 해당 소문자로 변환한 시퀀스의 복사본을 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="go">b&#39;hello world&#39;</span>
</pre></div>
</div>
<p>ASCII 소문자는 시퀀스 <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code> 에 있는 바이트 값입니다. ASCII 대문자는, 시퀀스 <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> 에 있는 바이트 값입니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<span class="target" id="index-40"></span><dl class="method">
<dt id="bytes.splitlines">
<code class="descclassname">bytes.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><em>keepends=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.splitlines" title="정의 주소">¶</a></dt>
<dt id="bytearray.splitlines">
<code class="descclassname">bytearray.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><em>keepends=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.splitlines" title="정의 주소">¶</a></dt>
<dd><p>ASCII 줄 경계에서 나눈 바이너리 시퀀스의 줄 리스트를 돌려줍니다. 이 메서드는 줄을 나누는데 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> 접근법을 사용합니다. <em>keepends</em> 가 참으로 주어지지 않는 한 결과 리스트에 줄 바꿈은 포함되지 않습니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[b&#39;ab c&#39;, b&#39;&#39;, b&#39;de fg&#39;, b&#39;kl&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[b&#39;ab c\n&#39;, b&#39;\n&#39;, b&#39;de fg\r&#39;, b&#39;kl\r\n&#39;]</span>
</pre></div>
</div>
<p>구분자 시퀀스 <em>sep</em> 이 주어졌을 때 <a class="reference internal" href="#bytes.split" title="bytes.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> 와 달리, 이 메서드는 빈 시퀀스에 대해서 빈 리스트를 돌려주고, 마지막 줄 바꿈은 새 줄을 만들지 않습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">),</span> <span class="sa">b</span><span class="s2">&quot;Two lines</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">([b&#39;&#39;], [b&#39;Two lines&#39;, b&#39;&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">&quot;One line</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">([], [b&#39;One line&#39;])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.swapcase">
<code class="descclassname">bytes.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.swapcase" title="정의 주소">¶</a></dt>
<dt id="bytearray.swapcase">
<code class="descclassname">bytearray.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.swapcase" title="정의 주소">¶</a></dt>
<dd><p>모든 ASCII 소문자를 해당 대문자로, 그 반대도 마찬가지로 변환한 시퀀스의 복사본을 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">swapcase</span><span class="p">()</span>
<span class="go">b&#39;hELLO wORLD&#39;</span>
</pre></div>
</div>
<p>ASCII 소문자는 시퀀스 <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code> 에 있는 바이트 값입니다. ASCII 대문자는, 시퀀스 <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> 에 있는 바이트 값입니다.</p>
<p><a class="reference internal" href="#str.swapcase" title="str.swapcase"><code class="xref py py-func docutils literal"><span class="pre">str.swapcase()</span></code></a> 와는 달리 바이너리 버전의 경우 항상 <code class="docutils literal"><span class="pre">bin.swapcase().swapcase()</span> <span class="pre">==</span> <span class="pre">bin</span></code> 이 성립합니다. 임의의 유니코드 포인트에서 일반적으로 성립하지는 않지만, ASCII에서 케이스 변환은 대칭적입니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.title">
<code class="descclassname">bytes.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.title" title="정의 주소">¶</a></dt>
<dt id="bytearray.title">
<code class="descclassname">bytearray.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.title" title="정의 주소">¶</a></dt>
<dd><p>단어가 ASCII 대문자로 시작하고 나머지 문자들은 소문자인 제목 케이스 버전의 바이너리 시퀀스를 돌려줍니다. 케이스 없는 바이트 값은 수정되지 않은 상태로 남습니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">b&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>ASCII 소문자는 시퀀스 <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code> 에 있는 바이트 값입니다. ASCII 대문자는 시퀀스 <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> 에 있는 바이트 값입니다. 다른 모든 바이트 값은 케이스가 없습니다.</p>
<p>이 알고리즘은 단어를 글자들의 연속으로 보는 간단한 언어 독립적 정의를 사용합니다. 이 정의는 여러 상황에서 작동하지만, 축약과 소유의 아포스트로피가 단어 경계를 형성한다는 것을 의미하고, 이는 원하는 결과가 아닐 수도 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;they&#39;re bill&#39;s friends from the UK&quot;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">b&quot;They&#39;Re Bill&#39;S Friends From The Uk&quot;</span>
</pre></div>
</div>
<p>정규식을 사용하여 아포스트로피에 대한 해결 방법을 구성할 수 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">titlecase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">rb</span><span class="s2">&quot;[A-Za-z]+(&#39;[A-Za-z]+)?&quot;</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="k">lambda</span> <span class="n">mo</span><span class="p">:</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span>
<span class="gp">... </span>                             <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
<span class="gp">... </span>                  <span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">titlecase</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;they&#39;re bill&#39;s friends.&quot;</span><span class="p">)</span>
<span class="go">b&quot;They&#39;re Bill&#39;s Friends.&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.upper">
<code class="descclassname">bytes.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.upper" title="정의 주소">¶</a></dt>
<dt id="bytearray.upper">
<code class="descclassname">bytearray.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.upper" title="정의 주소">¶</a></dt>
<dd><p>모든 ASCII 소문자를 해당 대문자로 변환한 시퀀스의 복사본을 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="go">b&#39;HELLO WORLD&#39;</span>
</pre></div>
</div>
<p>ASCII 소문자는 시퀀스 <code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code> 에 있는 바이트 값입니다. ASCII 대문자는, 시퀀스 <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code> 에 있는 바이트 값입니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.zfill">
<code class="descclassname">bytes.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.zfill" title="정의 주소">¶</a></dt>
<dt id="bytearray.zfill">
<code class="descclassname">bytearray.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.zfill" title="정의 주소">¶</a></dt>
<dd><p>길이가 <em>width</em> 인 시퀀스를 만들기 위해 ASCII <code class="docutils literal"><span class="pre">b'0'</span></code> 문자를 왼쪽에 채운 시퀀스의 복사본을 돌려줍니다. 선행 부호 접두어(<code class="docutils literal"><span class="pre">b'+'</span></code>/<code class="docutils literal"><span class="pre">b'-'</span></code>)는 부호 문자의 앞이 아니라 <em>뒤</em> 에 채우는 것으로 처리됩니다. <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체의 경우, <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 시퀀스를 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">b&#39;00042&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;-42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">b&#39;-0042&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="printf-style-bytes-formatting">
<span id="bytes-formatting"></span><h3>4.8.4. <code class="docutils literal"><span class="pre">printf</span></code> 스타일 바이너리 포매팅<a class="headerlink" href="#printf-style-bytes-formatting" title="제목 주소">¶</a></h3>
<div class="admonition note" id="index-41">
<p class="first admonition-title">주석</p>
<p class="last">여기에 설명된 포맷 연산은 여러 가지 일반적인 오류를 (예를 들어 튜플과 딕셔너리를 올바르게 표시하지 못하는 것) 유발하는 다양한 문제점들이 있습니다. 인쇄될 값이 튜플 또는 딕셔너리일 경우 튜플로 감싸야 합니다.</p>
</div>
<p>바이너리 시퀀스 객체는 한가지 고유한 내장 연산을 갖고 있습니다: <code class="docutils literal"><span class="pre">%</span></code> 연산자 (모듈로). 이것은 바이너리 <em>포매팅</em> 또는 <em>치환</em> 연산자라고도 합니다. <code class="docutils literal"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">values</span></code> 가 주어질 때 (<em>format</em> 은 바이너리 시퀀스입니다), <em>format</em> 내부의 <code class="docutils literal"><span class="pre">%</span></code> 변환 명세는 0개 이상의 <em>values​​</em> 의 요소로 대체됩니다. 이 효과는 C 언어에서 <code class="xref c c-func docutils literal"><span class="pre">sprintf()</span></code>를 사용하는 것과 비슷합니다.</p>
<p><em>format</em> 이 하나의 인자를 요구하면, <em>values​​</em> 는 하나의 비 튜플 객체 일 수 있습니다. <a class="footnote-reference" href="#id16" id="id11">[5]</a> 그렇지 않으면, <em>values​​</em> 는 format 바이너리 시퀀스 객체가 지정하는 항목의 수와 같은 튜플이거나 단일 매핑 객체 (예를 들어, 딕셔너리) 여야 합니다.</p>
<p>변환 명세는 두 개 이상의 문자를 포함하며 다음과 같은 구성 요소들을 포함하는데, 반드시 이 순서대로 나와야 합니다:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">'%'</span></code> 문자: 명세의 시작을 나타냅니다.</li>
<li>매핑 키 (선택 사항): 괄호로 둘러싸인 문자들의 시퀀스로 구성됩니다 (예를 들어, <code class="docutils literal"><span class="pre">(somename)</span></code>).</li>
<li>변환 플래그 (선택 사항): 일부 변환 유형의 결과에 영향을 줍니다.</li>
<li>최소 필드 폭 (선택 사항): <code class="docutils literal"><span class="pre">'*'</span></code> (애스터리스크) 로 지정하면, 실제 폭은 <em>values</em> 튜플의 다음 요소에서 읽히고, 변환할 객체는 최소 필드 폭과 선택적 정밀도 뒤에 옵니다.</li>
<li>정밀도 (선택 사항): <code class="docutils literal"><span class="pre">'.'</span></code> (점) 다음에 정밀도가 옵니다. <code class="docutils literal"><span class="pre">'*'</span></code> (애스터리스크) 로 지정하면, 실제 정밀도는 <em>values</em> 튜플의 다음 요소에서 읽히고, 변환할 값은 정밀도 뒤에 옵니다.</li>
<li>길이 수정자 (선택 사항).</li>
<li>변환 유형.</li>
</ol>
<p>오른쪽 인자가 딕셔너리 (또는 다른 매핑 형) 인 경우, 바이너리 시퀀스 객체에 있는 변환 명세는 <em>반드시</em> <code class="docutils literal"><span class="pre">'%'</span></code> 문자 바로 뒤에 그 딕셔너리의 매핑 키를 괄호로 둘러싼 형태로 포함해야 합니다. 매핑 키는 포맷할 값을 매핑으로 부터 선택합니다. 예를 들어:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="si">%(language)s</span><span class="s1"> has </span><span class="si">%(number)03d</span><span class="s1"> quote types.&#39;</span> <span class="o">%</span>
<span class="gp">... </span>      <span class="p">{</span><span class="sa">b</span><span class="s1">&#39;language&#39;</span><span class="p">:</span> <span class="sa">b</span><span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;number&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">b&#39;Python has 002 quote types.&#39;</span>
</pre></div>
</div>
<p>이 경우 <code class="docutils literal"><span class="pre">*</span></code> 지정자를 사용할 수 없습니다 (순차적인 파라미터 목록이 필요하기 때문입니다).</p>
<p>변환 플래그 문자는 다음과 같습니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">플래그</th>
<th class="head">뜻</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'#'</span></code></td>
<td>값 변환에 &quot;대체 형식&quot; (아래에 정의되어있습니다) 을 사용합니다.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'0'</span></code></td>
<td>변환은 숫자 값의 경우 0으로 채웁니다.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'-'</span></code></td>
<td>변환된 값은 왼쪽으로 정렬됩니다 (둘 다 주어지면 <code class="docutils literal"><span class="pre">'0'</span></code> 변환보다 우선 합니다).</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></code></td>
<td>(스페이스) 부호 있는 변환 때문에 만들어진 양수 앞에 빈칸을 남겨둡니다 (음수면 빈 문자열입니다).</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'+'</span></code></td>
<td>부호 문자 (<code class="docutils literal"><span class="pre">'+'</span></code> or <code class="docutils literal"><span class="pre">'-'</span></code>) 가 변환 앞에 놓입니다 (<code class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></code> 플래그에 우선합니다).</td>
</tr>
</tbody>
</table>
<p>길이 수정자 (<code class="docutils literal"><span class="pre">h</span></code>, <code class="docutils literal"><span class="pre">l</span></code>, <code class="docutils literal"><span class="pre">L</span></code>) 를 제공할 수는 있지만, 파이썬에서 필요하지 않기 때문에 무시됩니다 -- 예를 들어 <code class="docutils literal"><span class="pre">%ld</span></code> 는 <code class="docutils literal"><span class="pre">%d</span></code> 와 같습니다.</p>
<p>변환 유형은 다음과 같습니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="74%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">변환</th>
<th class="head">뜻</th>
<th class="head">노트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'d'</span></code></td>
<td>부호 있는 정수 십진 표기.</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'i'</span></code></td>
<td>부호 있는 정수 십진 표기.</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'o'</span></code></td>
<td>부호 있는 8진수 값.</td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'u'</span></code></td>
<td>쓸데없는 유형 -- <code class="docutils literal"><span class="pre">'d'</span></code> 와 같습니다.</td>
<td>(8)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'x'</span></code></td>
<td>부호 있는 16진수 (소문자).</td>
<td>(2)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'X'</span></code></td>
<td>부호 있는 16진수 (대문자).</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'e'</span></code></td>
<td>부동 소수점 지수 형식 (소문자).</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'E'</span></code></td>
<td>부동 소수점 지수 형식 (대문자).</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'f'</span></code></td>
<td>부동 소수점 십진수 형식.</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'F'</span></code></td>
<td>부동 소수점 십진수 형식.</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'g'</span></code></td>
<td>부동 소수점 형식. 지수가 -4보다 작거나 정밀도 보다 작지 않으면 소문자 지수형식을 사용하고, 그렇지 않으면 십진수 형식을 사용합니다.</td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'G'</span></code></td>
<td>부동 소수점 형식. 지수가 -4보다 작거나 정밀도 보다 작지 않으면 대문자 지수형식을 사용하고, 그렇지 않으면 십진수 형식을 사용합니다.</td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'c'</span></code></td>
<td>단일 바이트 (정수 또는 길이 1인 바이너리 시퀀스를 허용합니다).</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">`b`</span></code></td>
<td>바이너리 시퀀스 ( <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">버퍼 프로토콜</span></a> 을 따르거나 <a class="reference internal" href="../reference/datamodel.html#object.__bytes__" title="object.__bytes__"><code class="xref py py-meth docutils literal"><span class="pre">__bytes__()</span></code></a> 가 있는 모든 객체).</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'s'</span></code></td>
<td><code class="docutils literal"><span class="pre">'s'</span></code> 는 <code class="docutils literal"><span class="pre">'b'</span></code> 의 별칭이고 파이썬 2/3에서만 사용되어야 합니다.</td>
<td>(6)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'a'</span></code></td>
<td>바이트열 (<code class="docutils literal"><span class="pre">repr(obj).encode('ascii','backslashreplace)</span></code> 를 사용하여 모든 파이썬 객체를 변환합니다).</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'r'</span></code></td>
<td><code class="docutils literal"><span class="pre">'r'</span></code> 는 <code class="docutils literal"><span class="pre">'a'</span></code> 의 별칭이고 파이썬 2/3에서만 사용되어야 합니다.</td>
<td>(7)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'%'</span></code></td>
<td>인자는 변환되지 않고, 결과에 <code class="docutils literal"><span class="pre">'%'</span></code> 문자가 표시됩니다.</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>노트:</p>
<ol class="arabic">
<li><p class="first">대체 형식은 첫 번째 숫자 앞에 선행 8진수 지정자 (<code class="docutils literal"><span class="pre">'0o'</span></code>)를 삽입합니다.</p>
</li>
<li><p class="first">대체 형식은 첫 번째 숫자 앞에 선행 <code class="docutils literal"><span class="pre">'0x'</span></code> 또는 <code class="docutils literal"><span class="pre">'0X'</span></code> (<code class="docutils literal"><span class="pre">'x'</span></code> 나 <code class="docutils literal"><span class="pre">'X'</span></code> 유형 중 어느 것을 사용하느냐에 따라 달라집니다) 를 삽입합니다.</p>
</li>
<li><p class="first">대체 형식은 그 뒤에 숫자가 나오지 않더라도 항상 소수점을 포함합니다.</p>
<p>정밀도는 소수점 이하 자릿수를 결정하며 기본값은 6입니다.</p>
</li>
<li><p class="first">대체 형식은 결과에 항상 소수점을 포함하고 뒤에 오는 0은 제거되지 않습니다.</p>
<p>정밀도는 소수점 앞뒤의 유효 자릿수를 결정하며 기본값은 6입니다.</p>
</li>
<li><p class="first">정밀도가 <code class="docutils literal"><span class="pre">N</span></code> 이라면, 출력은 <code class="docutils literal"><span class="pre">N</span></code> 문자로 잘립니다.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">b'%s'</span></code> 는 폐지되었습니다. 하지만 3.x 시리즈에서는 제거되지 않습니다.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">b'%r'</span></code> 는 폐지되었습니다. 하지만 3.x 시리즈에서는 제거되지 않습니다.</p>
</li>
<li><p class="first"><span class="target" id="index-59"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a>을 참조하세요.</p>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><span class="target" id="index-43"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0461"><strong>PEP 461</strong></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</div>
<div class="section" id="memory-views">
<span id="typememoryview"></span><h3>4.8.5. 메모리 뷰<a class="headerlink" href="#memory-views" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> 객체는 파이썬 코드가 <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">버퍼 프로토콜</span></a> 을 지원하는 객체의 내부 데이터에 복사 없이 접근할 수 있게 합니다.</p>
<dl class="class">
<dt id="memoryview">
<em class="property">class </em><code class="descname">memoryview</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#memoryview" title="정의 주소">¶</a></dt>
<dd><p><em>obj</em> 를 참조하는 <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> 를 만듭니다. <em>obj</em> 는 버퍼 프로토콜을 지원해야 합니다. 버퍼 프로토콜을 지원하는 내장 객체에는 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 와 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 가 있습니다.</p>
<p>A <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> 는 <em>요소</em> 라는 개념을 갖는데, 원래 객체 <em>obj</em> 에 의해 처리되는 원자 적 메모리 단위입니다. <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 와 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 와 같은 많은 간단한 형의 경우 요소는 하나의 바이트이지만, <a class="reference internal" href="array.html#array.array" title="array.array"><code class="xref py py-class docutils literal"><span class="pre">array.array</span></code></a> 와 같은 다른 형들은 더 큰 요소를 가질 수 있습니다.</p>
<p><code class="docutils literal"><span class="pre">len(view)</span></code> 는 <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-class docutils literal"><span class="pre">tolist</span></code></a> 의 길이와 같습니다. <code class="docutils literal"><span class="pre">view.ndim</span> <span class="pre">=</span> <span class="pre">0</span></code> 이면 길이는 1입니다. <code class="docutils literal"><span class="pre">view.ndim</span> <span class="pre">=</span> <span class="pre">1</span></code> 이면 길이는 뷰에 있는 요소의 개수와 같습니다. 고차원의 경우, 길이는 뷰의 중첩된 리스트 표현의 길이와 같습니다. <a class="reference internal" href="#memoryview.itemsize" title="memoryview.itemsize"><code class="xref py py-class docutils literal"><span class="pre">itemsize</span></code></a> 어트리뷰트는 단일 요소의 바이트 수를 알려줍니다.</p>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> 는 슬라이싱과 인덱싱을 지원하여 데이터를 노출합니다. 일차원 슬라이스는 서브 뷰를 만듭니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">98</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">103</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">&lt;memory at 0x7f3ddc9f4350&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
<span class="go">b&#39;bce&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#memoryview.format" title="memoryview.format"><code class="xref py py-class docutils literal"><span class="pre">format</span></code></a> 이 <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> 모듈의 네이티브 형식 지정자 중 하나인 경우, 정수 또는 정수의 튜플을 사용하는 인덱싱도 지원되며 올바른 형으로 하나의 요소를 돌려줍니다. 일차원 메모리 뷰는 정수 또는 하나의 정수를 갖는 튜플로 인덱싱 할 수 있습니다. 다차원 메모리 뷰는 정확히 <em>ndim</em> 개의 정수를 갖는 튜플로 인덱싱할 수 있습니다. 여기서 <em>ndim</em> 은 차원 수입니다. 영차원 메모리 뷰는 빈 튜플로 인덱싱할 수 있습니다.</p>
<p>다음은 바이트가 아닌 형식의 예입니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">11111111</span><span class="p">,</span> <span class="mi">22222222</span><span class="p">,</span> <span class="o">-</span><span class="mi">33333333</span><span class="p">,</span> <span class="mi">44444444</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-11111111</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">44444444</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[-11111111, -33333333]</span>
</pre></div>
</div>
<p>하부 객체가 쓰기 가능하면, 메모리 뷰는 일차원 슬라이스 대입을 지원합니다. 크기 변경은 허용되지 않습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">readonly</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;zbcefg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;123&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;z123fg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;spam&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">memoryview assignment: lvalue and rvalue have different structures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;spam&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;z1spam&#39;)</span>
</pre></div>
</div>
<p>'B', 'b' 'c' 형식의 해시 가능 (읽기 전용) 형의 일차원 메모리 뷰는 역시 해시 가능합니다. 해시는 <code class="docutils literal"><span class="pre">hash(m)</span> <span class="pre">==</span> <span class="pre">hash(m.tobytes())</span></code> 로 정의됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ce&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>이제 일차원 메모리 뷰를 슬라이스할 수 있습니다. 이제 형식이 'B', 'b', 'c' 인 일차원 메모리 뷰는 해시 가능합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>이제 메모리 뷰는 자동으로 <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sequence</span></code></a> 로 등록됩니다</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>이제 메모리 뷰는 정수의 튜플로 인덱싱될 수 있습니다.</p>
</div>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> 는 몇 가지 메서드를 가지고 있습니다:</p>
<dl class="method">
<dt id="memoryview.__eq__">
<code class="descname">__eq__</code><span class="sig-paren">(</span><em>exporter</em><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.__eq__" title="정의 주소">¶</a></dt>
<dd><p>메모리 뷰와 <span class="target" id="index-60"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3118"><strong>PEP 3118</strong></a> 제공자(exporter)는 다음과 같은 조건을 만족할 때 같다고 비교됩니다: 모양이 동등하고 피연산자의 각 형식 코드가 <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> 문법을 사용하여 해석될 때 모든 해당 값이 같다.</p>
<p>현재 <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal"><span class="pre">tolist()</span></code></a> 가 지원하는 <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> 형식 문자열의 부분 집합의 경우, <code class="docutils literal"><span class="pre">v.tolist()</span> <span class="pre">==</span> <span class="pre">w.tolist()</span></code> 면 <code class="docutils literal"><span class="pre">v</span></code> 와 <code class="docutils literal"><span class="pre">w</span></code> 는 같습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="o">==</span> <span class="n">y</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">==</span> <span class="n">c</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>형식 문자열이 <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> 모듈에서 지원되지 않으면 객체는 항상 같지 않다고 비교됩니다 (형식 문자열과 버퍼 내용이 같더라도 그렇습니다):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">BigEndianStructure</span><span class="p">,</span> <span class="n">c_long</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">BEPoint</span><span class="p">(</span><span class="n">BigEndianStructure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_long</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_long</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">BEPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">point</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">False</span>
</pre></div>
</div>
<p>부동 소수점 숫자와 마찬가지로, 메모리 뷰 객체의 경우 <code class="docutils literal"><span class="pre">v</span> <span class="pre">is</span> <span class="pre">w</span></code> 일 때도 <code class="docutils literal"><span class="pre">v</span> <span class="pre">==</span> <span class="pre">w</span></code> 가 성립하지 <em>않을</em> 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>이전 버전에서는 항목 형식과 논리 배열 구조를 무시하고 원시 메모리를 비교했습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.tobytes">
<code class="descname">tobytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.tobytes" title="정의 주소">¶</a></dt>
<dd><p>버퍼의 데이터를 바이트열로 돌려줍니다. 이는 메모리 뷰에 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 생성자를 호출하는 것과 동등합니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">b&#39;abc&#39;</span>
</pre></div>
</div>
<p>불연속 배열의 경우 결과는 모든 요소를 바이트로 변환하여 평평한 리스트로 만든 것과 같습니다. <a class="reference internal" href="#memoryview.tobytes" title="memoryview.tobytes"><code class="xref py py-meth docutils literal"><span class="pre">tobytes()</span></code></a> 는 <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> 모듈 문법에 없는 것을 포함하여 모든 형식 문자열을 지원합니다.</p>
</dd></dl>

<dl class="method">
<dt id="memoryview.hex">
<code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.hex" title="정의 주소">¶</a></dt>
<dd><p>버퍼 내의 각 바이트를 두 개의 16진수로 표현한 문자열 객체를 돌려줍니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;616263&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.tolist">
<code class="descname">tolist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.tolist" title="정의 주소">¶</a></dt>
<dd><p>버퍼 내의 데이터를 요소들의 리스트로 돌려줍니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[97, 98, 99]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[1.1, 2.2, 3.3]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal"><span class="pre">tolist()</span></code></a> 는 이제 <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> 모듈 문법의 모든 단일 문자 네이티브 형식과 다차원 표현을 지원합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.release" title="정의 주소">¶</a></dt>
<dd><p>메모리 뷰 객체에 의해 노출된 하부 버퍼를 해제합니다. 많은 객체는 뷰가 그 객체에 연결될 때 특별한 조처를 합니다 (예를 들어, <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 는 일시적으로 크기 조절을 금지합니다); 따라서, release()를 호출하면 가능한 한 빨리 이 제한 사항을 제거하고 붙잡힌 자원을 해제할 수 있습니다.</p>
<p>이 메서드가 호출된 후, 뷰에 대한 더 이상의 연산은 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-class docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다 (여러 번 호출 될 수 있는 <a class="reference internal" href="#memoryview.release" title="memoryview.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> 자신은 예외입니다):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operation forbidden on released memoryview object</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">with</span></code> 문을 사용한 컨텍스트 관리 프로토콜은 비슷한 효과를 낼 수 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">97</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operation forbidden on released memoryview object</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.cast">
<code class="descname">cast</code><span class="sig-paren">(</span><em>format</em><span class="optional">[</span>, <em>shape</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.cast" title="정의 주소">¶</a></dt>
<dd><p>메모리 뷰를 새로운 형식이나 모양으로 캐스팅합니다. <em>shape</em> 의 기본값은 <code class="docutils literal"><span class="pre">[byte_length//new_itemsize]</span></code> 인데, 결과 뷰가 일차원이 된다는 의미입니다. 반환 값은 새로운 메모리 뷰이지만 버퍼 자체는 복사되지 않습니다. 지원되는 캐스팅은 1D -&gt; C-<a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">연속</span></a> 과 C-연속 -&gt; 1D입니다.</p>
<p>목적 형식은 <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> 문법의 단일 요소 네이티브 형식으로 제한됩니다. 형식 중 하나는 바이트 형식('B', 'b', 'c')이어야 합니다. 결과의 바이트 길이는 원래 길이와 같아야 합니다.</p>
<p>1D/long 을 1D/unsigned bytes 로 캐스트:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;l&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;B&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">24</span>
</pre></div>
</div>
<p>1D/unsigned bytes 를 1D/char 로 캐스트:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;zyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;a&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">memoryview: invalid value for format &quot;B&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">bytearray(b&#39;ayz&#39;)</span>
</pre></div>
</div>
<p>1D/bytes 를 3D/ints 로 캐스트 한 후 다시 1D/signed char 로 캐스트:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;i&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
</pre></div>
</div>
<p>1D/unsigned char 를 2D/unsigned long 으로 캐스트:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0, 1, 2], [3, 4, 5]]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>바이트 형식으로 변환할 때 소스 형식이 더는 제한되지 않습니다.</p>
</div>
</dd></dl>

<p>몇 가지 읽기 전용 어트리뷰트도 사용할 수 있습니다:</p>
<dl class="attribute">
<dt id="memoryview.obj">
<code class="descname">obj</code><a class="headerlink" href="#memoryview.obj" title="정의 주소">¶</a></dt>
<dd><p>메모리 뷰의 하부 객체:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.nbytes">
<code class="descname">nbytes</code><a class="headerlink" href="#memoryview.nbytes" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">nbytes</span> <span class="pre">==</span> <span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">len(m.tobytes())</span></code>. 배열이 연속적일 때 차지하게 될 바이트 수입니다. 꼭 len(m) 과 같을 필요는 없습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">m</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">12</span>
</pre></div>
</div>
<p>다차원 배열:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="mf">1.5</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">96</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.readonly">
<code class="descname">readonly</code><a class="headerlink" href="#memoryview.readonly" title="정의 주소">¶</a></dt>
<dd><p>메모리가 읽기 전용인지 여부를 나타내는 논리값.</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.format">
<code class="descname">format</code><a class="headerlink" href="#memoryview.format" title="정의 주소">¶</a></dt>
<dd><p>뷰의 각 요소에 대한 형식(<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> 모듈 스타일)을 포함하는 문자열입니다. 메모리 뷰는 제공자로부터 임의의 형식 문자열로 만들어질 수 있지만, 일부 메서드(예, <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal"><span class="pre">tolist()</span></code></a>)는 원시 네이티브 단일 요소 형식으로 제한됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><code class="docutils literal"><span class="pre">'B'</span></code> 형식은 이제 struct 모듈 문법에 따라 처리됩니다. 이것은 <code class="docutils literal"><span class="pre">memoryview(b'abc')[0]</span> <span class="pre">==</span> <span class="pre">b'abc'[0]</span> <span class="pre">==</span> <span class="pre">97</span></code> 이 됨을 의미합니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.itemsize">
<code class="descname">itemsize</code><a class="headerlink" href="#memoryview.itemsize" title="정의 주소">¶</a></dt>
<dd><p>메모리 뷰 각 요소의 크기 (바이트):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span><span class="o">,</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">32000</span><span class="p">,</span> <span class="mi">32001</span><span class="p">,</span> <span class="mi">32002</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">32000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#memoryview.ndim" title="정의 주소">¶</a></dt>
<dd><p>메모리가 나타내는 다차원 배열의 차원 수를 나타내는 정수.</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.shape">
<code class="descname">shape</code><a class="headerlink" href="#memoryview.shape" title="정의 주소">¶</a></dt>
<dd><p>N-차원 배열로서의 메모리의 모양을 가리키는, 길이 <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal"><span class="pre">ndim</span></code></a> 인 정수의 튜플입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>ndim = 0 일 때 <code class="docutils literal"><span class="pre">None</span></code> 대신 빈 튜플을 제공합니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.strides">
<code class="descname">strides</code><a class="headerlink" href="#memoryview.strides" title="정의 주소">¶</a></dt>
<dd><p>배열의 각 차원에 대해 각 요소를 참조하는데 필요한 바이트 수를 제공하는, 길이 <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal"><span class="pre">ndim</span></code></a> 인 정수의 튜플입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>ndim = 0 일 때 <code class="docutils literal"><span class="pre">None</span></code> 대신 빈 튜플을 제공합니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.suboffsets">
<code class="descname">suboffsets</code><a class="headerlink" href="#memoryview.suboffsets" title="정의 주소">¶</a></dt>
<dd><p>PIL 스타일 배열에 내부적으로 사용됩니다. 값은 정보 제공용입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.c_contiguous">
<code class="descname">c_contiguous</code><a class="headerlink" href="#memoryview.c_contiguous" title="정의 주소">¶</a></dt>
<dd><p>메모리가 C-<a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">연속</span></a> 인지를 나타내는 논리값.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.f_contiguous">
<code class="descname">f_contiguous</code><a class="headerlink" href="#memoryview.f_contiguous" title="정의 주소">¶</a></dt>
<dd><p>메모리가 포트란 <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">연속</span></a> 인지를 나타내는 논리값.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.contiguous">
<code class="descname">contiguous</code><a class="headerlink" href="#memoryview.contiguous" title="정의 주소">¶</a></dt>
<dd><p>메모리가 <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">연속</span></a> 인지를 나타내는 논리값.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="set-types-set-frozenset">
<span id="types-set"></span><h2>4.9. 집합 형 --- <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a><a class="headerlink" href="#set-types-set-frozenset" title="제목 주소">¶</a></h2>
<p id="index-45"><em class="dfn">집합 (set)</em> 객체는 서로 다른 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 객체의 순서 없는 컬렉션입니다. 일반적인 용도는 멤버십 검사, 시퀀스에서 중복 제거와 교집합, 합집합, 차집합, 대칭 차집합과 같은 수학 연산을 계산하는 것입니다. (다른 컨테이너들은 내장 <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>, <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> 클래스 및 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> 모듈을 참조하십시오.)</p>
<p>다른 컬렉션과 마찬가지로, 집합은 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">set</span></code>,``len(set)``, <code class="docutils literal"><span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">set</span></code> 을 지원합니다. 순서가 없는 컬렉션이므로, 집합은 원소의 위치나 삽입 순서를 기록하지 않습니다. 따라서 집합은 인덱싱, 슬라이싱 또는 기타 시퀀스와 유사한 동작을 지원하지 않습니다.</p>
<p>현재 두 가지 내장형이 있습니다, <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>과 <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>. <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> 형은 가변입니다 --- 내용을 <code class="xref py py-meth docutils literal"><span class="pre">add()</span></code> 나 <code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code> 와 같은 메서드를 사용하여 변경할 수 있습니다. 가변이기 때문에, 해시값이 없으며 딕셔너리 키 또는 다른 집합의 원소로 사용할 수 없습니다. <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> 형은 불변이고 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 합니다 --- 만들어진 후에는 내용을 바꿀 수 없습니다; 따라서 딕셔너리 키 또는 다른 집합의 원소로 사용할 수 있습니다.</p>
<p>비어 있지 않은 set은 (frozenset 은 아닙니다) <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> 생성자뿐만 아니라 중괄호 안에 쉼표로 구분된 원소 목록을 넣어서 만들 수 있습니다, 예를 들어: <code class="docutils literal"><span class="pre">{'jack',</span> <span class="pre">'sjoerd'}</span></code>.</p>
<p>두 클래스의 생성자는 같게 작동합니다:</p>
<dl class="class">
<dt id="set">
<em class="property">class </em><code class="descname">set</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#set" title="정의 주소">¶</a></dt>
<dt id="frozenset">
<em class="property">class </em><code class="descname">frozenset</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset" title="정의 주소">¶</a></dt>
<dd><p><em>iterable</em> 에서 요소를 취하는 새 set 또는 frozenset 객체를 돌려줍니다. 집합의 원소는 반드시 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 해야 합니다. 집합의 집합을 표현하려면, 포함되는 집합은 반드시 <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> 객체여야 합니다. <em>iterable</em> 을 지정하지 않으면 새 빈 집합을 돌려줍니다.</p>
<p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>과 <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> 의 인스턴스는 다음과 같은 연산을 제공합니다:</p>
<dl class="describe">
<dt>
<code class="descname">len(s)</code></dt>
<dd><p>집합 <em>s</em> 의 원소 수(<em>s</em> 의 크기)를 돌려줍니다.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x in s</code></dt>
<dd><p><em>s</em> 에 대해 <em>x</em> 의 멤버십을 검사합니다.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x not in s</code></dt>
<dd><p><em>s</em> 에 대해 <em>x</em> 의 비 멤버십을 검사합니다.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.isdisjoint">
<code class="descname">isdisjoint</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.isdisjoint" title="정의 주소">¶</a></dt>
<dd><p>집합이 <em>other</em> 와 공통 원소를 갖지 않는 경우 <code class="docutils literal"><span class="pre">True</span></code> 을 돌려줍니다. 집합은 교집합이 공집합일 때, 그리고 그때만 서로소(disjoint)라고 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.issubset">
<code class="descname">issubset</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.issubset" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set &lt;= other</code></dt>
<dd><p>집합의 모든 원소가 <em>other</em> 에 포함되는지 검사합니다.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set &lt; other</code></dt>
<dd><p>집합이 <em>other</em> 의 진부분집합인지 검사합니다, 즉, <code class="docutils literal"><span class="pre">set</span> <span class="pre">&lt;=</span> <span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.issuperset">
<code class="descname">issuperset</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.issuperset" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set &gt;= other</code></dt>
<dd><p><em>other</em> 의 모든 원소가 집합에 포함되는지 검사합니다.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set &gt; other</code></dt>
<dd><p>집합이 <em>other</em> 의 진상위집합인지 검사합니다, 즉, <code class="docutils literal"><span class="pre">set</span> <span class="pre">&gt;=</span> <span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.union">
<code class="descname">union</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.union" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set | other | ...</code></dt>
<dd><p>집합과 모든 others에 있는 원소들로 구성된 새 집합을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.intersection" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set &amp; other &amp; ...</code></dt>
<dd><p>집합과 모든 others의 공통 원소들로 구성된 새 집합을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.difference">
<code class="descname">difference</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.difference" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set - other - ...</code></dt>
<dd><p>집합에는 포함되었으나 others에는 포함되지 않은 원소들로 구성된 새 집합을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.symmetric_difference">
<code class="descname">symmetric_difference</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.symmetric_difference" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set ^ other</code></dt>
<dd><p>집합이나 other에 포함되어 있으나 둘 모두에 포함되지는 않은 원소들로 구성된 새 집합을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.copy" title="정의 주소">¶</a></dt>
<dd><p><em>s</em> 의 얕은 복사본인 새 집합을 돌려줍니다.</p>
</dd></dl>

<p>참고로, 연산자가 아닌 버전의 <a class="reference internal" href="#frozenset.union" title="frozenset.union"><code class="xref py py-meth docutils literal"><span class="pre">union()</span></code></a>, <a class="reference internal" href="#frozenset.intersection" title="frozenset.intersection"><code class="xref py py-meth docutils literal"><span class="pre">intersection()</span></code></a>, <a class="reference internal" href="#frozenset.difference" title="frozenset.difference"><code class="xref py py-meth docutils literal"><span class="pre">difference()</span></code></a>, <a class="reference internal" href="#frozenset.symmetric_difference" title="frozenset.symmetric_difference"><code class="xref py py-meth docutils literal"><span class="pre">symmetric_difference()</span></code></a>, <a class="reference internal" href="#frozenset.issubset" title="frozenset.issubset"><code class="xref py py-meth docutils literal"><span class="pre">issubset()</span></code></a>, <a class="reference internal" href="#frozenset.issuperset" title="frozenset.issuperset"><code class="xref py py-meth docutils literal"><span class="pre">issuperset()</span></code></a> 메서드는 임의의 이터러블을 인자로 받아들입니다. 대조적으로, 연산자를 기반으로 하는 대응 연산들은 인자가 집합일 것을 요구합니다. 이것은 오류가 발생하기 쉬운 <code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">&amp;</span> <span class="pre">'cbs'</span></code> 와 같은 구성을 배제하고 더 읽기 쉬운 <code class="docutils literal"><span class="pre">set('abc').intersection('cbs')</span></code> 를 선호합니다.</p>
<p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>과 <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> 모두 집합 간의 비교를 지원합니다. 두 집합은 각 집합의 모든 원소가 다른 집합에 포함되어있는 경우에만 같습니다 (서로 다른 집합의 부분집합입니다). 집합이 다른 집합의 진부분집합(부분집합이지만 같지는 않은 경우)일 때만 첫 번째 집합이 두 번째 집합보다 작습니다. 집합이 다른 집합의 진상위집합(상위집합이지만 같지는 않은 경우)일 때만 첫 번째 집합이 두 번째 집합보다 큽니다.</p>
<p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> 의 인스턴스는 그 원소를 기반으로 <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> 의 인스턴스와 비교됩니다. 예를 들어, <code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">==</span> <span class="pre">frozenset('abc')</span></code> 는 <code class="docutils literal"><span class="pre">True</span></code> 를 돌려주고 <code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">in</span> <span class="pre">set([frozenset('abc')])</span></code> 도 마찬가지입니다.</p>
<p>부분 집합 및 동등 비교는 전 순서(total ordering) 함수로 일반화되지 않습니다. 예를 들어, 비어 있지 않은 두 개의 서로소인 집합은 같지 않고 서로의 부분 집합이 아닙니다, 그래서 다음은 <em>모두</em> <code class="docutils literal"><span class="pre">False</span></code> 를 돌려줍니다: <code class="docutils literal"><span class="pre">a&lt;b</span></code>, <code class="docutils literal"><span class="pre">a==b</span></code>, <code class="docutils literal"><span class="pre">a&gt;b</span></code>.</p>
<p>집합은 부분 순서(부분 집합 관계)만 정의하기 때문에, 집합의 리스트에 대한 <a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code></a> 메서드의 결과는 정의되지 않습니다.</p>
<p>딕셔너리 키처럼, 집합의 원소는 반드시 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 해야 합니다.</p>
<p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> 인스턴스와 <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> 을 혼합 한 이항 연산은 첫 번째 피연산자의 형을 돌려줍니다. 예를 들어: <code class="docutils literal"><span class="pre">frozenset('ab')</span> <span class="pre">|</span> <span class="pre">set('bc')</span></code> 는 <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> 의 인스턴스를 돌려줍니다.</p>
<p>다음 표는 <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> 의 불변 인스턴스에는 적용되지 않고 <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> 에서만 사용할 수 있는 연산들을 나열합니다:</p>
<dl class="method">
<dt id="frozenset.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.update" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set |= other | ...</code></dt>
<dd><p>집합을 갱신해서, 모든 others의 원소들을 더합니다.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.intersection_update">
<code class="descname">intersection_update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.intersection_update" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set &amp;= other &amp; ...</code></dt>
<dd><p>집합을 갱신해서, 그 집합과 others에 공통으로 포함된 원소들만 남깁니다.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.difference_update">
<code class="descname">difference_update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.difference_update" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set -= other | ...</code></dt>
<dd><p>집합을 갱신해서, others에 있는 원소들을 제거합니다.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.symmetric_difference_update">
<code class="descname">symmetric_difference_update</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.symmetric_difference_update" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set ^= other</code></dt>
<dd><p>집합을 갱신해서, 두 집합의 어느 한 곳에만 포함된 원소들만 남깁니다.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.add" title="정의 주소">¶</a></dt>
<dd><p>원소 <em>elem</em> 을 집합에 추가합니다.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.remove" title="정의 주소">¶</a></dt>
<dd><p>원소 <em>elem</em> 을 집합에서 제거합니다. <em>elem</em> 가 집합에 포함되어 있지 않으면 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.discard">
<code class="descname">discard</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.discard" title="정의 주소">¶</a></dt>
<dd><p>원소 <em>elem</em> 이 집합에 포함되어 있으면 제거합니다.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.pop" title="정의 주소">¶</a></dt>
<dd><p>집합으로부터 임의의 원소를 제거해 돌려줍니다. 집합이 비어있는 경우 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.clear" title="정의 주소">¶</a></dt>
<dd><p>집합의 모든 원소를 제거합니다.</p>
</dd></dl>

<p>참고로, <a class="reference internal" href="#frozenset.update" title="frozenset.update"><code class="xref py py-meth docutils literal"><span class="pre">update()</span></code></a>, <a class="reference internal" href="#frozenset.intersection_update" title="frozenset.intersection_update"><code class="xref py py-meth docutils literal"><span class="pre">intersection_update()</span></code></a>, <a class="reference internal" href="#frozenset.difference_update" title="frozenset.difference_update"><code class="xref py py-meth docutils literal"><span class="pre">difference_update()</span></code></a>, <a class="reference internal" href="#frozenset.symmetric_difference_update" title="frozenset.symmetric_difference_update"><code class="xref py py-meth docutils literal"><span class="pre">symmetric_difference_update()</span></code></a> 메서드의 비 연산자 버전은 임의의 이터러블을 인자로 받아들입니다.</p>
<p>참고로, <a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a>, <a class="reference internal" href="#frozenset.remove" title="frozenset.remove"><code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code></a>, <a class="reference internal" href="#frozenset.discard" title="frozenset.discard"><code class="xref py py-meth docutils literal"><span class="pre">discard()</span></code></a> 메서드로 제공되는 <em>elem</em> 인자는 set 일 수 있습니다. 동등한 frozenset 검색을 지원하기 위해, <em>elem</em> 으로 임시 frozenset 을 만듭니다.</p>
</dd></dl>

</div>
<div class="section" id="mapping-types-dict">
<span id="typesmapping"></span><h2>4.10. 매핑 형 --- <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a><a class="headerlink" href="#mapping-types-dict" title="제목 주소">¶</a></h2>
<p id="index-46"><a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">매핑</span></a> 객체는 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 값을 임의의 객체에 대응합니다. 매핑은 가변 객체입니다. 현재 오직 하나의 표준 매핑 형이 있습니다, <em class="dfn">딕셔너리 (dictionary)</em>. (다른 컨테이너들은 내장 <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> 클래스 및 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> 모듈을 참조하십시오.)</p>
<p>딕셔너리의 키는 <em>거의</em> 임의의 값입니다. <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 하지 않은 값들, 즉, 리스트, 딕셔너리 또는 다른 가변형 (객체 아이덴티티 대신 값으로 비교됩니다) 은 키로 사용할 수 없습니다. 키에 사용되는 숫자 형은 숫자 비교를 위한 일반적인 규칙을 따릅니다: 두 숫자가 같다고 비교되는 경우 (<code class="docutils literal"><span class="pre">1</span></code> 과 <code class="docutils literal"><span class="pre">1.0</span></code> 처럼) 같은 딕셔너리 항목을 인덱싱하는데 서로 교환하여 사용할 수 있습니다. (그러나 컴퓨터는 부동 소수점 숫자를 근삿값으로 저장하므로 이것들을 딕셔너리 키로 사용하는 것은 현명하지 않습니다.)</p>
<p>딕셔너리는 <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> 생성자뿐만 아니라 중괄호 안에 쉼표로 구분된 <code class="docutils literal"><span class="pre">key:</span> <span class="pre">value</span></code> 쌍을 나열해서 만들 수 있습니다, 예를 들어: <code class="docutils literal"><span class="pre">{'jack':</span> <span class="pre">4098,</span> <span class="pre">'sjoerd':</span> <span class="pre">4127}</span></code> 또는 <code class="docutils literal"><span class="pre">{4098:</span> <span class="pre">'jack',</span> <span class="pre">4127:</span> <span class="pre">'sjoerd'}</span></code>.</p>
<dl class="class">
<dt id="dict">
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>**kwarg</em><span class="sig-paren">)</span><a class="headerlink" href="#dict" title="정의 주소">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>mapping</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>iterable</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dd><p>선택적 위치 인자와 (비어있을 수 있는) 키워드 인자들의 집합으로부터 초기화된 새 딕셔너리를 돌려줍니다.</p>
<p>위치 인자가 제공되지 않으면 빈 딕셔너리가 만들어집니다. 위치 인자가 지정되고 매핑 객체인 경우, 매핑 객체와 같은 키-값 쌍을 갖는 딕셔너리가 만들어집니다. 그렇지 않으면, 위치 인자는 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">이터러블</span></a> 객체여야 합니다. 이터러블의 각 항목은 그 자체로 정확하게 두 개의 객체가 있는 이터러블이어야 합니다. 각 항목의 첫 번째 객체는 새 딕셔너리의 키가 되고, 두 ​​번째 객체는 해당 값이 됩니다. 키가 두 번 이상 나타나면, 그 키의 마지막 값이 새 딕셔너리의 해당 값이 됩니다.</p>
<p>키워드 인자가 제공되면, 키워드 인자와 해당 값이 위치 인자로부터 만들어진 딕셔너리에 추가됩니다. 추가되는 키가 이미 존재하면, 키워드 인자에서 온 값이 위치 인자에게서 온 값을 대체합니다.</p>
<p>예를 들어, 다음 예제는 모두 <code class="docutils literal"><span class="pre">{&quot;one&quot;:</span> <span class="pre">1,</span> <span class="pre">&quot;two&quot;:</span> <span class="pre">2,</span> <span class="pre">&quot;three&quot;:</span> <span class="pre">3}</span></code> 와 같은 딕셔너리를 돌려줍니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">one</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">three</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;three&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span> <span class="o">==</span> <span class="n">d</span> <span class="o">==</span> <span class="n">e</span>
<span class="go">True</span>
</pre></div>
</div>
<p>첫 번째 예제에서와같이 키워드 인자는 유효한 파이썬 식별자인 키에 대해서만 작동합니다. 그 외의 경우는 모든 유효한 키를 사용할 수 있습니다.</p>
<p>이것들은 딕셔너리가 지원하는 연산들입니다 (그러므로, 사용자 정의 매핑 형도 지원해야 합니다):</p>
<dl class="describe">
<dt>
<code class="descname">len(d)</code></dt>
<dd><p>딕셔너리 <em>d</em> 에 있는 항목의 수를 돌려줍니다.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">d[key]</code></dt>
<dd><p>키 <em>key</em> 인 <em>d</em> 의 항목을 돌려줍니다. <em>key</em> 가 매핑에 없는 경우 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> 를 일으킵니다.</p>
<p id="index-47">dict 의 서브 클래스가 method <a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> 을 정의하고 <em>key</em> 가 존재하지 않는다면, <code class="docutils literal"><span class="pre">d[key]</span></code> 연산은 키 <em>key</em> 를 인자로 하여 그 메서드를 호출합니다. 그런 다음 <code class="docutils literal"><span class="pre">d[key]</span></code> 연산은 <code class="docutils literal"><span class="pre">__missing__(key)</span></code> 호출이 반환한 값이나 일으킨 예외를 그대로 반환하거나 일으킵니다. 다른 연산이나 메서드는 <a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> 을 호출하지 않습니다. <a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> 이 정의되어 있지 않으면 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> 를 일으킵니다. <a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> 은 메서드 여야 합니다; 인스턴스 변수가 될 수 없습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Counter</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
<p>위의 예는 <a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal"><span class="pre">collections.Counter</span></code></a> 구현 일부를 보여줍니다. 다른 <code class="docutils literal"><span class="pre">__missing__</span></code> 메서드가 <a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal"><span class="pre">collections.defaultdict</span></code></a> 에서 사용됩니다.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">d[key] = value</code></dt>
<dd><p><code class="docutils literal"><span class="pre">d[key]</span></code> 를 <em>value</em> 로 설정합니다.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">del d[key]</code></dt>
<dd><p><em>d</em> 에서 <code class="docutils literal"><span class="pre">d[key]</span></code> 를 제거합니다. <em>key</em> 가 매핑에 없는 경우 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">key in d</code></dt>
<dd><p><em>d</em> 에 키 <em>key</em> 가 있으면 <code class="docutils literal"><span class="pre">True</span></code> 를, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code> 를 돌려줍니다.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">key not in d</code></dt>
<dd><p><code class="docutils literal"><span class="pre">not</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">d</span></code> 와 동등합니다.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">iter(d)</code></dt>
<dd><p>딕셔너리의 키에 대한 이터레이터를 돌려줍니다. 이것은 <code class="docutils literal"><span class="pre">iter(d.keys())</span></code> 의 단축입니다.</p>
</dd></dl>

<dl class="method">
<dt id="dict.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.clear" title="정의 주소">¶</a></dt>
<dd><p>딕셔너리에서 모든 항목을 제거합니다.</p>
</dd></dl>

<dl class="method">
<dt id="dict.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.copy" title="정의 주소">¶</a></dt>
<dd><p>딕셔너리의 얕은 복사본을 돌려줍니다.</p>
</dd></dl>

<dl class="classmethod">
<dt id="dict.fromkeys">
<em class="property">classmethod </em><code class="descname">fromkeys</code><span class="sig-paren">(</span><em>seq</em><span class="optional">[</span>, <em>value</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.fromkeys" title="정의 주소">¶</a></dt>
<dd><p><em>seq</em> 가 제공하는 값들을 키로 사용하고 모든 값을 <em>value</em> 로 설정한 새 딕셔러리를 돌려줍니다.</p>
<p><a class="reference internal" href="#dict.fromkeys" title="dict.fromkeys"><code class="xref py py-meth docutils literal"><span class="pre">fromkeys()</span></code></a> 는 새로운 딕셔너리를 돌려주는 클래스 메서드입니다. <em>value</em> 의 기본값은 <code class="docutils literal"><span class="pre">None</span></code> 입니다.</p>
</dd></dl>

<dl class="method">
<dt id="dict.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.get" title="정의 주소">¶</a></dt>
<dd><p><em>key</em> 가 딕셔너리에 있는 경우 <em>key</em> 에 대응하는 값을 돌려주고, 그렇지 않으면 <em>default</em> 를 돌려줍니다. <em>default</em> 가 주어지지 않으면 기본값 <code class="docutils literal"><span class="pre">None</span></code> 이 사용됩니다. 그래서 이 메서드는 절대로 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> 를 일으키지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="dict.items">
<code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.items" title="정의 주소">¶</a></dt>
<dd><p>딕셔너리 항목들(<code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> 쌍들)의 새 뷰를 돌려줍니다. <a class="reference internal" href="#dict-views"><span class="std std-ref">뷰 객체의 도큐멘테이션</span></a> 을 참조하세요.</p>
</dd></dl>

<dl class="method">
<dt id="dict.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.keys" title="정의 주소">¶</a></dt>
<dd><p>딕셔너리 키들의 새 뷰를 돌려줍니다. <a class="reference internal" href="#dict-views"><span class="std std-ref">뷰 객체의 도큐멘테이션</span></a> 을 참조하세요.</p>
</dd></dl>

<dl class="method">
<dt id="dict.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.pop" title="정의 주소">¶</a></dt>
<dd><p><em>key</em> 가 딕셔너리에 있으면 제거하고 그 값을 돌려줍니다. 그렇지 않으면 <em>default</em> 를 돌려줍니다. <em>default</em> 가 주어지지 않고 <em>key</em> 가 딕셔너리에 없으면 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="dict.popitem">
<code class="descname">popitem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.popitem" title="정의 주소">¶</a></dt>
<dd><p>딕셔너리에서 임의의 <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> 쌍을 제거하고 돌려줍니다.</p>
<p><a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal"><span class="pre">popitem()</span></code></a> 은 집합 알고리즘에서 종종 사용되듯이 딕셔너리를 파괴적으로 이터레이션 하는 데 유용합니다. 딕셔너리가 비어 있으면 <a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal"><span class="pre">popitem()</span></code></a> 호출은 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="dict.setdefault">
<code class="descname">setdefault</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.setdefault" title="정의 주소">¶</a></dt>
<dd><p><em>key</em> 가 딕셔너리에 있으면 해당 값을 돌려줍니다. 그렇지 않으면, <em>default</em> 값을 갖는 <em>key</em> 를 삽입한 후 <em>default</em> 를 돌려줍니다. <em>default</em> 의 기본값은 <code class="docutils literal"><span class="pre">None</span></code> 입니다.</p>
</dd></dl>

<dl class="method">
<dt id="dict.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em>other</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.update" title="정의 주소">¶</a></dt>
<dd><p><em>other</em> 가 제공하는 키/값 쌍으로 사전을 갱신합니다. 기존 키는 덮어씁니다. <code class="docutils literal"><span class="pre">None</span></code> 을 돌려줍니다.</p>
<p><a class="reference internal" href="#dict.update" title="dict.update"><code class="xref py py-meth docutils literal"><span class="pre">update()</span></code></a> 는 다른 딕셔너리 객체 나 키/값 쌍(길이 2인 튜플이나 다른 이터러블)을 주는 이터레이터를 모두 받아들입니다. 키워드 인자가 지정되면, 딕셔너리는 그 키/값 쌍으로 갱신됩니다: <code class="docutils literal"><span class="pre">d.update(red=1,</span> <span class="pre">blue=2)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.values" title="정의 주소">¶</a></dt>
<dd><p>딕셔너리 값들의 새 뷰를 돌려줍니다. <a class="reference internal" href="#dict-views"><span class="std std-ref">뷰 객체의 도큐멘테이션</span></a> 을 참조하세요.</p>
</dd></dl>

<p>딕셔너리는 같은 <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> 쌍들을 가질 때, 그리고 그때만 같다고 비교됩니다. 순서 비교('&lt;', '&lt;=', '&gt;=', '&gt;')는 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal"><span class="pre">types.MappingProxyType</span></code></a> 를 <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> 의 읽기 전용 뷰를 만드는 데 사용할 수 있습니다.</p>
</div>
<div class="section" id="dictionary-view-objects">
<span id="dict-views"></span><h3>4.10.1. 딕셔너리 뷰 객체<a class="headerlink" href="#dictionary-view-objects" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="#dict.values" title="dict.values"><code class="xref py py-meth docutils literal"><span class="pre">dict.values()</span></code></a>, <a class="reference internal" href="#dict.items" title="dict.items"><code class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></code></a> 가 돌려주는 객체는 <em>뷰 객체</em> 입니다. 딕셔너리의 항목들에 대한 동적 뷰를 제공합니다. 즉, 딕셔너리가 변경되면 뷰는 이러한 변경 사항을 반영합니다.</p>
<p>딕셔너리 뷰는 이터레이션을 통해 각각의 데이터를 산출할 수 있고, 멤버십 검사를 지원합니다:</p>
<dl class="describe">
<dt>
<code class="descname">len(dictview)</code></dt>
<dd><p>딕셔너리에 있는 항목 수를 돌려줍니다.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">iter(dictview)</code></dt>
<dd><p>딕셔너리에서 키, 값, 항목(<code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> 튜플로 표현됩니다)에 대한 이터레이터를 돌려줍니다.</p>
<p>키와 값은 무작위는 아니지만, 임의의 순서(파이썬 구현에 따라 달라집니다)로 이터레이션 되고, 딕셔너리의 삽입 및 삭제 이력에 따라 달라집니다. 키, 값 및 항목 뷰를 이터레이션 하는 도중에 딕셔너리를 수정하지 않으면, 항목들의 순서는 모두 일치합니다. 이 때문에 <a class="reference internal" href="functions.html#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a>을 사용해서 <code class="docutils literal"><span class="pre">(value,</span> <span class="pre">key)</span></code> 쌍을 만들 수 있습니다: <code class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">zip(d.values(),</span> <span class="pre">d.keys())</span></code>. 같은 리스트를 만드는 다른 방법은 <code class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">[(v,</span> <span class="pre">k)</span> <span class="pre">for</span> <span class="pre">(k,</span> <span class="pre">v)</span> <span class="pre">in</span> <span class="pre">d.items()]</span></code> 입니다.</p>
<p>딕셔너리에 항목을 추가하거나 삭제하는 동안 뷰를 이터레이션 하면 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> 를 일으키거나 모든 항목을 이터레이션 하지 못할 수 있습니다.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x in dictview</code></dt>
<dd><p><em>x</em> 가 하부 딕셔너리의 키, 갑, 항목에 있는 경우 <code class="docutils literal"><span class="pre">True</span></code> 를 돌려줍니다 (마지막의 경우 <em>x</em> 는 <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> 튜플이어야 합니다).</p>
</dd></dl>

<p>키 뷰는 항목이 고유하고 해시 가능하므로 집합과 유사합니다. 모든 값이 해시 가능해서 <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> 쌍들이 고유하고 해시 가능하다면, 항목 뷰 역시 집합과 유사합니다. (값 뷰는 항목이 일반적으로 고유하지 않기 때문에 집합과 같이 취급되지 않습니다.) 집합과 유사한 뷰의 경우 추상 베이스 클래스 <a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Set</span></code></a> 에 정의된 모든 연산을 사용할 수 있습니다 (예를 들어, <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">^</span></code>).</p>
<p>딕셔너리 뷰 사용의 예:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dishes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;sausage&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># iteration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">+=</span> <span class="n">val</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">504</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># keys and values are iterated over in the same order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">[&#39;eggs&#39;, &#39;bacon&#39;, &#39;sausage&#39;, &#39;spam&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">[2, 1, 1, 500]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view objects are dynamic and reflect dict changes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s1">&#39;eggs&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s1">&#39;sausage&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">[&#39;spam&#39;, &#39;bacon&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># set operations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s1">&#39;eggs&#39;</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">,</span> <span class="s1">&#39;salad&#39;</span><span class="p">}</span>
<span class="go">{&#39;bacon&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">^</span> <span class="p">{</span><span class="s1">&#39;sausage&#39;</span><span class="p">,</span> <span class="s1">&#39;juice&#39;</span><span class="p">}</span>
<span class="go">{&#39;juice&#39;, &#39;sausage&#39;, &#39;bacon&#39;, &#39;spam&#39;}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="context-manager-types">
<span id="typecontextmanager"></span><h2>4.11. 컨텍스트 관리자 형<a class="headerlink" href="#context-manager-types" title="제목 주소">¶</a></h2>
<p id="index-48">파이썬의 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 문은 컨텍스트 관리자가 정의한 실행 시간 컨텍스트 개념을 지원합니다. 이는 한 쌍의 메서드를 사용해서 구현되는데, 사용자 정의 클래스가 문장 바디가 실행되기 전에 진입하고, 문장이 끝날 때 탈출하는 실행 시간 컨텍스트를 정의할 수 있게 합니다:</p>
<dl class="method">
<dt id="contextmanager.__enter__">
<code class="descclassname">contextmanager.</code><code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#contextmanager.__enter__" title="정의 주소">¶</a></dt>
<dd><p>실행시간 컨텍스트에 진입하고 이 객체 자신이나 실행 시간 컨텍스트와 관련된 다른 객체를 돌려줍니다. 이 메서드가 돌려주는 값은, 이 컨텍스트 관리자를 사용하는 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 문의 <a class="reference internal" href="../reference/compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> 절의 식별자에 연결됩니다.</p>
<p>자신을 돌려주는 컨텍스트 관리자의 예는 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a> 입니다. 파일 객체는 __enter__() 에서 자기 자신을 돌려주는데 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 문의 컨텍스트 표현식으로 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> 을 사용할 수 있도록 하기 위함입니다.</p>
<p>관련 객체를 돌려주는 컨텍스트 관리자의 예는 <a class="reference internal" href="decimal.html#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal"><span class="pre">decimal.localcontext()</span></code></a> 가 돌려주는 것입니다. 이 관리자들은 활성 십진 소수 컨텍스트를 원래 십진 소수 컨텍스트의 복사본으로 설정한 다음 복사본을 돌려줍니다. 이것은 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 문 바깥의 코드에 영향을 주지 않으면서 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 문 바디에 있는 현재 십진 소수 컨텍스트를 변경할 수 있게 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="contextmanager.__exit__">
<code class="descclassname">contextmanager.</code><code class="descname">__exit__</code><span class="sig-paren">(</span><em>exc_type</em>, <em>exc_val</em>, <em>exc_tb</em><span class="sig-paren">)</span><a class="headerlink" href="#contextmanager.__exit__" title="정의 주소">¶</a></dt>
<dd><p>실행 시간 컨텍스트를 탈출하고 발생한 예외를 막아야 하는지를 가리키는 논리 플래그를 돌려줍니다. <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 문의 바디를 실행하는 동안 예외가 발생하면, 인자에 예외 형, 값 및 추적 정보가 포함됩니다. 그렇지 않으면, 세 가지 인자 모두 <code class="docutils literal"><span class="pre">None</span></code> 입니다.</p>
<p>이 메서드에서 참 값을 돌려주면 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 문이 예외를 막고 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 문 바로 뒤에 오는 문장에서 계속 실행됩니다. 그 이외의 경우, 이 메서드의 실행이 완료된 후에 예외는 계속 퍼집니다. 이 메서드의 실행 중에 발생하는 예외는 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> 문의 바디에서 발생한 모든 예외를 대체합니다.</p>
<p>전달 된 예외를 명시적으로 다시 일으켜서는 안 됩니다 - 대신, 이 메서드가 성공적으로 완료되었으며 발생 된 예외를 막지 않겠다는 의미의 거짓을 돌려주어야 합니다. 이렇게 하면 컨텍스트 관리 코드가 <a class="reference internal" href="#contextmanager.__exit__" title="contextmanager.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> 메서드가 실제로 실패했는지를 쉽게 감지할 수 있습니다.</p>
</dd></dl>

<p>파이썬은 쉬운 스레드 동기화, 파일이나 다른 객체의 신속한 닫기, 그리고 활성 십진 소수 산술 컨텍스트의 보다 간단한 조작을 지원하기 위해 몇 가지 컨텍스트 관리자를 정의합니다. 컨텍스트 관리 프로토콜의 구현을 넘어 구체적인 형은 특별히 취급되지 않습니다. 몇 가지 예제는 <a class="reference internal" href="contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a> 모듈을 보십시오.</p>
<p>파이썬의 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a>s들과 <a class="reference internal" href="contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-class docutils literal"><span class="pre">contextlib.contextmanager</span></code></a> 데코레이터는 이 프로토콜을 구현하는 편리한 방법을 제공합니다. 제너레이터 함수가 <a class="reference internal" href="contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-class docutils literal"><span class="pre">contextlib.contextmanager</span></code></a> 데코레이터로 데코레이팅 되면, 데코레이팅 되지 않은 제너레이터 함수가 만드는 이터레이터 대신에 필요한 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> 와 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> 메서드를 구현하는 컨텍스트 관리자를 돌려줍니다.</p>
<p>파이썬/C API의 파이썬 객체에 대한 형 구조체에는 이러한 메서드들을 위해 준비된 슬롯이 없다는 점에 유의하십시오. 이러한 메서드를 정의하고자 하는 확장형은 일반적인 파이썬 액세스가 가능한 메서드로 제공해야 합니다. 실행 시간 컨텍스트를 설정하는 오버헤드와 비교할 때 한 번의 클래스 딕셔너리 조회의 오버헤드는 무시할 수 있습니다.</p>
</div>
<div class="section" id="other-built-in-types">
<span id="typesother"></span><h2>4.12. 기타 내장형<a class="headerlink" href="#other-built-in-types" title="제목 주소">¶</a></h2>
<p>인터프리터는 여러 가지 다른 객체를 지원합니다. 이것들 대부분은 한두 가지 연산만 지원합니다.</p>
<div class="section" id="modules">
<span id="typesmodules"></span><h3>4.12.1. 모듈<a class="headerlink" href="#modules" title="제목 주소">¶</a></h3>
<p>모듈에 대한 유일한 특별한 연산은 어트리뷰트 액세스입니다: <code class="docutils literal"><span class="pre">m.name</span></code>. 여기서 <em>m</em> 은 모듈이고 <em>name</em> 은 <em>m</em> 의 심볼 테이블에 정의된 이름에 액세스합니다. 모듈 어트리뷰트는 대입할 수 있습니다. (<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 문은 엄밀히 말하면 모듈 객체에 대한 연산이 아닙니다; <code class="docutils literal"><span class="pre">import</span> <span class="pre">foo</span></code> 는 <em>foo</em> 라는 이름의 모듈 객체가 존재할 것을 요구하지 않고, 어딘가에 있는 <em>foo</em> 라는 이름의 (외부) <em>정의</em> 를 요구합니다.</p>
<p>모든 모듈의 특수 어트리뷰트는 <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> 입니다. 이것은 모듈의 심볼 테이블을 저장하는 딕셔너리입니다. 이 딕셔너리를 수정하면 모듈의 심볼 테이블이 실제로 변경되지만, <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> 어트리뷰트에 대한 직접 대입은 불가능합니다 (<code class="docutils literal"><span class="pre">m.__dict__['a']</span> <span class="pre">=</span> <span class="pre">1</span></code> 라고 쓸 수 있고, <code class="docutils literal"><span class="pre">m.a</span></code> 가 <code class="docutils literal"><span class="pre">1</span></code> 이 되지만, <code class="docutils literal"><span class="pre">m.__dict__</span> <span class="pre">=</span> <span class="pre">{}</span></code> 라고 쓸 수는 없습니다). <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> 의 직접적인 수정은 추천하지 않습니다.</p>
<p>인터프리터에 내장된 모듈은 다음과 같이 쓰입니다: <code class="docutils literal"><span class="pre">&lt;module</span> <span class="pre">'sys'</span> <span class="pre">(built-in)&gt;</span></code>. 파일에서 로드되면, <code class="docutils literal"><span class="pre">&lt;module</span> <span class="pre">'os'</span> <span class="pre">from</span> <span class="pre">'/usr/local/lib/pythonX.Y/os.pyc'&gt;</span></code> 처럼 쓰입니다.</p>
</div>
<div class="section" id="classes-and-class-instances">
<span id="typesobjects"></span><h3>4.12.2. 클래스와 클래스 인스턴스<a class="headerlink" href="#classes-and-class-instances" title="제목 주소">¶</a></h3>
<p>여기에 대해서는 <a class="reference internal" href="../reference/datamodel.html#objects"><span class="std std-ref">객체, 값, 형</span></a>와 <a class="reference internal" href="../reference/compound_stmts.html#class"><span class="std std-ref">클래스 정의</span></a>를 참조하세요.</p>
</div>
<div class="section" id="functions">
<span id="typesfunctions"></span><h3>4.12.3. 함수<a class="headerlink" href="#functions" title="제목 주소">¶</a></h3>
<p>함수 객체는 함수 정의로 만들어집니다. 함수 객체에 대한 유일한 연산은 호출하는 것입니다: <code class="docutils literal"><span class="pre">func(argument-list)</span></code>.</p>
<p>함수 객체에는 내장 함수와 사용자 정의 함수라는 두 가지 종류가 있습니다. 두 함수 모두 같은 연산(함수 호출)을 지원하지만, 구현이 다르므로 서로 다른 객체 형입니다.</p>
<p>자세한 정보는 <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a>을 보십시오.</p>
</div>
<div class="section" id="methods">
<span id="typesmethods"></span><h3>4.12.4. 메서드<a class="headerlink" href="#methods" title="제목 주소">¶</a></h3>
<p id="index-49">메서드는 어트리뷰트 표기법을 사용하여 호출되는 함수입니다. 두 가지 종류가 있습니다: 내장 메서드(리스트의 <code class="xref py py-meth docutils literal"><span class="pre">append()</span></code> 같은 것들)와 클래스 인스턴스 메서드. 내장 메서드는 이를 지원하는 형에서 설명됩니다.</p>
<p>인스턴스를 통해 메서드(클래스 이름 공간에 정의 된 함수)에 액세스하면, 특별한 객체인 <em class="dfn">연결된 메서드 (bound method)</em> (<em class="dfn">인스턴스 메서드 (instance method)</em> 라고도 부릅니다) 객체를 얻게 됩니다. 호출되면 인자 목록에 <code class="docutils literal"><span class="pre">self</span></code> 인자를 추가합니다. 연결된 메서드는 두 가지 특수한 읽기 전용 어트리뷰트를 가지고 있습니다: <code class="docutils literal"><span class="pre">m.__self__</span></code> 는 메서드가 작동하는 객체이고, <code class="docutils literal"><span class="pre">m.__func__</span></code> 는 메서드를 구현하는 함수입니다. <code class="docutils literal"><span class="pre">m(arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span> <span class="pre">arg-n)</span></code> 을 호출하는 것은 <code class="docutils literal"><span class="pre">m.__func__(m.__self__,</span> <span class="pre">arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span> <span class="pre">arg-n)</span></code> 를 호출하는 것과 완전히 같습니다.</p>
<p>함수 객체와 같이, 연결된 메서드 객체는 임의 어트리뷰트를 읽는 것을 지원합니다. 그러나 메서드 어트리뷰트는 실제로 하부 함수 객체(<code class="docutils literal"><span class="pre">meth.__func__</span></code>)에 저장되기 때문에, 연결된 메서드에 메서드 어트리뷰트를 설정하는 것은 허용되지 않습니다. 메서드 어트리뷰트를 설정하려고 하면 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> 를 일으킵니다. 메서드 어트리뷰트를 설정하려면, 명시적으로 하부 함수 객체에 설정해야 합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s1">&#39;my name is method&#39;</span>  <span class="c1"># can&#39;t set on the method</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;method&#39; object has no attribute &#39;whoami&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="vm">__func__</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s1">&#39;my name is method&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">whoami</span>
<span class="go">&#39;my name is method&#39;</span>
</pre></div>
</div>
<p>자세한 정보는 <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">표준형 계층</span></a>를 보십시오.</p>
</div>
<div class="section" id="code-objects">
<span id="bltin-code-objects"></span><span id="index-50"></span><h3>4.12.5. 코드 객체<a class="headerlink" href="#code-objects" title="제목 주소">¶</a></h3>
<p id="index-51">코드 객체는 함수 바디와 같은 &quot;의사 컴파일된&quot; 실행 가능한 파이썬 코드를 표현하기 위해 구현에서 사용됩니다. 전역 실행 환경에 대한 참조가 없으므로 함수 객체와 다릅니다. 코드 객체는 내장 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a> 함수가 돌려주고, 함수 객체들로부터 <code class="xref py py-attr docutils literal"><span class="pre">__code__</span></code> 어트리뷰트를 통해 추출할 수 있습니다. <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal"><span class="pre">code</span></code></a> 모듈도 참고하십시오.</p>
<p id="index-52">코드 객체는 <a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> 또는 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a> 내장 함수에 (소스 문자열 대신) 전달하여 실행하거나 값을 구할 수 있습니다.</p>
<p>자세한 정보는 <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">표준형 계층</span></a>를 보십시오.</p>
</div>
<div class="section" id="type-objects">
<span id="bltin-type-objects"></span><h3>4.12.6. 형 객체<a class="headerlink" href="#type-objects" title="제목 주소">¶</a></h3>
<p id="index-53">형 객체는 다양한 객체 형을 나타냅니다. 객체의 형은 내장 함수 <a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a>으로 액세스할 수 있습니다. 형에는 특별한 연산이 없습니다. 표준 모듈 <a class="reference internal" href="types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal"><span class="pre">types</span></code></a> 는 모든 표준 내장형의 이름을 정의합니다.</p>
<p>형은 다음과 같이 쓰입니다: <code class="docutils literal"><span class="pre">&lt;class</span> <span class="pre">'int'&gt;</span></code>.</p>
</div>
<div class="section" id="the-null-object">
<span id="bltin-null-object"></span><h3>4.12.7. 널 객체<a class="headerlink" href="#the-null-object" title="제목 주소">¶</a></h3>
<p>이 객체는 명시적으로 값을 돌려주지 않는 함수에 의해 반환됩니다. 특별한 연산을 지원하지 않습니다. 정확하게 하나의 널 객체가 있으며, 이름은 <code class="docutils literal"><span class="pre">None``(내장</span> <span class="pre">이름)입니다.</span> <span class="pre">``type(None)()</span></code> 은 같은 싱글톤을 만듭니다.</p>
<p><code class="docutils literal"><span class="pre">None</span></code> 이라고 쓰입니다.</p>
</div>
<div class="section" id="the-ellipsis-object">
<span id="bltin-ellipsis-object"></span><h3>4.12.8. Ellipsis 객체<a class="headerlink" href="#the-ellipsis-object" title="제목 주소">¶</a></h3>
<p>이 객체는 일반적으로 슬라이싱에 사용됩니다 (<a class="reference internal" href="../reference/expressions.html#slicings"><span class="std std-ref">슬라이싱(Slicings)</span></a> 를 참조하세요). 특별한 연산을 지원하지 않습니다. 정확하게 하나의 Ellipsis 객체가 있으며, 이름은 <code class="xref py py-const docutils literal"><span class="pre">Ellipsis`(내장</span> <span class="pre">이름)입니다.</span> <span class="pre">``type(Ellipsis)()`</span></code> 는 <a class="reference internal" href="constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal"><span class="pre">Ellipsis</span></code></a> 싱글톤을 만듭니다.</p>
<p><code class="docutils literal"><span class="pre">Ellipsis</span></code> 나 <code class="docutils literal"><span class="pre">...</span></code> 로 쓰입니다.</p>
</div>
<div class="section" id="the-notimplemented-object">
<span id="bltin-notimplemented-object"></span><h3>4.12.9. NotImplemented 객체<a class="headerlink" href="#the-notimplemented-object" title="제목 주소">¶</a></h3>
<p>이 객체는 비교와 이항 연산이 지원하지 않는 형에 대한 요청을 받았을 때 돌려줍니다. 자세한 정보는 <a class="reference internal" href="../reference/expressions.html#comparisons"><span class="std std-ref">비교</span></a>를 보십시오. 정확하게 하나의 <code class="docutils literal"><span class="pre">NotImplemented</span></code> 객체가 있습니다. <code class="docutils literal"><span class="pre">type(NotImplemented)()</span></code> 는 싱글톤 인스턴스를 만듭니다.</p>
<p><code class="docutils literal"><span class="pre">NotImplemented</span></code> 로 쓰입니다.</p>
</div>
<div class="section" id="boolean-values">
<span id="bltin-boolean-values"></span><h3>4.12.10. 논리값<a class="headerlink" href="#boolean-values" title="제목 주소">¶</a></h3>
<p>논리값은 두 개의 상수 객체인 <code class="docutils literal"><span class="pre">False</span></code> 와 <code class="docutils literal"><span class="pre">True</span></code> 입니다. 이것들은 논리값을 나타내기 위해 사용됩니다 (하지만 다른 값도 거짓 또는 참으로 간주 될 수 있습니다). 숫자 컨텍스트(예를 들어, 산술 연산자의 인자로 사용될 때)에서는 각각 정수 0과 1처럼 작동합니다. 내장 함수 <a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-func docutils literal"><span class="pre">bool()</span></code></a> 은 값이 논리값으로 해석될 수 있는 경우 모든 값을 논리값으로 변환하는 데 사용할 수 있습니다 (위의 <a class="reference internal" href="#truth"><span class="std std-ref">논리값 검사</span></a> 절을 참조하세요).</p>
<p id="index-54">각각 <code class="docutils literal"><span class="pre">False</span></code> 과 <code class="docutils literal"><span class="pre">True</span></code> 로 쓰입니다.</p>
</div>
<div class="section" id="internal-objects">
<span id="typesinternal"></span><h3>4.12.11. 내부 객체<a class="headerlink" href="#internal-objects" title="제목 주소">¶</a></h3>
<p>여기에 관한 정보는 <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">표준형 계층</span></a>를 참조하십시오. 스택 프레임 객체, 트레이스백 객체 및 슬라이스 객체에 관해 설명합니다.</p>
</div>
</div>
<div class="section" id="special-attributes">
<span id="specialattrs"></span><h2>4.13. 특수 어트리뷰트<a class="headerlink" href="#special-attributes" title="제목 주소">¶</a></h2>
<p>관련성이 있을 때, 구현은 몇 가지 객체 유형에 몇 가지 특수 읽기 전용 어트리뷰트를 추가합니다. 이 중 일부는 <a class="reference internal" href="functions.html#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> 내장 함수에 의해 보고되지 않습니다.</p>
<dl class="attribute">
<dt id="object.__dict__">
<code class="descclassname">object.</code><code class="descname">__dict__</code><a class="headerlink" href="#object.__dict__" title="정의 주소">¶</a></dt>
<dd><p>객체의 (쓰기 가능한) 어트리뷰트를 저장하는 데 사용되는 딕셔너리나 또는 기타 매핑 객체.</p>
</dd></dl>

<dl class="attribute">
<dt id="instance.__class__">
<code class="descclassname">instance.</code><code class="descname">__class__</code><a class="headerlink" href="#instance.__class__" title="정의 주소">¶</a></dt>
<dd><p>클래스 인스턴스가 속한 클래스.</p>
</dd></dl>

<dl class="attribute">
<dt id="class.__bases__">
<code class="descclassname">class.</code><code class="descname">__bases__</code><a class="headerlink" href="#class.__bases__" title="정의 주소">¶</a></dt>
<dd><p>클래스 객체의 베이스 클래스들의 튜플.</p>
</dd></dl>

<dl class="attribute">
<dt id="definition.__name__">
<code class="descclassname">definition.</code><code class="descname">__name__</code><a class="headerlink" href="#definition.__name__" title="정의 주소">¶</a></dt>
<dd><p>클래스, 함수, 메서드, 디스크립터 또는 제너레이터 인스턴스의 이름.</p>
</dd></dl>

<dl class="attribute">
<dt id="definition.__qualname__">
<code class="descclassname">definition.</code><code class="descname">__qualname__</code><a class="headerlink" href="#definition.__qualname__" title="정의 주소">¶</a></dt>
<dd><p>클래스, 함수, 메서드, 디스크립터 또는 제너레이터 인스턴스의 <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">정규화된 이름</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="class.__mro__">
<code class="descclassname">class.</code><code class="descname">__mro__</code><a class="headerlink" href="#class.__mro__" title="정의 주소">¶</a></dt>
<dd><p>이 어트리뷰트는 메서드 결정 중에 베이스 클래스를 찾을 때 고려되는 클래스들의 튜플입니다.</p>
</dd></dl>

<dl class="method">
<dt id="class.mro">
<code class="descclassname">class.</code><code class="descname">mro</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#class.mro" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 인스턴스의 메서드 결정 순서를 사용자 정의하기 위해 메타 클래스가 재정의할 수 있습니다. 클래스 인스턴스를 만들 때 호출되며 그 결과는 <a class="reference internal" href="#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal"><span class="pre">__mro__</span></code></a> 에 저장됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="class.__subclasses__">
<code class="descclassname">class.</code><code class="descname">__subclasses__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasses__" title="정의 주소">¶</a></dt>
<dd><p>각 클래스는 직계 서브 클래스에 대한 약한 참조의 리스트를 유지합니다. 이 메서드는 아직 살아있는 모든 참조의 리스트를 돌려줍니다. 예:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>
<span class="go">[&lt;class &#39;bool&#39;&gt;]</span>
</pre></div>
</div>
</dd></dl>

<p class="rubric">각주</p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>이 특수 메서드에 대한 추가 정보는 파이썬 레퍼런스 설명서(<a class="reference internal" href="../reference/datamodel.html#customization"><span class="std std-ref">기본적인 커스터마이제이션</span></a>)에서 찾을 수 있습니다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>결과적으로, 리스트 <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2]</span></code> 는 <code class="docutils literal"><span class="pre">[1.0,</span> <span class="pre">2.0]</span></code> 과 같다고 취급되고, 튜플도 마찬가지입니다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>파서가 피연산자 유형을 알 수 없으므로 그럴 수밖에 없습니다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id7">2</a>, <a class="fn-backref" href="#id8">3</a>, <a class="fn-backref" href="#id9">4</a>)</em> 케이스 문자는 일반 범주 속성이 &quot;Lu&quot; (Letter, 대문자), &quot;Ll&quot; (Letter, 소문자), &quot;Lt&quot; (Letter, 제목 문자) 중 한 가지인 경우입니다.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id11">2</a>)</em> 그래서, 튜플만을 포매팅하려면 포맷할 튜플 하나만을 포함하는 1-튜플을 제공해야 합니다.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">4. 내장형</a><ul>
<li><a class="reference internal" href="#truth-value-testing">4.1. 논리값 검사</a></li>
<li><a class="reference internal" href="#boolean-operations-and-or-not">4.2. 논리 연산 --- <code class="docutils literal"><span class="pre">and</span></code>, <code class="docutils literal"><span class="pre">or</span></code>, <code class="docutils literal"><span class="pre">not</span></code></a></li>
<li><a class="reference internal" href="#comparisons">4.3. 비교</a></li>
<li><a class="reference internal" href="#numeric-types-int-float-complex">4.4. 숫자 형 --- <code class="docutils literal"><span class="pre">int</span></code>, <code class="docutils literal"><span class="pre">float</span></code>, <code class="docutils literal"><span class="pre">complex</span></code></a><ul>
<li><a class="reference internal" href="#bitwise-operations-on-integer-types">4.4.1. 정수 형에 대한 비트 연산</a></li>
<li><a class="reference internal" href="#additional-methods-on-integer-types">4.4.2. 정수 형에 대한 추가 메서드</a></li>
<li><a class="reference internal" href="#additional-methods-on-float">4.4.3. 실수에 대한 추가 메서드</a></li>
<li><a class="reference internal" href="#hashing-of-numeric-types">4.4.4. 숫자 형의 해싱</a></li>
</ul>
</li>
<li><a class="reference internal" href="#iterator-types">4.5. 이터레이터 형</a><ul>
<li><a class="reference internal" href="#generator-types">4.5.1. 제너레이터 형</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequence-types-list-tuple-range">4.6. 시퀀스 형 --- <code class="docutils literal"><span class="pre">list</span></code>, <code class="docutils literal"><span class="pre">tuple</span></code>, <code class="docutils literal"><span class="pre">range</span></code></a><ul>
<li><a class="reference internal" href="#common-sequence-operations">4.6.1. 공통 시퀀스 연산</a></li>
<li><a class="reference internal" href="#immutable-sequence-types">4.6.2. 불변 시퀀스 형</a></li>
<li><a class="reference internal" href="#mutable-sequence-types">4.6.3. 가변 시퀀스 형</a></li>
<li><a class="reference internal" href="#lists">4.6.4. 리스트</a></li>
<li><a class="reference internal" href="#tuples">4.6.5. 튜플</a></li>
<li><a class="reference internal" href="#ranges">4.6.6. 범위</a></li>
</ul>
</li>
<li><a class="reference internal" href="#text-sequence-type-str">4.7. 텍스트 시퀀스 형 --- <code class="docutils literal"><span class="pre">str</span></code></a><ul>
<li><a class="reference internal" href="#string-methods">4.7.1. 문자열 메서드</a></li>
<li><a class="reference internal" href="#printf-style-string-formatting">4.7.2. <code class="docutils literal"><span class="pre">printf</span></code> 스타일 문자열 포매팅</a></li>
</ul>
</li>
<li><a class="reference internal" href="#binary-sequence-types-bytes-bytearray-memoryview">4.8. 바이너리 시퀀스 형 --- <code class="docutils literal"><span class="pre">bytes</span></code>, <code class="docutils literal"><span class="pre">bytearray</span></code>, <code class="docutils literal"><span class="pre">memoryview</span></code></a><ul>
<li><a class="reference internal" href="#bytes-objects">4.8.1. 바이트열 객체</a></li>
<li><a class="reference internal" href="#bytearray-objects">4.8.2. 바이트 배열 객체</a></li>
<li><a class="reference internal" href="#bytes-and-bytearray-operations">4.8.3. 바이트열 과 바이트 배열 연산</a></li>
<li><a class="reference internal" href="#printf-style-bytes-formatting">4.8.4. <code class="docutils literal"><span class="pre">printf</span></code> 스타일 바이너리 포매팅</a></li>
<li><a class="reference internal" href="#memory-views">4.8.5. 메모리 뷰</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-types-set-frozenset">4.9. 집합 형 --- <code class="docutils literal"><span class="pre">set</span></code>, <code class="docutils literal"><span class="pre">frozenset</span></code></a></li>
<li><a class="reference internal" href="#mapping-types-dict">4.10. 매핑 형 --- <code class="docutils literal"><span class="pre">dict</span></code></a><ul>
<li><a class="reference internal" href="#dictionary-view-objects">4.10.1. 딕셔너리 뷰 객체</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-manager-types">4.11. 컨텍스트 관리자 형</a></li>
<li><a class="reference internal" href="#other-built-in-types">4.12. 기타 내장형</a><ul>
<li><a class="reference internal" href="#modules">4.12.1. 모듈</a></li>
<li><a class="reference internal" href="#classes-and-class-instances">4.12.2. 클래스와 클래스 인스턴스</a></li>
<li><a class="reference internal" href="#functions">4.12.3. 함수</a></li>
<li><a class="reference internal" href="#methods">4.12.4. 메서드</a></li>
<li><a class="reference internal" href="#code-objects">4.12.5. 코드 객체</a></li>
<li><a class="reference internal" href="#type-objects">4.12.6. 형 객체</a></li>
<li><a class="reference internal" href="#the-null-object">4.12.7. 널 객체</a></li>
<li><a class="reference internal" href="#the-ellipsis-object">4.12.8. Ellipsis 객체</a></li>
<li><a class="reference internal" href="#the-notimplemented-object">4.12.9. NotImplemented 객체</a></li>
<li><a class="reference internal" href="#boolean-values">4.12.10. 논리값</a></li>
<li><a class="reference internal" href="#internal-objects">4.12.11. 내부 객체</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-attributes">4.13. 특수 어트리뷰트</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="constants.html"
                        title="이전 장">3. 내장 상수</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="exceptions.html"
                        title="다음 장">5. Built-in Exceptions</a></p>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/stdtypes.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="exceptions.html" title="5. Built-in Exceptions"
             >다음</a> |</li>
        <li class="right" >
          <a href="constants.html" title="3. 내장 상수"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2018, Flowdas. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 를 사용해서 만들었습니다.
    </div>

  </body>
</html>