
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>4. 내장 형 &#8212; Python 3.6.5 documentation</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.6.5 documentation에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="5. Built-in Exceptions" href="exceptions.html" />
    <link rel="prev" title="3. 내장 상수" href="constants.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="http://python.flowdas.com/library/stdtypes.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="exceptions.html" title="5. Built-in Exceptions"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="constants.html" title="3. 내장 상수"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 표준 라이브러리</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="built-in-types">
<span id="bltin-types"></span><h1>4. 내장 형<a class="headerlink" href="#built-in-types" title="제목 주소">¶</a></h1>
<p>다음 섹션에서는 인터프리터에 내장 된 표준 형에 대해 설명합니다.</p>
<p id="index-0">기본 내장 유형은 숫자, 시퀀스, 매핑, 클래스, 인스턴스 및 예외입니다.</p>
<p>일부 컬렉션 클래스는 가변입니다. 제자리에서 멤버를 추가, 삭제 또는 재배치하고 특정 항목을 반환하지 않는 메서드는 컬렉션 인스턴스 자체를 반환하지 않고 <code class="docutils literal"><span class="pre">None</span></code> 을 반환합니다.</p>
<p>일부 연산들은 여러 객체 형에서 지원됩니다; 특히 사실상 모든 객체를 비교하고, 논리값을 검사하고, (<a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 함수 또는 약간 다른 <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> 함수를 사용해서) 문자열로 변환 할 수 있습니다. 두번째 함수는 <a class="reference internal" href="functions.html#print" title="print"><code class="xref py py-func docutils literal"><span class="pre">print()</span></code></a> 함수로 객체를 쓸 때 묵시적으로 사용됩니다.</p>
<div class="section" id="truth-value-testing">
<span id="truth"></span><h2>4.1. 논리값 검사<a class="headerlink" href="#truth-value-testing" title="제목 주소">¶</a></h2>
<p id="index-1">모든 객체는 논리값을 검사할 수 있는데, <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> 또는 <a class="reference internal" href="../reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal"><span class="pre">while</span></code></a> 조건 또는 다음에 나오는 논리 연산의 피연산자로 사용될 수 있도록 합니다.</p>
<p id="index-2">기본적으로 객체는 클래스가 그 객체에 대해 호출될 때 <code class="docutils literal"><span class="pre">False</span></code> 를 돌려주는 <a class="reference internal" href="../reference/datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal"><span class="pre">__bool__()</span></code></a> 메서드나 0을 돌려주는 <a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal"><span class="pre">__len__()</span></code></a> 메서드를 정의하지 않는 한 참으로 간주됩니다. <a class="footnote-reference" href="#id12" id="id1">[1]</a> 여기에 거짓으로 간주되는 대부분의 내장 객체들이 있습니다:</p>
<blockquote>
<div></div></blockquote>
<ul class="simple" id="index-3">
<li>거짓으로 정의 된 상수: <code class="docutils literal"><span class="pre">None</span></code> 과 <code class="docutils literal"><span class="pre">False</span></code>.</li>
<li>모든 숫자형들의 영: <code class="docutils literal"><span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">0.0</span></code>, <code class="docutils literal"><span class="pre">0j</span></code>, <code class="docutils literal"><span class="pre">Decimal(0)</span></code>, <code class="docutils literal"><span class="pre">Fraction(0,</span> <span class="pre">1)</span></code></li>
<li>빈 시퀀스와 컬렉션: <code class="docutils literal"><span class="pre">''</span></code>, <code class="docutils literal"><span class="pre">()</span></code>, <code class="docutils literal"><span class="pre">[]</span></code>, <code class="docutils literal"><span class="pre">{}</span></code>, <code class="docutils literal"><span class="pre">set()</span></code>, <code class="docutils literal"><span class="pre">range(0)</span></code></li>
</ul>
<p id="index-4">논리 값을 돌려주는 연산 과 내장 함수는 달리 명시하지 않는 한 항상 거짓의 경우 <code class="docutils literal"><span class="pre">0</span></code> 이나 <code class="docutils literal"><span class="pre">False</span></code> 를, 참인 경우 <code class="docutils literal"><span class="pre">1</span></code> 이나 <code class="docutils literal"><span class="pre">True</span></code> 를 돌려줍니다. (중요한 예외: 논리 연산 <code class="docutils literal"><span class="pre">or</span></code> 와 <code class="docutils literal"><span class="pre">and</span></code> 는 항상 피연산자 중 하나를 돌려줍니다.)</p>
</div>
<div class="section" id="boolean-operations-and-or-not">
<span id="boolean"></span><h2>4.2. 논리 연산 --- <a class="reference internal" href="../reference/expressions.html#and"><code class="xref std std-keyword docutils literal"><span class="pre">and</span></code></a>, <a class="reference internal" href="../reference/expressions.html#or"><code class="xref std std-keyword docutils literal"><span class="pre">or</span></code></a>, <a class="reference internal" href="../reference/expressions.html#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a><a class="headerlink" href="#boolean-operations-and-or-not" title="제목 주소">¶</a></h2>
<p id="index-5">이 것들은 우선 순위에 따라 오름차순으로 정렬된 논리 연산들입니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="62%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산</th>
<th class="head">결과</th>
<th class="head">노트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code></td>
<td><em>x</em> 가 거짓이면 <em>y</em>, 그렇지 않으면 <em>x</em></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code></td>
<td><em>x*가 거짓이면 *x</em>, 그렇지 않으면 <em>y</em></td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">not</span> <span class="pre">x</span></code></td>
<td><em>x</em> 가 거짓이면 <code class="docutils literal"><span class="pre">True</span></code>, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code></td>
<td>(3)</td>
</tr>
</tbody>
</table>
<p id="index-6">노트:</p>
<ol class="arabic simple">
<li>이것은 단락-회로 연산자이므로 첫 번째 인자가 거짓일 때만 두 번째의 값을 구합니다.</li>
<li>이것은 단락-회로 연산자이므로 첫 번째 인자가 참일때만 두 번째의 값을 구합니다.</li>
<li><code class="docutils literal"><span class="pre">not</span></code> 은 비논리 연산자들보다 낮은 우선순위를 갖습니다. 그래서, <code class="docutils literal"><span class="pre">not</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code> 는 <code class="docutils literal"><span class="pre">not</span> <span class="pre">(a</span> <span class="pre">==</span> <span class="pre">b)</span></code> 로 해석되고, <code class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">not</span> <span class="pre">b</span></code> 는 문법 오류입니다.</li>
</ol>
</div>
<div class="section" id="comparisons">
<span id="stdcomparisons"></span><h2>4.3. 비교<a class="headerlink" href="#comparisons" title="제목 주소">¶</a></h2>
<p id="index-7">파이썬에는 8 가지 비교 연산이 있습니다. 이들 모두는 동일한 우선 순위를 가집니다 (논리 연산 보다는 높습니다). 비교는 임의로 연결될 수 있습니다; 예를 들어 <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> 는 <em>y</em> 의 값을 한번만 구한다는 점을 제외하고는 <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> 와 동등합니다 (하지만 두 경우 모두 <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> 가 거짓으로 밝혀지면 <em>z</em> 의 값을 구하지 않습니다).</p>
<p>이 표는 비교 연산을 요약합니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산</th>
<th class="head">뜻</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&lt;</span></code></td>
<td>엄격히 작다</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;=</span></code></td>
<td>작거나 같다</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&gt;</span></code></td>
<td>엄격히 크다</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&gt;=</span></code></td>
<td>크거나 같다</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">==</span></code></td>
<td>같다</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">!=</span></code></td>
<td>같지 않다</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">is</span></code></td>
<td>객체 아이덴티티</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></td>
<td>부정 된 객체 아이덴티티</td>
</tr>
</tbody>
</table>
<p id="index-8">서로 다른 숫자 형을 제외하고는 서로 다른 형의 객체들은 같다고 비교되지 않습니다. 더 나아가, 어떤 형들은 (예를 들어, 함수 객체) 그 형의 모든 두 객체들이 다르다고 비교되는 비교의 축약적인 개념만을 지원합니다. <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code> 연산자들은 복소수를 다른 내장 숫자 형과 비교할 때, 객체들이 비교될 수 없는 다른 형일 때, 정의된 순서가 없을 때 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 예외를 일으킵니다.</p>
<p id="index-9">클래스의 동일하지 않은 인스턴스들은 그 클래스가 <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> 메서드를 정의하지 않는 이상 보통 같지 않다고 비교됩니다.</p>
<p>클래스가 <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal"><span class="pre">__le__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal"><span class="pre">__gt__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal"><span class="pre">__ge__()</span></code></a> 메서드들을 충분히 정의하지 않는 이상, 클래스의 인스턴스들은 같은 클래스의 다른 인스턴스나 다른 형의 객체와의 순서를 정할 수 없습니다 (일반적으로, 여러분이 비교 연산자의 관습적인 의미를 원한다면 <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a> 와 <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a> 만으로 충분합니다).</p>
<p><a class="reference internal" href="../reference/expressions.html#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a> 와 <a class="reference internal" href="../reference/expressions.html#is-not"><code class="xref std std-keyword docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></a> 연산자의 동작은 사용자 정의 할 수 없습니다; 또한 임의의 두 객체에 적용 할 수 있으며 예외를 발생시키지 않습니다.</p>
<p id="index-10">동일한 문법적 우선 순위를 갖는 두 개의 연산, <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 과 <a class="reference internal" href="../reference/expressions.html#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a>, 은 (아래에 나오는) 시퀀스 형 에서만 지원됩니다.</p>
</div>
<div class="section" id="numeric-types-int-float-complex">
<span id="typesnumeric"></span><h2>4.4. 숫자 형 --- <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a><a class="headerlink" href="#numeric-types-int-float-complex" title="제목 주소">¶</a></h2>
<p id="index-11">세 가지 다른 숫자 형이 있습니다: <em class="dfn">정수 (integers)</em>, <em class="dfn">실수 (floating point numbers)</em>, <em class="dfn">복소수 (complex numbers)</em>. 또한 논리형은 정수의 하위 유형입니다. 정수는 무제한의 정밀도를 갖습니다. 실수는 보통 C 의 <code class="xref c c-type docutils literal"><span class="pre">double</span></code> 을 사용해서 구현됩니다; 프로그램이 실행되고있는 기계의 부동 소수점 숫자의 정밀도와 내부 표현에 관한 정보는 <a class="reference internal" href="sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal"><span class="pre">sys.float_info</span></code></a> 에서 얻을 수 있습니다. 복소수는 각각 실수로 표현되는 실수부와 허수부를 가집니다. 복소수 <em>z</em> 에서 이들 부분을 추출하려면 <code class="docutils literal"><span class="pre">z.real</span></code> 과 <code class="docutils literal"><span class="pre">z.imag</span></code> 를 사용하십시오. (표준 라이브러리는 추가적인 숫자 형들을 포함하는데, <a class="reference internal" href="fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal"><span class="pre">fractions</span></code></a> 은 유리수를, <a class="reference internal" href="decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code></a> 은 사용자가 정의할 수 있는 정밀도로 부동 소수점 숫자를 다룹니다.)</p>
<p id="index-12">숫자는 숫자 리터럴 또는 내장 함수와 연산자의 결과로 만들어집니다. 꾸밈없는 정수 리터럴(16 진수, 8 진수, 2 진수 포함)은 정수를 만듭니다. 소수점 또는 지수 기호가 포함 된 숫자 리터럴은 실수를 만듭니다. 숫자 리터럴에 <code class="docutils literal"><span class="pre">'j'</span></code> 나 <code class="docutils literal"><span class="pre">'J'</span></code> 를 덧붙이면 허수 (실수부가 0인 복소수) 가 만들어 지는데, 정수나 실수에 더해서 실수부와 허수부가 있는 복소수를 만들 수 있습니다.</p>
<p id="index-13">파이썬은 혼합 산술을 완벽하게 지원합니다: 이항 산술 연산자가 다른 숫자 형의 피연산자를 가질 때, &quot;더 좁은&quot; 형의 피연산자는 다른 피연산자의 형으로 넓혀집니다. 정수는 실수보다 좁고, 실수는 복소수보다 좁습니다. 혼합 형 숫자 사이의 비교는 같은 규칙을 사용합니다. <a class="footnote-reference" href="#id13" id="id2">[2]</a> 생성자 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a>, <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a> 를 특정 형의 숫자를 만드는데 사용할 수 있습니다.</p>
<p>(복소수를 제외한) 모든 숫자 형은 다음과 같은 연산들을 지원하는데, 우선 순위에 따라 오름차순 정렬되어 있습니다 (모든 숫자 연산은 비교 연산보다 높은 우선 순위를 갖습니다):</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="40%" />
<col width="11%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산</th>
<th class="head">결과</th>
<th class="head">노트</th>
<th class="head">전체 문서</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 합</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 차</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 곱</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 몫</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">//</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 정수로 내림한 몫</td>
<td>(1)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code></td>
<td><code class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> 의 나머지</td>
<td>(2)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">-x</span></code></td>
<td>음의 <em>x</em></td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">+x</span></code></td>
<td><em>x</em> 그대로</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">abs(x)</span></code></td>
<td><em>x</em> 의 절대 값 또는 크기</td>
<td>&#160;</td>
<td><a class="reference internal" href="functions.html#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">int(x)</span></code></td>
<td>정수로 변환된 <em>x</em></td>
<td>(3)(6)</td>
<td><a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-func docutils literal"><span class="pre">int()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">float(x)</span></code></td>
<td>실수로 변환된 <em>x</em></td>
<td>(4)(6)</td>
<td><a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-func docutils literal"><span class="pre">float()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">complex(re,</span> <span class="pre">im)</span></code></td>
<td>실수부 <em>re</em> 와 허수부 <em>im</em> 으로 구성된 복소수. <em>im</em> 의 기본값은 0 입니다.</td>
<td>(6)</td>
<td><a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-func docutils literal"><span class="pre">complex()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">c.conjugate()</span></code></td>
<td>복소수 <em>c</em> 의 켤레</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">divmod(x,</span> <span class="pre">y)</span></code></td>
<td>쌍 <code class="docutils literal"><span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y,</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y)</span></code></td>
<td>(2)</td>
<td><a class="reference internal" href="functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">y)</span></code></td>
<td><em>x</em> 의 <em>y</em> 거듭 제곱</td>
<td>(5)</td>
<td><a class="reference internal" href="functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">y</span></code></td>
<td><em>x</em> 의 <em>y</em> 거듭 제곱</td>
<td>(5)</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p id="index-14">노트:</p>
<ol class="arabic">
<li><p class="first">정수 나눗셈이라고도합니다. 결과 값의 형이 꼭 int 일 필요는 없지만, 결과 값은 항상 정수입니다. 결과는 항상 음의 무한대를 향해 내림됩니다: <code class="docutils literal"><span class="pre">1//2</span></code> 는 <code class="docutils literal"><span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">(-1)//2</span></code> 는 <code class="docutils literal"><span class="pre">-1</span></code>, <code class="docutils literal"><span class="pre">1//(-2)</span></code> 는 <code class="docutils literal"><span class="pre">-1</span></code>, <code class="docutils literal"><span class="pre">(-1)//(-2)</span></code> 는 <code class="docutils literal"><span class="pre">0</span></code> 입니다.</p>
</li>
<li><p class="first">복소수에는 사용할 수 없습니다. 적절한 경우 <a class="reference internal" href="functions.html#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a> 을 사용하여 실수로 변환하십시오.</p>
</li>
<li><p id="index-15">실수에서 정수로의 변환은 C 에서 처럼 반올림이나 자름이 발생할 수 있습니다; 잘 정의 된 변환을 위해서는 <a class="reference internal" href="math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal"><span class="pre">math.floor()</span></code></a> 와 <a class="reference internal" href="math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal"><span class="pre">math.ceil()</span></code></a> 함수를 보십시오.</p>
</li>
<li><p class="first">float 는 또한 숫자가 아님 (NaN) 과 양 또는 음의 무한대를 나타내는 문자열 &quot;nan&quot; 과 접두사 &quot;+&quot; 나 &quot;-&quot; 가 선택적으로 붙을 수 있는 &quot;inf&quot; 를 받아들입니다.</p>
</li>
<li><p class="first">파이썬은 프로그래밍 언어들에서 흔히 그렇듯이, 있는 것처럼 <code class="docutils literal"><span class="pre">pow(0,</span> <span class="pre">0)</span></code> 와 <code class="docutils literal"><span class="pre">0</span> <span class="pre">**</span> <span class="pre">0</span></code> 이 <code class="docutils literal"><span class="pre">1</span></code> 이 되도록 정의합니다.</p>
</li>
<li><p class="first">받아 들여지는 숫자 리터럴은 <code class="docutils literal"><span class="pre">0</span></code> 에서 <code class="docutils literal"><span class="pre">9</span></code> 까지 또는 모든 동등한 유니 코드들을 (<code class="docutils literal"><span class="pre">Nd</span></code> 속성을 가진 코드 포인트들) 포함합니다.</p>
<p><code class="docutils literal"><span class="pre">Nd</span></code> 속성을 가진 코드 포인트의 전체 목록을 보려면 <a class="reference external" href="http://www.unicode.org/Public/9.0.0/ucd/extracted/DerivedNumericType.txt">http://www.unicode.org/Public/9.0.0/ucd/extracted/DerivedNumericType.txt</a> 를 보십시오.</p>
</li>
</ol>
<p>모든 <a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal"><span class="pre">numbers.Real</span></code></a> 형 (<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 와 <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>) 은 또한 다음과 같은 연산들을 포함합니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산</th>
<th class="head">결과</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal"><span class="pre">math.trunc(x)</span></code></a></td>
<td><em>x</em> 는 <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a> 로 잘립니다</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="functions.html#round" title="round"><code class="xref py py-func docutils literal"><span class="pre">round(x[,</span>
<span class="pre">n])</span></code></a></td>
<td><em>x</em> 를 <em>n</em> 자리로 반올림하는데, 절반값은 짝수로 반올림합니다. <em>n</em> 을 생략하면 기본값은 0 입니다.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal"><span class="pre">math.floor(x)</span></code></a></td>
<td>가장 큰 <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a> &lt;= <em>x</em></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal"><span class="pre">math.ceil(x)</span></code></a></td>
<td>가장 작은 <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a> &gt;= <em>x</em></td>
</tr>
</tbody>
</table>
<p>추가적인 숫자 연산은 <a class="reference internal" href="math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal"><span class="pre">math</span></code></a> 와 <a class="reference internal" href="cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal"><span class="pre">cmath</span></code></a> 모듈을 보십시오.</p>
<div class="section" id="bitwise-operations-on-integer-types">
<span id="bitstring-ops"></span><h3>4.4.1. 정수 형에 대한 비트 연산<a class="headerlink" href="#bitwise-operations-on-integer-types" title="제목 주소">¶</a></h3>
<p id="index-16">비트 연산은 정수에 대해서만 의미가 있습니다. 음수는 2의 보수 값으로 처리됩니다 (이는 연산 중에 오버플로가 발생하지 않도록 충분한 비트가 있다고 가정합니다).</p>
<p>이진 비트 연산의 우선 순위는 모두 숫자 연산보다 낮고 비교보다 높습니다; 일항 연산 <code class="docutils literal"><span class="pre">~</span></code> 은 다른 일항 연산들 (<code class="docutils literal"><span class="pre">+</span></code> 와 <code class="docutils literal"><span class="pre">-</span></code>) 과 동일한 우선 순위를 가집니다.</p>
<p>이 표는 비트 연산을 나열하는데, 우선 순위에 따라 오름차순으로 정렬되어 있습니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="59%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산</th>
<th class="head">결과</th>
<th class="head">노트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">|</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 비트별 <em class="dfn">or</em></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">^</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 비트별 <em class="dfn">배타적 or (exclusive or)</em></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">&amp;</span> <span class="pre">y</span></code></td>
<td><em>x</em> 와 <em>y</em> 의 비트별 <em class="dfn">and</em></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">n</span></code></td>
<td><em>x</em> 를 <em>n</em> 비트만큼 왼쪽으로 시프트</td>
<td>(1)(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">n</span></code></td>
<td><em>x</em> 를 <em>n</em> 비트만큼 오른쪽으로 시프트</td>
<td>(1)(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">~x</span></code></td>
<td><em>x</em> 의 비트 반전</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>노트:</p>
<ol class="arabic simple">
<li>음의 시프트 수는 허락되지 않고 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</li>
<li><em>n</em> 비트만큼의 왼쪽 쉬프트는 오버 플로우 검사없이 <code class="docutils literal"><span class="pre">pow(2,</span> <span class="pre">n)</span></code> 를 곱하는 것과 동등합니다.</li>
<li><em>n</em> 비트만큼 오른쪽으로 시프트하는 것은 오버 플로우 검사없이 <code class="docutils literal"><span class="pre">pow(2,</span> <span class="pre">n)</span></code> 로 나누는 것과 동등합니다.</li>
</ol>
</div>
<div class="section" id="additional-methods-on-integer-types">
<h3>4.4.2. 정수 형에 대한 추가 메서드<a class="headerlink" href="#additional-methods-on-integer-types" title="제목 주소">¶</a></h3>
<p>int 형은 <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal"><span class="pre">numbers.Integral</span></code></a> <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">추상 베이스 클래스</span></a> 를 구현합니다. 또한 몇 가지 메서드를 더 제공합니다:</p>
<dl class="method">
<dt id="int.bit_length">
<code class="descclassname">int.</code><code class="descname">bit_length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#int.bit_length" title="정의 주소">¶</a></dt>
<dd><p>부호와 선행 0을 제외하고, 이진수로 정수를 나타 내기 위해 필요한 비트 수를 돌려줍니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">&#39;-0b100101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<p>좀 더 정확하게 말하자면, <code class="docutils literal"><span class="pre">x</span></code> 가 0이 아니면, <code class="docutils literal"><span class="pre">x.bit_length()</span></code> 는 <code class="docutils literal"><span class="pre">2**(k-1)</span> <span class="pre">&lt;=</span> <span class="pre">abs(x)</span> <span class="pre">&lt;</span> <span class="pre">2**k</span></code> 를 만족하는 유일한 양의 정수 <code class="docutils literal"><span class="pre">k</span></code> 입니다. 동등하게, <code class="docutils literal"><span class="pre">abs(x)</span></code> 가 정확하게 반올림 된 로그값을 가질만큼 충분히 작으면, <code class="docutils literal"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">int(log(abs(x),</span> <span class="pre">2))</span></code> 가 됩니다. <code class="docutils literal"><span class="pre">x</span></code> 가 0 이면, <code class="docutils literal"><span class="pre">x.bit_length()</span></code> 는 <code class="docutils literal"><span class="pre">0</span></code> 을 돌려줍니다.</p>
<p>다음 코드와 동등합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bit_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>       <span class="c1"># binary representation:  bin(-37) --&gt; &#39;-0b100101&#39;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;-0b&#39;</span><span class="p">)</span> <span class="c1"># remove leading zeros and minus sign</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>       <span class="c1"># len(&#39;100101&#39;) --&gt; 6</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="int.to_bytes">
<code class="descclassname">int.</code><code class="descname">to_bytes</code><span class="sig-paren">(</span><em>length</em>, <em>byteorder</em>, <em>*</em>, <em>signed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#int.to_bytes" title="정의 주소">¶</a></dt>
<dd><p>정수를 나타내는 바이트의 배열을 돌려줍니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x04\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">b&#39;\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;little&#39;</span><span class="p">)</span>
<span class="go">b&#39;\xe8\x03&#39;</span>
</pre></div>
</div>
<p>정수는 <em>length</em> 바이트를 사용하여 표현됩니다. 정수가 주어진 바이트 수로 표현할 수 없는 경우 An <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> 를 일으킵니다.</p>
<p><em>byteorder</em> 인자는 정수를 나타내는 데 사용되는 바이트 순서를 결정합니다. <em>byteorder</em> 가 <code class="docutils literal"><span class="pre">&quot;big&quot;</span></code> 인 경우, 최상위 바이트는 바이트 배열의 처음에 있습니다. <em>byteorder</em> 가 <code class="docutils literal"><span class="pre">&quot;little&quot;</span></code> 인 경우, 최상위 바이트는 바이트 배열의 끝에 있습니다. 호스트 시스템의 기본 바이트 순서를 요청하려면 바이트 순서 값으로 <a class="reference internal" href="sys.html#sys.byteorder" title="sys.byteorder"><code class="xref py py-data docutils literal"><span class="pre">sys.byteorder</span></code></a> 를 사용하십시오.</p>
<p><em>signed</em> 인자는 정수를 표현하는데 2의 보수가 사용되는지 여부를 결정합니다. <em>signed</em> 가 <code class="docutils literal"><span class="pre">False</span></code> 이고 음의 정수가 주어지면, <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> 가 일어납니다. <em>signed</em> 의 기본값은 <code class="docutils literal"><span class="pre">False</span></code> 입니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="int.from_bytes">
<em class="property">classmethod </em><code class="descclassname">int.</code><code class="descname">from_bytes</code><span class="sig-paren">(</span><em>bytes</em>, <em>byteorder</em>, <em>*</em>, <em>signed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#int.from_bytes" title="정의 주소">¶</a></dt>
<dd><p>주어진 바이트 배열로 표현되는 정수를 돌려줍니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x10</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x10</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;little&#39;</span><span class="p">)</span>
<span class="go">4096</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xfc\x00</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">-1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xfc\x00</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">64512</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">([</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">16711680</span>
</pre></div>
</div>
<p>인자 <em>bytes</em> 는 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a> 이거나 바이트를 생성하는 이터러블이어야합니다.</p>
<p><em>byteorder</em> 인자는 정수를 나타내는 데 사용되는 바이트 순서를 결정합니다. <em>byteorder</em> 가 <code class="docutils literal"><span class="pre">&quot;big&quot;</span></code> 인 경우, 최상위 바이트는 바이트 배열의 처음에 있습니다. <em>byteorder</em> 가 <code class="docutils literal"><span class="pre">&quot;little&quot;</span></code> 인 경우, 최상위 바이트는 바이트 배열의 끝에 있습니다. 호스트 시스템의 기본 바이트 순서를 요청하려면 바이트 순서 값으로 <a class="reference internal" href="sys.html#sys.byteorder" title="sys.byteorder"><code class="xref py py-data docutils literal"><span class="pre">sys.byteorder</span></code></a> 를 사용하십시오.</p>
<p><em>signed</em> 인자는 정수를 표현하는데 2의 보수가 사용되는지 여부를 나타냅니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="additional-methods-on-float">
<h3>4.4.3. 실수에 대한 추가 메서드<a class="headerlink" href="#additional-methods-on-float" title="제목 주소">¶</a></h3>
<p>float 형은 <a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal"><span class="pre">numbers.Real</span></code></a> <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">추상 베이스 클래스</span></a> 를 구현합니다. 또한 float 는 다음과 같은 추가 메서드를 갖습니다.</p>
<dl class="method">
<dt id="float.as_integer_ratio">
<code class="descclassname">float.</code><code class="descname">as_integer_ratio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.as_integer_ratio" title="정의 주소">¶</a></dt>
<dd><p>비율이 원래 float 와 정확히 같고 양의 분모를 갖는 정수 쌍을 돌려줍니다. 무한대에는 <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> 를, NaN 에는 a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="float.is_integer">
<code class="descclassname">float.</code><code class="descname">is_integer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.is_integer" title="정의 주소">¶</a></dt>
<dd><p>float 인스턴스가 정수 값을 가진 유한이면 <code class="docutils literal"><span class="pre">True</span></code> 를, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code> 를 돌려줍니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<p>두 가지 메서드가 16 진수 문자열과의 변환을 지원합니다. 파이썬의 float 는 내부적으로 이진수로 저장되기 때문에 float 를 <em>십진수</em> 문자열로 또는 그 반대로 변환하는 것은 보통 반올림 오류를 수반합니다. 이에 반해, 16 진수 문자열은 부동 소수점 숫자의 정확한 표현과 지정을 가능하게 합니다. 이것은 디버깅 및 수치 작업에 유용 할 수 있습니다.</p>
<dl class="method">
<dt id="float.hex">
<code class="descclassname">float.</code><code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.hex" title="정의 주소">¶</a></dt>
<dd><p>부동 소수점의 16 진수 문자열 표현을 돌려줍니다. 유한 부동 소수점의 경우, 이 표현은 항상 선행하는 <code class="docutils literal"><span class="pre">0x</span></code> 와 후행하는 <code class="docutils literal"><span class="pre">p</span></code> 와 지수를 포함합니다.</p>
</dd></dl>

<dl class="classmethod">
<dt id="float.fromhex">
<em class="property">classmethod </em><code class="descclassname">float.</code><code class="descname">fromhex</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#float.fromhex" title="정의 주소">¶</a></dt>
<dd><p>16 진수 문자열 <em>s</em> 로 표현되는 float 를 돌려주는 클래스 메서드. 문자열 <em>s</em> 는 앞뒤 공백을 가질 수 있습니다.</p>
</dd></dl>

<p><a class="reference internal" href="#float.hex" title="float.hex"><code class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></code></a> 는 인스턴스 메서드인 반면, <a class="reference internal" href="#float.fromhex" title="float.fromhex"><code class="xref py py-meth docutils literal"><span class="pre">float.fromhex()</span></code></a> 는 클래스 메서드임에 주의하세요.</p>
<p>16 진수 문자열은 다음과 같은 형식을 취합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="p">[</span><span class="s1">&#39;0x&#39;</span><span class="p">]</span> <span class="n">integer</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span> <span class="n">fraction</span><span class="p">]</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span> <span class="n">exponent</span><span class="p">]</span>
</pre></div>
</div>
<p>선택적인 <code class="docutils literal"><span class="pre">sign</span></code> 은 <code class="docutils literal"><span class="pre">+</span></code> 나 <code class="docutils literal"><span class="pre">-</span></code> 가 될 수 있고, <code class="docutils literal"><span class="pre">integer</span></code> 와 <code class="docutils literal"><span class="pre">fraction</span></code> 은 16 진수 문자열이고, <code class="docutils literal"><span class="pre">exponent</span></code> 는 선택적인 선행 부호가 붙을 수 있는 10 진수입니다. 대소 문자는 중요하지 않으며 integer 나 fraction 중 어느 하나에 적어도 하나의 16 진수가 있어야합니다. 이 문법은 C99 표준의 6.4.4.2 절에 지정된 문법과 비슷하며, 자바 1.5 이상에서 사용되는 문법과도 비슷합니다. 특히, <a class="reference internal" href="#float.hex" title="float.hex"><code class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></code></a> 의 출력은 C 또는 자바 코드에서 16 진수의 부동 소수점 리터럴로 사용할 수 있으며, C 의 <code class="docutils literal"><span class="pre">%a</span></code> 포맷 문자나 자바의 <code class="docutils literal"><span class="pre">Double.toHexString</span></code> 가 만들어내는 16 진수 문자열은 <a class="reference internal" href="#float.fromhex" title="float.fromhex"><code class="xref py py-meth docutils literal"><span class="pre">float.fromhex()</span></code></a> 가 받아들입니다.</p>
<p>지수는 16 진수가 아닌 십진수로 쓰여지고, 숫자에 곱해지는 2 의 거듭제곱을 제공한다는 점에 유의하십시오 예를 들어, 16 진수 문자열 <code class="docutils literal"><span class="pre">0x3.a7p10</span></code> 는 부동 소수점 숫자 <code class="docutils literal"><span class="pre">(3</span> <span class="pre">+</span> <span class="pre">10./16</span> <span class="pre">+</span> <span class="pre">7./16**2)</span> <span class="pre">*</span> <span class="pre">2.0**10</span></code> 또는 <code class="docutils literal"><span class="pre">3740.0</span></code> 를 나타냅니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;0x3.a7p10&#39;</span><span class="p">)</span>
<span class="go">3740.0</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">3740.0</span></code> 에 역 변환을 적용하면 같은 숫자를 나타내는 다른 16 진수 문자열을 얻을 수 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">hex</span><span class="p">(</span><span class="mf">3740.0</span><span class="p">)</span>
<span class="go">&#39;0x1.d380000000000p+11&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="hashing-of-numeric-types">
<span id="numeric-hash"></span><h3>4.4.4. 숫자 형의 해싱<a class="headerlink" href="#hashing-of-numeric-types" title="제목 주소">¶</a></h3>
<p>숫자 <code class="docutils literal"><span class="pre">x</span></code> 와 <code class="docutils literal"><span class="pre">y</span></code>, 서로 다른 형이어도 됩니다, 에 대하여, <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 면 항상 <code class="docutils literal"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code> 일 것이 요구됩니다 (자세한 내용은 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal"><span class="pre">__hash__()</span></code></a> 메서드 도큐멘테이션을 보세요). 다양한 숫자 형 (<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code></a>, <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal"><span class="pre">fractions.Fraction</span></code></a> 포함)을의 구현의 편의성과 효율 때문에, 파이썬의 숫자형의 해시는 단일한 수학 함수에 기반하고 있고, 이 함수는 임의의 유리수에 대해 정의되어서 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 와 <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal"><span class="pre">fractions.Fraction</span></code></a> 의 모든 인스턴스, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a> 와 <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal"><span class="pre">decimal.Decimal</span></code></a> 의 모든 유한 인스턴스에 적용됩니다. 본질적으로, 이 함수는 고정 소수 <code class="docutils literal"><span class="pre">P</span></code> 에 대해 모듈로 <code class="docutils literal"><span class="pre">P</span></code> 환원(reduction modulo <code class="docutils literal"><span class="pre">P</span></code>) 으로 주어집니다. <code class="docutils literal"><span class="pre">P</span></code> 의 값은 <a class="reference internal" href="sys.html#sys.hash_info" title="sys.hash_info"><code class="xref py py-data docutils literal"><span class="pre">sys.hash_info</span></code></a> 의 <code class="xref py py-attr docutils literal"><span class="pre">modulus</span></code> 어트리뷰트로 파이썬에 제공됩니다.</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> 현재, 사용되는 소수는 32-비트 C long 을 가진 기계에서는 <code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">2**31</span> <span class="pre">-</span> <span class="pre">1</span></code> 이고, 64-비트 C long 을 가진 기계에서는 <code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">2**61</span> <span class="pre">-</span> <span class="pre">1</span></code> 입니다.</p>
</div>
<p>다음은 규칙에 대한 세부 사항입니다:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> 이 음이 아닌 유리수이고 <code class="docutils literal"><span class="pre">n</span></code> 이 <code class="docutils literal"><span class="pre">P</span></code> 로 나눠지지 않는다면, <code class="docutils literal"><span class="pre">hash(x)</span></code> 를 <code class="docutils literal"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">invmod(n,</span> <span class="pre">P)</span> <span class="pre">%</span> <span class="pre">P</span></code> 로 정의합니다. 여기서 <code class="docutils literal"><span class="pre">invmod(n,</span> <span class="pre">P)</span></code> 는 <code class="docutils literal"><span class="pre">n</span></code> 의 모듈로 <code class="docutils literal"><span class="pre">P</span></code> 역수를 줍니다.</li>
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> 이 음이 아닌 유리수이고 <code class="docutils literal"><span class="pre">n</span></code> 이 <code class="docutils literal"><span class="pre">P</span></code> 나눠지면 (하지만 <code class="docutils literal"><span class="pre">m</span></code> 은 나눠지지 않으면) <code class="docutils literal"><span class="pre">n</span></code> 은 모듈로 <code class="docutils literal"><span class="pre">P</span></code> 역수를 가지지 않고 위의 규칙은 적용되지 않습니다; 이 경우 <code class="docutils literal"><span class="pre">hash(x)</span></code> 를 상수 값 <code class="docutils literal"><span class="pre">sys.hash_info.inf</span></code> 로 정의합니다.</li>
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> 이 음의 유리수이면 <code class="docutils literal"><span class="pre">hash(x)</span></code> 를 <code class="docutils literal"><span class="pre">-hash(-x)</span></code> 로 정의합니다. 얻어진 해시가 <code class="docutils literal"><span class="pre">-1</span></code> 이면 <code class="docutils literal"><span class="pre">-2</span></code> 로 바꿉니다.</li>
<li>특별한 값 <code class="docutils literal"><span class="pre">sys.hash_info.inf</span></code>, <code class="docutils literal"><span class="pre">-sys.hash_info.inf</span></code>, <code class="docutils literal"><span class="pre">sys.hash_info.nan</span></code> 은 각각 무한대, 음의 무한대, nan 으로 사용됩니다. (모든 해시 가능 nan 은 동일한 해시 값을 가집니다.)</li>
<li>복소수(<a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a>) <code class="docutils literal"><span class="pre">z</span></code> 의 경우, <code class="docutils literal"><span class="pre">hash(z.real)</span> <span class="pre">+</span> <span class="pre">sys.hash_info.imag</span> <span class="pre">*</span> <span class="pre">hash(z.imag)</span></code> 를 계산하여 실수부와 허수부의 해시 값을 결합하는데, <code class="docutils literal"><span class="pre">2**sys.hash_info.width</span></code> 의 모듈로로 환원해서 <code class="docutils literal"><span class="pre">range(-2**(sys.hash_info.width</span> <span class="pre">-</span> <span class="pre">1),</span> <span class="pre">2**(sys.hash_info.width</span> <span class="pre">-</span> <span class="pre">1))</span></code> 범위에 들어가도록 만듭니다. 다시한번, 결과가 <code class="docutils literal"><span class="pre">-1</span></code> 이라면 <code class="docutils literal"><span class="pre">-2</span></code> 로 바꿉니다.</li>
</ul>
<p>위의 규칙을 명확히 하기 위해, 여기에 유리수, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a> 의 해시를 계산하는, 내장 해시와 동등한, 파이썬 코드를 예시합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">hash_fraction</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a rational number m / n.</span>

<span class="sd">    Assumes m and n are integers, with n positive.</span>
<span class="sd">    Equivalent to hash(fractions.Fraction(m, n)).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">modulus</span>
    <span class="c1"># Remove common factors of P.  (Unnecessary if m and n already coprime.)</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">//</span> <span class="n">P</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="n">P</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Fermat&#39;s Little Theorem: pow(n, P-1, P) is 1, so</span>
        <span class="c1"># pow(n, P-2, P) gives the inverse of n modulo P.</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">%</span> <span class="n">P</span><span class="p">)</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">P</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="o">%</span> <span class="n">P</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="n">hash_value</span>
    <span class="k">if</span> <span class="n">hash_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">hash_value</span>

<span class="k">def</span> <span class="nf">hash_float</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a float x.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">elif</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hash_fraction</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">hash_complex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a complex number z.&quot;&quot;&quot;</span>

    <span class="n">hash_value</span> <span class="o">=</span> <span class="n">hash_float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">hash_float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
    <span class="c1"># do a signed reduction modulo 2**sys.hash_info.width</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">hash_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&amp;</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hash_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">hash_value</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="iterator-types">
<span id="typeiter"></span><h2>4.5. 이터레이터 형<a class="headerlink" href="#iterator-types" title="제목 주소">¶</a></h2>
<p id="index-17">파이썬은 컨테이너에 대한 이터레이션 개념을 지원합니다. 이것은 두 개의 메서드를 사용해서 구현됩니다; 이 것들은 사용자 정의 클래스가 이터레이션을 지원할 수 있도록하는 데 사용됩니다. 아래에서 더 자세히 설명할 시퀀스는 항상 이터레이션 메서드를 지원합니다.</p>
<p>컨테이너 객체가 이터레이션 지원을 제공하려면 한가지 메서드를 정의할 필요가 있습니다.:</p>
<dl class="method">
<dt id="container.__iter__">
<code class="descclassname">container.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#container.__iter__" title="정의 주소">¶</a></dt>
<dd><p>이터레이터 객체를 돌려줍니다. 이 객체는 아래에서 설명하는 이터레이터 프로토콜을 지원해야합니다. 컨테이너가 여러 유형의 이터레이션을 지원하는 경우, 이터레이션 유형에 대한 이터레이터를 구체적으로 요구하는 추가 메서드를 제공 할 수 있습니다. (여러 형태의 이터레이션을 지원하는 객체의 예로 너비 우선과 깊이 우선 탐색을 모두 지원하는 트리 구조를 들 수 있습니다.) 이 메서드는 파이썬/C API 에서 파이썬 객체를 위한 구조체의 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a> 슬롯에 대응합니다.</p>
</dd></dl>

<p>이터레이터 객체 자체는 다음과 같은 두 가지 메서드를 지원해야 하는데, 둘이 함께 <em class="dfn">이터레이터 프로토콜 (iterator protocol)</em> 를 이룹니다.:</p>
<dl class="method">
<dt id="iterator.__iter__">
<code class="descclassname">iterator.</code><code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iterator.__iter__" title="정의 주소">¶</a></dt>
<dd><p>이터레이터 객체 자신을 돌려줍니다. 이는 <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 와 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 문에 컨테이너와 이터레이터 모두 사용될 수 있게하기위해 필요합니다. 이 메서드는 파이썬/C API 에서 파이썬 객체를 위한 구조체의 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal"><span class="pre">tp_iter</span></code></a> 슬롯에 대응합니다.</p>
</dd></dl>

<dl class="method">
<dt id="iterator.__next__">
<code class="descclassname">iterator.</code><code class="descname">__next__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iterator.__next__" title="정의 주소">¶</a></dt>
<dd><p>컨테이너의 다음 항목을 돌려줍니다. 더 이상 항목이 없으면 <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 예외를 일으킵니다. 이 메서드는 파이썬/C API 에서 파이썬 객체를 위한 구조체의 <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal"><span class="pre">tp_iternext</span></code></a> 슬롯에 대응합니다.</p>
</dd></dl>

<p>파이썬은 일반적이거나 특정한 시퀀스 형, 딕셔너리, 기타 더 특화된 형태에 대한 이터레이션을 지원하기 위해 여러 이러레이터 객체를 정의합니다. 이터레이터 프로토콜의 구현을 넘어서 개별적인 형이 중요하지는 않습니다.</p>
<p>일단 이터레이터의 <a class="reference internal" href="#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> 메서드가 <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 를 일으키면, 그 이후의 호출에 대해서도 동일하게 동작해야 합니다. 이 속성을 따르지 않는 구현은 망가진 것으로 간주됩니다.</p>
<div class="section" id="generator-types">
<span id="id3"></span><h3>4.5.1. 제너레이터 형<a class="headerlink" href="#generator-types" title="제목 주소">¶</a></h3>
<p>파이썬의 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a> 는 이터레이터 프로토콜을 구현하는 편리한 방법을 제공합니다. 컨테이너 객체의 <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> 메서드가 제너레이터로 구현되면, <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> 와 <a class="reference internal" href="../reference/expressions.html#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> 메서드를 제공하는 이터레이터 객체(기술적으로, 제너레이터 객체)를 자동으로 돌려줍니다. 제너레이터에 대한 더 자세한 정보는 <a class="reference internal" href="../reference/expressions.html#yieldexpr"><span class="std std-ref">일드 표현식 도큐멘테이션</span></a> 에서 찾을 수 있습니다.</p>
</div>
</div>
<div class="section" id="sequence-types-list-tuple-range">
<span id="typesseq"></span><h2>4.6. 시퀀스 형 --- <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a><a class="headerlink" href="#sequence-types-list-tuple-range" title="제목 주소">¶</a></h2>
<p>세 가지 기본 시퀀스 형이 있습니다: 리스트, 튜플, 범위 객체. <a class="reference internal" href="#binaryseq"><span class="std std-ref">바이너리 데이터</span></a> 와 <a class="reference internal" href="#textseq"><span class="std std-ref">텍스트 문자열</span></a> 의 처리를 위해 추가 된 시퀀스 형들은 별도의 섹션에서 설명합니다.</p>
<div class="section" id="common-sequence-operations">
<span id="typesseq-common"></span><h3>4.6.1. 공통 시퀀스 연산<a class="headerlink" href="#common-sequence-operations" title="제목 주소">¶</a></h3>
<p id="index-18">다음 표의 연산들은 대부분의 가변과 불변 시퀀스에서 지원됩니다. 사용자 정의 시퀀스에서 이 연산들을 올바르게 구현하기 쉽도록 하기 위해 <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sequence</span></code></a> ABC 가 제공됩니다.</p>
<p>이 표는 우선 순위에 따라 오름차순으로 시퀀스 연산들을 나열합니다. 표에서,  <em>s</em> 와 <em>t</em> 는 같은 형의 시퀀스이고, <em>n</em>, <em>i</em>, <em>j</em>, <em>k</em> 는 정수이고, <em>x</em> 는 <em>s</em> 가 요구하는 형과 값 제한을 만족하는 임의의 객체입니다.</p>
<p><code class="docutils literal"><span class="pre">in</span></code> 과 <code class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></code> 연산은 비교 연산과 우선 순위가 같습니다. <code class="docutils literal"><span class="pre">+</span></code> (이어 붙이기) 와 <code class="docutils literal"><span class="pre">*</span></code> (반복) 연산은 대응하는 숫자 연산과 동일한 우선 순위를 갖습니다. <a class="footnote-reference" href="#id14" id="id4">[3]</a></p>
<table border="1" class="docutils" id="index-19">
<colgroup>
<col width="38%" />
<col width="47%" />
<col width="15%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산</th>
<th class="head">결과</th>
<th class="head">노트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code></td>
<td><em>s</em> 의 항목 중 하나가 <em>x</em> 와 같으면 <code class="docutils literal"><span class="pre">True</span></code>, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code></td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code></td>
<td><em>s</em> 의 항목 중 하나가 <em>x</em> 와 같으면 <code class="docutils literal"><span class="pre">False</span></code>, 그렇지 않으면 <code class="docutils literal"><span class="pre">True</span></code></td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s</span> <span class="pre">+</span> <span class="pre">t</span></code></td>
<td><em>s</em> 와 <em>t</em> 의 이어 붙이기</td>
<td>(6)(7)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n</span></code> 또는 <code class="docutils literal"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">s</span></code></td>
<td><em>s</em> 를 그 자신에 <em>n</em> 번 더하는 것과 같습니다</td>
<td>(2)(7)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s[i]</span></code></td>
<td><em>s</em> 의 <em>i</em> 번째 항목, 0 에서 시작합니다</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s[i:j]</span></code></td>
<td><em>s</em> 의 <em>i</em> 에서 <em>j</em> 까지의 슬라이스</td>
<td>(3)(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s[i:j:k]</span></code></td>
<td><em>s</em> 의 <em>i</em> 에서 <em>j</em> 까지 스텝 <em>k</em> 의 슬라이스</td>
<td>(3)(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">len(s)</span></code></td>
<td><em>s</em> 의 길이</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">min(s)</span></code></td>
<td><em>s</em> 의 가장 작은 항목</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">max(s)</span></code></td>
<td><em>s</em> 의 가장 큰 항목</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.index(x[,</span> <span class="pre">i[,</span> <span class="pre">j]])</span></code></td>
<td>(인덱스 <em>i</em> 또는 그 이후에, 인덱스 <em>j</em> 전에 등장하는) <em>s</em> 의 첫 번째 <em>x</em> 의 인덱스</td>
<td>(8)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.count(x)</span></code></td>
<td><em>s</em> 등장하는 <em>x</em> 의 총 수</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>같은 형의 시퀀스는 비교를 지원합니다. 특히, 튜플과 리스트는 대응하는 항목들을 사전적으로 비교합니다. 이 것은 같다고 비교되기 위해서는, 모든 항목들이 같다고 비교되고, 두 시퀀스의 형과 길이가 같아야함을 의미합니다. (자세한 내용은 언어 레퍼런스의 <a class="reference internal" href="../reference/expressions.html#comparisons"><span class="std std-ref">비교</span></a> 를 참조하십시오.)</p>
<p>노트:</p>
<ol class="arabic">
<li><p class="first"><code class="docutils literal"><span class="pre">in</span></code> 과 <code class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></code> 연산은 일반적인 경우에 단순한 포함 검사를 위해서만 사용되지만, 몇몇 특수한 시퀀스 (<a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 같은) 들은 서브 시퀀스 검사에 사용하기도 합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;gg&quot;</span> <span class="ow">in</span> <span class="s2">&quot;eggs&quot;</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p class="first"><em>n</em> 의 값이 <code class="docutils literal"><span class="pre">0</span></code> 보다 작으면 <code class="docutils literal"><span class="pre">0</span></code> 으로 처리됩니다 (<em>s</em> 와 같은 형의 빈 시퀀스가 됩니다). 시퀀스 <em>s</em> 의 항목들이 복사되지 않음에 주의해야합니다; 그들은 여러 번 참조됩니다. 이것은 종종 새 파이썬 프로그래머들을 괴롭힙니다; 이 코드를 살펴보세요:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[], [], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [3], [3]]</span>
</pre></div>
</div>
<p>무슨 일이 일어났는가 하면, <code class="docutils literal"><span class="pre">[[]]</span></code> 는 빈 리스트를 포함하는 길이 1 인 리스트인데, <code class="docutils literal"><span class="pre">[[]]</span> <span class="pre">*</span> <span class="pre">3</span></code> 의 세 항목들은 모두 같은 빈 리스트를 참조합니다. <code class="docutils literal"><span class="pre">lists</span></code> 의 어느 항목을 수정하더라도 이 하나의 리스트를 수정하게 됩니다. 서로 다른 리스트를을 포함하는 리스트는 이런식으로 만들 수 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [5], [7]]</span>
</pre></div>
</div>
<p>더 자세한 설명은 FAQ 항목 <a class="reference internal" href="../faq/programming.html#faq-multidimensional-list"><span class="std std-ref">How do I create a multidimensional list?</span></a> 에서 얻을 수 있습니다.</p>
</li>
<li><p class="first"><em>i</em> 또는 <em>j</em> 가 음수인 경우, 인덱스는 시퀀스 <em>s</em> 의 끝에 상대적입니다: <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">i</span></code> 이나 <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">j</span></code> 로 치환됩니다. 하지만 <code class="docutils literal"><span class="pre">-0</span></code> 은 여전히 <code class="docutils literal"><span class="pre">0</span></code> 입니다.</p>
</li>
<li><p class="first"><em>i</em> 에서 <em>j</em> 까지의 <em>s</em> 의 슬라이스는 <code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">j</span></code> 를 만족하는 인덱스 <em>k</em> 의 항목들로 구성된 시퀀스로 정의됩니다. <em>i</em> 또는 <em>j</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 크면 <code class="docutils literal"><span class="pre">len(s)</span></code> 을 사용합니다. <em>i</em> 가 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이라면 <code class="docutils literal"><span class="pre">0</span></code> 을 사용합니다. <em>j</em> 가 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이면 <code class="docutils literal"><span class="pre">len(s)</span></code> 을 사용합니다. <em>i</em> 가 <em>j</em> 보다 크거나 같으면 빈 슬라이스가 됩니다.</p>
</li>
<li><p class="first">스텝 <em>k</em> 가 있는 <em>i</em> 에서 <em>j</em> 까지의 슬라이스는 <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">(j-i)/k</span></code> 를 만족하는 인덱스 <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code> 의 항목들로 구성된 시퀀스로 정의됩니다. 다시 말하면, 인덱스는 <code class="docutils literal"><span class="pre">i</span></code>, <code class="docutils literal"><span class="pre">i+k</span></code>, <code class="docutils literal"><span class="pre">i+2*k</span></code>, <code class="docutils literal"><span class="pre">i+3*k</span></code> 등이며 <em>j</em> 에 도달할 때 멈춥니다 (하지만 절대 <em>j</em> 를 포함하지는 않습니다). <em>k</em> 가 양수면 <em>i</em> 와 <em>j</em> 는 더 큰 경우 <code class="docutils literal"><span class="pre">len(s)</span></code> 로 줄어듭니다. <em>k</em> 가 음수면, <em>i</em> 와 <em>j</em> 는 더 큰 경우 <code class="docutils literal"><span class="pre">len(s)</span> <span class="pre">-</span> <span class="pre">1</span></code> 로 줄어듭니다. <em>i</em> 또는 <em>j</em> 가 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이면, 그것들은 &quot;끝&quot; 값이됩니다 (끝은 <em>k</em> 의 부호에 따라 달라집니다). <em>k</em> 는 0 일 수 없음에 주의하세요. <em>k</em> 가 <code class="docutils literal"><span class="pre">None</span></code> 이면 <code class="docutils literal"><span class="pre">1</span></code> 로 취급됩니다.</p>
</li>
<li><p class="first">불변 시퀀스를 이어 붙이면 항상 새로운 객체가 생성됩니다. 이 것은 반복적으로 이어붙이기 해서 시퀀스를 만들 때 실행 시간이 시퀀스의 총 길이의 제곱에 비례한다는 뜻입니다. 선형 실행 시간 비용을 얻으려면 아래 대안 중 하나로 전환해야합니다:</p>
<ul class="simple">
<li><a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 객체를 이어붙이기 한다면, 리스트를 만들고 마지막에 <a class="reference internal" href="#str.join" title="str.join"><code class="xref py py-meth docutils literal"><span class="pre">str.join()</span></code></a> 을 사용하거나 <a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a> 인스턴스에 쓰고 완료 될 때 값을 꺼낼 수 있습니다</li>
<li><a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체를 연결하는 경우 비슷하게 <a class="reference internal" href="#bytes.join" title="bytes.join"><code class="xref py py-meth docutils literal"><span class="pre">bytes.join()</span></code></a> 또는 <a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></code></a> 를 사용하거나, <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 객체를 사용하여 제자리에서 이어붙이기를 할 수 있습니다. <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 객체는 가변이고 효율적인 과할당(overallocation) 메커니즘을 가지고 있습니다.</li>
<li><a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> 객체를 이어붙이기한다면, 대신 <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> 를 extend 하십시오.</li>
<li>다른 형의 경우 관련 클래스 문서를 조사하십시오.</li>
</ul>
</li>
<li><p class="first">일부 시퀀스 형 (예를 들어 <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a>)은 특정 패턴을 따르는 항목 시퀀스 만 지원하기 때문에 시퀀스 이어붙이기나 반복을 지원하지 않습니다.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">index</span></code> raises <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> when <em>x</em> is not found in <em>s</em>.
Not all implementations support passing the additional arguments <em>i</em> and <em>j</em>.
These arguments allow efficient searching of subsections of the sequence. Passing
the extra arguments is roughly equivalent to using <code class="docutils literal"><span class="pre">s[i:j].index(x)</span></code>, only
without copying any data and with the returned index being relative to
the start of the sequence rather than the start of the slice.</p>
</li>
</ol>
</div>
<div class="section" id="immutable-sequence-types">
<span id="typesseq-immutable"></span><h3>4.6.2. 불변 시퀀스 형<a class="headerlink" href="#immutable-sequence-types" title="제목 주소">¶</a></h3>
<p id="index-20">불변 시퀀스 형이 일반적으로 구현하지만 가변 시퀀스 형에서는 구현되지 않는 연산은 내장 <a class="reference internal" href="functions.html#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a> 에 대한 지원입니다.</p>
<p>이 지원은 <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> 인스턴스와 같은 불변 시퀀스를 <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> 키로 사용하고 <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> 및 <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> 인스턴스에 저장할 수 있도록 합니다.</p>
<p>해시불가능 값을 포함하는 불변 시퀀스를 해시하려고 하면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 를 일으킵니다.</p>
</div>
<div class="section" id="mutable-sequence-types">
<span id="typesseq-mutable"></span><h3>4.6.3. 가변 시퀀스 형<a class="headerlink" href="#mutable-sequence-types" title="제목 주소">¶</a></h3>
<p id="index-21">다음 표의 연산들은 가변 시퀀스 형에 정의되어 있습니다. 사용자 정의 시퀀스에서 이 연산들을 올바르게 구현하기 쉽도록 하기 위해 <a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.MutableSequence</span></code></a> ABC 가 제공됩니다.</p>
<p>표에서 <em>s</em> 는 가변 시퀀스 형의 인스턴스이고, <em>t</em> 는 임의의 이터러블 객체이며, <em>x</em> 는 <em>s</em> 가 요구하는 형 및 값 제한을 충족시키는 임의의 객체입니다 (예를 들어, <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 는 값 제한 <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">255</span></code> 를 만족하는 정수 만 받아들입니다.</p>
<table border="1" class="docutils" id="index-22">
<colgroup>
<col width="36%" />
<col width="39%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">연산</th>
<th class="head">결과</th>
<th class="head">노트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s[i]</span> <span class="pre">=</span> <span class="pre">x</span></code></td>
<td><em>s</em> 의 항목 <em>i</em> 를 <em>x</em> 로 대체합니다</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">t</span></code></td>
<td><em>i</em> 에서 <em>j</em> 까지의 <em>s</em> 슬라이스가 이터러블 <em>t</em> 의 내용으로 대체됩니다</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">del</span> <span class="pre">s[i:j]</span></code></td>
<td><code class="docutils literal"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">[]</span></code> 와 같습니다</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s[i:j:k]</span> <span class="pre">=</span> <span class="pre">t</span></code></td>
<td><code class="docutils literal"><span class="pre">s[i:j:k]</span></code> 의 항목들이 <em>t</em> 의 항목들로 대체됩니다</td>
<td>(1)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">del</span> <span class="pre">s[i:j:k]</span></code></td>
<td>removes the elements of
<code class="docutils literal"><span class="pre">s[i:j:k]</span></code> from the list</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.append(x)</span></code></td>
<td>시퀀스의 끝에 <em>x</em> 를 추가합니다 (<code class="docutils literal"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">[x]</span></code> 와 같습니다)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.clear()</span></code></td>
<td><code class="docutils literal"><span class="pre">s</span></code> 에서 모든 항목을 제거합니다 (<code class="docutils literal"><span class="pre">del</span> <span class="pre">s[:]</span></code> 와 같습니다)</td>
<td>(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.copy()</span></code></td>
<td><code class="docutils literal"><span class="pre">s</span></code> 의 얕은 복사본을 만듭니다 (<code class="docutils literal"><span class="pre">s[:]</span></code> 와 같습니다)</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.extend(t)</span></code> 또는 <code class="docutils literal"><span class="pre">s</span> <span class="pre">+=</span> <span class="pre">t</span></code></td>
<td><em>t</em> 의 내용으로 <em>s</em> 를 확장합니다 (대부분 <code class="docutils literal"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">t</span></code> 와 동일합니다)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s</span> <span class="pre">*=</span> <span class="pre">n</span></code></td>
<td>내용이 <em>n</em> 번 반복되도록 <em>s</em> 를 갱신합니다</td>
<td>(6)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.insert(i,</span> <span class="pre">x)</span></code></td>
<td><em>x</em> 를 <em>s</em> 의 <em>i</em> 로 주어진 인덱스에 삽입합니다 (<code class="docutils literal"><span class="pre">s[i:i]</span> <span class="pre">=</span> <span class="pre">[x]</span></code> 와 동일합니다)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.pop([i])</span></code></td>
<td><em>i</em> 에 있는 항목을 꺼냄과 동시에  <em>s</em> 에서 제거합니다</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">s.remove(x)</span></code></td>
<td><code class="docutils literal"><span class="pre">s[i]</span> <span class="pre">==</span> <span class="pre">x</span></code> 가 되는 첫번째 항목을 <em>s</em> 에서 제거합니다</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">s.reverse()</span></code></td>
<td>제자리에서 <em>s</em> 의 항목들의 순서를 뒤집습니다</td>
<td>(4)</td>
</tr>
</tbody>
</table>
<p>노트:</p>
<ol class="arabic">
<li><p class="first"><em>t</em> 는 교체 할 슬라이스와 길이가 같아야합니다.</p>
</li>
<li><p class="first">선택적 인자 <em>i</em> 의 기본값은 <code class="docutils literal"><span class="pre">-1</span></code> 입니다. 그래서 기본적으로 마지막 항목이 제거되면서 반환됩니다.</p>
</li>
<li><p class="first"><em>x</em> 가 <em>s</em> 에서 발견되지 않으면 <code class="docutils literal"><span class="pre">remove</span></code> 는 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
</li>
<li><p class="first">큰 시퀀스를 뒤집을 때 공간 절약을 위해 <code class="xref py py-meth docutils literal"><span class="pre">reverse()</span></code> 메서드는 제자리에서 시퀀스를 수정합니다. 부작용으로 작동한다는 것을 사용자에게 상기시키기 위해 뒤집힌 시퀀스를 돌려주지 않습니다.</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code> 와 <code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code> 는 슬라이싱 연산을 지원하지 않는 (<a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> 와 <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> 같은) 가변 컨테이너들의 인터페이스와 일관성을 유지하기 위해 포함됩니다</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><code class="xref py py-meth docutils literal"><span class="pre">clear()</span></code> 와 <code class="xref py py-meth docutils literal"><span class="pre">copy()</span></code> 메서드.</p>
</div>
</li>
<li><p class="first"><em>n</em> 값은 정수이거나, <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal"><span class="pre">__index__()</span></code></a> 를 구현하는 객체입니다. <em>n</em> 이 0 이거나 음수면 시퀀스를 지웁니다. 시퀀스의 항목들은 복사되지 않습니다; <a class="reference internal" href="#typesseq-common"><span class="std std-ref">공통 시퀀스 연산</span></a> 에서 <code class="docutils literal"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n</span></code> 를 위해 설명한 것처럼 여러 번 참조됩니다.</p>
</li>
</ol>
</div>
<div class="section" id="lists">
<span id="typesseq-list"></span><h3>4.6.4. 리스트<a class="headerlink" href="#lists" title="제목 주소">¶</a></h3>
<p id="index-23">리스트는 가변 시퀀스로, 일반적으로 등질 항목들의 모음을 저장하는 데 사용됩니다 (정확한 유사도는 응용 프로그램마다 다를 수 있습니다).</p>
<dl class="class">
<dt id="list">
<em class="property">class </em><code class="descname">list</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#list" title="정의 주소">¶</a></dt>
<dd><p>리스트는 여러 가지 방법으로 만들 수 있습니다:</p>
<ul class="simple">
<li>꺾쇠괄호를 사용하여 빈리스트를 표시하기: <code class="docutils literal"><span class="pre">[]</span></code></li>
<li>꺾쇠괄호를 사용하여 쉼표로 항목 구분하기: <code class="docutils literal"><span class="pre">[a]</span></code>, <code class="docutils literal"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c]</span></code></li>
<li>리스트 컴프리헨션 사용하기: <code class="docutils literal"><span class="pre">[x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">iterable]</span></code></li>
<li>형 생성자를 사용하기: <code class="docutils literal"><span class="pre">list()</span></code> 또는 <code class="docutils literal"><span class="pre">list(iterable)</span></code></li>
</ul>
<p>생성자는 항목들과 그 순서가 <em>iterable</em> 과 동일한 리스트를 만듭니다. <em>iterable</em> 은 시퀀스, 이터레이션을 지원하는 컨테이너, 이터레이터 객체가 될 수 있습니다. <em>iterable</em> 이 이미 리스트라면, <code class="docutils literal"><span class="pre">iterable[:]</span></code> 과 비슷하게 복사본을 만들어서 반환합니다. 예를 들어, <code class="docutils literal"><span class="pre">list('abc')</span></code> 는 <code class="docutils literal"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code> 를 반환하고 <code class="docutils literal"><span class="pre">list(</span> <span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span> <span class="pre">)</span></code> 는 <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> 를 반환합니다. 인자가 주어지지 않으면, 생성자는 새로운 빈리스트 인 <code class="docutils literal"><span class="pre">[]</span></code> 을 만듭니다.</p>
<p>다른 많은 연산들도 리스트를 만드는데, 내장 <a class="reference internal" href="functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a> 도 그런 것들 중 하나다.</p>
<p>리스트는 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">공통</span></a> 과 <a class="reference internal" href="#typesseq-mutable"><span class="std std-ref">가변</span></a> 시퀀스 연산들을 모두 구현합니다. 또한 리스트는 다음과 같은 추가 메서드를 제공합니다:</p>
<dl class="method">
<dt id="list.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>*</em>, <em>key=None</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#list.sort" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 항목 간의 <code class="docutils literal"><span class="pre">&lt;</span></code> 비교 만 사용하여 리스트를 제자리에서 정렬합니다. 예외는 억제되지 않습니다 - 비교 연산이 실패하면 전체 정렬 연산이 실패합니다 (리스트는 부분적으로 수정된 상태로 남아있게됩니다).</p>
<p><a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code></a> 는 키워드로만 전달할 수있는 두 개의 인자를 받아들입니다 (<a class="reference internal" href="../glossary.html#keyword-only-parameter"><span class="std std-ref">키워드-전용 인자</span></a>):</p>
<p><em>key</em> 는 인자 하나를 받아들이는 함수를 지정하는데, 각 리스트 요소에서 비교 키를 추출하는 데 사용됩니다 (예들 들어, <code class="docutils literal"><span class="pre">key=str.lower</span></code>). 리스트의 각 항목에 해당하는 키는 한 번만 계산 된 후 전체 정렬 프로세스에 사용됩니다. 기본값 <code class="docutils literal"><span class="pre">None</span></code> 은 리스트 항목들이 별도의 키 값을 계산하지 않고 직접 정렬된다는 것을 의미합니다.</p>
<p><a class="reference internal" href="functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal"><span class="pre">functools.cmp_to_key()</span></code></a> 유틸리티는 2.x 스타일 <em>cmp</em> 함수를 <em>key</em> 함수로 변환하는 데 사용할 수 있습니다.</p>
<p><em>reverse</em> 는 논리값입니다. <code class="docutils literal"><span class="pre">True</span></code> 로 설정되면, 각 비교가 역전 된 것 처럼 리스트 요들이 정렬됩니다.</p>
<p>이 메서드는 큰 시퀀스를 정렬 할 때 공간 절약을 위해 시퀀스를 제자리에서 수정합니다. 부작용으로 작동한다는 것을 사용자에게 상기시키기 위해 정렬된 시퀀스를 돌려주지 않습니다 (새 정렬 된 리스트 인스턴스를 명시적으로 요청하려면 <a class="reference internal" href="functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a> 를 사용하십시오).</p>
<p><a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">sort()</span></code></a> 메서드는 안정적임이 보장됩니다. 정렬은 같다고 비교되는 요소들의 상대적 순서를 변경하지 않을 경우 안정적입니다 --- 이는 여러번 정렬하는 데 유용합니다 (예를 들어, 부서별로 정렬한 후에 급여 등급으로 정렬).</p>
<div class="impl-detail compound">
<p><strong>CPython 구현 상세:</strong> 리스트가 정렬되는 동안, 리스트를 변경하려고 할 때의, 또는 관찰하려고 할 때 조차, 효과는 정의되지 않습니다. 파이썬의 C 구현은 그 기간동안 리스트를 비어있는 것으로 보이게하고, 정렬 중에 리스트가 변경되었음을 감지 할 수 있다면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tuples">
<span id="typesseq-tuple"></span><h3>4.6.5. 튜플<a class="headerlink" href="#tuples" title="제목 주소">¶</a></h3>
<p id="index-24">튜플은 불변 시퀀스인데, 보통 이질적인 데이터의 모음을 저장하는데 사용됩니다 (예를 들어, 내장 <a class="reference internal" href="functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal"><span class="pre">enumerate()</span></code></a> 가 만드는 2-튜플). 튜플은 등질적인 데이터의 불변 시퀀스가 필요한 경우에도 사용됩니다 (예를 들어, <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> 이나 <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> 인스턴스에 저장하고자 하는 경우).</p>
<dl class="class">
<dt id="tuple">
<em class="property">class </em><code class="descname">tuple</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#tuple" title="정의 주소">¶</a></dt>
<dd><p>튜플은 여러 가지 방법으로 만들 수 있습니다:</p>
<ul class="simple">
<li>괄호를 사용하여 빈 튜플을 나타 내기: <code class="docutils literal"><span class="pre">()</span></code></li>
<li>단일 항목 튜플을 위해 끝에 쉼표를 붙이기: <code class="docutils literal"><span class="pre">a,</span></code> 또는 <code class="docutils literal"><span class="pre">(a,)</span></code></li>
<li>항목을 쉼표로 구분하기: <code class="docutils literal"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c</span></code> 또는``(a, b, c)``</li>
<li>내장 <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-func docutils literal"><span class="pre">tuple()</span></code></a> 사용하기:  <code class="docutils literal"><span class="pre">tuple()</span></code> 또는 <code class="docutils literal"><span class="pre">tuple(iterable)</span></code></li>
</ul>
<p>생성자는 항목들과 그 순서가 <em>iterable</em> 과 동일한 튜플을 만듭니다. <em>iterable</em> 은 시퀀스, 이터레이션을 지원하는 컨테이너, 이터레이터 객체가 될 수 있습니다. <em>iterable</em> 이 이미 튜플이라면 변경되지 않은 상태로 반환됩니다. 예를 들어 <code class="docutils literal"><span class="pre">tuple('abc')</span></code> 는 <code class="docutils literal"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'c')</span></code> 를 반환하고, <code class="docutils literal"><span class="pre">tuple(</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span> <span class="pre">)</span></code> 는 <code class="docutils literal"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code> 을 반환합니다. 인자가 주어지지 않으면, 생성자는 새로운 빈튜플 인 <code class="docutils literal"><span class="pre">()</span></code> 을 만듭니다.</p>
<p>튜플을 만드는 것은 실제로는 괄호가 아닌 쉼표임에 유의하십시오. 괄호는 빈 튜플의 경우를 제외하고는 선택적이거나 문법상의 모호함을 피하기 위해 필요합니다. 예를 들어, <code class="docutils literal"><span class="pre">f(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> 는 3 개의 인자를 가진 함수 호출인 반면, <code class="docutils literal"><span class="pre">f((a,</span> <span class="pre">b,</span> <span class="pre">c))</span></code> 는 하나의 인자로 3-튜플을 갖는 함수 호출입니다.</p>
<p>튜플은 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">공통</span></a> 시퀀스 연산을 모두 구현합니다.</p>
</dd></dl>

<p>이름에 의한 액세스가 인덱스에 의한 액세스보다 더 명확한 이질적 데이터 컬렉션의 경우, <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal"><span class="pre">collections.namedtuple()</span></code></a> 이 단순한 튜플 객체보다 더 적절한 선택 일 수 있습니다.</p>
</div>
<div class="section" id="ranges">
<span id="typesseq-range"></span><h3>4.6.6. 범위<a class="headerlink" href="#ranges" title="제목 주소">¶</a></h3>
<p id="index-25"><a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a> 형은 숫자의 불변 시퀀스를 나타내며 <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 루프에서 특정 횟수만큼 반복하는데 흔히 사용됩니다.</p>
<dl class="class">
<dt id="range">
<em class="property">class </em><code class="descname">range</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span><a class="headerlink" href="#range" title="정의 주소">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">range</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>범위 생성자에 대한 인자는 정수여야합니다 (내장 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 또는 <code class="docutils literal"><span class="pre">__index__</span></code> 특수 메서드를 구현하는 임의의 객체). <em>step</em> 인자가 생략되면 기본값 <code class="docutils literal"><span class="pre">1</span></code> 이 사용됩니다. <em>start</em> 인자가 생략되면 기본값 <code class="docutils literal"><span class="pre">0</span></code> 이 사용됩니다. <em>step</em> 이 0이면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
<p>양수 <em>step</em> 의 경우, 범위 <code class="docutils literal"><span class="pre">r</span></code> 의 내용은 식 <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">step*i</span></code> 에 의해 결정됩니다. 이 때 <code class="docutils literal"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> 이고 <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">&lt;</span> <span class="pre">stop</span></code> 입니다.</p>
<p>음수 <em>step</em> 의 경우, 범위의 내용은 여전히 식 <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">step*i</span></code> 에 의해 결정되지만, 제약 조건은 <code class="docutils literal"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> 과 <code class="docutils literal"><span class="pre">r[i]</span> <span class="pre">&gt;</span> <span class="pre">stop</span></code> 이 됩니다.</p>
<p><code class="docutils literal"><span class="pre">r[0]</span></code> 제약 조건을 만족시키지 않으면 범위 객체는 비게됩니다. 범위는 음의 인덱스를 지원하지만, 이는 시퀀스의 끝에서부터 양의 인덱스만큼 떨어진 인덱스로 해석됩니다.</p>
<p><a class="reference internal" href="sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal"><span class="pre">sys.maxsize</span></code></a> 보다 큰 절대 값을 포함하는 범위는 허용되지만, (<a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal"><span class="pre">len()</span></code></a> 과 같은) 일부 기능은 <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> 를 발생시킬 수 있습니다.</p>
<p>범위 예제:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">[0, 5, 10, 15, 20, 25]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[0, 3, 6, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>범위는 이어 붙이기와 반복을 제외한 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">공통</span></a> 시퀀스 연산을 모두 구현합니다 (범위 객체는 엄격한 패턴을 따르는 시퀀스 만 나타낼 수 있는데 반복과 이어 붙이기는 보통 그 패턴을 위반한다는 사실에 기인합니다).</p>
<dl class="attribute">
<dt id="range.start">
<code class="descname">start</code><a class="headerlink" href="#range.start" title="정의 주소">¶</a></dt>
<dd><p><em>start</em> 파라미터의 값 (또는 파라미터가 제공되지 않으면 <code class="docutils literal"><span class="pre">0</span></code>)</p>
</dd></dl>

<dl class="attribute">
<dt id="range.stop">
<code class="descname">stop</code><a class="headerlink" href="#range.stop" title="정의 주소">¶</a></dt>
<dd><p><em>stop</em> 파라미터의 값</p>
</dd></dl>

<dl class="attribute">
<dt id="range.step">
<code class="descname">step</code><a class="headerlink" href="#range.step" title="정의 주소">¶</a></dt>
<dd><p><em>step</em> 파라미터의 값 (또는 파라미터가 제공되지 않으면 <code class="docutils literal"><span class="pre">1</span></code>)</p>
</dd></dl>

</dd></dl>

<p>정규 <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> 나 <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> 에 비해 <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a> 형의 장점은 <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal"><span class="pre">range</span></code></a> 객체는 표현하는 범위의 크기에 무관하게 항상 같은 (작은) 양의 메모리를 사용한다는 것입니다 (<code class="docutils literal"><span class="pre">start</span></code>, <code class="docutils literal"><span class="pre">stop</span></code>, <code class="docutils literal"><span class="pre">step</span></code> 값만을 저장하고, 필요에 따라 개별 항목과 하위 범위를 계산하기 때문입니다).</p>
<p>범위 객체는 <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sequence</span></code></a> ABC를 구현하고, 포함 검사, 요소 인덱스 검색, 슬라이싱, 음수 인덱스 지원과 같은 기능을 제공합니다 (<a class="reference internal" href="#typesseq"><span class="std std-ref">시퀀스 형 --- list, tuple, range</span></a> 를 보세요):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span>
<span class="go">range(0, 20, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">11</span> <span class="ow">in</span> <span class="n">r</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">10</span> <span class="ow">in</span> <span class="n">r</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">range(0, 10, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">18</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">==</span></code> 나 <code class="docutils literal"><span class="pre">!=</span></code> 로 범위 객체가 같은지 검사하면 시퀀스 처럼 비교합니다. 즉, 두 범위 객체가 동일한 시퀀스의 값을 나나낼 때 같다고 취급됩니다. (같다고 비교되는 두 개의 범위 객체가 서로 다른 <a class="reference internal" href="#range.start" title="range.start"><code class="xref py py-attr docutils literal"><span class="pre">start</span></code></a>, <a class="reference internal" href="#range.stop" title="range.stop"><code class="xref py py-attr docutils literal"><span class="pre">stop</span></code></a>, <a class="reference internal" href="#range.step" title="range.step"><code class="xref py py-attr docutils literal"><span class="pre">step</span></code></a> 어트리뷰트를 가질 수 있음에 주의하세요. 예를 들어, <code class="docutils literal"><span class="pre">range(0)</span> <span class="pre">==</span> <span class="pre">range(2,</span> <span class="pre">1,</span> <span class="pre">3)</span></code> 또는 <code class="docutils literal"><span class="pre">range(0,</span> <span class="pre">3,</span> <span class="pre">2)</span> <span class="pre">==</span> <span class="pre">range(0,</span> <span class="pre">4,</span> <span class="pre">2)</span></code>.)</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span>시퀀스 ABC를 구현합니다. <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> 객체의 포함 검사는 모든 항목들을 이터레이트하는 대신 상수 시간으로 수행됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>(객체 아이덴티티에 기반하는 대신) 범위 객체가 정의하는 값들의 시퀀스에 기반한 비교를 위해 '==' 와 '!=' 를 정의합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가: </span><a class="reference internal" href="#range.start" title="range.start"><code class="xref py py-attr docutils literal"><span class="pre">start</span></code></a>, <a class="reference internal" href="#range.stop" title="range.stop"><code class="xref py py-attr docutils literal"><span class="pre">stop</span></code></a>, <a class="reference internal" href="#range.step" title="range.step"><code class="xref py py-attr docutils literal"><span class="pre">step</span></code></a> 어트리뷰트.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<ul class="last simple">
<li><a class="reference external" href="http://code.activestate.com/recipes/579000/">linspace recipe</a> 에서는 부동 소수점 응용 프로그램에 적합한 범위의 지연된 버전을 구현하는 방법을 보여줍니다.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="text-sequence-type-str">
<span id="textseq"></span><span id="index-26"></span><h2>4.7. 텍스트 시퀀스 형 --- <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a><a class="headerlink" href="#text-sequence-type-str" title="제목 주소">¶</a></h2>
<p>파이썬의 텍스트 데이터는 <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, 또는 <em class="dfn">문자열 (strings)</em>, 객체를 사용하여 처리됩니다. 문자열은 유니코드 코드 포인트의 불변 <a class="reference internal" href="#typesseq"><span class="std std-ref">시퀀스</span></a> 입니다. 문자열 리터럴은 다양한 방법으로 작성됩니다:</p>
<ul class="simple">
<li>작은 따옴표: <code class="docutils literal"><span class="pre">'&quot;큰&quot;</span> <span class="pre">따옴표를</span> <span class="pre">담을</span> <span class="pre">수</span> <span class="pre">있습니다'</span></code></li>
<li>큰 따옴표: <code class="docutils literal"><span class="pre">&quot;'작은'</span> <span class="pre">따옴표를</span> <span class="pre">담을</span> <span class="pre">수</span> <span class="pre">있습니다&quot;</span></code>.</li>
<li>삼중 따옴표: <code class="docutils literal"><span class="pre">'''세</span> <span class="pre">개의</span> <span class="pre">작은</span> <span class="pre">따옴표'''</span></code>, <code class="docutils literal"><span class="pre">&quot;&quot;&quot;세</span> <span class="pre">개의</span> <span class="pre">큰</span> <span class="pre">따옴표&quot;&quot;&quot;</span></code></li>
</ul>
<p>삼중 따옴표로 묶인 문자열은 여러 줄에 걸쳐있을 수 있습니다 - 연관된 모든 공백이 문자열 리터럴에 포함됩니다.</p>
<p>단일 표현식의 일부이고 그 들 사이에 공백 만 있는 문자열 리터럴들은 묵시적으로 단일 문자열 리터럴로 변환됩니다. 즉, <code class="docutils literal"><span class="pre">(&quot;spam</span> <span class="pre">&quot;</span> <span class="pre">&quot;eggs&quot;)</span> <span class="pre">==</span> <span class="pre">&quot;spam</span> <span class="pre">eggs&quot;</span></code>.</p>
<p>지원되는 이스케이프 시퀀스와 대부분의 이스케이프 시퀀스 처리를 비활성화하는 <code class="docutils literal"><span class="pre">r</span></code> (&quot;날&quot;) 접두어를 포함하여 문자열 리터럴의 다양한 형식에 대한 자세한 내용은 <a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">문자열과 바이트열 리터럴</span></a> 을 참조하십시오.</p>
<p>문자열은 <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 생성자를 사용하여 다른 객체로부터 만들어질 수도 있습니다.</p>
<p>별도의 &quot;문자&quot; 형이 없으므로 문자열을 인덱싱하면 길이가 1 인 문자열이 생성됩니다. 즉, 비어 있지 않은 문자열 <em>s</em> 의 경우, <code class="docutils literal"><span class="pre">s[0]</span> <span class="pre">==</span> <span class="pre">s[0:1]</span></code> 입니다.</p>
<p id="index-27">또한 가변 문자열 형은 없지만, 여러 단편들로 부터 문자열을 효율적으로 구성하는데 <a class="reference internal" href="#str.join" title="str.join"><code class="xref py py-meth docutils literal"><span class="pre">str.join()</span></code></a> 또는 <a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal"><span class="pre">io.StringIO</span></code></a> 를 사용할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>파이썬 2 시리즈와의 하위 호환성을 위해서, <code class="docutils literal"><span class="pre">u</span></code> 접두어가 문자열 리터럴에 다시 한번 허용됩니다. 문자열 리터럴의 의미에 영향을 미치지 않으며 <code class="docutils literal"><span class="pre">r</span></code> 접두사와 결합 될 수 없습니다.</p>
</div>
<span class="target" id="index-28"></span><dl class="class">
<dt id="str">
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=''</em><span class="sig-paren">)</span><a class="headerlink" href="#str" title="정의 주소">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=b''</em>, <em>encoding='utf-8'</em>, <em>errors='strict'</em><span class="sig-paren">)</span></dt>
<dd><p><em>object</em> 의 <a class="reference internal" href="#textseq"><span class="std std-ref">문자열</span></a> 버전을 돌려줍니다. <em>object</em> 가 제공되지 않으면, 빈 문자열을 돌려줍니다. 그렇지 않으면, <code class="docutils literal"><span class="pre">str()</span></code> 의 동작은 <em>encoding</em> 또는 <em>errors</em> 가 주어 졌는지에 따라 달라지는데, 다음과 같습니다.</p>
<p><em>encoding</em> 과 <em>errors</em> 모두 주어지지 않으면, <code class="docutils literal"><span class="pre">str(object)</span></code> 는 <a class="reference internal" href="../reference/datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal"><span class="pre">object.__str__()</span></code></a> 를 돌려주는데, <em>object</em> 의 &quot;비형식적&quot; 또는 멋지게 인쇄가능한 문자열 표현입니다. 문자열 객체의 경우, 이 것은 문자열 자신입니다. 만약 <em>object</em> 가 <a class="reference internal" href="../reference/datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal"><span class="pre">__str__()</span></code></a> 메서드를 가지고 있지 않다면, <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> 은 대신 <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-meth docutils literal"><span class="pre">repr(object)</span></code></a> 를 돌려줍니다.</p>
<p id="index-29"><em>encoding</em> 또는 <em>errors</em> 중 적어도 하나가 주어지면, <em>object</em> 는 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> (예, <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 또는 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>) 이어야합니다. 이 경우, <em>object</em> 가 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> (또는 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>) 객체이면, <code class="docutils literal"><span class="pre">str(bytes,</span> <span class="pre">encoding,</span> <span class="pre">errors)</span></code> 는 <a class="reference internal" href="#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode(encoding,</span> <span class="pre">errors)</span></code></a> 와 동등합니다. 그 이외의 경우, <a class="reference internal" href="#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode()</span></code></a> 호출 전에 버퍼 객체의 하부 바이트열 객체를 얻습니다. 버퍼 객체에 대한 정보는 <a class="reference internal" href="#binaryseq"><span class="std std-ref">바이너리 시퀀스 형 --- bytes, bytearray, memoryview</span></a> 와 <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">Buffer Protocol</span></a> 를 보십시오.</p>
<p><em>encoding</em> 또는 <em>errors</em> 인자 없이 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체를 <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> 에 전달하는 것은 비형식적 문자열 표현을 반환하는 첫 번째 경우에 해당합니다 (파이썬 명령행 옵션 <a class="reference internal" href="../using/cmdline.html#cmdoption-b"><code class="xref std std-option docutils literal"><span class="pre">-b</span></code></a> 도 보십시오). 예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Zoot!&#39;</span><span class="p">)</span>
<span class="go">&quot;b&#39;Zoot!&#39;&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">str</span></code> 클래스와 그 메서드에 대한 더 자세한 정보는 <a class="reference internal" href="#textseq"><span class="std std-ref">텍스트 시퀀스 형 --- str</span></a> 와 아래의 <a class="reference internal" href="#string-methods"><span class="std std-ref">문자열 메서드</span></a> 섹션을 보십시오. 포맷된 문자열을 출력하려면 <a class="reference internal" href="../reference/lexical_analysis.html#f-strings"><span class="std std-ref">포맷 문자열 리터럴</span></a> 및 <a class="reference internal" href="string.html#formatstrings"><span class="std std-ref">Format String Syntax</span></a> 섹션을 참조하십시오. 또한, <a class="reference internal" href="text.html#stringservices"><span class="std std-ref">Text Processing Services</span></a> 섹션을 보십시오.</p>
</dd></dl>

<div class="section" id="string-methods">
<span id="index-30"></span><span id="id5"></span><h3>4.7.1. 문자열 메서드<a class="headerlink" href="#string-methods" title="제목 주소">¶</a></h3>
<p id="index-31">문자열은 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">공통</span></a> 시퀀스 연산들을 모두 구현하고, 아래에 기술된 추가적인 메서드들도 구현합니다.</p>
<p>문자열은 또한 두 가지 스타일의 문자열 포맷팅을 지원합니다. 하나는 큰 폭의 유연성과 사용자 지정을 제공하고 (참조 <a class="reference internal" href="#str.format" title="str.format"><code class="xref py py-meth docutils literal"><span class="pre">str.format()</span></code></a>, <a class="reference internal" href="string.html#formatstrings"><span class="std std-ref">Format String Syntax</span></a>, <a class="reference internal" href="string.html#string-formatting"><span class="std std-ref">Custom String Formatting</span></a> 를 참조하세요) 다른 하나는 C <code class="docutils literal"><span class="pre">printf</span></code> 스타일에 기반하는데 더 좁은 범위의 형을 타입을 처리하고 올바르게 사용하기는 다소 어렵지만 처리 할 수있는 경우에는 종종 더 빠릅니다 (<a class="reference internal" href="#old-string-formatting"><span class="std std-ref">printf 스타일 문자열 포맷팅</span></a>).</p>
<p>표준 라이브러리의 <a class="reference internal" href="text.html#textservices"><span class="std std-ref">Text Processing Services</span></a> 섹션은 다양한 텍스트 관련 유틸리티를 (<a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> 모듈의 정규식 지원을 포함합니다) 제공하는 많은 다른 모듈들을 다룹니다.</p>
<dl class="method">
<dt id="str.capitalize">
<code class="descclassname">str.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.capitalize" title="정의 주소">¶</a></dt>
<dd><p>첫 문자가 대문자이고 나머지가 소문자 인 문자열의 복사본을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.casefold">
<code class="descclassname">str.</code><code class="descname">casefold</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.casefold" title="정의 주소">¶</a></dt>
<dd><p>케이스폴딩된 문자열을 반환합니다. 케이스폴딩된 문자열은 대소문자를 무시한 매칭에 사용될 수 있습니다.</p>
<p>케이스폴딩은 소문자로 변환하는 것과 비슷하지만 문자열의 모든 케이스 구분을 제거하기 때문에 보다 공격적입니다. 예를 들어, 독일어 소문자 <code class="docutils literal"><span class="pre">'ß'</span></code> 는 <code class="docutils literal"><span class="pre">&quot;ss&quot;</span></code> 와 동등합니다. 이미 소문자이므로 <a class="reference internal" href="#str.lower" title="str.lower"><code class="xref py py-meth docutils literal"><span class="pre">lower()</span></code></a> 는 <code class="docutils literal"><span class="pre">'ß'</span></code> 에 아무런 영향을 미치지 않습니다; <a class="reference internal" href="#str.casefold" title="str.casefold"><code class="xref py py-meth docutils literal"><span class="pre">casefold()</span></code></a> 는 <code class="docutils literal"><span class="pre">&quot;ss&quot;</span></code> 로 변환합니다.</p>
<p>케이스폴딩 알고리즘은 유니 코드 표준의 섹션 3.13 에 설명되어 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.center">
<code class="descclassname">str.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.center" title="정의 주소">¶</a></dt>
<dd><p>길이 <em>width</em> 인 문자열의 가운데에 정렬한 값을 돌려줍니다. 지정된 <em>fillchar</em> (기본값은 ASCII 스페이스)을 사용하여 채워넣기합니다. <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 문자열이 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.count">
<code class="descclassname">str.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.count" title="정의 주소">¶</a></dt>
<dd><p>범위 [<em>start</em>, <em>end</em>] 에서 서브스트링 <em>sub</em> 가 중첩되지 않고 등장하는 회수를 돌려줍니다. 선택적 인자 <em>start</em> 와 <em>end</em> 는 슬라이스 표기법으로 해석됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.encode">
<code class="descclassname">str.</code><code class="descname">encode</code><span class="sig-paren">(</span><em>encoding=&quot;utf-8&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#str.encode" title="정의 주소">¶</a></dt>
<dd><p>문자열의 바이트열 객체로 인코딩된 버젼을 돌려줍니다. 기본 인코딩은 <code class="docutils literal"><span class="pre">'utf-8'</span></code> 입니다. <em>errors</em> 는 다른 오류 처리 방식을 설정하기 위해 제공 될 수 있습니다. <em>errors</em> 의 기본값은 <code class="docutils literal"><span class="pre">'strict'</span></code> 인데, 인코딩 오류가 있으면 <a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> 를 일으키라는 뜻입니다. 다른 가능한 값은 <code class="docutils literal"><span class="pre">'ignore'</span></code>, <code class="docutils literal"><span class="pre">'replace'</span></code>, <code class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></code>, <code class="docutils literal"><span class="pre">'backslashreplace'</span></code> 와 <a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></code></a> 를 통해 등록 된 다른 이름들입니다. <a class="reference internal" href="codecs.html#error-handlers"><span class="std std-ref">Error Handlers</span></a> 를 보세요. 가능한 인코딩의 목록을 보려면 <a class="reference internal" href="codecs.html#standard-encodings"><span class="std std-ref">Standard Encodings</span></a> 섹션을 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.1으로 변경: </span>키워드 인자 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.endswith">
<code class="descclassname">str.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.endswith" title="정의 주소">¶</a></dt>
<dd><p>문자열이 지정된 <em>suffix</em> 로 끝나면 <code class="docutils literal"><span class="pre">True</span></code> 를 돌려주고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code> 를 돌려줍니다. <em>suffix</em> 는 찾고자 하는 접미사들의 튜플이 될 수도 있습니다. 선택적 <em>start</em> 가 제공되면 그 위치에서 검사를 시작합니다. 선택적 <em>end</em> 를 사용하면 해당 위치에서 비교를 중단합니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.expandtabs">
<code class="descclassname">str.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span><a class="headerlink" href="#str.expandtabs" title="정의 주소">¶</a></dt>
<dd><p>모든 탭 문자들을 현재의 열과 주어진 탭 크기에 따라 하나나 그 이상의 스페이스로 치환한 문자열의 복사본을 돌려줍니다. 탭 위치는 <em>tabize</em> 문자마다 발생합니다 (기본값은 8이고, 열 0, 8, 16 등에 탭 위치를 지정합니다). 문자열을 확장하기위해 현재 열이 0으로 설정되고 문자열을 문자 단위로 검사합니다. 문자가 탭 (<code class="docutils literal"><span class="pre">\t</span></code>) 이면, 현재 열이 다음 탭 위치와 같아 질 때까지 하나 이상의 스페이스 문자가 삽입됩니다. (탭 문자 자체는 복사되지 않습니다.) 문자가 개행 문자 (<code class="docutils literal"><span class="pre">\n</span></code>) 또는 복귀 문자 (<code class="docutils literal"><span class="pre">\r</span></code>) 이면 복사되고 현재 열은 0으로 재설정됩니다. 다른 문자는 변경되지 않고 복사되고 현재 열은 인쇄 할 때 문자가 어떻게 표시되는지에 관계없이 1 씩 증가합니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
<span class="go">&#39;01      012     0123    01234&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;01  012 0123    01234&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.find">
<code class="descclassname">str.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.find" title="정의 주소">¶</a></dt>
<dd><p>서브스트링 <em>sub</em> 가 슬라이스 <code class="docutils literal"><span class="pre">s[start:end]</span></code> 내에 등장하는 가장 작은 문자열의 인덱스를 돌려줍니다. 선택적 인자 <em>start</em> 와 <em>end</em> 는 슬라이스 표기법으로 해석됩니다. <em>sub</em> 가 없으면 <code class="docutils literal"><span class="pre">-1</span></code> 을 돌려줍니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p><a class="reference internal" href="#str.find" title="str.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a> 메서드는 <em>sub</em> 의 위치를 ​​알아야 할 경우에만 사용해야합니다. <em>sub</em> 가 서브스트링인지 여부를 확인하려면 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 연산자를 사용하십시오:</p>
<div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Py&#39;</span> <span class="ow">in</span> <span class="s1">&#39;Python&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.format">
<code class="descclassname">str.</code><code class="descname">format</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#str.format" title="정의 주소">¶</a></dt>
<dd><p>문자열 포맷 연산을 수행합니다. 이 메서드가 호출되는 문자열은 리터럴 텍스트나 중괄호 <code class="docutils literal"><span class="pre">{}</span></code> 로 구분 된 치환 필드를 포함 할 수 있습니다. 각 치환 필드는 위치 인자의 숫자 인덱스나 키워드 인자의 이름을 가질 수 있습니다. 각 치환 필드를 해당 인자의 문자열 값으로 치환한 문자열의 사본을 돌려줍니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;The sum of 1 + 2 is </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;The sum of 1 + 2 is 3&#39;</span>
</pre></div>
</div>
<p>포맷 문자열에 지정할 수있는 다양한 포맷 옵션에 대한 설명은 <a class="reference internal" href="string.html#formatstrings"><span class="std std-ref">Format String Syntax</span></a> 을 참조하십시오.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">When formatting a number (<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>
and subclasses) with the <code class="docutils literal"><span class="pre">n</span></code> type (ex: <code class="docutils literal"><span class="pre">'{:n}'.format(1234)</span></code>), the
function sets temporarily the <code class="docutils literal"><span class="pre">LC_CTYPE</span></code> locale to the <code class="docutils literal"><span class="pre">LC_NUMERIC</span></code>
locale to decode <code class="docutils literal"><span class="pre">decimal_point</span></code> and <code class="docutils literal"><span class="pre">thousands_sep</span></code> fields of
<code class="xref c c-func docutils literal"><span class="pre">localeconv()</span></code> if they are non-ASCII or longer than 1 byte, and the
<code class="docutils literal"><span class="pre">LC_NUMERIC</span></code> locale is different than the <code class="docutils literal"><span class="pre">LC_CTYPE</span></code> locale. This
temporary change affects other threads.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6.5으로 변경: </span>When formatting a number with the <code class="docutils literal"><span class="pre">n</span></code> type, the function sets
temporarily the <code class="docutils literal"><span class="pre">LC_CTYPE</span></code> locale to the <code class="docutils literal"><span class="pre">LC_NUMERIC</span></code> locale in some
cases.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.format_map">
<code class="descclassname">str.</code><code class="descname">format_map</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#str.format_map" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">str.format(**mapping)</span></code> 과 비슷하지만, <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> 로 복사되지 않고 <code class="docutils literal"><span class="pre">mapping</span></code> 을 직접적으로 사용합니다. 예를 들어 <code class="docutils literal"><span class="pre">mapping</span></code> 이 dict 서브 클래스인 경우 유용합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Default</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">key</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1"> was born in </span><span class="si">{country}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format_map</span><span class="p">(</span><span class="n">Default</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Guido&#39;</span><span class="p">))</span>
<span class="go">&#39;Guido was born in country&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="str.index">
<code class="descclassname">str.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.index" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#str.find" title="str.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a> 과 비슷하지만, 서브스트링을 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.isalnum">
<code class="descclassname">str.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isalnum" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 문자가 알파벳과 숫자이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 문자 <code class="docutils literal"><span class="pre">c</span></code> 는 다음 중 하나가 <code class="docutils literal"><span class="pre">True</span></code> 를 반환하면 알파벳이거나 숫자입니다: <code class="docutils literal"><span class="pre">c.isalpha()</span></code>, <code class="docutils literal"><span class="pre">c.isdecimal()</span></code>, <code class="docutils literal"><span class="pre">c.isdigit()</span></code>, <code class="docutils literal"><span class="pre">c.isnumeric()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="str.isalpha">
<code class="descclassname">str.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isalpha" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 문자가 알파벳이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 알파벳 문자는 유니 코드 문자 데이터베이스에서 &quot;Letter&quot; 로 정의 된 문자입니다. 즉, 일반 범주 속성이 &quot;Lm&quot;, &quot;Lt&quot;, &quot;Lu&quot;, &quot;Ll&quot;, &quot;Lo&quot; 중 하나인 문자입니다. 이것은 유니 코드 표준에서 정의 된 &quot;Alphabetic&quot; 속성과 다름에 주의하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="str.isdecimal">
<code class="descclassname">str.</code><code class="descname">isdecimal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isdecimal" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 문자가 십진수 문자이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 십진수 문자는 십진법으로 숫자를 구성할 때 사용될 수 있는 문자들입니다. 예를 들어, U+0660, ARABIC-INDIC DIGIT ZERO. 형식적으로 십진수 문자는 유니 코드 일반 범주 &quot;Nd&quot; 에 속하는 문자입니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.isdigit">
<code class="descclassname">str.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isdigit" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 문자가 디지트이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 디지트에는 십진수 문자와 호환성 위 첨자 숫자와 같은 특수 처리가 필요한 숫자가 포함됩니다. 여기에는 카로슈티 숫자처럼 십진법으로 숫자를 구성할 때 사용될 수 없는 것들이 포함됩니다. 형식적으로, 디지트는 속성 값이 Numeric_Type=Digit 또는 Numeric_Type=Decimal 인 문자입니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.isidentifier">
<code class="descclassname">str.</code><code class="descname">isidentifier</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isidentifier" title="정의 주소">¶</a></dt>
<dd><p>문자열이 섹션 section <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">식별자와 키워드</span></a> 의 언어 정의에 따른 유효한 식별자인 경우 참을 돌려줍니다.</p>
<p><a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal"><span class="pre">def</span></code></a> 나 <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a> 와 같은 예약 식별자를 검사하려면 <a class="reference internal" href="keyword.html#keyword.iskeyword" title="keyword.iskeyword"><code class="xref py py-func docutils literal"><span class="pre">keyword.iskeyword()</span></code></a> 를 사용하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="str.islower">
<code class="descclassname">str.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.islower" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 케이스 문자가 <a class="footnote-reference" href="#id15" id="id6">[4]</a> 소문자이고, 적어도 하나의 케이스 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.isnumeric">
<code class="descclassname">str.</code><code class="descname">isnumeric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isnumeric" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 문자가 숫자이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 숫자는 디지트와 유니코드 숫자값 속성을 갖는 모든 문자를 포함합니다. 예를 들어, U+2155, VULGAR FRACTION ONE FIFTH. 형식적으로, 숫자는 속성 값이 Numeric_Type=Digit, Numeric_Type=Decimal, Numeric_Type=Numeric 인 문자입니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.isprintable">
<code class="descclassname">str.</code><code class="descname">isprintable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isprintable" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 문자가 인쇄가능하거나 문자열이 비어있으면 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 인쇄 할 수없는 문자는 유니 코드 문자 데이터베이스에 &quot;Other&quot; 또는 &quot;Separator&quot; 로 정의 된 문자입니다. ASCII 스페이스 (0x20) 는 예외인데, 인쇄가능한 것으로 간주됩니다. (이 문맥에서, 인쇄 가능한 문자는 문자열에 <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 을 호출했을 때 이스케이프되지 않아야 하는 것들입니다. <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></code></a> 또는 <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></code></a> 로 출력되는 문자열의 처리에 영향을주지 않습니다.)</p>
</dd></dl>

<dl class="method">
<dt id="str.isspace">
<code class="descclassname">str.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isspace" title="정의 주소">¶</a></dt>
<dd><p>문자열 내에 공백 문자만 있고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 공백 문자는 유니 코드 문자 데이터베이스에서 &quot;Other&quot; 나 &quot;Separator&quot; 로 정의되고 양방향 속성이 &quot;WS&quot;, &quot;B&quot;, &quot;S&quot; 중 하나 인 문자입니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.istitle">
<code class="descclassname">str.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.istitle" title="정의 주소">¶</a></dt>
<dd><p>문자열이 제목 케이스 문자열이고 하나 이상의 문자가있는 경우 참을 돌려줍니다. 예를 들어 대문자 앞에는 케이스 없는 문자만 올 수 있고 소문자는 케이스 문자 뒤에만 올 수 있습니다. 그렇지 않은 경우는 거짓을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.isupper">
<code class="descclassname">str.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isupper" title="정의 주소">¶</a></dt>
<dd><p>문자열 내의 모든 케이스 문자가 <a class="footnote-reference" href="#id15" id="id7">[4]</a> 대문자이고, 적어도 하나의 케이스 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.join">
<code class="descclassname">str.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#str.join" title="정의 주소">¶</a></dt>
<dd><p><em>iterable</em> 의 문자열들을 이어붙이기한 문자열을 돌려줍니다. <em>iterable</em> 에 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체나 기타 문자열이 아닌 값이 있으면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 를 일으킵니다. 요소들 사이의 구분자는 이 메서드를 제공하는 문자열입니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.ljust">
<code class="descclassname">str.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.ljust" title="정의 주소">¶</a></dt>
<dd><p>왼쪽으로 정렬 된 문자열을 길이 <em>width</em> 인 문자열로 돌려줍니다. 지정된 <em>fillchar</em> (기본값은 ASCII 스페이스)을 사용하여 채워넣기합니다. <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 문자열이 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.lower">
<code class="descclassname">str.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.lower" title="정의 주소">¶</a></dt>
<dd><p>모든 케이스 문자 <a class="footnote-reference" href="#id15" id="id8">[4]</a> 가 소문자로 변환 된 문자열의 복사본을 돌려줍니다.</p>
<p>사용되는 소문자화 알고리즘은 유니 코드 표준의 섹션 3.13에 설명되어 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.lstrip">
<code class="descclassname">str.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.lstrip" title="정의 주소">¶</a></dt>
<dd><p>선행 문자가 제거 된 문자열의 복사본을 돌려줍니다. <em>chars</em> 인자는 제거 할 문자 집합을 지정하는 문자열입니다. 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이라면, <em>chars</em> 인자의 기본값은 공백을 제거하도록합니다. <em>chars</em> 인자는 접두사가 아닙니다; 모든 값 조합이 제거됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">&#39;spacious   &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">&#39;example.com&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="str.maketrans">
<em class="property">static </em><code class="descclassname">str.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>x</em><span class="optional">[</span>, <em>y</em><span class="optional">[</span>, <em>z</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.maketrans" title="정의 주소">¶</a></dt>
<dd><p>이 정적 메서드는 <a class="reference internal" href="#str.translate" title="str.translate"><code class="xref py py-meth docutils literal"><span class="pre">str.translate()</span></code></a> 에 사용할 수있는 변환표를 돌려줍니다.</p>
<p>인자가 하나만 있으면 유니 코드 포인트 (정수) 또는 문자 (길이가 1 인 문자열)를 유니 코드 포인트, 문자열 (임의 길이) 또는 <code class="docutils literal"><span class="pre">None</span></code> 으로 매핑하는 딕셔너리이어야합니다. 문자 키는 유니 코드 포인트로 변환됩니다.</p>
<p>인자가 두 개인 경우 길이가 같은 문자열이어야하며, 결과 딕셔너리에서, x의 각 문자는 y의 같은 위치에있는 문자로 매핑됩니다. 세번째의 인자가있는 경우, 문자열이어야 하는데 각 문자들이 <code class="docutils literal"><span class="pre">None</span></code> 으로 매핑되는 결과를 줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.partition">
<code class="descclassname">str.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#str.partition" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 가 처음 나타나는 위치에서 문자열을 분할하고, 구분자 앞에있는 부분, 구분자 자체, 구분자 뒤에 오는 부분으로 구성된 3-튜플을 돌려줍니다. 구분자가 발견되지 않으면, 문자열 자신과 그 뒤를 따르는 두 개의 빈 문자열로 구성된 3-튜플을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.replace">
<code class="descclassname">str.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.replace" title="정의 주소">¶</a></dt>
<dd><p>모든 서브스트링 <em>old</em> 가 <em>new</em> 로 치환 된 문자열의 복사본을 돌려줍니다. 선택적 인자 <em>count</em> 가 주어지면, 앞의 <em>count</em> 개만 치환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.rfind">
<code class="descclassname">str.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rfind" title="정의 주소">¶</a></dt>
<dd><p>서브스트링 <em>sub</em> 가 <code class="docutils literal"><span class="pre">s[start:end]</span></code> 내에 등장하는 가장 큰 문자열의 인덱스를 돌려줍니다. 선택적 인자 <em>start</em> 와 <em>end</em> 는 슬라이스 표기법으로 해석됩니다. 실패하면 <code class="docutils literal"><span class="pre">-1</span></code> 을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.rindex">
<code class="descclassname">str.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rindex" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#str.rfind" title="str.rfind"><code class="xref py py-meth docutils literal"><span class="pre">rfind()</span></code></a> 와 비슷하지만, 서브스트링 <em>sub</em> 를 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.rjust">
<code class="descclassname">str.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillchar</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rjust" title="정의 주소">¶</a></dt>
<dd><p>오른쪽으로 정렬 된 문자열을 길이 <em>width</em> 인 문자열로 돌려줍니다. 지정된 <em>fillchar</em> (기본값은 ASCII 스페이스)을 사용하여 채워넣기합니다. <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 문자열이 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.rpartition">
<code class="descclassname">str.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#str.rpartition" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 가 마지막으로 나타나는 위치에서 문자열을 분할하고, 구분자 앞에있는 부분, 구분자 자체, 구분자 뒤에 오는 부분으로 구성된 3-튜플을 돌려줍니다. 구분자가 발견되지 않으면, 두 개의 빈 문자열과 그 뒤를 따르는 문자열 자신으로 구성된 3-튜플을 돌려줍니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.rsplit">
<code class="descclassname">str.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#str.rsplit" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를 돌려줍니다. <em>maxsplit</em> 이 주어지면 가장 오른쪽에서 최대 <em>maxsplit</em> 번의 분할이 수행됩니다. <em>sep</em> 이 지정되지 않거나 <code class="docutils literal"><span class="pre">None</span></code> 이면, 구분자로 모든 공백 문자가 사용됩니다. 오른쪽에서 분리하는 것을 제외하면, <a class="reference internal" href="#str.rsplit" title="str.rsplit"><code class="xref py py-meth docutils literal"><span class="pre">rsplit()</span></code></a> 는 아래에서 자세히 설명될 <a class="reference internal" href="#str.split" title="str.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> 처럼 동작합니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.rstrip">
<code class="descclassname">str.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rstrip" title="정의 주소">¶</a></dt>
<dd><p>후행 문자가 제거 된 문자열의 복사본을 돌려줍니다. <em>chars</em> 인자는 제거 할 문자 집합을 지정하는 문자열입니다. 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이라면, <em>chars</em> 인자의 기본값은 공백을 제거하도록합니다. <em>chars</em> 인자는 접미사가 아닙니다; 모든 값 조합이 제거됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">&#39;   spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;mississippi&#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;ipz&#39;</span><span class="p">)</span>
<span class="go">&#39;mississ&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.split">
<code class="descclassname">str.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#str.split" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를 돌려줍니다. <em>maxsplit</em> 이 주어지면 최대 <em>maxsplit</em> 번의 분할이 수행됩니다 (따라서, 리스트는 최대 <code class="docutils literal"><span class="pre">maxsplit+1</span></code> 개의 요소를 가지게됩니다). <em>maxsplit</em> 이 지정되지 않았거나 <code class="docutils literal"><span class="pre">-1</span></code> 이라면 분할 수에 제한이 없습니다 (가능한 모든 분할이 만들어집니다).</p>
<p><em>sep</em> 이 주어지면, 연속 된 구분자는 묶이지 않고 빈 문자열을 구분하는 것으로 간주됩니다 (예를 들어, <code class="docutils literal"><span class="pre">'1,,2'.split(',')</span></code> 는 <code class="docutils literal"><span class="pre">['1',</span> <span class="pre">'',</span> <span class="pre">'2']</span></code> 를 돌려줍니다). <em>sep</em> 인자는 여러 문자로 구성 될 수 있습니다 (예를 들어, <code class="docutils literal"><span class="pre">'1&lt;&gt;2&lt;&gt;3'.split('&lt;&gt;')</span></code> 는 <code class="docutils literal"><span class="pre">['1',</span> <span class="pre">'2',</span> <span class="pre">'3']</span></code> 를 돌려줍니다). 지정된 구분자로 빈 문자열을 분할하면 <code class="docutils literal"><span class="pre">['']</span></code> 를 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2,3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,,3,&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;&#39;, &#39;3&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p><em>sep</em> 이 지정되지 않거나 <code class="docutils literal"><span class="pre">None</span></code> 이면, 다른 분할 알고리즘이 적용됩니다: 연속 된 공백 문자는 단일한 구분자로 간주되고, 문자열이 선행이나 후행 공백을 포함해도 결과는 시작과 끝에 빈 분자열을 포함하지 않습니다. 결과적으로, 빈 문자열이나 공백만으로 구성된 문자열을 <code class="docutils literal"><span class="pre">None</span></code> 구분자로 분할하면 <code class="docutils literal"><span class="pre">[]</span></code> 를 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2 3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   1   2   3   &#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="index-32"></span><dl class="method">
<dt id="str.splitlines">
<code class="descclassname">str.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><span class="optional">[</span><em>keepends</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.splitlines" title="정의 주소">¶</a></dt>
<dd><p>줄 경계에서 분할한 문자열의 줄 리스트를 돌려줍니다. <em>keepends</em> 가 참으로 추어지지 않는 한 결과 리스트에 줄 바꿈은 포함되지 않습니다.</p>
<p>이 메서드는 다음 줄 경계에서 분할합니다. 특히, 경계는 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">유니버설 줄 넘김</span></a> 을 포함합니다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">표현</th>
<th class="head">설명</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\n</span></code></td>
<td>개행</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\r</span></code></td>
<td>캐리지 리턴</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\r\n</span></code></td>
<td>캐리지 리턴 + 개행</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\v</span></code> 또는 <code class="docutils literal"><span class="pre">\x0b</span></code></td>
<td>수직 탭</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\f</span></code> 또는 <code class="docutils literal"><span class="pre">\x0c</span></code></td>
<td>폼 피드</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\x1c</span></code></td>
<td>파일 구분자</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\x1d</span></code></td>
<td>그룹 구분자</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\x1e</span></code></td>
<td>레코드 구분자</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\x85</span></code></td>
<td>다음 줄 (C1 제어 코드)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\u2028</span></code></td>
<td>줄 구분자</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\u2029</span></code></td>
<td>문단 구분자</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><code class="docutils literal"><span class="pre">\v</span></code> 와 <code class="docutils literal"><span class="pre">\f</span></code> 를 줄 경계 목록에 추가했습니다.</p>
</div>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[&#39;ab c&#39;, &#39;&#39;, &#39;de fg&#39;, &#39;kl&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[&#39;ab c\n&#39;, &#39;\n&#39;, &#39;de fg\r&#39;, &#39;kl\r\n&#39;]</span>
</pre></div>
</div>
<p>구분자 문자열 <em>sep</em> 가 주어 졌을 때 <a class="reference internal" href="#str.split" title="str.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> 와 달리, 이 메서드는 빈 문자열에 대해서 빈 리스트를 돌려주고, 마지막 줄 바꿈은 새 줄을 만들지 않습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;One line</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[&#39;One line&#39;]</span>
</pre></div>
</div>
<p>비교해 보면, <code class="docutils literal"><span class="pre">split('\n')</span></code> 는 이렇게 됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Two lines</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;Two lines&#39;, &#39;&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.startswith">
<code class="descclassname">str.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.startswith" title="정의 주소">¶</a></dt>
<dd><p>문자열이 지정된 <em>prefix</em> 로 시작하면 <code class="docutils literal"><span class="pre">True</span></code> 를 돌려주고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code> 를 돌려줍니다. <em>prefix</em> 는 찾고자 하는 접두사들의 튜플이 될 수도 있습니다. 선택적 <em>start</em> 가 제공되면 그 위치에서 검사를 시작합니다. 선택적 <em>end</em> 를 사용하면 해당 위치에서 비교를 중단합니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.strip">
<code class="descclassname">str.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.strip" title="정의 주소">¶</a></dt>
<dd><p>선행과 후행 문자가 제거 된 문자열의 복사본을 돌려줍니다. <em>chars</em> 인자는 제거 할 문자 집합을 지정하는 문자열입니다. 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이라면, <em>chars</em> 인자의 기본값은 공백을 제거하도록합니다. <em>chars</em> 인자는 접두사나 접미사가 아닙니다; 모든 값 조합이 제거됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">&#39;spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">&#39;example&#39;</span>
</pre></div>
</div>
<p>가장 바깥 쪽의 선행 또는 후행 <em>chars</em> 인자 값들이 문자열에서 제거됩니다. 문자는 <em>chars</em> 에 있는 문자 집합에 포함되지 않은 문자에 도달 할 때까지 맨 앞에서 제거됩니다. 끝에서도 유사한 동작이 수행됩니다. 예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">comment_string</span> <span class="o">=</span> <span class="s1">&#39;#....... Section 3.2.1 Issue #32 .......&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comment_string</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;.#! &#39;</span><span class="p">)</span>
<span class="go">&#39;Section 3.2.1 Issue #32&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.swapcase">
<code class="descclassname">str.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.swapcase" title="정의 주소">¶</a></dt>
<dd><p>대문자를 소문자로, 그 반대로 마찬가지로 변환 한 문자열의 복사본을 돌려줍니다. <code class="docutils literal"><span class="pre">s.swapcase().swapcase()</span> <span class="pre">==</span> <span class="pre">s</span></code> 가 반드시 성립하지 않음에 주의하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="str.title">
<code class="descclassname">str.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.title" title="정의 주소">¶</a></dt>
<dd><p>단어가 대문자로 시작하고 나머지 문자는 소문자가 되도록 문자열의 제목 케이스 버전을 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>이 알고리즘은 단어를 글자들의 연속으로 보는 간단한 언어 독립적 정의를 사용합니다. 이 정의는 여러 상황에서 작동하지만, 축약과 소유의 아포스트로피가 단어 경계를 형성한다는 것을 의미하고, 이는 원하는 결과가 아닐 수도 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;they&#39;re bill&#39;s friends from the UK&quot;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">&quot;They&#39;Re Bill&#39;S Friends From The Uk&quot;</span>
</pre></div>
</div>
<p>정규식을 사용하여 아포스트로피에 대한 해결 방법을 구성 할 수 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">titlecase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[A-Za-z]+(&#39;[A-Za-z]+)?&quot;</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="k">lambda</span> <span class="n">mo</span><span class="p">:</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span>
<span class="gp">... </span>                             <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
<span class="gp">... </span>                  <span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">titlecase</span><span class="p">(</span><span class="s2">&quot;they&#39;re bill&#39;s friends.&quot;</span><span class="p">)</span>
<span class="go">&quot;They&#39;re Bill&#39;s Friends.&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="str.translate">
<code class="descclassname">str.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em><span class="sig-paren">)</span><a class="headerlink" href="#str.translate" title="정의 주소">¶</a></dt>
<dd><p>각 문자를 지정된 변환표를 사용해 매핑한 문자열의 복사본을 돌려줍니다. table 은 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> 을 통한 인덱싱을 구현하는 객체 여야하는데, 보통 <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">매핑</span></a> 이나 <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">시퀀스</span></a> 입니다. 유니 코드 포인트 (정수)로 인덱싱 할 때, table 객체는 다음 중 하나를 수행 할 수 있습니다: 그 문자를 하나 이상의 다른 문자들로 매핑하기 위해 유니 코드 포인트나 문자열을 돌려줍니다; 결과 문자열에서 그 문자를 제거하기 위해 <code class="docutils literal"><span class="pre">None</span></code> 을 돌려줍니다; 그 문자를 자기 자신으로 매핑하기 위해 <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a> 예외를 일으킵니다.</p>
<p><a class="reference internal" href="#str.maketrans" title="str.maketrans"><code class="xref py py-meth docutils literal"><span class="pre">str.maketrans()</span></code></a> 를 사용하여 다른 형식의 문자 대 문자 매핑으로 부터 변환 맵을 만들 수 있습니다.</p>
<p>커스텀 문자 매핑에 대한 보다 유연한 접근법은 <a class="reference internal" href="codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a> 모듈을 참고하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="str.upper">
<code class="descclassname">str.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.upper" title="정의 주소">¶</a></dt>
<dd><p>모든 케이스 문자 <a class="footnote-reference" href="#id15" id="id9">[4]</a> 가 대문자로 변환 된 문자열의 복사본을 돌려줍니다. <code class="docutils literal"><span class="pre">s</span></code> 가 케이스 없는 문자를 포함하거나 결과 문자의 유니 코드 범주가 &quot;Lu&quot; (Letter, 대문자) 가 아닌 경우, 예를 들어  &quot;Lt&quot; (Letter, 제목 케이스), <code class="docutils literal"><span class="pre">str.upper().isupper()</span></code> 가 <code class="docutils literal"><span class="pre">False</span></code> 일 수 있음에 주의하십시오.</p>
<p>사용되는 대문자화 알고리즘은 유니 코드 표준의 섹션 3.13에 설명되어 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="str.zfill">
<code class="descclassname">str.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#str.zfill" title="정의 주소">¶</a></dt>
<dd><p>길이가 <em>width</em> 인 문자열을 만들기 위해 ASCII <code class="docutils literal"><span class="pre">'0'</span></code> 문자를 왼쪽에 채운 문자열의 복사본을 돌려줍니다. 선행 부호 접두어(<code class="docutils literal"><span class="pre">'+'</span></code>/<code class="docutils literal"><span class="pre">'-'</span></code>)는 부호 문자의 앞이 아니라 <em>뒤</em> 에 채워넣는 것으로 처리됩니다. <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 문자열을 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;00042&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;-42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;-0042&#39;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="printf-style-string-formatting">
<span id="old-string-formatting"></span><h3>4.7.2. <code class="docutils literal"><span class="pre">printf</span></code> 스타일 문자열 포맷팅<a class="headerlink" href="#printf-style-string-formatting" title="제목 주소">¶</a></h3>
<div class="admonition note" id="index-33">
<p class="first admonition-title">주석</p>
<p class="last">여기에 설명 된 포맷 연산은 여러 가지 일반적인 오류를 (예를 들어 튜플 과 딕셔너리를 올바르게 표시하지 못하는 것) 유발하는 다양한 문제점들이 있습니다. 새 <a class="reference internal" href="../reference/lexical_analysis.html#f-strings"><span class="std std-ref">포맷 문자열 리터럴</span></a> 나 <a class="reference internal" href="#str.format" title="str.format"><code class="xref py py-meth docutils literal"><span class="pre">str.format()</span></code></a> 인터페이스를 사용하면 이러한 오류를 피할 수 있습니다. 이 대안들은 또한 텍스트 포맷팅에 보다 강력하고 유연하며 확장 가능한 접근법을 제공합니다.</p>
</div>
<p>문자열 객체는 한가지 고유한 내장 연산을 갖고 있습니다: <code class="docutils literal"><span class="pre">%</span></code> 연산자 (모듈로). 이것은 문자열 <em>포맷팅</em> 또는 <em>치환</em> 연산자라고도 합니다. <code class="docutils literal"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">values</span></code> 가 주어질 때 (<em>format</em> 은 문자열입니다), <em>format</em> 내부의 <code class="docutils literal"><span class="pre">%</span></code> 변환 명세는 0 개 이상의 <em>values​​</em> 의 요소로 대체됩니다. 이 효과는 C 언어에서 <code class="xref c c-func docutils literal"><span class="pre">sprintf()</span></code> 를 사용하는 것과 비슷합니다.</p>
<p><em>format</em> 이 하나의 인자를 요구하면, <em>values​​</em> 는 하나의 비 튜플 객체 일 수 있습니다. <a class="footnote-reference" href="#id16" id="id10">[5]</a> 그렇지 않으면, <em>values​​</em> 는 format 문자열이 지정하는 항목의 수와 같은 튜플이거나 단일 매핑 객체 (예를 들어, 딕셔너리) 이어야합니다.</p>
<p>변환 명세는 두 개 이상의 문자를 포함하며 다음과 같은 구성 요소들을 포함하는데, 반드시 이 순서대로 나와야 합니다:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">'%'</span></code> 문자: 명세자의 시작을 나타냅니다.</li>
<li>매핑 키 (선택 사항): 괄호로 둘러싸인 문자들의 시퀀스로 구성됩니다 (예를 들어, <code class="docutils literal"><span class="pre">(somename)</span></code>).</li>
<li>변환 플래그 (선택 사항): 일부 변환 유형의 결과에 영향을 줍니다.</li>
<li>최소 필드 폭 (선택 사항): <code class="docutils literal"><span class="pre">'*'</span></code> (애스터리스크) 로 지정하면, 실제 폭은 <em>values</em> 튜플의 다음 요소에서 읽히고, 변환 할 객체는 최소 필드 폭과 선택적 정밀도 뒤에 옵니다.</li>
<li>정밀도 (선택 사항): <code class="docutils literal"><span class="pre">'.'</span></code> (점) 다음에 정밀도가 옵니다. <code class="docutils literal"><span class="pre">'*'</span></code> (애스터리스크) 로 지정하면, 실제 정밀도는 <em>values</em> 튜플의 다음 요소에서 읽히고, 변환 할 값은 정밀도 뒤에 옵니다.</li>
<li>길이 수정자 (선택 사항).</li>
<li>변환 유형.</li>
</ol>
<p>오른쪽 인자가 딕셔너리 (또는 다른 매핑 형) 인 경우, 문자열에 있는 변환 명세는 <em>반드시</em> <code class="docutils literal"><span class="pre">'%'</span></code> 문자 바로 뒤에 그 딕셔너리의 매핑 키를 괄호로 둘러싸인 형태로 포함해야합니다. 매핑 키는 포맷할 값은 매핑으로 부터 선택합니다. 예를 들어:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(language)s</span><span class="s1"> has </span><span class="si">%(number)03d</span><span class="s1"> quote types.&#39;</span> <span class="o">%</span>
<span class="gp">... </span>      <span class="p">{</span><span class="s1">&#39;language&#39;</span><span class="p">:</span> <span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">Python has 002 quote types.</span>
</pre></div>
</div>
<p>이 경우 <code class="docutils literal"><span class="pre">*</span></code> 지정자를 사용할 수 없습니다 (순차적인 파라미터 목록이 필요하기 때문입니다).</p>
<p>변환 플래그 문자는 다음과 같습니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">플래그</th>
<th class="head">뜻</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'#'</span></code></td>
<td>값 변환에 &quot;대체 형식&quot; (아래에 정의되어있습니다) 을 사용합니다.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'0'</span></code></td>
<td>변환은 숫자 값의 경우 0으로 채웁니다.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'-'</span></code></td>
<td>변환 된 값은 왼쪽으로 정렬됩니다 (둘 다 주어지면 <code class="docutils literal"><span class="pre">'0'</span></code> 변환보다 우선 합니다).</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></code></td>
<td>(스페이스) 부호있는 변환에 의해 만들어진 양수 앞에 빈칸을 남겨둡니다 (음수면 빈 문자열입니다).</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'+'</span></code></td>
<td>부호 문자 (<code class="docutils literal"><span class="pre">'+'</span></code> or <code class="docutils literal"><span class="pre">'-'</span></code>) 가 변환 앞에 놓입니다 (<code class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></code> 플래그에 우선합니다).</td>
</tr>
</tbody>
</table>
<p>길이 수정자 (<code class="docutils literal"><span class="pre">h</span></code>, <code class="docutils literal"><span class="pre">l</span></code>, <code class="docutils literal"><span class="pre">L</span></code>) 를 제공할 수는 있지만, 파이썬에서 필요하지 않기 때문에 무시됩니다 -- 예를 들어 <code class="docutils literal"><span class="pre">%ld</span></code> 는 <code class="docutils literal"><span class="pre">%d</span></code> 와 동일합니다.</p>
<p>변환 유형은 다음과 같습니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="74%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">변환</th>
<th class="head">뜻</th>
<th class="head">노트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'d'</span></code></td>
<td>부호있는 정수 십진표기.</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'i'</span></code></td>
<td>부호있는 정수 십진표기.</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'o'</span></code></td>
<td>부호있는 8진수 값.</td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'u'</span></code></td>
<td>쓸데없는 유형 -- <code class="docutils literal"><span class="pre">'d'</span></code> 와 동일합니다.</td>
<td>(6)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'x'</span></code></td>
<td>부호있는 16 진수 (소문자).</td>
<td>(2)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'X'</span></code></td>
<td>부호있는 16 진수 (대문자).</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'e'</span></code></td>
<td>부동 소수점 지수 형식 (소문자).</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'E'</span></code></td>
<td>부동 소수점 지수 형식 (대문자).</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'f'</span></code></td>
<td>부동 소수점 십진수 형식.</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'F'</span></code></td>
<td>부동 소수점 십진수 형식.</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'g'</span></code></td>
<td>부동 소수점 형식. 지수가 -4보다 작거나 정밀도 보다 작지 않으면 소문자 지수형식을 사용하고, 그렇지 않으면 십진수 형식을 사용합니다.</td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'G'</span></code></td>
<td>부동 소수점 형식. 지수가 -4보다 작거나 정밀도 보다 작지 않으면 대문자 지수형식을 사용하고, 그렇지 않으면 십진수 형식을 사용합니다.</td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'c'</span></code></td>
<td>단일 문자 (정수 또는 길이 1 인 문자열을 허용합니다).</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'r'</span></code></td>
<td>문자열 (<a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 를 사용하여 파이썬 객체를 변환합니다).</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'s'</span></code></td>
<td>문자열 (<a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a> 을 사용하여 파이썬 객체를 변환합니다).</td>
<td>(5)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'a'</span></code></td>
<td>문자열 (<a class="reference internal" href="functions.html#ascii" title="ascii"><code class="xref py py-func docutils literal"><span class="pre">ascii()</span></code></a> 를 사용하여 파이썬 객체를 변환합니다).</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'%'</span></code></td>
<td>인자는 변환되지 않고, 결과에 <code class="docutils literal"><span class="pre">'%'</span></code> 문자가 표시됩니다.</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>노트:</p>
<ol class="arabic">
<li><p class="first">대체 형식은 첫 번째 숫자 앞에 선행 8 진수 지정자 (<code class="docutils literal"><span class="pre">'0o'</span></code>)를  삽입합니다.</p>
</li>
<li><p class="first">대체 형식은 첫 번째 숫자 앞에 선행 <code class="docutils literal"><span class="pre">'0x'</span></code> 또는 <code class="docutils literal"><span class="pre">'0X'</span></code> (<code class="docutils literal"><span class="pre">'x'</span></code> 나 <code class="docutils literal"><span class="pre">'X'</span></code> 유형중 어느 것을 사용하느냐에 따라 달라집니다) 를 삽입합니다.</p>
</li>
<li><p class="first">대체 형식은 그 뒤에 숫자가 나오지 않더라도 항상 소수점을 포함시킵니다.</p>
<p>정밀도는 소수점 이하 자릿수를 결정하며 기본값은 6입니다.</p>
</li>
<li><p class="first">대체 형식은 결과에 항상 소수점을 포함시키고 뒤에 오는 0은 제거되지 않습니다.</p>
<p>정밀도는 소수점 앞뒤의 유효 자릿수를 결정하며 기본값은 6입니다.</p>
</li>
<li><p class="first">정밀도가 <code class="docutils literal"><span class="pre">N</span></code> 이라면, 출력은 <code class="docutils literal"><span class="pre">N</span></code> 문자로 잘립니다.</p>
</li>
<li><p class="first"><span class="target" id="index-57"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a> 을 참조하세요.</p>
</li>
</ol>
<p>파이썬 문자열은 명시적인 길이를 가지고 있기 때문에, <code class="docutils literal"><span class="pre">%s</span></code> 변환은 문자열의 끝이 <code class="docutils literal"><span class="pre">'\0'</span></code> 이라고 가정하지 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.1으로 변경: </span>절대값이 1e50 을 넘는 숫자에 대한 <code class="docutils literal"><span class="pre">%f</span></code> 변환은 더 이상 <code class="docutils literal"><span class="pre">%g</span></code> 변환으로 대체되지 않습니다.</p>
</div>
</div>
</div>
<div class="section" id="binary-sequence-types-bytes-bytearray-memoryview">
<span id="binaryseq"></span><span id="index-35"></span><h2>4.8. 바이너리 시퀀스 형 --- <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>, <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a><a class="headerlink" href="#binary-sequence-types-bytes-bytearray-memoryview" title="제목 주소">¶</a></h2>
<p id="index-36">바이너리 데이터를 조작하기위한 핵심 내장 형은 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 와 <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 입니다. 이것들은 <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> 에 의해 지원되는데, 다른 바이너리 객체들의 메모리에 복사없이 접근하기위해 <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">버퍼 프로토콜</span></a> 을 사용합니다.</p>
<p><a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal"><span class="pre">array</span></code></a> 모듈은 32 비트 정수와 IEEE754 배정도 부동 소수점 같은 기본 데이터 형의 효율적인 저장을 지원합니다.</p>
<div class="section" id="bytes-objects">
<span id="typebytes"></span><h3>4.8.1. 바이트열 객체<a class="headerlink" href="#bytes-objects" title="제목 주소">¶</a></h3>
<p id="index-37">바이트열 객체는 단일 바이트들의 불변 시퀀스입니다. 많은 주요 바이너리 프로토콜이 ASCII 텍스트 인코딩을 기반으로하므로, 바이트열 객체는 ASCII 호환 데이터로 작업 할 때만 유효한 여러 가지 메서드를 제공하며 다양한 다른 방법으로 문자열 객체와 밀접한 관련이 있습니다.</p>
<dl class="class">
<dt id="bytes">
<em class="property">class </em><code class="descname">bytes</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes" title="정의 주소">¶</a></dt>
<dd><p>첫째로, 바이트열 리터럴의 문법은 문자열 리터럴과 거의 동일하지만 <code class="docutils literal"><span class="pre">b</span></code> 접두사가 추가된다는 점이 다릅니다.:</p>
<ul class="simple">
<li>작은 따옴표: <code class="docutils literal"><span class="pre">b'still</span> <span class="pre">allows</span> <span class="pre">embedded</span> <span class="pre">&quot;double&quot;</span> <span class="pre">quotes'</span></code></li>
<li>큰 따옴표: <code class="docutils literal"><span class="pre">b&quot;still</span> <span class="pre">allows</span> <span class="pre">embedded</span> <span class="pre">'single'</span> <span class="pre">quotes&quot;</span></code>.</li>
<li>삼중 따옴표: <code class="docutils literal"><span class="pre">b'''3</span> <span class="pre">single</span> <span class="pre">quotes'''</span></code>, <code class="docutils literal"><span class="pre">b&quot;&quot;&quot;3</span> <span class="pre">double</span> <span class="pre">quotes&quot;&quot;&quot;</span></code></li>
</ul>
<p>바이트열 리터럴에는 ASCII 문자 만 허용됩니다 (선언된 소스 코드 인코딩과 관계 없읍니다). 127 보다 큰 바이너리 값은 적절한 이스케이프 시퀀스를 사용하여 바이트열 리터럴에 입력해야합니다.</p>
<p>문자열 리터럴의 경우와 마찬가지로 바이트열 리터럴은 이스케이프 시퀀스 처리를 비활성화하기 위해 <code class="docutils literal"><span class="pre">r</span></code> 접두사를 사용할 수도 있습니다. 지원되는 이스케이프 시퀀스를 포함하여 바이트열 리터럴의 다양한 형식에 대한 자세한 내용은 <a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">문자열과 바이트열 리터럴</span></a> 을 참조하십시오.</p>
<p>바이트열 리터럴과 그 표현은 ASCII 텍스트를 기반으로하지만, 바이트열 객체는 실제로는 정수의 불변 시퀀스 처럼 동작하고, 시퀀스의 각 값은 <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> 이 되도록 제한됩니다 (이 제한을 위반하려고 시도하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다). 이것은 많은 바이너리 형식이 ASCII 기반 요소를 포함하고 일부 텍스트 지향 알고리즘으로 유용하게 조작 될 수 있지만, 임의의 바이너리 데이터에 일반적으로 적용될수는 없음을 강조하기 위한 것입니다 (텍스트 처리 알고리즘을 맹목적으로 ASCII 호환이 아닌 바이너리 데이터 형식에 적용하면 대개 데이터 손상으로 이어집니다).</p>
<p>리터럴 형식 외에도, 바이트열 객체는 여러 가지 다른 방법으로 만들 수 있습니다.:</p>
<ul class="simple">
<li>지정된 길이의 0 으로 채워진 바이트열 객체: <code class="docutils literal"><span class="pre">bytes(10)</span></code></li>
<li>정수의 이터러블로 부터: <code class="docutils literal"><span class="pre">bytes(range(20))</span></code></li>
<li>버퍼 프로토콜을 통해 기존 바이너리 데이터 복사: <code class="docutils literal"><span class="pre">bytes(obj)</span></code></li>
</ul>
<p>내장 <a class="reference internal" href="functions.html#func-bytes"><span class="std std-ref">bytes</span></a> 도 참조하세요.</p>
<p>2 개의 16 진수는 정확히 하나의 바이트에 대응하기 때문에 16 진수는 바이너리 데이터를 설명하는 데 일반적으로 사용되는 형식입니다. 따라서, 바이트열 형은 그 형식의 데이터를 읽는 추가의 클래스 메서드를 갖습니다:</p>
<dl class="classmethod">
<dt id="bytes.fromhex">
<em class="property">classmethod </em><code class="descname">fromhex</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.fromhex" title="정의 주소">¶</a></dt>
<dd><p>이 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 클래스 메서드는 주어진 문자열 객체를 디코딩해서 바이트열 객체를 돌려줍니다. 문자열은 바이트 당 두 개의 16 진수가 포함되어야하며 ASCII 공백은 무시됩니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;2Ef0 F1f2  &#39;</span><span class="p">)</span>
<span class="go">b&#39;.\xf0\xf1\xf2&#39;</span>
</pre></div>
</div>
</dd></dl>

<p>바이트열 객체를 16 진수 표현으로 변환하기위한 역 변환 함수가 있습니다.</p>
<dl class="method">
<dt id="bytes.hex">
<code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.hex" title="정의 주소">¶</a></dt>
<dd><p>인스턴스의 각 바이트마다 2 자리수의 16 진수로 표현한 문자열 객체를 돌려줍니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xf0\xf1\xf2</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;f0f1f2&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<p>바이트열 객체는 정수의 시퀀스(튜플과 유사)이기 때문에, 바이트열 객체 <em>b</em> 에 대해서, <code class="docutils literal"><span class="pre">b[0]</span></code> 는 정수가됩니다. 반면, <code class="docutils literal"><span class="pre">b[0:1]</span></code> 는 길이 1 인 바이트열 객체가 됩니다. (이것은 인덱싱과 슬라이싱 모두 길이 1인 문자열을 생성하는 텍스트 문자열과 대조됩니다)</p>
<p>바이트열 객체의 표현은 리터럴 형식 (<code class="docutils literal"><span class="pre">b'...'</span></code>) 을 사용하는데, 종종 <code class="docutils literal"><span class="pre">bytes([46,</span> <span class="pre">46,</span> <span class="pre">46])</span></code> 보다 유용하기 때문입니다. <code class="docutils literal"><span class="pre">list(b)</span></code> 를 사용하면 바이트열 객체를 항상 정수 리스트로 변환 할 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">파이썬 2.x 사용자에게: 파이썬 2.x 시리즈에서는 8-비트 문자열(2.x가 내장 바이너리 데이터 형에 제공하는 가장 가까운 것)과 유니 코드 문자열 간의 다양한 묵시적 변환이 허용되었습니다. 이는 파이썬이 원래 8-비트 텍스트 만 지원했으며 유니 코드 텍스트는 나중에 추가 된 사실을 반영하는 하위 호환성 해결책입니다. 파이썬 3.x 에서, 이러한 묵시적 변환은 사라졌습니다 - 8-비트 바이너리 데이터와 유니 코드 텍스트 간의 변환은 반드시 명시적이어야하며 바이트열과 문자열 객체는 항상 다르다고 비교됩니다.</p>
</div>
</div>
<div class="section" id="bytearray-objects">
<span id="typebytearray"></span><h3>4.8.2. 바이트 배열 객체<a class="headerlink" href="#bytearray-objects" title="제목 주소">¶</a></h3>
<p id="index-38"><a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 객체는 <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체의 가변형입니다.</p>
<dl class="class">
<dt id="bytearray">
<em class="property">class </em><code class="descname">bytearray</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray" title="정의 주소">¶</a></dt>
<dd><p>바이트 배열 객체에 대한 전용 리터럴 문법은 없으며 항상 생성자를 호출하여 만듭니다:</p>
<ul class="simple">
<li>빈 인스턴스 만들기: <code class="docutils literal"><span class="pre">bytearray()</span></code></li>
<li>주어진 길이의 0 으로 채워진 인스턴스 만들기: <code class="docutils literal"><span class="pre">bytearray(10)</span></code></li>
<li>정수의 이터러블로 부터: <code class="docutils literal"><span class="pre">bytearray(range(20))</span></code></li>
<li>버퍼 프로토콜을 통해 기존 바이너리 데이터 복사: <code class="docutils literal"><span class="pre">bytearray(b'Hi!')</span></code></li>
</ul>
<p>바이트 배열 객체는 가변이기 때문에, <a class="reference internal" href="#bytes-methods"><span class="std std-ref">바이트열 과 바이트 배열 연산</span></a> 에 설명되어있는 공통 바이트열과 바이트 배열 연산에 더해, <a class="reference internal" href="#typesseq-mutable"><span class="std std-ref">가변</span></a> 시퀀스 연산도 지원합니다.</p>
<p>내장 <a class="reference internal" href="functions.html#func-bytearray"><span class="std std-ref">bytearray</span></a> 도 참조하세요.</p>
<p>2 개의 16 진수는 정확히 하나의 바이트에 대응하기 때문에 16 진수는 바이너리 데이터를 설명하는 데 일반적으로 사용되는 형식입니다. 따라서, 바이트 배열 형은 그 형식의 데이터를 읽는 추가의 클래스 메서드를 갖습니다:</p>
<dl class="classmethod">
<dt id="bytearray.fromhex">
<em class="property">classmethod </em><code class="descname">fromhex</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.fromhex" title="정의 주소">¶</a></dt>
<dd><p>This <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> class method returns bytearray object, decoding
the given string object.  The string must contain two hexadecimal digits
per byte, with ASCII whitespace being ignored.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;2Ef0 F1f2  &#39;</span><span class="p">)</span>
<span class="go">bytearray(b&#39;.\xf0\xf1\xf2&#39;)</span>
</pre></div>
</div>
</dd></dl>

<p>바이트 배열 객체를 16 진수 표현으로 변환하기위한 역 변환 함수가 있습니다.</p>
<dl class="method">
<dt id="bytearray.hex">
<code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.hex" title="정의 주소">¶</a></dt>
<dd><p>인스턴스의 각 바이트마다 2 자리수의 16 진수로 표현한 문자열 객체를 돌려줍니다.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xf0\xf1\xf2</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;f0f1f2&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<p>바이트 배열 객체는 정수의 시퀀스(리스트와 유사)이기 때문에, 바이트 배열 객체 <em>b</em> 에 대해서, <code class="docutils literal"><span class="pre">b[0]</span></code> 는 정수가됩니다. 반면, <code class="docutils literal"><span class="pre">b[0:1]</span></code> 는 길이 1 인 바이트 배열 객체가 됩니다. (이것은 인덱싱과 슬라이싱 모두 길이 1인 문자열을 생성하는 텍스트 문자열과 대조됩니다)</p>
<p>바이트 배열 객체의 표현은 바이트열 리터럴 형식 (<code class="docutils literal"><span class="pre">bytearray(b'...')</span></code>) 을 사용하는데, 종종 <code class="docutils literal"><span class="pre">bytearray([46,</span> <span class="pre">46,</span> <span class="pre">46])</span></code> 보다 유용하기 때문입니다. <code class="docutils literal"><span class="pre">list(b)</span></code> 를 사용하면 바이트 배열 객체를 항상 정수 리스트로 변환 할 수 있습니다.</p>
</div>
<div class="section" id="bytes-and-bytearray-operations">
<span id="bytes-methods"></span><h3>4.8.3. 바이트열 과 바이트 배열 연산<a class="headerlink" href="#bytes-and-bytearray-operations" title="제목 주소">¶</a></h3>
<p id="index-39">바이트열와 바이트 배열 객체는 <a class="reference internal" href="#typesseq-common"><span class="std std-ref">공통</span></a> 시퀀스 연산을 지원합니다. 이 것들은 같은 형의 피연산자뿐만 아니라 모든 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 와 상호 운용됩니다. 이러한 유연성으로 인해, 오류없이 작업을 자유롭게 혼합 할 수 있습니다. 그러나, 결과의 반환 형은 피연산자의 순서에 따라 달라질 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p>바이트열 및 바이트 배열 객체의 메서드는 인자로 문자열을 받아들이지 않습니다, 문자열의 메서드가 바이트열을 인자로 허용하지 않는 것과 마찬가지 입니다. 예를 들어, 다음과 같이 작성해야합니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;abc&quot;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>그리고:</p>
<div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;abc&quot;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>일부 바이트열 및 바이트 배열 연산은 ASCII 호환 바이너리 형식을 가정하므로, 임의의 바이너리 데이터로 작업 할 때는 피해야합니다. 이러한 제한 사항은 아래에서 다룹니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이러한 ASCII 기반 연산을 사용하여 ASCII 기반 형식으로 저장되지 않은 바이너리 데이터를 조작하면 데이터가 손상 될 수 있습니다.</p>
</div>
<p>바이트열 및 바이트 배열 객체에 대한 다음 메서드는 임의의 바이너리 데이터와 함께 사용할 수 있습니다.</p>
<dl class="method">
<dt id="bytes.count">
<code class="descclassname">bytes.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.count" title="정의 주소">¶</a></dt>
<dt id="bytearray.count">
<code class="descclassname">bytearray.</code><code class="descname">count</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.count" title="정의 주소">¶</a></dt>
<dd><p>범위 [<em>start</em>, <em>end</em>] 에서 서브 시퀀스 <em>sub</em> 가 중첩되지 않고 등장하는 회수를 돌려줍니다. 선택적 인자 <em>start</em> 와 <em>end</em> 는 슬라이스 표기법으로 해석됩니다.</p>
<p>검색 할 서브 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 또는 0에서 255 사이의 정수일 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>서브 시퀀스로 0에서 255 사이의 정수도 허용합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.decode">
<code class="descclassname">bytes.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>encoding=&quot;utf-8&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.decode" title="정의 주소">¶</a></dt>
<dt id="bytearray.decode">
<code class="descclassname">bytearray.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>encoding=&quot;utf-8&quot;</em>, <em>errors=&quot;strict&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.decode" title="정의 주소">¶</a></dt>
<dd><p>주어진 바이트열로부터 디코딩된 문자열을 돌려줍니다. 기본 인코딩은 <code class="docutils literal"><span class="pre">'utf-8'</span></code> 입니다. <em>errors</em> 는 다른 오류 처리 방식을 설정하기 위해 제공 될 수 있습니다. <em>errors</em> 의 기본값은 <code class="docutils literal"><span class="pre">'strict'</span></code> 인데, 인코딩 오류가 있으면 <a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> 를 일으키라는 뜻입니다. 다른 가능한 값은 <code class="docutils literal"><span class="pre">'ignore'</span></code>, <code class="docutils literal"><span class="pre">'replace'</span></code> 와 <a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">codecs.register_error()</span></code></a> 를 통해 등록 된 다른 이름들입니다. <a class="reference internal" href="codecs.html#error-handlers"><span class="std std-ref">Error Handlers</span></a> 를 보세요. 가능한 인코딩의 목록을 보려면 <a class="reference internal" href="codecs.html#standard-encodings"><span class="std std-ref">Standard Encodings</span></a> 섹션을 참조하십시오.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><em>encoding</em> 인자를 <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 에 전달하면 임시 바이트열이나 바이트 배열 객체를 만들 필요없이 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 를 직접 디코딩 할 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.1으로 변경: </span>키워드 인자 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.endswith">
<code class="descclassname">bytes.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.endswith" title="정의 주소">¶</a></dt>
<dt id="bytearray.endswith">
<code class="descclassname">bytearray.</code><code class="descname">endswith</code><span class="sig-paren">(</span><em>suffix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.endswith" title="정의 주소">¶</a></dt>
<dd><p>바이너리 데이터가 지정된 <em>suffix</em> 로 끝나면 <code class="docutils literal"><span class="pre">True</span></code> 를 돌려주고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code> 를 돌려줍니다. <em>suffix</em> 는 찾고자 하는 접미사들의 튜플이 될 수도 있습니다. 선택적 <em>start</em> 가 제공되면 그 위치에서 검사를 시작합니다. 선택적 <em>end</em> 를 사용하면 해당 위치에서 비교를 중단합니다.</p>
<p>검색 할 접미사(들)는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.find">
<code class="descclassname">bytes.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.find" title="정의 주소">¶</a></dt>
<dt id="bytearray.find">
<code class="descclassname">bytearray.</code><code class="descname">find</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.find" title="정의 주소">¶</a></dt>
<dd><p>서브 시퀀스 <em>sub</em> 가 슬라이스 <code class="docutils literal"><span class="pre">s[start:end]</span></code> 내에 등장하는 가장 작은 데이터의 인덱스를 돌려줍니다. 선택적 인자 <em>start</em> 와 <em>end</em> 는 슬라이스 표기법으로 해석됩니다. <em>sub</em> 가 없으면 <code class="docutils literal"><span class="pre">-1</span></code> 을 돌려줍니다.</p>
<p>검색 할 서브 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 또는 0에서 255 사이의 정수일 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p><a class="reference internal" href="#bytes.find" title="bytes.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a> 메서드는 <em>sub</em> 의 위치를 ​​알아야 할 경우에만 사용해야합니다. <em>sub</em> 가 서브 시퀀스인지 여부를 확인하려면 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> 연산자를 사용하십시오:</p>
<div class="last highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Py&#39;</span> <span class="ow">in</span> <span class="sa">b</span><span class="s1">&#39;Python&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>서브 시퀀스로 0에서 255 사이의 정수도 허용합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.index">
<code class="descclassname">bytes.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.index" title="정의 주소">¶</a></dt>
<dt id="bytearray.index">
<code class="descclassname">bytearray.</code><code class="descname">index</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.index" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#bytes.find" title="bytes.find"><code class="xref py py-meth docutils literal"><span class="pre">find()</span></code></a> 과 비슷하지만, 서브 시퀀스를 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
<p>검색 할 서브 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 또는 0에서 255 사이의 정수일 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>서브 시퀀스로 0에서 255 사이의 정수도 허용합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.join">
<code class="descclassname">bytes.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.join" title="정의 주소">¶</a></dt>
<dt id="bytearray.join">
<code class="descclassname">bytearray.</code><code class="descname">join</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.join" title="정의 주소">¶</a></dt>
<dd><p><em>iterable</em> 의 바이너리 데이터 시퀀스들을 이어붙이기한 바이트열 또는 바이트 배열 객체를 돌려줍니다. <em>iterable</em> 에 <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 객체나 기타 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 가 아닌 값이 있으면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 를 일으킵니다. 요소들 사이의 구분자는 이 메서드를 제공하는 바이트열 이나 바이트 배열 객체입니다.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="bytes.maketrans">
<em class="property">static </em><code class="descclassname">bytes.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>from</em>, <em>to</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.maketrans" title="정의 주소">¶</a></dt>
<dt id="bytearray.maketrans">
<em class="property">static </em><code class="descclassname">bytearray.</code><code class="descname">maketrans</code><span class="sig-paren">(</span><em>from</em>, <em>to</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.maketrans" title="정의 주소">¶</a></dt>
<dd><p>이 정적 메서드는 <a class="reference internal" href="#bytes.translate" title="bytes.translate"><code class="xref py py-meth docutils literal"><span class="pre">bytes.translate()</span></code></a> 에 사용할 수있는 변환표를 돌려주는데, <em>from</em> 에 있는 문자를 <em>to</em> 의 같은 위치에 있는 문자로 매핑합니다; <em>from</em> 과 <em>to</em> 는 모두 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 이어야하고 길이가 같아야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.partition">
<code class="descclassname">bytes.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.partition" title="정의 주소">¶</a></dt>
<dt id="bytearray.partition">
<code class="descclassname">bytearray.</code><code class="descname">partition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.partition" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 가 처음 나타나는 위치에서 시퀀스를 분할하고, 구분자 앞에있는 부분, 구분자 자체, 구분자 뒤에 오는 부분으로 구성된 3-튜플을 돌려줍니다. 구분자가 발견되지 않으면, 원래 시퀀스의 복사본과 그 뒤를 따르는 두 개의 빈 바이트열 또는 바이트 배열 객체로 구성된 3-튜플을 돌려줍니다.</p>
<p>검색 할 구분자는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.replace">
<code class="descclassname">bytes.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.replace" title="정의 주소">¶</a></dt>
<dt id="bytearray.replace">
<code class="descclassname">bytearray.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="optional">[</span>, <em>count</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.replace" title="정의 주소">¶</a></dt>
<dd><p>모든 서브 시퀀스 <em>old</em> 가 <em>new</em> 로 치환 된 시퀀스의 복사본을 돌려줍니다. 선택적 인자 <em>count</em> 가 주어지면, 앞의 <em>count</em> 개만 치환됩니다.</p>
<p>검색할 서브 시퀀스와 그 대체물은 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rfind">
<code class="descclassname">bytes.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rfind" title="정의 주소">¶</a></dt>
<dt id="bytearray.rfind">
<code class="descclassname">bytearray.</code><code class="descname">rfind</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rfind" title="정의 주소">¶</a></dt>
<dd><p>서브 시퀀스 <em>sub</em> 가 <code class="docutils literal"><span class="pre">s[start:end]</span></code> 내에 등장하는 가장 큰 시퀀스의의 인덱스를 돌려줍니다. 선택적 인자 <em>start</em> 와 <em>end</em> 는 슬라이스 표기법으로 해석됩니다. 실패하면 <code class="docutils literal"><span class="pre">-1</span></code> 을 돌려줍니다.</p>
<p>검색 할 서브 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 또는 0에서 255 사이의 정수일 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>서브 시퀀스로 0에서 255 사이의 정수도 허용합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rindex">
<code class="descclassname">bytes.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rindex" title="정의 주소">¶</a></dt>
<dt id="bytearray.rindex">
<code class="descclassname">bytearray.</code><code class="descname">rindex</code><span class="sig-paren">(</span><em>sub</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rindex" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#bytes.rfind" title="bytes.rfind"><code class="xref py py-meth docutils literal"><span class="pre">rfind()</span></code></a> 와 비슷하지만, 서브 시퀀스 <em>sub</em> 를 찾을 수 없는 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 를 일으킵니다.</p>
<p>검색 할 서브 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 또는 0에서 255 사이의 정수일 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>서브 시퀀스로 0에서 255 사이의 정수도 허용합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rpartition">
<code class="descclassname">bytes.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rpartition" title="정의 주소">¶</a></dt>
<dt id="bytearray.rpartition">
<code class="descclassname">bytearray.</code><code class="descname">rpartition</code><span class="sig-paren">(</span><em>sep</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rpartition" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 가 마지막으로 나타나는 위치에서 시퀀스를 분할하고, 구분자 앞에있는 부분, 구분자 자체, 구분자 뒤에 오는 부분으로 구성된 3-튜플을 돌려줍니다. 구분자가 발견되지 않으면, 두 개의 빈 바이트열 또는 바이트 배열 객체와 그 뒤를 따르는 원래 시퀀스의 복사본으로 구성된 3-튜플을 돌려줍니다.</p>
<p>검색 할 구분자는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.startswith">
<code class="descclassname">bytes.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.startswith" title="정의 주소">¶</a></dt>
<dt id="bytearray.startswith">
<code class="descclassname">bytearray.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>prefix</em><span class="optional">[</span>, <em>start</em><span class="optional">[</span>, <em>end</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.startswith" title="정의 주소">¶</a></dt>
<dd><p>바이너리 데이터가 지정된 <em>prefix</em> 로 시작하면 <code class="docutils literal"><span class="pre">True</span></code> 를 돌려주고, 그렇지 않으면 <code class="docutils literal"><span class="pre">False</span></code> 를 돌려줍니다. <em>prefix</em> 는 찾고자 하는 접두사들의 튜플이 될 수도 있습니다. 선택적 <em>start</em> 가 제공되면 그 위치에서 검사를 시작합니다. 선택적 <em>end</em> 를 사용하면 해당 위치에서 비교를 중단합니다.</p>
<p>검색 할 접두사(들)은 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.translate">
<code class="descclassname">bytes.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em>, <em>delete=b''</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.translate" title="정의 주소">¶</a></dt>
<dt id="bytearray.translate">
<code class="descclassname">bytearray.</code><code class="descname">translate</code><span class="sig-paren">(</span><em>table</em>, <em>delete=b''</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.translate" title="정의 주소">¶</a></dt>
<dd><p>생략 가능한 인자 <em>delete</em> 의 모든 바이트들을 제거하고, 나머지 바이트들을 주어진 변환표로 매핑한 바이트열이나 바이트 배열 객체의 복사본을 돌려준비다. table 은 길이 256 인 바이트열 객체이어야 합니다.</p>
<p><a class="reference internal" href="#bytes.maketrans" title="bytes.maketrans"><code class="xref py py-func docutils literal"><span class="pre">bytes.maketrans()</span></code></a> 메서드를 사용하여 변환표를 만들 수 있습니다.</p>
<p>문자를 지우기만 하는 변환에는 <em>table</em> 인자를 <code class="docutils literal"><span class="pre">None</span></code> 으로 설정하십시오:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;read this short text&#39;</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;aeiou&#39;</span><span class="p">)</span>
<span class="go">b&#39;rd ths shrt txt&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>이제 <em>delete</em> 는 키워드 인자로 지원됩니다.</p>
</div>
</dd></dl>

<p>바이트열 및 바이트 배열 객체에 대한 다음 메서드는 ASCII 호환 바이너리 형식의 사용을 가정하는 기본 동작을 갖지만, 적절한 인자를 전달하여 임의의 바이너리 데이터와 함께 사용할 수 있습니다. 이 섹션의 바이트 배열 메서드는 모두 제자리에서 작동하지 않고 대신 새로운 객체를 생성함에 주의하십시오.</p>
<dl class="method">
<dt id="bytes.center">
<code class="descclassname">bytes.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.center" title="정의 주소">¶</a></dt>
<dt id="bytearray.center">
<code class="descclassname">bytearray.</code><code class="descname">center</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.center" title="정의 주소">¶</a></dt>
<dd><p>길이 <em>width</em> 인 시퀀스의 가운데에 정렬한 객체의 복사본을 돌려줍니다. 지정된 <em>fillbyte</em> (기본값은 ASCII 스페이스)를 사용하여 채워넣기합니다. <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체의 경우, <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 시퀀스가 반환됩니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.ljust">
<code class="descclassname">bytes.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.ljust" title="정의 주소">¶</a></dt>
<dt id="bytearray.ljust">
<code class="descclassname">bytearray.</code><code class="descname">ljust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.ljust" title="정의 주소">¶</a></dt>
<dd><p>왼쪽으로 정렬 된 객체의 복사본을 길이 <em>width</em> 인 시퀀스로 돌려줍니다. 지정된 <em>fillbyte</em> (기본값은 ASCII 스페이스)을 사용하여 채워넣기합니다. <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체의 경우, <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 시퀀스가 반환됩니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.lstrip">
<code class="descclassname">bytes.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.lstrip" title="정의 주소">¶</a></dt>
<dt id="bytearray.lstrip">
<code class="descclassname">bytearray.</code><code class="descname">lstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.lstrip" title="정의 주소">¶</a></dt>
<dd><p>선행 바이트가 제거 된 시퀀스의 복사본을 돌려줍니다. <em>chars</em> 인자는 제거 할 바이트 집합을 지정하는 바이너리 시퀀스입니다 - 이름은 이 메서드가 보통 ASCII 문자와 사용된다는 사실을 반영합니다. 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이라면, <em>chars</em> 인자의 기본값은 ASCII 공백을 제거하도록합니다. <em>chars</em> 인자는 접두사가 아닙니다; 모든 값 조합이 제거됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">b&#39;spacious   &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">b&#39;example.com&#39;</span>
</pre></div>
</div>
<p>제거 할 바이트 값의 바이너리 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rjust">
<code class="descclassname">bytes.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rjust" title="정의 주소">¶</a></dt>
<dt id="bytearray.rjust">
<code class="descclassname">bytearray.</code><code class="descname">rjust</code><span class="sig-paren">(</span><em>width</em><span class="optional">[</span>, <em>fillbyte</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rjust" title="정의 주소">¶</a></dt>
<dd><p>오른쪽으로 정렬 된 객체의 복사본을 길이 <em>width</em> 인 시퀀스로 돌려줍니다. 지정된 <em>fillbyte</em> (기본값은 ASCII 스페이스)를 사용하여 채워넣기합니다. <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 객체의 경우, <em>width</em> 가 <code class="docutils literal"><span class="pre">len(s)</span></code> 보다 작거나 같은 경우 원래 시퀀스가 반환됩니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.rsplit">
<code class="descclassname">bytes.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rsplit" title="정의 주소">¶</a></dt>
<dt id="bytearray.rsplit">
<code class="descclassname">bytearray.</code><code class="descname">rsplit</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rsplit" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 을 구분자 시퀀스로 사용하여 바이너리 시퀀스를 같은 형의 서브 시퀀스로 분할합니다. <em>maxsplit</em> 이 주어지면 가장 오른쪽에서 최대 <em>maxsplit</em> 번의 분할이 수행됩니다. <em>sep</em> 이 지정되지 않거나 <code class="docutils literal"><span class="pre">None</span></code> 이면, ASCII 공백 문자만으로 이루어진 모든 서브 시퀀스는 구분자입니다. 오른쪽에서 분리하는 것을 제외하면, <a class="reference internal" href="#bytearray.rsplit" title="bytearray.rsplit"><code class="xref py py-meth docutils literal"><span class="pre">rsplit()</span></code></a> 는 아래에서 자세히 설명될 <a class="reference internal" href="#bytearray.split" title="bytearray.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> 처럼 동작합니다.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.rstrip">
<code class="descclassname">bytes.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rstrip" title="정의 주소">¶</a></dt>
<dt id="bytearray.rstrip">
<code class="descclassname">bytearray.</code><code class="descname">rstrip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rstrip" title="정의 주소">¶</a></dt>
<dd><p>지정된 후행 바이트가 제거 된 시퀀스의 복사본을 돌려줍니다. <em>chars</em> 인자는 제거 할 바이트 집합을 지정하는 바이너리 시퀀스입니다 - 이름은 이 메서드가 보통 ASCII 문자와 사용된다는 사실을 반영합니다. 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이라면, <em>chars</em> 인자의 기본값은 ASCII 공백을 제거하도록합니다. <em>chars</em> 인자는 접미사가 아닙니다; 모든 값 조합이 제거됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">b&#39;   spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;mississippi&#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ipz&#39;</span><span class="p">)</span>
<span class="go">b&#39;mississ&#39;</span>
</pre></div>
</div>
<p>제거 할 바이트 값의 바이너리 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.split">
<code class="descclassname">bytes.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.split" title="정의 주소">¶</a></dt>
<dt id="bytearray.split">
<code class="descclassname">bytearray.</code><code class="descname">split</code><span class="sig-paren">(</span><em>sep=None</em>, <em>maxsplit=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.split" title="정의 주소">¶</a></dt>
<dd><p><em>sep</em> 를 구분자 시퀀스로 사용하여 바이너리 시퀀스를 같은 형의 서브 시퀀스로 분할합니다. <em>maxsplit</em> 이 지정되고 음수가 아닌 경우, 최대 <em>maxsplit</em> 분할이 수행됩니다 (따라서, 리스트는 최대 <code class="docutils literal"><span class="pre">maxsplit+1</span></code> 개의 요소를 가지게됩니다). <em>maxsplit</em> 이 지정되지 않았거나 <code class="docutils literal"><span class="pre">-1</span></code> 이라면 분할 수에 제한이 없습니다 (가능한 모든 분할이 만들어집니다).</p>
<p><em>sep</em> 이 주어지면, 연속 된 구분자는 묶이지 않고 빈 서브시퀀스를 구분하는 것으로 간주됩니다 (예를 들어, <code class="docutils literal"><span class="pre">b'1,,2'.split(b',')</span></code> 는 <code class="docutils literal"><span class="pre">[b'1',</span> <span class="pre">b'',</span> <span class="pre">b'2']</span></code> 를 돌려줍니다). <em>sep</em> 인자는 멀티바이트 시퀀스로 구성 될 수 있습니다 (예를 들어, <code class="docutils literal"><span class="pre">b'1&lt;&gt;2&lt;&gt;3'.split(b'&lt;&gt;')</span></code> 는 <code class="docutils literal"><span class="pre">[b'1',</span> <span class="pre">b'2',</span> <span class="pre">b'3']</span></code> 를 돌려줍니다). 지정된 구분자로 빈 시퀀스를 분할하면 분할하는 객체의 형에 따라 <code class="docutils literal"><span class="pre">[b'']</span></code> 나 <code class="docutils literal"><span class="pre">[bytearray(b'')]</span></code> 를 돌려줍니다. <em>sep</em> 인자는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2,3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,,3,&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;&#39;, b&#39;3&#39;, b&#39;&#39;]</span>
</pre></div>
</div>
<p><em>sep</em> 이 지정되지 않거나 <code class="docutils literal"><span class="pre">None</span></code> 이면, 다른 분할 알고리즘이 적용됩니다: 연속 된 ASCII 공백 문자는 단일한 구분자로 간주되고, 시퀀스가 선행이나 후행 공백을 포함해도 결과는 시작과 끝에 빈 시퀀스를 포함하지 않습니다. 결과적으로, 빈 시퀀스나나 ASCII 공백만으로 구성된 시퀀스를 <code class="docutils literal"><span class="pre">None</span></code> 구분자로 분할하면 <code class="docutils literal"><span class="pre">[]</span></code> 를 돌려줍니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2 3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   1   2   3   &#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.strip">
<code class="descclassname">bytes.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.strip" title="정의 주소">¶</a></dt>
<dt id="bytearray.strip">
<code class="descclassname">bytearray.</code><code class="descname">strip</code><span class="sig-paren">(</span><span class="optional">[</span><em>chars</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.strip" title="정의 주소">¶</a></dt>
<dd><p>선행과 후행 바이트가 제거 된 시퀀스의 복사본을 돌려줍니다. <em>chars</em> 인자는 제거 할 바이트 집합을 지정하는 바이너리 시퀀스입니다 - 이름은 이 메서드가 보통 ASCII 문자와 사용된다는 사실을 반영합니다. 생략되거나 <code class="docutils literal"><span class="pre">None</span></code> 이라면, <em>chars</em> 인자의 기본값은 ASCII 공백을 제거하도록합니다. <em>chars</em> 인자는 접두사나 접미사가 아닙니다; 모든 값 조합이 제거됩니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">b&#39;spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">b&#39;example&#39;</span>
</pre></div>
</div>
<p>제거 할 바이트 값의 바이너리 시퀀스는 임의의 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 일 수 있습니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<p>바이트열 및 바이트 배열 객체에 대한 다음 메서드는 ASCII 호환 바이너리 형식의 사용을 가정하며 임의의 바이너리 데이터에 적용하면 안됩니다. 이 섹션의 바이트 배열 메서드는 모두 제자리에서 작동하지 <em>않고</em> 대신 새로운 객체를 생성합니다.</p>
<dl class="method">
<dt id="bytes.capitalize">
<code class="descclassname">bytes.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.capitalize" title="정의 주소">¶</a></dt>
<dt id="bytearray.capitalize">
<code class="descclassname">bytearray.</code><code class="descname">capitalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.capitalize" title="정의 주소">¶</a></dt>
<dd><p>Return a copy of the sequence with each byte interpreted as an ASCII
character, and the first byte capitalized and the rest lowercased.
Non-ASCII byte values are passed through unchanged.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.expandtabs">
<code class="descclassname">bytes.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.expandtabs" title="정의 주소">¶</a></dt>
<dt id="bytearray.expandtabs">
<code class="descclassname">bytearray.</code><code class="descname">expandtabs</code><span class="sig-paren">(</span><em>tabsize=8</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.expandtabs" title="정의 주소">¶</a></dt>
<dd><p>Return a copy of the sequence where all ASCII tab characters are replaced
by one or more ASCII spaces, depending on the current column and the given
tab size.  Tab positions occur every <em>tabsize</em> bytes (default is 8,
giving tab positions at columns 0, 8, 16 and so on).  To expand the
sequence, the current column is set to zero and the sequence is examined
byte by byte.  If the byte is an ASCII tab character (<code class="docutils literal"><span class="pre">b'\t'</span></code>), one or
more space characters are inserted in the result until the current column
is equal to the next tab position. (The tab character itself is not
copied.)  If the current byte is an ASCII newline (<code class="docutils literal"><span class="pre">b'\n'</span></code>) or
carriage return (<code class="docutils literal"><span class="pre">b'\r'</span></code>), it is copied and the current column is reset
to zero.  Any other byte value is copied unchanged and the current column
is incremented by one regardless of how the byte value is represented when
printed:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
<span class="go">b&#39;01      012     0123    01234&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">b&#39;01  012 0123    01234&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isalnum">
<code class="descclassname">bytes.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isalnum" title="정의 주소">¶</a></dt>
<dt id="bytearray.isalnum">
<code class="descclassname">bytearray.</code><code class="descname">isalnum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isalnum" title="정의 주소">¶</a></dt>
<dd><p>Return true if all bytes in the sequence are alphabetical ASCII characters
or ASCII decimal digits and the sequence is not empty, false otherwise.
Alphabetic ASCII characters are those byte values in the sequence
<code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>. ASCII decimal
digits are those byte values in the sequence <code class="docutils literal"><span class="pre">b'0123456789'</span></code>.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc1&#39;</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABC abc1&#39;</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isalpha">
<code class="descclassname">bytes.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isalpha" title="정의 주소">¶</a></dt>
<dt id="bytearray.isalpha">
<code class="descclassname">bytearray.</code><code class="descname">isalpha</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isalpha" title="정의 주소">¶</a></dt>
<dd><p>Return true if all bytes in the sequence are alphabetic ASCII characters
and the sequence is not empty, false otherwise.  Alphabetic ASCII
characters are those byte values in the sequence
<code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc&#39;</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc1&#39;</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isdigit">
<code class="descclassname">bytes.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isdigit" title="정의 주소">¶</a></dt>
<dt id="bytearray.isdigit">
<code class="descclassname">bytearray.</code><code class="descname">isdigit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isdigit" title="정의 주소">¶</a></dt>
<dd><p>Return true if all bytes in the sequence are ASCII decimal digits
and the sequence is not empty, false otherwise. ASCII decimal digits are
those byte values in the sequence <code class="docutils literal"><span class="pre">b'0123456789'</span></code>.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1234&#39;</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1.23&#39;</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.islower">
<code class="descclassname">bytes.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.islower" title="정의 주소">¶</a></dt>
<dt id="bytearray.islower">
<code class="descclassname">bytearray.</code><code class="descname">islower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.islower" title="정의 주소">¶</a></dt>
<dd><p>Return true if there is at least one lowercase ASCII character
in the sequence and no uppercase ASCII characters, false otherwise.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;hello world&#39;</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Lowercase ASCII characters are those byte values in the sequence
<code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Uppercase ASCII characters
are those byte values in the sequence <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.isspace">
<code class="descclassname">bytes.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isspace" title="정의 주소">¶</a></dt>
<dt id="bytearray.isspace">
<code class="descclassname">bytearray.</code><code class="descname">isspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isspace" title="정의 주소">¶</a></dt>
<dd><p>Return true if all bytes in the sequence are ASCII whitespace and the
sequence is not empty, false otherwise.  ASCII whitespace characters are
those byte values in the sequence <code class="docutils literal"><span class="pre">b'</span> <span class="pre">\t\n\r\x0b\f'</span></code> (space, tab, newline,
carriage return, vertical tab, form feed).</p>
</dd></dl>

<dl class="method">
<dt id="bytes.istitle">
<code class="descclassname">bytes.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.istitle" title="정의 주소">¶</a></dt>
<dt id="bytearray.istitle">
<code class="descclassname">bytearray.</code><code class="descname">istitle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.istitle" title="정의 주소">¶</a></dt>
<dd><p>Return true if the sequence is ASCII titlecase and the sequence is not
empty, false otherwise. See <a class="reference internal" href="#bytes.title" title="bytes.title"><code class="xref py py-meth docutils literal"><span class="pre">bytes.title()</span></code></a> for more details on the
definition of &quot;titlecase&quot;.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">istitle</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">istitle</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.isupper">
<code class="descclassname">bytes.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isupper" title="정의 주소">¶</a></dt>
<dt id="bytearray.isupper">
<code class="descclassname">bytearray.</code><code class="descname">isupper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isupper" title="정의 주소">¶</a></dt>
<dd><p>Return true if there is at least one uppercase alphabetic ASCII character
in the sequence and no lowercase ASCII characters, false otherwise.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;HELLO WORLD&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Lowercase ASCII characters are those byte values in the sequence
<code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Uppercase ASCII characters
are those byte values in the sequence <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="bytes.lower">
<code class="descclassname">bytes.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.lower" title="정의 주소">¶</a></dt>
<dt id="bytearray.lower">
<code class="descclassname">bytearray.</code><code class="descname">lower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.lower" title="정의 주소">¶</a></dt>
<dd><p>Return a copy of the sequence with all the uppercase ASCII characters
converted to their corresponding lowercase counterpart.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="go">b&#39;hello world&#39;</span>
</pre></div>
</div>
<p>Lowercase ASCII characters are those byte values in the sequence
<code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Uppercase ASCII characters
are those byte values in the sequence <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<span class="target" id="index-40"></span><dl class="method">
<dt id="bytes.splitlines">
<code class="descclassname">bytes.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><em>keepends=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.splitlines" title="정의 주소">¶</a></dt>
<dt id="bytearray.splitlines">
<code class="descclassname">bytearray.</code><code class="descname">splitlines</code><span class="sig-paren">(</span><em>keepends=False</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.splitlines" title="정의 주소">¶</a></dt>
<dd><p>Return a list of the lines in the binary sequence, breaking at ASCII
line boundaries. This method uses the <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> approach
to splitting lines. Line breaks are not included in the resulting list
unless <em>keepends</em> is given and true.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[b&#39;ab c&#39;, b&#39;&#39;, b&#39;de fg&#39;, b&#39;kl&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[b&#39;ab c\n&#39;, b&#39;\n&#39;, b&#39;de fg\r&#39;, b&#39;kl\r\n&#39;]</span>
</pre></div>
</div>
<p>Unlike <a class="reference internal" href="#bytes.split" title="bytes.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> when a delimiter string <em>sep</em> is given, this
method returns an empty list for the empty string, and a terminal line
break does not result in an extra line:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">),</span> <span class="sa">b</span><span class="s2">&quot;Two lines</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">([b&#39;&#39;], [b&#39;Two lines&#39;, b&#39;&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">&quot;One line</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">([], [b&#39;One line&#39;])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.swapcase">
<code class="descclassname">bytes.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.swapcase" title="정의 주소">¶</a></dt>
<dt id="bytearray.swapcase">
<code class="descclassname">bytearray.</code><code class="descname">swapcase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.swapcase" title="정의 주소">¶</a></dt>
<dd><p>Return a copy of the sequence with all the lowercase ASCII characters
converted to their corresponding uppercase counterpart and vice-versa.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">swapcase</span><span class="p">()</span>
<span class="go">b&#39;hELLO wORLD&#39;</span>
</pre></div>
</div>
<p>Lowercase ASCII characters are those byte values in the sequence
<code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Uppercase ASCII characters
are those byte values in the sequence <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
<p>Unlike <a class="reference internal" href="#str.swapcase" title="str.swapcase"><code class="xref py py-func docutils literal"><span class="pre">str.swapcase()</span></code></a>, it is always the case that
<code class="docutils literal"><span class="pre">bin.swapcase().swapcase()</span> <span class="pre">==</span> <span class="pre">bin</span></code> for the binary versions. Case
conversions are symmetrical in ASCII, even though that is not generally
true for arbitrary Unicode code points.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.title">
<code class="descclassname">bytes.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.title" title="정의 주소">¶</a></dt>
<dt id="bytearray.title">
<code class="descclassname">bytearray.</code><code class="descname">title</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.title" title="정의 주소">¶</a></dt>
<dd><p>Return a titlecased version of the binary sequence where words start with
an uppercase ASCII character and the remaining characters are lowercase.
Uncased byte values are left unmodified.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">b&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>Lowercase ASCII characters are those byte values in the sequence
<code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Uppercase ASCII characters
are those byte values in the sequence <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.
All other byte values are uncased.</p>
<p>이 알고리즘은 단어를 글자들의 연속으로 보는 간단한 언어 독립적 정의를 사용합니다. 이 정의는 여러 상황에서 작동하지만, 축약과 소유의 아포스트로피가 단어 경계를 형성한다는 것을 의미하고, 이는 원하는 결과가 아닐 수도 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;they&#39;re bill&#39;s friends from the UK&quot;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">b&quot;They&#39;Re Bill&#39;S Friends From The Uk&quot;</span>
</pre></div>
</div>
<p>정규식을 사용하여 아포스트로피에 대한 해결 방법을 구성 할 수 있습니다:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">titlecase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">rb</span><span class="s2">&quot;[A-Za-z]+(&#39;[A-Za-z]+)?&quot;</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="k">lambda</span> <span class="n">mo</span><span class="p">:</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span>
<span class="gp">... </span>                             <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
<span class="gp">... </span>                  <span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">titlecase</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;they&#39;re bill&#39;s friends.&quot;</span><span class="p">)</span>
<span class="go">b&quot;They&#39;re Bill&#39;s Friends.&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.upper">
<code class="descclassname">bytes.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.upper" title="정의 주소">¶</a></dt>
<dt id="bytearray.upper">
<code class="descclassname">bytearray.</code><code class="descname">upper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.upper" title="정의 주소">¶</a></dt>
<dd><p>Return a copy of the sequence with all the lowercase ASCII characters
converted to their corresponding uppercase counterpart.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="go">b&#39;HELLO WORLD&#39;</span>
</pre></div>
</div>
<p>Lowercase ASCII characters are those byte values in the sequence
<code class="docutils literal"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Uppercase ASCII characters
are those byte values in the sequence <code class="docutils literal"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="bytes.zfill">
<code class="descclassname">bytes.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.zfill" title="정의 주소">¶</a></dt>
<dt id="bytearray.zfill">
<code class="descclassname">bytearray.</code><code class="descname">zfill</code><span class="sig-paren">(</span><em>width</em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.zfill" title="정의 주소">¶</a></dt>
<dd><p>Return a copy of the sequence left filled with ASCII <code class="docutils literal"><span class="pre">b'0'</span></code> digits to
make a sequence of length <em>width</em>. A leading sign prefix (<code class="docutils literal"><span class="pre">b'+'</span></code>/
<code class="docutils literal"><span class="pre">b'-'</span></code> is handled by inserting the padding <em>after</em> the sign character
rather than before. For <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> objects, the original sequence is
returned if <em>width</em> is less than or equal to <code class="docutils literal"><span class="pre">len(seq)</span></code>.</p>
<p>예를 들면:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">b&#39;00042&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;-42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">b&#39;-0042&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="printf-style-bytes-formatting">
<span id="bytes-formatting"></span><h3>4.8.4. <code class="docutils literal"><span class="pre">printf</span></code>-style Bytes Formatting<a class="headerlink" href="#printf-style-bytes-formatting" title="제목 주소">¶</a></h3>
<div class="admonition note" id="index-41">
<p class="first admonition-title">주석</p>
<p class="last">The formatting operations described here exhibit a variety of quirks that
lead to a number of common errors (such as failing to display tuples and
dictionaries correctly).  If the value being printed may be a tuple or
dictionary, wrap it in a tuple.</p>
</div>
<p>Bytes objects (<code class="docutils literal"><span class="pre">bytes</span></code>/<code class="docutils literal"><span class="pre">bytearray</span></code>) have one unique built-in operation:
the <code class="docutils literal"><span class="pre">%</span></code> operator (modulo).
This is also known as the bytes <em>formatting</em> or <em>interpolation</em> operator.
Given <code class="docutils literal"><span class="pre">format</span> <span class="pre">%</span> <span class="pre">values</span></code> (where <em>format</em> is a bytes object), <code class="docutils literal"><span class="pre">%</span></code> conversion
specifications in <em>format</em> are replaced with zero or more elements of <em>values</em>.
The effect is similar to using the <code class="xref c c-func docutils literal"><span class="pre">sprintf()</span></code> in the C language.</p>
<p>If <em>format</em> requires a single argument, <em>values</em> may be a single non-tuple
object. <a class="footnote-reference" href="#id16" id="id11">[5]</a>  Otherwise, <em>values</em> must be a tuple with exactly the number of
items specified by the format bytes object, or a single mapping object (for
example, a dictionary).</p>
<p>변환 명세는 두 개 이상의 문자를 포함하며 다음과 같은 구성 요소들을 포함하는데, 반드시 이 순서대로 나와야 합니다:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">'%'</span></code> 문자: 명세자의 시작을 나타냅니다.</li>
<li>매핑 키 (선택 사항): 괄호로 둘러싸인 문자들의 시퀀스로 구성됩니다 (예를 들어, <code class="docutils literal"><span class="pre">(somename)</span></code>).</li>
<li>변환 플래그 (선택 사항): 일부 변환 유형의 결과에 영향을 줍니다.</li>
<li>최소 필드 폭 (선택 사항): <code class="docutils literal"><span class="pre">'*'</span></code> (애스터리스크) 로 지정하면, 실제 폭은 <em>values</em> 튜플의 다음 요소에서 읽히고, 변환 할 객체는 최소 필드 폭과 선택적 정밀도 뒤에 옵니다.</li>
<li>정밀도 (선택 사항): <code class="docutils literal"><span class="pre">'.'</span></code> (점) 다음에 정밀도가 옵니다. <code class="docutils literal"><span class="pre">'*'</span></code> (애스터리스크) 로 지정하면, 실제 정밀도는 <em>values</em> 튜플의 다음 요소에서 읽히고, 변환 할 값은 정밀도 뒤에 옵니다.</li>
<li>길이 수정자 (선택 사항).</li>
<li>변환 유형.</li>
</ol>
<p>When the right argument is a dictionary (or other mapping type), then the
formats in the bytes object <em>must</em> include a parenthesised mapping key into that
dictionary inserted immediately after the <code class="docutils literal"><span class="pre">'%'</span></code> character. The mapping key
selects the value to be formatted from the mapping.  For example:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="si">%(language)s</span><span class="s1"> has </span><span class="si">%(number)03d</span><span class="s1"> quote types.&#39;</span> <span class="o">%</span>
<span class="gp">... </span>      <span class="p">{</span><span class="sa">b</span><span class="s1">&#39;language&#39;</span><span class="p">:</span> <span class="sa">b</span><span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;number&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">b&#39;Python has 002 quote types.&#39;</span>
</pre></div>
</div>
<p>이 경우 <code class="docutils literal"><span class="pre">*</span></code> 지정자를 사용할 수 없습니다 (순차적인 파라미터 목록이 필요하기 때문입니다).</p>
<p>변환 플래그 문자는 다음과 같습니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">플래그</th>
<th class="head">뜻</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'#'</span></code></td>
<td>값 변환에 &quot;대체 형식&quot; (아래에 정의되어있습니다) 을 사용합니다.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'0'</span></code></td>
<td>변환은 숫자 값의 경우 0으로 채웁니다.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'-'</span></code></td>
<td>변환 된 값은 왼쪽으로 정렬됩니다 (둘 다 주어지면 <code class="docutils literal"><span class="pre">'0'</span></code> 변환보다 우선 합니다).</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></code></td>
<td>(스페이스) 부호있는 변환에 의해 만들어진 양수 앞에 빈칸을 남겨둡니다 (음수면 빈 문자열입니다).</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'+'</span></code></td>
<td>부호 문자 (<code class="docutils literal"><span class="pre">'+'</span></code> or <code class="docutils literal"><span class="pre">'-'</span></code>) 가 변환 앞에 놓입니다 (<code class="docutils literal"><span class="pre">'</span> <span class="pre">'</span></code> 플래그에 우선합니다).</td>
</tr>
</tbody>
</table>
<p>길이 수정자 (<code class="docutils literal"><span class="pre">h</span></code>, <code class="docutils literal"><span class="pre">l</span></code>, <code class="docutils literal"><span class="pre">L</span></code>) 를 제공할 수는 있지만, 파이썬에서 필요하지 않기 때문에 무시됩니다 -- 예를 들어 <code class="docutils literal"><span class="pre">%ld</span></code> 는 <code class="docutils literal"><span class="pre">%d</span></code> 와 동일합니다.</p>
<p>변환 유형은 다음과 같습니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="74%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">변환</th>
<th class="head">뜻</th>
<th class="head">노트</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'d'</span></code></td>
<td>부호있는 정수 십진표기.</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'i'</span></code></td>
<td>부호있는 정수 십진표기.</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'o'</span></code></td>
<td>부호있는 8진수 값.</td>
<td>(1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'u'</span></code></td>
<td>쓸데없는 유형 -- <code class="docutils literal"><span class="pre">'d'</span></code> 와 동일합니다.</td>
<td>(8)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'x'</span></code></td>
<td>부호있는 16 진수 (소문자).</td>
<td>(2)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'X'</span></code></td>
<td>부호있는 16 진수 (대문자).</td>
<td>(2)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'e'</span></code></td>
<td>부동 소수점 지수 형식 (소문자).</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'E'</span></code></td>
<td>부동 소수점 지수 형식 (대문자).</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'f'</span></code></td>
<td>부동 소수점 십진수 형식.</td>
<td>(3)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'F'</span></code></td>
<td>부동 소수점 십진수 형식.</td>
<td>(3)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'g'</span></code></td>
<td>부동 소수점 형식. 지수가 -4보다 작거나 정밀도 보다 작지 않으면 소문자 지수형식을 사용하고, 그렇지 않으면 십진수 형식을 사용합니다.</td>
<td>(4)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'G'</span></code></td>
<td>부동 소수점 형식. 지수가 -4보다 작거나 정밀도 보다 작지 않으면 대문자 지수형식을 사용하고, 그렇지 않으면 십진수 형식을 사용합니다.</td>
<td>(4)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'c'</span></code></td>
<td>Single byte (accepts integer or single
byte objects).</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'b'</span></code></td>
<td>Bytes (any object that follows the
<a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">buffer protocol</span></a> or has
<a class="reference internal" href="../reference/datamodel.html#object.__bytes__" title="object.__bytes__"><code class="xref py py-meth docutils literal"><span class="pre">__bytes__()</span></code></a>).</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'s'</span></code></td>
<td><code class="docutils literal"><span class="pre">'s'</span></code> is an alias for <code class="docutils literal"><span class="pre">'b'</span></code> and should only
be used for Python2/3 code bases.</td>
<td>(6)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'a'</span></code></td>
<td>Bytes (converts any Python object using
<code class="docutils literal"><span class="pre">repr(obj).encode('ascii','backslashreplace)</span></code>).</td>
<td>(5)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'r'</span></code></td>
<td><code class="docutils literal"><span class="pre">'r'</span></code> is an alias for <code class="docutils literal"><span class="pre">'a'</span></code> and should only
be used for Python2/3 code bases.</td>
<td>(7)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'%'</span></code></td>
<td>인자는 변환되지 않고, 결과에 <code class="docutils literal"><span class="pre">'%'</span></code> 문자가 표시됩니다.</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>노트:</p>
<ol class="arabic">
<li><p class="first">대체 형식은 첫 번째 숫자 앞에 선행 8 진수 지정자 (<code class="docutils literal"><span class="pre">'0o'</span></code>)를  삽입합니다.</p>
</li>
<li><p class="first">대체 형식은 첫 번째 숫자 앞에 선행 <code class="docutils literal"><span class="pre">'0x'</span></code> 또는 <code class="docutils literal"><span class="pre">'0X'</span></code> (<code class="docutils literal"><span class="pre">'x'</span></code> 나 <code class="docutils literal"><span class="pre">'X'</span></code> 유형중 어느 것을 사용하느냐에 따라 달라집니다) 를 삽입합니다.</p>
</li>
<li><p class="first">대체 형식은 그 뒤에 숫자가 나오지 않더라도 항상 소수점을 포함시킵니다.</p>
<p>정밀도는 소수점 이하 자릿수를 결정하며 기본값은 6입니다.</p>
</li>
<li><p class="first">대체 형식은 결과에 항상 소수점을 포함시키고 뒤에 오는 0은 제거되지 않습니다.</p>
<p>정밀도는 소수점 앞뒤의 유효 자릿수를 결정하며 기본값은 6입니다.</p>
</li>
<li><p class="first">정밀도가 <code class="docutils literal"><span class="pre">N</span></code> 이라면, 출력은 <code class="docutils literal"><span class="pre">N</span></code> 문자로 잘립니다.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">b'%s'</span></code> is deprecated, but will not be removed during the 3.x series.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">b'%r'</span></code> is deprecated, but will not be removed during the 3.x series.</p>
</li>
<li><p class="first"><span class="target" id="index-58"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a> 을 참조하세요.</p>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">이 메서드의 바이트 배열 버전은 제자리에서 동작하지 <em>않습니다</em> - 변경되지 않는 경우조차 항상 새 객체를 만듭니다.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><span class="target" id="index-43"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0461"><strong>PEP 461</strong></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</div>
<div class="section" id="memory-views">
<span id="typememoryview"></span><h3>4.8.5. Memory Views<a class="headerlink" href="#memory-views" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> objects allow Python code to access the internal data
of an object that supports the <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">buffer protocol</span></a> without
copying.</p>
<dl class="class">
<dt id="memoryview">
<em class="property">class </em><code class="descname">memoryview</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#memoryview" title="정의 주소">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> that references <em>obj</em>.  <em>obj</em> must support the
buffer protocol.  Built-in objects that support the buffer protocol include
<a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> and <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>.</p>
<p>A <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> has the notion of an <em>element</em>, which is the
atomic memory unit handled by the originating object <em>obj</em>.  For many
simple types such as <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> and <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>, an element
is a single byte, but other types such as <a class="reference internal" href="array.html#array.array" title="array.array"><code class="xref py py-class docutils literal"><span class="pre">array.array</span></code></a> may have
bigger elements.</p>
<p><code class="docutils literal"><span class="pre">len(view)</span></code> is equal to the length of <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-class docutils literal"><span class="pre">tolist</span></code></a>.
If <code class="docutils literal"><span class="pre">view.ndim</span> <span class="pre">=</span> <span class="pre">0</span></code>, the length is 1. If <code class="docutils literal"><span class="pre">view.ndim</span> <span class="pre">=</span> <span class="pre">1</span></code>, the length
is equal to the number of elements in the view. For higher dimensions,
the length is equal to the length of the nested list representation of
the view. The <a class="reference internal" href="#memoryview.itemsize" title="memoryview.itemsize"><code class="xref py py-class docutils literal"><span class="pre">itemsize</span></code></a> attribute will give you the
number of bytes in a single element.</p>
<p>A <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> supports slicing and indexing to expose its data.
One-dimensional slicing will result in a subview:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">98</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">103</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">&lt;memory at 0x7f3ddc9f4350&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
<span class="go">b&#39;bce&#39;</span>
</pre></div>
</div>
<p>If <a class="reference internal" href="#memoryview.format" title="memoryview.format"><code class="xref py py-class docutils literal"><span class="pre">format</span></code></a> is one of the native format specifiers
from the <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> module, indexing with an integer or a tuple of
integers is also supported and returns a single <em>element</em> with
the correct type.  One-dimensional memoryviews can be indexed
with an integer or a one-integer tuple.  Multi-dimensional memoryviews
can be indexed with tuples of exactly <em>ndim</em> integers where <em>ndim</em> is
the number of dimensions.  Zero-dimensional memoryviews can be indexed
with the empty tuple.</p>
<p>Here is an example with a non-byte format:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">11111111</span><span class="p">,</span> <span class="mi">22222222</span><span class="p">,</span> <span class="o">-</span><span class="mi">33333333</span><span class="p">,</span> <span class="mi">44444444</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-11111111</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">44444444</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[-11111111, -33333333]</span>
</pre></div>
</div>
<p>If the underlying object is writable, the memoryview supports
one-dimensional slice assignment. Resizing is not allowed:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">readonly</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;zbcefg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;123&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;z123fg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;spam&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">memoryview assignment: lvalue and rvalue have different structures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;spam&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;z1spam&#39;)</span>
</pre></div>
</div>
<p>One-dimensional memoryviews of hashable (read-only) types with formats
'B', 'b' or 'c' are also hashable. The hash is defined as
<code class="docutils literal"><span class="pre">hash(m)</span> <span class="pre">==</span> <span class="pre">hash(m.tobytes())</span></code>:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ce&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>One-dimensional memoryviews can now be sliced.
One-dimensional memoryviews with formats 'B', 'b' or 'c' are now hashable.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>memoryview is now registered automatically with
<a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Sequence</span></code></a></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>memoryviews can now be indexed with tuple of integers.</p>
</div>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal"><span class="pre">memoryview</span></code></a> has several methods:</p>
<dl class="method">
<dt id="memoryview.__eq__">
<code class="descname">__eq__</code><span class="sig-paren">(</span><em>exporter</em><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.__eq__" title="정의 주소">¶</a></dt>
<dd><p>A memoryview and a <span class="target" id="index-44"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3118"><strong>PEP 3118</strong></a> exporter are equal if their shapes are
equivalent and if all corresponding values are equal when the operands'
respective format codes are interpreted using <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> syntax.</p>
<p>For the subset of <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> format strings currently supported by
<a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal"><span class="pre">tolist()</span></code></a>, <code class="docutils literal"><span class="pre">v</span></code> and <code class="docutils literal"><span class="pre">w</span></code> are equal if <code class="docutils literal"><span class="pre">v.tolist()</span> <span class="pre">==</span> <span class="pre">w.tolist()</span></code>:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="o">==</span> <span class="n">y</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">==</span> <span class="n">c</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If either format string is not supported by the <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> module,
then the objects will always compare as unequal (even if the format
strings and buffer contents are identical):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">BigEndianStructure</span><span class="p">,</span> <span class="n">c_long</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">BEPoint</span><span class="p">(</span><span class="n">BigEndianStructure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_long</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_long</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">BEPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">point</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that, as with floating point numbers, <code class="docutils literal"><span class="pre">v</span> <span class="pre">is</span> <span class="pre">w</span></code> does <em>not</em> imply
<code class="docutils literal"><span class="pre">v</span> <span class="pre">==</span> <span class="pre">w</span></code> for memoryview objects.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>Previous versions compared the raw memory disregarding the item format
and the logical array structure.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.tobytes">
<code class="descname">tobytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.tobytes" title="정의 주소">¶</a></dt>
<dd><p>Return the data in the buffer as a bytestring.  This is equivalent to
calling the <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> constructor on the memoryview.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">b&#39;abc&#39;</span>
</pre></div>
</div>
<p>For non-contiguous arrays the result is equal to the flattened list
representation with all elements converted to bytes. <a class="reference internal" href="#memoryview.tobytes" title="memoryview.tobytes"><code class="xref py py-meth docutils literal"><span class="pre">tobytes()</span></code></a>
supports all format strings, including those that are not in
<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> module syntax.</p>
</dd></dl>

<dl class="method">
<dt id="memoryview.hex">
<code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.hex" title="정의 주소">¶</a></dt>
<dd><p>Return a string object containing two hexadecimal digits for each
byte in the buffer.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;616263&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.tolist">
<code class="descname">tolist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.tolist" title="정의 주소">¶</a></dt>
<dd><p>Return the data in the buffer as a list of elements.</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[97, 98, 99]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[1.1, 2.2, 3.3]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal"><span class="pre">tolist()</span></code></a> now supports all single character native formats in
<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> module syntax as well as multi-dimensional
representations.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.release" title="정의 주소">¶</a></dt>
<dd><p>Release the underlying buffer exposed by the memoryview object.  Many
objects take special actions when a view is held on them (for example,
a <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> would temporarily forbid resizing); therefore,
calling release() is handy to remove these restrictions (and free any
dangling resources) as soon as possible.</p>
<p>After this method has been called, any further operation on the view
raises a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-class docutils literal"><span class="pre">ValueError</span></code></a> (except <a class="reference internal" href="#memoryview.release" title="memoryview.release"><code class="xref py py-meth docutils literal"><span class="pre">release()</span></code></a> itself which can
be called multiple times):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operation forbidden on released memoryview object</span>
</pre></div>
</div>
<p>The context management protocol can be used for a similar effect,
using the <code class="docutils literal"><span class="pre">with</span></code> statement:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">97</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operation forbidden on released memoryview object</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="memoryview.cast">
<code class="descname">cast</code><span class="sig-paren">(</span><em>format</em><span class="optional">[</span>, <em>shape</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.cast" title="정의 주소">¶</a></dt>
<dd><p>Cast a memoryview to a new format or shape. <em>shape</em> defaults to
<code class="docutils literal"><span class="pre">[byte_length//new_itemsize]</span></code>, which means that the result view
will be one-dimensional. The return value is a new memoryview, but
the buffer itself is not copied. Supported casts are 1D -&gt; C-<a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>
and C-contiguous -&gt; 1D.</p>
<p>The destination format is restricted to a single element native format in
<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> syntax. One of the formats must be a byte format
('B', 'b' or 'c'). The byte length of the result must be the same
as the original length.</p>
<p>Cast 1D/long to 1D/unsigned bytes:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;l&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;B&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">24</span>
</pre></div>
</div>
<p>Cast 1D/unsigned bytes to 1D/char:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;zyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;a&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">memoryview: invalid value for format &quot;B&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">bytearray(b&#39;ayz&#39;)</span>
</pre></div>
</div>
<p>Cast 1D/bytes to 3D/ints to 1D/signed char:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;i&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
</pre></div>
</div>
<p>Cast 1D/unsigned char to 2D/unsigned long:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0, 1, 2], [3, 4, 5]]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>The source format is no longer restricted when casting to a byte view.</p>
</div>
</dd></dl>

<p>There are also several readonly attributes available:</p>
<dl class="attribute">
<dt id="memoryview.obj">
<code class="descname">obj</code><a class="headerlink" href="#memoryview.obj" title="정의 주소">¶</a></dt>
<dd><p>The underlying object of the memoryview:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.nbytes">
<code class="descname">nbytes</code><a class="headerlink" href="#memoryview.nbytes" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">nbytes</span> <span class="pre">==</span> <span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">len(m.tobytes())</span></code>. This is
the amount of space in bytes that the array would use in a contiguous
representation. It is not necessarily equal to len(m):</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">m</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">12</span>
</pre></div>
</div>
<p>Multi-dimensional arrays:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="mf">1.5</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">96</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.readonly">
<code class="descname">readonly</code><a class="headerlink" href="#memoryview.readonly" title="정의 주소">¶</a></dt>
<dd><p>A bool indicating whether the memory is read only.</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.format">
<code class="descname">format</code><a class="headerlink" href="#memoryview.format" title="정의 주소">¶</a></dt>
<dd><p>A string containing the format (in <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal"><span class="pre">struct</span></code></a> module style) for each
element in the view. A memoryview can be created from exporters with
arbitrary format strings, but some methods (e.g. <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal"><span class="pre">tolist()</span></code></a>) are
restricted to native single element formats.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>format <code class="docutils literal"><span class="pre">'B'</span></code> is now handled according to the struct module syntax.
This means that <code class="docutils literal"><span class="pre">memoryview(b'abc')[0]</span> <span class="pre">==</span> <span class="pre">b'abc'[0]</span> <span class="pre">==</span> <span class="pre">97</span></code>.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.itemsize">
<code class="descname">itemsize</code><a class="headerlink" href="#memoryview.itemsize" title="정의 주소">¶</a></dt>
<dd><p>The size in bytes of each element of the memoryview:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span><span class="o">,</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">32000</span><span class="p">,</span> <span class="mi">32001</span><span class="p">,</span> <span class="mi">32002</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">32000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#memoryview.ndim" title="정의 주소">¶</a></dt>
<dd><p>An integer indicating how many dimensions of a multi-dimensional array the
memory represents.</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.shape">
<code class="descname">shape</code><a class="headerlink" href="#memoryview.shape" title="정의 주소">¶</a></dt>
<dd><p>A tuple of integers the length of <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal"><span class="pre">ndim</span></code></a> giving the shape of the
memory as an N-dimensional array.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>An empty tuple instead of <code class="docutils literal"><span class="pre">None</span></code> when ndim = 0.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.strides">
<code class="descname">strides</code><a class="headerlink" href="#memoryview.strides" title="정의 주소">¶</a></dt>
<dd><p>A tuple of integers the length of <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal"><span class="pre">ndim</span></code></a> giving the size in bytes to
access each element for each dimension of the array.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>An empty tuple instead of <code class="docutils literal"><span class="pre">None</span></code> when ndim = 0.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.suboffsets">
<code class="descname">suboffsets</code><a class="headerlink" href="#memoryview.suboffsets" title="정의 주소">¶</a></dt>
<dd><p>Used internally for PIL-style arrays. The value is informational only.</p>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.c_contiguous">
<code class="descname">c_contiguous</code><a class="headerlink" href="#memoryview.c_contiguous" title="정의 주소">¶</a></dt>
<dd><p>A bool indicating whether the memory is C-<a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.f_contiguous">
<code class="descname">f_contiguous</code><a class="headerlink" href="#memoryview.f_contiguous" title="정의 주소">¶</a></dt>
<dd><p>A bool indicating whether the memory is Fortran <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="memoryview.contiguous">
<code class="descname">contiguous</code><a class="headerlink" href="#memoryview.contiguous" title="정의 주소">¶</a></dt>
<dd><p>A bool indicating whether the memory is <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="set-types-set-frozenset">
<span id="types-set"></span><h2>4.9. Set Types --- <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a><a class="headerlink" href="#set-types-set-frozenset" title="제목 주소">¶</a></h2>
<p id="index-45">A <em class="dfn">set</em> object is an unordered collection of distinct <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> objects.
Common uses include membership testing, removing duplicates from a sequence, and
computing mathematical operations such as intersection, union, difference, and
symmetric difference.
(For other containers see the built-in <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>, <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>,
and <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> classes, and the <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> module.)</p>
<p>Like other collections, sets support <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">set</span></code>, <code class="docutils literal"><span class="pre">len(set)</span></code>, and <code class="docutils literal"><span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span>
<span class="pre">set</span></code>.  Being an unordered collection, sets do not record element position or
order of insertion.  Accordingly, sets do not support indexing, slicing, or
other sequence-like behavior.</p>
<p>There are currently two built-in set types, <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> and <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>.
The <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> type is mutable --- the contents can be changed using methods
like <code class="xref py py-meth docutils literal"><span class="pre">add()</span></code> and <code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code>.  Since it is mutable, it has no
hash value and cannot be used as either a dictionary key or as an element of
another set.  The <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> type is immutable and <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> ---
its contents cannot be altered after it is created; it can therefore be used as
a dictionary key or as an element of another set.</p>
<p>Non-empty sets (not frozensets) can be created by placing a comma-separated list
of elements within braces, for example: <code class="docutils literal"><span class="pre">{'jack',</span> <span class="pre">'sjoerd'}</span></code>, in addition to the
<a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> constructor.</p>
<p>The constructors for both classes work the same:</p>
<dl class="class">
<dt id="set">
<em class="property">class </em><code class="descname">set</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#set" title="정의 주소">¶</a></dt>
<dt id="frozenset">
<em class="property">class </em><code class="descname">frozenset</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset" title="정의 주소">¶</a></dt>
<dd><p>Return a new set or frozenset object whose elements are taken from
<em>iterable</em>.  The elements of a set must be <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>.  To
represent sets of sets, the inner sets must be <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>
objects.  If <em>iterable</em> is not specified, a new empty set is
returned.</p>
<p>Instances of <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> and <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> provide the following
operations:</p>
<dl class="describe">
<dt>
<code class="descname">len(s)</code></dt>
<dd><p>Return the number of elements in set <em>s</em> (cardinality of <em>s</em>).</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x in s</code></dt>
<dd><p>Test <em>x</em> for membership in <em>s</em>.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x not in s</code></dt>
<dd><p>Test <em>x</em> for non-membership in <em>s</em>.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.isdisjoint">
<code class="descname">isdisjoint</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.isdisjoint" title="정의 주소">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if the set has no elements in common with <em>other</em>.  Sets are
disjoint if and only if their intersection is the empty set.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.issubset">
<code class="descname">issubset</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.issubset" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set &lt;= other</code></dt>
<dd><p>Test whether every element in the set is in <em>other</em>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set &lt; other</code></dt>
<dd><p>Test whether the set is a proper subset of <em>other</em>, that is,
<code class="docutils literal"><span class="pre">set</span> <span class="pre">&lt;=</span> <span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.issuperset">
<code class="descname">issuperset</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.issuperset" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set &gt;= other</code></dt>
<dd><p>Test whether every element in <em>other</em> is in the set.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set &gt; other</code></dt>
<dd><p>Test whether the set is a proper superset of <em>other</em>, that is, <code class="docutils literal"><span class="pre">set</span> <span class="pre">&gt;=</span>
<span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.union">
<code class="descname">union</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.union" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set | other | ...</code></dt>
<dd><p>Return a new set with elements from the set and all others.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.intersection" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set &amp; other &amp; ...</code></dt>
<dd><p>Return a new set with elements common to the set and all others.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.difference">
<code class="descname">difference</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.difference" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set - other - ...</code></dt>
<dd><p>Return a new set with elements in the set that are not in the others.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.symmetric_difference">
<code class="descname">symmetric_difference</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.symmetric_difference" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set ^ other</code></dt>
<dd><p>Return a new set with elements in either the set or <em>other</em> but not both.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.copy" title="정의 주소">¶</a></dt>
<dd><p>Return a new set with a shallow copy of <em>s</em>.</p>
</dd></dl>

<p>Note, the non-operator versions of <a class="reference internal" href="#frozenset.union" title="frozenset.union"><code class="xref py py-meth docutils literal"><span class="pre">union()</span></code></a>, <a class="reference internal" href="#frozenset.intersection" title="frozenset.intersection"><code class="xref py py-meth docutils literal"><span class="pre">intersection()</span></code></a>,
<a class="reference internal" href="#frozenset.difference" title="frozenset.difference"><code class="xref py py-meth docutils literal"><span class="pre">difference()</span></code></a>, and <a class="reference internal" href="#frozenset.symmetric_difference" title="frozenset.symmetric_difference"><code class="xref py py-meth docutils literal"><span class="pre">symmetric_difference()</span></code></a>, <a class="reference internal" href="#frozenset.issubset" title="frozenset.issubset"><code class="xref py py-meth docutils literal"><span class="pre">issubset()</span></code></a>, and
<a class="reference internal" href="#frozenset.issuperset" title="frozenset.issuperset"><code class="xref py py-meth docutils literal"><span class="pre">issuperset()</span></code></a> methods will accept any iterable as an argument.  In
contrast, their operator based counterparts require their arguments to be
sets.  This precludes error-prone constructions like <code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">&amp;</span> <span class="pre">'cbs'</span></code>
in favor of the more readable <code class="docutils literal"><span class="pre">set('abc').intersection('cbs')</span></code>.</p>
<p>Both <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> and <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a> support set to set comparisons. Two
sets are equal if and only if every element of each set is contained in the
other (each is a subset of the other). A set is less than another set if and
only if the first set is a proper subset of the second set (is a subset, but
is not equal). A set is greater than another set if and only if the first set
is a proper superset of the second set (is a superset, but is not equal).</p>
<p>Instances of <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> are compared to instances of <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>
based on their members.  For example, <code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">==</span> <span class="pre">frozenset('abc')</span></code>
returns <code class="docutils literal"><span class="pre">True</span></code> and so does <code class="docutils literal"><span class="pre">set('abc')</span> <span class="pre">in</span> <span class="pre">set([frozenset('abc')])</span></code>.</p>
<p>The subset and equality comparisons do not generalize to a total ordering
function.  For example, any two nonempty disjoint sets are not equal and are not
subsets of each other, so <em>all</em> of the following return <code class="docutils literal"><span class="pre">False</span></code>: <code class="docutils literal"><span class="pre">a&lt;b</span></code>,
<code class="docutils literal"><span class="pre">a==b</span></code>, or <code class="docutils literal"><span class="pre">a&gt;b</span></code>.</p>
<p>Since sets only define partial ordering (subset relationships), the output of
the <a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal"><span class="pre">list.sort()</span></code></a> method is undefined for lists of sets.</p>
<p>Set elements, like dictionary keys, must be <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>.</p>
<p>Binary operations that mix <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> instances with <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>
return the type of the first operand.  For example: <code class="docutils literal"><span class="pre">frozenset('ab')</span> <span class="pre">|</span>
<span class="pre">set('bc')</span></code> returns an instance of <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>.</p>
<p>The following table lists operations available for <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> that do not
apply to immutable instances of <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal"><span class="pre">frozenset</span></code></a>:</p>
<dl class="method">
<dt id="frozenset.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.update" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set |= other | ...</code></dt>
<dd><p>Update the set, adding elements from all others.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.intersection_update">
<code class="descname">intersection_update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.intersection_update" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set &amp;= other &amp; ...</code></dt>
<dd><p>Update the set, keeping only elements found in it and all others.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.difference_update">
<code class="descname">difference_update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.difference_update" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set -= other | ...</code></dt>
<dd><p>Update the set, removing elements found in others.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.symmetric_difference_update">
<code class="descname">symmetric_difference_update</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.symmetric_difference_update" title="정의 주소">¶</a></dt>
<dt>
<code class="descname">set ^= other</code></dt>
<dd><p>Update the set, keeping only elements found in either set, but not in both.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.add" title="정의 주소">¶</a></dt>
<dd><p>Add element <em>elem</em> to the set.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.remove" title="정의 주소">¶</a></dt>
<dd><p>Remove element <em>elem</em> from the set.  Raises <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> if <em>elem</em> is
not contained in the set.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.discard">
<code class="descname">discard</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.discard" title="정의 주소">¶</a></dt>
<dd><p>Remove element <em>elem</em> from the set if it is present.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.pop" title="정의 주소">¶</a></dt>
<dd><p>Remove and return an arbitrary element from the set.  Raises
<a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> if the set is empty.</p>
</dd></dl>

<dl class="method">
<dt id="frozenset.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.clear" title="정의 주소">¶</a></dt>
<dd><p>Remove all elements from the set.</p>
</dd></dl>

<p>Note, the non-operator versions of the <a class="reference internal" href="#frozenset.update" title="frozenset.update"><code class="xref py py-meth docutils literal"><span class="pre">update()</span></code></a>,
<a class="reference internal" href="#frozenset.intersection_update" title="frozenset.intersection_update"><code class="xref py py-meth docutils literal"><span class="pre">intersection_update()</span></code></a>, <a class="reference internal" href="#frozenset.difference_update" title="frozenset.difference_update"><code class="xref py py-meth docutils literal"><span class="pre">difference_update()</span></code></a>, and
<a class="reference internal" href="#frozenset.symmetric_difference_update" title="frozenset.symmetric_difference_update"><code class="xref py py-meth docutils literal"><span class="pre">symmetric_difference_update()</span></code></a> methods will accept any iterable as an
argument.</p>
<p>Note, the <em>elem</em> argument to the <a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a>, <a class="reference internal" href="#frozenset.remove" title="frozenset.remove"><code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code></a>, and
<a class="reference internal" href="#frozenset.discard" title="frozenset.discard"><code class="xref py py-meth docutils literal"><span class="pre">discard()</span></code></a> methods may be a set.  To support searching for an equivalent
frozenset, a temporary one is created from <em>elem</em>.</p>
</dd></dl>

</div>
<div class="section" id="mapping-types-dict">
<span id="typesmapping"></span><h2>4.10. Mapping Types --- <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a><a class="headerlink" href="#mapping-types-dict" title="제목 주소">¶</a></h2>
<p id="index-46">A <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a> object maps <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> values to arbitrary objects.
Mappings are mutable objects.  There is currently only one standard mapping
type, the <em class="dfn">dictionary</em>.  (For other containers see the built-in
<a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>, <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a>, and <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> classes, and the
<a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal"><span class="pre">collections</span></code></a> module.)</p>
<p>A dictionary's keys are <em>almost</em> arbitrary values.  Values that are not
<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>, that is, values containing lists, dictionaries or other
mutable types (that are compared by value rather than by object identity) may
not be used as keys.  Numeric types used for keys obey the normal rules for
numeric comparison: if two numbers compare equal (such as <code class="docutils literal"><span class="pre">1</span></code> and <code class="docutils literal"><span class="pre">1.0</span></code>)
then they can be used interchangeably to index the same dictionary entry.  (Note
however, that since computers store floating-point numbers as approximations it
is usually unwise to use them as dictionary keys.)</p>
<p>Dictionaries can be created by placing a comma-separated list of <code class="docutils literal"><span class="pre">key:</span> <span class="pre">value</span></code>
pairs within braces, for example: <code class="docutils literal"><span class="pre">{'jack':</span> <span class="pre">4098,</span> <span class="pre">'sjoerd':</span> <span class="pre">4127}</span></code> or <code class="docutils literal"><span class="pre">{4098:</span>
<span class="pre">'jack',</span> <span class="pre">4127:</span> <span class="pre">'sjoerd'}</span></code>, or by the <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> constructor.</p>
<dl class="class">
<dt id="dict">
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>**kwarg</em><span class="sig-paren">)</span><a class="headerlink" href="#dict" title="정의 주소">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>mapping</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>iterable</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dd><p>Return a new dictionary initialized from an optional positional argument
and a possibly empty set of keyword arguments.</p>
<p>If no positional argument is given, an empty dictionary is created.
If a positional argument is given and it is a mapping object, a dictionary
is created with the same key-value pairs as the mapping object.  Otherwise,
the positional argument must be an <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> object.  Each item in
the iterable must itself be an iterable with exactly two objects.  The
first object of each item becomes a key in the new dictionary, and the
second object the corresponding value.  If a key occurs more than once, the
last value for that key becomes the corresponding value in the new
dictionary.</p>
<p>If keyword arguments are given, the keyword arguments and their values are
added to the dictionary created from the positional argument.  If a key
being added is already present, the value from the keyword argument
replaces the value from the positional argument.</p>
<p>To illustrate, the following examples all return a dictionary equal to
<code class="docutils literal"><span class="pre">{&quot;one&quot;:</span> <span class="pre">1,</span> <span class="pre">&quot;two&quot;:</span> <span class="pre">2,</span> <span class="pre">&quot;three&quot;:</span> <span class="pre">3}</span></code>:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">one</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">three</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;three&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span> <span class="o">==</span> <span class="n">d</span> <span class="o">==</span> <span class="n">e</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Providing keyword arguments as in the first example only works for keys that
are valid Python identifiers.  Otherwise, any valid keys can be used.</p>
<p>These are the operations that dictionaries support (and therefore, custom
mapping types should support too):</p>
<dl class="describe">
<dt>
<code class="descname">len(d)</code></dt>
<dd><p>Return the number of items in the dictionary <em>d</em>.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">d[key]</code></dt>
<dd><p>Return the item of <em>d</em> with key <em>key</em>.  Raises a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> if <em>key</em> is
not in the map.</p>
<p id="index-47">If a subclass of dict defines a method <a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> and <em>key</em>
is not present, the <code class="docutils literal"><span class="pre">d[key]</span></code> operation calls that method with the key <em>key</em>
as argument.  The <code class="docutils literal"><span class="pre">d[key]</span></code> operation then returns or raises whatever is
returned or raised by the <code class="docutils literal"><span class="pre">__missing__(key)</span></code> call.
No other operations or methods invoke <a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a>. If
<a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> is not defined, <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> is raised.
<a class="reference internal" href="../reference/datamodel.html#object.__missing__" title="object.__missing__"><code class="xref py py-meth docutils literal"><span class="pre">__missing__()</span></code></a> must be a method; it cannot be an instance variable:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Counter</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The example above shows part of the implementation of
<a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal"><span class="pre">collections.Counter</span></code></a>.  A different <code class="docutils literal"><span class="pre">__missing__</span></code> method is used
by <a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal"><span class="pre">collections.defaultdict</span></code></a>.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">d[key] = value</code></dt>
<dd><p>Set <code class="docutils literal"><span class="pre">d[key]</span></code> to <em>value</em>.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">del d[key]</code></dt>
<dd><p>Remove <code class="docutils literal"><span class="pre">d[key]</span></code> from <em>d</em>.  Raises a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> if <em>key</em> is not in the
map.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">key in d</code></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <em>d</em> has a key <em>key</em>, else <code class="docutils literal"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">key not in d</code></dt>
<dd><p>Equivalent to <code class="docutils literal"><span class="pre">not</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">d</span></code>.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">iter(d)</code></dt>
<dd><p>Return an iterator over the keys of the dictionary.  This is a shortcut
for <code class="docutils literal"><span class="pre">iter(d.keys())</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.clear" title="정의 주소">¶</a></dt>
<dd><p>Remove all items from the dictionary.</p>
</dd></dl>

<dl class="method">
<dt id="dict.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.copy" title="정의 주소">¶</a></dt>
<dd><p>Return a shallow copy of the dictionary.</p>
</dd></dl>

<dl class="classmethod">
<dt id="dict.fromkeys">
<em class="property">classmethod </em><code class="descname">fromkeys</code><span class="sig-paren">(</span><em>seq</em><span class="optional">[</span>, <em>value</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.fromkeys" title="정의 주소">¶</a></dt>
<dd><p>Create a new dictionary with keys from <em>seq</em> and values set to <em>value</em>.</p>
<p><a class="reference internal" href="#dict.fromkeys" title="dict.fromkeys"><code class="xref py py-meth docutils literal"><span class="pre">fromkeys()</span></code></a> is a class method that returns a new dictionary. <em>value</em>
defaults to <code class="docutils literal"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.get" title="정의 주소">¶</a></dt>
<dd><p>Return the value for <em>key</em> if <em>key</em> is in the dictionary, else <em>default</em>.
If <em>default</em> is not given, it defaults to <code class="docutils literal"><span class="pre">None</span></code>, so that this method
never raises a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.items">
<code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.items" title="정의 주소">¶</a></dt>
<dd><p>Return a new view of the dictionary's items (<code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> pairs).
See the <a class="reference internal" href="#dict-views"><span class="std std-ref">documentation of view objects</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.keys" title="정의 주소">¶</a></dt>
<dd><p>Return a new view of the dictionary's keys.  See the <a class="reference internal" href="#dict-views"><span class="std std-ref">documentation
of view objects</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.pop" title="정의 주소">¶</a></dt>
<dd><p>If <em>key</em> is in the dictionary, remove it and return its value, else return
<em>default</em>.  If <em>default</em> is not given and <em>key</em> is not in the dictionary,
a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> is raised.</p>
</dd></dl>

<dl class="method">
<dt id="dict.popitem">
<code class="descname">popitem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.popitem" title="정의 주소">¶</a></dt>
<dd><p>Remove and return an arbitrary <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> pair from the dictionary.</p>
<p><a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal"><span class="pre">popitem()</span></code></a> is useful to destructively iterate over a dictionary, as
often used in set algorithms.  If the dictionary is empty, calling
<a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal"><span class="pre">popitem()</span></code></a> raises a <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.setdefault">
<code class="descname">setdefault</code><span class="sig-paren">(</span><em>key</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.setdefault" title="정의 주소">¶</a></dt>
<dd><p>If <em>key</em> is in the dictionary, return its value.  If not, insert <em>key</em>
with a value of <em>default</em> and return <em>default</em>.  <em>default</em> defaults to
<code class="docutils literal"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em>other</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.update" title="정의 주소">¶</a></dt>
<dd><p>Update the dictionary with the key/value pairs from <em>other</em>, overwriting
existing keys.  Return <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p><a class="reference internal" href="#dict.update" title="dict.update"><code class="xref py py-meth docutils literal"><span class="pre">update()</span></code></a> accepts either another dictionary object or an iterable of
key/value pairs (as tuples or other iterables of length two).  If keyword
arguments are specified, the dictionary is then updated with those
key/value pairs: <code class="docutils literal"><span class="pre">d.update(red=1,</span> <span class="pre">blue=2)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="dict.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.values" title="정의 주소">¶</a></dt>
<dd><p>Return a new view of the dictionary's values.  See the
<a class="reference internal" href="#dict-views"><span class="std std-ref">documentation of view objects</span></a>.</p>
</dd></dl>

<p>Dictionaries compare equal if and only if they have the same <code class="docutils literal"><span class="pre">(key,</span>
<span class="pre">value)</span></code> pairs. Order comparisons ('&lt;', '&lt;=', '&gt;=', '&gt;') raise
<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal"><span class="pre">types.MappingProxyType</span></code></a> can be used to create a read-only view
of a <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>.</p>
</div>
<div class="section" id="dictionary-view-objects">
<span id="dict-views"></span><h3>4.10.1. Dictionary view objects<a class="headerlink" href="#dictionary-view-objects" title="제목 주소">¶</a></h3>
<p>The objects returned by <a class="reference internal" href="#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="#dict.values" title="dict.values"><code class="xref py py-meth docutils literal"><span class="pre">dict.values()</span></code></a> and
<a class="reference internal" href="#dict.items" title="dict.items"><code class="xref py py-meth docutils literal"><span class="pre">dict.items()</span></code></a> are <em>view objects</em>.  They provide a dynamic view on the
dictionary's entries, which means that when the dictionary changes, the view
reflects these changes.</p>
<p>Dictionary views can be iterated over to yield their respective data, and
support membership tests:</p>
<dl class="describe">
<dt>
<code class="descname">len(dictview)</code></dt>
<dd><p>Return the number of entries in the dictionary.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">iter(dictview)</code></dt>
<dd><p>Return an iterator over the keys, values or items (represented as tuples of
<code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code>) in the dictionary.</p>
<p>Keys and values are iterated over in an arbitrary order which is non-random,
varies across Python implementations, and depends on the dictionary's history
of insertions and deletions. If keys, values and items views are iterated
over with no intervening modifications to the dictionary, the order of items
will directly correspond.  This allows the creation of <code class="docutils literal"><span class="pre">(value,</span> <span class="pre">key)</span></code> pairs
using <a class="reference internal" href="functions.html#zip" title="zip"><code class="xref py py-func docutils literal"><span class="pre">zip()</span></code></a>: <code class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">zip(d.values(),</span> <span class="pre">d.keys())</span></code>.  Another way to
create the same list is <code class="docutils literal"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">[(v,</span> <span class="pre">k)</span> <span class="pre">for</span> <span class="pre">(k,</span> <span class="pre">v)</span> <span class="pre">in</span> <span class="pre">d.items()]</span></code>.</p>
<p>Iterating views while adding or deleting entries in the dictionary may raise
a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> or fail to iterate over all entries.</p>
</dd></dl>

<dl class="describe">
<dt>
<code class="descname">x in dictview</code></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <em>x</em> is in the underlying dictionary's keys, values or
items (in the latter case, <em>x</em> should be a <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> tuple).</p>
</dd></dl>

<p>Keys views are set-like since their entries are unique and hashable.  If all
values are hashable, so that <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> pairs are unique and hashable,
then the items view is also set-like.  (Values views are not treated as set-like
since the entries are generally not unique.)  For set-like views, all of the
operations defined for the abstract base class <a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal"><span class="pre">collections.abc.Set</span></code></a> are
available (for example, <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code>, or <code class="docutils literal"><span class="pre">^</span></code>).</p>
<p>An example of dictionary view usage:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dishes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;sausage&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># iteration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">+=</span> <span class="n">val</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">504</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># keys and values are iterated over in the same order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">[&#39;eggs&#39;, &#39;bacon&#39;, &#39;sausage&#39;, &#39;spam&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">[2, 1, 1, 500]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view objects are dynamic and reflect dict changes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s1">&#39;eggs&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s1">&#39;sausage&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">[&#39;spam&#39;, &#39;bacon&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># set operations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s1">&#39;eggs&#39;</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">,</span> <span class="s1">&#39;salad&#39;</span><span class="p">}</span>
<span class="go">{&#39;bacon&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">^</span> <span class="p">{</span><span class="s1">&#39;sausage&#39;</span><span class="p">,</span> <span class="s1">&#39;juice&#39;</span><span class="p">}</span>
<span class="go">{&#39;juice&#39;, &#39;sausage&#39;, &#39;bacon&#39;, &#39;spam&#39;}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="context-manager-types">
<span id="typecontextmanager"></span><h2>4.11. Context Manager Types<a class="headerlink" href="#context-manager-types" title="제목 주소">¶</a></h2>
<p id="index-48">Python's <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement supports the concept of a runtime context
defined by a context manager.  This is implemented using a pair of methods
that allow user-defined classes to define a runtime context that is entered
before the statement body is executed and exited when the statement ends:</p>
<dl class="method">
<dt id="contextmanager.__enter__">
<code class="descclassname">contextmanager.</code><code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#contextmanager.__enter__" title="정의 주소">¶</a></dt>
<dd><p>Enter the runtime context and return either this object or another object
related to the runtime context. The value returned by this method is bound to
the identifier in the <a class="reference internal" href="../reference/compound_stmts.html#as"><code class="xref std std-keyword docutils literal"><span class="pre">as</span></code></a> clause of <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statements using
this context manager.</p>
<p>An example of a context manager that returns itself is a <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>.
File objects return themselves from __enter__() to allow <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> to be
used as the context expression in a <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement.</p>
<p>An example of a context manager that returns a related object is the one
returned by <a class="reference internal" href="decimal.html#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal"><span class="pre">decimal.localcontext()</span></code></a>. These managers set the active
decimal context to a copy of the original decimal context and then return the
copy. This allows changes to be made to the current decimal context in the body
of the <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement without affecting code outside the
<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement.</p>
</dd></dl>

<dl class="method">
<dt id="contextmanager.__exit__">
<code class="descclassname">contextmanager.</code><code class="descname">__exit__</code><span class="sig-paren">(</span><em>exc_type</em>, <em>exc_val</em>, <em>exc_tb</em><span class="sig-paren">)</span><a class="headerlink" href="#contextmanager.__exit__" title="정의 주소">¶</a></dt>
<dd><p>Exit the runtime context and return a Boolean flag indicating if any exception
that occurred should be suppressed. If an exception occurred while executing the
body of the <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement, the arguments contain the exception type,
value and traceback information. Otherwise, all three arguments are <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p>Returning a true value from this method will cause the <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement
to suppress the exception and continue execution with the statement immediately
following the <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement. Otherwise the exception continues
propagating after this method has finished executing. Exceptions that occur
during execution of this method will replace any exception that occurred in the
body of the <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal"><span class="pre">with</span></code></a> statement.</p>
<p>The exception passed in should never be reraised explicitly - instead, this
method should return a false value to indicate that the method completed
successfully and does not want to suppress the raised exception. This allows
context management code to easily detect whether or not an <a class="reference internal" href="#contextmanager.__exit__" title="contextmanager.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a>
method has actually failed.</p>
</dd></dl>

<p>Python defines several context managers to support easy thread synchronisation,
prompt closure of files or other objects, and simpler manipulation of the active
decimal arithmetic context. The specific types are not treated specially beyond
their implementation of the context management protocol. See the
<a class="reference internal" href="contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal"><span class="pre">contextlib</span></code></a> module for some examples.</p>
<p>Python's <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>s and the <a class="reference internal" href="contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-class docutils literal"><span class="pre">contextlib.contextmanager</span></code></a> decorator
provide a convenient way to implement these protocols.  If a generator function is
decorated with the <a class="reference internal" href="contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-class docutils literal"><span class="pre">contextlib.contextmanager</span></code></a> decorator, it will return a
context manager implementing the necessary <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal"><span class="pre">__enter__()</span></code></a> and
<a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal"><span class="pre">__exit__()</span></code></a> methods, rather than the iterator produced by an undecorated
generator function.</p>
<p>Note that there is no specific slot for any of these methods in the type
structure for Python objects in the Python/C API. Extension types wanting to
define these methods must provide them as a normal Python accessible method.
Compared to the overhead of setting up the runtime context, the overhead of a
single class dictionary lookup is negligible.</p>
</div>
<div class="section" id="other-built-in-types">
<span id="typesother"></span><h2>4.12. Other Built-in Types<a class="headerlink" href="#other-built-in-types" title="제목 주소">¶</a></h2>
<p>The interpreter supports several other kinds of objects. Most of these support
only one or two operations.</p>
<div class="section" id="modules">
<span id="typesmodules"></span><h3>4.12.1. Modules<a class="headerlink" href="#modules" title="제목 주소">¶</a></h3>
<p>The only special operation on a module is attribute access: <code class="docutils literal"><span class="pre">m.name</span></code>, where
<em>m</em> is a module and <em>name</em> accesses a name defined in <em>m</em>'s symbol table.
Module attributes can be assigned to.  (Note that the <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a>
statement is not, strictly speaking, an operation on a module object; <code class="docutils literal"><span class="pre">import</span>
<span class="pre">foo</span></code> does not require a module object named <em>foo</em> to exist, rather it requires
an (external) <em>definition</em> for a module named <em>foo</em> somewhere.)</p>
<p>A special attribute of every module is <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a>. This is the
dictionary containing the module's symbol table. Modifying this dictionary will
actually change the module's symbol table, but direct assignment to the
<a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> attribute is not possible (you can write
<code class="docutils literal"><span class="pre">m.__dict__['a']</span> <span class="pre">=</span> <span class="pre">1</span></code>, which defines <code class="docutils literal"><span class="pre">m.a</span></code> to be <code class="docutils literal"><span class="pre">1</span></code>, but you can't write
<code class="docutils literal"><span class="pre">m.__dict__</span> <span class="pre">=</span> <span class="pre">{}</span></code>).  Modifying <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code></a> directly is
not recommended.</p>
<p>Modules built into the interpreter are written like this: <code class="docutils literal"><span class="pre">&lt;module</span> <span class="pre">'sys'</span>
<span class="pre">(built-in)&gt;</span></code>.  If loaded from a file, they are written as <code class="docutils literal"><span class="pre">&lt;module</span> <span class="pre">'os'</span> <span class="pre">from</span>
<span class="pre">'/usr/local/lib/pythonX.Y/os.pyc'&gt;</span></code>.</p>
</div>
<div class="section" id="classes-and-class-instances">
<span id="typesobjects"></span><h3>4.12.2. Classes and Class Instances<a class="headerlink" href="#classes-and-class-instances" title="제목 주소">¶</a></h3>
<p>See <a class="reference internal" href="../reference/datamodel.html#objects"><span class="std std-ref">객체, 값, 형</span></a> and <a class="reference internal" href="../reference/compound_stmts.html#class"><span class="std std-ref">클래스 정의</span></a> for these.</p>
</div>
<div class="section" id="functions">
<span id="typesfunctions"></span><h3>4.12.3. Functions<a class="headerlink" href="#functions" title="제목 주소">¶</a></h3>
<p>Function objects are created by function definitions.  The only operation on a
function object is to call it: <code class="docutils literal"><span class="pre">func(argument-list)</span></code>.</p>
<p>There are really two flavors of function objects: built-in functions and
user-defined functions.  Both support the same operation (to call the function),
but the implementation is different, hence the different object types.</p>
<p>See <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> for more information.</p>
</div>
<div class="section" id="methods">
<span id="typesmethods"></span><h3>4.12.4. Methods<a class="headerlink" href="#methods" title="제목 주소">¶</a></h3>
<p id="index-49">Methods are functions that are called using the attribute notation. There are
two flavors: built-in methods (such as <code class="xref py py-meth docutils literal"><span class="pre">append()</span></code> on lists) and class
instance methods.  Built-in methods are described with the types that support
them.</p>
<p>If you access a method (a function defined in a class namespace) through an
instance, you get a special object: a <em class="dfn">bound method</em> (also called
<em class="dfn">instance method</em>) object. When called, it will add the <code class="docutils literal"><span class="pre">self</span></code> argument
to the argument list.  Bound methods have two special read-only attributes:
<code class="docutils literal"><span class="pre">m.__self__</span></code> is the object on which the method operates, and <code class="docutils literal"><span class="pre">m.__func__</span></code> is
the function implementing the method.  Calling <code class="docutils literal"><span class="pre">m(arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span> <span class="pre">arg-n)</span></code>
is completely equivalent to calling <code class="docutils literal"><span class="pre">m.__func__(m.__self__,</span> <span class="pre">arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span>
<span class="pre">arg-n)</span></code>.</p>
<p>Like function objects, bound method objects support getting arbitrary
attributes.  However, since method attributes are actually stored on the
underlying function object (<code class="docutils literal"><span class="pre">meth.__func__</span></code>), setting method attributes on
bound methods is disallowed.  Attempting to set an attribute on a method
results in an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> being raised.  In order to set a method
attribute, you need to explicitly set it on the underlying function object:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s1">&#39;my name is method&#39;</span>  <span class="c1"># can&#39;t set on the method</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;method&#39; object has no attribute &#39;whoami&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="vm">__func__</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s1">&#39;my name is method&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">whoami</span>
<span class="go">&#39;my name is method&#39;</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">표준형 계층</span></a> for more information.</p>
</div>
<div class="section" id="code-objects">
<span id="bltin-code-objects"></span><span id="index-50"></span><h3>4.12.5. Code Objects<a class="headerlink" href="#code-objects" title="제목 주소">¶</a></h3>
<p id="index-51">Code objects are used by the implementation to represent &quot;pseudo-compiled&quot;
executable Python code such as a function body. They differ from function
objects because they don't contain a reference to their global execution
environment.  Code objects are returned by the built-in <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a> function
and can be extracted from function objects through their <code class="xref py py-attr docutils literal"><span class="pre">__code__</span></code>
attribute. See also the <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal"><span class="pre">code</span></code></a> module.</p>
<p id="index-52">A code object can be executed or evaluated by passing it (instead of a source
string) to the <a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal"><span class="pre">exec()</span></code></a> or <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal"><span class="pre">eval()</span></code></a>  built-in functions.</p>
<p>See <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">표준형 계층</span></a> for more information.</p>
</div>
<div class="section" id="type-objects">
<span id="bltin-type-objects"></span><h3>4.12.6. Type Objects<a class="headerlink" href="#type-objects" title="제목 주소">¶</a></h3>
<p id="index-53">Type objects represent the various object types.  An object's type is accessed
by the built-in function <a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-func docutils literal"><span class="pre">type()</span></code></a>.  There are no special operations on
types.  The standard module <a class="reference internal" href="types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal"><span class="pre">types</span></code></a> defines names for all standard built-in
types.</p>
<p>Types are written like this: <code class="docutils literal"><span class="pre">&lt;class</span> <span class="pre">'int'&gt;</span></code>.</p>
</div>
<div class="section" id="the-null-object">
<span id="bltin-null-object"></span><h3>4.12.7. The Null Object<a class="headerlink" href="#the-null-object" title="제목 주소">¶</a></h3>
<p>This object is returned by functions that don't explicitly return a value.  It
supports no special operations.  There is exactly one null object, named
<code class="docutils literal"><span class="pre">None</span></code> (a built-in name).  <code class="docutils literal"><span class="pre">type(None)()</span></code> produces the same singleton.</p>
<p>It is written as <code class="docutils literal"><span class="pre">None</span></code>.</p>
</div>
<div class="section" id="the-ellipsis-object">
<span id="bltin-ellipsis-object"></span><h3>4.12.8. The Ellipsis Object<a class="headerlink" href="#the-ellipsis-object" title="제목 주소">¶</a></h3>
<p>This object is commonly used by slicing (see <a class="reference internal" href="../reference/expressions.html#slicings"><span class="std std-ref">슬라이싱(Slicings)</span></a>).  It supports no
special operations.  There is exactly one ellipsis object, named
<a class="reference internal" href="constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal"><span class="pre">Ellipsis</span></code></a> (a built-in name).  <code class="docutils literal"><span class="pre">type(Ellipsis)()</span></code> produces the
<a class="reference internal" href="constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal"><span class="pre">Ellipsis</span></code></a> singleton.</p>
<p>It is written as <code class="docutils literal"><span class="pre">Ellipsis</span></code> or <code class="docutils literal"><span class="pre">...</span></code>.</p>
</div>
<div class="section" id="the-notimplemented-object">
<span id="bltin-notimplemented-object"></span><h3>4.12.9. The NotImplemented Object<a class="headerlink" href="#the-notimplemented-object" title="제목 주소">¶</a></h3>
<p>This object is returned from comparisons and binary operations when they are
asked to operate on types they don't support. See <a class="reference internal" href="../reference/expressions.html#comparisons"><span class="std std-ref">비교</span></a> for more
information.  There is exactly one <code class="docutils literal"><span class="pre">NotImplemented</span></code> object.
<code class="docutils literal"><span class="pre">type(NotImplemented)()</span></code> produces the singleton instance.</p>
<p>It is written as <code class="docutils literal"><span class="pre">NotImplemented</span></code>.</p>
</div>
<div class="section" id="boolean-values">
<span id="bltin-boolean-values"></span><h3>4.12.10. Boolean Values<a class="headerlink" href="#boolean-values" title="제목 주소">¶</a></h3>
<p>Boolean values are the two constant objects <code class="docutils literal"><span class="pre">False</span></code> and <code class="docutils literal"><span class="pre">True</span></code>.  They are
used to represent truth values (although other values can also be considered
false or true).  In numeric contexts (for example when used as the argument to
an arithmetic operator), they behave like the integers 0 and 1, respectively.
The built-in function <a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-func docutils literal"><span class="pre">bool()</span></code></a> can be used to convert any value to a
Boolean, if the value can be interpreted as a truth value (see section
<a class="reference internal" href="#truth"><span class="std std-ref">논리값 검사</span></a> above).</p>
<p id="index-54">They are written as <code class="docutils literal"><span class="pre">False</span></code> and <code class="docutils literal"><span class="pre">True</span></code>, respectively.</p>
</div>
<div class="section" id="internal-objects">
<span id="typesinternal"></span><h3>4.12.11. Internal Objects<a class="headerlink" href="#internal-objects" title="제목 주소">¶</a></h3>
<p>See <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">표준형 계층</span></a> for this information.  It describes stack frame objects,
traceback objects, and slice objects.</p>
</div>
</div>
<div class="section" id="special-attributes">
<span id="specialattrs"></span><h2>4.13. Special Attributes<a class="headerlink" href="#special-attributes" title="제목 주소">¶</a></h2>
<p>The implementation adds a few special read-only attributes to several object
types, where they are relevant.  Some of these are not reported by the
<a class="reference internal" href="functions.html#dir" title="dir"><code class="xref py py-func docutils literal"><span class="pre">dir()</span></code></a> built-in function.</p>
<dl class="attribute">
<dt id="object.__dict__">
<code class="descclassname">object.</code><code class="descname">__dict__</code><a class="headerlink" href="#object.__dict__" title="정의 주소">¶</a></dt>
<dd><p>A dictionary or other mapping object used to store an object's (writable)
attributes.</p>
</dd></dl>

<dl class="attribute">
<dt id="instance.__class__">
<code class="descclassname">instance.</code><code class="descname">__class__</code><a class="headerlink" href="#instance.__class__" title="정의 주소">¶</a></dt>
<dd><p>The class to which a class instance belongs.</p>
</dd></dl>

<dl class="attribute">
<dt id="class.__bases__">
<code class="descclassname">class.</code><code class="descname">__bases__</code><a class="headerlink" href="#class.__bases__" title="정의 주소">¶</a></dt>
<dd><p>The tuple of base classes of a class object.</p>
</dd></dl>

<dl class="attribute">
<dt id="definition.__name__">
<code class="descclassname">definition.</code><code class="descname">__name__</code><a class="headerlink" href="#definition.__name__" title="정의 주소">¶</a></dt>
<dd><p>The name of the class, function, method, descriptor, or
generator instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="definition.__qualname__">
<code class="descclassname">definition.</code><code class="descname">__qualname__</code><a class="headerlink" href="#definition.__qualname__" title="정의 주소">¶</a></dt>
<dd><p>The <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">qualified name</span></a> of the class, function, method, descriptor,
or generator instance.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="class.__mro__">
<code class="descclassname">class.</code><code class="descname">__mro__</code><a class="headerlink" href="#class.__mro__" title="정의 주소">¶</a></dt>
<dd><p>This attribute is a tuple of classes that are considered when looking for
base classes during method resolution.</p>
</dd></dl>

<dl class="method">
<dt id="class.mro">
<code class="descclassname">class.</code><code class="descname">mro</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#class.mro" title="정의 주소">¶</a></dt>
<dd><p>This method can be overridden by a metaclass to customize the method
resolution order for its instances.  It is called at class instantiation, and
its result is stored in <a class="reference internal" href="#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal"><span class="pre">__mro__</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="class.__subclasses__">
<code class="descclassname">class.</code><code class="descname">__subclasses__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasses__" title="정의 주소">¶</a></dt>
<dd><p>Each class keeps a list of weak references to its immediate subclasses.  This
method returns a list of all those references still alive.
Example:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>
<span class="go">[&lt;class &#39;bool&#39;&gt;]</span>
</pre></div>
</div>
</dd></dl>

<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Additional information on these special methods may be found in the Python
Reference Manual (<a class="reference internal" href="../reference/datamodel.html#customization"><span class="std std-ref">기본적인 커스터마이제이션</span></a>).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>As a consequence, the list <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2]</span></code> is considered equal to <code class="docutils literal"><span class="pre">[1.0,</span> <span class="pre">2.0]</span></code>, and
similarly for tuples.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>They must have since the parser can't tell the type of the operands.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id7">2</a>, <a class="fn-backref" href="#id8">3</a>, <a class="fn-backref" href="#id9">4</a>)</em> Cased characters are those with general category property being one of
&quot;Lu&quot; (Letter, uppercase), &quot;Ll&quot; (Letter, lowercase), or &quot;Lt&quot; (Letter, titlecase).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id11">2</a>)</em> To format only a tuple you should therefore provide a singleton tuple whose only
element is the tuple to be formatted.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">4. 내장 형</a><ul>
<li><a class="reference internal" href="#truth-value-testing">4.1. 논리값 검사</a></li>
<li><a class="reference internal" href="#boolean-operations-and-or-not">4.2. 논리 연산 --- <code class="docutils literal"><span class="pre">and</span></code>, <code class="docutils literal"><span class="pre">or</span></code>, <code class="docutils literal"><span class="pre">not</span></code></a></li>
<li><a class="reference internal" href="#comparisons">4.3. 비교</a></li>
<li><a class="reference internal" href="#numeric-types-int-float-complex">4.4. 숫자 형 --- <code class="docutils literal"><span class="pre">int</span></code>, <code class="docutils literal"><span class="pre">float</span></code>, <code class="docutils literal"><span class="pre">complex</span></code></a><ul>
<li><a class="reference internal" href="#bitwise-operations-on-integer-types">4.4.1. 정수 형에 대한 비트 연산</a></li>
<li><a class="reference internal" href="#additional-methods-on-integer-types">4.4.2. 정수 형에 대한 추가 메서드</a></li>
<li><a class="reference internal" href="#additional-methods-on-float">4.4.3. 실수에 대한 추가 메서드</a></li>
<li><a class="reference internal" href="#hashing-of-numeric-types">4.4.4. 숫자 형의 해싱</a></li>
</ul>
</li>
<li><a class="reference internal" href="#iterator-types">4.5. 이터레이터 형</a><ul>
<li><a class="reference internal" href="#generator-types">4.5.1. 제너레이터 형</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequence-types-list-tuple-range">4.6. 시퀀스 형 --- <code class="docutils literal"><span class="pre">list</span></code>, <code class="docutils literal"><span class="pre">tuple</span></code>, <code class="docutils literal"><span class="pre">range</span></code></a><ul>
<li><a class="reference internal" href="#common-sequence-operations">4.6.1. 공통 시퀀스 연산</a></li>
<li><a class="reference internal" href="#immutable-sequence-types">4.6.2. 불변 시퀀스 형</a></li>
<li><a class="reference internal" href="#mutable-sequence-types">4.6.3. 가변 시퀀스 형</a></li>
<li><a class="reference internal" href="#lists">4.6.4. 리스트</a></li>
<li><a class="reference internal" href="#tuples">4.6.5. 튜플</a></li>
<li><a class="reference internal" href="#ranges">4.6.6. 범위</a></li>
</ul>
</li>
<li><a class="reference internal" href="#text-sequence-type-str">4.7. 텍스트 시퀀스 형 --- <code class="docutils literal"><span class="pre">str</span></code></a><ul>
<li><a class="reference internal" href="#string-methods">4.7.1. 문자열 메서드</a></li>
<li><a class="reference internal" href="#printf-style-string-formatting">4.7.2. <code class="docutils literal"><span class="pre">printf</span></code> 스타일 문자열 포맷팅</a></li>
</ul>
</li>
<li><a class="reference internal" href="#binary-sequence-types-bytes-bytearray-memoryview">4.8. 바이너리 시퀀스 형 --- <code class="docutils literal"><span class="pre">bytes</span></code>, <code class="docutils literal"><span class="pre">bytearray</span></code>, <code class="docutils literal"><span class="pre">memoryview</span></code></a><ul>
<li><a class="reference internal" href="#bytes-objects">4.8.1. 바이트열 객체</a></li>
<li><a class="reference internal" href="#bytearray-objects">4.8.2. 바이트 배열 객체</a></li>
<li><a class="reference internal" href="#bytes-and-bytearray-operations">4.8.3. 바이트열 과 바이트 배열 연산</a></li>
<li><a class="reference internal" href="#printf-style-bytes-formatting">4.8.4. <code class="docutils literal"><span class="pre">printf</span></code>-style Bytes Formatting</a></li>
<li><a class="reference internal" href="#memory-views">4.8.5. Memory Views</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-types-set-frozenset">4.9. Set Types --- <code class="docutils literal"><span class="pre">set</span></code>, <code class="docutils literal"><span class="pre">frozenset</span></code></a></li>
<li><a class="reference internal" href="#mapping-types-dict">4.10. Mapping Types --- <code class="docutils literal"><span class="pre">dict</span></code></a><ul>
<li><a class="reference internal" href="#dictionary-view-objects">4.10.1. Dictionary view objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-manager-types">4.11. Context Manager Types</a></li>
<li><a class="reference internal" href="#other-built-in-types">4.12. Other Built-in Types</a><ul>
<li><a class="reference internal" href="#modules">4.12.1. Modules</a></li>
<li><a class="reference internal" href="#classes-and-class-instances">4.12.2. Classes and Class Instances</a></li>
<li><a class="reference internal" href="#functions">4.12.3. Functions</a></li>
<li><a class="reference internal" href="#methods">4.12.4. Methods</a></li>
<li><a class="reference internal" href="#code-objects">4.12.5. Code Objects</a></li>
<li><a class="reference internal" href="#type-objects">4.12.6. Type Objects</a></li>
<li><a class="reference internal" href="#the-null-object">4.12.7. The Null Object</a></li>
<li><a class="reference internal" href="#the-ellipsis-object">4.12.8. The Ellipsis Object</a></li>
<li><a class="reference internal" href="#the-notimplemented-object">4.12.9. The NotImplemented Object</a></li>
<li><a class="reference internal" href="#boolean-values">4.12.10. Boolean Values</a></li>
<li><a class="reference internal" href="#internal-objects">4.12.11. Internal Objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-attributes">4.13. Special Attributes</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="constants.html"
                        title="이전 장">3. 내장 상수</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="exceptions.html"
                        title="다음 장">5. Built-in Exceptions</a></p>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/stdtypes.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="일반 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="exceptions.html" title="5. Built-in Exceptions"
             >다음</a> |</li>
        <li class="right" >
          <a href="constants.html" title="3. 내장 상수"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">도큐멘테이션 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2018, Flowdas. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.5 를 사용해서 만들었습니다.
    </div>

  </body>
</html>