
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>파이썬 프로파일러 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="timeit --- 작은 코드 조각의 실행 시간 측정" href="timeit.html" />
    <link rel="prev" title="pdb --- 파이썬 디버거" href="pdb.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/profile.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="timeit.html" title="timeit --- 작은 코드 조각의 실행 시간 측정"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="pdb.html" title="pdb --- 파이썬 디버거"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="debug.html" accesskey="U">디버깅과 프로파일링</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-python-profilers">
<span id="profile"></span><h1>파이썬 프로파일러<a class="headerlink" href="#the-python-profilers" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/profile.py">Lib/profile.py</a> 및 <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/pstats.py">Lib/pstats.py</a></p>
<hr class="docutils" />
<div class="section" id="introduction-to-the-profilers">
<span id="profiler-introduction"></span><h2>프로파일러 소개<a class="headerlink" href="#introduction-to-the-profilers" title="제목 주소">¶</a></h2>
<p id="index-0"><a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>과 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>는 파이썬 프로그램의 <em class="dfn">결정적 프로파일링 (deterministic profiling)</em>을 제공합니다. <em class="dfn">프로파일 (profile)</em>은 프로그램의 여러 부분이 얼마나 자주 그리고 얼마나 오랫동안 실행되었는지를 기술하는 통계 집합입니다. 이러한 통계는 <a class="reference internal" href="#module-pstats" title="pstats: Statistics object for use with the profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pstats</span></code></a> 모듈을 통해 보고서로 포매팅 할 수 있습니다.</p>
<p>파이썬 표준 라이브러리는 같은 프로파일링 인터페이스의 두 가지 구현을 제공합니다:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>이 대부분 사용자에게 권장됩니다; 오래 실행되는 프로그램을 프로파일링하는 데 적합한 합리적인 부하를 주는 C 확장입니다. Brett Rosen과 Ted Czotter가 제공한 <code class="xref py py-mod docutils literal notranslate"><span class="pre">lsprof</span></code>를 기반으로합니다.</p></li>
<li><p><a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>은 순수 파이썬 모듈이고 이 인터페이스를 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>이 모방했습니다. 하지만, 프로파일링 되는 프로그램에 상당한 부하를 추가합니다. 어떤 방식으로 프로파일러를 확장하려고 한다면, 이 모듈을 사용하면 작업이 더 쉬울 수 있습니다. Jim Roskind가 원래 설계하고 작성했습니다.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>프로파일러 모듈은 벤치마킹 목적(이를 위해서는 합리적으로 정확한 결과를 주는 <a class="reference internal" href="timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code class="xref py py-mod docutils literal notranslate"><span class="pre">timeit</span></code></a>이 있습니다)이 아니라 주어진 프로그램에 대한 실행 프로파일을 제공하도록 설계되었습니다 . 이것은 특히 C 코드에 대한 파이썬 코드 벤치마킹에 적용됩니다: 프로파일러는 파이썬 코드에 부하를 가하지만, C 수준 함수에는 그렇지 않아서 C 코드는 모든 파이썬 코드보다 빨라 보입니다.</p>
</div>
</div>
<div class="section" id="instant-user-s-manual">
<span id="profile-instant"></span><h2>즉석 사용자 설명서<a class="headerlink" href="#instant-user-s-manual" title="제목 주소">¶</a></h2>
<p>이 섹션은 &quot;설명서를 읽고 싶지 않은&quot; 사용자를 위해 제공됩니다. 매우 간단한 개요를 제공하며, 사용자가 기존 응용 프로그램에서 프로파일링을 빠르게 수행할 수 있도록 합니다.</p>
<p>단일 인자를 취하는 함수를 프로파일링하려면, 이렇게 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cProfile</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;re.compile(&quot;foo|bar&quot;)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>(시스템에서 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>을 사용할 수 없으면 대신 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>을 사용하십시오.)</p>
<p>위의 작업은 <a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>을 실행하고 다음과 같은 프로파일 결과를 인쇄합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>      <span class="mi">197</span> <span class="n">function</span> <span class="n">calls</span> <span class="p">(</span><span class="mi">192</span> <span class="n">primitive</span> <span class="n">calls</span><span class="p">)</span> <span class="ow">in</span> <span class="mf">0.002</span> <span class="n">seconds</span>

<span class="n">Ordered</span> <span class="n">by</span><span class="p">:</span> <span class="n">standard</span> <span class="n">name</span>

<span class="n">ncalls</span>  <span class="n">tottime</span>  <span class="n">percall</span>  <span class="n">cumtime</span>  <span class="n">percall</span> <span class="n">filename</span><span class="p">:</span><span class="n">lineno</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.001</span>    <span class="mf">0.001</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">1</span><span class="p">(</span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.001</span>    <span class="mf">0.001</span> <span class="n">re</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">212</span><span class="p">(</span><span class="nb">compile</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.001</span>    <span class="mf">0.001</span> <span class="n">re</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">268</span><span class="p">(</span><span class="n">_compile</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">sre_compile</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">172</span><span class="p">(</span><span class="n">_compile_charset</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">sre_compile</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">201</span><span class="p">(</span><span class="n">_optimize_charset</span><span class="p">)</span>
     <span class="mi">4</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">sre_compile</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">25</span><span class="p">(</span><span class="n">_identityfunction</span><span class="p">)</span>
   <span class="mi">3</span><span class="o">/</span><span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">sre_compile</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">33</span><span class="p">(</span><span class="n">_compile</span><span class="p">)</span>
</pre></div>
</div>
<p>첫 번째 줄은 197 개의 호출이 관찰되었음을 나타냅니다. 이 호출 중 192 개는 <em class="dfn">프리미티브(primitive)</em>였으며, 이는 호출이 재귀를 통해 유발되지 않았 음을 의미합니다. 다음 줄: <code class="docutils literal notranslate"><span class="pre">Ordered</span> <span class="pre">by:</span> <span class="pre">standard</span> <span class="pre">name</span></code>, 은 가장 오른쪽 열의 텍스트 문자열이 출력을 정렬하는 데 사용되었음을 나타냅니다. 열 제목은 다음과 같습니다:</p>
<dl class="simple">
<dt>ncalls</dt><dd><p>호출 수.</p>
</dd>
<dt>tottime</dt><dd><p>주어진 함수에서 소비된 총 시간 (서브 함수 호출에 소요된 시간은 제외합니다)</p>
</dd>
<dt>percall</dt><dd><p><code class="docutils literal notranslate"><span class="pre">tottime</span></code>을 <code class="docutils literal notranslate"><span class="pre">ncalls</span></code>로 나눈 몫</p>
</dd>
<dt>cumtime</dt><dd><p>이 함수와 모든 서브 함수에서 소요된 누적 시간 (호출에서 종료까지). 이 수치는 재귀 함수에서도 <em>정확</em>합니다.</p>
</dd>
<dt>percall</dt><dd><p><code class="docutils literal notranslate"><span class="pre">cumtime</span></code>을 프리미티브 호출로 나눈 몫</p>
</dd>
<dt>filename:lineno(function)</dt><dd><p>각 함수의 해당 데이터를 제공합니다 -- 파일명:줄 번호(함수)</p>
</dd>
</dl>
<p>첫 번째 열에 두 개의 숫자가 있으면 (예를 들어 <code class="docutils literal notranslate"><span class="pre">3/1</span></code>), 함수가 재귀되었음을 의미합니다. 두 번째 값은 프리미티브 호출 수이고 앞의 것은 총 호출 수입니다. 함수가 재귀되지 않으면, 이 두 값은 같으며, 한 숫자 만 인쇄됩니다.</p>
<p>프로파일 실행의 끝에 출력을 인쇄하는 대신, <code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code> 함수에 파일명을 지정하여 결과를 파일에 저장할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cProfile</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;re.compile(&quot;foo|bar&quot;)&#39;</span><span class="p">,</span> <span class="s1">&#39;restats&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">pstats.Stats</span></code></a> 클래스는 파일에서 프로파일 결과를 읽고 다양한 방식으로 포맷합니다.</p>
<p><a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>과 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>을 스크립트로 호출하여 다른 스크립트를 프로파일링 할 수도 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">cProfile</span> <span class="p">[</span><span class="o">-</span><span class="n">o</span> <span class="n">output_file</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">s</span> <span class="n">sort_order</span><span class="p">]</span> <span class="p">(</span><span class="o">-</span><span class="n">m</span> <span class="n">module</span> <span class="o">|</span> <span class="n">myscript</span><span class="o">.</span><span class="n">py</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-o</span></code>는 stdout 대신 파일에 프로파일 결과를 씁니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">-s</span></code>는 출력을 정렬할 <a class="reference internal" href="#pstats.Stats.sort_stats" title="pstats.Stats.sort_stats"><code class="xref py py-func docutils literal notranslate"><span class="pre">sort_stats()</span></code></a> 정렬 값 중 하나를 지정합니다. 이는 <code class="docutils literal notranslate"><span class="pre">-o</span></code>가 제공되지 않은 경우에만 적용됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">-m</span></code>은 스크립트 대신 모듈이 프로파일링되도록 지정합니다.</p>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span><code class="docutils literal notranslate"><span class="pre">-m</span></code> 옵션을 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>에 추가했습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가: </span><code class="docutils literal notranslate"><span class="pre">-m</span></code> 옵션을 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>에 추가했습니다.</p>
</div>
</div></blockquote>
<p><a class="reference internal" href="#module-pstats" title="pstats: Statistics object for use with the profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pstats</span></code></a> 모듈의 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스에는 프로파일 결과 파일에 저장된 데이터를 조작하고 인쇄하기위한 다양한 메서드가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pstats</span>
<span class="kn">from</span> <span class="nn">pstats</span> <span class="k">import</span> <span class="n">SortKey</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">pstats</span><span class="o">.</span><span class="n">Stats</span><span class="p">(</span><span class="s1">&#39;restats&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">strip_dirs</span><span class="p">()</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="#pstats.Stats.strip_dirs" title="pstats.Stats.strip_dirs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strip_dirs()</span></code></a> 메서드는 모든 모듈 이름에서 외부 경로를 제거했습니다. <a class="reference internal" href="#pstats.Stats.sort_stats" title="pstats.Stats.sort_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_stats()</span></code></a> 메서드는 인쇄되는 표준 모듈/줄/이름 문자열에 따라 모든 항목을 정렬했습니다. <a class="reference internal" href="#pstats.Stats.print_stats" title="pstats.Stats.print_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">print_stats()</span></code></a> 메서드는 모든 통계를 인쇄했습니다. 다음과 같은 정렬 호출을 시도할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="n">SortKey</span><span class="o">.</span><span class="n">NAME</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
</pre></div>
</div>
<p>첫 번째 호출은 실제로 함수 이름으로 목록을 정렬하고, 두 번째 호출은 통계를 인쇄합니다. 다음은 몇 가지 흥미로운 실험 호출입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="n">SortKey</span><span class="o">.</span><span class="n">CUMULATIVE</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>이것은 함수에서의 누적 시간을 기준으로 프로파일을 정렬한 다음, 가장 중요한 10개의 줄만 인쇄합니다. 시간이 걸리는 알고리즘을 이해하려면, 위의 줄을 사용하십시오.</p>
<p>어떤 함수가 많이 반복되고 많은 시간이 걸리는지 알고 싶다면, 다음을 수행하여:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="n">SortKey</span><span class="o">.</span><span class="n">TIME</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>각 함수 내에서 소비한 시간에 따라 정렬한 다음, 상위 10개 함수에 대한 통계를 인쇄하십시오.</p>
<p>다음과 같은 것도 시도해 볼 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="n">SortKey</span><span class="o">.</span><span class="n">FILENAME</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="s1">&#39;__init__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>이렇게하면 모든 통계가 파일 이름으로 정렬된 다음, 클래스 초기화(init) 메서드에 대한 통계만 인쇄됩니다 (이들의 철자가 <code class="docutils literal notranslate"><span class="pre">__init__</span></code>이기 때문입니다). 마지막 예로, 다음을 시도해 볼 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="n">SortKey</span><span class="o">.</span><span class="n">TIME</span><span class="p">,</span> <span class="n">SortKey</span><span class="o">.</span><span class="n">CUMULATIVE</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;init&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>이 줄은 주 시간 키와 누적 시간 보조 키로 통계를 정렬한 다음, 일부 통계를 인쇄합니다. 구체적으로, 목록을 먼저 원래 크기의 50%(<code class="docutils literal notranslate"><span class="pre">.5</span></code>)로 줄인 다음, <code class="docutils literal notranslate"><span class="pre">init</span></code>를 포함하는 줄만 유지되고, 그 서브 서브 목록이 인쇄됩니다.</p>
<p>어떤 함수가 위의 함수를 호출했는지 궁금하다면, 이제 다음과 같이 할 수 있습니다 (<code class="docutils literal notranslate"><span class="pre">p</span></code>는 여전히 마지막 기준에 따라 정렬됩니다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">print_callers</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;init&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>그러면 나열된 각 함수에 대한 호출자 목록을 얻습니다.</p>
<p>더 많은 기능을 원하면, 매뉴얼을 읽거나, 다음 함수가 무엇인지 추측하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">print_callees</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;restats&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>스크립트로 호출될 때, <a class="reference internal" href="#module-pstats" title="pstats: Statistics object for use with the profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pstats</span></code></a> 모듈은 프로파일 덤프를 읽고 검사하기위한 통계 브라우저입니다. 간단한 줄 지향 인터페이스(<a class="reference internal" href="cmd.html#module-cmd" title="cmd: Build line-oriented command interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmd</span></code></a>를 사용하여 구현되었습니다)와 대화식 도움말이 있습니다.</p>
</div>
<div class="section" id="module-cProfile">
<span id="profile-and-cprofile-module-reference"></span><h2><a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>과 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a> 모듈 레퍼런스<a class="headerlink" href="#module-cProfile" title="제목 주소">¶</a></h2>
<span class="target" id="module-profile"></span><p><a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>과 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a> 모듈은 모두 다음 함수를 제공합니다:</p>
<dl class="function">
<dt id="profile.run">
<code class="sig-prename descclassname">profile.</code><code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">command</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">sort=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.run" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 함수에 전달할 수 있는 단일 인자와 선택적 파일 이름을 취합니다. 모든 경우에 이 루틴은 다음을 실행합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">exec</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">__main__</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">,</span> <span class="n">__main__</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
</pre></div>
</div>
<p>그리고 실행으로부터 프로파일링 통계를 수집합니다. 파일 이름이 없으면, 이 함수는 자동으로 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 인스턴스를 만들고 간단한 프로파일링 보고서를 인쇄합니다. 정렬 값이 지정되면, 이 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 인스턴스로 전달되어 결과 정렬 방법을 제어합니다.</p>
</dd></dl>

<dl class="function">
<dt id="profile.runctx">
<code class="sig-prename descclassname">profile.</code><code class="sig-name descname">runctx</code><span class="sig-paren">(</span><em class="sig-param">command</em>, <em class="sig-param">globals</em>, <em class="sig-param">locals</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">sort=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.runctx" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="#profile.run" title="profile.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>과 유사하며, <em>command</em> 문자열에 대한 전역(globals)과 지역(locals) 딕셔너리를 제공하기 위한 인자가 추가되었습니다. 이 루틴은 다음을 실행합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">exec</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="nb">globals</span><span class="p">,</span> <span class="nb">locals</span><span class="p">)</span>
</pre></div>
</div>
<p>그리고 위의 <a class="reference internal" href="#profile.run" title="profile.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> 함수에서와 같이 프로파일링 통계를 수집합니다.</p>
</dd></dl>

<dl class="class">
<dt id="profile.Profile">
<em class="property">class </em><code class="sig-prename descclassname">profile.</code><code class="sig-name descname">Profile</code><span class="sig-paren">(</span><em class="sig-param">timer=None</em>, <em class="sig-param">timeunit=0.0</em>, <em class="sig-param">subcalls=True</em>, <em class="sig-param">builtins=True</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 일반적으로 <code class="xref py py-func docutils literal notranslate"><span class="pre">cProfile.run()</span></code> 함수가 제공하는 것보다 프로파일링에 대한 더 세밀한 제어가 필요할 때만 사용됩니다.</p>
<p><em>timer</em> 인자를 통해 코드를 실행하는 데 걸리는 시간을 측정하기 위한 사용자 정의 타이머를 제공할 수 있습니다. 현재 시간을 나타내는 단일 숫자를 반환하는 함수 여야합니다. 숫자가 정수이면, <em>timeunit</em>는 각 시간 단위의 지속 시간을 지정하는 승수를 지정합니다. 예를 들어, 타이머가 밀리초 단위로 측정된 시간을 반환하면 시간 단위는 <code class="docutils literal notranslate"><span class="pre">.001</span></code>입니다.</p>
<p><a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">Profile</span></code></a> 클래스를 직접 사용하면 프로파일 데이터를 파일에 쓰지 않고도 프로파일 결과를 포맷할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cProfile</span><span class="o">,</span> <span class="nn">pstats</span><span class="o">,</span> <span class="nn">io</span>
<span class="kn">from</span> <span class="nn">pstats</span> <span class="k">import</span> <span class="n">SortKey</span>
<span class="n">pr</span> <span class="o">=</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
<span class="n">pr</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
<span class="c1"># ... 뭔가 합니다 ...</span>
<span class="n">pr</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
<span class="n">sortby</span> <span class="o">=</span> <span class="n">SortKey</span><span class="o">.</span><span class="n">CUMULATIVE</span>
<span class="n">ps</span> <span class="o">=</span> <span class="n">pstats</span><span class="o">.</span><span class="n">Stats</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="n">sortby</span><span class="p">)</span>
<span class="n">ps</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>
</pre></div>
</div>
<p><a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">Profile</span></code></a> 클래스는 컨텍스트 관리자로도 사용될 수 있습니다 (<a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a> 모듈에서만 지원됩니다. <a class="reference internal" href="stdtypes.html#typecontextmanager"><span class="std std-ref">컨텍스트 관리자 형</span></a>을 참조하십시오):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cProfile</span>

<span class="k">with</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span> <span class="k">as</span> <span class="n">pr</span><span class="p">:</span>
    <span class="c1"># ... 뭔가 합니다 ...</span>

<span class="n">pr</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>컨텍스트 관리자 지원이 추가되었습니다.</p>
</div>
<dl class="method">
<dt id="profile.Profile.enable">
<code class="sig-name descname">enable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.enable" title="정의 주소">¶</a></dt>
<dd><p>프로파일링 데이터 수집을 시작합니다. <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>에만 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.disable">
<code class="sig-name descname">disable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.disable" title="정의 주소">¶</a></dt>
<dd><p>프로파일링 데이터 수집을 중지합니다. <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>에만 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.create_stats">
<code class="sig-name descname">create_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.create_stats" title="정의 주소">¶</a></dt>
<dd><p>프로파일링 데이터 수집을 중지하고 결과를 내부적으로 현재 프로파일로 기록합니다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.print_stats">
<code class="sig-name descname">print_stats</code><span class="sig-paren">(</span><em class="sig-param">sort=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.print_stats" title="정의 주소">¶</a></dt>
<dd><p>현재 프로파일을 기반으로 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 객체를 만들고 결과를 stdout에 인쇄합니다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.dump_stats">
<code class="sig-name descname">dump_stats</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.dump_stats" title="정의 주소">¶</a></dt>
<dd><p>현재 프로파일의 결과를 <em>filename</em>에 씁니다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.run" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a>를 통해 cmd를 프로파일합니다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.runctx">
<code class="sig-name descname">runctx</code><span class="sig-paren">(</span><em class="sig-param">cmd</em>, <em class="sig-param">globals</em>, <em class="sig-param">locals</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.runctx" title="정의 주소">¶</a></dt>
<dd><p>지정된 전역과 지역 환경으로 <a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a>를 통해 cmd를 프로파일합니다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.runcall">
<code class="sig-name descname">runcall</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.runcall" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">func(*args,</span> <span class="pre">**kwargs)</span></code>를 프로파일합니다</p>
</dd></dl>

</dd></dl>

<p>프로파일링은 호출된 명령/함수가 실제로 반환하는 경우에만 작동함에 유의하십시오. 인터프리터가 종료되면 (예를 들어 호출된 명령/함수 실행 중 <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> 호출을 통해) 아무런 프로파일링 결과도 인쇄되지 않습니다.</p>
</div>
<div class="section" id="the-stats-class">
<span id="profile-stats"></span><h2><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스<a class="headerlink" href="#the-stats-class" title="제목 주소">¶</a></h2>
<p>Analysis of the profiler data is done using the <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> class.</p>
<span class="target" id="module-pstats"></span><dl class="class">
<dt id="pstats.Stats">
<em class="property">class </em><code class="sig-prename descclassname">pstats.</code><code class="sig-name descname">Stats</code><span class="sig-paren">(</span><em class="sig-param">*filenames or profile</em>, <em class="sig-param">stream=sys.stdout</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats" title="정의 주소">¶</a></dt>
<dd><p>This class constructor creates an instance of a &quot;statistics object&quot; from a
<em>filename</em> (or list of filenames) or from a <code class="xref py py-class docutils literal notranslate"><span class="pre">Profile</span></code> instance. Output
will be printed to the stream specified by <em>stream</em>.</p>
<p>The file selected by the above constructor must have been created by the
corresponding version of <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> or <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>.  To be specific,
there is <em>no</em> file compatibility guaranteed with future versions of this
profiler, and there is no compatibility with files produced by other
profilers, or the same profiler run on a different operating system.  If
several files are provided, all the statistics for identical functions will
be coalesced, so that an overall view of several processes can be considered
in a single report.  If additional files need to be combined with data in an
existing <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> object, the <a class="reference internal" href="#pstats.Stats.add" title="pstats.Stats.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a> method
can be used.</p>
<p>Instead of reading the profile data from a file, a <code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code>
or <a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">profile.Profile</span></code></a> object can be used as the profile data source.</p>
<p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> objects have the following methods:</p>
<dl class="method">
<dt id="pstats.Stats.strip_dirs">
<code class="sig-name descname">strip_dirs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.strip_dirs" title="정의 주소">¶</a></dt>
<dd><p>This method for the <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> class removes all leading path
information from file names.  It is very useful in reducing the size of
the printout to fit within (close to) 80 columns.  This method modifies
the object, and the stripped information is lost.  After performing a
strip operation, the object is considered to have its entries in a
&quot;random&quot; order, as it was just after object initialization and loading.
If <a class="reference internal" href="#pstats.Stats.strip_dirs" title="pstats.Stats.strip_dirs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strip_dirs()</span></code></a> causes two function names to be
indistinguishable (they are on the same line of the same filename, and
have the same function name), then the statistics for these two entries
are accumulated into a single entry.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">*filenames</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.add" title="정의 주소">¶</a></dt>
<dd><p>This method of the <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> class accumulates additional profiling
information into the current profiling object.  Its arguments should refer
to filenames created by the corresponding version of <a class="reference internal" href="#profile.run" title="profile.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">profile.run()</span></code></a>
or <code class="xref py py-func docutils literal notranslate"><span class="pre">cProfile.run()</span></code>. Statistics for identically named (re: file, line,
name) functions are automatically accumulated into single function
statistics.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.dump_stats">
<code class="sig-name descname">dump_stats</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.dump_stats" title="정의 주소">¶</a></dt>
<dd><p>Save the data loaded into the <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> object to a file named
<em>filename</em>.  The file is created if it does not exist, and is overwritten
if it already exists.  This is equivalent to the method of the same name
on the <a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">profile.Profile</span></code></a> and <code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code> classes.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.sort_stats">
<code class="sig-name descname">sort_stats</code><span class="sig-paren">(</span><em class="sig-param">*keys</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.sort_stats" title="정의 주소">¶</a></dt>
<dd><p>This method modifies the <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> object by sorting it according to
the supplied criteria.  The argument can be either a string or a SortKey
enum identifying the basis of a sort (example: <code class="docutils literal notranslate"><span class="pre">'time'</span></code>, <code class="docutils literal notranslate"><span class="pre">'name'</span></code>,
<code class="docutils literal notranslate"><span class="pre">SortKey.TIME</span></code> or <code class="docutils literal notranslate"><span class="pre">SortKey.NAME</span></code>). The SortKey enums argument have
advantage over the string argument in that it is more robust and less
error prone.</p>
<p>When more than one key is provided, then additional keys are used as
secondary criteria when there is equality in all keys selected before
them.  For example, <code class="docutils literal notranslate"><span class="pre">sort_stats(SortKey.NAME,</span> <span class="pre">SortKey.FILE)</span></code> will sort
all the entries according to their function name, and resolve all ties
(identical function names) by sorting by file name.</p>
<p>For the string argument, abbreviations can be used for any key names, as
long as the abbreviation is unambiguous.</p>
<p>The following are the valid string and SortKey:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 34%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Valid String Arg</p></th>
<th class="head"><p>Valid enum Arg</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'calls'</span></code></p></td>
<td><p>SortKey.CALLS</p></td>
<td><p>call count</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'cumulative'</span></code></p></td>
<td><p>SortKey.CUMULATIVE</p></td>
<td><p>cumulative time</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'cumtime'</span></code></p></td>
<td><p>N/A</p></td>
<td><p>cumulative time</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'file'</span></code></p></td>
<td><p>N/A</p></td>
<td><p>file name</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'filename'</span></code></p></td>
<td><p>SortKey.FILENAME</p></td>
<td><p>file name</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'module'</span></code></p></td>
<td><p>N/A</p></td>
<td><p>file name</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'ncalls'</span></code></p></td>
<td><p>N/A</p></td>
<td><p>call count</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'pcalls'</span></code></p></td>
<td><p>SortKey.PCALLS</p></td>
<td><p>primitive call count</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'line'</span></code></p></td>
<td><p>SortKey.LINE</p></td>
<td><p>line number</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'name'</span></code></p></td>
<td><p>SortKey.NAME</p></td>
<td><p>function name</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'nfl'</span></code></p></td>
<td><p>SortKey.NFL</p></td>
<td><p>name/file/line</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'stdname'</span></code></p></td>
<td><p>SortKey.STDNAME</p></td>
<td><p>standard name</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'time'</span></code></p></td>
<td><p>SortKey.TIME</p></td>
<td><p>internal time</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'tottime'</span></code></p></td>
<td><p>N/A</p></td>
<td><p>internal time</p></td>
</tr>
</tbody>
</table>
<p>Note that all sorts on statistics are in descending order (placing most
time consuming items first), where as name, file, and line number searches
are in ascending order (alphabetical). The subtle distinction between
<code class="docutils literal notranslate"><span class="pre">SortKey.NFL</span></code> and <code class="docutils literal notranslate"><span class="pre">SortKey.STDNAME</span></code> is that the standard name is a
sort of the name as printed, which means that the embedded line numbers
get compared in an odd way.  For example, lines 3, 20, and 40 would (if
the file names were the same) appear in the string order 20, 3 and 40.
In contrast, <code class="docutils literal notranslate"><span class="pre">SortKey.NFL</span></code> does a numeric compare of the line numbers.
In fact, <code class="docutils literal notranslate"><span class="pre">sort_stats(SortKey.NFL)</span></code> is the same as
<code class="docutils literal notranslate"><span class="pre">sort_stats(SortKey.NAME,</span> <span class="pre">SortKey.FILENAME,</span> <span class="pre">SortKey.LINE)</span></code>.</p>
<p>For backward-compatibility reasons, the numeric arguments <code class="docutils literal notranslate"><span class="pre">-1</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span></code>,
<code class="docutils literal notranslate"><span class="pre">1</span></code>, and <code class="docutils literal notranslate"><span class="pre">2</span></code> are permitted.  They are interpreted as <code class="docutils literal notranslate"><span class="pre">'stdname'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'calls'</span></code>, <code class="docutils literal notranslate"><span class="pre">'time'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'cumulative'</span></code> respectively.  If this old
style format (numeric) is used, only one sort key (the numeric key) will
be used, and additional arguments will be silently ignored.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span>Added the SortKey enum.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.reverse_order">
<code class="sig-name descname">reverse_order</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.reverse_order" title="정의 주소">¶</a></dt>
<dd><p>This method for the <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> class reverses the ordering of the
basic list within the object.  Note that by default ascending vs
descending order is properly selected based on the sort key of choice.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.print_stats">
<code class="sig-name descname">print_stats</code><span class="sig-paren">(</span><em class="sig-param">*restrictions</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.print_stats" title="정의 주소">¶</a></dt>
<dd><p>This method for the <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> class prints out a report as described
in the <a class="reference internal" href="#profile.run" title="profile.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">profile.run()</span></code></a> definition.</p>
<p>The order of the printing is based on the last
<a class="reference internal" href="#pstats.Stats.sort_stats" title="pstats.Stats.sort_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_stats()</span></code></a> operation done on the object (subject to
caveats in <a class="reference internal" href="#pstats.Stats.add" title="pstats.Stats.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a> and
<a class="reference internal" href="#pstats.Stats.strip_dirs" title="pstats.Stats.strip_dirs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strip_dirs()</span></code></a>).</p>
<p>The arguments provided (if any) can be used to limit the list down to the
significant entries.  Initially, the list is taken to be the complete set
of profiled functions.  Each restriction is either an integer (to select a
count of lines), or a decimal fraction between 0.0 and 1.0 inclusive (to
select a percentage of lines), or a string that will interpreted as a
regular expression (to pattern match the standard name that is printed).
If several restrictions are provided, then they are applied sequentially.
For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">print_stats</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;foo:&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>would first limit the printing to first 10% of list, and then only print
functions that were part of filename <code class="file docutils literal notranslate"><span class="pre">.*foo:</span></code>.  In contrast, the
command:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">print_stats</span><span class="p">(</span><span class="s1">&#39;foo:&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>would limit the list to all functions having file names <code class="file docutils literal notranslate"><span class="pre">.*foo:</span></code>,
and then proceed to only print the first 10% of them.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.print_callers">
<code class="sig-name descname">print_callers</code><span class="sig-paren">(</span><em class="sig-param">*restrictions</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.print_callers" title="정의 주소">¶</a></dt>
<dd><p>This method for the <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> class prints a list of all functions
that called each function in the profiled database.  The ordering is
identical to that provided by <a class="reference internal" href="#pstats.Stats.print_stats" title="pstats.Stats.print_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">print_stats()</span></code></a>, and the
definition of the restricting argument is also identical.  Each caller is
reported on its own line.  The format differs slightly depending on the
profiler that produced the stats:</p>
<ul class="simple">
<li><p>With <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>, a number is shown in parentheses after each caller
to show how many times this specific call was made.  For convenience, a
second non-parenthesized number repeats the cumulative time spent in the
function at the right.</p></li>
<li><p>With <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>, each caller is preceded by three numbers: the
number of times this specific call was made, and the total and
cumulative times spent in the current function while it was invoked by
this specific caller.</p></li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.print_callees">
<code class="sig-name descname">print_callees</code><span class="sig-paren">(</span><em class="sig-param">*restrictions</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.print_callees" title="정의 주소">¶</a></dt>
<dd><p>This method for the <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> class prints a list of all function
that were called by the indicated function.  Aside from this reversal of
direction of calls (re: called vs was called by), the arguments and
ordering are identical to the <a class="reference internal" href="#pstats.Stats.print_callers" title="pstats.Stats.print_callers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">print_callers()</span></code></a> method.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="what-is-deterministic-profiling">
<span id="deterministic-profiling"></span><h2>What Is Deterministic Profiling?<a class="headerlink" href="#what-is-deterministic-profiling" title="제목 주소">¶</a></h2>
<p><em class="dfn">Deterministic profiling</em> is meant to reflect the fact that all <em>function
call</em>, <em>function return</em>, and <em>exception</em> events are monitored, and precise
timings are made for the intervals between these events (during which time the
user's code is executing).  In contrast, <em class="dfn">statistical profiling</em> (which is
not done by this module) randomly samples the effective instruction pointer, and
deduces where time is being spent.  The latter technique traditionally involves
less overhead (as the code does not need to be instrumented), but provides only
relative indications of where time is being spent.</p>
<p>In Python, since there is an interpreter active during execution, the presence
of instrumented code is not required in order to do deterministic profiling.
Python automatically provides a <em class="dfn">hook</em> (optional callback) for each event.
In addition, the interpreted nature of Python tends to add so much overhead to
execution, that deterministic profiling tends to only add small processing
overhead in typical applications.  The result is that deterministic profiling is
not that expensive, yet provides extensive run time statistics about the
execution of a Python program.</p>
<p>Call count statistics can be used to identify bugs in code (surprising counts),
and to identify possible inline-expansion points (high call counts).  Internal
time statistics can be used to identify &quot;hot loops&quot; that should be carefully
optimized.  Cumulative time statistics should be used to identify high level
errors in the selection of algorithms.  Note that the unusual handling of
cumulative times in this profiler allows statistics for recursive
implementations of algorithms to be directly compared to iterative
implementations.</p>
</div>
<div class="section" id="limitations">
<span id="profile-limitations"></span><h2>Limitations<a class="headerlink" href="#limitations" title="제목 주소">¶</a></h2>
<p>One limitation has to do with accuracy of timing information. There is a
fundamental problem with deterministic profilers involving accuracy.  The most
obvious restriction is that the underlying &quot;clock&quot; is only ticking at a rate
(typically) of about .001 seconds.  Hence no measurements will be more accurate
than the underlying clock.  If enough measurements are taken, then the &quot;error&quot;
will tend to average out. Unfortunately, removing this first error induces a
second source of error.</p>
<p>The second problem is that it &quot;takes a while&quot; from when an event is dispatched
until the profiler's call to get the time actually <em>gets</em> the state of the
clock.  Similarly, there is a certain lag when exiting the profiler event
handler from the time that the clock's value was obtained (and then squirreled
away), until the user's code is once again executing.  As a result, functions
that are called many times, or call many functions, will typically accumulate
this error. The error that accumulates in this fashion is typically less than
the accuracy of the clock (less than one clock tick), but it <em>can</em> accumulate
and become very significant.</p>
<p>The problem is more important with <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> than with the lower-overhead
<a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>.  For this reason, <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> provides a means of
calibrating itself for a given platform so that this error can be
probabilistically (on the average) removed. After the profiler is calibrated, it
will be more accurate (in a least square sense), but it will sometimes produce
negative numbers (when call counts are exceptionally low, and the gods of
probability work against you :-). )  Do <em>not</em> be alarmed by negative numbers in
the profile.  They should <em>only</em> appear if you have calibrated your profiler,
and the results are actually better than without calibration.</p>
</div>
<div class="section" id="calibration">
<span id="profile-calibration"></span><h2>Calibration<a class="headerlink" href="#calibration" title="제목 주소">¶</a></h2>
<p>The profiler of the <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> module subtracts a constant from each event
handling time to compensate for the overhead of calling the time function, and
socking away the results.  By default, the constant is 0. The following
procedure can be used to obtain a better constant for a given platform (see
<a class="reference internal" href="#profile-limitations"><span class="std std-ref">Limitations</span></a>).</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">profile</span>
<span class="n">pr</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pr</span><span class="o">.</span><span class="n">calibrate</span><span class="p">(</span><span class="mi">10000</span><span class="p">))</span>
</pre></div>
</div>
<p>The method executes the number of Python calls given by the argument, directly
and again under the profiler, measuring the time for both. It then computes the
hidden overhead per profiler event, and returns that as a float.  For example,
on a 1.8Ghz Intel Core i5 running Mac OS X, and using Python's time.process_time() as
the timer, the magical number is about 4.04e-6.</p>
<p>The object of this exercise is to get a fairly consistent result. If your
computer is <em>very</em> fast, or your timer function has poor resolution, you might
have to pass 100000, or even 1000000, to get consistent results.</p>
<p>When you have a consistent answer, there are three ways you can use it:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">profile</span>

<span class="c1"># 1. Apply computed bias to all Profile instances created hereafter.</span>
<span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">your_computed_bias</span>

<span class="c1"># 2. Apply computed bias to a specific Profile instance.</span>
<span class="n">pr</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
<span class="n">pr</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">your_computed_bias</span>

<span class="c1"># 3. Specify computed bias in instance constructor.</span>
<span class="n">pr</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="p">(</span><span class="n">bias</span><span class="o">=</span><span class="n">your_computed_bias</span><span class="p">)</span>
</pre></div>
</div>
<p>If you have a choice, you are better off choosing a smaller constant, and then
your results will &quot;less often&quot; show up as negative in profile statistics.</p>
</div>
<div class="section" id="using-a-custom-timer">
<span id="profile-timers"></span><h2>Using a custom timer<a class="headerlink" href="#using-a-custom-timer" title="제목 주소">¶</a></h2>
<p>If you want to change how current time is determined (for example, to force use
of wall-clock time or elapsed process time), pass the timing function you want
to the <code class="xref py py-class docutils literal notranslate"><span class="pre">Profile</span></code> class constructor:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pr</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="p">(</span><span class="n">your_time_func</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting profiler will then call <code class="docutils literal notranslate"><span class="pre">your_time_func</span></code>. Depending on whether
you are using <a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">profile.Profile</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code>,
<code class="docutils literal notranslate"><span class="pre">your_time_func</span></code>'s return value will be interpreted differently:</p>
<dl>
<dt><a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">profile.Profile</span></code></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">your_time_func</span></code> should return a single number, or a list of numbers whose
sum is the current time (like what <a class="reference internal" href="os.html#os.times" title="os.times"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.times()</span></code></a> returns).  If the
function returns a single time number, or the list of returned numbers has
length 2, then you will get an especially fast version of the dispatch
routine.</p>
<p>Be warned that you should calibrate the profiler class for the timer function
that you choose (see <a class="reference internal" href="#profile-calibration"><span class="std std-ref">Calibration</span></a>).  For most machines, a timer
that returns a lone integer value will provide the best results in terms of
low overhead during profiling.  (<a class="reference internal" href="os.html#os.times" title="os.times"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.times()</span></code></a> is <em>pretty</em> bad, as it
returns a tuple of floating point values).  If you want to substitute a
better timer in the cleanest fashion, derive a class and hardwire a
replacement dispatch method that best handles your timer call, along with the
appropriate calibration constant.</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">your_time_func</span></code> should return a single number.  If it returns integers,
you can also invoke the class constructor with a second argument specifying
the real duration of one unit of time.  For example, if
<code class="docutils literal notranslate"><span class="pre">your_integer_time_func</span></code> returns times measured in thousands of seconds,
you would construct the <code class="xref py py-class docutils literal notranslate"><span class="pre">Profile</span></code> instance as follows:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pr</span> <span class="o">=</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">(</span><span class="n">your_integer_time_func</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">)</span>
</pre></div>
</div>
<p>As the <code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code> class cannot be calibrated, custom timer
functions should be used with care and should be as fast as possible.  For
the best results with a custom timer, it might be necessary to hard-code it
in the C source of the internal <code class="xref py py-mod docutils literal notranslate"><span class="pre">_lsprof</span></code> module.</p>
</dd>
</dl>
<p>Python 3.3 adds several new functions in <a class="reference internal" href="time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a> that can be used to make
precise measurements of process or wall-clock time. For example, see
<a class="reference internal" href="time.html#time.perf_counter" title="time.perf_counter"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.perf_counter()</span></code></a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">파이썬 프로파일러</a><ul>
<li><a class="reference internal" href="#introduction-to-the-profilers">프로파일러 소개</a></li>
<li><a class="reference internal" href="#instant-user-s-manual">즉석 사용자 설명서</a></li>
<li><a class="reference internal" href="#module-cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code>과 <code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code> 모듈 레퍼런스</a></li>
<li><a class="reference internal" href="#the-stats-class"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code> 클래스</a></li>
<li><a class="reference internal" href="#what-is-deterministic-profiling">What Is Deterministic Profiling?</a></li>
<li><a class="reference internal" href="#limitations">Limitations</a></li>
<li><a class="reference internal" href="#calibration">Calibration</a></li>
<li><a class="reference internal" href="#using-a-custom-timer">Using a custom timer</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="pdb.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code> --- 파이썬 디버거</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="timeit.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">timeit</span></code> --- 작은 코드 조각의 실행 시간 측정</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="timeit.html" title="timeit --- 작은 코드 조각의 실행 시간 측정"
             >다음</a> |</li>
        <li class="right" >
          <a href="pdb.html" title="pdb --- 파이썬 디버거"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="debug.html" >디버깅과 프로파일링</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>