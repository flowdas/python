
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>파이썬 프로파일러 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="timeit --- 작은 코드 조각의 실행 시간 측정" href="timeit.html" />
    <link rel="prev" title="pdb --- 파이썬 디버거" href="pdb.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/profile.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="timeit.html" title="timeit --- 작은 코드 조각의 실행 시간 측정"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="pdb.html" title="pdb --- 파이썬 디버거"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="debug.html" accesskey="U">디버깅과 프로파일링</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-python-profilers">
<span id="profile"></span><h1>파이썬 프로파일러<a class="headerlink" href="#the-python-profilers" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/profile.py">Lib/profile.py</a> 및 <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/pstats.py">Lib/pstats.py</a></p>
<hr class="docutils" />
<div class="section" id="introduction-to-the-profilers">
<span id="profiler-introduction"></span><h2>프로파일러 소개<a class="headerlink" href="#introduction-to-the-profilers" title="제목 주소">¶</a></h2>
<p id="index-0"><a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>과 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>은 파이썬 프로그램의 <em class="dfn">결정론적 프로파일링 (deterministic profiling)</em>을 제공합니다. <em class="dfn">프로파일 (profile)</em>은 프로그램의 여러 부분이 얼마나 자주 그리고 얼마나 오랫동안 실행되었는지를 기술하는 통계 집합입니다. 이러한 통계는 <a class="reference internal" href="#module-pstats" title="pstats: Statistics object for use with the profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pstats</span></code></a> 모듈을 통해 보고서로 포매팅 할 수 있습니다.</p>
<p>파이썬 표준 라이브러리는 같은 프로파일링 인터페이스의 두 가지 구현을 제공합니다:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>이 대부분 사용자에게 권장됩니다; 오래 실행되는 프로그램을 프로파일링하는 데 적합한 합리적인 부하를 주는 C 확장입니다. Brett Rosen과 Ted Czotter가 제공한 <code class="xref py py-mod docutils literal notranslate"><span class="pre">lsprof</span></code>를 기반으로 합니다.</p></li>
<li><p><a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>은 순수 파이썬 모듈이고 이 인터페이스를 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>이 모방했습니다. 하지만, 프로파일링 되는 프로그램에 상당한 부하를 추가합니다. 어떤 방식으로 프로파일러를 확장하려고 한다면, 이 모듈을 사용하면 작업이 더 쉬울 수 있습니다. Jim Roskind가 원래 설계하고 작성했습니다.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>프로파일러 모듈은 벤치마킹 목적(이를 위해서는 합리적으로 정확한 결과를 주는 <a class="reference internal" href="timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code class="xref py py-mod docutils literal notranslate"><span class="pre">timeit</span></code></a>이 있습니다)이 아니라 주어진 프로그램에 대한 실행 프로파일을 제공하도록 설계되었습니다. 이것은 특히 C 코드에 대한 파이썬 코드 벤치마킹에 적용됩니다: 프로파일러는 파이썬 코드에 부하를 가하지만, C 수준 함수에는 그렇지 않아서 C 코드는 모든 파이썬 코드보다 빨라 보입니다.</p>
</div>
</div>
<div class="section" id="instant-user-s-manual">
<span id="profile-instant"></span><h2>즉석 사용자 설명서<a class="headerlink" href="#instant-user-s-manual" title="제목 주소">¶</a></h2>
<p>이 섹션은 &quot;설명서를 읽고 싶지 않은&quot; 사용자를 위해 제공됩니다. 매우 간단한 개요를 제공하며, 사용자가 기존 응용 프로그램에서 프로파일링을 빠르게 수행할 수 있도록 합니다.</p>
<p>단일 인자를 취하는 함수를 프로파일링하려면, 이렇게 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cProfile</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;re.compile(&quot;foo|bar&quot;)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>(시스템에서 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>을 사용할 수 없으면 대신 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>을 사용하십시오.)</p>
<p>위의 작업은 <a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>을 실행하고 다음과 같은 프로파일 결과를 인쇄합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>      <span class="mi">197</span> <span class="n">function</span> <span class="n">calls</span> <span class="p">(</span><span class="mi">192</span> <span class="n">primitive</span> <span class="n">calls</span><span class="p">)</span> <span class="ow">in</span> <span class="mf">0.002</span> <span class="n">seconds</span>

<span class="n">Ordered</span> <span class="n">by</span><span class="p">:</span> <span class="n">standard</span> <span class="n">name</span>

<span class="n">ncalls</span>  <span class="n">tottime</span>  <span class="n">percall</span>  <span class="n">cumtime</span>  <span class="n">percall</span> <span class="n">filename</span><span class="p">:</span><span class="n">lineno</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.001</span>    <span class="mf">0.001</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">1</span><span class="p">(</span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.001</span>    <span class="mf">0.001</span> <span class="n">re</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">212</span><span class="p">(</span><span class="nb">compile</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.001</span>    <span class="mf">0.001</span> <span class="n">re</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">268</span><span class="p">(</span><span class="n">_compile</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">sre_compile</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">172</span><span class="p">(</span><span class="n">_compile_charset</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">sre_compile</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">201</span><span class="p">(</span><span class="n">_optimize_charset</span><span class="p">)</span>
     <span class="mi">4</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">sre_compile</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">25</span><span class="p">(</span><span class="n">_identityfunction</span><span class="p">)</span>
   <span class="mi">3</span><span class="o">/</span><span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">sre_compile</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">33</span><span class="p">(</span><span class="n">_compile</span><span class="p">)</span>
</pre></div>
</div>
<p>첫 번째 줄은 197개의 호출이 관찰되었음을 나타냅니다. 이 호출 중 192개는 <em class="dfn">프리미티브(primitive)</em>였으며, 이는 호출이 재귀를 통해 유발되지 않았음을 의미합니다. 다음 줄: <code class="docutils literal notranslate"><span class="pre">Ordered</span> <span class="pre">by:</span> <span class="pre">standard</span> <span class="pre">name</span></code>, 은 가장 오른쪽 열의 텍스트 문자열이 출력을 정렬하는 데 사용되었음을 나타냅니다. 열 제목은 다음과 같습니다:</p>
<dl class="simple">
<dt>ncalls</dt><dd><p>호출 수.</p>
</dd>
<dt>tottime</dt><dd><p>주어진 함수에서 소비된 총 시간 (서브 함수 호출에 든 시간은 제외합니다)</p>
</dd>
<dt>percall</dt><dd><p><code class="docutils literal notranslate"><span class="pre">tottime</span></code>을 <code class="docutils literal notranslate"><span class="pre">ncalls</span></code>로 나눈 몫</p>
</dd>
<dt>cumtime</dt><dd><p>이 함수와 모든 서브 함수에서 소요된 누적 시간 (호출에서 종료까지). 이 수치는 재귀 함수에서도 <em>정확</em>합니다.</p>
</dd>
<dt>percall</dt><dd><p><code class="docutils literal notranslate"><span class="pre">cumtime</span></code>을 프리미티브 호출로 나눈 몫</p>
</dd>
<dt>filename:lineno(function)</dt><dd><p>각 함수의 해당 데이터를 제공합니다 -- 파일명:줄 번호(함수)</p>
</dd>
</dl>
<p>첫 번째 열에 두 개의 숫자가 있으면 (예를 들어 <code class="docutils literal notranslate"><span class="pre">3/1</span></code>), 함수가 재귀 되었음을 의미합니다. 두 번째 값은 프리미티브 호출 수이고 앞엣것은 총 호출 수입니다. 함수가 재귀 되지 않으면, 이 두 값은 같으며, 한 숫자만 인쇄됩니다.</p>
<p>프로파일 실행의 끝에 출력을 인쇄하는 대신, <code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code> 함수에 파일명을 지정하여 결과를 파일에 저장할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cProfile</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;re.compile(&quot;foo|bar&quot;)&#39;</span><span class="p">,</span> <span class="s1">&#39;restats&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">pstats.Stats</span></code></a> 클래스는 파일에서 프로파일 결과를 읽고 다양한 방식으로 포맷합니다.</p>
<p><a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>과 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>을 스크립트로 호출하여 다른 스크립트를 프로파일링 할 수도 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">cProfile</span> <span class="p">[</span><span class="o">-</span><span class="n">o</span> <span class="n">output_file</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">s</span> <span class="n">sort_order</span><span class="p">]</span> <span class="p">(</span><span class="o">-</span><span class="n">m</span> <span class="n">module</span> <span class="o">|</span> <span class="n">myscript</span><span class="o">.</span><span class="n">py</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-o</span></code>는 stdout 대신 파일에 프로파일 결과를 씁니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">-s</span></code>는 출력을 정렬할 <a class="reference internal" href="#pstats.Stats.sort_stats" title="pstats.Stats.sort_stats"><code class="xref py py-func docutils literal notranslate"><span class="pre">sort_stats()</span></code></a> 정렬 값 중 하나를 지정합니다. 이는 <code class="docutils literal notranslate"><span class="pre">-o</span></code>가 제공되지 않은 경우에만 적용됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">-m</span></code>은 스크립트 대신 모듈이 프로파일링 되도록 지정합니다.</p>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span><code class="docutils literal notranslate"><span class="pre">-m</span></code> 옵션을 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>에 추가했습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가: </span><code class="docutils literal notranslate"><span class="pre">-m</span></code> 옵션을 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>에 추가했습니다.</p>
</div>
</div></blockquote>
<p><a class="reference internal" href="#module-pstats" title="pstats: Statistics object for use with the profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pstats</span></code></a> 모듈의 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스에는 프로파일 결과 파일에 저장된 데이터를 조작하고 인쇄하기 위한 다양한 메서드가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pstats</span>
<span class="kn">from</span> <span class="nn">pstats</span> <span class="k">import</span> <span class="n">SortKey</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">pstats</span><span class="o">.</span><span class="n">Stats</span><span class="p">(</span><span class="s1">&#39;restats&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">strip_dirs</span><span class="p">()</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="#pstats.Stats.strip_dirs" title="pstats.Stats.strip_dirs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strip_dirs()</span></code></a> 메서드는 모든 모듈 이름에서 외부 경로를 제거했습니다. <a class="reference internal" href="#pstats.Stats.sort_stats" title="pstats.Stats.sort_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_stats()</span></code></a> 메서드는 인쇄되는 표준 모듈/줄/이름 문자열에 따라 모든 항목을 정렬했습니다. <a class="reference internal" href="#pstats.Stats.print_stats" title="pstats.Stats.print_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">print_stats()</span></code></a> 메서드는 모든 통계를 인쇄했습니다. 다음과 같은 정렬 호출을 시도할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="n">SortKey</span><span class="o">.</span><span class="n">NAME</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
</pre></div>
</div>
<p>첫 번째 호출은 실제로 함수 이름으로 목록을 정렬하고, 두 번째 호출은 통계를 인쇄합니다. 다음은 몇 가지 흥미로운 실험 호출입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="n">SortKey</span><span class="o">.</span><span class="n">CUMULATIVE</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>이것은 함수에서의 누적 시간을 기준으로 프로파일을 정렬한 다음, 가장 중요한 10개의 줄만 인쇄합니다. 시간이 걸리는 알고리즘을 이해하려면, 위의 줄을 사용하십시오.</p>
<p>어떤 함수가 많이 반복되고 많은 시간이 걸리는지 알고 싶다면, 다음을 수행하여:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="n">SortKey</span><span class="o">.</span><span class="n">TIME</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>각 함수 내에서 소비한 시간에 따라 정렬한 다음, 상위 10개 함수에 대한 통계를 인쇄하십시오.</p>
<p>다음과 같은 것도 시도해 볼 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="n">SortKey</span><span class="o">.</span><span class="n">FILENAME</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="s1">&#39;__init__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>이렇게 하면 모든 통계가 파일 이름으로 정렬된 다음, 클래스 초기화(init) 메서드에 대한 통계만 인쇄됩니다 (이들의 철자가 <code class="docutils literal notranslate"><span class="pre">__init__</span></code>이기 때문입니다). 마지막 예로, 다음을 시도해 볼 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="n">SortKey</span><span class="o">.</span><span class="n">TIME</span><span class="p">,</span> <span class="n">SortKey</span><span class="o">.</span><span class="n">CUMULATIVE</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;init&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>이 줄은 주 시간 키와 누적 시간 보조 키로 통계를 정렬한 다음, 일부 통계를 인쇄합니다. 구체적으로, 목록을 먼저 원래 크기의 50%(<code class="docutils literal notranslate"><span class="pre">.5</span></code>)로 줄인 다음, <code class="docutils literal notranslate"><span class="pre">init</span></code>를 포함하는 줄만 유지되고, 그 서브 서브 목록이 인쇄됩니다.</p>
<p>어떤 함수가 위의 함수를 호출했는지 궁금하다면, 이제 다음과 같이 할 수 있습니다 (<code class="docutils literal notranslate"><span class="pre">p</span></code>는 여전히 마지막 기준에 따라 정렬됩니다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">print_callers</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;init&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>그러면 나열된 각 함수에 대한 호출자 목록을 얻습니다.</p>
<p>더 많은 기능을 원하면, 매뉴얼을 읽거나, 다음 함수가 무엇인지 추측하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">print_callees</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;restats&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>스크립트로 호출될 때, <a class="reference internal" href="#module-pstats" title="pstats: Statistics object for use with the profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pstats</span></code></a> 모듈은 프로파일 덤프를 읽고 검사하기 위한 통계 브라우저입니다. 간단한 줄 지향 인터페이스(<a class="reference internal" href="cmd.html#module-cmd" title="cmd: Build line-oriented command interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmd</span></code></a>를 사용하여 구현되었습니다)와 대화식 도움말이 있습니다.</p>
</div>
<div class="section" id="module-cProfile">
<span id="profile-and-cprofile-module-reference"></span><h2><a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>과 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a> 모듈 레퍼런스<a class="headerlink" href="#module-cProfile" title="제목 주소">¶</a></h2>
<span class="target" id="module-profile"></span><p><a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>과 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a> 모듈은 모두 다음 함수를 제공합니다:</p>
<dl class="function">
<dt id="profile.run">
<code class="sig-prename descclassname">profile.</code><code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">command</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">sort=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.run" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 함수에 전달할 수 있는 단일 인자와 선택적 파일 이름을 취합니다. 모든 경우에 이 루틴은 다음을 실행합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">exec</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">__main__</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">,</span> <span class="n">__main__</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
</pre></div>
</div>
<p>그리고 실행으로부터 프로파일링 통계를 수집합니다. 파일 이름이 없으면, 이 함수는 자동으로 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 인스턴스를 만들고 간단한 프로파일링 보고서를 인쇄합니다. 정렬 값이 지정되면, 이 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 인스턴스로 전달되어 결과 정렬 방법을 제어합니다.</p>
</dd></dl>

<dl class="function">
<dt id="profile.runctx">
<code class="sig-prename descclassname">profile.</code><code class="sig-name descname">runctx</code><span class="sig-paren">(</span><em class="sig-param">command</em>, <em class="sig-param">globals</em>, <em class="sig-param">locals</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">sort=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.runctx" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="#profile.run" title="profile.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>과 유사하며, <em>command</em> 문자열에 대한 전역(globals)과 지역(locals) 딕셔너리를 제공하기 위한 인자가 추가되었습니다. 이 루틴은 다음을 실행합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">exec</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="nb">globals</span><span class="p">,</span> <span class="nb">locals</span><span class="p">)</span>
</pre></div>
</div>
<p>그리고 위의 <a class="reference internal" href="#profile.run" title="profile.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> 함수에서와같이 프로파일링 통계를 수집합니다.</p>
</dd></dl>

<dl class="class">
<dt id="profile.Profile">
<em class="property">class </em><code class="sig-prename descclassname">profile.</code><code class="sig-name descname">Profile</code><span class="sig-paren">(</span><em class="sig-param">timer=None</em>, <em class="sig-param">timeunit=0.0</em>, <em class="sig-param">subcalls=True</em>, <em class="sig-param">builtins=True</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile" title="정의 주소">¶</a></dt>
<dd><p>이 클래스는 일반적으로 <code class="xref py py-func docutils literal notranslate"><span class="pre">cProfile.run()</span></code> 함수가 제공하는 것보다 프로파일링에 대한 더 세밀한 제어가 필요할 때만 사용됩니다.</p>
<p><em>timer</em> 인자를 통해 코드를 실행하는 데 걸리는 시간을 측정하기 위한 사용자 정의 타이머를 제공할 수 있습니다. 현재 시각을 나타내는 단일 숫자를 반환하는 함수여야 합니다. 숫자가 정수이면, <em>timeunit</em>는 각 시간 단위의 지속 시간을 지정하는 승수를 지정합니다. 예를 들어, 타이머가 밀리초 단위로 측정된 시간을 반환하면 시간 단위는 <code class="docutils literal notranslate"><span class="pre">.001</span></code>입니다.</p>
<p><a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">Profile</span></code></a> 클래스를 직접 사용하면 프로파일 데이터를 파일에 쓰지 않고도 프로파일 결과를 포맷할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cProfile</span><span class="o">,</span> <span class="nn">pstats</span><span class="o">,</span> <span class="nn">io</span>
<span class="kn">from</span> <span class="nn">pstats</span> <span class="k">import</span> <span class="n">SortKey</span>
<span class="n">pr</span> <span class="o">=</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
<span class="n">pr</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
<span class="c1"># ... 뭔가 합니다 ...</span>
<span class="n">pr</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
<span class="n">sortby</span> <span class="o">=</span> <span class="n">SortKey</span><span class="o">.</span><span class="n">CUMULATIVE</span>
<span class="n">ps</span> <span class="o">=</span> <span class="n">pstats</span><span class="o">.</span><span class="n">Stats</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="n">sortby</span><span class="p">)</span>
<span class="n">ps</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>
</pre></div>
</div>
<p><a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">Profile</span></code></a> 클래스는 컨텍스트 관리자로도 사용될 수 있습니다 (<a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a> 모듈에서만 지원됩니다. <a class="reference internal" href="stdtypes.html#typecontextmanager"><span class="std std-ref">컨텍스트 관리자 형</span></a>을 참조하십시오):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cProfile</span>

<span class="k">with</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span> <span class="k">as</span> <span class="n">pr</span><span class="p">:</span>
    <span class="c1"># ... 뭔가 합니다 ...</span>

<span class="n">pr</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>컨텍스트 관리자 지원이 추가되었습니다.</p>
</div>
<dl class="method">
<dt id="profile.Profile.enable">
<code class="sig-name descname">enable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.enable" title="정의 주소">¶</a></dt>
<dd><p>프로파일링 데이터 수집을 시작합니다. <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>에만 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.disable">
<code class="sig-name descname">disable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.disable" title="정의 주소">¶</a></dt>
<dd><p>프로파일링 데이터 수집을 중지합니다. <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>에만 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.create_stats">
<code class="sig-name descname">create_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.create_stats" title="정의 주소">¶</a></dt>
<dd><p>프로파일링 데이터 수집을 중지하고 결과를 내부적으로 현재 프로파일로 기록합니다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.print_stats">
<code class="sig-name descname">print_stats</code><span class="sig-paren">(</span><em class="sig-param">sort=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.print_stats" title="정의 주소">¶</a></dt>
<dd><p>현재 프로파일을 기반으로 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 객체를 만들고 결과를 stdout에 인쇄합니다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.dump_stats">
<code class="sig-name descname">dump_stats</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.dump_stats" title="정의 주소">¶</a></dt>
<dd><p>현재 프로파일의 결과를 <em>filename</em>에 씁니다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.run" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a>를 통해 cmd를 프로파일 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.runctx">
<code class="sig-name descname">runctx</code><span class="sig-paren">(</span><em class="sig-param">cmd</em>, <em class="sig-param">globals</em>, <em class="sig-param">locals</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.runctx" title="정의 주소">¶</a></dt>
<dd><p>지정된 전역과 지역 환경으로 <a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a>를 통해 cmd를 프로파일 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.runcall">
<code class="sig-name descname">runcall</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.runcall" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">func(*args,</span> <span class="pre">**kwargs)</span></code>를 프로파일 합니다</p>
</dd></dl>

</dd></dl>

<p>프로파일링은 호출된 명령/함수가 실제로 반환하는 경우에만 작동함에 유의하십시오. 인터프리터가 종료되면 (예를 들어 호출된 명령/함수 실행 중 <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> 호출을 통해) 아무런 프로파일링 결과도 인쇄되지 않습니다.</p>
</div>
<div class="section" id="the-stats-class">
<span id="profile-stats"></span><h2><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스<a class="headerlink" href="#the-stats-class" title="제목 주소">¶</a></h2>
<p>프로파일러 데이터의 분석은 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스를 사용하여 수행됩니다.</p>
<span class="target" id="module-pstats"></span><dl class="class">
<dt id="pstats.Stats">
<em class="property">class </em><code class="sig-prename descclassname">pstats.</code><code class="sig-name descname">Stats</code><span class="sig-paren">(</span><em class="sig-param">*filenames or profile</em>, <em class="sig-param">stream=sys.stdout</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats" title="정의 주소">¶</a></dt>
<dd><p>이 클래스 생성자는 <em>filename</em>(또는 파일명의 리스트)이나 <code class="xref py py-class docutils literal notranslate"><span class="pre">Profile</span></code> 인스턴스에서 &quot;통계 객체&quot;의 인스턴스를 만듭니다. 출력은 <em>stream</em>에 의해 지정된 스트림으로 인쇄됩니다.</p>
<p>위의 생성자에 의해 선택된 파일은 해당 버전의 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>이나 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>에 의해 만들어졌어야 합니다. 구체적으로, 이 프로파일러의 향후 버전에서 보장되는 파일 호환성은 <em>없으며</em>, 다른 프로파일러에서 생성된 파일이나 다른 운영 체제에서 실행되는 같은 프로파일러의 실행과 호환되지 않습니다. 여러 파일이 제공되면, 동일한 함수에 대한 모든 통계가 통합되므로, 여러 프로세스에 대한 전체 뷰를 단일 보고서에서 고려할 수 있습니다. 추가 파일을 기존 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 객체의 데이터와 결합해야 하면, <a class="reference internal" href="#pstats.Stats.add" title="pstats.Stats.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a> 메서드를 사용할 수 있습니다.</p>
<p>파일에서 프로파일 데이터를 읽는 대신, <code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code>이나 <a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">profile.Profile</span></code></a> 객체를 프로파일 데이터 소스로 사용할 수 있습니다.</p>
<p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 객체에는 다음과 같은 메서드가 있습니다:</p>
<dl class="method">
<dt id="pstats.Stats.strip_dirs">
<code class="sig-name descname">strip_dirs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.strip_dirs" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스에 대한 이 메서드는 파일 이름에서 모든 선행 경로 정보를 제거합니다. 80열 이내에 (가깝게) 맞게 출력물의 크기를 줄이는 데 매우 유용합니다. 이 메서드는 객체를 수정하고, 제거된 정보는 손실됩니다. 제거 조작을 수행한 후, 객체는 객체 초기화와 로드 직후와 마찬가지로 &quot;임의의&quot; 순서로 항목을 가진 것으로 간주합니다. <a class="reference internal" href="#pstats.Stats.strip_dirs" title="pstats.Stats.strip_dirs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strip_dirs()</span></code></a>로 인해 두 함수 이름이 구별할 수 없게 되면 (같은 파일 이름의 같은 줄에 있고, 함수 이름도 같습니다), 이 두 항목에 대한 통계는 단일 항목으로 누적됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">*filenames</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.add" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스의 이 메서드는 추가 프로파일링 정보를 현재 프로파일링 객체에 누적합니다. 인자는 해당 버전의 <a class="reference internal" href="#profile.run" title="profile.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">profile.run()</span></code></a>이나 <code class="xref py py-func docutils literal notranslate"><span class="pre">cProfile.run()</span></code>으로 만들어진 파일명을 참조해야 합니다. 동일한 이름을 가진 (파일, 줄, 이름) 함수에 대한 통계는 자동으로 단일 함수 통계에 축적됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.dump_stats">
<code class="sig-name descname">dump_stats</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.dump_stats" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 객체에 로드된 데이터를 <em>filename</em>이라는 파일에 저장합니다. 파일이 없으면 만들어지고, 이미 존재하면 덮어씁니다. 이것은 <a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">profile.Profile</span></code></a>과 <code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code> 클래스에 있는 같은 이름의 메서드와 동등합니다.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.sort_stats">
<code class="sig-name descname">sort_stats</code><span class="sig-paren">(</span><em class="sig-param">*keys</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.sort_stats" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 제공된 기준에 따라 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 객체를 정렬하여 수정합니다. 인자는 정렬 기준을 식별하는 문자열이나 SortKey 열거형일 수 있습니다 (예: <code class="docutils literal notranslate"><span class="pre">'time'</span></code>, <code class="docutils literal notranslate"><span class="pre">'name'</span></code>, <code class="docutils literal notranslate"><span class="pre">SortKey.TIME</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">SortKey.NAME</span></code>). SortKey 열거형 인자는 문자열 인자보다 안정적이고 에러가 적다는 점에서 문자열 인자보다 유리합니다.</p>
<p>둘 이상의 키가 제공되면, 그 앞에 선택된 모든 키가 같을 때 추가 키가 보조 기준으로 사용됩니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">sort_stats(SortKey.NAME,</span> <span class="pre">SortKey.FILE)</span></code>은 함수 이름에 따라 모든 항목을 정렬하고, 함수 이름이 같으면 파일 이름으로 정렬합니다.</p>
<p>문자열 인자의 경우, 약어가 모호하지 않은 한, 모든 키 이름에 약어를 사용할 수 있습니다.</p>
<p>유효한 문자열과 SortKey는 다음과 같습니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 34%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>유효한 문자열 인자</p></th>
<th class="head"><p>유효한 열거형 인자</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'calls'</span></code></p></td>
<td><p>SortKey.CALLS</p></td>
<td><p>호출 수</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'cumulative'</span></code></p></td>
<td><p>SortKey.CUMULATIVE</p></td>
<td><p>누적 시간</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'cumtime'</span></code></p></td>
<td><p>해당 없음</p></td>
<td><p>누적 시간</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'file'</span></code></p></td>
<td><p>해당 없음</p></td>
<td><p>파일 이름</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'filename'</span></code></p></td>
<td><p>SortKey.FILENAME</p></td>
<td><p>파일 이름</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'module'</span></code></p></td>
<td><p>해당 없음</p></td>
<td><p>파일 이름</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'ncalls'</span></code></p></td>
<td><p>해당 없음</p></td>
<td><p>호출 수</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'pcalls'</span></code></p></td>
<td><p>SortKey.PCALLS</p></td>
<td><p>프리미티브 호출 수</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'line'</span></code></p></td>
<td><p>SortKey.LINE</p></td>
<td><p>줄 번호</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'name'</span></code></p></td>
<td><p>SortKey.NAME</p></td>
<td><p>함수 이름</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'nfl'</span></code></p></td>
<td><p>SortKey.NFL</p></td>
<td><p>이름/파일/줄</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'stdname'</span></code></p></td>
<td><p>SortKey.STDNAME</p></td>
<td><p>표준 이름</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'time'</span></code></p></td>
<td><p>SortKey.TIME</p></td>
<td><p>내부 시간</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'tottime'</span></code></p></td>
<td><p>해당 없음</p></td>
<td><p>내부 시간</p></td>
</tr>
</tbody>
</table>
<p>통계의 모든 정렬은 내림차순이고 (가장 시간이 오래 걸리는 항목을 앞에 놓습니다), 이름, 파일 및 줄 번호 검색은 오름차순(알파벳 순서)임에 유의하십시오. <code class="docutils literal notranslate"><span class="pre">SortKey.NFL</span></code>과 <code class="docutils literal notranslate"><span class="pre">SortKey.STDNAME</span></code> 간의 미묘한 차이점은 표준 이름이 인쇄된 이름의 일종이라는 것입니다. 즉, 포함된 줄 번호가 이상한 방식으로 비교됩니다. 예를 들어, 줄 3, 20 및 40은 (파일 이름이 같으면) 문자열 순서 20, 3 및 40으로 나타납니다. 반면에 <code class="docutils literal notranslate"><span class="pre">SortKey.NFL</span></code>은 줄 번호를 숫자로 비교합니다. 실제로, <code class="docutils literal notranslate"><span class="pre">sort_stats(SortKey.NFL)</span></code>은 <code class="docutils literal notranslate"><span class="pre">sort_stats(SortKey.NAME,</span> <span class="pre">SortKey.FILENAME,</span> <span class="pre">SortKey.LINE)</span></code>과 같습니다.</p>
<p>이전 버전과의 호환성을 위해, 숫자 인자 <code class="docutils literal notranslate"><span class="pre">-1</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code> 및 <code class="docutils literal notranslate"><span class="pre">2</span></code>가 허용됩니다. 이들은 각각 <code class="docutils literal notranslate"><span class="pre">'stdname'</span></code>, <code class="docutils literal notranslate"><span class="pre">'calls'</span></code>, <code class="docutils literal notranslate"><span class="pre">'time'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">'cumulative'</span></code>로 해석됩니다. 이 이전 스타일 형식(숫자)을 사용하면, 오직 하나의 정렬 키(숫자키)만 사용되며, 추가 인자는 조용히 무시됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span>SortKey 열거형을 추가했습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.reverse_order">
<code class="sig-name descname">reverse_order</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.reverse_order" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스에 대한 이 메서드는 객체 내 기본 리스트의 순서를 뒤집습니다. 기본적으로 오름차순 대 내림차순은 선택한 정렬 키에 따라 올바르게 선택됨에 유의하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.print_stats">
<code class="sig-name descname">print_stats</code><span class="sig-paren">(</span><em class="sig-param">*restrictions</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.print_stats" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스에 대한 이 메서드는 <a class="reference internal" href="#profile.run" title="profile.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">profile.run()</span></code></a> 정의에 설명된 대로 보고서를 인쇄합니다.</p>
<p>인쇄 순서는 객체에서 수행된 마지막 <a class="reference internal" href="#pstats.Stats.sort_stats" title="pstats.Stats.sort_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_stats()</span></code></a> 연산을 기반으로 합니다 (<a class="reference internal" href="#pstats.Stats.add" title="pstats.Stats.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a>와 <a class="reference internal" href="#pstats.Stats.strip_dirs" title="pstats.Stats.strip_dirs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strip_dirs()</span></code></a>의 경고가 적용됩니다).</p>
<p>(있다면) 제공된 인자를 사용하여 목록을 중요한 항목으로 줄일 수 있습니다. 처음에는, 목록이 전체 프로파일링 된 함수 집합이 됩니다. 각 제한(restriction)은 정수(줄 수 선택)나 0.0과 1.0을 포함하고 그사이의 십진 소수(줄의 백분율을 선택), 또는 정규식으로 해석되는 문자열(인쇄되는 표준 이름과 일치하는 패턴)입니다. 여러 제한이 제공되면, 순차적으로 적용됩니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">print_stats</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;foo:&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>는 먼저 인쇄를 목록의 처음 10%로 제한한 다음, 파일 이름 <code class="file docutils literal notranslate"><span class="pre">.*foo:</span></code>의 일부인 함수만 인쇄합니다. 대조적으로, 명령:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">print_stats</span><span class="p">(</span><span class="s1">&#39;foo:&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>은 파일 이름이 <code class="file docutils literal notranslate"><span class="pre">.*foo:</span></code> 인 모든 함수로 목록을 제한한 다음, 그중 처음 10%만 인쇄합니다.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.print_callers">
<code class="sig-name descname">print_callers</code><span class="sig-paren">(</span><em class="sig-param">*restrictions</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.print_callers" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스에 대한 이 메서드는 프로파일 된 데이터베이스에 있는 각 함수를 호출한 모든 함수의 목록을 인쇄합니다. 순서는 <a class="reference internal" href="#pstats.Stats.print_stats" title="pstats.Stats.print_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">print_stats()</span></code></a>에서 제공한 순서와 동일하며, 제한 인자의 정의도 동일합니다. 각 호출자는 개별 줄로 보고됩니다. 통계를 생성한 프로파일러에 따라 형식이 약간 다릅니다:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>을 사용하면, 각 호출자 뒤에 숫자가 괄호 안에 표시되어 이 특정 호출이 몇 번이나 되었는지 표시됩니다. 편의를 위해, 두 번째 괄호로 묶지 않은 숫자는 오른쪽에 나오는 함수에서 소비한 누적 시간을 반복합니다.</p></li>
<li><p><a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>을 사용하면, 각 호출자 앞에 세 숫자가 나옵니다: 이 특정 호출이 발생한 횟수, 이 특정 호출자가 호출한 동안 현재 함수에서 소비 한 총 및 누적 시간.</p></li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.print_callees">
<code class="sig-name descname">print_callees</code><span class="sig-paren">(</span><em class="sig-param">*restrictions</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.print_callees" title="정의 주소">¶</a></dt>
<dd><blockquote>
<div><p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스에 대한 이 메서드는 표시된 함수에 의해 호출된 모든 함수의 목록을 인쇄합니다. 이러한 호출 방향 반전(호출한 대 호출된)을 제외하고, 인자와 순서는 <a class="reference internal" href="#pstats.Stats.print_callers" title="pstats.Stats.print_callers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">print_callers()</span></code></a> 메서드와 같습니다.</p>
</div></blockquote>
<dl class="method">
<dt id="pstats.Stats.get_stats_profile">
<code class="sig-name descname">get_stats_profile</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.get_stats_profile" title="정의 주소">¶</a></dt>
<dd><p>This method returns an instance of StatsProfile, which contains a mapping
of function names to instances of FunctionProfile. Each FunctionProfile
instance holds information related to the function's profile such as how
long the function took to run, how many times it was called, etc...</p>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가: </span>Added the following dataclasses: StatsProfile, FunctionProfile.
Added the following function: get_stats_profile.</p>
</div>
</div></blockquote>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="what-is-deterministic-profiling">
<span id="deterministic-profiling"></span><h2>결정론적 프로파일링이란 무엇입니까?<a class="headerlink" href="#what-is-deterministic-profiling" title="제목 주소">¶</a></h2>
<p><em class="dfn">결정론적 프로파일링(Deterministic profiling)</em>이라는 용어는 모든 <em>함수 호출</em>, <em>함수 반환</em> 및 <em>예외</em> 이벤트가 모니터링되고, (사용자 코드가 실행되는 시간 동안) 이러한 이벤트 사이의 간격에 대한 정확한 시간 측정이 이루어진다는 사실을 반영하기 위한 것입니다. 반면에, <em class="dfn">통계적 프로파일링(statistical profiling)</em>(이 모듈에서는 수행하지 않습니다)은 유효 명령어 포인터를 무작위로 샘플링하여 시간이 소비되는 위치를 추론합니다. 후자의 기술은 전통적으로 (코드를 계측할 필요가 없기 때문에) 오버헤드가 적지만, 시간이 어디에서 소비되는지에 대한 상대적 표시만 제공합니다.</p>
<p>파이썬에서는, 실행 중에 인터프리터가 활성화되어있어서, 결정론적 프로파일링을 수행하기 위해 인스트루먼트 된 코드(instrumented code)가 필요하지 않습니다. 파이썬은 각 이벤트에 대해 자동으로 <em class="dfn">훅(hook)</em>(선택적 콜백)을 제공합니다. 또한, 파이썬의 인터프리터 적인 성격은 실행에 이미 많은 오버헤드를 추가하는 경향이 있어서, 결정론적 프로파일링은 일반적인 응용 프로그램에서 작은 처리 오버헤드만 추가하는 경향이 있습니다. 결과적으로 결정론적 프로파일링은 그다지 비싸지 않으면서도, 파이썬 프로그램의 실행에 대한 광범위한 실행 시간 통계를 제공합니다.</p>
<p>호출 수 통계를 사용하여 코드의 버그(놀랄만한 횟수)를 식별하고, 가능한 인라인 확장 지점(높은 호출 횟수)을 식별할 수 있습니다. 내부 시간 통계를 사용하여 신중하게 최적화해야 하는 &quot;핫 루프(hot loops)&quot;를 식별할 수 있습니다. 누적 시간 통계를 사용하여 알고리즘 선택에서의 고수준 에러를 식별할 수 있습니다. 이 프로파일러에서의 누적 시간의 특이한 처리는 알고리즘의 재귀 구현에 대한 통계를 반복 구현과 직접 비교할 수 있도록 함에 유의하십시오.</p>
</div>
<div class="section" id="limitations">
<span id="profile-limitations"></span><h2>한계<a class="headerlink" href="#limitations" title="제목 주소">¶</a></h2>
<p>타이밍 정보의 정확성과 관련하여 한 가지 제약이 있습니다. 정확성과 관련해서는 결정론적 프로파일러에 근본적인 문제가 있습니다. 가장 명백한 제약은 하부 &quot;시계&quot;가 (일반적으로) 약 .001 초의 속도로만 눈금이 변하는 것입니다. 따라서 하부 시계보다 더 정확한 측정은 없습니다. 충분한 측정을 수행하면, &quot;에러&quot;가 평균이 되어 사라지는 경향이 있습니다. 불행히도, 이 첫 번째 에러를 제거하면 두 번째 에러 원인이 발생합니다.</p>
<p>두 번째 문제는 이벤트가 디스패치 된 시점부터 프로파일러가 시간을 얻기 위해 호출하는 것이 실제로 시계의 상태를 <em>얻기</em>까지 &quot;시간이 걸린다&quot;는 것입니다. 마찬가지로, 프로파일러 이벤트 핸들러를 빠져나갈 때 시계값이 획득된 (그런 다음 저장됩니다) 시간부터, 사용자의 코드가 다시 실행될 때까지 어떤 지연이 발생합니다. 결과적으로, 여러 번 호출되거나, 많은 함수를 호출하는 함수는 일반적으로 이 에러를 누적합니다. 이러한 방식으로 누적되는 에러는 일반적으로 시계 정확도(1 눈금 미만)보다 작지만, 누적될 <em>수</em> 있어서 매우 중요해집니다.</p>
<p>오버헤드가 낮은 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>보다 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>에서 이 문제가 더 중요합니다. 이러한 이유로, <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>은 특정 플랫폼에 대해 자신을 보정하는 방법을 제공하여 이 에러를 확률적으로 (평균적으로) 제거할 수 있습니다. 프로파일러가 보정된 후에는, 더 정확하지만 (최소한 최소 자승의 의미에서), 때로는 음수를 생성합니다 (호출 횟수가 예외적으로 낮고, 확률의 신들이 당신에게 등을 돌리면 :-). ) 프로파일에서 음수를 보아도 너무 놀라지 <em>마십시오</em>. 프로파일러를 보정한 경우에*만* 나타나야 하며, 결과는 실제로 보정하지 않은 것보다 낫습니다.</p>
</div>
<div class="section" id="calibration">
<span id="profile-calibration"></span><h2>보정<a class="headerlink" href="#calibration" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> 모듈의 프로파일러는 각 이벤트 처리 시간에서 상수를 빼서 시간 함수 호출의 오버헤드를 보상하고, 결과를 잘 보관합니다. 기본적으로, 상수는 0입니다. 다음 절차는 주어진 플랫폼에 대해 더 나은 상수를 얻는 데 사용될 수 있습니다 (<a class="reference internal" href="#profile-limitations"><span class="std std-ref">한계</span></a>를 참조하십시오).</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">profile</span>
<span class="n">pr</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pr</span><span class="o">.</span><span class="n">calibrate</span><span class="p">(</span><span class="mi">10000</span><span class="p">))</span>
</pre></div>
</div>
<p>이 메서드는 인자가 제공한 횟수의 파이썬 호출을, 직접하고 프로파일러하에서 다시 하면서, 두 두 시간을 측정합니다. 그런 다음 프로파일러 이벤트 당 숨겨진 오버헤드를 계산하여 부동 소수점으로 반환합니다. 예를 들어, Mac OS X를 실행하는 1.8Ghz 인텔 코어 i5에서, 그리고 파이썬의 time.process_time()을 타이머로 사용할 때, 매직 넘버는 약 4.04e-6입니다.</p>
<p>이 반복의 목적은 상당히 일관된 결과를 얻는 것입니다. 컴퓨터가 <em>매우</em> 빠르거나, 타이머 함수의 해상도가 좋지 않으면, 일관된 결과를 얻기 위해 100000이나 심지어 1000000을 전달해야 할 수 있습니다.</p>
<p>일관된 대답을 얻었을 때, 세 가지 방법으로 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">profile</span>

<span class="c1"># 1. 이후에 만들어지는 모든 Profile 인스턴스에 계산된 바이어스를 적용합니다.</span>
<span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">your_computed_bias</span>

<span class="c1"># 2. 특정 Profile 인스턴스에 계산된 바이어스를 적용합니다.</span>
<span class="n">pr</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
<span class="n">pr</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">your_computed_bias</span>

<span class="c1"># 3. 인스턴스 생성자에 계산된 바이어스를 지정합니다.</span>
<span class="n">pr</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="p">(</span><span class="n">bias</span><span class="o">=</span><span class="n">your_computed_bias</span><span class="p">)</span>
</pre></div>
</div>
<p>선택해야 한다면, 더 작은 상수를 선택하는 것이 좋습니다, 그러면 결과가 프로파일 통계에서 결과가 &quot;덜 자주&quot; 음수로 표시됩니다.</p>
</div>
<div class="section" id="using-a-custom-timer">
<span id="profile-timers"></span><h2>사용자 정의 타이머 사용하기<a class="headerlink" href="#using-a-custom-timer" title="제목 주소">¶</a></h2>
<p>현재 시각을 결정하는 방법을 변경하려면 (예를 들어, 벽시계 시간이나 소요된 프로세스 시간을 사용하도록 만들려면), <code class="xref py py-class docutils literal notranslate"><span class="pre">Profile</span></code> 클래스 생성자에게 원하는 타이밍 함수를 전달합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pr</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="p">(</span><span class="n">your_time_func</span><span class="p">)</span>
</pre></div>
</div>
<p>결과 프로파일러는 <code class="docutils literal notranslate"><span class="pre">your_time_func</span></code>를 호출합니다. <a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">profile.Profile</span></code></a>이나 <code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code> 중 어느 것을 사용하느냐에 따라, <code class="docutils literal notranslate"><span class="pre">your_time_func</span></code>의 반환 값은 다르게 해석됩니다:</p>
<dl>
<dt><a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">profile.Profile</span></code></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">your_time_func</span></code>는 단일 숫자를 반환하거나, 또는 (<a class="reference internal" href="os.html#os.times" title="os.times"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.times()</span></code></a>가 반환하는 것과 같이) 합계가 현재 시각인 숫자 리스트를 반환해야 합니다. 함수가 단일 시간 숫자를 반환하거나, 반환된 숫자의 리스트 길이가 2이면, 특히 빠른 버전의 디스패치 루틴을 얻게 됩니다.</p>
<p>여러분이 선택한 타이머 함수에 대해 프로파일러 클래스를 보정해야 합니다 (<a class="reference internal" href="#profile-calibration"><span class="std std-ref">보정</span></a>을 참조하십시오). 대부분의 기계에서, 단일 정숫값을 반환하는 타이머는 프로파일링 중 낮은 오버헤드 측면에서 최상의 결과를 제공합니다. (<a class="reference internal" href="os.html#os.times" title="os.times"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.times()</span></code></a>는 부동 소수점 값의 튜플을 반환하므로 <em>꽤</em> 나쁩니다). 더 좋은 타이머를 가장 깨끗한 방식으로 대체하려면, 클래스를 파생하고 적절한 보정 상수와 함께 타이머 호출을 가장 잘 처리하는 대체 디스패치 메서드를 배선하십시오.</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">your_time_func</span></code>는 단일 숫자를 반환해야 합니다. 정수를 반환하면, 시간 단위의 실제 지속 시간을 지정하는 두 번째 인자로 클래스 생성자를 호출할 수도 있습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">your_integer_time_func</span></code>가 밀리초 단위로 측정된 시간을 반환하면, 다음과 같이 <code class="xref py py-class docutils literal notranslate"><span class="pre">Profile</span></code> 인스턴스를 구성합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pr</span> <span class="o">=</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">(</span><span class="n">your_integer_time_func</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code> 클래스를 보정할 수 없어서, 사용자 정의 타이머 함수는 주의해서 사용해야 하고 가능한 한 빨라야 합니다. 사용자 정의 타이머로 최상의 결과를 얻으려면, 내부 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_lsprof</span></code> 모듈의 C 소스에 하드 코딩해야 할 수도 있습니다.</p>
</dd>
</dl>
<p>파이썬 3.3은 <a class="reference internal" href="time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a>에 프로세스나 벽시계 시간을 정확하게 측정하는 데 사용할 수 있는 몇 가지 새로운 함수를 추가합니다. 예를 들어, <a class="reference internal" href="time.html#time.perf_counter" title="time.perf_counter"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.perf_counter()</span></code></a>를 참조하십시오.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">파이썬 프로파일러</a><ul>
<li><a class="reference internal" href="#introduction-to-the-profilers">프로파일러 소개</a></li>
<li><a class="reference internal" href="#instant-user-s-manual">즉석 사용자 설명서</a></li>
<li><a class="reference internal" href="#module-cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code>과 <code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code> 모듈 레퍼런스</a></li>
<li><a class="reference internal" href="#the-stats-class"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code> 클래스</a></li>
<li><a class="reference internal" href="#what-is-deterministic-profiling">결정론적 프로파일링이란 무엇입니까?</a></li>
<li><a class="reference internal" href="#limitations">한계</a></li>
<li><a class="reference internal" href="#calibration">보정</a></li>
<li><a class="reference internal" href="#using-a-custom-timer">사용자 정의 타이머 사용하기</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="pdb.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code> --- 파이썬 디버거</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="timeit.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">timeit</span></code> --- 작은 코드 조각의 실행 시간 측정</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="timeit.html" title="timeit --- 작은 코드 조각의 실행 시간 측정"
             >다음</a> |</li>
        <li class="right" >
          <a href="pdb.html" title="pdb --- 파이썬 디버거"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="debug.html" >디버깅과 프로파일링</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>