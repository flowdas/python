
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>test --- 파이썬 용 회귀 테스트 패키지 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="디버깅과 프로파일링" href="debug.html" />
    <link rel="prev" title="2to3 - 파이썬 2에서 파이썬 3으로 자동 코드 변환" href="2to3.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/test.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="debug.html" title="디버깅과 프로파일링"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="2to3.html" title="2to3 - 파이썬 2에서 파이썬 3으로 자동 코드 변환"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">개발 도구</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-test">
<span id="test-regression-tests-package-for-python"></span><h1><a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test</span></code></a> --- 파이썬 용 회귀 테스트 패키지<a class="headerlink" href="#module-test" title="제목 주소">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test</span></code></a> 패키지는 파이썬 내부 용으로만 사용됩니다. 파이썬의 핵심 개발자를 위해 설명됩니다. 여기에 언급된 코드는 파이썬 릴리스 사이에 예고 없이 변경되거나 제거될 수 있어서, 파이썬의 표준 라이브러리 외부에서 이 패키지를 사용하는 것은 권장되지 않습니다.</p>
</div>
<hr class="docutils" />
<p><a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test</span></code></a> 패키지에는 <a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support</span></code></a>와 <code class="xref py py-mod docutils literal notranslate"><span class="pre">test.regrtest</span></code>뿐만 아니라 파이썬에 대한 모든 회귀 테스트가 포함되어 있습니다. <a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support</span></code></a>는 테스트를 향상하는 데 사용되며 <code class="xref py py-mod docutils literal notranslate"><span class="pre">test.regrtest</span></code>는 테스트 스위트를 구동합니다.</p>
<p>이름이 <code class="docutils literal notranslate"><span class="pre">test_</span></code>로 시작하는 <a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test</span></code></a> 패키지의 각 모듈은 특정 모듈이나 기능에 대한 테스트 스위트입니다. 모든 새로운 테스트는 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>나 <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 모듈을 사용하여 작성해야 합니다. 일부 오래된 테스트는 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>으로 인쇄된 출력을 비교하는 &quot;전통적인&quot; 테스트 스타일을 사용하여 작성되었습니다; 이 테스트 스타일은 폐지된 것으로 간주합니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt>모듈 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a></dt><dd><p>PyUnit 회귀 테스트 작성.</p>
</dd>
<dt>모듈 <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a></dt><dd><p>독스트링에 포함된 테스트.</p>
</dd>
</dl>
</div>
<div class="section" id="writing-unit-tests-for-the-test-package">
<span id="writing-tests"></span><h2><a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test</span></code></a> 패키지를 위한 단위 테스트 작성하기<a class="headerlink" href="#writing-unit-tests-for-the-test-package" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 모듈을 사용하는 테스트는 몇 가지 지침을 따르는 것이 좋습니다. 하나는 테스트 모듈의 이름을 <code class="docutils literal notranslate"><span class="pre">test_</span></code>로 시작하고 테스트 중인 모듈의 이름으로 끝나도록 짓는 것입니다. 테스트 모듈의 테스트 메서드는 <code class="docutils literal notranslate"><span class="pre">test_</span></code>로 시작하고 메서드가 테스트하는 내용에 대한 설명으로 끝나야 합니다. 이는 테스트 드라이버가 메서드를 테스트 메서드로 인식하기 위해 필요합니다. 또한, 메서드에 대한 독스트링이 포함되어서는 안 됩니다. 주석(가령 <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">Tests</span> <span class="pre">function</span> <span class="pre">returns</span> <span class="pre">only</span> <span class="pre">True</span> <span class="pre">or</span> <span class="pre">False</span></code>)을 사용하여 테스트 메서드에 대한 설명을 제공해야 합니다. 이는 독스트링이 존재하면 이것이 인쇄되어 실행되는 테스트가 인쇄되지 않기 때문입니다.</p>
<p>기본 상용구가 자주 사용됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">from</span> <span class="nn">test</span> <span class="k">import</span> <span class="n">support</span>

<span class="k">class</span> <span class="nc">MyTestCase1</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="c1"># setUp()과 tearDown()은 필요할 때만 사용합니다</span>

    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span> <span class="n">테스트</span> <span class="n">준비를</span> <span class="n">위해</span> <span class="n">실행할</span> <span class="n">코드</span> <span class="o">...</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span> <span class="n">테스트</span> <span class="n">후</span> <span class="n">정리를</span> <span class="n">위해</span> <span class="n">실행할</span> <span class="n">코드</span> <span class="o">...</span>

    <span class="k">def</span> <span class="nf">test_feature_one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># feature one을 테스트합니다.</span>
        <span class="o">...</span> <span class="n">테스트</span> <span class="n">코드</span> <span class="o">...</span>

    <span class="k">def</span> <span class="nf">test_feature_two</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># feature two를 테스트합니다.</span>
        <span class="o">...</span> <span class="n">테스트</span> <span class="n">코드</span> <span class="o">...</span>

    <span class="o">...</span> <span class="n">더</span> <span class="n">많은</span> <span class="n">테스트</span> <span class="n">메서드</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">MyTestCase2</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">MyTestCase1</span> <span class="n">과</span> <span class="n">같은</span> <span class="n">구조</span> <span class="o">...</span>

<span class="o">...</span> <span class="n">더</span> <span class="n">많은</span> <span class="n">테스트</span> <span class="n">클래스</span> <span class="o">...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>이 코드 패턴을 사용하면 <code class="xref py py-mod docutils literal notranslate"><span class="pre">test.regrtest</span></code>에서 자체적으로 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> CLI를 지원하는 스크립트로나 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span></code> CLI를 통해 테스트 스위트를 실행할 수 있습니다.</p>
<p>회귀 테스트의 목표는 코드를 깨려고 시도하는 것입니다. 이는 따라야 할 몇 가지 지침으로 이어집니다:</p>
<ul>
<li><p>테스트 스위트는 모든 클래스, 함수 및 상수를 괴롭혀야 합니다. 여기에는 외부 세계에 제공되는 외부 API뿐만 아니라 &quot;내부(private)&quot; 코드도 포함됩니다.</p></li>
<li><p>화이트 박스 테스트 (테스트 작성 시 테스트 중인 코드 검사)가 선호됩니다. 블랙박스 테스트(게시된 사용자 인터페이스 만 테스트)는 모든 경계와 에지 케이스가 테스트 되었는지 확인하기에 충분하지 않습니다.</p></li>
<li><p>유효하지 않은 값을 포함하여 가능한 모든 값이 테스트 되었는지 확인하십시오. 이렇게 하면 모든 유효한 값이 받아들여질 뿐만 아니라 부적절한 값이 올바르게 처리되었는지 확인하게 됩니다.</p></li>
<li><p>가능한 한 많은 코드 경로를 소진하십시오. 분기가 발생하는 위치를 테스트하고 입력을 조정하여 코드에서 여러 경로가 사용되는지 확인합니다.</p></li>
<li><p>테스트 된 코드에 대해 발견된 버그에 대한 명시적 테스트를 추가합니다. 이렇게 하면 나중에 코드가 변경되어도 에러가 다시 발생하는지 확인합니다.</p></li>
<li><p>테스트 후에 정리해야 합니다 (가령 모든 임시 파일 닫고 제거하기).</p></li>
<li><p>테스트가 운영 체제의 특정 조건에 의존하면 테스트를 시도하기 전에 조건이 이미 존재하는지 확인하십시오.</p></li>
<li><p>가능한 한 적은 수의 모듈을 임포트 하고 가능한 한 빨리 수행하십시오. 이렇게 하면 테스트의 외부 종속성이 최소화되고 모듈 임포트의 부작용에 따른 비정상적인 동작이 최소화됩니다.</p></li>
<li><p>코드 재사용을 극대화하십시오. 때에 따라, 테스트는 사용되는 입력 유형에 따라 조금씩 달라집니다. 입력을 지정하는 클래스로 기본 테스트 클래스를 서브 클래싱하여 코드 중복을 최소화합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestFuncAcceptsSequencesMixin</span><span class="p">:</span>

    <span class="n">func</span> <span class="o">=</span> <span class="n">mySuperWhammyFunction</span>

    <span class="k">def</span> <span class="nf">test_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">AcceptLists</span><span class="p">(</span><span class="n">TestFuncAcceptsSequencesMixin</span><span class="p">,</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">AcceptStrings</span><span class="p">(</span><span class="n">TestFuncAcceptsSequencesMixin</span><span class="p">,</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span>

<span class="k">class</span> <span class="nc">AcceptTuples</span><span class="p">(</span><span class="n">TestFuncAcceptsSequencesMixin</span><span class="p">,</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>이 패턴을 사용할 때, <a class="reference internal" href="unittest.html#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a>를 상속한 모든 클래스가 테스트로 실행된다는 점을 기억하십시오. 위 예제의 <code class="xref py py-class docutils literal notranslate"><span class="pre">Mixin</span></code> 클래스는 데이터가 없어서 자체적으로 실행할 수 없기 때문에, <a class="reference internal" href="unittest.html#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a>를 상속하지 않습니다.</p>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt>테스트 주도 개발(Test Driven Development)</dt><dd><p>코드 전에 테스트를 작성하는 것에 관한 Kent Beck의 책.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="running-tests-using-the-command-line-interface">
<span id="regrtest"></span><h2>명령 줄 인터페이스를 사용하여 테스트 실행하기<a class="headerlink" href="#running-tests-using-the-command-line-interface" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 옵션 덕분에 <a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test</span></code></a> 패키지를 스크립트로 실행하여 파이썬의 회귀 테스트 스위트를 구동 할 수 있습니다: <strong class="program">python -m test</strong>. 내부적으로는 <code class="xref py py-mod docutils literal notranslate"><span class="pre">test.regrtest</span></code>를 사용합니다; 이전 파이썬 버전에서 사용된 호출 <strong class="program">python -m test.regrtest</strong>는 여전히 작동합니다. 스크립트를 단독으로 실행하면 <a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test</span></code></a> 패키지의 모든 회귀 테스트 실행이 자동으로 시작됩니다. 패키지에서 이름이 <code class="docutils literal notranslate"><span class="pre">test_</span></code>로 시작하는 모든 모듈을 찾아서, 임포트 하고, <code class="xref py py-func docutils literal notranslate"><span class="pre">test_main()</span></code> 함수가 있으면 실행하고, <code class="docutils literal notranslate"><span class="pre">test_main</span></code>이 없으면 unittest.TestLoader.loadTestsFromModule 을 통해 테스트를 로드하여 이를 수행합니다. 실행할 테스트 이름도 스크립트에 전달할 수 있습니다. 단일 회귀 테스트를 지정하면 (<strong class="program">python -m test test_spam</strong>) 출력이 최소화되고 테스트의 통과나 실패 여부만 인쇄됩니다.</p>
<p><a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test</span></code></a>를 직접 실행하면 테스트에 사용할 수 있는 리소스를 설정할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">-u</span></code> 명령 줄 옵션을 사용하여 이 작업을 수행합니다. <code class="docutils literal notranslate"><span class="pre">-u</span></code> 옵션의 값으로 <code class="docutils literal notranslate"><span class="pre">all</span></code>을 지정하면 가능한 모든 자원을 사용할 수 있습니다: <strong class="program">python -m test -uall</strong>. 하나를 제외한 모든 리소스가 필요한 경우 (더 흔한 경우입니다), 원하지 않는 리소스의 쉼표로 구분된 목록이 <code class="docutils literal notranslate"><span class="pre">all</span></code> 뒤에 나열될 수 있습니다. <strong class="program">python -m test -uall,-audio,-largefile</strong> 명령은 <code class="docutils literal notranslate"><span class="pre">audio</span></code>와 <code class="docutils literal notranslate"><span class="pre">largefile</span></code> 리소스를 제외한 모든 리소스로 <a class="reference internal" href="#module-test" title="test: Regression tests package containing the testing suite for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test</span></code></a>를 실행합니다. 모든 리소스와 추가 명령 줄 옵션 목록을 보려면, <strong class="program">python -m test -h</strong>를 실행하십시오.</p>
<p>회귀 테스트를 실행하는 다른 방법은 테스트가 실행되는 플랫폼에 따라 다릅니다. 유닉스에서는, 파이썬이 빌드된 최상위 디렉터리에서 <strong class="program">make test</strong>를 실행할 수 있습니다. 윈도우에서는, <code class="file docutils literal notranslate"><span class="pre">PCbuild</span></code> 디렉터리에서 <strong class="program">rt.bat</strong>을 실행하면 모든 회귀 테스트가 실행됩니다.</p>
</div>
</div>
<div class="section" id="module-test.support">
<span id="test-support-utilities-for-the-python-test-suite"></span><h1><a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support</span></code></a> --- 파이썬 테스트 스위트용 유틸리티<a class="headerlink" href="#module-test.support" title="제목 주소">¶</a></h1>
<p><a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support</span></code></a> 모듈은 파이썬의 회귀 테스트 스위트를 지원합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support</span></code></a>는 공용 모듈이 아닙니다. 파이썬 개발자가 테스트를 작성하는 데 도움이 되도록 여기에 설명하고 있습니다. 이 모듈의 API는 릴리스 간에 하위 호환성에 대한 고려 없이 변경될 수 있습니다.</p>
</div>
<p>이 모듈은 다음 예외를 정의합니다:</p>
<dl class="exception">
<dt id="test.support.TestFailed">
<em class="property">exception </em><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">TestFailed</code><a class="headerlink" href="#test.support.TestFailed" title="정의 주소">¶</a></dt>
<dd><p>테스트가 실패할 때 발생하는 예외. 이것은 폐지되었고 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 기반 테스트와 <a class="reference internal" href="unittest.html#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a>의 어서션 메서드로 대체합니다.</p>
</dd></dl>

<dl class="exception">
<dt id="test.support.ResourceDenied">
<em class="property">exception </em><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">ResourceDenied</code><a class="headerlink" href="#test.support.ResourceDenied" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="unittest.html#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">unittest.SkipTest</span></code></a>의 서브 클래스. 리소스(가령 네트워크 연결)를 사용할 수 없을 때 발생합니다. <a class="reference internal" href="#test.support.requires" title="test.support.requires"><code class="xref py py-func docutils literal notranslate"><span class="pre">requires()</span></code></a> 함수에 의해 발생합니다.</p>
</dd></dl>

<p><a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support</span></code></a> 모듈은 다음 상수를 정의합니다:</p>
<dl class="data">
<dt id="test.support.verbose">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">verbose</code><a class="headerlink" href="#test.support.verbose" title="정의 주소">¶</a></dt>
<dd><p>상세 출력이 활성화될 때 <code class="docutils literal notranslate"><span class="pre">True</span></code>. 실행 중인 테스트에 대한 자세한 정보가 필요할 때 확인해야 합니다. <em>verbose</em>는 <code class="xref py py-mod docutils literal notranslate"><span class="pre">test.regrtest</span></code>에 의해 설정됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.is_jython">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">is_jython</code><a class="headerlink" href="#test.support.is_jython" title="정의 주소">¶</a></dt>
<dd><p>실행 중인 인터프리터가 Jython이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.is_android">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">is_android</code><a class="headerlink" href="#test.support.is_android" title="정의 주소">¶</a></dt>
<dd><p>시스템이 안드로이드이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.unix_shell">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">unix_shell</code><a class="headerlink" href="#test.support.unix_shell" title="정의 주소">¶</a></dt>
<dd><p>윈도우가 아니면 셸 경로; 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.FS_NONASCII">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">FS_NONASCII</code><a class="headerlink" href="#test.support.FS_NONASCII" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="os.html#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsencode()</span></code></a>로 인코딩 할 수 있는 비 ASCII 문자.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.TESTFN">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">TESTFN</code><a class="headerlink" href="#test.support.TESTFN" title="정의 주소">¶</a></dt>
<dd><p>임시 파일의 이름으로 사용하기에 안전한 이름으로 설정합니다. 만들어진 모든 임시 파일은 닫히고 언 링크(제거) 되어야 합니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.TESTFN_UNICODE">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">TESTFN_UNICODE</code><a class="headerlink" href="#test.support.TESTFN_UNICODE" title="정의 주소">¶</a></dt>
<dd><p>임시 파일을 위한 비 ASCII 이름으로 설정합니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.TESTFN_ENCODING">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">TESTFN_ENCODING</code><a class="headerlink" href="#test.support.TESTFN_ENCODING" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code></a>로 설정합니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.TESTFN_UNENCODABLE">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">TESTFN_UNENCODABLE</code><a class="headerlink" href="#test.support.TESTFN_UNENCODABLE" title="정의 주소">¶</a></dt>
<dd><p>엄격(strict) 모드에서 파일 시스템 인코딩으로 인코딩할 수 없는 파일명(str 형)으로 설정합니다. 이러한 파일명을 생성할 수 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>일 수 있습니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.TESTFN_UNDECODABLE">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">TESTFN_UNDECODABLE</code><a class="headerlink" href="#test.support.TESTFN_UNDECODABLE" title="정의 주소">¶</a></dt>
<dd><p>엄격(strict) 모드에서 파일 시스템 인코딩으로 디코딩할 수 없는 파일명(bytes 형)으로 설정합니다. 이러한 파일명을 생성할 수 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>일 수 있습니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.TESTFN_NONASCII">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">TESTFN_NONASCII</code><a class="headerlink" href="#test.support.TESTFN_NONASCII" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#test.support.FS_NONASCII" title="test.support.FS_NONASCII"><code class="xref py py-data docutils literal notranslate"><span class="pre">FS_NONASCII</span></code></a> 문자를 포함하는 파일명으로 설정합니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.LOOPBACK_TIMEOUT">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">LOOPBACK_TIMEOUT</code><a class="headerlink" href="#test.support.LOOPBACK_TIMEOUT" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">127.0.0.1</span></code>과 같은 네트워크 로컬 루프 백 인터페이스에서 리스닝하는 네트워크 서버를 사용하는 테스트의 초 단위 제한 시간.</p>
<p>제한 시간은 테스트 실패를 방지 할 수 있을 만큼 깁니다: 클라이언트와 서버가 다른 스레드나 다른 프로세스에서 실행될 수 있다는 점을 고려합니다.</p>
<p>제한 시간은 <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>의 <a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a> 및 <a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 메서드를 위해 충분히 길어야 합니다.</p>
<p>기본값은 5초입니다.</p>
<p><a class="reference internal" href="#test.support.INTERNET_TIMEOUT" title="test.support.INTERNET_TIMEOUT"><code class="xref py py-data docutils literal notranslate"><span class="pre">INTERNET_TIMEOUT</span></code></a>도 참조하십시오.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.INTERNET_TIMEOUT">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">INTERNET_TIMEOUT</code><a class="headerlink" href="#test.support.INTERNET_TIMEOUT" title="정의 주소">¶</a></dt>
<dd><p>인터넷으로 가는 네트워크 요청에 대한 초 단위 제한 시간.</p>
<p>어떤 이유로 든 인터넷 요청이 블록 되면 테스트가 너무 오래 기다리지 않을 만큼 제한 시간이 적당히 짧습니다.</p>
<p>일반적으로, <a class="reference internal" href="#test.support.INTERNET_TIMEOUT" title="test.support.INTERNET_TIMEOUT"><code class="xref py py-data docutils literal notranslate"><span class="pre">INTERNET_TIMEOUT</span></code></a>을 사용하는 시간 초과는 테스트를 실패로 표시해서는 안 되며, 대신 테스트를 건너뜁니다: <a class="reference internal" href="#test.support.socket_helper.transient_internet" title="test.support.socket_helper.transient_internet"><code class="xref py py-func docutils literal notranslate"><span class="pre">transient_internet()</span></code></a>을 참조하십시오.</p>
<p>기본값은 1분입니다.</p>
<p><a class="reference internal" href="#test.support.LOOPBACK_TIMEOUT" title="test.support.LOOPBACK_TIMEOUT"><code class="xref py py-data docutils literal notranslate"><span class="pre">LOOPBACK_TIMEOUT</span></code></a>도 참조하십시오.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.SHORT_TIMEOUT">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">SHORT_TIMEOUT</code><a class="headerlink" href="#test.support.SHORT_TIMEOUT" title="정의 주소">¶</a></dt>
<dd><p>테스트가 &quot;너무 오래&quot; 걸리면 테스트를 실패로 표시하는 초 단위 제한 시간.</p>
<p>제한 시간 값은 regrtest <code class="docutils literal notranslate"><span class="pre">--timeout</span></code> 명령 줄 옵션에 따라 다릅니다.</p>
<p><a class="reference internal" href="#test.support.SHORT_TIMEOUT" title="test.support.SHORT_TIMEOUT"><code class="xref py py-data docutils literal notranslate"><span class="pre">SHORT_TIMEOUT</span></code></a>을 사용하는 테스트가 느린 빌드 봇에서 무작위로 실패하기 시작하면, 대신 <a class="reference internal" href="#test.support.LONG_TIMEOUT" title="test.support.LONG_TIMEOUT"><code class="xref py py-data docutils literal notranslate"><span class="pre">LONG_TIMEOUT</span></code></a>을 사용합니다.</p>
<p>기본값은 30초입니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.LONG_TIMEOUT">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">LONG_TIMEOUT</code><a class="headerlink" href="#test.support.LONG_TIMEOUT" title="정의 주소">¶</a></dt>
<dd><p>테스트 멈춤을 감지하기 위한 초 단위 제한 시간.</p>
<p>가장 느린 파이썬 빌드 봇에서 테스트 실패의 위험을 줄이기에 충분히 깁니다. 테스트가 &quot;너무 오래&quot; 걸리면 테스트를 실패로 표시하는 데 사용해서는 안 됩니다. 제한 시간 값은 regrtest <code class="docutils literal notranslate"><span class="pre">--timeout</span></code> 명령 줄 옵션에 따라 다릅니다.</p>
<p>기본값은 5분입니다.</p>
<p><a class="reference internal" href="#test.support.LOOPBACK_TIMEOUT" title="test.support.LOOPBACK_TIMEOUT"><code class="xref py py-data docutils literal notranslate"><span class="pre">LOOPBACK_TIMEOUT</span></code></a>, <a class="reference internal" href="#test.support.INTERNET_TIMEOUT" title="test.support.INTERNET_TIMEOUT"><code class="xref py py-data docutils literal notranslate"><span class="pre">INTERNET_TIMEOUT</span></code></a> 및 <a class="reference internal" href="#test.support.SHORT_TIMEOUT" title="test.support.SHORT_TIMEOUT"><code class="xref py py-data docutils literal notranslate"><span class="pre">SHORT_TIMEOUT</span></code></a>도 참조하십시오.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.SAVEDCWD">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">SAVEDCWD</code><a class="headerlink" href="#test.support.SAVEDCWD" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="os.html#os.getcwd" title="os.getcwd"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.getcwd()</span></code></a>로 설정합니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.PGO">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">PGO</code><a class="headerlink" href="#test.support.PGO" title="정의 주소">¶</a></dt>
<dd><p>PGO에 유용하지 않은 테스트를 건너뛸 수 있을 때 설정합니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.PIPE_MAX_SIZE">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">PIPE_MAX_SIZE</code><a class="headerlink" href="#test.support.PIPE_MAX_SIZE" title="정의 주소">¶</a></dt>
<dd><p>쓰기 블로킹을 일으키기 위해, 하부 OS 파이프 버퍼 크기보다 클 가능성이 높은 상수.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.SOCK_MAX_SIZE">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">SOCK_MAX_SIZE</code><a class="headerlink" href="#test.support.SOCK_MAX_SIZE" title="정의 주소">¶</a></dt>
<dd><p>쓰기 블로킹을 일으키기 위해, 하부 OS 소켓 버퍼 크기보다 클 가능성이 높은 상수.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.TEST_SUPPORT_DIR">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">TEST_SUPPORT_DIR</code><a class="headerlink" href="#test.support.TEST_SUPPORT_DIR" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support</span></code></a>를 포함하는 최상위 디렉터리로 설정합니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.TEST_HOME_DIR">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">TEST_HOME_DIR</code><a class="headerlink" href="#test.support.TEST_HOME_DIR" title="정의 주소">¶</a></dt>
<dd><p>테스트 패키지의 최상위 디렉터리로 설정합니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.TEST_DATA_DIR">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">TEST_DATA_DIR</code><a class="headerlink" href="#test.support.TEST_DATA_DIR" title="정의 주소">¶</a></dt>
<dd><p>테스트 패키지 내의 <code class="docutils literal notranslate"><span class="pre">data</span></code> 디렉터리로 설정합니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.MAX_Py_ssize_t">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">MAX_Py_ssize_t</code><a class="headerlink" href="#test.support.MAX_Py_ssize_t" title="정의 주소">¶</a></dt>
<dd><p>대용량 메모리 테스트를 위해 <a class="reference internal" href="sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a>로 설정합니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.max_memuse">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">max_memuse</code><a class="headerlink" href="#test.support.max_memuse" title="정의 주소">¶</a></dt>
<dd><p>대용량 메모리 테스트를 위한 메모리 제한으로 <a class="reference internal" href="#test.support.set_memlimit" title="test.support.set_memlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_memlimit()</span></code></a>에 의해 설정됩니다. <a class="reference internal" href="#test.support.MAX_Py_ssize_t" title="test.support.MAX_Py_ssize_t"><code class="xref py py-data docutils literal notranslate"><span class="pre">MAX_Py_ssize_t</span></code></a>에 의해 제한됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.real_max_memuse">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">real_max_memuse</code><a class="headerlink" href="#test.support.real_max_memuse" title="정의 주소">¶</a></dt>
<dd><p>대용량 메모리 테스트를 위한 메모리 제한으로 <a class="reference internal" href="#test.support.set_memlimit" title="test.support.set_memlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_memlimit()</span></code></a>에 의해 설정됩니다. <a class="reference internal" href="#test.support.MAX_Py_ssize_t" title="test.support.MAX_Py_ssize_t"><code class="xref py py-data docutils literal notranslate"><span class="pre">MAX_Py_ssize_t</span></code></a>에 의해 제한되지 않습니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.MISSING_C_DOCSTRINGS">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">MISSING_C_DOCSTRINGS</code><a class="headerlink" href="#test.support.MISSING_C_DOCSTRINGS" title="정의 주소">¶</a></dt>
<dd><p>윈도우가 아닌 CPython에서 실행 중이고, 구성이 <code class="docutils literal notranslate"><span class="pre">WITH_DOC_STRINGS</span></code>로 설정되지 않았으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.HAVE_DOCSTRINGS">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">HAVE_DOCSTRINGS</code><a class="headerlink" href="#test.support.HAVE_DOCSTRINGS" title="정의 주소">¶</a></dt>
<dd><p>독스트링이 있는지 확인합니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.TEST_HTTP_URL">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">TEST_HTTP_URL</code><a class="headerlink" href="#test.support.TEST_HTTP_URL" title="정의 주소">¶</a></dt>
<dd><p>네트워크 테스트를 위한 전용 HTTP 서버의 URL을 정의합니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.ALWAYS_EQ">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">ALWAYS_EQ</code><a class="headerlink" href="#test.support.ALWAYS_EQ" title="정의 주소">¶</a></dt>
<dd><p>모든 것과 같은 객체. 혼합형 비교를 테스트하는 데 사용됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.NEVER_EQ">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">NEVER_EQ</code><a class="headerlink" href="#test.support.NEVER_EQ" title="정의 주소">¶</a></dt>
<dd><p>어떤 것과도 같지 않은 객체 (<a class="reference internal" href="#test.support.ALWAYS_EQ" title="test.support.ALWAYS_EQ"><code class="xref py py-data docutils literal notranslate"><span class="pre">ALWAYS_EQ</span></code></a>에도 해당합니다). 혼합형 비교를 테스트하는 데 사용됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.LARGEST">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">LARGEST</code><a class="headerlink" href="#test.support.LARGEST" title="정의 주소">¶</a></dt>
<dd><p>모든 것보다 큰 객체 (자신은 제외하고). 혼합형 비교를 테스트하는 데 사용됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="test.support.SMALLEST">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">SMALLEST</code><a class="headerlink" href="#test.support.SMALLEST" title="정의 주소">¶</a></dt>
<dd><p>모든 것보다 작은 객체 (자신은 제외하고). 혼합형 비교를 테스트하는 데 사용됩니다.</p>
</dd></dl>

<p><a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support</span></code></a> 모듈은 다음 함수를 정의합니다:</p>
<dl class="function">
<dt id="test.support.forget">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">forget</code><span class="sig-paren">(</span><em class="sig-param">module_name</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.forget" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>에서 <em>module_name</em>이라는 모듈을 제거하고 모듈의 바이트 컴파일된 파일을 삭제합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.unload">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">unload</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.unload" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>에서 <em>name</em>을 삭제합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.unlink">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">unlink</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.unlink" title="정의 주소">¶</a></dt>
<dd><p><em>filename</em>에 대해 <a class="reference internal" href="os.html#os.unlink" title="os.unlink"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.unlink()</span></code></a>를 호출합니다. 윈도우 플랫폼에서는, 파일의 존재를 확인하는 대기 루프로 래핑 됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.rmdir">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">rmdir</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.rmdir" title="정의 주소">¶</a></dt>
<dd><p><em>filename</em>에 대해 <a class="reference internal" href="os.html#os.rmdir" title="os.rmdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.rmdir()</span></code></a>을 호출합니다. 윈도우 플랫폼에서는, 파일의 존재를 확인하는 대기 루프로 래핑 됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.rmtree">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">rmtree</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.rmtree" title="정의 주소">¶</a></dt>
<dd><p><em>path</em>에 대해 <a class="reference internal" href="shutil.html#shutil.rmtree" title="shutil.rmtree"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.rmtree()</span></code></a>를 호출하거나 <a class="reference internal" href="os.html#os.lstat" title="os.lstat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.lstat()</span></code></a>과 <a class="reference internal" href="os.html#os.rmdir" title="os.rmdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.rmdir()</span></code></a>을 호출하여 경로와 해당 내용을 제거합니다. 윈도우 플랫폼에서, 이것은 파일의 존재를 확인하는 대기 루프로 래핑 됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.make_legacy_pyc">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">make_legacy_pyc</code><span class="sig-paren">(</span><em class="sig-param">source</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.make_legacy_pyc" title="정의 주소">¶</a></dt>
<dd><p><span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>/<span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a> pyc 파일을 레거시 pyc 위치로 옮기고 레거시 pyc 파일에 대한 파일 시스템 경로를 반환합니다. <em>source</em> 값은 소스 파일에 대한 파일 시스템 경로입니다. 반드시 존재할 필요는 없지만, PEP 3147/488 pyc 파일이 있어야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.is_resource_enabled">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">is_resource_enabled</code><span class="sig-paren">(</span><em class="sig-param">resource</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.is_resource_enabled" title="정의 주소">¶</a></dt>
<dd><p><em>resource</em>가 활성화되고 사용할 수 있으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다. 사용 가능한 리소스 목록은 <code class="xref py py-mod docutils literal notranslate"><span class="pre">test.regrtest</span></code>가 테스트를 실행할 때만 설정됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.python_is_optimized">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">python_is_optimized</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.python_is_optimized" title="정의 주소">¶</a></dt>
<dd><p>파이썬이 <code class="docutils literal notranslate"><span class="pre">-O0</span></code>이나 <code class="docutils literal notranslate"><span class="pre">-Og</span></code>로 빌드되지 않았으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.with_pymalloc">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">with_pymalloc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.with_pymalloc" title="정의 주소">¶</a></dt>
<dd><p><code class="xref py py-data docutils literal notranslate"><span class="pre">_testcapi.WITH_PYMALLOC</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.requires">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param">resource</em>, <em class="sig-param">msg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.requires" title="정의 주소">¶</a></dt>
<dd><p><em>resource</em>를 사용할 수 없으면 <a class="reference internal" href="#test.support.ResourceDenied" title="test.support.ResourceDenied"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ResourceDenied</span></code></a>를 발생시킵니다. <em>msg</em>는 <a class="reference internal" href="#test.support.ResourceDenied" title="test.support.ResourceDenied"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ResourceDenied</span></code></a>가 발생한다면 이에 대한 인자입니다. <code class="docutils literal notranslate"><span class="pre">__name__</span></code>이 <code class="docutils literal notranslate"><span class="pre">'__main__'</span></code>인 함수에 의해 호출되면 항상 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다. <code class="xref py py-mod docutils literal notranslate"><span class="pre">test.regrtest</span></code>에서 테스트를 실행할 때 사용됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.system_must_validate_cert">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">system_must_validate_cert</code><span class="sig-paren">(</span><em class="sig-param">f</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.system_must_validate_cert" title="정의 주소">¶</a></dt>
<dd><p>TLS 인증서 유효성 검사 실패 시 <a class="reference internal" href="unittest.html#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">unittest.SkipTest</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.sortdict">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">sortdict</code><span class="sig-paren">(</span><em class="sig-param">dict</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.sortdict" title="정의 주소">¶</a></dt>
<dd><p>정렬된 키로 <em>dict</em>의 repr을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.findfile">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">findfile</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">subdir=None</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.findfile" title="정의 주소">¶</a></dt>
<dd><p><em>filename</em>이라는 파일의 경로를 반환합니다. 일치하는 것이 없으면 <em>filename</em>이 반환됩니다. 이것은 파일의 경로일 수 있어서 실패와 같지 않습니다.</p>
<p><em>subdir</em> 설정은 경로 디렉터리를 직접 찾는 대신 파일을 찾는 데 사용할 상대 경로를 나타냅니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.create_empty_file">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">create_empty_file</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.create_empty_file" title="정의 주소">¶</a></dt>
<dd><p><em>filename</em>으로 빈 파일을 만듭니다. 이미 있으면, 자릅니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.fd_count">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">fd_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.fd_count" title="정의 주소">¶</a></dt>
<dd><p>열린 파일 기술자의 수를 셉니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.match_test">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">match_test</code><span class="sig-paren">(</span><em class="sig-param">test</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.match_test" title="정의 주소">¶</a></dt>
<dd><p><em>test</em>를 <a class="reference internal" href="#test.support.set_match_tests" title="test.support.set_match_tests"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_match_tests()</span></code></a>에 설정된 패턴과 일치시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.set_match_tests">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">set_match_tests</code><span class="sig-paren">(</span><em class="sig-param">patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.set_match_tests" title="정의 주소">¶</a></dt>
<dd><p>정규식 <em>patterns</em>로 일치 테스트를 정의합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.run_unittest">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">run_unittest</code><span class="sig-paren">(</span><em class="sig-param">*classes</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.run_unittest" title="정의 주소">¶</a></dt>
<dd><p>함수에 전달된 <a class="reference internal" href="unittest.html#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a> 서브 클래스를 실행합니다. 이 함수는 접두사 <code class="docutils literal notranslate"><span class="pre">test_</span></code>로 시작하는 메서드에 대해 클래스를 검색하고 테스트를 개별적으로 실행합니다.</p>
<p>문자열을 매개 변수로 전달하는 것도 유효합니다; <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>의 키여야 합니다. 각 관련 모듈은 <code class="docutils literal notranslate"><span class="pre">unittest.TestLoader.loadTestsFromModule()</span></code> 에 의해 스캔 됩니다. 일반적으로 다음 <code class="xref py py-func docutils literal notranslate"><span class="pre">test_main()</span></code> 함수에서 볼 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_main</span><span class="p">():</span>
    <span class="n">support</span><span class="o">.</span><span class="n">run_unittest</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
</pre></div>
</div>
<p>이것은 명명된 모듈에 정의된 모든 테스트가 실행됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.run_doctest">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">run_doctest</code><span class="sig-paren">(</span><em class="sig-param">module</em>, <em class="sig-param">verbosity=None</em>, <em class="sig-param">optionflags=0</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.run_doctest" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>module</em>에서 <a class="reference internal" href="doctest.html#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">doctest.testmod()</span></code></a>를 실행합니다. <code class="docutils literal notranslate"><span class="pre">(failure_count,</span> <span class="pre">test_count)</span></code>를 반환합니다.</p>
<p><em>verbosity</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, <a class="reference internal" href="doctest.html#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">doctest.testmod()</span></code></a>는 상세도를 <a class="reference internal" href="#test.support.verbose" title="test.support.verbose"><code class="xref py py-data docutils literal notranslate"><span class="pre">verbose</span></code></a>로 설정하여 실행됩니다. 그렇지 않으면 상세도를 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정하여 실행됩니다. <em>optionflags</em>는 <code class="docutils literal notranslate"><span class="pre">optionflags</span></code>로 <a class="reference internal" href="doctest.html#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">doctest.testmod()</span></code></a>에 전달됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.setswitchinterval">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">setswitchinterval</code><span class="sig-paren">(</span><em class="sig-param">interval</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.setswitchinterval" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.setswitchinterval" title="sys.setswitchinterval"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setswitchinterval()</span></code></a>을 주어진 <em>interval</em>로 설정합니다. 시스템이 멈추는 것을 방지하기 위해 안드로이드 시스템을 위한 최소 간격을 정의합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.check_impl_detail">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">check_impl_detail</code><span class="sig-paren">(</span><em class="sig-param">**guards</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.check_impl_detail" title="정의 주소">¶</a></dt>
<dd><p>이 검사를 사용하여 CPython의 구현 별 테스트를 보호하거나 인자로 보호되는 구현에서만 실행합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">check_impl_detail</span><span class="p">()</span>               <span class="c1"># CPython에서만 (기본값).</span>
<span class="n">check_impl_detail</span><span class="p">(</span><span class="n">jython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>    <span class="c1"># Jython에서만.</span>
<span class="n">check_impl_detail</span><span class="p">(</span><span class="n">cpython</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># CPython을 제외한 모든 곳.</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.check_warnings">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">check_warnings</code><span class="sig-paren">(</span><em class="sig-param">*filters</em>, <em class="sig-param">quiet=True</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.check_warnings" title="정의 주소">¶</a></dt>
<dd><p>경고가 올바르게 발생했는지 테스트하기 쉽게 하는 <a class="reference internal" href="warnings.html#warnings.catch_warnings" title="warnings.catch_warnings"><code class="xref py py-func docutils literal notranslate"><span class="pre">warnings.catch_warnings()</span></code></a> 용 편의 래퍼. <a class="reference internal" href="warnings.html#warnings.simplefilter" title="warnings.simplefilter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">warnings.simplefilter()</span></code></a>를 <code class="docutils literal notranslate"><span class="pre">always</span></code>로 설정하고 기록된 결과를 자동으로 검증하는 옵션을 사용하여 <code class="docutils literal notranslate"><span class="pre">warnings.catch_warnings(record=True)</span></code>를 호출하는 것과 거의 동등합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">check_warnings</span></code>는 위치 인자로 <code class="docutils literal notranslate"><span class="pre">(&quot;message</span> <span class="pre">regexp&quot;,</span> <span class="pre">WarningCategory)</span></code> 형식의 2-튜플을 받습니다. 하나 이상의 <em>filters</em>가 제공되거나, 선택적 키워드 인자 <em>quiet</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, 경고가 예상대로인지 확인합니다: 지정된 각 필터는 둘러싸인 코드에서 발생한 경고 중 적어도 하나와 일치해야 합니다. 그렇지 않으면 테스트가 실패합니다. 지정된 필터와 일치하지 않는 경고가 발생하면 테스트가 실패합니다. 첫 번째 검사를 비활성화하려면, <em>quiet</em>를 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정합니다.</p>
<p>인자가 지정되지 않으면, 기본값은 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">check_warnings</span><span class="p">((</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="ne">Warning</span><span class="p">),</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>이 경우 모든 경고가 포착되고 에러가 발생하지 않습니다.</p>
<p>컨텍스트 관리자에 진입하면, <code class="xref py py-class docutils literal notranslate"><span class="pre">WarningRecorder</span></code> 인스턴스가 반환됩니다. <a class="reference internal" href="warnings.html#warnings.catch_warnings" title="warnings.catch_warnings"><code class="xref py py-func docutils literal notranslate"><span class="pre">catch_warnings()</span></code></a>의 하부 경고 리스트는 레코더 객체의 <a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-attr docutils literal notranslate"><span class="pre">warnings</span></code></a> 어트리뷰트를 통해 사용할 수 있습니다. 편의상, 가장 최근의 경고를 나타내는 객체의 어트리뷰트는 레코더 객체를 통해 직접 액세스 할 수도 있습니다 (아래 예를 참조하십시오). 경고가 발생하지 않으면, 객체에서 예상되는 경고를 나타내는 어트리뷰트는 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<p>레코더 객체에는 경고 리스트를 지우는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">reset()</span></code> 메서드도 있습니다.</p>
<p>컨텍스트 관리자는 다음과 같이 사용되도록 설계되었습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">check_warnings</span><span class="p">((</span><span class="s2">&quot;assertion is always true&quot;</span><span class="p">,</span> <span class="ne">SyntaxWarning</span><span class="p">),</span>
                    <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)):</span>
    <span class="n">exec</span><span class="p">(</span><span class="s1">&#39;assert(False, &quot;Hey!&quot;)&#39;</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">(</span><span class="s2">&quot;Hide me!&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>이 경우 경고가 발생하지 않았거나, 다른 경고가 발생하면, <a class="reference internal" href="#test.support.check_warnings" title="test.support.check_warnings"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_warnings()</span></code></a>는 에러를 발생시킵니다.</p>
<p>테스트에서 경고가 발생했는지를 확인하는 것만이 아니라, 경고를 더 깊이 조사해야 할 때, 다음과 같은 코드를 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">check_warnings</span><span class="p">(</span><span class="n">quiet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="s2">&quot;foo&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="s2">&quot;bar&quot;</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">warnings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="s2">&quot;foo&quot;</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">warnings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="s2">&quot;bar&quot;</span>
    <span class="n">w</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">warnings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
<p>여기에서 모든 경고가 포착되고, 테스트 코드는 포착된 경고를 직접 테스트합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>새로운 선택적 인자 <em>filters</em>와 <em>quiet</em>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.check_no_resource_warning">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">check_no_resource_warning</code><span class="sig-paren">(</span><em class="sig-param">testcase</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.check_no_resource_warning" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="exceptions.html#ResourceWarning" title="ResourceWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ResourceWarning</span></code></a>이 발생하지 않았는지 확인하는 컨텍스트 관리자. 컨텍스트 관리자가 끝나기 전에 <a class="reference internal" href="exceptions.html#ResourceWarning" title="ResourceWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ResourceWarning</span></code></a>을 방출할 수 있는 객체를 제거해야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.set_memlimit">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">set_memlimit</code><span class="sig-paren">(</span><em class="sig-param">limit</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.set_memlimit" title="정의 주소">¶</a></dt>
<dd><p>대용량 메모리 테스트를 위해 <a class="reference internal" href="#test.support.max_memuse" title="test.support.max_memuse"><code class="xref py py-data docutils literal notranslate"><span class="pre">max_memuse</span></code></a>와 <a class="reference internal" href="#test.support.real_max_memuse" title="test.support.real_max_memuse"><code class="xref py py-data docutils literal notranslate"><span class="pre">real_max_memuse</span></code></a> 값을 설정합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.record_original_stdout">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">record_original_stdout</code><span class="sig-paren">(</span><em class="sig-param">stdout</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.record_original_stdout" title="정의 주소">¶</a></dt>
<dd><p><em>stdout</em>의 값을 저장합니다. regrtest가 시작될 때 stdout을 잡기 위한 것입니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.get_original_stdout">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">get_original_stdout</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.get_original_stdout" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#test.support.record_original_stdout" title="test.support.record_original_stdout"><code class="xref py py-func docutils literal notranslate"><span class="pre">record_original_stdout()</span></code></a>에 의해 설정된 원래 stdout이나 설정되지 않았으면 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.args_from_interpreter_flags">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">args_from_interpreter_flags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.args_from_interpreter_flags" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">sys.flags</span></code>와 <code class="docutils literal notranslate"><span class="pre">sys.warnoptions</span></code>의 현재 설정을 재현하는 명령 줄 인자 리스트를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.optim_args_from_interpreter_flags">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">optim_args_from_interpreter_flags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.optim_args_from_interpreter_flags" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">sys.flags</span></code>의 현재 최적화 설정을 재현하는 명령 줄 인자 리스트를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.captured_stdin">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">captured_stdin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.captured_stdin" title="정의 주소">¶</a></dt>
<dt id="test.support.captured_stdout">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">captured_stdout</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.captured_stdout" title="정의 주소">¶</a></dt>
<dt id="test.support.captured_stderr">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">captured_stderr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.captured_stderr" title="정의 주소">¶</a></dt>
<dd><p>명명된 스트림을 <a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> 객체로 일시적으로 대체하는 컨텍스트 관리자.</p>
<p>출력 스트림 사용 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">captured_stdout</span><span class="p">()</span> <span class="k">as</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">captured_stderr</span><span class="p">()</span> <span class="k">as</span> <span class="n">stderr</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;error&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">stdout</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;hello</span><span class="se">\n</span><span class="s2">&quot;</span>
<span class="k">assert</span> <span class="n">stderr</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;error</span><span class="se">\n</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>입력 스트림 사용 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">captured_stdin</span><span class="p">()</span> <span class="k">as</span> <span class="n">stdin</span><span class="p">:</span>
    <span class="n">stdin</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;hello</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">stdin</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># sys.stdin에서 소비하는 테스트 코드를 호출합니다</span>
    <span class="n">captured</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">captured</span><span class="p">,</span> <span class="s2">&quot;hello&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.temp_dir">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">temp_dir</code><span class="sig-paren">(</span><em class="sig-param">path=None</em>, <em class="sig-param">quiet=False</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.temp_dir" title="정의 주소">¶</a></dt>
<dd><p><em>path</em>에 임시 디렉터리를 만들고 그 디렉터리를 산출하는 컨텍스트 관리자.</p>
<p><em>path</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, 임시 디렉터리는 <a class="reference internal" href="tempfile.html#tempfile.mkdtemp" title="tempfile.mkdtemp"><code class="xref py py-func docutils literal notranslate"><span class="pre">tempfile.mkdtemp()</span></code></a>를 사용하여 만들어집니다. <em>quiet</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, 컨텍스트 관리자는 에러 시 예외를 발생시킵니다. 그렇지 않으면, <em>path</em>가 지정되고 만들 수 없으면, 경고만 발행됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.change_cwd">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">change_cwd</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">quiet=False</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.change_cwd" title="정의 주소">¶</a></dt>
<dd><p>현재 작업 디렉터리를 <em>path</em>로 일시적으로 변경하고 그 디렉터리를 산출하는 컨텍스트 관리자.</p>
<p><em>quiet</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, 컨텍스트 관리자는 에러 시 예외를 발생시킵니다. 그렇지 않으면, 경고만 발행하고 현재 작업 디렉터리를 같게 유지합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.temp_cwd">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">temp_cwd</code><span class="sig-paren">(</span><em class="sig-param">name='tempcwd'</em>, <em class="sig-param">quiet=False</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.temp_cwd" title="정의 주소">¶</a></dt>
<dd><p>임시로 새 디렉터리를 만들고 현재 작업 디렉터리(CWD)를 변경하는 컨텍스트 관리자.</p>
<p>컨텍스트 관리자는 현재 작업 디렉터리를 임시로 변경하기 전에 이름이 <em>name</em>인 임시 디렉터리를 현재 디렉터리에 만듭니다. <em>name</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, 임시 디렉터리는 <a class="reference internal" href="tempfile.html#tempfile.mkdtemp" title="tempfile.mkdtemp"><code class="xref py py-func docutils literal notranslate"><span class="pre">tempfile.mkdtemp()</span></code></a>를 사용하여 만들어집니다.</p>
<p><em>quiet</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이고 만들 수 없거나 CWD를 변경할 수 없으면, 에러가 발생합니다. 그렇지 않으면, 경고만 발생하고 원래 CWD가 사용됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.temp_umask">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">temp_umask</code><span class="sig-paren">(</span><em class="sig-param">umask</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.temp_umask" title="정의 주소">¶</a></dt>
<dd><p>프로세스 umask를 임시로 설정하는 컨텍스트 관리자.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.disable_faulthandler">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">disable_faulthandler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.disable_faulthandler" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>를 <code class="docutils literal notranslate"><span class="pre">sys.__stderr__</span></code>로 대체하는 컨텍스트 관리자.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.gc_collect">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">gc_collect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.gc_collect" title="정의 주소">¶</a></dt>
<dd><p>가능한 한 많은 객체를 수거하도록 강제합니다. 이는 가비지 수거기가 적시에 할당 해제를 보장하지 않기 때문에 필요합니다. 이는 <code class="docutils literal notranslate"><span class="pre">__del__</span></code> 메서드가 예상보다 늦게 호출될 수 있고 약한 참조(weakrefs)가 예상보다 오래 살아있을 수 있음을 의미합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.disable_gc">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">disable_gc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.disable_gc" title="정의 주소">¶</a></dt>
<dd><p>진입할 때 가비지 수거기를 비활성화하고 탈출할 때 다시 활성화하는 컨텍스트 관리자.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.swap_attr">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">swap_attr</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">attr</em>, <em class="sig-param">new_val</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.swap_attr" title="정의 주소">¶</a></dt>
<dd><p>어트리뷰트를 새 객체로 스와프하는 컨텍스트 관리자.</p>
<p>용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">swap_attr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;attr&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>이렇게 하면 <code class="docutils literal notranslate"><span class="pre">with</span></code> 블록의 기간 중 <code class="docutils literal notranslate"><span class="pre">obj.attr</span></code>이 5로 설정되고, 블록 끝에서 이전 값이 복원됩니다. <code class="docutils literal notranslate"><span class="pre">obj</span></code>에 <code class="docutils literal notranslate"><span class="pre">attr</span></code>이 없으면, 만들어지고 블록의 끝에서 삭제됩니다.</p>
<p>이전 값(또는 존재하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>)이 &quot;as&quot; 절의 대상(있다면)에 대입됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.swap_item">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">swap_item</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">attr</em>, <em class="sig-param">new_val</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.swap_item" title="정의 주소">¶</a></dt>
<dd><p>항목을 새 객체로 스와프하는 컨텍스트 관리자.</p>
<p>용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">swap_item</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;item&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>이렇게 하면 <code class="docutils literal notranslate"><span class="pre">with</span></code> 블록의 기간 중 <code class="docutils literal notranslate"><span class="pre">obj[&quot;item&quot;]</span></code>이 5로 설정되고, 블록 끝에서 이전 값이 복원됩니다. <code class="docutils literal notranslate"><span class="pre">obj</span></code>에 <code class="docutils literal notranslate"><span class="pre">item</span></code>이 없으면, 만들어지고 블록의 끝에서 삭제됩니다.</p>
<p>이전 값(또는 존재하지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>)이 &quot;as&quot; 절의 대상(있다면)에 대입됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.print_warning">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">print_warning</code><span class="sig-paren">(</span><em class="sig-param">msg</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.print_warning" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.__stderr__" title="sys.__stderr__"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.__stderr__</span></code></a>에 경고를 인쇄합니다. 메시지를 다음처럼 포맷합니다: <code class="docutils literal notranslate"><span class="pre">f&quot;Warning</span> <span class="pre">--</span> <span class="pre">{msg}&quot;</span></code>. <em>msg</em>가 여러 줄로 구성되면, 각 줄에 <code class="docutils literal notranslate"><span class="pre">&quot;Warning</span> <span class="pre">--</span> <span class="pre">&quot;</span></code> 접두사를 추가합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.wait_process">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">wait_process</code><span class="sig-paren">(</span><em class="sig-param">pid</em>, <em class="sig-param">*</em>, <em class="sig-param">exitcode</em>, <em class="sig-param">timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.wait_process" title="정의 주소">¶</a></dt>
<dd><p>프로세스 <em>pid</em>가 완료될 때까지 기다렸다가 프로세스 종료 코드가 <em>exitcode</em>인지 확인합니다.</p>
<p>프로세스 종료 코드가 <em>exitcode</em>와 같지 않으면 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a>를 발생시킵니다.</p>
<p>프로세스가 <em>timeout</em>(기본적으로 <a class="reference internal" href="#test.support.SHORT_TIMEOUT" title="test.support.SHORT_TIMEOUT"><code class="xref py py-data docutils literal notranslate"><span class="pre">SHORT_TIMEOUT</span></code></a>) 초보다 오래 실행되면, 프로세스를 죽이고 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a>를 발생시킵니다. 제한 시간 기능은 윈도우에서 사용할 수 없습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.wait_threads_exit">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">wait_threads_exit</code><span class="sig-paren">(</span><em class="sig-param">timeout=60.0</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.wait_threads_exit" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">with</span></code> 문에서 만들어진 모든 스레드가 종료할 때까지 대기하는 컨텍스트 관리자.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.start_threads">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">start_threads</code><span class="sig-paren">(</span><em class="sig-param">threads</em>, <em class="sig-param">unlock=None</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.start_threads" title="정의 주소">¶</a></dt>
<dd><p><em>threads</em>를 시작하는 컨텍스트 관리자. 탈출 시 스레드 join을 시도합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.calcobjsize">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">calcobjsize</code><span class="sig-paren">(</span><em class="sig-param">fmt</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.calcobjsize" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">nP{fmt}0n</span></code>이나 <code class="docutils literal notranslate"><span class="pre">gettotalrefcount</span></code> 가 있으면, <code class="docutils literal notranslate"><span class="pre">2PnP{fmt}0P</span></code>에 대해 <a class="reference internal" href="struct.html#struct.calcsize" title="struct.calcsize"><code class="xref py py-func docutils literal notranslate"><span class="pre">struct.calcsize()</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.calcvobjsize">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">calcvobjsize</code><span class="sig-paren">(</span><em class="sig-param">fmt</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.calcvobjsize" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">nPn{fmt}0n</span></code>이나 <code class="docutils literal notranslate"><span class="pre">gettotalrefcount</span></code> 가 있으면, <code class="docutils literal notranslate"><span class="pre">2PnPn{fmt}0P</span></code>에 대해 <a class="reference internal" href="struct.html#struct.calcsize" title="struct.calcsize"><code class="xref py py-func docutils literal notranslate"><span class="pre">struct.calcsize()</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.checksizeof">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">checksizeof</code><span class="sig-paren">(</span><em class="sig-param">test</em>, <em class="sig-param">o</em>, <em class="sig-param">size</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.checksizeof" title="정의 주소">¶</a></dt>
<dd><p>테스트 케이스 <em>test</em>에 대해, <em>o</em>의 <code class="docutils literal notranslate"><span class="pre">sys.getsizeof</span></code>에 GC 헤더 크기를 더한 값이 <em>size</em>와 같다고 어서션 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.can_symlink">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">can_symlink</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.can_symlink" title="정의 주소">¶</a></dt>
<dd><p>OS가 심볼릭 링크를 지원하면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.can_xattr">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">can_xattr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.can_xattr" title="정의 주소">¶</a></dt>
<dd><p>OS가 xattr을 지원하면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.skip_unless_symlink">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">skip_unless_symlink</code><a class="headerlink" href="#test.support.skip_unless_symlink" title="정의 주소">¶</a></dt>
<dd><p>심볼릭 링크 지원이 필요한 테스트를 실행하기 위한 데코레이터.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.skip_unless_xattr">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">skip_unless_xattr</code><a class="headerlink" href="#test.support.skip_unless_xattr" title="정의 주소">¶</a></dt>
<dd><p>xattr 지원이 필요한 테스트를 실행하기 위한 데코레이터.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.anticipate_failure">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">anticipate_failure</code><span class="sig-paren">(</span><em class="sig-param">condition</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.anticipate_failure" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="unittest.html#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.expectedFailure()</span></code></a>로 테스트를 조건부로 표시하는 데코레이터. 이 데코레이터를 사용하려면 관련 추적기(tracker) 이슈를 식별하는 관련 주석이 있어야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.run_with_locale">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">run_with_locale</code><span class="sig-paren">(</span><em class="sig-param">catstr</em>, <em class="sig-param">*locales</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.run_with_locale" title="정의 주소">¶</a></dt>
<dd><p>다른 로케일에서 함수를 실행하기 위한 데코레이터로, 완료된 후 올바르게 재설정합니다. <em>catstr</em>은 문자열로 된 로케일 범주입니다 (예를 들어 <code class="docutils literal notranslate"><span class="pre">&quot;LC_ALL&quot;</span></code>). 전달된 <em>locales</em>는 순차적으로 시도되며, 첫 번째 유효한 로케일이 사용됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.run_with_tz">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">run_with_tz</code><span class="sig-paren">(</span><em class="sig-param">tz</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.run_with_tz" title="정의 주소">¶</a></dt>
<dd><p>특정 시간대에서 함수를 실행하기 위한 데코레이터로, 완료된 후 올바르게 재설정합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.requires_freebsd_version">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">requires_freebsd_version</code><span class="sig-paren">(</span><em class="sig-param">*min_version</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.requires_freebsd_version" title="정의 주소">¶</a></dt>
<dd><p>FreeBSD에서 테스트를 실행할 때 최소 버전을 위한 데코레이터. FreeBSD 버전이 최소 버전보다 낮으면, <a class="reference internal" href="unittest.html#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">unittest.SkipTest</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.requires_linux_version">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">requires_linux_version</code><span class="sig-paren">(</span><em class="sig-param">*min_version</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.requires_linux_version" title="정의 주소">¶</a></dt>
<dd><p>리눅스에서 테스트를 실행할 때 최소 버전을 위한 데코레이터. 리눅스 버전이 최소 버전보다 낮으면, <a class="reference internal" href="unittest.html#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">unittest.SkipTest</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.requires_mac_version">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">requires_mac_version</code><span class="sig-paren">(</span><em class="sig-param">*min_version</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.requires_mac_version" title="정의 주소">¶</a></dt>
<dd><p>Mac OS X에서 테스트를 실행할 때 최소 버전을 위한 데코레이터. MAC OS X 버전이 최소 버전보다 낮으면, <a class="reference internal" href="unittest.html#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">unittest.SkipTest</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.requires_IEEE_754">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">requires_IEEE_754</code><a class="headerlink" href="#test.support.requires_IEEE_754" title="정의 주소">¶</a></dt>
<dd><p>비 IEEE 754 플랫폼에서 테스트를 건너뛰는 데코레이터.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.requires_zlib">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">requires_zlib</code><a class="headerlink" href="#test.support.requires_zlib" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a>가 없으면 테스트를 건너뛰는 데코레이터.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.requires_gzip">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">requires_gzip</code><a class="headerlink" href="#test.support.requires_gzip" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gzip</span></code></a>이 없으면 테스트를 건너뛰는 데코레이터.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.requires_bz2">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">requires_bz2</code><a class="headerlink" href="#test.support.requires_bz2" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a>가 없으면 테스트를 건너뛰는 데코레이터.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.requires_lzma">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">requires_lzma</code><a class="headerlink" href="#test.support.requires_lzma" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="lzma.html#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lzma</span></code></a>가 없으면 테스트를 건너뛰는 데코레이터.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.requires_resource">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">requires_resource</code><span class="sig-paren">(</span><em class="sig-param">resource</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.requires_resource" title="정의 주소">¶</a></dt>
<dd><p><em>resource</em>를 사용할 수 없으면 테스트를 건너뛰는 데코레이터.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.requires_docstrings">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">requires_docstrings</code><a class="headerlink" href="#test.support.requires_docstrings" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#test.support.HAVE_DOCSTRINGS" title="test.support.HAVE_DOCSTRINGS"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAVE_DOCSTRINGS</span></code></a>일 때만 테스트를 실행하는 데코레이터.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.cpython_only">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">cpython_only</code><span class="sig-paren">(</span><em class="sig-param">test</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.cpython_only" title="정의 주소">¶</a></dt>
<dd><p>CPython에만 적용되는 테스트용 데코레이터.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.impl_detail">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">impl_detail</code><span class="sig-paren">(</span><em class="sig-param">msg=None</em>, <em class="sig-param">**guards</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.impl_detail" title="정의 주소">¶</a></dt>
<dd><p><em>guards</em>에 <a class="reference internal" href="#test.support.check_impl_detail" title="test.support.check_impl_detail"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_impl_detail()</span></code></a>을 호출하는 데코레이터. <code class="docutils literal notranslate"><span class="pre">False</span></code>가 반환되면, 테스트를 건너뛰는 이유로 <em>msg</em>를 사용합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.no_tracing">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">no_tracing</code><span class="sig-paren">(</span><em class="sig-param">func</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.no_tracing" title="정의 주소">¶</a></dt>
<dd><p>테스트 기간 중 일시적으로 추적을 해제하는 데코레이터.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.refcount_test">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">refcount_test</code><span class="sig-paren">(</span><em class="sig-param">test</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.refcount_test" title="정의 주소">¶</a></dt>
<dd><p>참조 횟수를 수반하는 테스트를 위한 데코레이터. 데코레이터는 CPython에 의해 실행되지 않으면 테스트를 실행하지 않습니다. 추적 함수로 인한 예기치 않은 참조 횟수를 방지하기 위해 테스트 기간 중 모든 추적 함수가 설정 해제됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.reap_threads">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">reap_threads</code><span class="sig-paren">(</span><em class="sig-param">func</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.reap_threads" title="정의 주소">¶</a></dt>
<dd><p>테스트가 실패하더라도 스레드를 정리하는 데코레이터.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.bigmemtest">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">bigmemtest</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">memuse</em>, <em class="sig-param">dry_run=True</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.bigmemtest" title="정의 주소">¶</a></dt>
<dd><p>bigmem 테스트를 위한 데코레이터.</p>
<p><em>size</em>는 테스트를 위해 요청된 크기입니다 (임의의 테스트가 해석하는 단위.) <em>memuse</em>는 테스트 단위당 바이트 수, 또는 이의 적절한 추정치입니다. 예를 들어, 각각 4GiB인 두 개의 바이트 버퍼가 필요한 테스트는 <code class="docutils literal notranslate"><span class="pre">&#64;bigmemtest(size=_4G,</span> <span class="pre">memuse=2)</span></code>로 데코레이트 될 수 있습니다.</p>
<p><em>size</em> 인자는 일반적으로 데코레이트 된 테스트 메서드에 추가 인자로 전달됩니다. <em>dry_run</em>이 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, 테스트 메서드에 전달된 값이 요청된 값보다 작을 수 있습니다. <em>dry_run</em>이 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, <code class="docutils literal notranslate"><span class="pre">-M</span></code>가 지정되지 않은 경우 테스트가 더미 실행을 지원하지 않음을 의미합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.bigaddrspacetest">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">bigaddrspacetest</code><span class="sig-paren">(</span><em class="sig-param">f</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.bigaddrspacetest" title="정의 주소">¶</a></dt>
<dd><p>주소 공간을 채우는 테스트용 데코레이터. <em>f</em>는 래핑 할 함수입니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.make_bad_fd">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">make_bad_fd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.make_bad_fd" title="정의 주소">¶</a></dt>
<dd><p>임시 파일을 여닫아서 잘못된 파일 기술자를 만든 다음, 그 기술자를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.check_syntax_error">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">check_syntax_error</code><span class="sig-paren">(</span><em class="sig-param">testcase</em>, <em class="sig-param">statement</em>, <em class="sig-param">errtext=''</em>, <em class="sig-param">*</em>, <em class="sig-param">lineno=None</em>, <em class="sig-param">offset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.check_syntax_error" title="정의 주소">¶</a></dt>
<dd><p><em>statement</em> 컴파일을 시도하여 <em>statement</em>의 구문 에러를 테스트합니다. <em>testcase</em>는 테스트를 위한 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 인스턴스입니다. <em>errtext</em>는 발생한 <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>의 문자열 표현과 일치해야 하는 정규식입니다. <em>lineno</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면, 예외 줄과 비교합니다. <em>offset</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면, 예외의 오프셋과 비교합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.check_syntax_warning">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">check_syntax_warning</code><span class="sig-paren">(</span><em class="sig-param">testcase</em>, <em class="sig-param">statement</em>, <em class="sig-param">errtext=''</em>, <em class="sig-param">*</em>, <em class="sig-param">lineno=1</em>, <em class="sig-param">offset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.check_syntax_warning" title="정의 주소">¶</a></dt>
<dd><p><em>statement</em> 컴파일을 시도하여 <em>statement</em>에서 구문 경고를 테스트합니다. <a class="reference internal" href="exceptions.html#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a>이 한 번만 방출되고, 에러로 바꿀 때 <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>로 변환되는지도 테스트합니다. <em>testcase</em>는 테스트를 위한 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 인스턴스입니다. <em>errtext</em>는 방출된 <a class="reference internal" href="exceptions.html#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a>과 발생한 <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>의 문자열 표현과 일치해야 하는 정규식입니다. <em>lineno</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면 경고와 예외 줄과 비교합니다. <em>offset</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면, 예외 오프셋과 비교합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.open_urlresource">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">open_urlresource</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.open_urlresource" title="정의 주소">¶</a></dt>
<dd><p><em>url</em>을 엽니다. 열기에 실패하면, <a class="reference internal" href="#test.support.TestFailed" title="test.support.TestFailed"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TestFailed</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.import_module">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">import_module</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">deprecated=False</em>, <em class="sig-param">*</em>, <em class="sig-param">required_on()</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.import_module" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 명명된 모듈을 임포트하고 반환합니다. 일반 임포트와 달리, 이 함수는 모듈을 임포트할 수 없으면 <a class="reference internal" href="unittest.html#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">unittest.SkipTest</span></code></a>를 발생시킵니다.</p>
<p><em>deprecated</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면 이 임포트 중에 모듈과 패키지 폐지 메시지가 억제됩니다. 모듈이 한 플랫폼에서는 필수지만, 다른 곳에서는 선택적이면, <em>required_on</em>을 <a class="reference internal" href="sys.html#sys.platform" title="sys.platform"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.platform</span></code></a>과 비교할 플랫폼 접두사의 이터러블로 설정합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.import_fresh_module">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">import_fresh_module</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">fresh=()</em>, <em class="sig-param">blocked=()</em>, <em class="sig-param">deprecated=False</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.import_fresh_module" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 임포트 전에 <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>에서 명명된 모듈을 제거하여 명명된 파이썬 모듈의 새 복사본을 임포트하고 반환합니다. <code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code>와 달리, 원래 모듈은 이 연산의 영향을 받지 않습니다.</p>
<p><em>fresh</em>는 임포트를 수행하기 전에 <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> 캐시에서 함께 제거되는 추가 모듈 이름의 이터러블입니다.</p>
<p><em>blocked</em>는 임포트 하는 동안 모듈 캐시에서 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 대체되는 모듈 이름의 이터러블로, 임포트 하려고 시도하면 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>가 발생하도록 합니다.</p>
<p>명명된 모듈과 <em>fresh</em>와 <em>blocked</em> 매개 변수에 명명된 모든 모듈은 임포트를 시작하기 전에 보관되고 새 임포트가 완료되면 <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>에 다시 삽입됩니다.</p>
<p><em>deprecated</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면 이 임포트 중에 모듈과 패키지 폐지 메시지가 억제됩니다.</p>
<p>이 함수는 명명된 모듈을 임포트 할 수 없으면 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다.</p>
<p>사용 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 나머지 테스트 스위트에서 사용 중인 버전에 영향을 주지 않고 테스트용 경고 모듈의 사본을</span>
<span class="c1"># 얻습니다. 한 사본은 C 구현을 사용하고, 다른 사본은 순수한 파이썬 대체 구현을 사용하도록</span>
<span class="c1"># 강요됩니다.</span>
<span class="n">py_warnings</span> <span class="o">=</span> <span class="n">import_fresh_module</span><span class="p">(</span><span class="s1">&#39;warnings&#39;</span><span class="p">,</span> <span class="n">blocked</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_warnings&#39;</span><span class="p">])</span>
<span class="n">c_warnings</span> <span class="o">=</span> <span class="n">import_fresh_module</span><span class="p">(</span><span class="s1">&#39;warnings&#39;</span><span class="p">,</span> <span class="n">fresh</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_warnings&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.modules_setup">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">modules_setup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.modules_setup" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>의 복사본을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.modules_cleanup">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">modules_cleanup</code><span class="sig-paren">(</span><em class="sig-param">oldmodules</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.modules_cleanup" title="정의 주소">¶</a></dt>
<dd><p>내부 캐시를 보존하기 위해 <em>oldmodules</em>와 <code class="docutils literal notranslate"><span class="pre">encodings</span></code>를 제외한 모듈들을 제거합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.threading_setup">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">threading_setup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.threading_setup" title="정의 주소">¶</a></dt>
<dd><p>현재 스레드 수와 매달린(dangling) 스레드의 복사본을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.threading_cleanup">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">threading_cleanup</code><span class="sig-paren">(</span><em class="sig-param">*original_values</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.threading_cleanup" title="정의 주소">¶</a></dt>
<dd><p><em>original_values</em>에 지정되지 않은 스레드를 정리합니다. 테스트가 백그라운드에서 실행 중인 스레드를 남겨두면 경고를 내도록 설계되었습니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.join_thread">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">join_thread</code><span class="sig-paren">(</span><em class="sig-param">thread</em>, <em class="sig-param">timeout=30.0</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.join_thread" title="정의 주소">¶</a></dt>
<dd><p><em>timeout</em> 내에 <em>thread</em>에 조인(join)합니다. 스레드가 <em>timeout</em> 초 후에도 여전히 살아 있으면 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.reap_children">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">reap_children</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.reap_children" title="정의 주소">¶</a></dt>
<dd><p>서브 프로세스가 시작될 때마다 <code class="docutils literal notranslate"><span class="pre">test_main</span></code> 끝에 이것을 사용하십시오. 이렇게 하면 여분의 자식(좀비)이 남아서 리소스를 탐하지 않도록 하고 참조 누수를 찾을 때 문제가 발생하지 않도록 할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.get_attribute">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">get_attribute</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.get_attribute" title="정의 주소">¶</a></dt>
<dd><p>어트리뷰트를 가져옵니다, <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>가 발생하면 <a class="reference internal" href="unittest.html#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">unittest.SkipTest</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.catch_threading_exception">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">catch_threading_exception</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.catch_threading_exception" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="threading.html#threading.excepthook" title="threading.excepthook"><code class="xref py py-func docutils literal notranslate"><span class="pre">threading.excepthook()</span></code></a>을 사용하여 <a class="reference internal" href="threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Thread</span></code></a> 예외를 포착하는 컨텍스트 관리자.</p>
<p>예외가 포착될 때 설정되는 어트리뷰트:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">exc_type</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exc_value</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exc_traceback</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">thread</span></code></p></li>
</ul>
<p><a class="reference internal" href="threading.html#threading.excepthook" title="threading.excepthook"><code class="xref py py-func docutils literal notranslate"><span class="pre">threading.excepthook()</span></code></a> 설명서를 참조하십시오.</p>
<p>이러한 어트리뷰트들은 컨텍스트 관리자 탈출 시에 삭제됩니다.</p>
<p>용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">support</span><span class="o">.</span><span class="n">catch_threading_exception</span><span class="p">()</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="c1"># 예외를 발생시키는 스레드를 생성하는 코드</span>
    <span class="o">...</span>

    <span class="c1"># 스레드 예외를 확인합니다, cm 어트리뷰트를 사용하십시오:</span>
    <span class="c1"># exc_type, exc_value, exc_traceback, thread</span>
    <span class="o">...</span>

<span class="c1"># cm의 exc_type, exc_value, exc_traceback, thread 어트리뷰트가 이 지점에서</span>
<span class="c1"># 더는 존재하지 않습니다</span>
<span class="c1"># (참조 순환을 피하고자)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.catch_unraisable_exception">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">catch_unraisable_exception</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.catch_unraisable_exception" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.unraisablehook" title="sys.unraisablehook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.unraisablehook()</span></code></a>를 사용하여 발생시킬 수 없는(unraisable) 예외를 포착하는 컨텍스트 관리자.</p>
<p>예외 값(<code class="docutils literal notranslate"><span class="pre">cm.unraisable.exc_value</span></code>)을 저장하면 참조 순환을 만듭니다. 컨텍스트 관리자가 탈출할 때 참조 순환이 명시적으로 끊어집니다.</p>
<p>객체(<code class="docutils literal notranslate"><span class="pre">cm.unraisable.object</span></code>)를 저장하면 파이널라이즈 중인 객체로 설정되어 있으면 되살릴 수 있습니다. 컨텍스트 관리자를 탈출하면 저장된 객체가 지워집니다.</p>
<p>용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">support</span><span class="o">.</span><span class="n">catch_unraisable_exception</span><span class="p">()</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="c1"># &quot;발생시킬 수 없는 예외&quot;를 만드는 코드</span>
    <span class="o">...</span>

    <span class="c1"># 발생시킬 수 없는 예외를 확인합니다: cm.unraisable 을 사용하십시오</span>
    <span class="o">...</span>

<span class="c1"># 이 지점에서 cm.unraisable 어트리뷰트는 더는 존재하지 않습니다</span>
<span class="c1"># (참조 순환을 끊고자)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.load_package_tests">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">load_package_tests</code><span class="sig-paren">(</span><em class="sig-param">pkg_dir</em>, <em class="sig-param">loader</em>, <em class="sig-param">standard_tests</em>, <em class="sig-param">pattern</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.load_package_tests" title="정의 주소">¶</a></dt>
<dd><p>테스트 패키지에서 사용하기 위한 <a class="reference internal" href="unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> 프로토콜의 일반 구현. <em>pkg_dir</em>는 패키지의 루트 디렉터리입니다; <em>loader</em>, <em>standard_tests</em> 및 <em>pattern</em>은 <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>가 기대하는 인자입니다. 간단한 경우, 테스트 패키지의 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>는 다음과 같을 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">test.support</span> <span class="k">import</span> <span class="n">load_package_tests</span>

<span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">load_package_tests</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.fs_is_case_insensitive">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">fs_is_case_insensitive</code><span class="sig-paren">(</span><em class="sig-param">directory</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.fs_is_case_insensitive" title="정의 주소">¶</a></dt>
<dd><p><em>directory</em>의 파일 시스템이 대소 문자를 구분하지 않으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.detect_api_mismatch">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">detect_api_mismatch</code><span class="sig-paren">(</span><em class="sig-param">ref_api</em>, <em class="sig-param">other_api</em>, <em class="sig-param">*</em>, <em class="sig-param">ignore=()</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.detect_api_mismatch" title="정의 주소">¶</a></dt>
<dd><p><em>ignore</em>에 지정된 이 검사에서 무시할 정의된 항목 리스트를 제외하고, <em>other_api</em>에서 찾을 수 없는 <em>ref_api</em>의 어트리뷰트, 함수 또는 메서드 집합을 반환합니다.</p>
<p>기본적으로 이것은 '_'로 시작하는 내부(private) 어트리뷰트를 건너뛰지만, 모든 매직 메서드, 즉 '__'로 시작하고 끝나는 것들을 포함합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.patch">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">patch</code><span class="sig-paren">(</span><em class="sig-param">test_instance</em>, <em class="sig-param">object_to_patch</em>, <em class="sig-param">attr_name</em>, <em class="sig-param">new_value</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.patch" title="정의 주소">¶</a></dt>
<dd><p><em>object_to_patch.attr_name</em>을 <em>new_value</em>로 대체합니다. 또한 <em>test_instance</em>에 대한 정리 절차를 추가하여 <em>object_to_patch</em>의 <em>attr_name</em>을 복원합니다. <em>attr_name</em>은 <em>object_to_patch</em>의 유효한 어트리뷰트여야 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.run_in_subinterp">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">run_in_subinterp</code><span class="sig-paren">(</span><em class="sig-param">code</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.run_in_subinterp" title="정의 주소">¶</a></dt>
<dd><p>서브 인터프리터에서 <em>code</em>를 실행합니다. <a class="reference internal" href="tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a>이 활성화되면 <a class="reference internal" href="unittest.html#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">unittest.SkipTest</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.check_free_after_iterating">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">check_free_after_iterating</code><span class="sig-paren">(</span><em class="sig-param">test</em>, <em class="sig-param">iter</em>, <em class="sig-param">cls</em>, <em class="sig-param">args=()</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.check_free_after_iterating" title="정의 주소">¶</a></dt>
<dd><p>이터레이션 후 <em>iter</em>가 할당 해제되었음을 어서션 합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.missing_compiler_executable">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">missing_compiler_executable</code><span class="sig-paren">(</span><em class="sig-param">cmd_names=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.missing_compiler_executable" title="정의 주소">¶</a></dt>
<dd><p><em>cmd_names</em>에 이름이 나열된 컴파일러 실행 파일이나 <em>cmd_names</em>가 비어있을 때 모든 컴파일러 실행 파일이 있는지 확인하고 누락된 첫 번째 실행 파일을 반환하거나 누락된 것이 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.check__all__">
<code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">check__all__</code><span class="sig-paren">(</span><em class="sig-param">test_case</em>, <em class="sig-param">module</em>, <em class="sig-param">name_of_module=None</em>, <em class="sig-param">extra=()</em>, <em class="sig-param">blacklist=()</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.check__all__" title="정의 주소">¶</a></dt>
<dd><p><em>module</em>의 <code class="docutils literal notranslate"><span class="pre">__all__</span></code> 변수에 모든 공용 이름이 포함되어 있는지 어서션 합니다.</p>
<p>모듈의 공용 이름(그것의 API)은 공용 이름 규칙과 일치하고 <em>module</em>에 정의되었는지에 따라 자동으로 감지됩니다.</p>
<p><em>name_of_module</em> 인자는 공용 API로 감지하기 위해 API를 정의 할 수 있는 모듈을 (문자열이나 튜플로) 지정할 수 있습니다. 이에 대한 한 가지 사례는 <em>module</em>이 다른 모듈에서 공용 API의 일부를 임포트 할 때입니다, C 백 엔드도 가능합니다 (<code class="docutils literal notranslate"><span class="pre">csv</span></code>와 그것의 <code class="docutils literal notranslate"><span class="pre">_csv</span></code> 처럼).</p>
<p><em>extra</em> 인자는 적절한 <code class="docutils literal notranslate"><span class="pre">__module__</span></code> 어트리뷰트가 없는 객체처럼, &quot;공용&quot;으로 자동 감지되지 않는 이름 집합일 수 있습니다. 제공되면, 자동 감지된 항목에 추가됩니다.</p>
<p><em>blacklist</em> 인자는 이름이 공용처럼 보이더라도 공용 API의 일부로 취급해서는 안 되는 이름 집합일 수 있습니다.</p>
<p>사용 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">bar</span>
<span class="kn">import</span> <span class="nn">foo</span>
<span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">from</span> <span class="nn">test</span> <span class="k">import</span> <span class="n">support</span>

<span class="k">class</span> <span class="nc">MiscTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test__all__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">support</span><span class="o">.</span><span class="n">check__all__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foo</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">OtherTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test__all__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BAR_CONST&#39;</span><span class="p">,</span> <span class="s1">&#39;FOO_CONST&#39;</span><span class="p">}</span>
        <span class="n">blacklist</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;baz&#39;</span><span class="p">}</span>  <span class="c1"># 문서화되지 않은 이름.</span>
        <span class="c1"># bar는 _bar에서 API의 일부를 임포트 합니다.</span>
        <span class="n">support</span><span class="o">.</span><span class="n">check__all__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bar</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;_bar&#39;</span><span class="p">),</span>
                             <span class="n">extra</span><span class="o">=</span><span class="n">extra</span><span class="p">,</span> <span class="n">blacklist</span><span class="o">=</span><span class="n">blacklist</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<p><a class="reference internal" href="#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support</span></code></a> 모듈은 다음 클래스를 정의합니다:</p>
<dl class="class">
<dt id="test.support.TransientResource">
<em class="property">class </em><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">TransientResource</code><span class="sig-paren">(</span><em class="sig-param">exc</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.TransientResource" title="정의 주소">¶</a></dt>
<dd><p>인스턴스는 지정된 예외 형이 발생하면 <a class="reference internal" href="#test.support.ResourceDenied" title="test.support.ResourceDenied"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ResourceDenied</span></code></a>를 발생시키는 컨텍스트 관리자입니다. 모든 키워드 인자는 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문 내에서 발생한 예외와 비교할 어트리뷰트/값 쌍으로 처리됩니다. 모든 쌍이 예외의 어트리뷰트와 올바르게 일치할 때만 <a class="reference internal" href="#test.support.ResourceDenied" title="test.support.ResourceDenied"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ResourceDenied</span></code></a>가 발생합니다.</p>
</dd></dl>

<dl class="class">
<dt id="test.support.EnvironmentVarGuard">
<em class="property">class </em><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">EnvironmentVarGuard</code><a class="headerlink" href="#test.support.EnvironmentVarGuard" title="정의 주소">¶</a></dt>
<dd><p>환경 변수를 임시로 설정하거나 설정 해제하는 데 사용되는 클래스. 인스턴스는 컨텍스트 관리자로 사용할 수 있으며 하부 <code class="docutils literal notranslate"><span class="pre">os.environ</span></code>을 조회/수정하기 위한 완전한 딕셔너리 인터페이스를 가질 수 있습니다. 컨텍스트 관리자를 탈출하면 이 인스턴스를 통해 수행된 환경 변수에 대한 모든 변경 사항이 되돌려집니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span>딕셔너리 인터페이스가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="test.support.EnvironmentVarGuard.set">
<code class="sig-prename descclassname">EnvironmentVarGuard.</code><code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="sig-param">envvar</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.EnvironmentVarGuard.set" title="정의 주소">¶</a></dt>
<dd><p>일시적으로 환경 변수 <code class="docutils literal notranslate"><span class="pre">envvar</span></code>를 <code class="docutils literal notranslate"><span class="pre">value</span></code> 값으로 설정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="test.support.EnvironmentVarGuard.unset">
<code class="sig-prename descclassname">EnvironmentVarGuard.</code><code class="sig-name descname">unset</code><span class="sig-paren">(</span><em class="sig-param">envvar</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.EnvironmentVarGuard.unset" title="정의 주소">¶</a></dt>
<dd><p>일시적으로 환경 변수 <code class="docutils literal notranslate"><span class="pre">envvar</span></code>를 설정 해제합니다.</p>
</dd></dl>

<dl class="class">
<dt id="test.support.SuppressCrashReport">
<em class="property">class </em><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">SuppressCrashReport</code><a class="headerlink" href="#test.support.SuppressCrashReport" title="정의 주소">¶</a></dt>
<dd><p>서브 프로세스를 충돌시킬 것으로 예상되는 테스트에서 충돌 대화 상자 팝업을 방지하는 데 사용되는 컨텍스트 관리자.</p>
<p>윈도우에서는, <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680621.aspx">SetErrorMode</a>를 사용하여 윈도우 에러 보고 대화 상자를 비활성화합니다.</p>
<p>유닉스에서는, <a class="reference internal" href="resource.html#resource.setrlimit" title="resource.setrlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">resource.setrlimit()</span></code></a>를 사용하여 <a class="reference internal" href="resource.html#resource.RLIMIT_CORE" title="resource.RLIMIT_CORE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">resource.RLIMIT_CORE</span></code></a>의 소프트 제한을 0으로 설정하여 코어 덤프 파일 생성을 방지하는 데 사용됩니다.</p>
<p>두 플랫폼 모두에서, 이전 값은 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a>에 의해 복원됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="test.support.CleanImport">
<em class="property">class </em><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">CleanImport</code><span class="sig-paren">(</span><em class="sig-param">*module_names</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.CleanImport" title="정의 주소">¶</a></dt>
<dd><p>새 모듈 참조를 반환하도록 임포트를 강제하는 컨텍스트 관리자. 이는 임포트 시 DeprecationWarning의 방출과 같은 모듈 수준 동작을 테스트하는 데 유용합니다. 사용 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">CleanImport</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">):</span>
    <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>  <span class="c1"># 새 참조.</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="test.support.DirsOnSysPath">
<em class="property">class </em><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">DirsOnSysPath</code><span class="sig-paren">(</span><em class="sig-param">*paths</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.DirsOnSysPath" title="정의 주소">¶</a></dt>
<dd><p>sys.path에 디렉터리를 임시로 추가하는 컨텍스트 관리자.</p>
<p>이렇게 하면 <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>의 복사본이 만들어지고, 위치 인자로 지정된 모든 디렉터리를 추가한 다음, 컨텍스트가 끝나면 <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>를 복사된 설정으로 되돌립니다.</p>
<p>객체 교체를 포함하여, 컨텍스트 관리자 본문의 <em>모든</em> <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 수정 사항은 블록 끝에서 되돌려짐에 유의하십시오.</p>
</dd></dl>

<dl class="class">
<dt id="test.support.SaveSignals">
<em class="property">class </em><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">SaveSignals</code><a class="headerlink" href="#test.support.SaveSignals" title="정의 주소">¶</a></dt>
<dd><p>파이썬 시그널 처리기가 등록한 시그널 처리기를 저장하고 복원하는 클래스.</p>
</dd></dl>

<dl class="class">
<dt id="test.support.Matcher">
<em class="property">class </em><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">Matcher</code><a class="headerlink" href="#test.support.Matcher" title="정의 주소">¶</a></dt>
<dd><dl class="method">
<dt id="test.support.Matcher.matches">
<code class="sig-name descname">matches</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">d</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.Matcher.matches" title="정의 주소">¶</a></dt>
<dd><p>단일 딕셔너리를 제공된 인자와 일치시키려고 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="test.support.Matcher.match_value">
<code class="sig-name descname">match_value</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">k</em>, <em class="sig-param">dv</em>, <em class="sig-param">v</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.Matcher.match_value" title="정의 주소">¶</a></dt>
<dd><p>단일 저장된 값(<em>dv</em>)을 제공된 값(<em>v</em>)과 일치시키려고 합니다.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="test.support.WarningsRecorder">
<em class="property">class </em><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">WarningsRecorder</code><a class="headerlink" href="#test.support.WarningsRecorder" title="정의 주소">¶</a></dt>
<dd><p>단위 테스트에 대한 경고를 기록하는 데 사용되는 클래스. 자세한 내용은 위의 <a class="reference internal" href="#test.support.check_warnings" title="test.support.check_warnings"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_warnings()</span></code></a> 설명서를 참조하십시오.</p>
</dd></dl>

<dl class="class">
<dt id="test.support.BasicTestRunner">
<em class="property">class </em><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">BasicTestRunner</code><a class="headerlink" href="#test.support.BasicTestRunner" title="정의 주소">¶</a></dt>
<dd><dl class="method">
<dt id="test.support.BasicTestRunner.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">test</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.BasicTestRunner.run" title="정의 주소">¶</a></dt>
<dd><p><em>test</em>를 실행하고 결과를 반환합니다.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="test.support.FakePath">
<em class="property">class </em><code class="sig-prename descclassname">test.support.</code><code class="sig-name descname">FakePath</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.FakePath" title="정의 주소">¶</a></dt>
<dd><p>단순 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>. 단지 <em>path</em> 인자를 반환하는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__fspath__()</span></code> 메서드를 구현합니다. <em>path</em>가 예외이면, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__fspath__()</span></code>에서 발생시킵니다.</p>
</dd></dl>

</div>
<div class="section" id="module-test.support.socket_helper">
<span id="test-support-socket-helper-utilities-for-socket-tests"></span><h1><a class="reference internal" href="#module-test.support.socket_helper" title="test.support.socket_helper: Support for socket tests."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support.socket_helper</span></code></a> --- 소켓 테스트용 유틸리티<a class="headerlink" href="#module-test.support.socket_helper" title="제목 주소">¶</a></h1>
<p><a class="reference internal" href="#module-test.support.socket_helper" title="test.support.socket_helper: Support for socket tests."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support.socket_helper</span></code></a> 모듈은 소켓 테스트를 지원합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
<dl class="data">
<dt id="test.support.socket_helper.IPV6_ENABLED">
<code class="sig-prename descclassname">test.support.socket_helper.</code><code class="sig-name descname">IPV6_ENABLED</code><a class="headerlink" href="#test.support.socket_helper.IPV6_ENABLED" title="정의 주소">¶</a></dt>
<dd><p>이 호스트에서 IPv6가 활성화되어 있으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정하고, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 설정합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.socket_helper.find_unused_port">
<code class="sig-prename descclassname">test.support.socket_helper.</code><code class="sig-name descname">find_unused_port</code><span class="sig-paren">(</span><em class="sig-param">family=socket.AF_INET</em>, <em class="sig-param">socktype=socket.SOCK_STREAM</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.socket_helper.find_unused_port" title="정의 주소">¶</a></dt>
<dd><p>바인딩에 적합해야 하는 미사용 포트를 반환합니다. 이는 <code class="docutils literal notranslate"><span class="pre">sock</span></code> 매개 변수와 같은 패밀리와 유형으로 (기본값은 <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a>, <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>) 임시 소켓을 만들고, 포트를 0으로 설정하여 지정된 호스트 주소(기본값은 <code class="docutils literal notranslate"><span class="pre">0.0.0.0</span></code>)에 바인딩하여, OS에서 사용되지 않은 임시 포트를 도출하여 수행됩니다. 그런 다음 임시 소켓이 닫히고 삭제되고, 임시 포트가 반환됩니다.</p>
<p>이 메서드나 <a class="reference internal" href="#test.support.socket_helper.bind_port" title="test.support.socket_helper.bind_port"><code class="xref py py-func docutils literal notranslate"><span class="pre">bind_port()</span></code></a>는 테스트 기간 중 서버 소켓을 특정 포트에 바인딩해야 하는 모든 테스트에 사용해야 합니다. 어떤 것을 사용할 것인지는 호출하는 코드가 파이썬 소켓을 만드는지, 또는 사용되지 않은 포트가 생성자에서 제공되어야 하는지 또는 외부 프로그램에 전달되어야 하는지 (즉 openssl의 s_server 모드에 대한 <code class="docutils literal notranslate"><span class="pre">-accept</span></code> 인자)에 따라 다릅니다. 가능하면 항상 <a class="reference internal" href="#test.support.socket_helper.find_unused_port" title="test.support.socket_helper.find_unused_port"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_unused_port()</span></code></a>보다 <a class="reference internal" href="#test.support.socket_helper.bind_port" title="test.support.socket_helper.bind_port"><code class="xref py py-func docutils literal notranslate"><span class="pre">bind_port()</span></code></a>를 선호하십시오. 하드 코딩된 포트를 사용하면 여러 테스트 인스턴스를 동시에 실행할 수 없게 되어 빌드 봇에 문제가 될 수 있어서 피하는 것이 좋습니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.socket_helper.bind_port">
<code class="sig-prename descclassname">test.support.socket_helper.</code><code class="sig-name descname">bind_port</code><span class="sig-paren">(</span><em class="sig-param">sock</em>, <em class="sig-param">host=HOST</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.socket_helper.bind_port" title="정의 주소">¶</a></dt>
<dd><p>소켓을 사용 가능한 포트에 바인딩하고 포트 번호를 반환합니다. 바인딩 되지 않은 포트를 사용하기 위해 임시 포트에 의존합니다. 이는 특히 빌드 봇 환경에서, 많은 테스트가 동시에 실행될 수 있어서 중요합니다. 이 메서드는 <code class="docutils literal notranslate"><span class="pre">sock.family</span></code>가 <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a>이고 <code class="docutils literal notranslate"><span class="pre">sock.type</span></code>이 <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>이고, 소켓에 <code class="xref py py-const docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code>이나 <code class="xref py py-const docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code>가 설정되면 예외가 발생합니다. 테스트는 TCP/IP 소켓에 대해 이러한 소켓 옵션을 설정해서는 안 됩니다. 이러한 옵션을 설정하는 유일한 경우는 여러 UDP 소켓을 통해 멀티캐스팅을 테스트하는 것입니다.</p>
<p>또한, <code class="xref py py-const docutils literal notranslate"><span class="pre">SO_EXCLUSIVEADDRUSE</span></code> 소켓 옵션을 사용할 수 있으면 (즉 윈도우에서), 소켓에 설정됩니다. 이렇게 하면 다른 사람이 테스트 기간 중 우리의 호스트/포트에 바인딩하는 것을 방지할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.socket_helper.bind_unix_socket">
<code class="sig-prename descclassname">test.support.socket_helper.</code><code class="sig-name descname">bind_unix_socket</code><span class="sig-paren">(</span><em class="sig-param">sock</em>, <em class="sig-param">addr</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.socket_helper.bind_unix_socket" title="정의 주소">¶</a></dt>
<dd><p>유닉스 소켓을 바인드 합니다, <a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PermissionError</span></code></a>가 발생하면 <a class="reference internal" href="unittest.html#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">unittest.SkipTest</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.socket_helper.skip_unless_bind_unix_socket">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">test.support.socket_helper.</code><code class="sig-name descname">skip_unless_bind_unix_socket</code><a class="headerlink" href="#test.support.socket_helper.skip_unless_bind_unix_socket" title="정의 주소">¶</a></dt>
<dd><p>유닉스 소켓용 <code class="docutils literal notranslate"><span class="pre">bind()</span></code> 기능이 필요한 테스트를 실행하기 위한 데코레이터.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.socket_helper.transient_internet">
<code class="sig-prename descclassname">test.support.socket_helper.</code><code class="sig-name descname">transient_internet</code><span class="sig-paren">(</span><em class="sig-param">resource_name</em>, <em class="sig-param">*</em>, <em class="sig-param">timeout=30.0</em>, <em class="sig-param">errnos=()</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.socket_helper.transient_internet" title="정의 주소">¶</a></dt>
<dd><p>인터넷 연결과 관련된 다양한 문제가 예외로 나타날 때 <a class="reference internal" href="#test.support.ResourceDenied" title="test.support.ResourceDenied"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ResourceDenied</span></code></a>를 발생시키는 컨텍스트 관리자.</p>
</dd></dl>

</div>
<div class="section" id="module-test.support.script_helper">
<span id="test-support-script-helper-utilities-for-the-python-execution-tests"></span><h1><a class="reference internal" href="#module-test.support.script_helper" title="test.support.script_helper: Support for Python's script execution tests."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support.script_helper</span></code></a> --- 파이썬 실행 테스트용 유틸리티<a class="headerlink" href="#module-test.support.script_helper" title="제목 주소">¶</a></h1>
<p><a class="reference internal" href="#module-test.support.script_helper" title="test.support.script_helper: Support for Python's script execution tests."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support.script_helper</span></code></a> 모듈은 파이썬의 스크립트 실행 테스트를 지원합니다.</p>
<dl class="function">
<dt id="test.support.script_helper.interpreter_requires_environment">
<code class="sig-prename descclassname">test.support.script_helper.</code><code class="sig-name descname">interpreter_requires_environment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#test.support.script_helper.interpreter_requires_environment" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">sys.executable</span> <span class="pre">인터프리터</span></code>를 실행하기 위해 환경 변수가 필요하면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">assert_python*()</span></code> 함수를 사용하여 격리 모드(<code class="docutils literal notranslate"><span class="pre">-I</span></code>)를 시작하거나 환경 없음 모드(<code class="docutils literal notranslate"><span class="pre">-E</span></code>) 서브 인터프리터 프로세스를 시작해야 하는 테스트를 어노테이트 하는 <code class="docutils literal notranslate"><span class="pre">&#64;unittest.skipIf()</span></code>와 함께 사용하도록 설계되었습니다.</p>
<p>정상적인 빌드와 테스트는 이러한 상황을 만나지 않지만, 파이썬의 현재 홈 찾기 논리로 명확한 홈이 없는 인터프리터에서 표준 라이브러리 테스트 스위트를 실행하려고 할 때 발생할 수 있습니다.</p>
<p><span class="target" id="index-12"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a> 설정은 이러한 상황에서 대부분의 테스트 스위트를 실행하는 한 가지 방법입니다. <span class="target" id="index-13"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a>나 <span class="target" id="index-14"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONUSERSITE</span></code>는 인터프리터가 시작될 수 있는지에 영향을 줄 수 있는 다른 공통 환경 변수입니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.script_helper.run_python_until_end">
<code class="sig-prename descclassname">test.support.script_helper.</code><code class="sig-name descname">run_python_until_end</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**env_vars</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.script_helper.run_python_until_end" title="정의 주소">¶</a></dt>
<dd><p>서브 프로세스에서 인터프리터를 실행하기 위해 <em>env_vars</em> 기반 환경을 설정합니다. 값에는 <code class="docutils literal notranslate"><span class="pre">__isolated</span></code>, <code class="docutils literal notranslate"><span class="pre">__cleanenv</span></code>, <code class="docutils literal notranslate"><span class="pre">__cwd</span></code> 및 <code class="docutils literal notranslate"><span class="pre">TERM</span></code>이 포함될 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>이 함수는 더는 <em>stderr</em>에서 공백을 제거하지 않습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.script_helper.assert_python_ok">
<code class="sig-prename descclassname">test.support.script_helper.</code><code class="sig-name descname">assert_python_ok</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**env_vars</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.script_helper.assert_python_ok" title="정의 주소">¶</a></dt>
<dd><p><em>args</em>와 선택적 환경 변수 <em>env_vars</em>를 사용하여 인터프리터를 실행하면 성공(<code class="docutils literal notranslate"><span class="pre">rc</span> <span class="pre">==</span> <span class="pre">0</span></code>)하고 <code class="docutils literal notranslate"><span class="pre">(return</span> <span class="pre">code,</span> <span class="pre">stdout,</span> <span class="pre">stderr)</span></code> 튜플을 반환함을 어서션 합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">__cleanenv</span></code> 키워드가 설정되면, <em>env_vars</em>가 새로운 환경으로 사용됩니다.</p>
<p>파이썬은 <code class="docutils literal notranslate"><span class="pre">__isolated</span></code> 키워드가 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 설정된 경우를 제외하고, 격리 모드(명령 줄 옵션 <code class="docutils literal notranslate"><span class="pre">-I</span></code>)에서 시작됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>이 함수는 더는 <em>stderr</em>에서 공백을 제거하지 않습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.script_helper.assert_python_failure">
<code class="sig-prename descclassname">test.support.script_helper.</code><code class="sig-name descname">assert_python_failure</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**env_vars</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.script_helper.assert_python_failure" title="정의 주소">¶</a></dt>
<dd><p><em>args</em>와 선택적 환경 변수 <em>env_vars</em>를 사용하여 인터프리터 실행하면 실패(<code class="docutils literal notranslate"><span class="pre">rc</span> <span class="pre">!=</span> <span class="pre">0</span></code>)하고 <code class="docutils literal notranslate"><span class="pre">(return</span> <span class="pre">code,</span> <span class="pre">stdout,</span> <span class="pre">stderr)</span></code> 튜플을 반환함을 어서션 합니다.</p>
<p>추가 옵션은 <a class="reference internal" href="#test.support.script_helper.assert_python_ok" title="test.support.script_helper.assert_python_ok"><code class="xref py py-func docutils literal notranslate"><span class="pre">assert_python_ok()</span></code></a>를 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>이 함수는 더는 <em>stderr</em>에서 공백을 제거하지 않습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="test.support.script_helper.spawn_python">
<code class="sig-prename descclassname">test.support.script_helper.</code><code class="sig-name descname">spawn_python</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">stdout=subprocess.PIPE</em>, <em class="sig-param">stderr=subprocess.STDOUT</em>, <em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.script_helper.spawn_python" title="정의 주소">¶</a></dt>
<dd><p>주어진 인자로 파이썬 서브 프로세스를 실행합니다.</p>
<p><em>kw</em>는 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">subprocess.Popen()</span></code></a>에 전달할 추가 키워드 인자입니다. <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 객체를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.script_helper.kill_python">
<code class="sig-prename descclassname">test.support.script_helper.</code><code class="sig-name descname">kill_python</code><span class="sig-paren">(</span><em class="sig-param">p</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.script_helper.kill_python" title="정의 주소">¶</a></dt>
<dd><p>완료될 때까지 주어진 <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 프로세스를 실행하고 stdout을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.script_helper.make_script">
<code class="sig-prename descclassname">test.support.script_helper.</code><code class="sig-name descname">make_script</code><span class="sig-paren">(</span><em class="sig-param">script_dir</em>, <em class="sig-param">script_basename</em>, <em class="sig-param">source</em>, <em class="sig-param">omit_suffix=False</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.script_helper.make_script" title="정의 주소">¶</a></dt>
<dd><p><em>script_dir</em>과 <em>script_basename</em> 경로에 <em>source</em>를 포함하는 스크립트를 만듭니다. <em>omit_suffix</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, 이름에 <code class="docutils literal notranslate"><span class="pre">.py</span></code>를 추가합니다. 전체 스크립트 경로를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.script_helper.make_zip_script">
<code class="sig-prename descclassname">test.support.script_helper.</code><code class="sig-name descname">make_zip_script</code><span class="sig-paren">(</span><em class="sig-param">zip_dir</em>, <em class="sig-param">zip_basename</em>, <em class="sig-param">script_name</em>, <em class="sig-param">name_in_zip=None</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.script_helper.make_zip_script" title="정의 주소">¶</a></dt>
<dd><p><em>script_name</em>의 파일을 포함하는 확장자가 <code class="docutils literal notranslate"><span class="pre">zip</span></code>인 zip 파일을 <em>zip_dir</em>과 <em>zip_basename</em>에 만듭니다. <em>name_in_zip</em>은 아카이브 이름입니다. <code class="docutils literal notranslate"><span class="pre">(full</span> <span class="pre">path,</span> <span class="pre">full</span> <span class="pre">path</span> <span class="pre">of</span> <span class="pre">archive</span> <span class="pre">name)</span></code>을 포함하는 튜플을 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.script_helper.make_pkg">
<code class="sig-prename descclassname">test.support.script_helper.</code><code class="sig-name descname">make_pkg</code><span class="sig-paren">(</span><em class="sig-param">pkg_dir</em>, <em class="sig-param">init_source=''</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.script_helper.make_pkg" title="정의 주소">¶</a></dt>
<dd><p><em>init_source</em>를 내용으로 하는 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 파일을 포함하는 <em>pkg_dir</em>이라는 디렉터리를 만듭니다.</p>
</dd></dl>

<dl class="function">
<dt id="test.support.script_helper.make_zip_pkg">
<code class="sig-prename descclassname">test.support.script_helper.</code><code class="sig-name descname">make_zip_pkg</code><span class="sig-paren">(</span><em class="sig-param">zip_dir</em>, <em class="sig-param">zip_basename</em>, <em class="sig-param">pkg_name</em>, <em class="sig-param">script_basename</em>, <em class="sig-param">source</em>, <em class="sig-param">depth=1</em>, <em class="sig-param">compiled=False</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.script_helper.make_zip_pkg" title="정의 주소">¶</a></dt>
<dd><p>빈 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 파일과 <em>source</em>를 포함하는 파일 <em>script_basename</em>을 포함하는 zip 패키지 디렉터리를 <em>zip_dir</em>과 <em>zip_basename</em> 경로로 만듭니다. <em>compiled</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, 두 소스 파일이 모두 컴파일되어 zip 패키지에 추가됩니다. 전체 zip 경로와 zip 파일의 아카이브 이름의 튜플을 반환합니다.</p>
</dd></dl>

</div>
<div class="section" id="module-test.support.bytecode_helper">
<span id="test-support-bytecode-helper-support-tools-for-testing-correct-bytecode-generation"></span><h1><a class="reference internal" href="#module-test.support.bytecode_helper" title="test.support.bytecode_helper: Support tools for testing correct bytecode generation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support.bytecode_helper</span></code></a> --- 올바른 바이트 코드 생성 테스트를 위한 지원 도구<a class="headerlink" href="#module-test.support.bytecode_helper" title="제목 주소">¶</a></h1>
<p><a class="reference internal" href="#module-test.support.bytecode_helper" title="test.support.bytecode_helper: Support tools for testing correct bytecode generation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support.bytecode_helper</span></code></a> 모듈은 바이트 코드 생성 테스트와 검사를 지원합니다.</p>
<p>모듈은 다음 클래스를 정의합니다:</p>
<dl class="class">
<dt id="test.support.bytecode_helper.BytecodeTestCase">
<em class="property">class </em><code class="sig-prename descclassname">test.support.bytecode_helper.</code><code class="sig-name descname">BytecodeTestCase</code><span class="sig-paren">(</span><em class="sig-param">unittest.TestCase</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.bytecode_helper.BytecodeTestCase" title="정의 주소">¶</a></dt>
<dd><p>이 클래스에는 바이트 코드를 검사하기 위한 사용자 정의 어서션 메서드가 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="test.support.bytecode_helper.BytecodeTestCase.get_disassembly_as_string">
<code class="sig-prename descclassname">BytecodeTestCase.</code><code class="sig-name descname">get_disassembly_as_string</code><span class="sig-paren">(</span><em class="sig-param">co</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.bytecode_helper.BytecodeTestCase.get_disassembly_as_string" title="정의 주소">¶</a></dt>
<dd><p><em>co</em>의 역 어셈블리를 문자열로 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="test.support.bytecode_helper.BytecodeTestCase.assertInBytecode">
<code class="sig-prename descclassname">BytecodeTestCase.</code><code class="sig-name descname">assertInBytecode</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">opname</em>, <em class="sig-param">argval=_UNSPECIFIED</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.bytecode_helper.BytecodeTestCase.assertInBytecode" title="정의 주소">¶</a></dt>
<dd><p><em>opname</em>이 발견되면 명령어를 반환하고, 그렇지 않으면 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a>를 던집니다.</p>
</dd></dl>

<dl class="method">
<dt id="test.support.bytecode_helper.BytecodeTestCase.assertNotInBytecode">
<code class="sig-prename descclassname">BytecodeTestCase.</code><code class="sig-name descname">assertNotInBytecode</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">opname</em>, <em class="sig-param">argval=_UNSPECIFIED</em><span class="sig-paren">)</span><a class="headerlink" href="#test.support.bytecode_helper.BytecodeTestCase.assertNotInBytecode" title="정의 주소">¶</a></dt>
<dd><p><em>opname</em>이 발견되면 <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a>를 던집니다.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">test</span></code> --- 파이썬 용 회귀 테스트 패키지</a><ul>
<li><a class="reference internal" href="#writing-unit-tests-for-the-test-package"><code class="xref py py-mod docutils literal notranslate"><span class="pre">test</span></code> 패키지를 위한 단위 테스트 작성하기</a></li>
<li><a class="reference internal" href="#running-tests-using-the-command-line-interface">명령 줄 인터페이스를 사용하여 테스트 실행하기</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-test.support"><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support</span></code> --- 파이썬 테스트 스위트용 유틸리티</a></li>
<li><a class="reference internal" href="#module-test.support.socket_helper"><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support.socket_helper</span></code> --- 소켓 테스트용 유틸리티</a></li>
<li><a class="reference internal" href="#module-test.support.script_helper"><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support.script_helper</span></code> --- 파이썬 실행 테스트용 유틸리티</a></li>
<li><a class="reference internal" href="#module-test.support.bytecode_helper"><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.support.bytecode_helper</span></code> --- 올바른 바이트 코드 생성 테스트를 위한 지원 도구</a></li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="2to3.html"
                        title="이전 장">2to3 - 파이썬 2에서 파이썬 3으로 자동 코드 변환</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="debug.html"
                        title="다음 장">디버깅과 프로파일링</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="debug.html" title="디버깅과 프로파일링"
             >다음</a> |</li>
        <li class="right" >
          <a href="2to3.html" title="2to3 - 파이썬 2에서 파이썬 3으로 자동 코드 변환"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >개발 도구</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>