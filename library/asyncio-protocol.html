
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>트랜스포트와 프로토콜 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="Policies" href="asyncio-policy.html" />
    <link rel="prev" title="퓨처" href="asyncio-future.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/library/asyncio-protocol.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-policy.html" title="Policies"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="퓨처"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U"><code class="docutils literal notranslate"><span class="pre">asyncio</span></code> --- 비동기 I/O</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="transports-and-protocols">
<span id="asyncio-transports-protocols"></span><h1>트랜스포트와 프로토콜<a class="headerlink" href="#transports-and-protocols" title="제목 주소">¶</a></h1>
<p class="rubric">머리말</p>
<p>트랜스포트와 프로토콜은 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>와 같은 <strong>저수준</strong> 이벤트 루프 API에서 사용됩니다. 그들은 콜백 기반 프로그래밍 스타일을 사용하고 네트워크 나 IPC 프로토콜(예를 들어 HTTP)의 고성능 구현을 가능하게합니다.</p>
<p>본질적으로 트랜스포트와 프로토콜은 라이브러리와 프레임워크에서만 사용되어야하며 고수준 asyncio 응용 프로그램에서는 사용되지 않아야합니다.</p>
<p>이 문서 페이지는 <a class="reference internal" href="#transports">트랜스포트</a>와 <a class="reference internal" href="#protocols">프로토콜</a>을 모두 다룹니다.</p>
<p class="rubric">소개</p>
<p>최상위 수준에서, 트랜스포트는 <em>어떻게(how)</em> 바이트를 전송할지를 다루는 반면, 프로토콜은 <em>어떤(which)</em> 바이트를 전송할지를 결정합니다 (그리고 어느 정도는 언제(when)도).</p>
<p>같은 것을 다른 식으로 말하면: 트랜스포트는 소켓(또는 유사한 I/O 엔드포인트)의 추상화인 반면, 프로토콜은 트랜스포트의 관점에서 응용 프로그램의 추상화입니다.</p>
<p>또 다른 시각은 트랜스포트와 프로토콜 인터페이스가 함께 네트워크 I/O 와 프로세스 간 I/O 를 사용하기위한 추상 인터페이스를 정의한다는 것입니다.</p>
<p>트랜스포트 객체와 프로토콜 객체 간에는 항상 1:1 관계가 있습니다: 프로토콜은 트랜스포트 메서드를 호출하여 데이터를 보내는 반면, 트랜스포트는 프로토콜 메서드를 호출하여 받은 데이터를 전달합니다.</p>
<p>대부분의 연결 지향 이벤트 루프 메서드(가령 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>)는 <em>Transport</em> 객체로 표현되는 받아들인 연결을 위한 <em>Protocol</em> 객체를 만드는 데 사용되는 <em>protocol_factory</em> 인자를 받아들입니다. 이러한 메서드는 대개 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>의 튜플을 반환합니다.</p>
<p class="rubric">목차</p>
<p>이 설명서 페이지는 다음 절로 구성됩니다:</p>
<ul class="simple">
<li><a class="reference internal" href="#transports">트랜스포트</a> 절은 asyncio <a class="reference internal" href="#asyncio.BaseTransport" title="asyncio.BaseTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseTransport</span></code></a>, <a class="reference internal" href="#asyncio.ReadTransport" title="asyncio.ReadTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReadTransport</span></code></a>, <a class="reference internal" href="#asyncio.WriteTransport" title="asyncio.WriteTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">WriteTransport</span></code></a>, <a class="reference internal" href="#asyncio.Transport" title="asyncio.Transport"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transport</span></code></a>, <a class="reference internal" href="#asyncio.DatagramTransport" title="asyncio.DatagramTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">DatagramTransport</span></code></a> 및 <a class="reference internal" href="#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessTransport</span></code></a> 클래스를 설명합니다.</li>
<li><a class="reference internal" href="#protocols">프로토콜</a> 절은 asyncio <a class="reference internal" href="#asyncio.BaseProtocol" title="asyncio.BaseProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseProtocol</span></code></a>, <a class="reference internal" href="#asyncio.Protocol" title="asyncio.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>, <a class="reference internal" href="#asyncio.BufferedProtocol" title="asyncio.BufferedProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedProtocol</span></code></a>, <a class="reference internal" href="#asyncio.DatagramProtocol" title="asyncio.DatagramProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">DatagramProtocol</span></code></a> 및 <a class="reference internal" href="#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessProtocol</span></code></a> 클래스를 설명합니다.</li>
<li><a class="reference internal" href="#examples">예제</a> 절은 트랜스포트, 프로토콜 및 저수준 이벤트 루프 API를 사용하는 방법을 보여줍니다.</li>
</ul>
<div class="section" id="transports">
<span id="asyncio-transport"></span><h2>트랜스포트<a class="headerlink" href="#transports" title="제목 주소">¶</a></h2>
<p>트랜스포트는 다양한 종류의 통신 채널을 추상화하기 위해 <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>에서 제공하는 클래스입니다.</p>
<p>트랜스포트 객체는 항상 ref:<cite>asyncio 이벤트 루프 &lt;asyncio-event-loop&gt;</cite>에 의해 인스턴스로 만들어집니다.</p>
<p>asyncio는 TCP, UDP, SSL 및 서브 프로세스 파이프를 위한 트랜스포트를 구현합니다. 트랜스포트에서 사용할 수 있는 메서드는 트랜스포트의 종류에 따라 다릅니다.</p>
<p>트랜스포트 클래스는 <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">스레드 안전하지 않습니다</span></a>.</p>
<div class="section" id="transports-hierarchy">
<h3>트랜스포트 계층 구조<a class="headerlink" href="#transports-hierarchy" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="asyncio.BaseTransport">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">BaseTransport</code><a class="headerlink" href="#asyncio.BaseTransport" title="정의 주소">¶</a></dt>
<dd><p>모든 트랜스포트의 베이스 클래스. 모든 asyncio 트랜스포트가 공유하는 메서드를 포함합니다.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.WriteTransport">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">WriteTransport</code><span class="sig-paren">(</span><em>BaseTransport</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport" title="정의 주소">¶</a></dt>
<dd><p>쓰기 전용 연결을 위한 베이스 트랜스포트</p>
<p><em>WriteTransport</em> 클래스의 인스턴스는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_write_pipe()</span></code></a> 이벤트 루프 메서드에서 반환되며 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a>와 같은 서브 프로세스 관련 메서드에서도 사용됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.ReadTransport">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">ReadTransport</code><span class="sig-paren">(</span><em>BaseTransport</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.ReadTransport" title="정의 주소">¶</a></dt>
<dd><p>읽기 전용 연결을 위한 베이스 트랜스포트</p>
<p><em>ReadTransport</em> 클래스의 인스턴스는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.connect_read_pipe" title="asyncio.loop.connect_read_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_read_pipe()</span></code></a> 이벤트 루프 메서드에서 반환되며 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a>와 같은 서브 프로세스 관련 메서드에서도 사용됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.Transport">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">Transport</code><span class="sig-paren">(</span><em>WriteTransport</em>, <em>ReadTransport</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Transport" title="정의 주소">¶</a></dt>
<dd><p>TCP 연결과 같은 양방향 트랜스포트를 나타내는 인터페이스.</p>
<p>사용자는 트랜스포트를 직접 인스턴스로 만들지 않습니다; 유틸리티 함수를 호출하고, 프로토콜 팩토리와 트랜스포트와 프로토콜을 만드는 데 필요한 기타 정보를 전달합니다.</p>
<p><em>Transport</em> 클래스의 인스턴스는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_unix_connection" title="asyncio.loop.create_unix_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_connection()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.sendfile" title="asyncio.loop.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.sendfile()</span></code></a> 등과 같은 이벤트 루프 메서드에서 반환되거나 사용됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.DatagramTransport">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">DatagramTransport</code><span class="sig-paren">(</span><em>BaseTransport</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.DatagramTransport" title="정의 주소">¶</a></dt>
<dd><p>데이터 그램 (UDP) 연결을 위한 트랜스포트.</p>
<p><em>DatagramTransport</em> 클래스의 인스턴스는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_datagram_endpoint" title="asyncio.loop.create_datagram_endpoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_datagram_endpoint()</span></code></a> 이벤트 루프 메서드에서 반환됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.SubprocessTransport">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">SubprocessTransport</code><span class="sig-paren">(</span><em>BaseTransport</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport" title="정의 주소">¶</a></dt>
<dd><p>부모와 그 자식 OS 프로세스 간의 연결을 나타내는 추상화.</p>
<p><em>SubprocessTransport</em> 클래스의 인스턴스는 이벤트 루프 메서드 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_shell" title="asyncio.loop.subprocess_shell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_shell()</span></code></a> 과 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a>에서 반환됩니다.</p>
</dd></dl>

</div>
<div class="section" id="base-transport">
<h3>베이스 트랜스포트<a class="headerlink" href="#base-transport" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.BaseTransport.close">
<code class="descclassname">BaseTransport.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseTransport.close" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트를 닫습니다.</p>
<p>트랜스포트에 송신 데이터 용 버퍼가 있으면, 버퍼링된 데이터는 비동기적으로 플러시됩니다. 더는 데이터가 수신되지 않습니다. 버퍼링된 모든 데이터가 플러시된 후, 프로토콜의 <a class="reference internal" href="#asyncio.BaseProtocol.connection_lost" title="asyncio.BaseProtocol.connection_lost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.connection_lost()</span></code></a> 메서드가 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 인자로 사용하여 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseTransport.is_closing">
<code class="descclassname">BaseTransport.</code><code class="descname">is_closing</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseTransport.is_closing" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트가 닫히는 중이거나 닫혔으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseTransport.get_extra_info">
<code class="descclassname">BaseTransport.</code><code class="descname">get_extra_info</code><span class="sig-paren">(</span><em>name</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseTransport.get_extra_info" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트나 그 것이 사용하는 하부 자원에 대한 정보를 반환합니다.</p>
<p><em>name</em>은 얻고자 하는 트랜스포트 특정 정보의 조각을 나타내는 문자열입니다.</p>
<p><em>default</em>는 정보가 없거나 트랜스포트가 제삼자 이벤트 루프 구현이나 현재 플랫폼에서 조회를 지원하지 않을 때 반환 할 값입니다.</p>
<p>예를 들어, 다음 코드는 트랜스포트의 하부 소켓 객체를 가져 오려고 시도합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sock</span> <span class="o">=</span> <span class="n">transport</span><span class="o">.</span><span class="n">get_extra_info</span><span class="p">(</span><span class="s1">&#39;socket&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">getsockopt</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
</pre></div>
</div>
<p>일부 트랜스포트에서 조회할 수 있는 정보의 범주:</p>
<ul class="simple">
<li>소켓:<ul>
<li><code class="docutils literal notranslate"><span class="pre">'peername'</span></code>: 소켓이 연결된 원격 주소, <a class="reference internal" href="socket.html#socket.socket.getpeername" title="socket.socket.getpeername"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.getpeername()</span></code></a>의 결과 (에러 시 <code class="docutils literal notranslate"><span class="pre">None</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">'socket'</span></code>: <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> 인스턴스</li>
<li><code class="docutils literal notranslate"><span class="pre">'sockname'</span></code>: 소켓 자체 주소, <a class="reference internal" href="socket.html#socket.socket.getsockname" title="socket.socket.getsockname"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.getsockname()</span></code></a>의 결과</li>
</ul>
</li>
<li>SSL 소켓:<ul>
<li><code class="docutils literal notranslate"><span class="pre">'compression'</span></code>: 문자열로 표현된 사용된 압축 알고리즘, 또는 연결이 압축되지 않았으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>; <a class="reference internal" href="ssl.html#ssl.SSLSocket.compression" title="ssl.SSLSocket.compression"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLSocket.compression()</span></code></a>의 결과</li>
<li><code class="docutils literal notranslate"><span class="pre">'cipher'</span></code>: 사용되는 암호 체계의 이름, 이의 사용을 정의하는 SSL 프로토콜의 버전 및 사용되는 비밀 비트의 수를 포함하는 3-튜플; <a class="reference internal" href="ssl.html#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLSocket.cipher()</span></code></a>의 결과</li>
<li><code class="docutils literal notranslate"><span class="pre">'peercert'</span></code>: 피어 인증서; <a class="reference internal" href="ssl.html#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLSocket.getpeercert()</span></code></a>의 결과</li>
<li><code class="docutils literal notranslate"><span class="pre">'sslcontext'</span></code>: <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 인스턴스</li>
<li><code class="docutils literal notranslate"><span class="pre">'ssl_object'</span></code>: <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a> 나 <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> 인스턴스</li>
</ul>
</li>
<li>파이프:<ul>
<li><code class="docutils literal notranslate"><span class="pre">'pipe'</span></code>: 파이프 객체</li>
</ul>
</li>
<li>서브 프로세스:<ul>
<li><code class="docutils literal notranslate"><span class="pre">'subprocess'</span></code>: <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 인스턴스</li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseTransport.set_protocol">
<code class="descclassname">BaseTransport.</code><code class="descname">set_protocol</code><span class="sig-paren">(</span><em>protocol</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseTransport.set_protocol" title="정의 주소">¶</a></dt>
<dd><p>새 프로토콜을 설정합니다.</p>
<p>프로토콜의 교환은 두 프로토콜이 교환을 지원한다고 문서화 되었을 때만 수행되어야합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseTransport.get_protocol">
<code class="descclassname">BaseTransport.</code><code class="descname">get_protocol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseTransport.get_protocol" title="정의 주소">¶</a></dt>
<dd><p>현재 프로토콜을 반환합니다.</p>
</dd></dl>

</div>
<div class="section" id="read-only-transports">
<h3>읽기 전용 트랜스포트<a class="headerlink" href="#read-only-transports" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.ReadTransport.is_reading">
<code class="descclassname">ReadTransport.</code><code class="descname">is_reading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.ReadTransport.is_reading" title="정의 주소">¶</a></dt>
<dd><p>트랜스 포트가 새로운 데이터를 받고있으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.ReadTransport.pause_reading">
<code class="descclassname">ReadTransport.</code><code class="descname">pause_reading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.ReadTransport.pause_reading" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트의 수신 끝을 일시 중지합니다. <a class="reference internal" href="#asyncio.ReadTransport.resume_reading" title="asyncio.ReadTransport.resume_reading"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resume_reading()</span></code></a>이 호출 될 때까지 프로토콜의 <a class="reference internal" href="#asyncio.Protocol.data_received" title="asyncio.Protocol.data_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.data_received()</span></code></a> 메서드에 데이터가 전달되지 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>이 메서드는 멱등적(idempotent)입니다. 즉, 트랜스포트가 이미 일시 중지되거나 닫혔을 때도 호출 할 수 있습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.ReadTransport.resume_reading">
<code class="descclassname">ReadTransport.</code><code class="descname">resume_reading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.ReadTransport.resume_reading" title="정의 주소">¶</a></dt>
<dd><p>수신 끝을 재개합니다. 읽을 수 있는 데이터가 있다면 프로토콜의 <a class="reference internal" href="#asyncio.Protocol.data_received" title="asyncio.Protocol.data_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.data_received()</span></code></a> 메서드가 다시 한 번 호출됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>이 메서드는 멱등적(idempotent)입니다. 즉, 트랜스포트가 이미 읽고 있을 때도 호출 할 수 있습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="write-only-transports">
<h3>쓰기 전용 트랜스포트<a class="headerlink" href="#write-only-transports" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.WriteTransport.abort">
<code class="descclassname">WriteTransport.</code><code class="descname">abort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.abort" title="정의 주소">¶</a></dt>
<dd><p>계류 중인 작업이 완료 될 때까지 기다리지 않고, 즉시 트랜스포트를 닫습니다. 버퍼링된 데이터는 손실됩니다. 더는 데이터가 수신되지 않습니다. 프로토콜의 <a class="reference internal" href="#asyncio.BaseProtocol.connection_lost" title="asyncio.BaseProtocol.connection_lost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.connection_lost()</span></code></a> 메서드는 결국 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 인자로 사용하여 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.WriteTransport.can_write_eof">
<code class="descclassname">WriteTransport.</code><code class="descname">can_write_eof</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.can_write_eof" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트가 <a class="reference internal" href="#asyncio.WriteTransport.write_eof" title="asyncio.WriteTransport.write_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write_eof()</span></code></a>를 지원하면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.WriteTransport.get_write_buffer_size">
<code class="descclassname">WriteTransport.</code><code class="descname">get_write_buffer_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.get_write_buffer_size" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트가 사용하는 출력 버퍼의 현재 크기를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.WriteTransport.get_write_buffer_limits">
<code class="descclassname">WriteTransport.</code><code class="descname">get_write_buffer_limits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.get_write_buffer_limits" title="정의 주소">¶</a></dt>
<dd><p>쓰기 흐름 제어를 위한 <em>high</em> 와 <em>low</em> 수위(watermark)를 가져옵니다. 튜플 <code class="docutils literal notranslate"><span class="pre">(low,</span> <span class="pre">high)</span></code>를 반환합니다. 여기서 <em>low</em> 와 <em>high</em>는 양의 바이트 수 입니다.</p>
<p>제한을 설정하려면 <a class="reference internal" href="#asyncio.WriteTransport.set_write_buffer_limits" title="asyncio.WriteTransport.set_write_buffer_limits"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_write_buffer_limits()</span></code></a>를 사용하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.WriteTransport.set_write_buffer_limits">
<code class="descclassname">WriteTransport.</code><code class="descname">set_write_buffer_limits</code><span class="sig-paren">(</span><em>high=None</em>, <em>low=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.set_write_buffer_limits" title="정의 주소">¶</a></dt>
<dd><p>쓰기 흐름 제어를 위한 <em>high</em> 와 <em>low</em> 수위(watermark)를 설정합니다.</p>
<p>이 두 값(바이트 수로 측정)은 프로토콜의 <a class="reference internal" href="#asyncio.BaseProtocol.pause_writing" title="asyncio.BaseProtocol.pause_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.pause_writing()</span></code></a> 과 <a class="reference internal" href="#asyncio.BaseProtocol.resume_writing" title="asyncio.BaseProtocol.resume_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.resume_writing()</span></code></a> 메서드가 언제 호출될지를 제어합니다. 지정하면, low 수위는 high 수위보다 작거나 같아야합니다. <em>high</em> 와 <em>low</em>는 음수가 될 수 없습니다.</p>
<p>버퍼 크기가 <em>high</em> 값보다 크거나 같아질 때 <a class="reference internal" href="#asyncio.BaseProtocol.pause_writing" title="asyncio.BaseProtocol.pause_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pause_writing()</span></code></a>가 호출됩니다. 쓰기가 일시 중지되면, 버퍼 크기가 <em>low</em> 값보다 작거나 같아질 때 <a class="reference internal" href="#asyncio.BaseProtocol.resume_writing" title="asyncio.BaseProtocol.resume_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resume_writing()</span></code></a>이 호출됩니다.</p>
<p>기본 값은 구현에 따라 다릅니다. high 수위만 주어지면, low 수위는 high 수위보다 작거나 같은 구현 특정 기본값이 사용됩니다. <em>high</em>를 0으로 설정하면, <em>low</em>도 0으로 설정되고, 버퍼가 비어있지 않게될 때마다 <a class="reference internal" href="#asyncio.BaseProtocol.pause_writing" title="asyncio.BaseProtocol.pause_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pause_writing()</span></code></a>가 호출되도록 합니다. <em>low</em>를 0으로 설정하면 버퍼가 빌 때만 <a class="reference internal" href="#asyncio.BaseProtocol.resume_writing" title="asyncio.BaseProtocol.resume_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resume_writing()</span></code></a>이 호출됩니다. 두 제한 중 하나에 0을 사용하는 것은 I/O 와 계산을 동시에 수행 할 기회를 줄이기 때문에 일반적으로 최선이 아닙니다.</p>
<p>제한을 가져오려면 <a class="reference internal" href="#asyncio.WriteTransport.get_write_buffer_limits" title="asyncio.WriteTransport.get_write_buffer_limits"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_write_buffer_limits()</span></code></a>를 사용하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.WriteTransport.write">
<code class="descclassname">WriteTransport.</code><code class="descname">write</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.write" title="정의 주소">¶</a></dt>
<dd><p>어떤 <em>data</em> 바이트열을 트랜스포트에 기록합니다.</p>
<p>이 메서드는 블록하지 않습니다; 데이터를 버퍼링하고 비동기적으로 전송되도록 배치합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.WriteTransport.writelines">
<code class="descclassname">WriteTransport.</code><code class="descname">writelines</code><span class="sig-paren">(</span><em>list_of_data</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.writelines" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트에 데이터 바이트열 리스트(또는 임의의 이터러블)를 기록합니다. 이것은 이터러블이 산출하는 각 요소에 대해 <a class="reference internal" href="#asyncio.WriteTransport.write" title="asyncio.WriteTransport.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a>를 호출하는 것과 기능면에서 동등하지만, 더 효율적으로 구현 될 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.WriteTransport.write_eof">
<code class="descclassname">WriteTransport.</code><code class="descname">write_eof</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.write_eof" title="정의 주소">¶</a></dt>
<dd><p>버퍼링된 모든 데이터를 플러시 한 후 트랜스포트의 쓰기 끝을 닫습니다. 데이터가 여전히 수신 될 수 있습니다.</p>
<p>이 메서드는 트랜스포트(예를 들어 SSL)가 반만 닫힌 연결을 지원하지 않으면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시킬 수 있습니다.</p>
</dd></dl>

</div>
<div class="section" id="datagram-transports">
<h3>데이터 그램 트랜스포트<a class="headerlink" href="#datagram-transports" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.DatagramTransport.sendto">
<code class="descclassname">DatagramTransport.</code><code class="descname">sendto</code><span class="sig-paren">(</span><em>data</em>, <em>addr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.DatagramTransport.sendto" title="정의 주소">¶</a></dt>
<dd><p><em>addr</em>(트랜스포트 종속적인 대상 주소)에 의해 주어진 원격 피어로 <em>data</em> 바이트열을 보냅니다. <em>addr</em>가 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>이면, 트랜스포트를 만들 때 지정된 대상 주소로 data가 전송됩니다.</p>
<p>이 메서드는 블록하지 않습니다; 데이터를 버퍼링하고 비동기적으로 전송되도록 배치합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.DatagramTransport.abort">
<code class="descclassname">DatagramTransport.</code><code class="descname">abort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.DatagramTransport.abort" title="정의 주소">¶</a></dt>
<dd><p>계류 중인 작업이 완료 될 때까지 기다리지 않고, 즉시 트랜스포트를 닫습니다. 버퍼링된 데이터는 손실됩니다. 더는 데이터가 수신되지 않습니다. 프로토콜의 <a class="reference internal" href="#asyncio.BaseProtocol.connection_lost" title="asyncio.BaseProtocol.connection_lost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.connection_lost()</span></code></a> 메서드는 결국 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 인자로 사용하여 호출됩니다.</p>
</dd></dl>

</div>
<div class="section" id="subprocess-transports">
<span id="asyncio-subprocess-transports"></span><h3>서브 프로세스 트랜스포트<a class="headerlink" href="#subprocess-transports" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.SubprocessTransport.get_pid">
<code class="descclassname">SubprocessTransport.</code><code class="descname">get_pid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport.get_pid" title="정의 주소">¶</a></dt>
<dd><p>Return the subprocess process id as an integer.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessTransport.get_pipe_transport">
<code class="descclassname">SubprocessTransport.</code><code class="descname">get_pipe_transport</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport.get_pipe_transport" title="정의 주소">¶</a></dt>
<dd><p>Return the transport for the communication pipe corresponding to the
integer file descriptor <em>fd</em>:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">0</span></code>: readable streaming transport of the standard input (<em>stdin</em>),
or <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> if the subprocess was not created with <code class="docutils literal notranslate"><span class="pre">stdin=PIPE</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">1</span></code>: writable streaming transport of the standard output (<em>stdout</em>),
or <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> if the subprocess was not created with <code class="docutils literal notranslate"><span class="pre">stdout=PIPE</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">2</span></code>: writable streaming transport of the standard error (<em>stderr</em>),
or <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> if the subprocess was not created with <code class="docutils literal notranslate"><span class="pre">stderr=PIPE</span></code></li>
<li>other <em>fd</em>: <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></li>
</ul>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessTransport.get_returncode">
<code class="descclassname">SubprocessTransport.</code><code class="descname">get_returncode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport.get_returncode" title="정의 주소">¶</a></dt>
<dd><p>Return the subprocess return code as an integer or <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>
if it hasn't returned, which is similar to the
<a class="reference internal" href="subprocess.html#subprocess.Popen.returncode" title="subprocess.Popen.returncode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">subprocess.Popen.returncode</span></code></a> attribute.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessTransport.kill">
<code class="descclassname">SubprocessTransport.</code><code class="descname">kill</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport.kill" title="정의 주소">¶</a></dt>
<dd><p>Kill the subprocess.</p>
<p>On POSIX systems, the function sends SIGKILL to the subprocess.
On Windows, this method is an alias for <a class="reference internal" href="#asyncio.SubprocessTransport.terminate" title="asyncio.SubprocessTransport.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a>.</p>
<p>See also <a class="reference internal" href="subprocess.html#subprocess.Popen.kill" title="subprocess.Popen.kill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess.Popen.kill()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessTransport.send_signal">
<code class="descclassname">SubprocessTransport.</code><code class="descname">send_signal</code><span class="sig-paren">(</span><em>signal</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport.send_signal" title="정의 주소">¶</a></dt>
<dd><p>Send the <em>signal</em> number to the subprocess, as in
<a class="reference internal" href="subprocess.html#subprocess.Popen.send_signal" title="subprocess.Popen.send_signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess.Popen.send_signal()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessTransport.terminate">
<code class="descclassname">SubprocessTransport.</code><code class="descname">terminate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport.terminate" title="정의 주소">¶</a></dt>
<dd><p>Stop the subprocess.</p>
<p>On POSIX systems, this method sends SIGTERM to the subprocess.
On Windows, the Windows API function TerminateProcess() is called to
stop the subprocess.</p>
<p>See also <a class="reference internal" href="subprocess.html#subprocess.Popen.terminate" title="subprocess.Popen.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess.Popen.terminate()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessTransport.close">
<code class="descclassname">SubprocessTransport.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport.close" title="정의 주소">¶</a></dt>
<dd><p>Kill the subprocess by calling the <a class="reference internal" href="#asyncio.SubprocessTransport.kill" title="asyncio.SubprocessTransport.kill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kill()</span></code></a> method.</p>
<p>If the subprocess hasn't returned yet, and close transports of
<em>stdin</em>, <em>stdout</em>, and <em>stderr</em> pipes.</p>
</dd></dl>

</div>
</div>
<div class="section" id="protocols">
<span id="asyncio-protocol"></span><h2>프로토콜<a class="headerlink" href="#protocols" title="제목 주소">¶</a></h2>
<p>asyncio provides a set of abstract base classes that should be used
to implement network protocols.  Those classes are meant to be used
together with <a class="reference internal" href="#asyncio-transport"><span class="std std-ref">transports</span></a>.</p>
<p>Subclasses of abstract base protocol classes may implement some or
all methods.  All these methods are callbacks: they are called by
transports on certain events, for example when some data is received.
A base protocol method should be called by the corresponding transport.</p>
<div class="section" id="base-protocols">
<h3>Base Protocols<a class="headerlink" href="#base-protocols" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="asyncio.BaseProtocol">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">BaseProtocol</code><a class="headerlink" href="#asyncio.BaseProtocol" title="정의 주소">¶</a></dt>
<dd><p>Base protocol with methods that all protocols share.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.Protocol">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">Protocol</code><span class="sig-paren">(</span><em>BaseProtocol</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Protocol" title="정의 주소">¶</a></dt>
<dd><p>The base class for implementing streaming protocols
(TCP, Unix sockets, etc).</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.BufferedProtocol">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">BufferedProtocol</code><span class="sig-paren">(</span><em>BaseProtocol</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BufferedProtocol" title="정의 주소">¶</a></dt>
<dd><p>A base class for implementing streaming protocols with manual
control of the receive buffer.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.DatagramProtocol">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">DatagramProtocol</code><span class="sig-paren">(</span><em>BaseProtocol</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.DatagramProtocol" title="정의 주소">¶</a></dt>
<dd><p>The base class for implementing datagram (UDP) protocols.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.SubprocessProtocol">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">SubprocessProtocol</code><span class="sig-paren">(</span><em>BaseProtocol</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessProtocol" title="정의 주소">¶</a></dt>
<dd><p>The base class for implementing protocols communicating with child
processes (unidirectional pipes).</p>
</dd></dl>

</div>
<div class="section" id="base-protocol">
<h3>Base Protocol<a class="headerlink" href="#base-protocol" title="제목 주소">¶</a></h3>
<p>All asyncio protocols can implement Base Protocol callbacks.</p>
<p class="rubric">Connection Callbacks</p>
<p>Connection callbacks are called on all protocols, exactly once per
a successful connection.  All other protocol callbacks can only be
called between those two methods.</p>
<dl class="method">
<dt id="asyncio.BaseProtocol.connection_made">
<code class="descclassname">BaseProtocol.</code><code class="descname">connection_made</code><span class="sig-paren">(</span><em>transport</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseProtocol.connection_made" title="정의 주소">¶</a></dt>
<dd><p>Called when a connection is made.</p>
<p>The <em>transport</em> argument is the transport representing the
connection.  The protocol is responsible for storing the reference
to its transport.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseProtocol.connection_lost">
<code class="descclassname">BaseProtocol.</code><code class="descname">connection_lost</code><span class="sig-paren">(</span><em>exc</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseProtocol.connection_lost" title="정의 주소">¶</a></dt>
<dd><p>Called when the connection is lost or closed.</p>
<p>The argument is either an exception object or <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.
The latter means a regular EOF is received, or the connection was
aborted or closed by this side of the connection.</p>
</dd></dl>

<p class="rubric">Flow Control Callbacks</p>
<p>Flow control callbacks can be called by transports to pause or
resume writing performed by the protocol.</p>
<p>See the documentation of the <a class="reference internal" href="#asyncio.WriteTransport.set_write_buffer_limits" title="asyncio.WriteTransport.set_write_buffer_limits"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_write_buffer_limits()</span></code></a>
method for more details.</p>
<dl class="method">
<dt id="asyncio.BaseProtocol.pause_writing">
<code class="descclassname">BaseProtocol.</code><code class="descname">pause_writing</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseProtocol.pause_writing" title="정의 주소">¶</a></dt>
<dd><p>Called when the transport's buffer goes over the high watermark.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseProtocol.resume_writing">
<code class="descclassname">BaseProtocol.</code><code class="descname">resume_writing</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseProtocol.resume_writing" title="정의 주소">¶</a></dt>
<dd><p>Called when the transport's buffer drains below the low watermark.</p>
</dd></dl>

<p>If the buffer size equals the high watermark,
<a class="reference internal" href="#asyncio.BaseProtocol.pause_writing" title="asyncio.BaseProtocol.pause_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pause_writing()</span></code></a> is not called: the buffer size must
go strictly over.</p>
<p>Conversely, <a class="reference internal" href="#asyncio.BaseProtocol.resume_writing" title="asyncio.BaseProtocol.resume_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resume_writing()</span></code></a> is called when the
buffer size is equal or lower than the low watermark.  These end
conditions are important to ensure that things go as expected when
either mark is zero.</p>
</div>
<div class="section" id="streaming-protocols">
<h3>Streaming Protocols<a class="headerlink" href="#streaming-protocols" title="제목 주소">¶</a></h3>
<p>Event methods, such as <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>,
<a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_unix_server" title="asyncio.loop.create_unix_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_server()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>,
<a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_unix_connection" title="asyncio.loop.create_unix_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_connection()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.connect_accepted_socket" title="asyncio.loop.connect_accepted_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_accepted_socket()</span></code></a>,
<a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.connect_read_pipe" title="asyncio.loop.connect_read_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_read_pipe()</span></code></a>, and <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_write_pipe()</span></code></a>
accept factories that return streaming protocols.</p>
<dl class="method">
<dt id="asyncio.Protocol.data_received">
<code class="descclassname">Protocol.</code><code class="descname">data_received</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Protocol.data_received" title="정의 주소">¶</a></dt>
<dd><p>Called when some data is received.  <em>data</em> is a non-empty bytes
object containing the incoming data.</p>
<p>Whether the data is buffered, chunked or reassembled depends on
the transport.  In general, you shouldn't rely on specific semantics
and instead make your parsing generic and flexible. However,
data is always received in the correct order.</p>
<p>The method can be called an arbitrary number of times while
a connection is open.</p>
<p>However, <a class="reference internal" href="#asyncio.Protocol.eof_received" title="asyncio.Protocol.eof_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.eof_received()</span></code></a>
is called at most once.  Once <cite>eof_received()</cite> is called,
<code class="docutils literal notranslate"><span class="pre">data_received()</span></code> is not called anymore.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Protocol.eof_received">
<code class="descclassname">Protocol.</code><code class="descname">eof_received</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Protocol.eof_received" title="정의 주소">¶</a></dt>
<dd><p>Called when the other end signals it won't send any more data
(for example by calling <a class="reference internal" href="#asyncio.WriteTransport.write_eof" title="asyncio.WriteTransport.write_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.write_eof()</span></code></a>, if the other end also uses
asyncio).</p>
<p>This method may return a false value (including <code class="docutils literal notranslate"><span class="pre">None</span></code>), in which case
the transport will close itself.  Conversely, if this method returns a
true value, the protocol used determines whether to close the transport.
Since the default implementation returns <code class="docutils literal notranslate"><span class="pre">None</span></code>, it implicitly closes the
connection.</p>
<p>Some transports, including SSL, don't support half-closed connections,
in which case returning true from this method will result in the connection
being closed.</p>
</dd></dl>

<p>State machine:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>start -&gt; connection_made
    [-&gt; data_received]*
    [-&gt; eof_received]?
-&gt; connection_lost -&gt; end
</pre></div>
</div>
</div>
<div class="section" id="buffered-streaming-protocols">
<h3>Buffered Streaming Protocols<a class="headerlink" href="#buffered-streaming-protocols" title="제목 주소">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><strong>Important:</strong> this has been added to asyncio in Python 3.7
<em>on a provisional basis</em>!  This is as an experimental API that
might be changed or removed completely in Python 3.8.</p>
</div>
<p>Buffered Protocols can be used with any event loop method
that supports <a class="reference internal" href="#streaming-protocols">Streaming Protocols</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">BufferedProtocol</span></code> implementations allow explicit manual allocation
and control of the receive buffer.  Event loops can then use the buffer
provided by the protocol to avoid unnecessary data copies.  This
can result in noticeable performance improvement for protocols that
receive big amounts of data.  Sophisticated protocol implementations
can significantly reduce the number of buffer allocations.</p>
<p>The following callbacks are called on <a class="reference internal" href="#asyncio.BufferedProtocol" title="asyncio.BufferedProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedProtocol</span></code></a>
instances:</p>
<dl class="method">
<dt id="asyncio.BufferedProtocol.get_buffer">
<code class="descclassname">BufferedProtocol.</code><code class="descname">get_buffer</code><span class="sig-paren">(</span><em>sizehint</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BufferedProtocol.get_buffer" title="정의 주소">¶</a></dt>
<dd><p>Called to allocate a new receive buffer.</p>
<p><em>sizehint</em> is the recommended minimum size for the returned
buffer.  It is acceptable to return smaller or larger buffers
than what <em>sizehint</em> suggests.  When set to -1, the buffer size
can be arbitrary. It is an error to return a buffer with a zero size.</p>
<p><code class="docutils literal notranslate"><span class="pre">get_buffer()</span></code> must return an object implementing the
<a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">buffer protocol</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BufferedProtocol.buffer_updated">
<code class="descclassname">BufferedProtocol.</code><code class="descname">buffer_updated</code><span class="sig-paren">(</span><em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BufferedProtocol.buffer_updated" title="정의 주소">¶</a></dt>
<dd><p>Called when the buffer was updated with the received data.</p>
<p><em>nbytes</em> is the total number of bytes that were written to the buffer.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BufferedProtocol.eof_received">
<code class="descclassname">BufferedProtocol.</code><code class="descname">eof_received</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BufferedProtocol.eof_received" title="정의 주소">¶</a></dt>
<dd><p>See the documentation of the <a class="reference internal" href="#asyncio.Protocol.eof_received" title="asyncio.Protocol.eof_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.eof_received()</span></code></a> method.</p>
</dd></dl>

<p><a class="reference internal" href="#asyncio.BufferedProtocol.get_buffer" title="asyncio.BufferedProtocol.get_buffer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_buffer()</span></code></a> can be called an arbitrary number
of times during a connection.  However, <a class="reference internal" href="#asyncio.Protocol.eof_received" title="asyncio.Protocol.eof_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.eof_received()</span></code></a> is called at most once
and, if called, <a class="reference internal" href="#asyncio.BufferedProtocol.get_buffer" title="asyncio.BufferedProtocol.get_buffer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_buffer()</span></code></a> and
<a class="reference internal" href="#asyncio.BufferedProtocol.buffer_updated" title="asyncio.BufferedProtocol.buffer_updated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">buffer_updated()</span></code></a> won't be called after it.</p>
<p>State machine:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>start -&gt; connection_made
    [-&gt; get_buffer
        [-&gt; buffer_updated]?
    ]*
    [-&gt; eof_received]?
-&gt; connection_lost -&gt; end
</pre></div>
</div>
</div>
<div class="section" id="datagram-protocols">
<h3>Datagram Protocols<a class="headerlink" href="#datagram-protocols" title="제목 주소">¶</a></h3>
<p>Datagram Protocol instances should be constructed by protocol
factories passed to the <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_datagram_endpoint" title="asyncio.loop.create_datagram_endpoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_datagram_endpoint()</span></code></a> method.</p>
<dl class="method">
<dt id="asyncio.DatagramProtocol.datagram_received">
<code class="descclassname">DatagramProtocol.</code><code class="descname">datagram_received</code><span class="sig-paren">(</span><em>data</em>, <em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.DatagramProtocol.datagram_received" title="정의 주소">¶</a></dt>
<dd><p>Called when a datagram is received.  <em>data</em> is a bytes object containing
the incoming data.  <em>addr</em> is the address of the peer sending the data;
the exact format depends on the transport.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.DatagramProtocol.error_received">
<code class="descclassname">DatagramProtocol.</code><code class="descname">error_received</code><span class="sig-paren">(</span><em>exc</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.DatagramProtocol.error_received" title="정의 주소">¶</a></dt>
<dd><p>Called when a previous send or receive operation raises an
<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a>.  <em>exc</em> is the <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> instance.</p>
<p>This method is called in rare conditions, when the transport (e.g. UDP)
detects that a datagram could not be delivered to its recipient.
In many conditions though, undeliverable datagrams will be silently
dropped.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">주석</p>
<p>On BSD systems (macOS, FreeBSD, etc.) flow control is not supported
for datagram protocols, because there is no reliable way to detect send
failures caused by writing too many packets.</p>
<p class="last">The socket always appears 'ready' and excess packets are dropped. An
<a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> with <code class="docutils literal notranslate"><span class="pre">errno</span></code> set to <a class="reference internal" href="errno.html#errno.ENOBUFS" title="errno.ENOBUFS"><code class="xref py py-const docutils literal notranslate"><span class="pre">errno.ENOBUFS</span></code></a> may
or may not be raised; if it is raised, it will be reported to
<a class="reference internal" href="#asyncio.DatagramProtocol.error_received" title="asyncio.DatagramProtocol.error_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DatagramProtocol.error_received()</span></code></a> but otherwise ignored.</p>
</div>
</div>
<div class="section" id="subprocess-protocols">
<span id="asyncio-subprocess-protocols"></span><h3>Subprocess Protocols<a class="headerlink" href="#subprocess-protocols" title="제목 주소">¶</a></h3>
<p>Datagram Protocol instances should be constructed by protocol
factories passed to the <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a> and
<a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_shell" title="asyncio.loop.subprocess_shell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_shell()</span></code></a> methods.</p>
<dl class="method">
<dt id="asyncio.SubprocessProtocol.pipe_data_received">
<code class="descclassname">SubprocessProtocol.</code><code class="descname">pipe_data_received</code><span class="sig-paren">(</span><em>fd</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessProtocol.pipe_data_received" title="정의 주소">¶</a></dt>
<dd><p>Called when the child process writes data into its stdout or stderr
pipe.</p>
<p><em>fd</em> is the integer file descriptor of the pipe.</p>
<p><em>data</em> is a non-empty bytes object containing the received data.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessProtocol.pipe_connection_lost">
<code class="descclassname">SubprocessProtocol.</code><code class="descname">pipe_connection_lost</code><span class="sig-paren">(</span><em>fd</em>, <em>exc</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessProtocol.pipe_connection_lost" title="정의 주소">¶</a></dt>
<dd><p>Called when one of the pipes communicating with the child process
is closed.</p>
<p><em>fd</em> is the integer file descriptor that was closed.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessProtocol.process_exited">
<code class="descclassname">SubprocessProtocol.</code><code class="descname">process_exited</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessProtocol.process_exited" title="정의 주소">¶</a></dt>
<dd><p>Called when the child process has exited.</p>
</dd></dl>

</div>
</div>
<div class="section" id="examples">
<h2>예제<a class="headerlink" href="#examples" title="제목 주소">¶</a></h2>
<div class="section" id="tcp-echo-server">
<span id="asyncio-example-tcp-echo-server-protocol"></span><h3>TCP Echo Server<a class="headerlink" href="#tcp-echo-server" title="제목 주소">¶</a></h3>
<p>Create a TCP echo server using the <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> method, send back
received data, and close the connection:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>


<span class="k">class</span> <span class="nc">EchoServerProtocol</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="n">peername</span> <span class="o">=</span> <span class="n">transport</span><span class="o">.</span><span class="n">get_extra_info</span><span class="p">(</span><span class="s1">&#39;peername&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Connection from </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">peername</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>

    <span class="k">def</span> <span class="nf">data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data received: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">message</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Send: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">message</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Close the client socket&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Get a reference to the event loop as we plan to use</span>
    <span class="c1"># low-level APIs.</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="n">server</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">EchoServerProtocol</span><span class="p">(),</span>
        <span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8888</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">with</span> <span class="n">server</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>


<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last">The <a class="reference internal" href="asyncio-stream.html#asyncio-tcp-echo-server-streams"><span class="std std-ref">TCP echo server using streams</span></a>
example uses the high-level <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.start_server()</span></code></a> function.</p>
</div>
</div>
<div class="section" id="tcp-echo-client">
<span id="asyncio-example-tcp-echo-client-protocol"></span><h3>TCP Echo Client<a class="headerlink" href="#tcp-echo-client" title="제목 주소">¶</a></h3>
<p>A TCP echo client using the <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> method, sends
data, and waits until the connection is closed:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>


<span class="k">class</span> <span class="nc">EchoClientProtocol</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">on_con_lost</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span> <span class="o">=</span> <span class="n">loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_con_lost</span> <span class="o">=</span> <span class="n">on_con_lost</span>

    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data sent: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data received: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">connection_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The server closed the connection&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_con_lost</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Get a reference to the event loop as we plan to use</span>
    <span class="c1"># low-level APIs.</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="n">on_con_lost</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;Hello World!&#39;</span>

    <span class="n">transport</span><span class="p">,</span> <span class="n">protocol</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_connection</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">EchoClientProtocol</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">on_con_lost</span><span class="p">,</span> <span class="n">loop</span><span class="p">),</span>
        <span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8888</span><span class="p">)</span>

    <span class="c1"># Wait until the protocol signals that the connection</span>
    <span class="c1"># is lost and close the transport.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">on_con_lost</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last">The <a class="reference internal" href="asyncio-stream.html#asyncio-tcp-echo-client-streams"><span class="std std-ref">TCP echo client using streams</span></a>
example uses the high-level <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a> function.</p>
</div>
</div>
<div class="section" id="udp-echo-server">
<span id="asyncio-udp-echo-server-protocol"></span><h3>UDP Echo Server<a class="headerlink" href="#udp-echo-server" title="제목 주소">¶</a></h3>
<p>A UDP echo server, using the <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_datagram_endpoint" title="asyncio.loop.create_datagram_endpoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_datagram_endpoint()</span></code></a>
method, sends back received data:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>


<span class="k">class</span> <span class="nc">EchoServerProtocol</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>

    <span class="k">def</span> <span class="nf">datagram_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Received </span><span class="si">%r</span><span class="s1"> from </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Send </span><span class="si">%r</span><span class="s1"> to </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting UDP server&quot;</span><span class="p">)</span>

    <span class="c1"># Get a reference to the event loop as we plan to use</span>
    <span class="c1"># low-level APIs.</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="c1"># One protocol instance will be created to serve all</span>
    <span class="c1"># client requests.</span>
    <span class="n">transport</span><span class="p">,</span> <span class="n">protocol</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_datagram_endpoint</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">EchoServerProtocol</span><span class="p">(),</span>
        <span class="n">local_addr</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">9999</span><span class="p">))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>  <span class="c1"># Serve for 1 hour.</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="udp-echo-client">
<span id="asyncio-udp-echo-client-protocol"></span><h3>UDP Echo Client<a class="headerlink" href="#udp-echo-client" title="제목 주소">¶</a></h3>
<p>A UDP echo client, using the <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_datagram_endpoint" title="asyncio.loop.create_datagram_endpoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_datagram_endpoint()</span></code></a>
method, sends data and closes the transport when it receives the answer:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>


<span class="k">class</span> <span class="nc">EchoClientProtocol</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span> <span class="o">=</span> <span class="n">loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_con_lost</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Send:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">datagram_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Received:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Close the socket&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">error_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error received:&#39;</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connection_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Connection closed&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_con_lost</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Get a reference to the event loop as we plan to use</span>
    <span class="c1"># low-level APIs.</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Hello World!&quot;</span>
    <span class="n">transport</span><span class="p">,</span> <span class="n">protocol</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_datagram_endpoint</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">EchoClientProtocol</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">loop</span><span class="p">),</span>
        <span class="n">remote_addr</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">9999</span><span class="p">))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">protocol</span><span class="o">.</span><span class="n">on_con_lost</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="connecting-existing-sockets">
<span id="asyncio-example-create-connection"></span><h3>Connecting Existing Sockets<a class="headerlink" href="#connecting-existing-sockets" title="제목 주소">¶</a></h3>
<p>Wait until a socket receives data using the
<a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> method with a protocol:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">socket</span>


<span class="k">class</span> <span class="nc">MyProtocol</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_con_lost</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>

    <span class="k">def</span> <span class="nf">data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Received:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>

        <span class="c1"># We are done: close the transport;</span>
        <span class="c1"># connection_lost() will be called automatically.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">connection_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
        <span class="c1"># The socket has been closed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_con_lost</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Get a reference to the event loop as we plan to use</span>
    <span class="c1"># low-level APIs.</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="c1"># Create a pair of connected sockets</span>
    <span class="n">rsock</span><span class="p">,</span> <span class="n">wsock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socketpair</span><span class="p">()</span>

    <span class="c1"># Register the socket to wait for data.</span>
    <span class="n">transport</span><span class="p">,</span> <span class="n">protocol</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_connection</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">MyProtocol</span><span class="p">(</span><span class="n">loop</span><span class="p">),</span> <span class="n">sock</span><span class="o">=</span><span class="n">rsock</span><span class="p">)</span>

    <span class="c1"># Simulate the reception of data from the network.</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">wsock</span><span class="o">.</span><span class="n">send</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">protocol</span><span class="o">.</span><span class="n">on_con_lost</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">wsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p>The <a class="reference internal" href="asyncio-eventloop.html#asyncio-example-watch-fd"><span class="std std-ref">watch a file descriptor for read events</span></a> example uses the low-level
<a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.add_reader" title="asyncio.loop.add_reader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_reader()</span></code></a> method to register an FD.</p>
<p class="last">The <a class="reference internal" href="asyncio-stream.html#asyncio-example-create-connection-streams"><span class="std std-ref">register an open socket to wait for data using streams</span></a> example uses high-level streams
created by the <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_connection()</span></code></a> function in a coroutine.</p>
</div>
</div>
<div class="section" id="loop-subprocess-exec-and-subprocessprotocol">
<span id="asyncio-example-subprocess-proto"></span><h3>loop.subprocess_exec() and SubprocessProtocol<a class="headerlink" href="#loop-subprocess-exec-and-subprocessprotocol" title="제목 주소">¶</a></h3>
<p>An example of a subprocess protocol used to get the output of a
subprocess and to wait for the subprocess exit.</p>
<p>The subprocess is created by th <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a> method:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">class</span> <span class="nc">DateProtocol</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">SubprocessProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exit_future</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exit_future</span> <span class="o">=</span> <span class="n">exit_future</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">pipe_data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_exited</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exit_future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">get_date</span><span class="p">():</span>
    <span class="c1"># Get a reference to the event loop as we plan to use</span>
    <span class="c1"># low-level APIs.</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="n">code</span> <span class="o">=</span> <span class="s1">&#39;import datetime; print(datetime.datetime.now())&#39;</span>
    <span class="n">exit_future</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">(</span><span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">)</span>

    <span class="c1"># Create the subprocess controlled by DateProtocol;</span>
    <span class="c1"># redirect the standard output into a pipe.</span>
    <span class="n">transport</span><span class="p">,</span> <span class="n">protocol</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">subprocess_exec</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">DateProtocol</span><span class="p">(</span><span class="n">exit_future</span><span class="p">),</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">executable</span><span class="p">,</span> <span class="s1">&#39;-c&#39;</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span>
        <span class="n">stdin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Wait for the subprocess exit using the process_exited()</span>
    <span class="c1"># method of the protocol.</span>
    <span class="k">await</span> <span class="n">exit_future</span>

    <span class="c1"># Close the stdout pipe.</span>
    <span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># Read the output which was collected by the</span>
    <span class="c1"># pipe_data_received() method of the protocol.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">protocol</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop_policy</span><span class="p">(</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">WindowsProactorEventLoopPolicy</span><span class="p">())</span>

<span class="n">date</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">get_date</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Current date: </span><span class="si">{date}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>See also the <a class="reference internal" href="asyncio-subprocess.html#asyncio-example-create-subprocess-exec"><span class="std std-ref">same example</span></a>
written using high-level APIs.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">트랜스포트와 프로토콜</a><ul>
<li><a class="reference internal" href="#transports">트랜스포트</a><ul>
<li><a class="reference internal" href="#transports-hierarchy">트랜스포트 계층 구조</a></li>
<li><a class="reference internal" href="#base-transport">베이스 트랜스포트</a></li>
<li><a class="reference internal" href="#read-only-transports">읽기 전용 트랜스포트</a></li>
<li><a class="reference internal" href="#write-only-transports">쓰기 전용 트랜스포트</a></li>
<li><a class="reference internal" href="#datagram-transports">데이터 그램 트랜스포트</a></li>
<li><a class="reference internal" href="#subprocess-transports">서브 프로세스 트랜스포트</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">프로토콜</a><ul>
<li><a class="reference internal" href="#base-protocols">Base Protocols</a></li>
<li><a class="reference internal" href="#base-protocol">Base Protocol</a></li>
<li><a class="reference internal" href="#streaming-protocols">Streaming Protocols</a></li>
<li><a class="reference internal" href="#buffered-streaming-protocols">Buffered Streaming Protocols</a></li>
<li><a class="reference internal" href="#datagram-protocols">Datagram Protocols</a></li>
<li><a class="reference internal" href="#subprocess-protocols">Subprocess Protocols</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">예제</a><ul>
<li><a class="reference internal" href="#tcp-echo-server">TCP Echo Server</a></li>
<li><a class="reference internal" href="#tcp-echo-client">TCP Echo Client</a></li>
<li><a class="reference internal" href="#udp-echo-server">UDP Echo Server</a></li>
<li><a class="reference internal" href="#udp-echo-client">UDP Echo Client</a></li>
<li><a class="reference internal" href="#connecting-existing-sockets">Connecting Existing Sockets</a></li>
<li><a class="reference internal" href="#loop-subprocess-exec-and-subprocessprotocol">loop.subprocess_exec() and SubprocessProtocol</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="asyncio-future.html"
                        title="이전 장">퓨처</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="asyncio-policy.html"
                        title="다음 장">Policies</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-policy.html" title="Policies"
             >다음</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="퓨처"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" ><code class="docutils literal notranslate"><span class="pre">asyncio</span></code> --- 비동기 I/O</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2018, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1 를 사용해서 만들었습니다.
    </div>

  </body>
</html>