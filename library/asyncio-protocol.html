
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>트랜스포트와 프로토콜 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="정책" href="asyncio-policy.html" />
    <link rel="prev" title="퓨처" href="asyncio-future.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/asyncio-protocol.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-policy.html" title="정책"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="퓨처"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U"><code class="docutils literal notranslate"><span class="pre">asyncio</span></code> --- 비동기 I/O</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="transports-and-protocols">
<span id="asyncio-transports-protocols"></span><h1>트랜스포트와 프로토콜<a class="headerlink" href="#transports-and-protocols" title="제목 주소">¶</a></h1>
<p class="rubric">머리말</p>
<p>트랜스포트와 프로토콜은 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>와 같은 <strong>저수준</strong> 이벤트 루프 API에서 사용됩니다. 그들은 콜백 기반 프로그래밍 스타일을 사용하고 네트워크 나 IPC 프로토콜(예를 들어 HTTP)의 고성능 구현을 가능하게 합니다.</p>
<p>본질에서 트랜스포트와 프로토콜은 라이브러리와 프레임워크에서만 사용되어야 하며 고수준 asyncio 응용 프로그램에서는 사용되지 않아야 합니다.</p>
<p>이 문서 페이지는 <a class="reference internal" href="#transports">트랜스포트</a>와 <a class="reference internal" href="#protocols">프로토콜</a>을 모두 다룹니다.</p>
<p class="rubric">소개</p>
<p>최상위 수준에서, 트랜스포트는 <em>어떻게(how)</em> 바이트를 전송할지를 다루지만, 프로토콜은 <em>어떤(which)</em> 바이트를 전송할지를 결정합니다 (그리고 어느 정도는 언제(when)도).</p>
<p>같은 것을 다른 식으로 말하면: 트랜스포트는 소켓(또는 유사한 I/O 엔드포인트)의 추상화지만, 프로토콜은 트랜스포트의 관점에서 응용 프로그램의 추상화입니다.</p>
<p>또 다른 시각은 트랜스포트와 프로토콜 인터페이스가 함께 네트워크 I/O와 프로세스 간 I/O를 사용하기 위한 추상 인터페이스를 정의한다는 것입니다.</p>
<p>트랜스포트 객체와 프로토콜 객체 간에는 항상 1:1 관계가 있습니다: 프로토콜은 트랜스포트 메서드를 호출하여 데이터를 보내지만, 트랜스포트는 프로토콜 메서드를 호출하여 받은 데이터를 전달합니다.</p>
<p>대부분의 연결 지향 이벤트 루프 메서드(가령 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>)는 <em>Transport</em> 객체로 표현되는 받아들인 연결을 위한 <em>Protocol</em> 객체를 만드는 데 사용되는 <em>protocol_factory</em> 인자를 받아들입니다. 이러한 메서드는 대개 <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>의 튜플을 반환합니다.</p>
<p class="rubric">목차</p>
<p>이 설명서 페이지는 다음 절로 구성됩니다:</p>
<ul class="simple">
<li><a class="reference internal" href="#transports">트랜스포트</a> 절은 asyncio <a class="reference internal" href="#asyncio.BaseTransport" title="asyncio.BaseTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseTransport</span></code></a>, <a class="reference internal" href="#asyncio.ReadTransport" title="asyncio.ReadTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReadTransport</span></code></a>, <a class="reference internal" href="#asyncio.WriteTransport" title="asyncio.WriteTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">WriteTransport</span></code></a>, <a class="reference internal" href="#asyncio.Transport" title="asyncio.Transport"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transport</span></code></a>, <a class="reference internal" href="#asyncio.DatagramTransport" title="asyncio.DatagramTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">DatagramTransport</span></code></a> 및 <a class="reference internal" href="#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessTransport</span></code></a> 클래스를 설명합니다.</li>
<li><a class="reference internal" href="#protocols">프로토콜</a> 절은 asyncio <a class="reference internal" href="#asyncio.BaseProtocol" title="asyncio.BaseProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseProtocol</span></code></a>, <a class="reference internal" href="#asyncio.Protocol" title="asyncio.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>, <a class="reference internal" href="#asyncio.BufferedProtocol" title="asyncio.BufferedProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedProtocol</span></code></a>, <a class="reference internal" href="#asyncio.DatagramProtocol" title="asyncio.DatagramProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">DatagramProtocol</span></code></a> 및 <a class="reference internal" href="#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessProtocol</span></code></a> 클래스를 설명합니다.</li>
<li><a class="reference internal" href="#examples">예제</a> 절은 트랜스포트, 프로토콜 및 저수준 이벤트 루프 API를 사용하는 방법을 보여줍니다.</li>
</ul>
<div class="section" id="transports">
<span id="asyncio-transport"></span><h2>트랜스포트<a class="headerlink" href="#transports" title="제목 주소">¶</a></h2>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/asyncio/transports.py">Lib/asyncio/transports.py</a></p>
<hr class="docutils" />
<p>트랜스포트는 다양한 종류의 통신 채널을 추상화하기 위해 <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>에서 제공하는 클래스입니다.</p>
<p>트랜스포트 객체는 항상 <a class="reference internal" href="asyncio-eventloop.html#asyncio-event-loop"><span class="std std-ref">asyncio 이벤트 루프</span></a>에 의해 인스턴스로 만들어집니다.</p>
<p>asyncio는 TCP, UDP, SSL 및 서브 프로세스 파이프를 위한 트랜스포트를 구현합니다. 트랜스포트에서 사용할 수 있는 메서드는 트랜스포트의 종류에 따라 다릅니다.</p>
<p>트랜스포트 클래스는 <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">스레드 안전하지 않습니다</span></a>.</p>
<div class="section" id="transports-hierarchy">
<h3>트랜스포트 계층 구조<a class="headerlink" href="#transports-hierarchy" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="asyncio.BaseTransport">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">BaseTransport</code><a class="headerlink" href="#asyncio.BaseTransport" title="정의 주소">¶</a></dt>
<dd><p>모든 트랜스포트의 베이스 클래스. 모든 asyncio 트랜스포트가 공유하는 메서드를 포함합니다.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.WriteTransport">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">WriteTransport</code><span class="sig-paren">(</span><em>BaseTransport</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport" title="정의 주소">¶</a></dt>
<dd><p>쓰기 전용 연결을 위한 베이스 트랜스포트</p>
<p><em>WriteTransport</em> 클래스의 인스턴스는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_write_pipe()</span></code></a> 이벤트 루프 메서드에서 반환되며 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a>와 같은 서브 프로세스 관련 메서드에서도 사용됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.ReadTransport">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">ReadTransport</code><span class="sig-paren">(</span><em>BaseTransport</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.ReadTransport" title="정의 주소">¶</a></dt>
<dd><p>읽기 전용 연결을 위한 베이스 트랜스포트</p>
<p><em>ReadTransport</em> 클래스의 인스턴스는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.connect_read_pipe" title="asyncio.loop.connect_read_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_read_pipe()</span></code></a> 이벤트 루프 메서드에서 반환되며 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a>와 같은 서브 프로세스 관련 메서드에서도 사용됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.Transport">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">Transport</code><span class="sig-paren">(</span><em>WriteTransport</em>, <em>ReadTransport</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Transport" title="정의 주소">¶</a></dt>
<dd><p>TCP 연결과 같은 양방향 트랜스포트를 나타내는 인터페이스.</p>
<p>사용자는 트랜스포트를 직접 인스턴스로 만들지 않습니다; 유틸리티 함수를 호출하고, 프로토콜 팩토리와 트랜스포트와 프로토콜을 만드는 데 필요한 기타 정보를 전달합니다.</p>
<p><em>Transport</em> 클래스의 인스턴스는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_unix_connection" title="asyncio.loop.create_unix_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_connection()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.sendfile" title="asyncio.loop.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.sendfile()</span></code></a> 등과 같은 이벤트 루프 메서드에서 반환되거나 사용됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.DatagramTransport">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">DatagramTransport</code><span class="sig-paren">(</span><em>BaseTransport</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.DatagramTransport" title="정의 주소">¶</a></dt>
<dd><p>데이터 그램 (UDP) 연결을 위한 트랜스포트.</p>
<p><em>DatagramTransport</em> 클래스의 인스턴스는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_datagram_endpoint" title="asyncio.loop.create_datagram_endpoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_datagram_endpoint()</span></code></a> 이벤트 루프 메서드에서 반환됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.SubprocessTransport">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">SubprocessTransport</code><span class="sig-paren">(</span><em>BaseTransport</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport" title="정의 주소">¶</a></dt>
<dd><p>부모와 그 자식 OS 프로세스 간의 연결을 나타내는 추상화.</p>
<p><em>SubprocessTransport</em> 클래스의 인스턴스는 이벤트 루프 메서드 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_shell" title="asyncio.loop.subprocess_shell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_shell()</span></code></a>과 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a>에서 반환됩니다.</p>
</dd></dl>

</div>
<div class="section" id="base-transport">
<h3>베이스 트랜스포트<a class="headerlink" href="#base-transport" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.BaseTransport.close">
<code class="descclassname">BaseTransport.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseTransport.close" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트를 닫습니다.</p>
<p>트랜스포트에 송신 데이터용 버퍼가 있으면, 버퍼 된 데이터는 비동기적으로 플러시 됩니다. 더는 데이터가 수신되지 않습니다. 버퍼 된 모든 데이터가 플러시 된 후, 프로토콜의 <a class="reference internal" href="#asyncio.BaseProtocol.connection_lost" title="asyncio.BaseProtocol.connection_lost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.connection_lost()</span></code></a> 메서드가 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 인자로 사용하여 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseTransport.is_closing">
<code class="descclassname">BaseTransport.</code><code class="descname">is_closing</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseTransport.is_closing" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트가 닫히는 중이거나 닫혔으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseTransport.get_extra_info">
<code class="descclassname">BaseTransport.</code><code class="descname">get_extra_info</code><span class="sig-paren">(</span><em>name</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseTransport.get_extra_info" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트나 그것이 사용하는 하부 자원에 대한 정보를 반환합니다.</p>
<p><em>name</em>은 얻고자 하는 트랜스포트 특정 정보의 조각을 나타내는 문자열입니다.</p>
<p><em>default</em>는 정보가 없거나 트랜스포트가 제삼자 이벤트 루프 구현이나 현재 플랫폼에서 조회를 지원하지 않을 때 반환 할 값입니다.</p>
<p>예를 들어, 다음 코드는 트랜스포트의 하부 소켓 객체를 가져오려고 시도합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sock</span> <span class="o">=</span> <span class="n">transport</span><span class="o">.</span><span class="n">get_extra_info</span><span class="p">(</span><span class="s1">&#39;socket&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">getsockopt</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
</pre></div>
</div>
<p>일부 트랜스포트에서 조회할 수 있는 정보의 범주:</p>
<ul class="simple">
<li>소켓:<ul>
<li><code class="docutils literal notranslate"><span class="pre">'peername'</span></code>: 소켓이 연결된 원격 주소, <a class="reference internal" href="socket.html#socket.socket.getpeername" title="socket.socket.getpeername"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.getpeername()</span></code></a>의 결과 (에러 시 <code class="docutils literal notranslate"><span class="pre">None</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">'socket'</span></code>: <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> 인스턴스</li>
<li><code class="docutils literal notranslate"><span class="pre">'sockname'</span></code>: 소켓 자체 주소, <a class="reference internal" href="socket.html#socket.socket.getsockname" title="socket.socket.getsockname"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.getsockname()</span></code></a>의 결과</li>
</ul>
</li>
<li>SSL 소켓:<ul>
<li><code class="docutils literal notranslate"><span class="pre">'compression'</span></code>: 문자열로 표현된 사용된 압축 알고리즘, 또는 연결이 압축되지 않았으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>; <a class="reference internal" href="ssl.html#ssl.SSLSocket.compression" title="ssl.SSLSocket.compression"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLSocket.compression()</span></code></a>의 결과</li>
<li><code class="docutils literal notranslate"><span class="pre">'cipher'</span></code>: 사용되는 암호 체계의 이름, 이의 사용을 정의하는 SSL 프로토콜의 버전 및 사용되는 비밀 비트의 수를 포함하는 3-튜플; <a class="reference internal" href="ssl.html#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLSocket.cipher()</span></code></a>의 결과</li>
<li><code class="docutils literal notranslate"><span class="pre">'peercert'</span></code>: 피어 인증서; <a class="reference internal" href="ssl.html#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLSocket.getpeercert()</span></code></a>의 결과</li>
<li><code class="docutils literal notranslate"><span class="pre">'sslcontext'</span></code>: <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 인스턴스</li>
<li><code class="docutils literal notranslate"><span class="pre">'ssl_object'</span></code>: <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a> 나 <a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> 인스턴스</li>
</ul>
</li>
<li>파이프:<ul>
<li><code class="docutils literal notranslate"><span class="pre">'pipe'</span></code>: 파이프 객체</li>
</ul>
</li>
<li>서브 프로세스:<ul>
<li><code class="docutils literal notranslate"><span class="pre">'subprocess'</span></code>: <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 인스턴스</li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseTransport.set_protocol">
<code class="descclassname">BaseTransport.</code><code class="descname">set_protocol</code><span class="sig-paren">(</span><em>protocol</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseTransport.set_protocol" title="정의 주소">¶</a></dt>
<dd><p>새 프로토콜을 설정합니다.</p>
<p>프로토콜의 교환은 두 프로토콜이 교환을 지원한다고 문서화 되었을 때만 수행되어야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseTransport.get_protocol">
<code class="descclassname">BaseTransport.</code><code class="descname">get_protocol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseTransport.get_protocol" title="정의 주소">¶</a></dt>
<dd><p>현재 프로토콜을 반환합니다.</p>
</dd></dl>

</div>
<div class="section" id="read-only-transports">
<h3>읽기 전용 트랜스포트<a class="headerlink" href="#read-only-transports" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.ReadTransport.is_reading">
<code class="descclassname">ReadTransport.</code><code class="descname">is_reading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.ReadTransport.is_reading" title="정의 주소">¶</a></dt>
<dd><p>트랜스 포트가 새로운 데이터를 받고 있으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.ReadTransport.pause_reading">
<code class="descclassname">ReadTransport.</code><code class="descname">pause_reading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.ReadTransport.pause_reading" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트의 수신 끝을 일시 중지합니다. <a class="reference internal" href="#asyncio.ReadTransport.resume_reading" title="asyncio.ReadTransport.resume_reading"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resume_reading()</span></code></a>이 호출 될 때까지 프로토콜의 <a class="reference internal" href="#asyncio.Protocol.data_received" title="asyncio.Protocol.data_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.data_received()</span></code></a> 메서드에 데이터가 전달되지 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>이 메서드는 멱등적(idempotent)입니다. 즉, 트랜스포트가 이미 일시 중지되거나 닫혔을 때도 호출할 수 있습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.ReadTransport.resume_reading">
<code class="descclassname">ReadTransport.</code><code class="descname">resume_reading</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.ReadTransport.resume_reading" title="정의 주소">¶</a></dt>
<dd><p>수신 끝을 재개합니다. 읽을 수 있는 데이터가 있다면 프로토콜의 <a class="reference internal" href="#asyncio.Protocol.data_received" title="asyncio.Protocol.data_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.data_received()</span></code></a> 메서드가 다시 한번 호출됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>이 메서드는 멱등적(idempotent)입니다. 즉, 트랜스포트가 이미 읽고 있을 때도 호출할 수 있습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="write-only-transports">
<h3>쓰기 전용 트랜스포트<a class="headerlink" href="#write-only-transports" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.WriteTransport.abort">
<code class="descclassname">WriteTransport.</code><code class="descname">abort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.abort" title="정의 주소">¶</a></dt>
<dd><p>계류 중인 작업이 완료될 때까지 기다리지 않고, 즉시 트랜스포트를 닫습니다. 버퍼 된 데이터는 손실됩니다. 더는 데이터가 수신되지 않습니다. 프로토콜의 <a class="reference internal" href="#asyncio.BaseProtocol.connection_lost" title="asyncio.BaseProtocol.connection_lost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.connection_lost()</span></code></a> 메서드는 결국 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 인자로 사용하여 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.WriteTransport.can_write_eof">
<code class="descclassname">WriteTransport.</code><code class="descname">can_write_eof</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.can_write_eof" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트가 <a class="reference internal" href="#asyncio.WriteTransport.write_eof" title="asyncio.WriteTransport.write_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write_eof()</span></code></a>를 지원하면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.WriteTransport.get_write_buffer_size">
<code class="descclassname">WriteTransport.</code><code class="descname">get_write_buffer_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.get_write_buffer_size" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트가 사용하는 출력 버퍼의 현재 크기를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.WriteTransport.get_write_buffer_limits">
<code class="descclassname">WriteTransport.</code><code class="descname">get_write_buffer_limits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.get_write_buffer_limits" title="정의 주소">¶</a></dt>
<dd><p>쓰기 흐름 제어를 위한 <em>high</em> 와 <em>low</em> 수위(watermark)를 가져옵니다. 튜플 <code class="docutils literal notranslate"><span class="pre">(low,</span> <span class="pre">high)</span></code>를 반환합니다. 여기서 <em>low</em> 와 <em>high</em>는 양의 바이트 수입니다.</p>
<p>제한을 설정하려면 <a class="reference internal" href="#asyncio.WriteTransport.set_write_buffer_limits" title="asyncio.WriteTransport.set_write_buffer_limits"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_write_buffer_limits()</span></code></a>를 사용하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.WriteTransport.set_write_buffer_limits">
<code class="descclassname">WriteTransport.</code><code class="descname">set_write_buffer_limits</code><span class="sig-paren">(</span><em>high=None</em>, <em>low=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.set_write_buffer_limits" title="정의 주소">¶</a></dt>
<dd><p>쓰기 흐름 제어를 위한 <em>high</em> 와 <em>low</em> 수위(watermark)를 설정합니다.</p>
<p>이 두 값(바이트 수로 측정)은 프로토콜의 <a class="reference internal" href="#asyncio.BaseProtocol.pause_writing" title="asyncio.BaseProtocol.pause_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.pause_writing()</span></code></a> 과 <a class="reference internal" href="#asyncio.BaseProtocol.resume_writing" title="asyncio.BaseProtocol.resume_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.resume_writing()</span></code></a> 메서드가 언제 호출될지를 제어합니다. 지정하면, low 수위는 high 수위보다 작거나 같아야 합니다. <em>high</em> 와 <em>low</em>는 음수가 될 수 없습니다.</p>
<p>버퍼 크기가 <em>high</em> 값보다 크거나 같아질 때 <a class="reference internal" href="#asyncio.BaseProtocol.pause_writing" title="asyncio.BaseProtocol.pause_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pause_writing()</span></code></a>가 호출됩니다. 쓰기가 일시 중지되면, 버퍼 크기가 <em>low</em> 값보다 작거나 같아질 때 <a class="reference internal" href="#asyncio.BaseProtocol.resume_writing" title="asyncio.BaseProtocol.resume_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resume_writing()</span></code></a>이 호출됩니다.</p>
<p>기본값은 구현에 따라 다릅니다. high 수위만 주어지면, low 수위는 high 수위보다 작거나 같은 구현 특정 기본값이 사용됩니다. <em>high</em>를 0으로 설정하면, <em>low</em>도 0으로 설정되고, 버퍼가 비어있지 않게 될 때마다 <a class="reference internal" href="#asyncio.BaseProtocol.pause_writing" title="asyncio.BaseProtocol.pause_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pause_writing()</span></code></a>가 호출되도록 합니다. <em>low</em>를 0으로 설정하면 버퍼가 빌 때만 <a class="reference internal" href="#asyncio.BaseProtocol.resume_writing" title="asyncio.BaseProtocol.resume_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resume_writing()</span></code></a>이 호출됩니다. 두 제한 중 하나에 0을 사용하는 것은 I/O와 계산을 동시에 수행할 기회를 줄이기 때문에 일반적으로 최선이 아닙니다.</p>
<p>제한을 가져오려면 <a class="reference internal" href="#asyncio.WriteTransport.get_write_buffer_limits" title="asyncio.WriteTransport.get_write_buffer_limits"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_write_buffer_limits()</span></code></a>를 사용하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.WriteTransport.write">
<code class="descclassname">WriteTransport.</code><code class="descname">write</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.write" title="정의 주소">¶</a></dt>
<dd><p>어떤 <em>data</em> 바이트열을 트랜스포트에 기록합니다.</p>
<p>이 메서드는 블록하지 않습니다; 데이터를 버퍼하고 비동기적으로 전송되도록 배치합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.WriteTransport.writelines">
<code class="descclassname">WriteTransport.</code><code class="descname">writelines</code><span class="sig-paren">(</span><em>list_of_data</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.writelines" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트에 데이터 바이트열 리스트(또는 임의의 이터러블)를 기록합니다. 이것은 이터러블이 산출하는 각 요소에 대해 <a class="reference internal" href="#asyncio.WriteTransport.write" title="asyncio.WriteTransport.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a>를 호출하는 것과 기능 면에서 동등하지만, 더 효율적으로 구현될 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.WriteTransport.write_eof">
<code class="descclassname">WriteTransport.</code><code class="descname">write_eof</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.WriteTransport.write_eof" title="정의 주소">¶</a></dt>
<dd><p>버퍼 된 모든 데이터를 플러시 한 후 트랜스포트의 쓰기 끝을 닫습니다. 데이터가 여전히 수신될 수 있습니다.</p>
<p>이 메서드는 트랜스포트(예를 들어 SSL)가 반만 닫힌 연결을 지원하지 않으면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>를 발생시킬 수 있습니다.</p>
</dd></dl>

</div>
<div class="section" id="datagram-transports">
<h3>데이터 그램 트랜스포트<a class="headerlink" href="#datagram-transports" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.DatagramTransport.sendto">
<code class="descclassname">DatagramTransport.</code><code class="descname">sendto</code><span class="sig-paren">(</span><em>data</em>, <em>addr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.DatagramTransport.sendto" title="정의 주소">¶</a></dt>
<dd><p><em>addr</em>(트랜스포트 종속적인 대상 주소)에 의해 주어진 원격 피어로 <em>data</em> 바이트열을 보냅니다. <em>addr</em>가 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>이면, 트랜스포트를 만들 때 지정된 대상 주소로 data가 전송됩니다.</p>
<p>이 메서드는 블록하지 않습니다; 데이터를 버퍼하고 비동기적으로 전송되도록 배치합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.DatagramTransport.abort">
<code class="descclassname">DatagramTransport.</code><code class="descname">abort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.DatagramTransport.abort" title="정의 주소">¶</a></dt>
<dd><p>계류 중인 작업이 완료될 때까지 기다리지 않고, 즉시 트랜스포트를 닫습니다. 버퍼 된 데이터는 손실됩니다. 더는 데이터가 수신되지 않습니다. 프로토콜의 <a class="reference internal" href="#asyncio.BaseProtocol.connection_lost" title="asyncio.BaseProtocol.connection_lost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.connection_lost()</span></code></a> 메서드는 결국 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 인자로 사용하여 호출됩니다.</p>
</dd></dl>

</div>
<div class="section" id="subprocess-transports">
<span id="asyncio-subprocess-transports"></span><h3>서브 프로세스 트랜스포트<a class="headerlink" href="#subprocess-transports" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="asyncio.SubprocessTransport.get_pid">
<code class="descclassname">SubprocessTransport.</code><code class="descname">get_pid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport.get_pid" title="정의 주소">¶</a></dt>
<dd><p>서브 프로세스 ID를 정수로 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessTransport.get_pipe_transport">
<code class="descclassname">SubprocessTransport.</code><code class="descname">get_pipe_transport</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport.get_pipe_transport" title="정의 주소">¶</a></dt>
<dd><p>정수 파일 기술자 <em>fd</em>에 대응하는 통신 파이프의 트랜스포트를 돌려줍니다:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">0</span></code>: 표준 입력(<em>stdin</em>)의 읽을 수 있는 스트리밍 트랜스포트, 또는 서브 프로세스가 <code class="docutils literal notranslate"><span class="pre">stdin=PIPE</span></code>로 만들어지지 않았으면 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></li>
<li><code class="docutils literal notranslate"><span class="pre">1</span></code>: 표준 출력(<em>stdout</em>)의 쓸 수 있는 스트리밍 트랜스포트, 또는 서브 프로세스가 <code class="docutils literal notranslate"><span class="pre">stdout=PIPE</span></code>로 만들어지지 않았으면 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></li>
<li><code class="docutils literal notranslate"><span class="pre">2</span></code>: 표준 오류(<em>stderr</em>)의 쓸 수 있는 스트리밍 트랜스포트, 또는 서브 프로세스가 <code class="docutils literal notranslate"><span class="pre">stderr=PIPE</span></code>로 만들어지지 않았으면 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></li>
<li>다른 <em>fd</em>: <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></li>
</ul>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessTransport.get_returncode">
<code class="descclassname">SubprocessTransport.</code><code class="descname">get_returncode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport.get_returncode" title="정의 주소">¶</a></dt>
<dd><p>서브 프로세스 반환 값을 정수로, 혹은 반환되지 않았으면 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환합니다. <a class="reference internal" href="subprocess.html#subprocess.Popen.returncode" title="subprocess.Popen.returncode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">subprocess.Popen.returncode</span></code></a> 어트리뷰트와 유사합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessTransport.kill">
<code class="descclassname">SubprocessTransport.</code><code class="descname">kill</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport.kill" title="정의 주소">¶</a></dt>
<dd><p>서브 프로세스를 죽입니다.</p>
<p>POSIX 시스템에서, 이 함수는 SIGKILL을 서브 프로세스로 보냅니다. 윈도우에서, 이 메서드는 <a class="reference internal" href="#asyncio.SubprocessTransport.terminate" title="asyncio.SubprocessTransport.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a>의 별칭입니다.</p>
<p><a class="reference internal" href="subprocess.html#subprocess.Popen.kill" title="subprocess.Popen.kill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess.Popen.kill()</span></code></a>도 참조하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessTransport.send_signal">
<code class="descclassname">SubprocessTransport.</code><code class="descname">send_signal</code><span class="sig-paren">(</span><em>signal</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport.send_signal" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="subprocess.html#subprocess.Popen.send_signal" title="subprocess.Popen.send_signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess.Popen.send_signal()</span></code></a>와 마찬가지로 <em>signal</em> 번호를 서브 프로세스로 보냅니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessTransport.terminate">
<code class="descclassname">SubprocessTransport.</code><code class="descname">terminate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport.terminate" title="정의 주소">¶</a></dt>
<dd><p>서브 프로세스를 중지합니다.</p>
<p>POSIX 시스템에서, 이 메서드는 SIGTERM을 서브 프로세스로 보냅니다. 윈도에서, 서브 프로세스를 중지하기 위해 윈도우 API 함수 TerminateProcess() 가 호출됩니다.</p>
<p><a class="reference internal" href="subprocess.html#subprocess.Popen.terminate" title="subprocess.Popen.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess.Popen.terminate()</span></code></a>도 참조하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessTransport.close">
<code class="descclassname">SubprocessTransport.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessTransport.close" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.SubprocessTransport.kill" title="asyncio.SubprocessTransport.kill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kill()</span></code></a> 메서드를 호출하여 서브 프로세스를 죽입니다.</p>
<p>서브 프로세스가 아직 반환하지 않았으면, <em>stdin</em>, <em>stdout</em> 및 <em>stderr</em> 파이프의 트랜스포트를 닫습니다.</p>
</dd></dl>

</div>
</div>
<div class="section" id="protocols">
<span id="asyncio-protocol"></span><h2>프로토콜<a class="headerlink" href="#protocols" title="제목 주소">¶</a></h2>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/asyncio/protocols.py">Lib/asyncio/protocols.py</a></p>
<hr class="docutils" />
<p>asyncio는 네트워크 프로토콜을 구현하는 데 사용해야 하는 추상 베이스 클래스 집합을 제공합니다. 이러한 클래스는 <a class="reference internal" href="#asyncio-transport"><span class="std std-ref">트랜스포트</span></a>와 함께 사용해야 합니다.</p>
<p>추상 베이스 프로토콜 클래스의 서브 클래스는 일부 또는 모든 메서드를 구현할 수 있습니다. 이 모든 메서드는 콜백입니다: 이것들은 특정 이벤트에서 트랜스포트에 의해 호출됩니다, 예를 들어 어떤 데이터가 수신될 때. 베이스 프로토콜 메서드는 해당 트랜스포트에 의해 호출되어야 합니다.</p>
<div class="section" id="base-protocols">
<h3>베이스 프로토콜<a class="headerlink" href="#base-protocols" title="제목 주소">¶</a></h3>
<dl class="class">
<dt id="asyncio.BaseProtocol">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">BaseProtocol</code><a class="headerlink" href="#asyncio.BaseProtocol" title="정의 주소">¶</a></dt>
<dd><p>모든 프로토콜이 공유하는 메서드를 가진 베이스 프로토콜.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.Protocol">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">Protocol</code><span class="sig-paren">(</span><em>BaseProtocol</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Protocol" title="정의 주소">¶</a></dt>
<dd><p>스트리밍 프로토콜(TCP, 유닉스 소켓 등)을 구현하기 위한 베이스 클래스.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.BufferedProtocol">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">BufferedProtocol</code><span class="sig-paren">(</span><em>BaseProtocol</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BufferedProtocol" title="정의 주소">¶</a></dt>
<dd><p>수신 버퍼의 수동 제어로 스트리밍 프로토콜을 구현하기 위한 베이스 클래스.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.DatagramProtocol">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">DatagramProtocol</code><span class="sig-paren">(</span><em>BaseProtocol</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.DatagramProtocol" title="정의 주소">¶</a></dt>
<dd><p>데이터 그램 (UDP) 프로토콜을 구현하기 위한 베이스 클래스.</p>
</dd></dl>

<dl class="class">
<dt id="asyncio.SubprocessProtocol">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">SubprocessProtocol</code><span class="sig-paren">(</span><em>BaseProtocol</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessProtocol" title="정의 주소">¶</a></dt>
<dd><p>자식 프로세스와 통신하는 (단방향 파이프) 프로토콜을 구현하기 위한 베이스 클래스.</p>
</dd></dl>

</div>
<div class="section" id="base-protocol">
<h3>베이스 프로토콜<a class="headerlink" href="#base-protocol" title="제목 주소">¶</a></h3>
<p>모든 asyncio 프로토콜은 베이스 프로토콜 콜백을 구현할 수 있습니다.</p>
<p class="rubric">연결 콜백</p>
<p>연결 콜백은 모든 프로토콜에서 성공적으로 연결될 때마다 정확히 한 번 호출됩니다. 다른 모든 프로토콜 콜백은 이 두 메서드 사이에서만 호출될 수 있습니다.</p>
<dl class="method">
<dt id="asyncio.BaseProtocol.connection_made">
<code class="descclassname">BaseProtocol.</code><code class="descname">connection_made</code><span class="sig-paren">(</span><em>transport</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseProtocol.connection_made" title="정의 주소">¶</a></dt>
<dd><p>연결이 이루어질 때 호출됩니다.</p>
<p><em>transport</em> 인자는 연결을 나타내는 트랜스포트입니다. 트랜스포트에 대한 참조를 저장하는 것은 프로토콜의 책임입니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseProtocol.connection_lost">
<code class="descclassname">BaseProtocol.</code><code class="descname">connection_lost</code><span class="sig-paren">(</span><em>exc</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseProtocol.connection_lost" title="정의 주소">¶</a></dt>
<dd><p>연결이 끊어지거나 닫힐 때 호출됩니다.</p>
<p>인자는 예외 객체나 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>입니다. 후자는 정상적인 EOF가 수신되었거나, 연결의 이쪽에서 연결이 중단(abort)되거나 닫혔다는 것을 의미합니다.</p>
</dd></dl>

<p class="rubric">흐름 제어 콜백</p>
<p>흐름 제어 콜백은 프로토콜에 의해 수행되는 쓰기를 일시 중지하거나 다시 시작하도록 트랜스포트에 의해 호출될 수 있습니다.</p>
<p>자세한 내용은 <a class="reference internal" href="#asyncio.WriteTransport.set_write_buffer_limits" title="asyncio.WriteTransport.set_write_buffer_limits"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_write_buffer_limits()</span></code></a> 메서드 설명서를 참조하십시오.</p>
<dl class="method">
<dt id="asyncio.BaseProtocol.pause_writing">
<code class="descclassname">BaseProtocol.</code><code class="descname">pause_writing</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseProtocol.pause_writing" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트 버퍼가 높은 수위를 넘을 때 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseProtocol.resume_writing">
<code class="descclassname">BaseProtocol.</code><code class="descname">resume_writing</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseProtocol.resume_writing" title="정의 주소">¶</a></dt>
<dd><p>트랜스포트 버퍼가 낮은 수위 아래로 내려갈 때 호출됩니다.</p>
</dd></dl>

<p>버퍼 크기가 높은 수위와 같으면, <a class="reference internal" href="#asyncio.BaseProtocol.pause_writing" title="asyncio.BaseProtocol.pause_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pause_writing()</span></code></a>이 호출되지 않습니다: 버퍼 크기는 엄격하게 초과해야 합니다.</p>
<p>반대로, <a class="reference internal" href="#asyncio.BaseProtocol.resume_writing" title="asyncio.BaseProtocol.resume_writing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resume_writing()</span></code></a>은 버퍼 크기가 낮은 수위와 같거나 낮을 때 호출됩니다. 이러한 종료 조건은 수위가 0일 때 예상대로 진행되게 하려면 중요합니다.</p>
</div>
<div class="section" id="streaming-protocols">
<h3>스트리밍 프로토콜<a class="headerlink" href="#streaming-protocols" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_unix_server" title="asyncio.loop.create_unix_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_server()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_unix_connection" title="asyncio.loop.create_unix_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_connection()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.connect_accepted_socket" title="asyncio.loop.connect_accepted_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_accepted_socket()</span></code></a>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.connect_read_pipe" title="asyncio.loop.connect_read_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_read_pipe()</span></code></a> 및 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.connect_write_pipe()</span></code></a>와 같은 이벤트 메서드는 스트리밍 프로토콜을 반환하는 팩토리를 받아들입니다.</p>
<dl class="method">
<dt id="asyncio.Protocol.data_received">
<code class="descclassname">Protocol.</code><code class="descname">data_received</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Protocol.data_received" title="정의 주소">¶</a></dt>
<dd><p>어떤 데이터가 수신될 때 호출됩니다. <em>data</em>는 수신 데이터가 들어있는 비어 있지 않은 바이트열 객체입니다.</p>
<p>데이터가 버퍼 되고, 조각으로 나뉘고, 재조립되는지는 트랜스포트에 달려있습니다. 일반적으로, 특정 의미에 의존해서는 안 되며, 구문 분석을 일반적이고 유연하게 만들어야 합니다. 그러나, 데이터는 항상 올바른 순서로 수신됩니다.</p>
<p>이 메서드는 연결이 열려있는 동안 임의의 횟수만큼 호출될 수 있습니다.</p>
<p>그러나, <a class="reference internal" href="#asyncio.Protocol.eof_received" title="asyncio.Protocol.eof_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.eof_received()</span></code></a>는 최대한 한 번만 호출됩니다. 일단 <cite>eof_received()</cite>가 호출되면, <code class="docutils literal notranslate"><span class="pre">data_received()</span></code>는 더는 호출되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Protocol.eof_received">
<code class="descclassname">Protocol.</code><code class="descname">eof_received</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Protocol.eof_received" title="정의 주소">¶</a></dt>
<dd><p>다른 쪽 끝이 더는 데이터를 보내지 않을 것이라는 신호를 보낼 때 호출됩니다 (예를 들어, 다른 쪽 끝도 asyncio를 사용하면, <a class="reference internal" href="#asyncio.WriteTransport.write_eof" title="asyncio.WriteTransport.write_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport.write_eof()</span></code></a>를 호출하여).</p>
<p>이 메서드는 거짓 값(<code class="docutils literal notranslate"><span class="pre">None</span></code> 포함)을 반환할 수 있으며, 이때 트랜스포트는 스스로 닫힙니다. 반대로, 이 메서드가 참값을 반환하면, 사용된 프로토콜이 트랜스포트를 닫을지를 결정합니다. 기본 구현이 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환하기 때문에, 묵시적으로 연결을 닫습니다.</p>
<p>SSL을 포함한 일부 트랜스포트는, 반만 닫힌 연결을 지원하지 않습니다. 이때, 이 메서드에서 참을 반환하면 연결이 닫힙니다.</p>
</dd></dl>

<p>상태 기계:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>start -&gt; connection_made
    [-&gt; data_received]*
    [-&gt; eof_received]?
-&gt; connection_lost -&gt; end
</pre></div>
</div>
</div>
<div class="section" id="buffered-streaming-protocols">
<h3>버퍼 된 스트리밍 프로토콜<a class="headerlink" href="#buffered-streaming-protocols" title="제목 주소">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><strong>중요:</strong> 이것은 파이썬 3.7에서 <em>잠정적으로</em> asyncio에 추가되었습니다! 이것은 실험용 API로서, 파이썬 3.8에서 변경되거나 완전히 제거될 수 있습니다.</p>
</div>
<p>버퍼 된 프로토콜은 <a class="reference internal" href="#streaming-protocols">스트리밍 프로토콜</a>을 지원하는 모든 이벤트 루프 메서드와 함께 사용할 수 있습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">BufferedProtocol</span></code> 구현은 수신 버퍼의 명시적 수동 할당과 제어를 허용합니다. 이벤트 루프는 프로토콜에서 제공하는 버퍼를 사용하여 불필요한 데이터 복사를 피할 수 있습니다. 이로 인해 대량의 데이터를 수신하는 프로토콜의 성능이 크게 향상될 수 있습니다. 정교한 프로토콜 구현은 버퍼 할당 수를 크게 줄일 수 있습니다.</p>
<p>다음 콜백은 <a class="reference internal" href="#asyncio.BufferedProtocol" title="asyncio.BufferedProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedProtocol</span></code></a> 인스턴스에 호출됩니다.:</p>
<dl class="method">
<dt id="asyncio.BufferedProtocol.get_buffer">
<code class="descclassname">BufferedProtocol.</code><code class="descname">get_buffer</code><span class="sig-paren">(</span><em>sizehint</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BufferedProtocol.get_buffer" title="정의 주소">¶</a></dt>
<dd><p>새로운 수신 버퍼를 할당하기 위해서 호출됩니다.</p>
<p><em>sizehint</em>는 반환되는 버퍼에 대해 권장되는 최소 크기입니다. <em>sizehint</em>가 제안하는 것보다 더 작거나 큰 버퍼를 반환하는 것이 허용됩니다. -1로 설정하면 버퍼 크기는 임의적일 수 있습니다. 크기가 0인 버퍼를 반환하는 것은 에러입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">get_buffer()</span></code>는 <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">버퍼 프로토콜</span></a>을 구현하는 객체를 반환해야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BufferedProtocol.buffer_updated">
<code class="descclassname">BufferedProtocol.</code><code class="descname">buffer_updated</code><span class="sig-paren">(</span><em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BufferedProtocol.buffer_updated" title="정의 주소">¶</a></dt>
<dd><p>수신된 데이터로 버퍼가 갱신될 때 호출됩니다.</p>
<p><em>nbytes</em>는 버퍼에 기록된 총 바이트 수입니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BufferedProtocol.eof_received">
<code class="descclassname">BufferedProtocol.</code><code class="descname">eof_received</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BufferedProtocol.eof_received" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.Protocol.eof_received" title="asyncio.Protocol.eof_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.eof_received()</span></code></a> 메서드의 설명서를 참조하십시오.</p>
</dd></dl>

<p><a class="reference internal" href="#asyncio.BufferedProtocol.get_buffer" title="asyncio.BufferedProtocol.get_buffer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_buffer()</span></code></a>는 연결 중에 임의의 횟수만큼 호출될 수 있습니다. 그러나, <a class="reference internal" href="#asyncio.Protocol.eof_received" title="asyncio.Protocol.eof_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol.eof_received()</span></code></a>는 최대한 한 번만 호출되며, 호출되면 <a class="reference internal" href="#asyncio.BufferedProtocol.get_buffer" title="asyncio.BufferedProtocol.get_buffer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_buffer()</span></code></a>와 <a class="reference internal" href="#asyncio.BufferedProtocol.buffer_updated" title="asyncio.BufferedProtocol.buffer_updated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">buffer_updated()</span></code></a>는 그 이후로 호출되지 않습니다.</p>
<p>상태 기계:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>start -&gt; connection_made
    [-&gt; get_buffer
        [-&gt; buffer_updated]?
    ]*
    [-&gt; eof_received]?
-&gt; connection_lost -&gt; end
</pre></div>
</div>
</div>
<div class="section" id="datagram-protocols">
<h3>데이터 그램 프로토콜<a class="headerlink" href="#datagram-protocols" title="제목 주소">¶</a></h3>
<p>데이터 그램 프로토콜 인스턴스는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_datagram_endpoint" title="asyncio.loop.create_datagram_endpoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_datagram_endpoint()</span></code></a> 메서드에 전달된 프로토콜 팩토리에 의해 만들어져야 합니다.</p>
<dl class="method">
<dt id="asyncio.DatagramProtocol.datagram_received">
<code class="descclassname">DatagramProtocol.</code><code class="descname">datagram_received</code><span class="sig-paren">(</span><em>data</em>, <em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.DatagramProtocol.datagram_received" title="정의 주소">¶</a></dt>
<dd><p>데이터 그램이 수신될 때 호출됩니다. <em>data</em>는 수신 데이터를 포함하는 바이트열 객체입니다. <em>addr</em>는 데이터를 보내는 피어의 주소입니다; 정확한 형식은 트랜스포트에 따라 다릅니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.DatagramProtocol.error_received">
<code class="descclassname">DatagramProtocol.</code><code class="descname">error_received</code><span class="sig-paren">(</span><em>exc</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.DatagramProtocol.error_received" title="정의 주소">¶</a></dt>
<dd><p>이전의 송신이나 수신 연산이 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a>를 일으킬 때 호출됩니다. <em>exc</em>는 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> 인스턴스입니다.</p>
<p>이 메서드는 드문 조건에서 호출됩니다, 트랜스포트(예를 들어 UDP)가 데이터 그램을 수신자에게 전달할 수 없음을 감지했을 때입니다. 하지만 대부분 전달할 수 없는 데이터 그램은 조용히 삭제됩니다.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">주석</p>
<p>BSD 시스템(macOS, FreeBSD 등)에서는, 너무 많은 패킷을 쓰는 것으로 인한 전송 실패를 감지하는 신뢰성 있는 방법이 없으므로 데이터 그램 프로토콜에 대한 흐름 제어가 지원되지 않습니다.</p>
<p class="last">소켓은 항상 'ready'로 나타나고 여분의 패킷은 삭제됩니다. <code class="docutils literal notranslate"><span class="pre">errno</span></code>가 <a class="reference internal" href="errno.html#errno.ENOBUFS" title="errno.ENOBUFS"><code class="xref py py-const docutils literal notranslate"><span class="pre">errno.ENOBUFS</span></code></a>로 설정된 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생할 수도 그렇지 않을 수도 있습니다; 발생하면, <a class="reference internal" href="#asyncio.DatagramProtocol.error_received" title="asyncio.DatagramProtocol.error_received"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DatagramProtocol.error_received()</span></code></a>에게 보고되지만 그렇지 않으면 무시됩니다.</p>
</div>
</div>
<div class="section" id="subprocess-protocols">
<span id="asyncio-subprocess-protocols"></span><h3>서브 프로세스 프로토콜<a class="headerlink" href="#subprocess-protocols" title="제목 주소">¶</a></h3>
<p>서브 프로세스 프로토콜 인스턴스는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a> 와 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_shell" title="asyncio.loop.subprocess_shell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_shell()</span></code></a> 메서드에 전달된 프로토콜 팩토리에 의해 만들어져야 합니다.</p>
<dl class="method">
<dt id="asyncio.SubprocessProtocol.pipe_data_received">
<code class="descclassname">SubprocessProtocol.</code><code class="descname">pipe_data_received</code><span class="sig-paren">(</span><em>fd</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessProtocol.pipe_data_received" title="정의 주소">¶</a></dt>
<dd><p>자식 프로세스가 stdout 이나 stderr 파이프에 데이터를 쓸 때 호출됩니다.</p>
<p><em>fd</em>는 파이프의 정수 파일 기술자입니다.</p>
<p><em>data</em>는 수신 된 데이터를 포함하는 비어 있지 않은 바이트열 객체입니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessProtocol.pipe_connection_lost">
<code class="descclassname">SubprocessProtocol.</code><code class="descname">pipe_connection_lost</code><span class="sig-paren">(</span><em>fd</em>, <em>exc</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessProtocol.pipe_connection_lost" title="정의 주소">¶</a></dt>
<dd><p>자식 프로세스와 통신하는 파이프 중 하나가 닫히면 호출됩니다.</p>
<p><em>fd</em>는 닫힌 정수 파일 기술자입니다.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.SubprocessProtocol.process_exited">
<code class="descclassname">SubprocessProtocol.</code><code class="descname">process_exited</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.SubprocessProtocol.process_exited" title="정의 주소">¶</a></dt>
<dd><p>자식 프로세스가 종료할 때 호출됩니다.</p>
</dd></dl>

</div>
</div>
<div class="section" id="examples">
<h2>예제<a class="headerlink" href="#examples" title="제목 주소">¶</a></h2>
<div class="section" id="tcp-echo-server">
<span id="asyncio-example-tcp-echo-server-protocol"></span><h3>TCP 메아리 서버<a class="headerlink" href="#tcp-echo-server" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> 메서드를 사용하여 TCP 메아리 서버를 만들고, 받은 데이터를 다시 보내고, 연결을 닫습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>


<span class="k">class</span> <span class="nc">EchoServerProtocol</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="n">peername</span> <span class="o">=</span> <span class="n">transport</span><span class="o">.</span><span class="n">get_extra_info</span><span class="p">(</span><span class="s1">&#39;peername&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Connection from </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">peername</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>

    <span class="k">def</span> <span class="nf">data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data received: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">message</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Send: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">message</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Close the client socket&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 저수준 API를 사용할 계획이므로 이벤트 루프에 대한 참조를 얻습니다.</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="n">server</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">EchoServerProtocol</span><span class="p">(),</span>
        <span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8888</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">with</span> <span class="n">server</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>


<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="asyncio-stream.html#asyncio-tcp-echo-server-streams"><span class="std std-ref">스트림을 사용하는 TCP 메아리 서버</span></a> 예제는 고수준 <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.start_server()</span></code></a> 함수를 사용합니다.</p>
</div>
</div>
<div class="section" id="tcp-echo-client">
<span id="asyncio-example-tcp-echo-client-protocol"></span><h3>TCP 메아리 클라이언트<a class="headerlink" href="#tcp-echo-client" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> 메서드를 사용하는 TCP 메아리 클라이언트, 데이터를 보내고 연결이 닫힐 때까지 기다립니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>


<span class="k">class</span> <span class="nc">EchoClientProtocol</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">on_con_lost</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_con_lost</span> <span class="o">=</span> <span class="n">on_con_lost</span>

    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data sent: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data received: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">connection_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The server closed the connection&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_con_lost</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 저수준 API를 사용할 계획이므로 이벤트 루프에 대한 참조를 얻습니다.</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="n">on_con_lost</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;Hello World!&#39;</span>

    <span class="n">transport</span><span class="p">,</span> <span class="n">protocol</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_connection</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">EchoClientProtocol</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">on_con_lost</span><span class="p">),</span>
        <span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8888</span><span class="p">)</span>

    <span class="c1"># 프로토콜이 연결이 끊어졌음을 알릴 때까지 기다리고 트랜스포트를 닫습니다.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">on_con_lost</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p class="last"><a class="reference internal" href="asyncio-stream.html#asyncio-tcp-echo-client-streams"><span class="std std-ref">스트림을 사용하는 TCP 메아리 클라이언트</span></a> 예제는 고수준 <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a> 함수를 사용합니다.</p>
</div>
</div>
<div class="section" id="udp-echo-server">
<span id="asyncio-udp-echo-server-protocol"></span><h3>UDP 메아리 서버<a class="headerlink" href="#udp-echo-server" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_datagram_endpoint" title="asyncio.loop.create_datagram_endpoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_datagram_endpoint()</span></code></a> 메서드를 사용하는 UDP 메아리 서버, 수신된 데이터를 다시 보냅니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>


<span class="k">class</span> <span class="nc">EchoServerProtocol</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>

    <span class="k">def</span> <span class="nf">datagram_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Received </span><span class="si">%r</span><span class="s1"> from </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Send </span><span class="si">%r</span><span class="s1"> to </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting UDP server&quot;</span><span class="p">)</span>

    <span class="c1"># 저수준 API를 사용할 계획이므로 이벤트 루프에 대한 참조를 얻습니다.</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="c1"># 모든 클라이언트 요청을 처리할 하나의 프로토콜 인스턴스가 만들어집니다.</span>
    <span class="n">transport</span><span class="p">,</span> <span class="n">protocol</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_datagram_endpoint</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">EchoServerProtocol</span><span class="p">(),</span>
        <span class="n">local_addr</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">9999</span><span class="p">))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>  <span class="c1"># 1시간 동안 서비스합니다.</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="udp-echo-client">
<span id="asyncio-udp-echo-client-protocol"></span><h3>UDP 메아리 클라이언트<a class="headerlink" href="#udp-echo-client" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_datagram_endpoint" title="asyncio.loop.create_datagram_endpoint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_datagram_endpoint()</span></code></a> 메서드를 사용하는 UDP 메아리 클라이언트, 데이터를 보내고 응답을 받으면 트랜스포트를 닫습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>


<span class="k">class</span> <span class="nc">EchoClientProtocol</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">on_con_lost</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_con_lost</span> <span class="o">=</span> <span class="n">on_con_lost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Send:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">datagram_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Received:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Close the socket&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">error_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error received:&#39;</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connection_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Connection closed&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_con_lost</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 저수준 API를 사용할 계획이므로 이벤트 루프에 대한 참조를 얻습니다.</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="n">on_con_lost</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Hello World!&quot;</span>

    <span class="n">transport</span><span class="p">,</span> <span class="n">protocol</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_datagram_endpoint</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">EchoClientProtocol</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">on_con_lost</span><span class="p">),</span>
        <span class="n">remote_addr</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">9999</span><span class="p">))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">on_con_lost</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="connecting-existing-sockets">
<span id="asyncio-example-create-connection"></span><h3>기존 소켓 연결하기<a class="headerlink" href="#connecting-existing-sockets" title="제목 주소">¶</a></h3>
<p>프로토콜과 함께 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> 메서드를 사용하여 소켓이 데이터를 수신할 때까지 기다립니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">socket</span>


<span class="k">class</span> <span class="nc">MyProtocol</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on_con_lost</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_con_lost</span> <span class="o">=</span> <span class="n">on_con_lost</span>

    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>

    <span class="k">def</span> <span class="nf">data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Received:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>

        <span class="c1"># 작업을 완료했습니다: 트랜스포트를 닫습니다;</span>
        <span class="c1"># connection_lost()가 자동으로 호출됩니다.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">connection_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
        <span class="c1"># 소켓이 닫혔습니다.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_con_lost</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 저수준 API를 사용할 계획이므로 이벤트 루프에 대한 참조를 얻습니다.</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
    <span class="n">on_con_lost</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>

    <span class="c1"># 연결된 소켓 쌍을 만듭니다</span>
    <span class="n">rsock</span><span class="p">,</span> <span class="n">wsock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socketpair</span><span class="p">()</span>

    <span class="c1"># 데이터를 기다릴 소켓을 등록합니다.</span>
    <span class="n">transport</span><span class="p">,</span> <span class="n">protocol</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_connection</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">MyProtocol</span><span class="p">(</span><span class="n">on_con_lost</span><span class="p">),</span> <span class="n">sock</span><span class="o">=</span><span class="n">rsock</span><span class="p">)</span>

    <span class="c1"># 네트워크로부터의 데이터 수신을 흉내 냅니다.</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">wsock</span><span class="o">.</span><span class="n">send</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">protocol</span><span class="o">.</span><span class="n">on_con_lost</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">wsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio-example-watch-fd"><span class="std std-ref">파일 기술자에서 읽기 이벤트를 관찰하기</span></a> 예제는 저수준의 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.add_reader" title="asyncio.loop.add_reader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_reader()</span></code></a> 메서드를 사용하여 FD를 등록합니다.</p>
<p class="last"><a class="reference internal" href="asyncio-stream.html#asyncio-example-create-connection-streams"><span class="std std-ref">스트림을 사용하여 데이터를 기다리는 열린 소켓 등록</span></a> 예제는 코루틴에서 <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_connection()</span></code></a> 함수에 의해 생성된 고수준 스트림을 사용합니다.</p>
</div>
</div>
<div class="section" id="loop-subprocess-exec-and-subprocessprotocol">
<span id="asyncio-example-subprocess-proto"></span><h3>loop.subprocess_exec() 와 SubprocessProtocol<a class="headerlink" href="#loop-subprocess-exec-and-subprocessprotocol" title="제목 주소">¶</a></h3>
<p>서브 프로세스의 출력을 가져오고 서브 프로세스가 끝날 때까지 대기하는 데 사용되는 서브 프로세스 프로토콜의 예.</p>
<p>서브 프로세스는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a> 메서드에 의해 만들어집니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">class</span> <span class="nc">DateProtocol</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">SubprocessProtocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exit_future</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exit_future</span> <span class="o">=</span> <span class="n">exit_future</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">pipe_data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_exited</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exit_future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">get_date</span><span class="p">():</span>
    <span class="c1"># 저수준 API를 사용할 계획이므로 이벤트 루프에 대한 참조를 얻습니다.</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="n">code</span> <span class="o">=</span> <span class="s1">&#39;import datetime; print(datetime.datetime.now())&#39;</span>
    <span class="n">exit_future</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">(</span><span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">)</span>

    <span class="c1"># DateProtocol이 제어하는 서브 프로세스를 만듭니다;</span>
    <span class="c1"># 표준 출력을 파이프로 리디렉트합니다.</span>
    <span class="n">transport</span><span class="p">,</span> <span class="n">protocol</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">subprocess_exec</span><span class="p">(</span>
        <span class="k">lambda</span><span class="p">:</span> <span class="n">DateProtocol</span><span class="p">(</span><span class="n">exit_future</span><span class="p">),</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">executable</span><span class="p">,</span> <span class="s1">&#39;-c&#39;</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span>
        <span class="n">stdin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># 프로토콜의 process_exited() 메서드를 사용하여 서브 프로세스 종료를 기다립니다.</span>
    <span class="k">await</span> <span class="n">exit_future</span>

    <span class="c1"># stdout 파이프를 닫습니다.</span>
    <span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># 프로토콜의 pipe_data_received() 메서드로 수집된 출력을 읽습니다.</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">protocol</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

<span class="n">date</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">get_date</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Current date: </span><span class="si">{date}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>고수준 API를 사용하여 작성된 <a class="reference internal" href="asyncio-subprocess.html#asyncio-example-create-subprocess-exec"><span class="std std-ref">같은 예제</span></a>도 참조하십시오.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">트랜스포트와 프로토콜</a><ul>
<li><a class="reference internal" href="#transports">트랜스포트</a><ul>
<li><a class="reference internal" href="#transports-hierarchy">트랜스포트 계층 구조</a></li>
<li><a class="reference internal" href="#base-transport">베이스 트랜스포트</a></li>
<li><a class="reference internal" href="#read-only-transports">읽기 전용 트랜스포트</a></li>
<li><a class="reference internal" href="#write-only-transports">쓰기 전용 트랜스포트</a></li>
<li><a class="reference internal" href="#datagram-transports">데이터 그램 트랜스포트</a></li>
<li><a class="reference internal" href="#subprocess-transports">서브 프로세스 트랜스포트</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">프로토콜</a><ul>
<li><a class="reference internal" href="#base-protocols">베이스 프로토콜</a></li>
<li><a class="reference internal" href="#base-protocol">베이스 프로토콜</a></li>
<li><a class="reference internal" href="#streaming-protocols">스트리밍 프로토콜</a></li>
<li><a class="reference internal" href="#buffered-streaming-protocols">버퍼 된 스트리밍 프로토콜</a></li>
<li><a class="reference internal" href="#datagram-protocols">데이터 그램 프로토콜</a></li>
<li><a class="reference internal" href="#subprocess-protocols">서브 프로세스 프로토콜</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">예제</a><ul>
<li><a class="reference internal" href="#tcp-echo-server">TCP 메아리 서버</a></li>
<li><a class="reference internal" href="#tcp-echo-client">TCP 메아리 클라이언트</a></li>
<li><a class="reference internal" href="#udp-echo-server">UDP 메아리 서버</a></li>
<li><a class="reference internal" href="#udp-echo-client">UDP 메아리 클라이언트</a></li>
<li><a class="reference internal" href="#connecting-existing-sockets">기존 소켓 연결하기</a></li>
<li><a class="reference internal" href="#loop-subprocess-exec-and-subprocessprotocol">loop.subprocess_exec() 와 SubprocessProtocol</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="asyncio-future.html"
                        title="이전 장">퓨처</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="asyncio-policy.html"
                        title="다음 장">정책</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-policy.html" title="정책"
             >다음</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="퓨처"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" ><code class="docutils literal notranslate"><span class="pre">asyncio</span></code> --- 비동기 I/O</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>