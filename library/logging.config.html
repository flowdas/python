
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>logging.config --- 로깅 구성 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="logging.handlers --- 로깅 처리기" href="logging.handlers.html" />
    <link rel="prev" title="logging --- 파이썬 로깅 시설" href="logging.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/logging.config.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="logging.handlers.html" title="logging.handlers --- 로깅 처리기"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="logging.html" title="logging --- 파이썬 로깅 시설"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">일반 운영 체제 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-logging.config">
<span id="logging-config-logging-configuration"></span><h1><a class="reference internal" href="#module-logging.config" title="logging.config: Configuration of the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code></a> --- 로깅 구성<a class="headerlink" href="#module-logging.config" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/logging/config.py">Lib/logging/config.py</a></p>
<div class="sidebar">
<p class="sidebar-title">Important</p>
<p>이 페이지에는 레퍼런스 정보만 있습니다. 자습서는 다음을 참조하십시오</p>
<ul class="simple">
<li><p><a class="reference internal" href="../howto/logging.html#logging-basic-tutorial"><span class="std std-ref">기초 자습서</span></a></p></li>
<li><p><a class="reference internal" href="../howto/logging.html#logging-advanced-tutorial"><span class="std std-ref">고급 자습서</span></a></p></li>
<li><p><a class="reference internal" href="../howto/logging-cookbook.html#logging-cookbook"><span class="std std-ref">로깅 요리책</span></a></p></li>
</ul>
</div>
<hr class="docutils" />
<p>이 절에서는 logging 모듈을 구성하기 위한 API에 관해 설명합니다.</p>
<div class="section" id="configuration-functions">
<span id="logging-config-api"></span><h2>구성 함수<a class="headerlink" href="#configuration-functions" title="제목 주소">¶</a></h2>
<p>다음 함수는 logging 모듈을 구성합니다. <a class="reference internal" href="#module-logging.config" title="logging.config: Configuration of the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code></a> 모듈에 있습니다. 사용은 선택 사항입니다 --- 이 함수들을 사용하거나 (<a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 자체에서 정의된) 주 API를 호출하고 <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a>이나 <a class="reference internal" href="logging.handlers.html#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a>에서 선언된 처리기를 정의해서 logging 모듈을 구성할 수 있습니다.</p>
<dl class="function">
<dt id="logging.config.dictConfig">
<code class="descclassname">logging.config.</code><code class="descname">dictConfig</code><span class="sig-paren">(</span><em>config</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.config.dictConfig" title="정의 주소">¶</a></dt>
<dd><blockquote>
<div><p>딕셔너리로 로깅 구성을 받습니다. 이 딕셔너리의 내용은 아래의 <a class="reference internal" href="#logging-config-dictschema"><span class="std std-ref">구성 딕셔너리 스키마</span></a>에 설명되어 있습니다.</p>
<p>구성 중에 에러를 만나면, 이 함수는 적절하게 설명하는 메시지와 함께 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>, <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 또는 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>를 발생시킵니다. 다음은 에러를 발생시킬 수 있는 (불완전한) 조건 목록입니다:</p>
<ul class="simple">
<li><p>문자열이 아니거나 실제 로깅 수준과 일치하지 않는 문자열인 <code class="docutils literal notranslate"><span class="pre">level</span></code>.</p></li>
<li><p>불리언이 아닌 <code class="docutils literal notranslate"><span class="pre">propagate</span></code> 값.</p></li>
<li><p>해당 대상이 없는 id.</p></li>
<li><p>증분(incremental) 호출 중에 발견된 존재하지 않는 처리기 id.</p></li>
<li><p>잘못된 로거 이름.</p></li>
<li><p>결정할 수 없는 내부나 외부 객체.</p></li>
</ul>
<p>구문 분석은 <code class="xref py py-class docutils literal notranslate"><span class="pre">DictConfigurator</span></code> 클래스에 의해 수행되며, 생성자로는 구성에 사용되는 딕셔너리가 전달되고, 객체는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">configure()</span></code> 메서드를 가집니다. <a class="reference internal" href="#module-logging.config" title="logging.config: Configuration of the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code></a> 모듈에는 초기에 <code class="xref py py-class docutils literal notranslate"><span class="pre">DictConfigurator</span></code>로 설정된 콜러블 어트리뷰트 <code class="xref py py-attr docutils literal notranslate"><span class="pre">dictConfigClass</span></code>가 있습니다. 여러분 자신의 적절한 구현으로 <code class="xref py py-attr docutils literal notranslate"><span class="pre">dictConfigClass</span></code>의 값을 바꿀 수 있습니다.</p>
<p><a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a>는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">dictConfigClass</span></code>를 호출해서 지정된 딕셔너리를 전달한 다음, 반환된 객체의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">configure()</span></code> 메서드를 호출하여 구성을 적용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dictConfig</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
    <span class="n">dictConfigClass</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="o">.</span><span class="n">configure</span><span class="p">()</span>
</pre></div>
</div>
<p>예를 들어, <code class="xref py py-class docutils literal notranslate"><span class="pre">DictConfigurator</span></code>의 서브 클래스는 자체 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>에서 <code class="docutils literal notranslate"><span class="pre">DictConfigurator.__init__()</span></code>를 호출한 다음, 후속 <code class="xref py py-meth docutils literal notranslate"><span class="pre">configure()</span></code> 호출에서 사용할 수 있는 사용자 정의 접두사를 설정할 수 있습니다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">dictConfigClass</span></code>는 이 새 서브 클래스에 연결되고, <a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a>는 기본, 사용자 정의되지 않은 상태에서와 똑같이 호출될 수 있습니다.</p>
</div></blockquote>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.config.fileConfig">
<code class="descclassname">logging.config.</code><code class="descname">fileConfig</code><span class="sig-paren">(</span><em>fname</em>, <em>defaults=None</em>, <em>disable_existing_loggers=True</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.config.fileConfig" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="configparser.html#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a>-형식 파일에서 로깅 구성을 읽습니다. 파일 형식은 <a class="reference internal" href="#logging-config-fileformat"><span class="std std-ref">구성 파일 형식</span></a>에 설명된 것과 같아야 합니다. 이 함수는 응용 프로그램에서 여러 번 호출 할 수 있어서, 최종 사용자가 여러 가지 미리 준비된 구성 중에서 선택할 수 있도록 합니다 (개발자가 선택 사항을 표시하고 선택한 구성을 로드하는 메커니즘을 제공한다면).</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> -- 파일명, 또는 파일류 객체, 또는 <a class="reference internal" href="configparser.html#configparser.RawConfigParser" title="configparser.RawConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">RawConfigParser</span></code></a>에서 파생된 인스턴스. <code class="docutils literal notranslate"><span class="pre">RawConfigParser</span></code>-파생 인스턴스가 전달되면, 그대로 사용됩니다. 그렇지 않으면, <code class="xref py py-class docutils literal notranslate"><span class="pre">Configparser</span></code>의 인스턴스가 만들어지고, 이것으로 <code class="docutils literal notranslate"><span class="pre">fname</span></code>으로 전달된 객체로부터 구성을 읽습니다. <a class="reference internal" href="readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> 메서드가 있으면, 파일류 객체라고 가정하고, <a class="reference internal" href="configparser.html#configparser.ConfigParser.read_file" title="configparser.ConfigParser.read_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_file()</span></code></a>을 사용하여 읽습니다; 그렇지 않으면, 파일명으로 간주하고 <a class="reference internal" href="configparser.html#configparser.ConfigParser.read" title="configparser.ConfigParser.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>로 전달됩니다.</p></li>
<li><p><strong>defaults</strong> -- ConfigParser로 전달되는 기본값을 이 인자로 지정할 수 있습니다.</p></li>
<li><p><strong>disable_existing_loggers</strong> -- <code class="docutils literal notranslate"><span class="pre">False</span></code>로 지정되면, 이 호출이 이루어졌을 때 존재하는 로거는 활성화된 상태로 남습니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">True</span></code>이므로, 과거 호환성을 유지하도록 이전 동작을 활성화합니다. 이 동작은 이미 존재하는 비 루트 로거를 그들이나 그들의 조상이 로깅 구성에서 명시적으로 명명되지 않으면 비활성화하는 것입니다.</p></li>
</ul>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><a class="reference internal" href="configparser.html#configparser.RawConfigParser" title="configparser.RawConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">RawConfigParser</span></code></a>의 서브 클래스의 인스턴스가 이제 <code class="docutils literal notranslate"><span class="pre">fname</span></code>에 대한 값으로 허용됩니다. 이것은 다음을 쉽게 합니다:</p>
<ul class="simple">
<li><p>로깅 구성이 전체 응용 프로그램 구성의 일부인 구성 파일의 사용.</p></li>
<li><p>파일에서 읽어 들인 다음 <code class="docutils literal notranslate"><span class="pre">fileConfig</span></code>로 전달되기 전에 사용하는 응용 프로그램이 (예를 들어, 명령 줄 매개 변수나 실행 시간 환경의 다른 측면에 기반하여) 수정하는 구성의 사용.</p></li>
</ul>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.config.listen">
<code class="descclassname">logging.config.</code><code class="descname">listen</code><span class="sig-paren">(</span><em>port=DEFAULT_LOGGING_CONFIG_PORT</em>, <em>verify=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.config.listen" title="정의 주소">¶</a></dt>
<dd><p>지정된 포트에서 소켓 서버를 시작하고, 새 구성을 수신 대기합니다. 포트를 지정하지 않으면, 모듈의 기본 <code class="xref py py-const docutils literal notranslate"><span class="pre">DEFAULT_LOGGING_CONFIG_PORT</span></code>가 사용됩니다. 로깅 구성은 <a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a>나 <a class="reference internal" href="#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a>로 처리하기에 적합한 파일로 전송됩니다. 서버를 시작하기 위해 <a class="reference internal" href="threading.html#threading.Thread.start" title="threading.Thread.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>를 호출할 수 있는 <a class="reference internal" href="threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal notranslate"><span class="pre">Thread</span></code></a> 인스턴스를 반환하고, 적절할 때 <a class="reference internal" href="threading.html#threading.Thread.join" title="threading.Thread.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a>할 수 있습니다. 서버를 중지하려면, <a class="reference internal" href="#logging.config.stopListening" title="logging.config.stopListening"><code class="xref py py-func docutils literal notranslate"><span class="pre">stopListening()</span></code></a>을 호출하십시오.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><code class="xref py py-const docutils literal notranslate"><span class="pre">DEFAULT_LOGGING_CONFIG_PORT</span></code>은 9030입니다.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">verify</span></code> 인자가 지정되면, 소켓을 통해 수신된 바이트열이 유효하고 처리되어야 하는지를 확인하는 콜러블이어야 합니다. 소켓을 통해 전송되는 것을 암호화 및/또는 서명하고, <code class="docutils literal notranslate"><span class="pre">verify</span></code> 콜러블이 서명 확인 및/또는 암호 해독을 수행할 수 있습니다. <code class="docutils literal notranslate"><span class="pre">verify</span></code> 콜러블은 단일 인자(소켓을 통해 수신된 바이트열)로 호출되며, 처리할 바이트열이나 바이트열을 버려야 함을 나타내기 위해 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 반환된 바이트열은 전달된 바이트열과 같을 수 있고 (예를 들어, 확인만 수행될 때), 또는 완전히 다를 수 있습니다 (아마도 암호 해독이 수행될 때).</p>
<p>소켓으로 구성을 보내려면, 구성 파일을 읽어서 소켓에 <code class="docutils literal notranslate"><span class="pre">struct.pack('&gt;L',</span> <span class="pre">n)</span></code>를 사용하여 바이너리로 만든 4바이트의 길이를 앞에 붙인 바이트 시퀀스를 보냅니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>앞에 붙는 4바이트 길이는 암호화나 서명의 대상이 아닙니다. <code class="docutils literal notranslate"><span class="pre">verify</span></code>로는 그 뒤에 오는
바이트열만 전달됩니다. 따라서 길이는 암호화나 서명 이후의 바이트열의 길이가 되어야 합니다.</p>
<p>또한 4바이트 길이가 한 번의 <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a> 로 읽힌다고 가정하고 있습니다.
아주 안전하지는 않은 코드인데, 구성을 보낼 때 최소한 4바이트 길이는 한 번의
<a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> 호출로 전달되도록 신경 써야 합니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>구성 일부가 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>로 전달되므로, 이 함수를 사용하면 사용자를 보안 위험에 노출할 수 있습니다. 이 함수는 소켓을 <code class="docutils literal notranslate"><span class="pre">localhost</span></code>에만 바인드하고, 원격 기계의 연결은 허용하지 않지만, 신뢰할 수 없는 코드가 <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a>을 호출하는 프로세스의 계정으로 실행될 수 있는 시나리오가 있습니다. 특히, <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a>을 호출하는 프로세스가 사용자가 서로를 신뢰할 수 없는 다중 사용자 시스템에서 실행되는 경우, 악의적인 사용자는 피해자의 <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a> 소켓에 연결하여 공격자가 피해자의 프로세스에서 실행하고자 하는 코드를 실행하는 구성을 보내는 것만으로도, 피해 사용자의 프로세스에서 사실상 임의의 코드를 실행할 수 있습니다. 이것은 기본 포트를 사용하는 경우 특히 쉽게 수행할 수 있지만, 다른 포트가 사용되는 경우에도 어렵지는 않습니다. 이러한 일이 발생할 위험을 피하려면, <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a>에 <code class="docutils literal notranslate"><span class="pre">verify</span></code> 인자를 사용하여 인식되지 않은 구성이 적용되지 않도록 하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">verify</span></code> 인자가 추가되었습니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>리스너에 기존 로거를 비활성화하지 않는 구성을 보내려면, <a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a>를 사용하도록 구성에 JSON 형식을 사용해야 합니다. 이 방법은 보내는 구성에서 <code class="docutils literal notranslate"><span class="pre">disable_existing_loggers</span></code>를 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 지정할 수 있도록 합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="logging.config.stopListening">
<code class="descclassname">logging.config.</code><code class="descname">stopListening</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.config.stopListening" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a>에 대한 호출로 만들어진 리스닝 서버를 중지합니다. 이것은 일반적으로 <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a>의 반환 값에 대해 <code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code>을 호출하기 전에 호출됩니다.</p>
</dd></dl>

</div>
<div class="section" id="configuration-dictionary-schema">
<span id="logging-config-dictschema"></span><h2>구성 딕셔너리 스키마<a class="headerlink" href="#configuration-dictionary-schema" title="제목 주소">¶</a></h2>
<p>로깅 구성을 기술하려면 만들려는 다양한 객체와 그들 간의 연결을 나열해야 합니다; 예를 들어, 'console'이라는 처리기를 만든 다음 'startup'이라는 로거가 'console' 처리기에 메시지를 보낼 것이라고 말할 수 있습니다. 사용자 자신의 포매터나 처리기 클래스를 작성할 수 있으므로, 이러한 객체가 <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 모듈에서 제공하는 객체로만 제한되지는 않습니다. 이러한 클래스의 매개 변수는 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>과 같은 외부 객체를 포함할 수도 있습니다. 이러한 객체와 연결을 기술하는 문법은 아래의 <a class="reference internal" href="#logging-config-dict-connections"><span class="std std-ref">객체 연결</span></a>에 정의되어 있습니다.</p>
<div class="section" id="dictionary-schema-details">
<h3>딕셔너리 스키마 세부사항<a class="headerlink" href="#dictionary-schema-details" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a>에 전달되는 딕셔너리에는 반드시 다음 키가 있어야 합니다:</p>
<ul class="simple">
<li><p><em>version</em> - 스키마 버전을 나타내는 정숫값으로 설정됩니다. 현재 유효한 유일한 값은 1이지만, 이 키를 사용하면 과거 호환성을 유지하면서 스키마를 발전시킬 수 있습니다.</p></li>
</ul>
<p>다른 모든 키는 선택 사항이지만, 있으면 아래에 설명된 대로 해석됩니다. 아래에서 '구성 딕셔너리(configuring dict)'가 언급되는 모든 경우에, 특수한 <code class="docutils literal notranslate"><span class="pre">'()'</span></code> 키를 검사해서 사용자 정의 인스턴스화가 필요한지를 확인합니다. 있다면, 아래의 <a class="reference internal" href="#logging-config-dict-userdef"><span class="std std-ref">사용자 정의 객체</span></a>에 설명된 메커니즘을 사용하여 인스턴스를 만듭니다; 그렇지 않다면, 어떤 인스턴스를 만들지를 결정하는데 문맥이 사용됩니다.</p>
<ul>
<li><p><em>formatters</em> - 해당 값은 딕셔너리인데, 각 키는 포매터 id이고, 각 값은 해당 <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 인스턴스를 구성하는 방법을 설명하는 딕셔너리입니다.</p>
<p>구성 딕셔너리는 키 <code class="docutils literal notranslate"><span class="pre">format</span></code>과 <code class="docutils literal notranslate"><span class="pre">datefmt</span></code>(기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>)으로 검색되며 이들은 <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 인스턴스를 만드는 데 사용됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>a <code class="docutils literal notranslate"><span class="pre">validate</span></code> key (with default of <code class="docutils literal notranslate"><span class="pre">True</span></code>) can be added into
the <code class="docutils literal notranslate"><span class="pre">formatters</span></code> section of the configuring dict, this is to
validate the format.</p>
</div>
</li>
<li><p><em>filters</em> - 해당 값은 딕셔너리인데, 각 키가 필터 id이고 각 값은 해당 Filter 인스턴스를 구성하는 방법을 설명하는 딕셔너리입니다.</p>
<p>구성 딕셔너리는 키 <code class="docutils literal notranslate"><span class="pre">name</span></code>(기본값은 빈 문자열)으로 검색되며, 이는 <a class="reference internal" href="logging.html#logging.Filter" title="logging.Filter"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Filter</span></code></a> 인스턴스를 만드는 데 사용됩니다.</p>
</li>
<li><p><em>handlers</em> - 해당 값은 딕셔너리인데, 각 키가 처리기 id이고 각 값은 해당 Handler 인스턴스를 구성하는 방법을 설명하는 딕셔너리입니다.</p>
<p>구성 딕셔너리는 다음 키에서 검색합니다:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">class</span></code> (필수). 이것은 처리기 클래스의 완전히 정규화된 이름입니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">level</span></code> (선택). 처리기의 수준.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">formatter</span></code> (선택). 이 처리기의 포매터의 id.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">filters</span></code> (선택). 이 처리기의 필터의 id의 리스트.</p></li>
</ul>
<p>모든 <em>다른</em> 키는, 처리기의 생성자에 키워드 인자로 전달됩니다. 예를 들어, 다음과 같이 주어진 조각에서:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">handlers</span><span class="p">:</span>
  <span class="nt">console</span><span class="p">:</span>
    <span class="nt">class </span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">logging.StreamHandler</span>
    <span class="nt">formatter</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">brief</span>
    <span class="nt">level   </span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">INFO</span>
    <span class="nt">filters</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="nv">allow_foo</span><span class="p p-Indicator">]</span>
    <span class="nt">stream  </span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ext://sys.stdout</span>
  <span class="nt">file</span><span class="p">:</span>
    <span class="nt">class </span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">logging.handlers.RotatingFileHandler</span>
    <span class="nt">formatter</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">precise</span>
    <span class="nt">filename</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">logconfig.log</span>
    <span class="nt">maxBytes</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">1024</span>
    <span class="nt">backupCount</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">3</span>
</pre></div>
</div>
<p>id가 <code class="docutils literal notranslate"><span class="pre">console</span></code> 인 처리기는 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>를 하부 스트림으로 사용하는 <a class="reference internal" href="logging.handlers.html#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.StreamHandler</span></code></a>로 인스턴스가 만들어집니다. id가 <code class="docutils literal notranslate"><span class="pre">file</span></code> 인 처리기는 키워드 인자 <code class="docutils literal notranslate"><span class="pre">filename='logconfig.log',</span> <span class="pre">maxBytes=1024,</span> <span class="pre">backupCount=3</span></code>를 사용하여 <a class="reference internal" href="logging.handlers.html#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.handlers.RotatingFileHandler</span></code></a>로 인스턴스가 만들어집니다.</p>
</li>
<li><p><em>loggers</em> - 해당 값은 딕셔너리인데, 각 키가 로거 이름이고 각 값은 해당 Logger 인스턴스를 구성하는 방법을 설명하는 딕셔너리입니다.</p>
<p>구성 딕셔너리는 다음 키에서 검색합니다:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">level</span></code> (선택). 로거의 수준.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">propagate</span></code> (선택). 로거의 전파(propagation) 설정.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">filters</span></code> (선택). 이 로거의 필터의 id의 리스트</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">handlers</span></code> (선택). 이 로거의 처리기의 id의 리스트.</p></li>
</ul>
<p>지정된 로거는 지정된 수준, 전파, 필터와 처리기에 따라 구성됩니다.</p>
</li>
<li><p><em>root</em> - 루트 로거에 대한 구성입니다. <code class="docutils literal notranslate"><span class="pre">propagate</span></code> 설정을 적용할 수 없다는 점을 제외하고 구성 처리는 모든 로거와 같습니다.</p></li>
<li><p><em>incremental</em> - 구성을 기존 구성의 증분으로 해석할지 여부. 이 값의 기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code>이며, 이는 지정된 구성이 기존 구성을 기존 <a class="reference internal" href="#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a> API에서 사용된 것과 같은 의미로 대체 함을 뜻합니다.</p>
<p>지정된 값이 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, <a class="reference internal" href="#logging-config-dict-incremental"><span class="std std-ref">증분 구성</span></a> 절에서 설명하는 대로 구성이 처리됩니다.</p>
</li>
<li><p><em>disable_existing_loggers</em> - 기존의 루트가 아닌 로거를 비활성화할지 여부. 이 설정은 <a class="reference internal" href="#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a>의 같은 이름의 매개 변수를 반영합니다. 없으면, 이 매개 변수의 기본값은 <code class="docutils literal notranslate"><span class="pre">True</span></code>입니다. <em>incremental</em>이 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면 이 값은 무시됩니다.</p></li>
</ul>
</div>
<div class="section" id="incremental-configuration">
<span id="logging-config-dict-incremental"></span><h3>증분 구성<a class="headerlink" href="#incremental-configuration" title="제목 주소">¶</a></h3>
<p>증분 구성에 완벽한 유연성을 제공하기는 어렵습니다. 예를 들어, 필터와 포매터와 같은 객체는 익명이므로, 일단 구성이 설정되면, 이러한 익명 객체를 참조하여 구성을 보강할 수 없습니다.</p>
<p>또한, 일단 구성이 설정되면, 실행 시간에 로거, 처리기, 필터, 포매터의 객체 그래프를 임의로 변경해야 할 강력한 사례는 없습니다; 로거와 처리기의 상세도는 단지 수준(과, loggers에서는 전파 플래그)을 설정하여 제어할 수 있습니다. 객체 그래프를 임의로 안전하게 변경하는 것은 다중 스레드 환경에서 문제가 됩니다; 불가능하지는 않지만, 구현에 추가되는 복잡성을 상쇄할만한 가치가 없습니다.</p>
<p>따라서, 구성 딕셔너리의 <code class="docutils literal notranslate"><span class="pre">incremental</span></code> 키가 있고 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, 시스템은 <code class="docutils literal notranslate"><span class="pre">formatters</span></code>와 <code class="docutils literal notranslate"><span class="pre">filters</span></code> 항목을 완전히 무시하고 <code class="docutils literal notranslate"><span class="pre">handlers</span></code> 항목의 <code class="docutils literal notranslate"><span class="pre">level</span></code> 설정과 <code class="docutils literal notranslate"><span class="pre">loggers</span></code>와 <code class="docutils literal notranslate"><span class="pre">root</span></code> 항목의 <code class="docutils literal notranslate"><span class="pre">level</span></code>과 <code class="docutils literal notranslate"><span class="pre">propagate</span></code> 설정만 처리합니다.</p>
<p>구성 딕셔너리의 값을 사용하면 구성을 피클 된 딕셔너리의 형태로 네트워크를 통해 소켓 리스너로 전송할 수 있습니다. 따라서, 장기 실행 응용 프로그램의 로깅 상세도는 응용 프로그램을 중지하고 다시 시작할 필요 없이 도중에 변경될 수 있습니다.</p>
</div>
<div class="section" id="object-connections">
<span id="logging-config-dict-connections"></span><h3>객체 연결<a class="headerlink" href="#object-connections" title="제목 주소">¶</a></h3>
<p>스키마는 객체 그래프에서 서로 연결된 로깅 객체 집합(로거, 처리기, 포매터, 필터)을 기술합니다. 따라서, 스키마는 객체 간의 연결을 표현할 필요가 있습니다. 예를 들어, 일단 구성되면, 특정 로거가 특정 처리기에 연결된다고 합시다. 이 토론의 목적을 위해, 둘 간의 연결에서 로거는 소스를, 처리기는 대상(destination)을 나타낸다고 할 수 있습니다. 물론 구성된 객체에서 이것은 처리기에 대한 참조를 갖는 로거로 표현됩니다. 구성 딕셔너리에서, 각 대상 객체에 명확하게 식별하는 id를 부여한 다음, 소스 객체의 구성에서 그 id를 사용하여, 소스와 그 id를 갖는 대상 객체 사이에 연결이 있음을 나타냅니다.</p>
<p>그래서, 예를 들어, 다음 YAML 조각을 고려해보십시오:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">formatters</span><span class="p">:</span>
  <span class="nt">brief</span><span class="p">:</span>
    <span class="c1"># id &#39;brief&#39;인 포매터 구성이 여기에 옵니다</span>
  <span class="nt">precise</span><span class="p">:</span>
    <span class="c1"># id &#39;precise&#39;인 포매터 구성이 여기에 옵니다</span>
<span class="nt">handlers</span><span class="p">:</span>
  <span class="nt">h1</span><span class="p">:</span> <span class="c1">#이것은 id입니다</span>
   <span class="c1"># id &#39;h1&#39;인 처리기 구성이 여기에 옵니다</span>
   <span class="nt">formatter</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">brief</span>
  <span class="nt">h2</span><span class="p">:</span> <span class="c1">#이것은 다른 id입니다.</span>
   <span class="c1"># id &#39;h2&#39;인 처리기 구성이 여기에 옵니다</span>
   <span class="nt">formatter</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">precise</span>
<span class="nt">loggers</span><span class="p">:</span>
  <span class="nt">foo.bar.baz</span><span class="p">:</span>
    <span class="c1"># 로거 &#39;foo.bar.baz&#39;의 다른 구성</span>
    <span class="nt">handlers</span><span class="p">:</span> <span class="p p-Indicator">[</span><span class="nv">h1</span><span class="p p-Indicator">,</span> <span class="nv">h2</span><span class="p p-Indicator">]</span>
</pre></div>
</div>
<p>(참고: 딕셔너리에 해당하는 파이썬 소스 형식보다 약간 더 읽기 쉬우므로 여기에서 YAML을 사용했습니다.)</p>
<p>로거의 id는 로거로의 참조를 얻기 위해서 프로그램적으로 사용되는 로거 이름입니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>. 포매터와 필터의 id는 임의의 문자열 값(가령 위의 <code class="docutils literal notranslate"><span class="pre">brief</span></code>, <code class="docutils literal notranslate"><span class="pre">precise</span></code>)이 될 수 있으며, 일시적이므로 구성 딕셔너리 처리에만 의미가 있고 객체 간의 연결을 결정하는 데 사용되며, 구성 호출이 완료된 후에는 어디에도 남아있지 않습니다.</p>
<p>위의 조각은 <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>라는 로거에 두 개의 처리기가 연결되어 있어야 하며, 이 처리기들은 처리기 id <code class="docutils literal notranslate"><span class="pre">h1</span></code>과 <code class="docutils literal notranslate"><span class="pre">h2``에</span> <span class="pre">의해</span> <span class="pre">기술됩니다.</span> <span class="pre">``h1</span></code>의 포매터는 id <code class="docutils literal notranslate"><span class="pre">brief</span></code>로 기술되는 것이고, <code class="docutils literal notranslate"><span class="pre">h2</span></code>의 포매터는 id <code class="docutils literal notranslate"><span class="pre">precise</span></code>로 기술되는 것입니다.</p>
</div>
<div class="section" id="user-defined-objects">
<span id="logging-config-dict-userdef"></span><h3>사용자 정의 객체<a class="headerlink" href="#user-defined-objects" title="제목 주소">¶</a></h3>
<p>스키마는 처리기, 필터 및 포매터에 대한 사용자 정의 객체를 지원합니다. (로거에는 인스턴스마다 다른 형이 필요하지 않으므로, 이 구성 스키마에는 사용자 정의 로거 클래스에 대한 지원이 없습니다.)</p>
<p>구성할 객체는 구성을 자세히 설명하는 딕셔너리로 시술됩니다. 어떤 곳에서는, 로깅 시스템이 객체를 어떻게 인스턴스화할지 문맥으로부터 추측할 수 있지만, 사용자 정의 객체를 인스턴스화 해야 할 때, 시스템은 이를 수행하는 방법을 알 수 없습니다. 사용자 정의 객체 인스턴스화를 위한 완벽한 유연성을 제공하기 위해, 사용자는 '팩토리'를 제공해야 하는데, 구성 딕셔너리로 호출되고 인스턴스화 된 객체를 반환하는 콜러블입니다. 이것은 특수키 <code class="docutils literal notranslate"><span class="pre">'()'</span></code>로 제공되는 팩토리로의 절대적 임포트 경로로 표시됩니다. 다음은 구체적인 예입니다:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">formatters</span><span class="p">:</span>
  <span class="nt">brief</span><span class="p">:</span>
    <span class="nt">format</span><span class="p">:</span> <span class="s">&#39;%(message)s&#39;</span>
  <span class="nt">default</span><span class="p">:</span>
    <span class="nt">format</span><span class="p">:</span> <span class="s">&#39;%(asctime)s</span><span class="nv"> </span><span class="s">%(levelname)-8s</span><span class="nv"> </span><span class="s">%(name)-15s</span><span class="nv"> </span><span class="s">%(message)s&#39;</span>
    <span class="nt">datefmt</span><span class="p">:</span> <span class="s">&#39;%Y-%m-%d</span><span class="nv"> </span><span class="s">%H:%M:%S&#39;</span>
  <span class="nt">custom</span><span class="p">:</span>
      <span class="nt">()</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">my.package.customFormatterFactory</span>
      <span class="nt">bar</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">baz</span>
      <span class="nt">spam</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">99.9</span>
      <span class="nt">answer</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">42</span>
</pre></div>
</div>
<p>위의 YAML 조각은 세 가지 포매터를 정의합니다. 첫 번째(id <code class="docutils literal notranslate"><span class="pre">brief</span></code>)는 지정된 포맷 문자열을 갖는 표준 <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Formatter</span></code></a> 인스턴스입니다. 두 번째(id <code class="docutils literal notranslate"><span class="pre">default</span></code>)는 더 긴 포맷을 가지며 명시적으로 시간 포맷을 정의하기도 하고, 이 두 포맷 문자열로 초기화된 <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Formatter</span></code></a>가 됩니다. 파이썬 소스 형식으로 표시하면, <code class="docutils literal notranslate"><span class="pre">brief</span></code>와 <code class="docutils literal notranslate"><span class="pre">default</span></code> 포매터는 각각 다음과 같은 구성 서브 딕셔너리를 갖습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s1">&#39;format&#39;</span> <span class="p">:</span> <span class="s1">&#39;</span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>그리고:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s1">&#39;format&#39;</span> <span class="p">:</span> <span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> </span><span class="si">%(levelname)-8s</span><span class="s1"> </span><span class="si">%(name)-15s</span><span class="s1"> </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">,</span>
  <span class="s1">&#39;datefmt&#39;</span> <span class="p">:</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>그리고, 이 딕셔너리에는 특수키 <code class="docutils literal notranslate"><span class="pre">'()'</span></code>가 포함되어 있지 않으므로, 문맥에서 인스턴스가 추론됩니다: 결과적으로, 표준 <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Formatter</span></code></a> 인스턴스가 만들어집니다. 세 번째 포매터(id <code class="docutils literal notranslate"><span class="pre">custom</span></code>)에 대한 구성 서브 딕셔너리는 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s1">&#39;()&#39;</span> <span class="p">:</span> <span class="s1">&#39;my.package.customFormatterFactory&#39;</span><span class="p">,</span>
  <span class="s1">&#39;bar&#39;</span> <span class="p">:</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span>
  <span class="s1">&#39;spam&#39;</span> <span class="p">:</span> <span class="mf">99.9</span><span class="p">,</span>
  <span class="s1">&#39;answer&#39;</span> <span class="p">:</span> <span class="mi">42</span>
<span class="p">}</span>
</pre></div>
</div>
<p>여기에는 특수키 <code class="docutils literal notranslate"><span class="pre">'()'</span></code>가 포함되어 있는데, 사용자 정의 인스턴스가 필요하다는 뜻입니다. 이때, 지정된 팩토리 콜러블이 사용됩니다. 그것이 실제 콜러블이면 직접 사용됩니다 - 그렇지 않고, (예에서와같이) 문자열을 지정하면 일반적인 임포트 메커니즘을 사용하여 실제 콜러블을 얻습니다. 콜러블은 구성 서브 딕셔너리의 <strong>나머지</strong> 항목을 키워드 인자로 호출됩니다. 위의 예제에서, id가 <code class="docutils literal notranslate"><span class="pre">custom</span></code>인 포매터는 다음과 같은 호출이 반환한다고 가정합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">my</span><span class="o">.</span><span class="n">package</span><span class="o">.</span><span class="n">customFormatterFactory</span><span class="p">(</span><span class="n">bar</span><span class="o">=</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="n">spam</span><span class="o">=</span><span class="mf">99.9</span><span class="p">,</span> <span class="n">answer</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">'()'</span></code> 키가 유효한 키워드 매개 변수 이름이 아니라서 특수키로 사용되었습니다. 그러므로 호출에 사용되는 키워드 인자의 이름과 충돌하지 않습니다. <code class="docutils literal notranslate"><span class="pre">'()'</span></code>는 해당 값이 콜러블이라는 표시로도 기능합니다.</p>
</div>
<div class="section" id="access-to-external-objects">
<span id="logging-config-dict-externalobj"></span><h3>외부 객체에 대한 액세스<a class="headerlink" href="#access-to-external-objects" title="제목 주소">¶</a></h3>
<p>구성에서 구성 외부의 객체를 참조해야 하는 경우가 있습니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>. 구성 딕셔너리가 파이썬 코드를 사용하여 만들어질 때는 간단하지만, 구성이 텍스트 파일(예를 들어, JSON, YAML)을 통해 제공될 때 문제가 발생합니다. 텍스트 파일에서는, <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>를 리터럴 문자열 <code class="docutils literal notranslate"><span class="pre">'sys.stderr'</span></code>과 구별하는 표준 방법이 없습니다. 이 구별을 쉽게 하기 위해, 구성 시스템은 문자열 값에서 특정 접두사를 찾아 특수하게 처리합니다. 예를 들어, 리터럴 문자열 <code class="docutils literal notranslate"><span class="pre">'ext://sys.stderr'</span></code>이 구성에서 값으로 제공되면, <code class="docutils literal notranslate"><span class="pre">ext://</span></code>는 제거되고 값의 나머지 부분을 일반 임포트 메커니즘을 사용하여 처리합니다.</p>
<p>이러한 접두사의 처리는 프로토콜 처리와 유사한 방식으로 수행됩니다: 정규식 <code class="docutils literal notranslate"><span class="pre">^(?P&lt;prefix&gt;[a-z]+)://(?P&lt;suffix&gt;.*)$</span></code>와 일치하는 접두사를 찾는 일반 메커니즘이 있습니다. <code class="docutils literal notranslate"><span class="pre">prefix</span></code>가 인식되면 <code class="docutils literal notranslate"><span class="pre">suffix</span></code>는 접두사 종속적 방식으로 처리되고 처리 결과가 문자열 값을 대체합니다. 접두사가 인식되지 않으면, 문자열 값은 그대로 남습니다.</p>
</div>
<div class="section" id="access-to-internal-objects">
<span id="logging-config-dict-internalobj"></span><h3>내부 객체에 대한 액세스<a class="headerlink" href="#access-to-internal-objects" title="제목 주소">¶</a></h3>
<p>외부 객체뿐만 아니라, 때로 구성에 있는 객체를 참조할 필요도 있습니다. 이것은 구성 시스템이 알고 있는 것들에 대해 묵시적으로 수행됩니다. 예를 들어, 로거나 처리기의 <code class="docutils literal notranslate"><span class="pre">level</span></code>에 대한 문자열 값 <code class="docutils literal notranslate"><span class="pre">'DEBUG'</span></code>은 자동으로 값 <code class="docutils literal notranslate"><span class="pre">logging.DEBUG</span></code>으로 변환되고, <code class="docutils literal notranslate"><span class="pre">handlers</span></code>, <code class="docutils literal notranslate"><span class="pre">filters</span></code> 및 <code class="docutils literal notranslate"><span class="pre">formatter</span></code> 항목은 객체 id를 받아서 적절한 대상 객체로 결정합니다.</p>
<p>하지만, <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 모듈에 알려지지 않은 사용자 정의 객체에는 더욱 일반적인 메커니즘이 필요합니다. 예를 들어, 위임할 다른 처리기인 <code class="docutils literal notranslate"><span class="pre">target</span></code> 인자를 취하는 <a class="reference internal" href="logging.handlers.html#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.handlers.MemoryHandler</span></code></a>를 고려해봅시다. 시스템이 이미 이 클래스에 대해 알고 있으므로, 구성에서, 주어진 <code class="docutils literal notranslate"><span class="pre">target</span></code>은 단지 관련 target 처리기의 객체 id이기만 하면 되며, 시스템은 id로부터 처리기를 결정합니다. 그러나 사용자가 <code class="docutils literal notranslate"><span class="pre">alternate</span></code> 처리기를 갖는 <code class="docutils literal notranslate"><span class="pre">my.package.MyHandler</span></code>를 정의하면, 구성 시스템은 <code class="docutils literal notranslate"><span class="pre">alternate</span></code>가 처리기를 참조한다는 것을 알 수 없습니다. 이 문제를 해결하기 위해, 일반 결정 시스템은 사용자가 다음과 같이 지정할 수 있게 합니다:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">handlers</span><span class="p">:</span>
  <span class="nt">file</span><span class="p">:</span>
    <span class="c1"># configuration of file handler goes here</span>

  <span class="nt">custom</span><span class="p">:</span>
    <span class="nt">()</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">my.package.MyHandler</span>
    <span class="nt">alternate</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">cfg://handlers.file</span>
</pre></div>
</div>
<p>리터럴 문자열 <code class="docutils literal notranslate"><span class="pre">'cfg://handlers.file'</span></code>은 <code class="docutils literal notranslate"><span class="pre">ext://</span></code> 접두사가 있는 문자열과 비슷하게 결정되지만, 임포트 이름 공간이 아닌 구성 자체를 조회합니다. 이 메커니즘은 <code class="docutils literal notranslate"><span class="pre">str.format</span></code>에서 제공하는 것과 유사한 방식으로 점이나 인덱스로 액세스하는 것을 허락합니다. 따라서, 구성에서 다음과 같은 조각이 주어질 때:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">handlers</span><span class="p">:</span>
  <span class="nt">email</span><span class="p">:</span>
    <span class="nt">class</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">logging.handlers.SMTPHandler</span>
    <span class="nt">mailhost</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">localhost</span>
    <span class="nt">fromaddr</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">my_app@domain.tld</span>
    <span class="nt">toaddrs</span><span class="p">:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">support_team@domain.tld</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">dev_team@domain.tld</span>
    <span class="nt">subject</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Houston, we have a problem.</span>
</pre></div>
</div>
<p>문자열 <code class="docutils literal notranslate"><span class="pre">'cfg://handlers'</span></code>는 키 <code class="docutils literal notranslate"><span class="pre">handlers</span></code>의 딕셔너리로 결정되고, 문자열 <code class="docutils literal notranslate"><span class="pre">'cfg://handlers.email</span></code>은 <code class="docutils literal notranslate"><span class="pre">handlers</span></code> 딕셔너리에 있는 키 <code class="docutils literal notranslate"><span class="pre">email</span></code>의 딕셔너리로 결정됩니다, 등등. 문자열 <code class="docutils literal notranslate"><span class="pre">'cfg://handlers.email.toaddrs[1]</span></code>은 <code class="docutils literal notranslate"><span class="pre">'dev_team.domain.tld'</span></code>로 결정되고 문자열 <code class="docutils literal notranslate"><span class="pre">'cfg://handlers.email.toaddrs[0]'</span></code>은 값 <code class="docutils literal notranslate"><span class="pre">'support_team&#64;domain.tld'</span></code>로 결정됩니다. <code class="docutils literal notranslate"><span class="pre">subject</span></code> 값은 <code class="docutils literal notranslate"><span class="pre">'cfg://handlers.email.subject'</span></code>나 동등하게 <code class="docutils literal notranslate"><span class="pre">'cfg://handlers.email[subject]'</span></code>를 사용하여 액세스할 수 있습니다. 후자의 형식은 키에 공백이나 영숫자가 아닌 문자가 포함되어있을 때만 필요합니다. 인덱스값이 십진수로만 구성되면, 해당 정숫값을 사용하여 액세스가 시도되고, 필요하면 문자열 값으로 다시 시도합니다.</p>
<p>문자열 <code class="docutils literal notranslate"><span class="pre">cfg://handlers.myhandler.mykey.123</span></code>이 주어지면, <code class="docutils literal notranslate"><span class="pre">config_dict['handlers']['myhandler']['mykey']['123']</span></code>으로 변환됩니다. 문자열이 <code class="docutils literal notranslate"><span class="pre">cfg://handlers.myhandler.mykey[123]</span></code>로 지정되면, 시스템은 <code class="docutils literal notranslate"><span class="pre">config_dict['handlers']['myhandler']['mykey'][123]</span></code>에서 값을 가져오려고 시도하고, 실패하면 <code class="docutils literal notranslate"><span class="pre">config_dict['handlers']['myhandler']['mykey']['123']</span></code>으로 폴백합니다.</p>
</div>
<div class="section" id="import-resolution-and-custom-importers">
<span id="logging-import-resolution"></span><h3>임포트 결정과 사용자 정의 임포터<a class="headerlink" href="#import-resolution-and-custom-importers" title="제목 주소">¶</a></h3>
<p>임포트 결정은, 기본적으로, 임포트 하는데 내장 <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수를 사용합니다. 이것을 자신의 임포트 메커니즘으로 바꾸고 싶을 수 있습니다: 그렇다면, <code class="xref py py-class docutils literal notranslate"><span class="pre">DictConfigurator</span></code>나 그것의 슈퍼 클래스(<code class="xref py py-class docutils literal notranslate"><span class="pre">BaseConfigurator</span></code> 클래스)의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">importer</span></code> 어트리뷰트를 바꿀 수 있습니다. 그러나, 함수가 클래스에서 디스크립터를 통해 액세스 되는 방식 때문에 주의해야 합니다. 파이썬 콜러블을 사용하여 임포트를 수행하려고 하고, 인스턴스 수준이 아닌 클래스 수준에서 정의하려고 한다면, <a class="reference internal" href="functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>로 감쌀 필요가 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">importlib</span> <span class="k">import</span> <span class="n">import_module</span>
<span class="kn">from</span> <span class="nn">logging.config</span> <span class="k">import</span> <span class="n">BaseConfigurator</span>

<span class="n">BaseConfigurator</span><span class="o">.</span><span class="n">importer</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">import_module</span><span class="p">)</span>
</pre></div>
</div>
<p>구성자 <em>instance</em>에서 임포트 콜러블을 설정한다면, <a class="reference internal" href="functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>로 감쌀 필요가 없습니다.</p>
</div>
</div>
<div class="section" id="configuration-file-format">
<span id="logging-config-fileformat"></span><h2>구성 파일 형식<a class="headerlink" href="#configuration-file-format" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a>이 이해하는 구성 파일 형식은 <a class="reference internal" href="configparser.html#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">configparser</span></code></a> 기능을 기반으로 합니다. 파일에는 <code class="docutils literal notranslate"><span class="pre">[loggers]</span></code>, <code class="docutils literal notranslate"><span class="pre">[handlers]</span></code> 및 <code class="docutils literal notranslate"><span class="pre">[formatters]</span></code>라는 섹션이 있어야 하며, 이 섹션에서는 파일에 정의된 각 유형의 엔티티를 이름으로 식별합니다. 이러한 엔티티마다 해당 엔티티 구성 방법을 식별하는 별도의 섹션이 있습니다. 따라서, <code class="docutils literal notranslate"><span class="pre">[loggers]</span></code> 섹션에서 <code class="docutils literal notranslate"><span class="pre">log01</span></code>이라고 이름 붙은 로거에 대해, 관련 구성 세부 사항은 <code class="docutils literal notranslate"><span class="pre">[logger_log01]</span></code> 섹션에 담깁니다. 마찬가지로, <code class="docutils literal notranslate"><span class="pre">[handlers]</span></code> 섹션에서 <code class="docutils literal notranslate"><span class="pre">hand01</span></code>이라고 부르는 처리기는 <code class="docutils literal notranslate"><span class="pre">[handler_hand01]</span></code>이라는 섹션에 구성이 담기고, <code class="docutils literal notranslate"><span class="pre">[formatters]</span></code> 섹션에서 <code class="docutils literal notranslate"><span class="pre">form01</span></code>이라고 부르는 포매터는 <code class="docutils literal notranslate"><span class="pre">[formatter_form01]</span></code>이라는 섹션에서 구성이 지정됩니다. 루트 로거 구성은 <code class="docutils literal notranslate"><span class="pre">[logger_root]</span></code>라는 섹션에서 지정해야 합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a> API는 <a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a> API보다 오래되었으며 로깅의 특정 측면을 다루는 기능을 제공하지 않습니다. 예를 들어, <a class="reference internal" href="#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a>를 사용해서는 간단한 정수 수준을 넘어서는 메시지 필터링을 제공하는 <a class="reference internal" href="logging.html#logging.Filter" title="logging.Filter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Filter</span></code></a> 객체를 구성할 수 없습니다. 로깅 구성에 <a class="reference internal" href="logging.html#logging.Filter" title="logging.Filter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Filter</span></code></a> 인스턴스가 필요하면, <a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a>를 사용해야 합니다. 향후 구성 기능의 개선은 <a class="reference internal" href="#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a>에 추가될 것임에 유의하십시오. 따라서, 편리할 때 이 새로운 API로 전환하는 것을 고려해 볼 가치가 있습니다.</p>
</div>
<p>파일에 있는 이 절의 예는 아래에 나와 있습니다.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[loggers]</span>
<span class="na">keys</span><span class="o">=</span><span class="s">root,log02,log03,log04,log05,log06,log07</span>

<span class="k">[handlers]</span>
<span class="na">keys</span><span class="o">=</span><span class="s">hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09</span>

<span class="k">[formatters]</span>
<span class="na">keys</span><span class="o">=</span><span class="s">form01,form02,form03,form04,form05,form06,form07,form08,form09</span>
</pre></div>
</div>
<p>루트 로거는 수준과 처리기 목록을 지정해야 합니다. 루트 로거 섹션의 예가 아래에 나와 있습니다.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[logger_root]</span>
<span class="na">level</span><span class="o">=</span><span class="s">NOTSET</span>
<span class="na">handlers</span><span class="o">=</span><span class="s">hand01</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">level</span></code> 항목은 <code class="docutils literal notranslate"><span class="pre">DEBUG,</span> <span class="pre">INFO,</span> <span class="pre">WARNING,</span> <span class="pre">ERROR,</span> <span class="pre">CRITICAL</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">NOTSET</span></code> 중 하나일 수 있습니다. 루트 로거에서만, <code class="docutils literal notranslate"><span class="pre">NOTSET</span></code>는 모든 메시지가 로그 됨을 의미합니다. 수준 값은 <code class="docutils literal notranslate"><span class="pre">logging</span></code> 패키지의 이름 공간 컨텍스트에서 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">handlers</span></code> 항목은 <code class="docutils literal notranslate"><span class="pre">[handlers]</span></code> 섹션에 나타나야 하는 처리기 이름의 쉼표로 구분된 목록입니다. 이 이름들은 <code class="docutils literal notranslate"><span class="pre">[handlers]</span></code> 섹션에 나타나야 하며, 구성 파일에 해당 섹션이 있어야 합니다.</p>
<p>루트 로거가 아닌 로거의 경우, 몇 가지 추가 정보가 필요합니다. 이것은 다음 예제가 보여줍니다.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[logger_parser]</span>
<span class="na">level</span><span class="o">=</span><span class="s">DEBUG</span>
<span class="na">handlers</span><span class="o">=</span><span class="s">hand01</span>
<span class="na">propagate</span><span class="o">=</span><span class="s">1</span>
<span class="na">qualname</span><span class="o">=</span><span class="s">compiler.parser</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">level</span></code>과 <code class="docutils literal notranslate"><span class="pre">handlers</span></code> 항목은 루트 로거에서처럼 해석됩니다. 단, 루트가 아닌 로거의 수준이 <code class="docutils literal notranslate"><span class="pre">NOTSET</span></code>로 지정되면, 시스템은 로거의 유효 수준을 판별하기 위해 상위 계층 로거를 참조합니다. <code class="docutils literal notranslate"><span class="pre">propagate</span></code> 항목은 메시지가 이 로거로부터 더 높은 로거 계층의 처리기로 전파되어야 함을 나타내려면 1로 설정되고, 메시지가 계층 위의 처리기로 전달되지 <strong>않음</strong>을 나타내려면 0으로 설정됩니다. <code class="docutils literal notranslate"><span class="pre">qualname</span></code> 항목은 로거의 계층적 채널 이름, 즉 응용 프로그램에서 로거를 가져오는 데 사용되는 이름입니다.</p>
<p>처리기 구성을 지정하는 섹션은 다음과 같이 예시됩니다.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[handler_hand01]</span>
<span class="na">class</span><span class="o">=</span><span class="s">StreamHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">NOTSET</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form01</span>
<span class="na">args</span><span class="o">=</span><span class="s">(sys.stdout,)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">class</span></code> 항목은 (<code class="docutils literal notranslate"><span class="pre">logging</span></code> 패키지의 이름 공간에서 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>로 결정되는) 처리기의 클래스를 나타냅니다. <code class="docutils literal notranslate"><span class="pre">level</span></code>은 로거에서처럼 해석되며, <code class="docutils literal notranslate"><span class="pre">NOTSET</span></code>은 '모든 것을 로깅'을 의미합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">formatter</span></code> 항목은 이 처리기의 포매터의 키 이름을 나타냅니다. 비어 있으면, 기본 포매터(<code class="docutils literal notranslate"><span class="pre">logging._defaultFormatter</span></code>)가 사용됩니다. 이름이 지정되면, <code class="docutils literal notranslate"><span class="pre">[formatters]</span></code> 섹션에 나타나야 하며 구성 파일에 해당 섹션이 있어야 합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">args</span></code> 항목은, <code class="docutils literal notranslate"><span class="pre">logging</span></code> 패키지의 이름 공간 컨텍스트에서 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>될 때, 처리기 클래스의 생성자에 대한 인자 목록입니다. 일반적인 항목 작성 방법을 보려면, 관련 처리기의 생성자나 아래 예제를 참조하십시오. 제공되지 않으면, 기본값은 <code class="docutils literal notranslate"><span class="pre">()</span></code>입니다.</p>
<p>선택적 <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> 항목은, <code class="docutils literal notranslate"><span class="pre">logging</span></code> 패키지의 이름 공간 컨텍스트에서 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>될 때, 처리기 클래스의 생성자에 대한 키워드 인자 딕셔너리입니다. 제공되지 않으면, 기본값은 <code class="docutils literal notranslate"><span class="pre">{}</span></code>입니다.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[handler_hand02]</span>
<span class="na">class</span><span class="o">=</span><span class="s">FileHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">DEBUG</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form02</span>
<span class="na">args</span><span class="o">=</span><span class="s">(&#39;python.log&#39;, &#39;w&#39;)</span>

<span class="k">[handler_hand03]</span>
<span class="na">class</span><span class="o">=</span><span class="s">handlers.SocketHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">INFO</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form03</span>
<span class="na">args</span><span class="o">=</span><span class="s">(&#39;localhost&#39;, handlers.DEFAULT_TCP_LOGGING_PORT)</span>

<span class="k">[handler_hand04]</span>
<span class="na">class</span><span class="o">=</span><span class="s">handlers.DatagramHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">WARN</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form04</span>
<span class="na">args</span><span class="o">=</span><span class="s">(&#39;localhost&#39;, handlers.DEFAULT_UDP_LOGGING_PORT)</span>

<span class="k">[handler_hand05]</span>
<span class="na">class</span><span class="o">=</span><span class="s">handlers.SysLogHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">ERROR</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form05</span>
<span class="na">args</span><span class="o">=</span><span class="s">((&#39;localhost&#39;, handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)</span>

<span class="k">[handler_hand06]</span>
<span class="na">class</span><span class="o">=</span><span class="s">handlers.NTEventLogHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">CRITICAL</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form06</span>
<span class="na">args</span><span class="o">=</span><span class="s">(&#39;Python Application&#39;, &#39;&#39;, &#39;Application&#39;)</span>

<span class="k">[handler_hand07]</span>
<span class="na">class</span><span class="o">=</span><span class="s">handlers.SMTPHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">WARN</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form07</span>
<span class="na">args</span><span class="o">=</span><span class="s">(&#39;localhost&#39;, &#39;from@abc&#39;, [&#39;user1@abc&#39;, &#39;user2@xyz&#39;], &#39;Logger Subject&#39;)</span>
<span class="na">kwargs</span><span class="o">=</span><span class="s">{&#39;timeout&#39;: 10.0}</span>

<span class="k">[handler_hand08]</span>
<span class="na">class</span><span class="o">=</span><span class="s">handlers.MemoryHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">NOTSET</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form08</span>
<span class="na">target</span><span class="o">=</span>
<span class="na">args</span><span class="o">=</span><span class="s">(10, ERROR)</span>

<span class="k">[handler_hand09]</span>
<span class="na">class</span><span class="o">=</span><span class="s">handlers.HTTPHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">NOTSET</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">form09</span>
<span class="na">args</span><span class="o">=</span><span class="s">(&#39;localhost:9022&#39;, &#39;/log&#39;, &#39;GET&#39;)</span>
<span class="na">kwargs</span><span class="o">=</span><span class="s">{&#39;secure&#39;: True}</span>
</pre></div>
</div>
<p>포매터 구성을 지정하는 섹션은 다음과 같이 예시됩니다.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[formatter_form01]</span>
<span class="na">format</span><span class="o">=</span><span class="s">F1 %(asctime)s %(levelname)s %(message)s</span>
<span class="na">datefmt</span><span class="o">=</span>
<span class="na">class</span><span class="o">=</span><span class="s">logging.Formatter</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">format</span></code> 항목은 전체 포맷 문자열이고, <code class="docutils literal notranslate"><span class="pre">datefmt</span></code> 항목은 <code class="xref py py-func docutils literal notranslate"><span class="pre">strftime()</span></code> 호환 날짜/시간 포맷 문자열입니다. 비어있으면, 패키지는 날짜 포맷 문자열 <code class="docutils literal notranslate"><span class="pre">'%Y-%m-%d</span> <span class="pre">%H:%M:%S'</span></code>를 지정하는 것과 거의 동등한 것으로 대체합니다. 이 포맷은 밀리 초도 지정하는데, 위의 포맷 문자열을 사용한 결과에 쉼표 구분 기호와 함께 추가됩니다. 이 포맷의 예제 시간은 <code class="docutils literal notranslate"><span class="pre">2003-01-23</span> <span class="pre">00:29:50,411</span></code>입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">class</span></code> 항목은 선택적입니다. 포매터 클래스의 이름을 나타냅니다 (점으로 구분된 모듈과 클래스 이름). 이 옵션은 <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 서브 클래스를 인스턴스화하는 데 유용합니다. <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a>의 서브 클래스는 확장 또는 압축 형식으로 예외 트래이스백을 표시할 수 있습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>위에서 설명한 대로 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>를 사용하기 때문에, <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a>을 사용하여 소켓을 통해 구성을 보내고 받을 때 발생할 수 있는 잠재적인 보안 위험이 있습니다. 위험은 상호 신뢰가 없는 여러 사용자가 같은 기계에서 코드를 실행할 때로 제한됩니다; 자세한 내용은 <a class="reference internal" href="#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code></a> 설명서를 참조하십시오.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt>모듈 <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a></dt><dd><p>logging 모듈에 관한 API 레퍼런스.</p>
</dd>
<dt>모듈 <a class="reference internal" href="logging.handlers.html#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a></dt><dd><p>logging 모듈에 포함된 유용한 처리기.</p>
</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code> --- 로깅 구성</a><ul>
<li><a class="reference internal" href="#configuration-functions">구성 함수</a></li>
<li><a class="reference internal" href="#configuration-dictionary-schema">구성 딕셔너리 스키마</a><ul>
<li><a class="reference internal" href="#dictionary-schema-details">딕셔너리 스키마 세부사항</a></li>
<li><a class="reference internal" href="#incremental-configuration">증분 구성</a></li>
<li><a class="reference internal" href="#object-connections">객체 연결</a></li>
<li><a class="reference internal" href="#user-defined-objects">사용자 정의 객체</a></li>
<li><a class="reference internal" href="#access-to-external-objects">외부 객체에 대한 액세스</a></li>
<li><a class="reference internal" href="#access-to-internal-objects">내부 객체에 대한 액세스</a></li>
<li><a class="reference internal" href="#import-resolution-and-custom-importers">임포트 결정과 사용자 정의 임포터</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configuration-file-format">구성 파일 형식</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="logging.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code> --- 파이썬 로깅 시설</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="logging.handlers.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code> --- 로깅 처리기</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="logging.handlers.html" title="logging.handlers --- 로깅 처리기"
             >다음</a> |</li>
        <li class="right" >
          <a href="logging.html" title="logging --- 파이썬 로깅 시설"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >일반 운영 체제 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>