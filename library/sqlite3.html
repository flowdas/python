
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>sqlite3 --- SQLite 데이터베이스용 DB-API 2.0 인터페이스 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="데이터 압축 및 보관" href="archiving.html" />
    <link rel="prev" title="dbm --- 유닉스 &#34;데이터베이스&#34; 인터페이스" href="dbm.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/sqlite3.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="archiving.html" title="데이터 압축 및 보관"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="dbm.html" title="dbm --- 유닉스 &#34;데이터베이스&#34; 인터페이스"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="persistence.html" accesskey="U">데이터 지속성</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-sqlite3">
<span id="sqlite3-db-api-2-0-interface-for-sqlite-databases"></span><h1><a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> --- SQLite 데이터베이스용 DB-API 2.0 인터페이스<a class="headerlink" href="#module-sqlite3" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/sqlite3/">Lib/sqlite3/</a></p>
<hr class="docutils" />
<p>SQLite는 별도의 서버 프로세스가 필요 없고 SQL 질의 언어의 비표준 변형을 사용하여 데이터베이스에 액세스할 수 있는 경량 디스크 기반 데이터베이스를 제공하는 C 라이브러리입니다. 일부 응용 프로그램은 내부 데이터 저장을 위해 SQLite를 사용할 수 있습니다. SQLite를 사용하여 응용 프로그램을 프로토타입 한 다음 PostgreSQL 이나 Oracle과 같은 더 큰 데이터베이스로 코드를 이식할 수도 있습니다.</p>
<p>sqlite3 모듈은 Gerhard Häring이 썼습니다. <span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0249"><strong>PEP 249</strong></a>에서 설명하는 DB-API 2.0 명세를 준수하는 SQL 인터페이스를 제공합니다.</p>
<p>모듈을 사용하려면, 먼저 데이터베이스를 나타내는 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 객체를 만들어야 합니다. 여기서 데이터는 <code class="file docutils literal notranslate"><span class="pre">example.db</span></code> 파일에 저장됩니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;example.db&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>특수 이름 <code class="docutils literal notranslate"><span class="pre">:memory:</span></code>를 제공하여 램에 데이터베이스를 만들 수도 있습니다.</p>
<p>일단 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>를 얻으면, <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 객체를 만들고 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> 메서드를 호출하여 SQL 명령을 수행할 수 있습니다.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="c1"># 테이블을 만듭니다</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;CREATE TABLE stocks</span>
<span class="s1">             (date text, trans text, symbol text, qty real, price real)&#39;&#39;&#39;</span><span class="p">)</span>

<span class="c1"># 데이터 행을 삽입합니다</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;INSERT INTO stocks VALUES (&#39;2006-01-05&#39;,&#39;BUY&#39;,&#39;RHAT&#39;,100,35.14)&quot;</span><span class="p">)</span>

<span class="c1"># 변경을 저장(commit)합니다</span>
<span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<span class="c1"># 작업이 끝나면 연결을 닫을 수도 있습니다.</span>
<span class="c1"># 모든 변경 사항이 커밋되었음을 확인하십시오. 그렇지 않으면 잃어버립니다.</span>
<span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>저장한 데이터는 영구적이며 이후 세션에서 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;example.db&#39;</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
</pre></div>
</div>
<p>일반적으로 SQL 연산은 파이썬 변수의 값을 사용해야 합니다. 파이썬의 문자열 연산을 사용하여 질의를 조합해서는 안 됩니다. 그렇게 하는 것은 안전하지 않기 때문입니다; 프로그램이 SQL 인젝션 공격에 취약하게 만듭니다 (잘못될 수 있는 유머러스한 예를 보려면 <a class="reference external" href="https://xkcd.com/327/">https://xkcd.com/327/</a> 를 참조하십시오).</p>
<p>대신 DB-API의 매개 변수 치환을 사용하십시오. 값을 사용하고자 할 때마다 <code class="docutils literal notranslate"><span class="pre">?</span></code>를 자리 표시자로 넣은 다음, 커서의 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> 메서드에 두 번째 인자로 값들의 튜플을 제공하십시오. (다른 데이터베이스 모듈은 다른 자리 표시자를 사용할 수 있습니다, 가령 <code class="docutils literal notranslate"><span class="pre">%s</span></code> 나 <code class="docutils literal notranslate"><span class="pre">:1</span></code>.) 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 절대로 하지 마십시오 -- 안전하지 않습니다!</span>
<span class="n">symbol</span> <span class="o">=</span> <span class="s1">&#39;RHAT&#39;</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM stocks WHERE symbol = &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">symbol</span><span class="p">)</span>

<span class="c1"># 대신 이렇게 하세요</span>
<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;RHAT&#39;</span><span class="p">,)</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;SELECT * FROM stocks WHERE symbol=?&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">fetchone</span><span class="p">())</span>

<span class="c1"># 한 번에 많은 레코드를 삽입하는 더 큰 예</span>
<span class="n">purchases</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;2006-03-28&#39;</span><span class="p">,</span> <span class="s1">&#39;BUY&#39;</span><span class="p">,</span> <span class="s1">&#39;IBM&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mf">45.00</span><span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;2006-04-05&#39;</span><span class="p">,</span> <span class="s1">&#39;BUY&#39;</span><span class="p">,</span> <span class="s1">&#39;MSFT&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mf">72.00</span><span class="p">),</span>
             <span class="p">(</span><span class="s1">&#39;2006-04-06&#39;</span><span class="p">,</span> <span class="s1">&#39;SELL&#39;</span><span class="p">,</span> <span class="s1">&#39;IBM&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mf">53.00</span><span class="p">),</span>
            <span class="p">]</span>
<span class="n">c</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s1">&#39;INSERT INTO stocks VALUES (?,?,?,?,?)&#39;</span><span class="p">,</span> <span class="n">purchases</span><span class="p">)</span>
</pre></div>
</div>
<p>SELECT 문을 실행한 후 데이터를 꺼내려면, 커서를 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a>로 취급하거나, 커서의 <a class="reference internal" href="#sqlite3.Cursor.fetchone" title="sqlite3.Cursor.fetchone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fetchone()</span></code></a> 메서드를 호출하여 일치하는 단일 행을 꺼내거나, <a class="reference internal" href="#sqlite3.Cursor.fetchall" title="sqlite3.Cursor.fetchall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fetchall()</span></code></a>를 호출하여 일치하는 행의 리스트를 가져올 수 있습니다.</p>
<p>이 예제는 이터레이터 방식을 사용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;SELECT * FROM stocks ORDER BY price&#39;</span><span class="p">):</span>
<span class="go">        print(row)</span>

<span class="go">(&#39;2006-01-05&#39;, &#39;BUY&#39;, &#39;RHAT&#39;, 100, 35.14)</span>
<span class="go">(&#39;2006-03-28&#39;, &#39;BUY&#39;, &#39;IBM&#39;, 1000, 45.0)</span>
<span class="go">(&#39;2006-04-06&#39;, &#39;SELL&#39;, &#39;IBM&#39;, 500, 53.0)</span>
<span class="go">(&#39;2006-04-05&#39;, &#39;BUY&#39;, &#39;MSFT&#39;, 1000, 72.0)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><a class="reference external" href="https://github.com/ghaering/pysqlite">https://github.com/ghaering/pysqlite</a></dt><dd><p>pysqlite 웹 페이지 -- sqlite3은 &quot;pysqlite&quot;라는 이름으로 외부에서 개발되었습니다.</p>
</dd>
<dt><a class="reference external" href="https://www.sqlite.org">https://www.sqlite.org</a></dt><dd><p>SQLite 웹 페이지; 설명서는 지원되는 SQL 언어에 대한 문법과 사용 가능한 데이터형을 설명합니다.</p>
</dd>
<dt><a class="reference external" href="https://www.w3schools.com/sql/">https://www.w3schools.com/sql/</a></dt><dd><p>SQL 문법 학습을 위한 자습서, 레퍼런스 및 예제</p>
</dd>
<dt><span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0249"><strong>PEP 249</strong></a> - 데이터베이스 API 명세 2.0</dt><dd><p>Marc-André Lemburg가 작성한 PEP.</p>
</dd>
</dl>
</div>
<div class="section" id="module-functions-and-constants">
<span id="sqlite3-module-contents"></span><h2>모듈 함수와 상수<a class="headerlink" href="#module-functions-and-constants" title="제목 주소">¶</a></h2>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>이 설명서에는 나와있지 않지만 DB-API 2.0은 세 개의 모듈 전역 상수를 정의하고 있습니다:
<code class="docutils literal notranslate"><span class="pre">apilevel</span></code>, <code class="docutils literal notranslate"><span class="pre">threadsafety</span></code>, <code class="docutils literal notranslate"><span class="pre">paramstyle</span></code>.
<a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 에는 세 상수 모두 정의되어 있습니다.</p>
</div>
<dl class="data">
<dt id="sqlite3.version">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">version</code><a class="headerlink" href="#sqlite3.version" title="정의 주소">¶</a></dt>
<dd><p>이 모듈의 버전 번호(문자열). SQLite 라이브러리의 버전이 아닙니다.</p>
</dd></dl>

<dl class="data">
<dt id="sqlite3.version_info">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">version_info</code><a class="headerlink" href="#sqlite3.version_info" title="정의 주소">¶</a></dt>
<dd><p>이 모듈의 버전 번호(정수들의 튜플). SQLite 라이브러리의 버전이 아닙니다.</p>
</dd></dl>

<dl class="data">
<dt id="sqlite3.sqlite_version">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">sqlite_version</code><a class="headerlink" href="#sqlite3.sqlite_version" title="정의 주소">¶</a></dt>
<dd><p>런타임 SQLite 라이브러리의 버전 번호(문자열).</p>
</dd></dl>

<dl class="data">
<dt id="sqlite3.sqlite_version_info">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">sqlite_version_info</code><a class="headerlink" href="#sqlite3.sqlite_version_info" title="정의 주소">¶</a></dt>
<dd><p>런타임 SQLite 라이브러리의 버전 번호(정수들의 튜플).</p>
</dd></dl>

<dl class="data">
<dt id="sqlite3.PARSE_DECLTYPES">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">PARSE_DECLTYPES</code><a class="headerlink" href="#sqlite3.PARSE_DECLTYPES" title="정의 주소">¶</a></dt>
<dd><p>이 상수는 <a class="reference internal" href="#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> 함수의 <em>detect_types</em> 매개 변수에 사용됩니다.</p>
<p>이것을 설정하면 <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈은 반환되는 각 열에 대해 선언된 형을 구문 분석합니다. 선언된 형의 첫 번째 단어를 구문 분석합니다, 즉 &quot;integer primary key&quot;에서는 &quot;integer&quot;를, &quot;number (10)&quot;에서는 &quot;number&quot;를 구문 분석합니다. 그런 다음 해당 열에 대해, 변환기 딕셔너리를 조사하고 그 형에 대해 등록된 변환기 함수를 사용합니다.</p>
</dd></dl>

<dl class="data">
<dt id="sqlite3.PARSE_COLNAMES">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">PARSE_COLNAMES</code><a class="headerlink" href="#sqlite3.PARSE_COLNAMES" title="정의 주소">¶</a></dt>
<dd><p>이 상수는 <a class="reference internal" href="#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> 함수의 <em>detect_types</em> 매개 변수에 사용됩니다.</p>
<p>이것을 설정하면 SQLite 인터페이스는 반환되는 각 열의 열 이름을 구문 분석합니다. 거기에서 [mytype] 형태의 문자열을 찾은 다음 'mytype'을 열의 형으로 결정합니다. 변환기 딕셔너리에서 'mytype' 항목을 찾은 다음 거기에 있는 변환기 함수를 사용하여 값을 반환하려고 시도합니다. <a class="reference internal" href="#sqlite3.Cursor.description" title="sqlite3.Cursor.description"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Cursor.description</span></code></a>에서 발견되는 열 이름은 형 이름을 포함하지 않습니다, 즉, SQL에서 <code class="docutils literal notranslate"><span class="pre">'as</span> <span class="pre">&quot;Expiration</span> <span class="pre">date</span> <span class="pre">[datetime]&quot;'</span></code>와 같은 것을 사용하면, 열 이름의 첫 번째 <code class="docutils literal notranslate"><span class="pre">'['</span></code>까지 모든 것을 구문 분석하고 앞에 오는 공백을 제거합니다: 열 이름은 단순히 &quot;Expiration date&quot; 가 됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="sqlite3.connect">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">connect</code><span class="sig-paren">(</span><em class="sig-param">database</em><span class="optional">[</span>, <em class="sig-param">timeout</em>, <em class="sig-param">detect_types</em>, <em class="sig-param">isolation_level</em>, <em class="sig-param">check_same_thread</em>, <em class="sig-param">factory</em>, <em class="sig-param">cached_statements</em>, <em class="sig-param">uri</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.connect" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0 이 정의하는 함수입니다. 이 함수가 반환하는 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 객체도 DB-API
2.0 이 정의합니다. 하지만 인자는 데이터베이스 종속적이고 DB-API 2.0은 어떤 매개 변수도 정의하지
않습니다. 다만 매개 변수를 정의하는 지침은 제공하고 있는데, 다음과 같은 키워드 매개 변수입니다.</p>
<ul class="simple">
<li><p><em>dsn</em> - 필수. 문자열 데이터 소스 이름.</p></li>
<li><p><em>user</em> - 선택적. 사용자 이름.</p></li>
<li><p><em>password</em> - 선택적. 암호.</p></li>
<li><p><em>host</em> - 선택적. 호스트 이름.</p></li>
<li><p><em>database</em> - 선택적. 데이터베이스 이름.</p></li>
</ul>
<p><a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 는 이 중 <em>database</em> 만 사용하고 있습니다만, 실제 의미는 이 지침의 <em>dsn</em> 에
해당합니다.</p>
</div>
<p>SQLite 데이터베이스 파일 <em>database</em>에 대한 연결을 엽니다. 사용자 정의 <em>factory</em>가 주어지지 않는 한, 기본적으로 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 객체를 반환합니다.</p>
<p><em>database</em>는 열릴 데이터베이스 파일의 경로명(절대 혹은 현재 작업 디렉터리에 대한 상대)을 제공하는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>입니다. <code class="docutils literal notranslate"><span class="pre">&quot;:memory:&quot;</span></code>를 사용하여 디스크 대신 램(RAM)에 있는 데이터베이스에 대한 데이터베이스 연결을 열 수 있습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><em>database</em> 에 빈 문자열을 주면 임시 파일이 사용되고, 연결이 닫히면 파일은 삭제됩니다.
데이터베이스가 파일에 만들어진다는 점을 제외하면 모든 면에서 <code class="docutils literal notranslate"><span class="pre">&quot;:memory:&quot;</span></code> 와 비슷합니다.</p>
</div>
<p>데이터베이스가 여러 연결을 통해 액세스 되고, 프로세스 중 하나가 데이터베이스를 수정할 때, 해당 트랜잭션이 커밋될 때까지 SQLite 데이터베이스가 잠깁니다. <em>timeout</em> 매개 변수는 예외를 일으키기 전에 잠금이 해제되기를 연결이 기다려야 하는 시간을 지정합니다. timeout 매개 변수의 기본값은 5.0(5초)입니다.</p>
<p><em>isolation_level</em> 매개 변수는 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 객체의 <a class="reference internal" href="#sqlite3.Connection.isolation_level" title="sqlite3.Connection.isolation_level"><code class="xref py py-attr docutils literal notranslate"><span class="pre">isolation_level</span></code></a> 프로퍼티를 참조하십시오.</p>
<p>SQLite는 기본적으로 TEXT, INTEGER, REAL, BLOB 및 NULL 형만 지원합니다. 다른 형을 사용하려면 직접 지원을 추가해야 합니다. <em>detect_types</em> 매개 변수와 모듈 수준 <a class="reference internal" href="#sqlite3.register_converter" title="sqlite3.register_converter"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_converter()</span></code></a> 함수로 등록된 사용자 정의 <strong>변환기</strong>를 사용하면 쉽게 할 수 있습니다.</p>
<p><em>detect_types</em>의 기본값은 0입니다 (즉, 형 감지가 없습니다). <a class="reference internal" href="#sqlite3.PARSE_DECLTYPES" title="sqlite3.PARSE_DECLTYPES"><code class="xref py py-const docutils literal notranslate"><span class="pre">PARSE_DECLTYPES</span></code></a>와 <a class="reference internal" href="#sqlite3.PARSE_COLNAMES" title="sqlite3.PARSE_COLNAMES"><code class="xref py py-const docutils literal notranslate"><span class="pre">PARSE_COLNAMES</span></code></a>의 조합으로 설정하여 형 감지를 켤 수 있습니다.</p>
<p>기본적으로 <em>check_same_thread</em>는 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>며, 만들고 있는 스레드 만 이 연결을 사용할 수 있습니다. <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>로 설정하면 반환된 연결을 여러 스레드에서 공유할 수 있습니다. 여러 스레드에서 같은 연결을 사용할 때, 데이터 손상을 피하려면 쓰기 연산을 사용자가 직렬화해야 합니다.</p>
<p>기본적으로, <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈은 connect 호출에 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 클래스를 사용합니다. 그러나, <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 클래스의 서브 클래스를 만들고 <em>factory</em> 매개 변수에 클래스를 제공하면 <a class="reference internal" href="#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a>가 그 클래스를 사용하게 할 수 있습니다.</p>
<p>자세한 내용은 이 설명서의 섹션 <a class="reference internal" href="#sqlite3-types"><span class="std std-ref">SQLite 와 파이썬 형</span></a>을 참조하십시오.</p>
<p><a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈은 내부적으로 SQL 구문 분석 오버헤드를 피하고자 명령문 캐시를 사용합니다. 연결에 대해 캐시 되는 명령문의 수를 명시적으로 설정하려면, <em>cached_statements</em> 매개 변수를 설정할 수 있습니다. 현재 구현된 기본값은 100개의 명령문을 캐시 하는 것입니다.</p>
<p><em>uri</em>가 참이면 <em>database</em>는 URI로 해석됩니다. 이렇게 하면 옵션을 지정할 수 있습니다. 예를 들어, 읽기 전용 모드로 데이터베이스를 열려면 다음과 같이 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">db</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;file:path/to/database?mode=ro&#39;</span><span class="p">,</span> <span class="n">uri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>인식되는 옵션 목록을 포함하여, 이 기능에 대한 자세한 내용은 <a class="reference external" href="https://www.sqlite.org/uri.html">SQLite URI documentation</a>에서 찾을 수 있습니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">database</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트(auditing event)</span></a> <code class="docutils literal notranslate"><span class="pre">sqlite3.connect</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><em>uri</em> 매개 변수가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><em>database</em>는 이제 문자열뿐만 아니라 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a> 일 수도 있습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="sqlite3.register_converter">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">register_converter</code><span class="sig-paren">(</span><em class="sig-param">typename</em>, <em class="sig-param">callable</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.register_converter" title="정의 주소">¶</a></dt>
<dd><p>데이터베이스의 바이트열을 사용자 정의 파이썬 형으로 변환할 수 있는 콜러블을 등록합니다. 콜러블은 형 <em>typename</em> 인 모든 데이터베이스 값에 대해 호출됩니다. 형 감지 작동 방식에 대해서는 <a class="reference internal" href="#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> 함수의 매개 변수 <em>detect_types</em>를 참고하십시오. <em>typename</em>과 질의의 형 이름은 대/소문자를 구분하지 않고 일치시킴에 유의하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="sqlite3.register_adapter">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">register_adapter</code><span class="sig-paren">(</span><em class="sig-param">type</em>, <em class="sig-param">callable</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.register_adapter" title="정의 주소">¶</a></dt>
<dd><p>사용자 정의 파이썬 형 <em>type</em>을 SQLite의 지원되는 형 중 하나로 변환할 수 있는 콜러블을 등록합니다. 콜러블 <em>callable</em>은 단일 매개 변수로 파이썬 값을 받아들이고 다음 형들의 값을 반환해야 합니다: int, float, str 또는 bytes.</p>
</dd></dl>

<dl class="function">
<dt id="sqlite3.complete_statement">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">complete_statement</code><span class="sig-paren">(</span><em class="sig-param">sql</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.complete_statement" title="정의 주소">¶</a></dt>
<dd><p>문자열 <em>sql</em>에 세미콜론으로 끝나는 하나 이상의 완전한 SQL 문이 포함되어 있으면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환합니다. SQL이 문법적으로 올바른지 확인하지는 않습니다. 닫히지 않은 문자열 리터럴이 없고 명령문이 세미콜론으로 끝나는지만 확인합니다.</p>
<p>이것은 다음 예제와 같이, SQLite 용 셸을 만드는데 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 실험을 위한 최소 SQLite 셸</span>

<span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">isolation_level</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="n">buffer</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter your SQL commands to execute in sqlite3.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter a blank line to exit.&quot;</span><span class="p">)</span>

<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">line</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">buffer</span> <span class="o">+=</span> <span class="n">line</span>
    <span class="k">if</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">complete_statement</span><span class="p">(</span><span class="n">buffer</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">buffer</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;SELECT&quot;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">())</span>
        <span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;An error occurred:&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sqlite3.enable_callback_tracebacks">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">enable_callback_tracebacks</code><span class="sig-paren">(</span><em class="sig-param">flag</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.enable_callback_tracebacks" title="정의 주소">¶</a></dt>
<dd><p>기본적으로 사용자 정의 함수, 집계(aggregates), 변환기, 인가(authorizer) 콜백 등에서는 트레이스백을 얻지 못합니다. 디버깅하려면 <em>flag</em>를 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정하여 이 함수를 호출할 수 있습니다. 그러면, <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>로 콜백의 트레이스백을 얻게 됩니다. 기능을 다시 비활성화하려면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 사용하십시오.</p>
</dd></dl>

</div>
<div class="section" id="connection-objects">
<span id="sqlite3-connection-objects"></span><h2>Connection 객체<a class="headerlink" href="#connection-objects" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="sqlite3.Connection">
<em class="property">class </em><code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">Connection</code><a class="headerlink" href="#sqlite3.Connection" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 클래스입니다.</p>
</div>
<p>SQLite 데이터베이스 연결에는 다음과 같은 어트리뷰트와 메서드가 있습니다:</p>
<dl class="attribute">
<dt id="sqlite3.Connection.isolation_level">
<code class="sig-name descname">isolation_level</code><a class="headerlink" href="#sqlite3.Connection.isolation_level" title="정의 주소">¶</a></dt>
<dd><p>현재의 기본 격리 수준을 가져오거나 설정합니다. 자동 커밋 모드를 뜻하는 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이나 &quot;DEFERRED&quot;, &quot;IMMEDIATE&quot; 또는 &quot;EXCLUSIVE&quot; 중 하나입니다. 자세한 설명은 <a class="reference internal" href="#sqlite3-controlling-transactions"><span class="std std-ref">트랜잭션 제어</span></a> 절을 참조하십시오.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><a class="reference internal" href="#sqlite3.Connection.isolation_level" title="sqlite3.Connection.isolation_level"><code class="xref py py-attr docutils literal notranslate"><span class="pre">isolation_level</span></code></a> 의 기본값은 &quot;&quot; 입니다. 이 값은 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 과는 다른 것이며
&quot;DEFERRED&quot; 와 같은 방식으로 동작합니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlite3.Connection.in_transaction">
<code class="sig-name descname">in_transaction</code><a class="headerlink" href="#sqlite3.Connection.in_transaction" title="정의 주소">¶</a></dt>
<dd><p>트랜잭션이 활성화 상태면(커밋되지 않은 변경 사항이 있으면) <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>. 읽기 전용 어트리뷰트.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.cursor">
<code class="sig-name descname">cursor</code><span class="sig-paren">(</span><em class="sig-param">factory=Cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.cursor" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 메서드입니다. 다만 <em>factory</em> 매개 변수는 정의하지 않습니다.</p>
</div>
<p>cursor 메서드는 단일 선택적 매개 변수 <em>factory</em>를 받아들입니다. 제공되면, 이것은 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 나 그 서브 클래스의 인스턴스를 반환하는 콜러블이어야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.commit">
<code class="sig-name descname">commit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.commit" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 메서드입니다.</p>
</div>
<p>이 메서드는 현재 트랜잭션을 커밋합니다. 이 메서드를 호출하지 않으면, 마지막 <code class="docutils literal notranslate"><span class="pre">commit()</span></code> 호출 이후에 수행한 작업은 다른 데이터베이스 연결에서 볼 수 없습니다. 데이터베이스에 기록한 데이터가 왜 보이지 않는지 궁금하면, 이 메서드를 호출하는 것을 잊지 않았는지 확인하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.rollback">
<code class="sig-name descname">rollback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.rollback" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 메서드입니다.</p>
</div>
<p>이 메서드는 마지막 <a class="reference internal" href="#sqlite3.Connection.commit" title="sqlite3.Connection.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commit()</span></code></a> 호출 이후의 데이터베이스에 대한 모든 변경 사항을 되돌립니다.</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.close" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 메서드입니다.</p>
</div>
<p>데이터베이스 연결을 닫습니다. 자동으로 <a class="reference internal" href="#sqlite3.Connection.commit" title="sqlite3.Connection.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commit()</span></code></a>을 호출하지 않음에 유의하십시오. <a class="reference internal" href="#sqlite3.Connection.commit" title="sqlite3.Connection.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commit()</span></code></a>를 먼저 호출하지 않고 데이터베이스 연결을 닫으면 변경 사항이 손실됩니다!</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.execute">
<code class="sig-name descname">execute</code><span class="sig-paren">(</span><em class="sig-param">sql</em><span class="optional">[</span>, <em class="sig-param">parameters</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.execute" title="정의 주소">¶</a></dt>
<dd><p>이것은 비표준 바로 가기인데, <a class="reference internal" href="#sqlite3.Connection.cursor" title="sqlite3.Connection.cursor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cursor()</span></code></a> 메서드를 호출하여 커서 객체를 만들고, 지정된 <em>parameters</em>를 사용하여 커서의 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> 메서드를 호출한 다음, 커서를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.executemany">
<code class="sig-name descname">executemany</code><span class="sig-paren">(</span><em class="sig-param">sql</em><span class="optional">[</span>, <em class="sig-param">parameters</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.executemany" title="정의 주소">¶</a></dt>
<dd><p>이것은 비표준 바로 가기인데, <a class="reference internal" href="#sqlite3.Connection.cursor" title="sqlite3.Connection.cursor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cursor()</span></code></a> 메서드를 호출하여 커서 객체를 만들고, 지정된 <em>parameters</em>를 사용하여 커서의 <a class="reference internal" href="#sqlite3.Cursor.executemany" title="sqlite3.Cursor.executemany"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executemany()</span></code></a> 메서드를 호출한 다음, 커서를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.executescript">
<code class="sig-name descname">executescript</code><span class="sig-paren">(</span><em class="sig-param">sql_script</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.executescript" title="정의 주소">¶</a></dt>
<dd><p>이것은 비표준 바로 가기인데, <a class="reference internal" href="#sqlite3.Connection.cursor" title="sqlite3.Connection.cursor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cursor()</span></code></a> 메서드를 호출하여 커서 객체를 만들고, 지정된 <em>sql_script</em>를 사용하여 커서의 <a class="reference internal" href="#sqlite3.Cursor.executescript" title="sqlite3.Cursor.executescript"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executescript()</span></code></a> 메서드를 호출한 다음, 커서를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.create_function">
<code class="sig-name descname">create_function</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">num_params</em>, <em class="sig-param">func</em>, <em class="sig-param">*</em>, <em class="sig-param">deterministic=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.create_function" title="정의 주소">¶</a></dt>
<dd><p>나중에 함수 이름 <em>name</em>으로 SQL 문에서 사용할 수 있는 사용자 정의 함수를 만듭니다. <em>num_params</em>는 함수가 받아들이는 매개 변수의 수입니다 (<em>num_params</em>가 -1이면 함수는 임의의 인자를 취할 수 있습니다). <em>func</em>는 SQL 함수로 호출되는 파이썬 콜러블입니다. <em>deterministic</em>이 참이면, 만들어진 함수는 SQLite가 추가적인 최적화를 수행할 수 있도록 <a class="reference external" href="https://sqlite.org/deterministic.html">결정론적(deterministic)</a>으로 표시됩니다. 이 플래그는 SQLite 3.8.3 이상에서 지원됩니다, 이전 버전에서 사용되면 <a class="reference internal" href="#sqlite3.NotSupportedError" title="sqlite3.NotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotSupportedError</span></code></a>가 발생합니다.</p>
<p>함수는 SQLite가 지원하는 모든 형을 반환할 수 있습니다: bytes, str, int, float 및 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><em>deterministic</em> 매개 변수가 추가되었습니다.</p>
</div>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">import</span> <span class="nn">hashlib</span>

<span class="k">def</span> <span class="nf">md5sum</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">create_function</span><span class="p">(</span><span class="s2">&quot;md5&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">md5sum</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select md5(?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="sa">b</span><span class="s2">&quot;foo&quot;</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.create_aggregate">
<code class="sig-name descname">create_aggregate</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">num_params</em>, <em class="sig-param">aggregate_class</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.create_aggregate" title="정의 주소">¶</a></dt>
<dd><p>사용자 정의 집계(aggregate) 함수를 만듭니다.</p>
<p>매개 변수의 수 <em>num_params</em>(<em>num_params</em>가 -1이면 함수는 임의의 인자를 취할 수 있습니다)를 받아들이며, 집계 클래스는 <code class="docutils literal notranslate"><span class="pre">step</span></code> 메서드와 집계의 최종 결과를 반환하는 <code class="docutils literal notranslate"><span class="pre">finalize</span></code> 메서드를 구현해야 합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">finalize</span></code> 메서드는 SQLite가 지원하는 모든 형을 반환할 수 있습니다: bytes, str, int, float 및 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="k">class</span> <span class="nc">MySum</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">create_aggregate</span><span class="p">(</span><span class="s2">&quot;mysum&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MySum</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;create table test(i)&quot;</span><span class="p">)</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into test(i) values (1)&quot;</span><span class="p">)</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into test(i) values (2)&quot;</span><span class="p">)</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select mysum(i) from test&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.create_collation">
<code class="sig-name descname">create_collation</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">callable</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.create_collation" title="정의 주소">¶</a></dt>
<dd><p>지정된 <em>name</em> 과 <em>callable</em>로 정렬법(collation)을 만듭니다. 콜러블에는 두 개의 문자열 인자가 전달됩니다. 첫째가 둘째보다 작은 순서면 -1, 같은 순서면 0, 첫째가 둘째보다 큰 순서면 1을 반환 해야 합니다. 이것은 정렬(SQL의 ORDER BY)을 제어하므로, 여러분의 비교는 다른 SQL 연산에 영향을 주지 않습니다.</p>
<p>콜러블 객체는 보통 UTF-8로 인코딩된 파이썬 바이트열로 매개 변수를 가져옵니다.</p>
<p>다음 예제는 &quot;잘못된 방법&quot;으로 정렬하는 사용자 정의 정렬법을 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="k">def</span> <span class="nf">collate_reverse</span><span class="p">(</span><span class="n">string1</span><span class="p">,</span> <span class="n">string2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">string1</span> <span class="o">==</span> <span class="n">string2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">string1</span> <span class="o">&lt;</span> <span class="n">string2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">create_collation</span><span class="p">(</span><span class="s2">&quot;reverse&quot;</span><span class="p">,</span> <span class="n">collate_reverse</span><span class="p">)</span>

<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;create table test(x)&quot;</span><span class="p">)</span>
<span class="n">cur</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;insert into test(x) values (?)&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s2">&quot;a&quot;</span><span class="p">,),</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,)])</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select x from test order by x collate reverse&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cur</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>정렬법을 제거하려면 callable에 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 사용해서 <code class="docutils literal notranslate"><span class="pre">create_collation</span></code>를 호출하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">con</span><span class="o">.</span><span class="n">create_collation</span><span class="p">(</span><span class="s2">&quot;reverse&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.interrupt">
<code class="sig-name descname">interrupt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.interrupt" title="정의 주소">¶</a></dt>
<dd><p>연결에서 실행 중일 수 있는 모든 질의를 중단하려면, 이 메서드를 다른 스레드에서 호출할 수 있습니다. 그러면 질의가 중단되고 호출자는 예외를 받습니다.</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.set_authorizer">
<code class="sig-name descname">set_authorizer</code><span class="sig-paren">(</span><em class="sig-param">authorizer_callback</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.set_authorizer" title="정의 주소">¶</a></dt>
<dd><p>이 루틴은 콜백을 등록합니다. 콜백은 데이터베이스의 테이블 열에 액세스할 때마다 호출됩니다. 콜백은 액세스가 허용되면 <code class="xref py py-const docutils literal notranslate"><span class="pre">SQLITE_OK</span></code>를 반환하고, 전체 SQL 문을 에러를 일으키며 중단해야 하면 <code class="xref py py-const docutils literal notranslate"><span class="pre">SQLITE_DENY</span></code>를, 열을 NULL 값으로 처리하려면 <code class="xref py py-const docutils literal notranslate"><span class="pre">SQLITE_IGNORE</span></code>를 반환해야 합니다. 이 상수들은 <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈에 있습니다.</p>
<p>콜백의 첫 번째 인자는 어떤 종류의 연산이 인가받으려 하는지를 나타냅니다. 두 번째와 세 번째 인자는 첫 번째 인자에 따라 인자이거나 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>이 됩니다. 네 번째 인자는 해당하면 데이터베이스 이름(&quot;main&quot;, &quot;temp&quot; 등)입니다. 다섯 번째 인자는 액세스 시도를 담당하는 가장 안쪽의 트리거나 뷰의 이름이거나, 이 액세스 시도가 입력 SQL 코드에서 직접 발생했으면 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>입니다.</p>
<p>첫 번째 인자에 가능한 값과 첫 번째 인자에 의존하는 두 번째 및 세 번째 인자의 의미에 대해서는 SQLite 문서를 참조하십시오. 필요한 모든 상수는 <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈에 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.set_progress_handler">
<code class="sig-name descname">set_progress_handler</code><span class="sig-paren">(</span><em class="sig-param">handler</em>, <em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.set_progress_handler" title="정의 주소">¶</a></dt>
<dd><p>이 루틴은 콜백을 등록합니다. 콜백은 SQLite 가상 머신의 매 <em>n</em>개의 명령어마다 호출됩니다. 장시간 실행되는 작업 중에 SQLite로부터 호출되기를 원할 때 유용합니다, 예를 들어 GUI를 갱신하는데 사용할 수 있습니다.</p>
<p>이전에 설치된 모든 진행 처리기를 지우려면 <em>handler</em>로 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 사용하여 메서드를 호출하십시오.</p>
<p>처리기 함수에서 0이 아닌 값을 반환하면 현재 실행 중인 질의가 종료되고 <a class="reference internal" href="#sqlite3.OperationalError" title="sqlite3.OperationalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OperationalError</span></code></a> 예외가 발생합니다.</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.set_trace_callback">
<code class="sig-name descname">set_trace_callback</code><span class="sig-paren">(</span><em class="sig-param">trace_callback</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.set_trace_callback" title="정의 주소">¶</a></dt>
<dd><p>SQLite 백 엔드가 실제로 실행하는 각 SQL 문마다 호출할 <em>trace_callback</em>을 등록합니다.</p>
<p>콜백에 전달되는 유일한 인자는 실행 중인 문장(문자열)입니다. 콜백의 반환 값은 무시됩니다. 백 엔드는 <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Cursor.execute()</span></code></a> 메서드에 전달된 명령문만 실행하는 것은 아님에 유의하시기 바랍니다. 다른 소스로는 파이썬 모듈의 트랜잭션 관리와 현재 데이터베이스에 정의된 트리거의 실행이 있습니다.</p>
<p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 <em>trace_callback</em>로 전달하면 추적 콜백을 비활성화합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.enable_load_extension">
<code class="sig-name descname">enable_load_extension</code><span class="sig-paren">(</span><em class="sig-param">enabled</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.enable_load_extension" title="정의 주소">¶</a></dt>
<dd><p>이 루틴은 SQLite 엔진이 공유 라이브러리에서 SQLite 확장을 로드하는 것을 허용/불허합니다. SQLite 확장은 새 함수, 집계 또는 완전히 새로운 가상 테이블 구현을 정의할 수 있습니다. 잘 알려진 확장 중 하나는 SQLite와 함께 배포되는 전체 텍스트 검색 확장입니다.</p>
<p>로드 가능한 확장은 기본적으로 비활성화되어 있습니다. <a class="footnote-reference brackets" href="#f1" id="id1">1</a>를 보세요.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>

<span class="c1"># 확장 로드를 활성화합니다</span>
<span class="n">con</span><span class="o">.</span><span class="n">enable_load_extension</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># 전체 텍스트 검색 확장을 로드합니다</span>
<span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select load_extension(&#39;./fts3.so&#39;)&quot;</span><span class="p">)</span>

<span class="c1"># 대신 API 호출을 사용하여 확장을 로드할 수도 있습니다:</span>
<span class="c1"># con.load_extension(&quot;./fts3.so&quot;)</span>

<span class="c1"># 확장 로드를 다시 비활성화합니다</span>
<span class="n">con</span><span class="o">.</span><span class="n">enable_load_extension</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># SQLite 위키의 예제</span>
<span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;create virtual table recipe using fts3(name, ingredients)&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">executescript</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    insert into recipe (name, ingredients) values (&#39;broccoli stew&#39;, &#39;broccoli peppers cheese tomatoes&#39;);</span>
<span class="s2">    insert into recipe (name, ingredients) values (&#39;pumpkin stew&#39;, &#39;pumpkin onions garlic celery&#39;);</span>
<span class="s2">    insert into recipe (name, ingredients) values (&#39;broccoli pie&#39;, &#39;broccoli cheese onions flour&#39;);</span>
<span class="s2">    insert into recipe (name, ingredients) values (&#39;pumpkin pie&#39;, &#39;pumpkin sugar flour butter&#39;);</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select rowid, name, ingredients from recipe where name match &#39;pie&#39;&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.load_extension">
<code class="sig-name descname">load_extension</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.load_extension" title="정의 주소">¶</a></dt>
<dd><p>이 루틴은 공유 라이브러리에서 SQLite 확장을 로드합니다. 이 루틴을 사용하려면 먼저 <a class="reference internal" href="#sqlite3.Connection.enable_load_extension" title="sqlite3.Connection.enable_load_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">enable_load_extension()</span></code></a>로 확장 로드를 활성화해야 합니다.</p>
<p>로드 가능한 확장은 기본적으로 비활성화되어 있습니다. <a class="footnote-reference brackets" href="#f1" id="id2">1</a>를 보세요.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlite3.Connection.row_factory">
<code class="sig-name descname">row_factory</code><a class="headerlink" href="#sqlite3.Connection.row_factory" title="정의 주소">¶</a></dt>
<dd><p>이 어트리뷰트를 커서와 원본 행을 튜플로 받아들이고 실제 결과 행을 반환하는 콜러블로 변경할 수 있습니다. 이렇게 하면, 이름으로 열을 액세스할 수 있는 객체를 반환하는 것과 같이, 결과를 반환하는 더 고급 방식을 구현할 수 있습니다.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="k">def</span> <span class="nf">dict_factory</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">):</span>
        <span class="n">d</span><span class="p">[</span><span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">d</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">row_factory</span> <span class="o">=</span> <span class="n">dict_factory</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select 1 as a&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="s2">&quot;a&quot;</span><span class="p">])</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>튜플을 반환하는 것으로 충분하지 않고 열에 대한 이름 기반 액세스를 원하면, <a class="reference internal" href="#sqlite3.Connection.row_factory" title="sqlite3.Connection.row_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">row_factory</span></code></a>를 고도로 최적화된 <a class="reference internal" href="#sqlite3.Row" title="sqlite3.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlite3.Row</span></code></a> 형으로 설정하는 것을 고려해야 합니다. <a class="reference internal" href="#sqlite3.Row" title="sqlite3.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a>는 메모리 오버헤드가 거의 없이 열에 대해 인덱스 기반과 대소 문자를 구분하지 않는 이름 기반 액세스를 제공합니다. 아마도 여러분 자신의 사용자 정의 딕셔너리 기반 접근법이나 심지어 db_row 기반 해법보다 더 좋을 것입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlite3.Connection.text_factory">
<code class="sig-name descname">text_factory</code><a class="headerlink" href="#sqlite3.Connection.text_factory" title="정의 주소">¶</a></dt>
<dd><p>이 어트리뷰트를 사용하면 <code class="docutils literal notranslate"><span class="pre">TEXT</span></code> 데이터형에 대해 반환되는 객체를 제어할 수 있습니다. 기본적으로, 이 어트리뷰트는 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로 설정되고 <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈은 <code class="docutils literal notranslate"><span class="pre">TEXT</span></code>에 대해 유니코드 객체를 반환합니다. 대신 바이트열을 반환하려면, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>로 설정할 수 있습니다.</p>
<p>하나의 바이트열 매개 변수를 받아들이고 결과 객체를 반환하는 다른 콜러블 객체로 설정할 수도 있습니다.</p>
<p>예시를 위해 다음 예제 코드를 참조하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="n">AUSTRIA</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\xd6</span><span class="s2">sterreich&quot;</span>

<span class="c1"># 기본적으로, 행은 유니코드로 반환됩니다</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">AUSTRIA</span><span class="p">,))</span>
<span class="n">row</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">AUSTRIA</span>

<span class="c1"># 하지만 우리는 sqlite3가 항상 바이트열을 반환하도록 할 수 있습니다 ...</span>
<span class="n">con</span><span class="o">.</span><span class="n">text_factory</span> <span class="o">=</span> <span class="nb">bytes</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">AUSTRIA</span><span class="p">,))</span>
<span class="n">row</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">bytes</span>
<span class="c1"># 여러분이 데이터베이스에 쓰레기를 저장하지 않는 이상, 바이트열은 UTF-8로 인코딩될 것입니다 ...</span>
<span class="k">assert</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">AUSTRIA</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>

<span class="c1"># 우리는 또한 사용자 정의 text_factory를 구현할 수 있습니다 ...</span>
<span class="c1"># 여기서 모든 문자열에 &quot;foo&quot;를 추가하는 것을 구현합니다</span>
<span class="n">con</span><span class="o">.</span><span class="n">text_factory</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;foo&quot;</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;bar&quot;</span><span class="p">,))</span>
<span class="n">row</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;barfoo&quot;</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlite3.Connection.total_changes">
<code class="sig-name descname">total_changes</code><a class="headerlink" href="#sqlite3.Connection.total_changes" title="정의 주소">¶</a></dt>
<dd><p>데이터베이스 연결이 열린 후 수정, 삽입 또는 삭제된 데이터베이스 행의 총수를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.iterdump">
<code class="sig-name descname">iterdump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.iterdump" title="정의 주소">¶</a></dt>
<dd><p>SQL 텍스트 형식으로 데이터베이스를 덤프하는 이터레이터를 반환합니다. 나중에 복원할 수 있도록 메모리 데이터베이스를 저장할 때 유용합니다. 이 함수는 <strong class="program">sqlite3</strong> 셸의 <kbd class="kbd docutils literal notranslate">.dump</kbd> 명령과 같은 기능을 제공합니다.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># existing_db.db 파일을 SQL 덤프 파일 dump.sql로 변환합니다</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;existing_db.db&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;dump.sql&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">con</span><span class="o">.</span><span class="n">iterdump</span><span class="p">():</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">line</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Connection.backup">
<code class="sig-name descname">backup</code><span class="sig-paren">(</span><em class="sig-param">target</em>, <em class="sig-param">*</em>, <em class="sig-param">pages=0</em>, <em class="sig-param">progress=None</em>, <em class="sig-param">name=&quot;main&quot;</em>, <em class="sig-param">sleep=0.250</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Connection.backup" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 SQLite 데이터베이스의 백업을 만드는데, 다른 클라이언트가 액세스하고 있거나 같은 연결로 동시에 액세스하고 있어도 됩니다. 복사본은 필수 인자 <em>target</em>에 기록되며, 이것은 다른 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 인스턴스여야 합니다.</p>
<p>기본적으로, 또는 <em>pages</em>가 <code class="docutils literal notranslate"><span class="pre">0</span></code> 이나 음의 정수이면, 전체 데이터베이스가 단일 단계로 복사됩니다; 그렇지 않으면 이 메서드는 한 번에 최대 <em>pages</em> 페이지만큼 복사하는 루프를 수행합니다.</p>
<p><em>progress</em>가 지정되면, <code class="docutils literal notranslate"><span class="pre">None</span></code> 또는 매 이터레이션마다 세 개의 정수 인자로 실행되는 콜러블 객체여야 합니다. 세 인자는 각각 직전 이터레이션의 <em>상태(status)</em>, 아직 복사해야 할 <em>남은(remaining)</em> 페이지 수, <em>전체(total)</em> 페이지 수입니다.</p>
<p><em>name</em> 인자는 복사할 데이터베이스 이름을 지정합니다: main 데이터베이스를 나타내는 <code class="docutils literal notranslate"><span class="pre">&quot;main&quot;</span></code>, 기본값, 임시 데이터베이스를 나타내는 <code class="docutils literal notranslate"><span class="pre">&quot;temp&quot;</span></code> 또는 첨부된 데이터베이스를 위한 <code class="docutils literal notranslate"><span class="pre">ATTACH</span> <span class="pre">DATABASE</span></code> 문에서 <code class="docutils literal notranslate"><span class="pre">AS</span></code> 키워드 뒤에 지정된 이름을 포함하는 문자열이어야 합니다.</p>
<p><em>sleep</em> 인자는 남은 페이지를 백업하는 연속적인 시도 사이에서 잠잘 시간을 초 단위로 지정하며, 정수 또는 부동 소수점 값으로 지정할 수 있습니다.</p>
<p>예제 1, 기존 데이터베이스를 다른 데이터베이스로 복사:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="k">def</span> <span class="nf">progress</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">total</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Copied {total-remaining} of </span><span class="si">{total}</span><span class="s1"> pages...&#39;</span><span class="p">)</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;existing_db.db&#39;</span><span class="p">)</span>
<span class="n">bck</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;backup.db&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">bck</span><span class="p">:</span>
    <span class="n">con</span><span class="o">.</span><span class="n">backup</span><span class="p">(</span><span class="n">bck</span><span class="p">,</span> <span class="n">pages</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="n">progress</span><span class="p">)</span>
<span class="n">bck</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>예제 2, 기존 데이터베이스를 임시 복사본으로 복사:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="n">source</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;existing_db.db&#39;</span><span class="p">)</span>
<span class="n">dest</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;:memory:&#39;</span><span class="p">)</span>
<span class="n">source</span><span class="o">.</span><span class="n">backup</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
</pre></div>
</div>
<p>가용성: SQLite 3.6.11 이상</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="cursor-objects">
<span id="sqlite3-cursor-objects"></span><h2>Cursor 객체<a class="headerlink" href="#cursor-objects" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="sqlite3.Cursor">
<em class="property">class </em><code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">Cursor</code><a class="headerlink" href="#sqlite3.Cursor" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 클래스입니다. 이 설명서에는 나와있지 않지만 DB-API 2.0이 필수로 정의하는
<code class="xref py py-meth docutils literal notranslate"><span class="pre">setinputsizes()</span></code> 와 <code class="xref py py-meth docutils literal notranslate"><span class="pre">setoutputsize()</span></code> 메서드도 정의되어 있습니다.
두 메서드 모두 아무일도 하지 않습니다.</p>
</div>
<p><a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 인스턴스에는 다음과 같은 어트리뷰트와 메서드가 있습니다.</p>
<span class="target" id="index-2"></span><span class="target" id="index-3"></span><dl class="method">
<dt id="sqlite3.Cursor.execute">
<code class="sig-name descname">execute</code><span class="sig-paren">(</span><em class="sig-param">sql</em><span class="optional">[</span>, <em class="sig-param">parameters</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Cursor.execute" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 메서드입니다.</p>
</div>
<p>SQL 문을 실행합니다. SQL 문을 매개 변수화(즉, SQL 리터럴 대신 자리 표시자)할 수 있습니다. <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈은 두 가지 자리 표시자를 지원합니다: 물음표(qmark 스타일)와 이름있는 자리 표시자(named 스타일).</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0은 다섯 종류의 자리표시자를 정의하고 있습니다: <code class="docutils literal notranslate"><span class="pre">qmark</span></code>, <code class="docutils literal notranslate"><span class="pre">numeric</span></code>, <code class="docutils literal notranslate"><span class="pre">named</span></code>,
<code class="docutils literal notranslate"><span class="pre">format</span></code>, <code class="docutils literal notranslate"><span class="pre">pyformat</span></code>. 이 중 어느 것을 지원하는지는 모듈 전역으로 정의되는
<code class="docutils literal notranslate"><span class="pre">paramstyle</span></code> 문자열 상수로 알려주도록 하고 있습니다. <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 는
<code class="docutils literal notranslate"><span class="pre">qmark</span></code> 와 <code class="docutils literal notranslate"><span class="pre">named</span></code> 를 지원하지만, <code class="xref py py-data docutils literal notranslate"><span class="pre">sqlite3.paramstyle</span></code> 는 <code class="docutils literal notranslate"><span class="pre">qmark</span></code> 라고
알려주고 있습니다. 하지만 DB-API 2.0 은 가능하다면 <code class="docutils literal notranslate"><span class="pre">numeric</span></code>, <code class="docutils literal notranslate"><span class="pre">named</span></code>, <code class="docutils literal notranslate"><span class="pre">pyformat</span></code> 중
하나를 사용하도록 권고하고 있습니다.</p>
</div>
<p>다음은 두 스타일의 예입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;create table people (name_last, age)&quot;</span><span class="p">)</span>

<span class="n">who</span> <span class="o">=</span> <span class="s2">&quot;Yeltsin&quot;</span>
<span class="n">age</span> <span class="o">=</span> <span class="mi">72</span>

<span class="c1"># qmark 스타일입니다:</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into people values (?, ?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">who</span><span class="p">,</span> <span class="n">age</span><span class="p">))</span>

<span class="c1"># named 스타일입니다:</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select * from people where name_last=:who and age=:age&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;who&quot;</span><span class="p">:</span> <span class="n">who</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">:</span> <span class="n">age</span><span class="p">})</span>

<span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">())</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a>는 단일 SQL 문만 실행합니다. 하나 이상의 명령문을 실행하려고 하면 <a class="reference internal" href="#sqlite3.Warning" title="sqlite3.Warning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Warning</span></code></a>이 발생합니다. 하나의 호출로 여러 SQL 문을 실행하려면 <a class="reference internal" href="#sqlite3.Cursor.executescript" title="sqlite3.Cursor.executescript"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executescript()</span></code></a>를 사용하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Cursor.executemany">
<code class="sig-name descname">executemany</code><span class="sig-paren">(</span><em class="sig-param">sql</em>, <em class="sig-param">seq_of_parameters</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Cursor.executemany" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 메서드입니다.</p>
</div>
<p>시퀀스 <em>seq_of_parameters</em>에 있는 모든 매개 변수 시퀀스나 매핑에 대해 SQL 명령을 실행합니다. <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈은 시퀀스 대신 매개 변수를 산출하는 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a>도 허용합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="k">class</span> <span class="nc">IterChars</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),)</span> <span class="c1"># 1-튜플입니다</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;create table characters(c)&quot;</span><span class="p">)</span>

<span class="n">theIter</span> <span class="o">=</span> <span class="n">IterChars</span><span class="p">()</span>
<span class="n">cur</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;insert into characters(c) values (?)&quot;</span><span class="p">,</span> <span class="n">theIter</span><span class="p">)</span>

<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select c from characters&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">())</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>다음은 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a>를 사용하는 간단한 예입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">import</span> <span class="nn">string</span>

<span class="k">def</span> <span class="nf">char_generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span><span class="p">:</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">c</span><span class="p">,)</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;create table characters(c)&quot;</span><span class="p">)</span>

<span class="n">cur</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;insert into characters(c) values (?)&quot;</span><span class="p">,</span> <span class="n">char_generator</span><span class="p">())</span>

<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select c from characters&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">())</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Cursor.executescript">
<code class="sig-name descname">executescript</code><span class="sig-paren">(</span><em class="sig-param">sql_script</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Cursor.executescript" title="정의 주소">¶</a></dt>
<dd><p>이것은 한 번에 여러 SQL 문을 실행하기 위한 비표준 편의 메서드입니다. 먼저 <code class="docutils literal notranslate"><span class="pre">COMMIT</span></code> 문을 실행한 다음, 매개 변수로 가져온 SQL 스크립트를 실행합니다.</p>
<p><em>sql_script</em>는 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>의 인스턴스가 될 수 있습니다.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">cur</span><span class="o">.</span><span class="n">executescript</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    create table person(</span>
<span class="s2">        firstname,</span>
<span class="s2">        lastname,</span>
<span class="s2">        age</span>
<span class="s2">    );</span>

<span class="s2">    create table book(</span>
<span class="s2">        title,</span>
<span class="s2">        author,</span>
<span class="s2">        published</span>
<span class="s2">    );</span>

<span class="s2">    insert into book(title, author, published)</span>
<span class="s2">    values (</span>
<span class="s2">        &#39;Dirk Gently&#39;&#39;s Holistic Detective Agency&#39;,</span>
<span class="s2">        &#39;Douglas Adams&#39;,</span>
<span class="s2">        1987</span>
<span class="s2">    );</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Cursor.fetchone">
<code class="sig-name descname">fetchone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Cursor.fetchone" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 메서드입니다.</p>
</div>
<p>질의 결과 집합의 다음 행을 가져옵니다. 단일 시퀀스를 반환하거나, 데이터가 더 없을 때 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Cursor.fetchmany">
<code class="sig-name descname">fetchmany</code><span class="sig-paren">(</span><em class="sig-param">size=cursor.arraysize</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Cursor.fetchmany" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 메서드입니다.</p>
</div>
<p>질의 결과의 다음 행 집합을 가져와서, 리스트를 반환합니다. 행이 더 없으면 빈 목록이 반환됩니다.</p>
<p>호출 당 가져오는 행의 수는 <em>size</em> 매개 변수로 지정됩니다. 지정되어 않으면, 커서의 arraysize가 가져올 행의 수를 결정합니다. 이 메서드는 size 매개 변수가 나타내는 수만큼의 행을 가져오려고 해야 합니다. 지정된 수의 행이 없어서 이것이 가능하지 않다면, 더 적은 행이 반환될 수 있습니다.</p>
<p><em>size</em> 매개 변수와 관련된 성능 고려 사항이 있습니다. 최적의 성능을 위해서, 일반적으로 arraysize 어트리뷰트를 사용하는 것이 가장 좋습니다. <em>size</em> 매개 변수가 사용되면, <a class="reference internal" href="#sqlite3.Cursor.fetchmany" title="sqlite3.Cursor.fetchmany"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fetchmany()</span></code></a> 호출마다 같은 값을 유지하는 것이 가장 좋습니다.</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Cursor.fetchall">
<code class="sig-name descname">fetchall</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Cursor.fetchall" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 메서드입니다.</p>
</div>
<p>질의 결과의 모든 (남은) 행을 가져와서 리스트를 반환합니다. 커서의 arraysize 어트리뷰트는 이 연산의 성능에 영향을 줄 수 있습니다. 행이 없으면 빈 리스트가 반환됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="sqlite3.Cursor.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Cursor.close" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 메서드입니다.</p>
</div>
<p>(<code class="docutils literal notranslate"><span class="pre">__del__</span></code>이 호출 될 때가 아니라) 지금 커서를 닫습니다.</p>
<p>이 시점부터는 커서를 사용할 수 없습니다; 커서로 어떤 연산이건 시도하면 <a class="reference internal" href="#sqlite3.ProgrammingError" title="sqlite3.ProgrammingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ProgrammingError</span></code></a> 예외가 발생합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlite3.Cursor.rowcount">
<code class="sig-name descname">rowcount</code><a class="headerlink" href="#sqlite3.Cursor.rowcount" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 어트리뷰트입니다.</p>
</div>
<p><a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈의 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 클래스가 이 어트리뷰트를 구현하지만, &quot;영향을 받는 행&quot;/&quot;선택된 행&quot;의 판단을 위한 데이터베이스 엔진 자체 지원은 기이합니다.</p>
<p><a class="reference internal" href="#sqlite3.Cursor.executemany" title="sqlite3.Cursor.executemany"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executemany()</span></code></a> 문에서, 수정 횟수는 <a class="reference internal" href="#sqlite3.Cursor.rowcount" title="sqlite3.Cursor.rowcount"><code class="xref py py-attr docutils literal notranslate"><span class="pre">rowcount</span></code></a>에 합산됩니다.</p>
<p>파이썬 DB API 스펙에 따라, <a class="reference internal" href="#sqlite3.Cursor.rowcount" title="sqlite3.Cursor.rowcount"><code class="xref py py-attr docutils literal notranslate"><span class="pre">rowcount</span></code></a> 어트리뷰트는 커서에서 <code class="docutils literal notranslate"><span class="pre">executeXX()</span></code>가 수행되지 않았거나 마지막 연산의 행 개수가 인터페이스에 의해 결정되지 않는 경우 -1입니다. 이런 경우는 <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 문을 포함하는데, 모든 행을 가져올 때까지 질의가 생성 한 행 수를 결정할 수 없기 때문입니다.</p>
<p>3.6.5 이전의 SQLite 버전에서는, 조건 없이 <code class="docutils literal notranslate"><span class="pre">DELETE</span> <span class="pre">FROM</span> <span class="pre">table</span></code>을 하면 <a class="reference internal" href="#sqlite3.Cursor.rowcount" title="sqlite3.Cursor.rowcount"><code class="xref py py-attr docutils literal notranslate"><span class="pre">rowcount</span></code></a>가 0으로 설정됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlite3.Cursor.lastrowid">
<code class="sig-name descname">lastrowid</code><a class="headerlink" href="#sqlite3.Cursor.lastrowid" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 선택적으로 정의하는 어트리뷰트입니다.</p>
</div>
<p>이 읽기 전용 어트리뷰트는 마지막으로 수정된 행의 rowid를 제공합니다. <a class="reference internal" href="#sqlite3.Cursor.execute" title="sqlite3.Cursor.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code></a> 메서드를 사용하여 <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> 나 <code class="docutils literal notranslate"><span class="pre">REPLACE</span></code> 문을 실행했을 때만 설정됩니다. <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> 나 <code class="docutils literal notranslate"><span class="pre">REPLACE</span></code> 이외의 연산이나 <a class="reference internal" href="#sqlite3.Cursor.executemany" title="sqlite3.Cursor.executemany"><code class="xref py py-meth docutils literal notranslate"><span class="pre">executemany()</span></code></a>가 호출될 때, <a class="reference internal" href="#sqlite3.Cursor.lastrowid" title="sqlite3.Cursor.lastrowid"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lastrowid</span></code></a>는 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>으로 설정됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">INSERT</span></code> 나 <code class="docutils literal notranslate"><span class="pre">REPLACE</span></code> 문이 삽입에 실패하면, 이전의 성공적인 rowid가 반환됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><code class="docutils literal notranslate"><span class="pre">REPLACE</span></code> 문에 대한 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sqlite3.Cursor.arraysize">
<code class="sig-name descname">arraysize</code><a class="headerlink" href="#sqlite3.Cursor.arraysize" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 어트리뷰트입니다.</p>
</div>
<p><a class="reference internal" href="#sqlite3.Cursor.fetchmany" title="sqlite3.Cursor.fetchmany"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fetchmany()</span></code></a>에 의해 반환되는 행의 수를 제어하는 읽기/쓰기 어트리뷰트. 기본값은 1입니다. 이는 호출 당 하나의 행을 가져오는 것을 뜻합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlite3.Cursor.description">
<code class="sig-name descname">description</code><a class="headerlink" href="#sqlite3.Cursor.description" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 어트리뷰트입니다. 하지만 그 내용은 규격에서 살짝 벗어납니다.
DB-API 2.0은 처음 두 항목 <code class="docutils literal notranslate"><span class="pre">name</span></code> 과 <code class="docutils literal notranslate"><span class="pre">type_code</span></code>를 필수 항목으로 정의하고 있습니다.
하지만 <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a>는 <a class="reference internal" href="#sqlite3.Cursor.description" title="sqlite3.Cursor.description"><code class="xref py py-attr docutils literal notranslate"><span class="pre">description</span></code></a> 의 두 번째 항목으로 항상 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을
줍니다. DB-API 2.0은 <code class="docutils literal notranslate"><span class="pre">type_code</span></code>\를 통해 열의 형을 파악할 수 있도록 하고 있고, 이 값과 비교할 수 있는
다음과 같은 형들을 모듈 수준에서 정의하고 있습니다: <code class="docutils literal notranslate"><span class="pre">STRING</span></code>, <code class="docutils literal notranslate"><span class="pre">BINARY</span></code>, <code class="docutils literal notranslate"><span class="pre">NUMBER</span></code>,
<code class="docutils literal notranslate"><span class="pre">DATETIME</span></code>, <code class="docutils literal notranslate"><span class="pre">ROWID</span></code>. <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈은 이 형들도 정의하고 있지 않습니다.</p>
</div>
<p>이 읽기 전용 어트리뷰트는 마지막 질의의 열 이름을 제공합니다. 파이썬 DB API와의 호환성을 유지하기 위해, 각 열마다 7-튜플을 반환하는데, 각 튜플의 마지막 6개 항목은 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 입니다.</p>
<p>일치하는 행이 없는 <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 문에도 설정됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="sqlite3.Cursor.connection">
<code class="sig-name descname">connection</code><a class="headerlink" href="#sqlite3.Cursor.connection" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 선택적으로 정의하는 어트리뷰트입니다.</p>
</div>
<p>이 읽기 전용 어트리뷰트는 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 객체가 사용하는 SQLite 데이터베이스 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>을 제공합니다. <a class="reference internal" href="#sqlite3.Connection.cursor" title="sqlite3.Connection.cursor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">con.cursor()</span></code></a>를 호출하여 생성된 <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 객체는 <em>con</em>을 참조하는 <a class="reference internal" href="#sqlite3.Cursor.connection" title="sqlite3.Cursor.connection"><code class="xref py py-attr docutils literal notranslate"><span class="pre">connection</span></code></a> 어트리뷰트를 가집니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cur</span><span class="o">.</span><span class="n">connection</span> <span class="o">==</span> <span class="n">con</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="row-objects">
<span id="sqlite3-row-objects"></span><h2>Row 객체<a class="headerlink" href="#row-objects" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="sqlite3.Row">
<em class="property">class </em><code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">Row</code><a class="headerlink" href="#sqlite3.Row" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#sqlite3.Row" title="sqlite3.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> 인스턴스는 <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 객체에 대해 고도로 최적화된 <a class="reference internal" href="#sqlite3.Connection.row_factory" title="sqlite3.Connection.row_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">row_factory</span></code></a> 역할을 합니다. 대부분 기능에서 튜플을 모방하려고 합니다.</p>
<p>열 이름과 인덱스에 의한 매핑 액세스와, 이터레이션, 표현(repr), 동등성 검사 및 <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>을 지원합니다.</p>
<p>두 개의 <a class="reference internal" href="#sqlite3.Row" title="sqlite3.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> 객체가 정확히 같은 열을 갖고 그 구성원이 같으면 같다고 비교됩니다.</p>
<dl class="method">
<dt id="sqlite3.Row.keys">
<code class="sig-name descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Row.keys" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 열 이름 리스트를 반환합니다. 질의 직후, <a class="reference internal" href="#sqlite3.Cursor.description" title="sqlite3.Cursor.description"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Cursor.description</span></code></a>에 있는 각 튜플의 첫 번째 멤버입니다.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>슬라이싱 지원이 추가되었습니다.</p>
</div>
</dd></dl>

<p>위에서 주어진 예제에서처럼 테이블을 초기화한다고 가정해 봅시다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;create table stocks</span>
<span class="s1">(date text, trans text, symbol text,</span>
<span class="s1"> qty real, price real)&#39;&#39;&#39;</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;insert into stocks</span>
<span class="s2">          values (&#39;2006-01-05&#39;,&#39;BUY&#39;,&#39;RHAT&#39;,100,35.14)&quot;&quot;&quot;</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>이제 우리는 <a class="reference internal" href="#sqlite3.Row" title="sqlite3.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a>를 연결합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">row_factory</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Row</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;select * from stocks&#39;</span><span class="p">)</span>
<span class="go">&lt;sqlite3.Cursor object at 0x7f4e7dd8fa80&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="go">&lt;class &#39;sqlite3.Row&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="go">(&#39;2006-01-05&#39;, &#39;BUY&#39;, &#39;RHAT&#39;, 100.0, 35.14)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">&#39;RHAT&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;date&#39;, &#39;trans&#39;, &#39;symbol&#39;, &#39;qty&#39;, &#39;price&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;qty&#39;</span><span class="p">]</span>
<span class="go">100.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">member</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">2006-01-05</span>
<span class="go">BUY</span>
<span class="go">RHAT</span>
<span class="go">100.0</span>
<span class="go">35.14</span>
</pre></div>
</div>
</div>
<div class="section" id="exceptions">
<span id="sqlite3-exceptions"></span><h2>예외<a class="headerlink" href="#exceptions" title="제목 주소">¶</a></h2>
<dl class="exception">
<dt id="sqlite3.Warning">
<em class="property">exception </em><code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">Warning</code><a class="headerlink" href="#sqlite3.Warning" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 예외입니다.</p>
</div>
<p><a class="reference internal" href="exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a>의 서브 클래스.</p>
</dd></dl>

<dl class="exception">
<dt id="sqlite3.Error">
<em class="property">exception </em><code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">Error</code><a class="headerlink" href="#sqlite3.Error" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 예외입니다.</p>
</div>
<p>이 모듈에 있는 다른 예외의 베이스 클래스. <a class="reference internal" href="exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a>의 서브 클래스입니다.</p>
</dd></dl>

<dl class="exception">
<dt id="sqlite3.DatabaseError">
<em class="property">exception </em><code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">DatabaseError</code><a class="headerlink" href="#sqlite3.DatabaseError" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 예외입니다.</p>
</div>
<p>데이터베이스와 관련된 에러에 대해 발생하는 예외.</p>
</dd></dl>

<dl class="exception">
<dt id="sqlite3.IntegrityError">
<em class="property">exception </em><code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">IntegrityError</code><a class="headerlink" href="#sqlite3.IntegrityError" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 예외입니다.</p>
</div>
<p>데이터베이스의 관계형 무결성이 영향을 받을 때 발생하는 예외. 예를 들어, 외부 키(foreign key) 검사가 실패할 때. <a class="reference internal" href="#sqlite3.DatabaseError" title="sqlite3.DatabaseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DatabaseError</span></code></a>의 서브 클래스입니다.</p>
</dd></dl>

<dl class="exception">
<dt id="sqlite3.ProgrammingError">
<em class="property">exception </em><code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">ProgrammingError</code><a class="headerlink" href="#sqlite3.ProgrammingError" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 예외입니다.</p>
</div>
<p>프로그래밍 에러에 대한 예외, 예를 들어, 테이블을 찾을 수 없거나 이미 존재 함, SQL 문의 문법 에러, 지정된 매개 변수 개수가 잘못됨 등. <a class="reference internal" href="#sqlite3.DatabaseError" title="sqlite3.DatabaseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DatabaseError</span></code></a>의 서브 클래스입니다.</p>
</dd></dl>

<dl class="exception">
<dt id="sqlite3.OperationalError">
<em class="property">exception </em><code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">OperationalError</code><a class="headerlink" href="#sqlite3.OperationalError" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 예외입니다.</p>
</div>
<p>데이터베이스 연산과 관련되고 프로그래머의 제어하에 있지 않은 에러에 관한 오류. 예를 들어, 예기치 않은 단절이 발생하거나, 데이터 소스 이름을 찾을 수 없거나, 트랜잭션이 진행될 수 없을 때 등. <a class="reference internal" href="#sqlite3.DatabaseError" title="sqlite3.DatabaseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DatabaseError</span></code></a>의 서브 클래스입니다.</p>
</dd></dl>

<dl class="exception">
<dt id="sqlite3.NotSupportedError">
<em class="property">exception </em><code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">NotSupportedError</code><a class="headerlink" href="#sqlite3.NotSupportedError" title="정의 주소">¶</a></dt>
<dd><div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0이 정의하는 예외입니다.</p>
</div>
<p>데이터베이스에서 지원하지 않는 메서드나 데이터베이스 API가 사용될 때 발생하는 예외. 예를 들어, 트랜잭션을 지원하지 않는 연결에서 <a class="reference internal" href="#sqlite3.Connection.rollback" title="sqlite3.Connection.rollback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rollback()</span></code></a> 메서드를 호출할 때. <a class="reference internal" href="#sqlite3.DatabaseError" title="sqlite3.DatabaseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DatabaseError</span></code></a>의 서브 클래스입니다.</p>
</dd></dl>

</div>
<div class="section" id="sqlite-and-python-types">
<span id="sqlite3-types"></span><h2>SQLite 와 파이썬 형<a class="headerlink" href="#sqlite-and-python-types" title="제목 주소">¶</a></h2>
<div class="section" id="introduction">
<h3>소개<a class="headerlink" href="#introduction" title="제목 주소">¶</a></h3>
<p>SQLite는 기본적으로 다음 형을 지원합니다: <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code>, <code class="docutils literal notranslate"><span class="pre">REAL</span></code>, <code class="docutils literal notranslate"><span class="pre">TEXT</span></code>, <code class="docutils literal notranslate"><span class="pre">BLOB</span></code>.</p>
<p>따라서 다음과 같은 파이썬 형을 아무 문제 없이 SQLite로 보낼 수 있습니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 70%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>파이썬 형</p></th>
<th class="head"><p>SQLite 형</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TEXT</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">BLOB</span></code></p></td>
</tr>
</tbody>
</table>
<p>이것은 SQLite 형이 기본적으로 파이썬 형으로 변환되는 방법입니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>SQLite 형</p></th>
<th class="head"><p>파이썬 형</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code></p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">INTEGER</span></code></p></td>
<td><p><a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">REAL</span></code></p></td>
<td><p><a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">TEXT</span></code></p></td>
<td><p><a class="reference internal" href="#sqlite3.Connection.text_factory" title="sqlite3.Connection.text_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">text_factory</span></code></a>에 따라 다릅니다, 기본적으로 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">BLOB</span></code></p></td>
<td><p><a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a></p></td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈의 형 시스템은 두 가지 방식으로 확장 가능합니다: 객체 어댑터를 통해 SQLite 데이터베이스에 추가 파이썬 형을 저장할 수 있으며 변환기를 통해 <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈에서 SQLite 형을 다른 파이썬 형으로 변환할 수 있습니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>DB-API 2.0은 날짜, 시간, 바이너리를 데이터베이스로 전달하는 데 사용할 수 있는 모듈 수준 함수들을
몇가지 정의하고 있습니다. 이 모두를 <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 가 지원하고 있지만 이 설명서에는 나오지 않습니다.
다음과 같은 함수입니다.</p>
<dl class="function">
<dt id="sqlite3.Date">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">Date</code><span class="sig-paren">(</span><em class="sig-param">year</em>, <em class="sig-param">month</em>, <em class="sig-param">day</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Date" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="sqlite3.Time">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">Time</code><span class="sig-paren">(</span><em class="sig-param">hour</em>, <em class="sig-param">minute</em>, <em class="sig-param">second</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Time" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="sqlite3.Timestamp">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">Timestamp</code><span class="sig-paren">(</span><em class="sig-param">year</em>, <em class="sig-param">month</em>, <em class="sig-param">day</em>, <em class="sig-param">hour</em>, <em class="sig-param">minute</em>, <em class="sig-param">second</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Timestamp" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="sqlite3.DateFromTicks">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">DateFromTicks</code><span class="sig-paren">(</span><em class="sig-param">ticks</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.DateFromTicks" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="sqlite3.TimeFromTicks">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">TimeFromTicks</code><span class="sig-paren">(</span><em class="sig-param">ticks</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.TimeFromTicks" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="sqlite3.TimestampFromTicks">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">TimestampFromTicks</code><span class="sig-paren">(</span><em class="sig-param">ticks</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.TimestampFromTicks" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="sqlite3.Binary">
<code class="sig-prename descclassname">sqlite3.</code><code class="sig-name descname">Binary</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlite3.Binary" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</div>
</div>
<div class="section" id="using-adapters-to-store-additional-python-types-in-sqlite-databases">
<h3>어댑터를 사용하여 SQLite 데이터베이스에 추가 파이썬 형을 저장하기<a class="headerlink" href="#using-adapters-to-store-additional-python-types-in-sqlite-databases" title="제목 주소">¶</a></h3>
<p>앞에서 설명한 것처럼, SQLite는 기본적으로 제한된 형 집합만 지원합니다. SQLite에 다른 파이썬 형을 사용하려면, SQLite에 대해 sqlite3 모듈이 지원하는 형 중 하나로 <strong>어댑트</strong> 해야 합니다: NoneType, int, float, str, bytes 중 하나.</p>
<p><a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈이 사용자 정의 파이썬 형을, 지원되는 형 중 하나로 어댑트하도록 만드는 두 가지 방법이 있습니다.</p>
<div class="section" id="letting-your-object-adapt-itself">
<h4>객체가 스스로 어댑트하도록 하기<a class="headerlink" href="#letting-your-object-adapt-itself" title="제목 주소">¶</a></h4>
<p>여러분이 스스로 클래스를 작성한다면 이것이 좋은 접근법입니다. 다음과 같은 클래스가 있다고 가정해 봅시다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<p>이제 Point를 단일 SQLite 열에 저장하려고 합니다. 먼저 포인트를 나타내는데 사용할 지원되는 형 중 하나를 선택해야 합니다. str을 사용하고 좌표를 세미콜론으로 분리하기로 합시다. 그런 다음 여러분의 클래스에 변환된 값을 반환하는 <code class="docutils literal notranslate"><span class="pre">__conform__(self,</span> <span class="pre">protocol)</span></code> 메서드를 제공해야 합니다. 매개 변수 <em>protocol</em>은 <code class="xref py py-class docutils literal notranslate"><span class="pre">PrepareProtocol</span></code>이 됩니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">__conform__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">protocol</span> <span class="ow">is</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">PrepareProtocol</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%f</span><span class="s2">;</span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.2</span><span class="p">)</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="registering-an-adapter-callable">
<h4>어댑터 콜러블 등록하기<a class="headerlink" href="#registering-an-adapter-callable" title="제목 주소">¶</a></h4>
<p>또 다른 가능성은 형을 문자열 표현으로 변환하는 함수를 만들고. 그 함수를 <a class="reference internal" href="#sqlite3.register_adapter" title="sqlite3.register_adapter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_adapter()</span></code></a>로 등록하는 것입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">adapt_point</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%f</span><span class="s2">;</span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

<span class="n">sqlite3</span><span class="o">.</span><span class="n">register_adapter</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="n">adapt_point</span><span class="p">)</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.2</span><span class="p">)</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈에는 파이썬의 내장 <a class="reference internal" href="datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.date</span></code></a> 와 <a class="reference internal" href="datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a> 형에 대한 두 개의 기본 어댑터가 있습니다. 이제 <a class="reference internal" href="datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a> 객체를 ISO 표현이 아닌 유닉스 타임스탬프로 저장하려고 한다고 가정해 봅시다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">adapt_datetime</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">mktime</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">timetuple</span><span class="p">())</span>

<span class="n">sqlite3</span><span class="o">.</span><span class="n">register_adapter</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">adapt_datetime</span><span class="p">)</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select ?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">now</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="converting-sqlite-values-to-custom-python-types">
<h3>SQLite 값을 사용자 정의 파이썬 형으로 변환하기<a class="headerlink" href="#converting-sqlite-values-to-custom-python-types" title="제목 주소">¶</a></h3>
<p>어댑터를 작성하면 사용자 정의 파이썬 형을 SQLite로 보낼 수 있습니다. 그러나 실제로 유용하게 사용하려면 파이썬에서 SQLite를 거쳐 다시 파이썬으로 돌아오는 순환이 동작하게 할 필요가 있습니다.</p>
<p>변환기를 사용하십시오.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Point</span></code> 클래스로 돌아갑시다. 세미콜론으로 분리된 x와 y 좌표를 SQLite에 문자열로 저장했습니다.</p>
<p>먼저, 문자열을 매개 변수로 받아들이고 이것으로부터 <code class="xref py py-class docutils literal notranslate"><span class="pre">Point</span></code> 객체를 만드는 변환기 함수를 정의합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>변환기 함수는 <strong>항상</strong> SQLite로 보낸 값의 데이터형에 상관없이 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체로 호출됩니다.</p>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">convert_point</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;;&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>이제 <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈이 데이터베이스에서 select 한 것이 실제로 Point임을 알게 해야 합니다. 이렇게 하는 두 가지 방법이 있습니다:</p>
<ul class="simple">
<li><p>선언된 형을 통해 묵시적으로</p></li>
<li><p>열 이름을 통해 명시적으로</p></li>
</ul>
<p>두 가지 방법은 섹션 <a class="reference internal" href="#sqlite3-module-contents"><span class="std std-ref">모듈 함수와 상수</span></a> 의 상수 <a class="reference internal" href="#sqlite3.PARSE_DECLTYPES" title="sqlite3.PARSE_DECLTYPES"><code class="xref py py-const docutils literal notranslate"><span class="pre">PARSE_DECLTYPES</span></code></a> 와 <a class="reference internal" href="#sqlite3.PARSE_COLNAMES" title="sqlite3.PARSE_COLNAMES"><code class="xref py py-const docutils literal notranslate"><span class="pre">PARSE_COLNAMES</span></code></a>에 대한 항목에서 설명합니다.</p>
<p>다음 예는 두 가지 접근법을 보여줍니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;(</span><span class="si">%f</span><span class="s2">;</span><span class="si">%f</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">adapt_point</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2">;</span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">convert_point</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;;&quot;</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># 어댑터를 등록합니다</span>
<span class="n">sqlite3</span><span class="o">.</span><span class="n">register_adapter</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="n">adapt_point</span><span class="p">)</span>

<span class="c1"># 변환기를 등록합니다</span>
<span class="n">sqlite3</span><span class="o">.</span><span class="n">register_converter</span><span class="p">(</span><span class="s2">&quot;point&quot;</span><span class="p">,</span> <span class="n">convert_point</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.2</span><span class="p">)</span>

<span class="c1">#########################</span>
<span class="c1"># 1) 선언된 형 사용하기</span>
<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">,</span> <span class="n">detect_types</span><span class="o">=</span><span class="n">sqlite3</span><span class="o">.</span><span class="n">PARSE_DECLTYPES</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;create table test(p point)&quot;</span><span class="p">)</span>

<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into test(p) values (?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,))</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select p from test&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;with declared types:&quot;</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">cur</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1">#######################</span>
<span class="c1"># 1) 열 이름 사용하기</span>
<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">,</span> <span class="n">detect_types</span><span class="o">=</span><span class="n">sqlite3</span><span class="o">.</span><span class="n">PARSE_COLNAMES</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;create table test(p)&quot;</span><span class="p">)</span>

<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into test(p) values (?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,))</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;select p as &quot;p [point]&quot; from test&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;with column names:&quot;</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">cur</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="default-adapters-and-converters">
<h3>기본 어댑터와 변환기<a class="headerlink" href="#default-adapters-and-converters" title="제목 주소">¶</a></h3>
<p>datetime 모듈의 date와 datetime 형에 대한 기본 어댑터가 있습니다. 이것들은 ISO 날짜/ISO 타임스탬프로 SQLite로 보내집니다.</p>
<p>기본 변환기는 <a class="reference internal" href="datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.date</span></code></a>는 &quot;date&quot;라는 이름으로, <a class="reference internal" href="datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a>은 &quot;timestamp&quot;라는 이름으로 등록됩니다.</p>
<p>이런 방법으로, 대부분 추가 작업 없이 파이썬의 날짜/타임스탬프를 사용할 수 있습니다. 어댑터의 형식은 실험적인 SQLite 날짜/시간 함수와도 호환됩니다.</p>
<p>다음 예제는 이를 보여줍니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">,</span> <span class="n">detect_types</span><span class="o">=</span><span class="n">sqlite3</span><span class="o">.</span><span class="n">PARSE_DECLTYPES</span><span class="o">|</span><span class="n">sqlite3</span><span class="o">.</span><span class="n">PARSE_COLNAMES</span><span class="p">)</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;create table test(d date, ts timestamp)&quot;</span><span class="p">)</span>

<span class="n">today</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>
<span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into test(d, ts) values (?, ?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">today</span><span class="p">,</span> <span class="n">now</span><span class="p">))</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select d, ts from test&quot;</span><span class="p">)</span>
<span class="n">row</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">today</span><span class="p">,</span> <span class="s2">&quot;=&gt;&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">type</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="s2">&quot;=&gt;&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">type</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;select current_date as &quot;d [date]&quot;, current_timestamp as &quot;ts [timestamp]&quot;&#39;</span><span class="p">)</span>
<span class="n">row</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;current_date&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">type</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;current_timestamp&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">type</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>SQLite에 저장된 타임스탬프가 6자리보다 긴 소수부가 있으면, 그 값은 타임스탬프 변환기에 의해 마이크로초 정밀도로 잘립니다.</p>
</div>
</div>
<div class="section" id="controlling-transactions">
<span id="sqlite3-controlling-transactions"></span><h2>트랜잭션 제어<a class="headerlink" href="#controlling-transactions" title="제목 주소">¶</a></h2>
<p>하부 <code class="docutils literal notranslate"><span class="pre">sqlite3</span></code> 라이브러리는 기본적으로 <code class="docutils literal notranslate"><span class="pre">autocommit</span></code> 모드로 작동하지만, 파이썬 <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈은 기본적으로 그렇지 않습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">autocommit</span></code> 모드는 데이터베이스를 수정하는 명령문이 즉시 적용됨을 뜻합니다. <code class="docutils literal notranslate"><span class="pre">BEGIN</span></code> 이나 <code class="docutils literal notranslate"><span class="pre">SAVEPOINT</span></code> 문은 <code class="docutils literal notranslate"><span class="pre">autocommit</span></code> 모드를 비활성화하고, 가장 바깥쪽 트랜잭션을 끝내는 <code class="docutils literal notranslate"><span class="pre">COMMIT</span></code>, <code class="docutils literal notranslate"><span class="pre">ROLLBACK</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">RELEASE</span></code>는 <code class="docutils literal notranslate"><span class="pre">autocommit</span></code> 모드를 다시 켭니다.</p>
<p>기본적으로 파이썬 <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈은 데이터 조작 언어(DML - Data Modification Language) 문 (즉, <code class="docutils literal notranslate"><span class="pre">INSERT</span></code>/<code class="docutils literal notranslate"><span class="pre">UPDATE</span></code>/<code class="docutils literal notranslate"><span class="pre">DELETE</span></code>/<code class="docutils literal notranslate"><span class="pre">REPLACE</span></code>) 앞에 암묵적으로 <code class="docutils literal notranslate"><span class="pre">BEGIN</span></code> 문을 넣습니다.</p>
<p><a class="reference internal" href="#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> 호출의 <em>isolation_level</em> 매개 변수를 통해, 또는 연결의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">isolation_level</span></code> 프로퍼티를 통해, <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a>가 묵시적으로 실행하는 <code class="docutils literal notranslate"><span class="pre">BEGIN</span></code> 문의 종류를 제어할 수 있습니다. <em>isolation_level</em>을 지정하지 않으면, 단순한 <code class="docutils literal notranslate"><span class="pre">BEGIN</span></code>이 사용되며, 이는 <code class="docutils literal notranslate"><span class="pre">DEFERRED</span></code>를 지정하는 것과 같습니다. 가능한 다른 값은 <code class="docutils literal notranslate"><span class="pre">IMMEDIATE</span></code> 와 <code class="docutils literal notranslate"><span class="pre">EXCLUSIVE</span></code>입니다.</p>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p><code class="docutils literal notranslate"><span class="pre">DEFERRED</span></code> 는 <code class="docutils literal notranslate"><span class="pre">BEGIN</span></code> 문이 실행될 때 록을 만들지 않고, 실제로 읽거나 쓰는 시점에 록을
만듭니다. 반면에 <code class="docutils literal notranslate"><span class="pre">IMMEDIATE</span></code> 는 <code class="docutils literal notranslate"><span class="pre">BEGIN</span></code> 문에서 즉시 록을 만듭니다. 두 경우 모두
다른 연결에서 여전히 데이터베이스를 읽을 수 있습니다. 하지만, <code class="docutils literal notranslate"><span class="pre">EXCLUSIVE</span></code> 도
<code class="docutils literal notranslate"><span class="pre">IMMEDIATE</span></code>처럼 <code class="docutils literal notranslate"><span class="pre">BEGIN</span></code> 문에서 즉시 록을 만드는데, 이때는 다른 연결에서도 읽기가 금지됩니다.</p>
</div>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">isolation_level</span></code>를 <code class="docutils literal notranslate"><span class="pre">None</span></code>로 설정하여 <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈의 묵시적 트랜잭션 관리를 비활성화할 수 있습니다. 그러면 하부 <code class="docutils literal notranslate"><span class="pre">sqlite3</span></code> 라이브러리가 <code class="docutils literal notranslate"><span class="pre">autocommit</span></code> 모드로 작동합니다. 그런 다음 코드에서 <code class="docutils literal notranslate"><span class="pre">BEGIN</span></code>, <code class="docutils literal notranslate"><span class="pre">ROLLBACK</span></code>, <code class="docutils literal notranslate"><span class="pre">SAVEPOINT</span></code> 및 <code class="docutils literal notranslate"><span class="pre">RELEASE</span></code> 문을 명시적으로 실행하여 트랜잭션 상태를 완전히 제어할 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a>는 DDL 문 앞에서 열린 트랜잭션을 묵시적으로 커밋했습니다. 더는 그렇지 않습니다.</p>
</div>
</div>
<div class="section" id="using-sqlite3-efficiently">
<h2>효율적으로 <a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 사용하기<a class="headerlink" href="#using-sqlite3-efficiently" title="제목 주소">¶</a></h2>
<div class="section" id="using-shortcut-methods">
<h3>바로 가기 메서드 사용하기<a class="headerlink" href="#using-shortcut-methods" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 객체의 비표준 <code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">executemany()</span></code> 및 <code class="xref py py-meth docutils literal notranslate"><span class="pre">executescript()</span></code> 메서드를 사용하면, (종종 불필요한) <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 객체를 명시적으로 만들 필요가 없으므로, 코드를 더 간결하게 작성할 수 있습니다. 대신, <a class="reference internal" href="#sqlite3.Cursor" title="sqlite3.Cursor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code></a> 객체가 묵시적으로 만들어지며 이러한 바로 가기 메서드는 커서 객체를 반환합니다. 이런 방법으로, <a class="reference internal" href="#sqlite3.Connection" title="sqlite3.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> 객체에 대한 단일 호출만 사용하여 <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 문을 실행하고 직접 이터레이트할 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="n">persons</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">&quot;Hugo&quot;</span><span class="p">,</span> <span class="s2">&quot;Boss&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;Calvin&quot;</span><span class="p">,</span> <span class="s2">&quot;Klein&quot;</span><span class="p">)</span>
    <span class="p">]</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>

<span class="c1"># 테이블을 만듭니다</span>
<span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;create table person(firstname, lastname)&quot;</span><span class="p">)</span>

<span class="c1"># 테이블을 채웁니다</span>
<span class="n">con</span><span class="o">.</span><span class="n">executemany</span><span class="p">(</span><span class="s2">&quot;insert into person(firstname, lastname) values (?, ?)&quot;</span><span class="p">,</span> <span class="n">persons</span><span class="p">)</span>

<span class="c1"># 테이블의 내용을 인쇄합니다</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select firstname, lastname from person&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I just deleted&quot;</span><span class="p">,</span> <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;delete from person&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rowcount</span><span class="p">,</span> <span class="s2">&quot;rows&quot;</span><span class="p">)</span>

<span class="c1"># close는 바로 가기 메서드가 아니며 자동으로 호출되지 않습니다.</span>
<span class="c1"># 그래서 연결 객체를 수동으로 닫아야 합니다.</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="accessing-columns-by-name-instead-of-by-index">
<h3>인덱스 대신 이름으로 열 액세스하기<a class="headerlink" href="#accessing-columns-by-name-instead-of-by-index" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 모듈의 유용한 기능 중 하나는 행 팩토리로 사용하도록 설계된 내장 <a class="reference internal" href="#sqlite3.Row" title="sqlite3.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlite3.Row</span></code></a> 클래스입니다.</p>
<p>이 클래스로 감싼 행은 인덱스(튜플처럼)와 대소 문자를 구분하지 않는 이름으로 액세스할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">row_factory</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Row</span>

<span class="n">cur</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select &#39;John&#39; as name, 42 as age&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">cur</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;nAmE&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;age&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;AgE&quot;</span><span class="p">]</span>

<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="using-the-connection-as-a-context-manager">
<h3>컨텍스트 관리자로 연결 사용하기<a class="headerlink" href="#using-the-connection-as-a-context-manager" title="제목 주소">¶</a></h3>
<p>연결 객체는 트랜잭션을 자동으로 커밋하거나 롤백하는 컨텍스트 관리자로 사용할 수 있습니다. 예외가 발생하면, 트랜잭션이 롤백 됩니다; 그렇지 않으면 트랜잭션이 커밋 됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sqlite3</span>

<span class="n">con</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
<span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;create table person (id integer primary key, firstname varchar unique)&quot;</span><span class="p">)</span>

<span class="c1"># 성공적입니다, con.commit()이 자동으로 나중에 호출됩니다</span>
<span class="k">with</span> <span class="n">con</span><span class="p">:</span>
    <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into person(firstname) values (?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Joe&quot;</span><span class="p">,))</span>

<span class="c1"># with 블록이 예외로 끝난 후에 con.rollback()이 호출됩니다, 예외는 여전히 발생하고, 잡아야 합니다</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">con</span><span class="p">:</span>
        <span class="n">con</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into person(firstname) values (?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Joe&quot;</span><span class="p">,))</span>
<span class="k">except</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">IntegrityError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;couldn&#39;t add Joe twice&quot;</span><span class="p">)</span>

<span class="c1"># 컨텍스트 관리자로 사용된 연결 객체는 트랜잭션을 커밋하거나 롤백하기만 합니다,</span>
<span class="c1"># 그래서 연결 객체를 수동으로 닫아야 합니다.</span>
<span class="n">con</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="common-issues">
<h2>일반적인 문제<a class="headerlink" href="#common-issues" title="제목 주소">¶</a></h2>
<div class="section" id="multithreading">
<h3>다중 스레드<a class="headerlink" href="#multithreading" title="제목 주소">¶</a></h3>
<p>이전 SQLite 버전에서는 스레드 간에 연결을 공유하는 데 문제가 있었습니다. 이것이 파이썬 모듈이 스레드 간에 연결과 커서를 공유하도록 허용하지 않는 이유입니다. 여전히 그렇게 하려고 하면 실행 시간에 예외가 발생합니다.</p>
<p>유일한 예외는 <a class="reference internal" href="#sqlite3.Connection.interrupt" title="sqlite3.Connection.interrupt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interrupt()</span></code></a> 메서드를 호출하는 것입니다. 이 메서드는 다른 스레드에서 호출해야만 합니다.</p>
<p class="rubric">각주</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>)</span></dt>
<dd><p>기본적으로 sqlite3 모듈은 로드 가능한 확장을 지원하도록 빌드되지 않습니다. 일부 플랫폼(특히 맥 OS X)에는 이 기능 없이 컴파일된 SQLite 라이브러리가 있기 때문입니다. 로드 가능한 확장 지원을 받으려면, configure에 --enable-loadable-sqlite-extensions를 전달해야 합니다.</p>
</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> --- SQLite 데이터베이스용 DB-API 2.0 인터페이스</a><ul>
<li><a class="reference internal" href="#module-functions-and-constants">모듈 함수와 상수</a></li>
<li><a class="reference internal" href="#connection-objects">Connection 객체</a></li>
<li><a class="reference internal" href="#cursor-objects">Cursor 객체</a></li>
<li><a class="reference internal" href="#row-objects">Row 객체</a></li>
<li><a class="reference internal" href="#exceptions">예외</a></li>
<li><a class="reference internal" href="#sqlite-and-python-types">SQLite 와 파이썬 형</a><ul>
<li><a class="reference internal" href="#introduction">소개</a></li>
<li><a class="reference internal" href="#using-adapters-to-store-additional-python-types-in-sqlite-databases">어댑터를 사용하여 SQLite 데이터베이스에 추가 파이썬 형을 저장하기</a><ul>
<li><a class="reference internal" href="#letting-your-object-adapt-itself">객체가 스스로 어댑트하도록 하기</a></li>
<li><a class="reference internal" href="#registering-an-adapter-callable">어댑터 콜러블 등록하기</a></li>
</ul>
</li>
<li><a class="reference internal" href="#converting-sqlite-values-to-custom-python-types">SQLite 값을 사용자 정의 파이썬 형으로 변환하기</a></li>
<li><a class="reference internal" href="#default-adapters-and-converters">기본 어댑터와 변환기</a></li>
</ul>
</li>
<li><a class="reference internal" href="#controlling-transactions">트랜잭션 제어</a></li>
<li><a class="reference internal" href="#using-sqlite3-efficiently">효율적으로 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code> 사용하기</a><ul>
<li><a class="reference internal" href="#using-shortcut-methods">바로 가기 메서드 사용하기</a></li>
<li><a class="reference internal" href="#accessing-columns-by-name-instead-of-by-index">인덱스 대신 이름으로 열 액세스하기</a></li>
<li><a class="reference internal" href="#using-the-connection-as-a-context-manager">컨텍스트 관리자로 연결 사용하기</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-issues">일반적인 문제</a><ul>
<li><a class="reference internal" href="#multithreading">다중 스레드</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="dbm.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm</span></code> --- 유닉스 &quot;데이터베이스&quot; 인터페이스</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="archiving.html"
                        title="다음 장">데이터 압축 및 보관</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="archiving.html" title="데이터 압축 및 보관"
             >다음</a> |</li>
        <li class="right" >
          <a href="dbm.html" title="dbm --- 유닉스 &#34;데이터베이스&#34; 인터페이스"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="persistence.html" >데이터 지속성</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>