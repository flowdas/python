
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>코루틴과 태스크 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="Streams" href="asyncio-stream.html" />
    <link rel="prev" title="asyncio --- 비동기 I/O" href="asyncio.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://python.flowdas.com/library/asyncio-task.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-stream.html" title="Streams"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="asyncio.html" title="asyncio --- 비동기 I/O"
             accesskey="P">이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U"><code class="docutils literal notranslate"><span class="pre">asyncio</span></code> --- 비동기 I/O</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="coroutines-and-tasks">
<h1>코루틴과 태스크<a class="headerlink" href="#coroutines-and-tasks" title="제목 주소">¶</a></h1>
<p>이 절에서는 코루틴과 태스크로 작업하기위한 고급 asyncio API에 대해 설명합니다.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#coroutines" id="id1">코루틴</a></li>
<li><a class="reference internal" href="#awaitables" id="id2">어웨이터블</a></li>
<li><a class="reference internal" href="#running-an-asyncio-program" id="id3">asyncio 프로그램 실행하기</a></li>
<li><a class="reference internal" href="#creating-tasks" id="id4">태스크 만들기</a></li>
<li><a class="reference internal" href="#sleeping" id="id5">잠자기</a></li>
<li><a class="reference internal" href="#running-tasks-concurrently" id="id6">동시에 태스크 실행하기</a></li>
<li><a class="reference internal" href="#shielding-from-cancellation" id="id7">취소로부터 보호하기</a></li>
<li><a class="reference internal" href="#timeouts" id="id8">시간 제한</a></li>
<li><a class="reference internal" href="#waiting-primitives" id="id9">대기 프리미티브</a></li>
<li><a class="reference internal" href="#scheduling-from-other-threads" id="id10">다른 스레드에서 예약하기</a></li>
<li><a class="reference internal" href="#introspection" id="id11">인트로스팩션</a></li>
<li><a class="reference internal" href="#task-object" id="id12">Task Object</a></li>
<li><a class="reference internal" href="#generator-based-coroutines" id="id13">Generator-based Coroutines</a></li>
</ul>
</div>
<div class="section" id="coroutines">
<span id="coroutine"></span><h2><a class="toc-backref" href="#id1">코루틴</a><a class="headerlink" href="#coroutines" title="제목 주소">¶</a></h2>
<p>async/await 문법으로 선언된 코루틴은 asyncio 응용 프로그램을 작성하는 기본 방법입니다. 예를 들어, 다음 코드 조각(파이썬 3.7 이상 필요)은 &quot;hello&quot;를 인쇄하고, 1초 동안 기다린 다음, &quot;world&quot;를 인쇄합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
<span class="go">hello</span>
<span class="go">world</span>
</pre></div>
</div>
<p>단지 코루틴을 호출하는 것으로 실행되도록 예약하는 것은 아닙니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">()</span>
<span class="go">&lt;coroutine object main at 0x1053bb7c8&gt;</span>
</pre></div>
</div>
<p>코루틴을 실제로 실행하기위해 asyncio가 세 가지 주요 메커니즘을 제공합니다:</p>
<ul>
<li><p class="first">최상위 진입 점 &quot;main()&quot; 함수를 실행하는 <a class="reference internal" href="#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> 함수 (위의 예를 보세요.)</p>
</li>
<li><p class="first">코루틴을 기다리기. 다음 코드 조각은 1초를 기다린 후 &quot;hello&quot;를 인쇄 한 다음 <em>또</em> 2초를 기다린 후 &quot;world&quot;를 인쇄합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">say_after</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">what</span><span class="p">):</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">what</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;started at&#39;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">))</span>

    <span class="k">await</span> <span class="n">say_after</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">say_after</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;finished at&#39;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">))</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p>예상 출력:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">started</span> <span class="n">at</span> <span class="mi">17</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span><span class="mi">52</span>
<span class="n">hello</span>
<span class="n">world</span>
<span class="n">finished</span> <span class="n">at</span> <span class="mi">17</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span><span class="mi">55</span>
</pre></div>
</div>
</li>
<li><p class="first">코루틴을 asyncio <a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">태스크</span></code></a>로 동시에 실행하는 <a class="reference internal" href="#asyncio.create_task" title="asyncio.create_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_task()</span></code></a> 함수.</p>
<p>위의 예를 수정해서 두 개의 <code class="docutils literal notranslate"><span class="pre">say_after</span></code> 코루틴을 <em>동시에</em> 실행 해 봅시다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">task1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span>
        <span class="n">say_after</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">))</span>

    <span class="n">task2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span>
        <span class="n">say_after</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;started at&#39;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">))</span>

    <span class="c1"># 두 태스크가 모두 완료할 때까지 기다립니다 (2초 정도 걸려야 합니다.)</span>
    <span class="k">await</span> <span class="n">task1</span>
    <span class="k">await</span> <span class="n">task2</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;finished at&#39;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>예상 출력은 이제 코드 조각이 이전보다 1초 빠르게 실행되었음을 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">started</span> <span class="n">at</span> <span class="mi">17</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">32</span>
<span class="n">hello</span>
<span class="n">world</span>
<span class="n">finished</span> <span class="n">at</span> <span class="mi">17</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="mi">34</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="awaitables">
<span id="asyncio-awaitables"></span><h2><a class="toc-backref" href="#id2">어웨이터블</a><a class="headerlink" href="#awaitables" title="제목 주소">¶</a></h2>
<p>우리는 객체가 <a class="reference internal" href="../reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식에서 사용될 수 있을 때 <strong>어웨이터블</strong> 객체라고 말합니다. 많은 asyncio API는 어웨이터블을 받아들이도록 설계되었습니다.</p>
<p><em>어웨이터블</em> 객체에는 세가지 주요 유형이 있습니다: <strong>코루틴</strong>, <strong>태스크</strong> 및 <strong>퓨처</strong>.</p>
<p class="rubric">코루틴</p>
<p>파이썬 코루틴은 <em>어웨이터블</em>이므로 다른 코루틴에서 기다릴 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">nested</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">42</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 단지 &quot;nested()&quot;를 호출하면 아무 일도 일어나지 않습니다.</span>
    <span class="c1"># 코루틴 객체가 생성되었지만 기다리지 않았습니다. 따라서 *전혀 실행되지 않습니다*.</span>
    <span class="n">nested</span><span class="p">()</span>

    <span class="c1"># 이제 다른 식으로 해봅시다, 기다립니다:</span>
    <span class="nb">print</span><span class="p">(</span><span class="k">await</span> <span class="n">nested</span><span class="p">())</span>  <span class="c1"># &quot;42&quot;를 인쇄합니다.</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition important">
<p class="first admonition-title">중요</p>
<p>이 설명서에서 &quot;코루틴&quot; 이라는 용어는 두 가지 밀접한 관련 개념에 사용될 수 있습니다:</p>
<ul class="last simple">
<li><em>코루틴 함수</em>: <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 함수;</li>
<li><em>코루틴 객체</em>: <em>코루틴 함수</em>를 호출하여 반환된 객체.</li>
</ul>
</div>
<p>asyncio는 레거시 <a class="reference internal" href="#asyncio-generator-based-coro"><span class="std std-ref">제너레이터 기반</span></a> 코루틴도 지원합니다.</p>
<p class="rubric">태스크</p>
<p><em>태스크</em>는 코루틴을 <em>동시에</em> 예약하는 데 사용됩니다.</p>
<p>코루틴이 <a class="reference internal" href="#asyncio.create_task" title="asyncio.create_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_task()</span></code></a>와 같은 함수를 사용하여 <em>태스크</em>로 싸일 때 코루틴은 곧 실행되도록 자동으로 예약됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">nested</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">42</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># nested()가 곧 &quot;main()&quot;과 동시에 실행되도록 예약합니다.</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">nested</span><span class="p">())</span>

    <span class="c1"># &quot;task&quot;는 이제 &quot;nested()&quot;를 취소하는 데 사용하거나,</span>
    <span class="c1"># 단순히 완료할 때까지 기다릴 수 있습니다:</span>
    <span class="k">await</span> <span class="n">task</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p class="rubric">퓨처</p>
<p><a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>는 비동기 연산의 <strong>최종 결과</strong>를 나타내는 특별한 <strong>저수준</strong> 어웨이터블 객체입니다.</p>
<p>Future 객체를 <em>기다릴</em> 때, 그것은 코루틴이 Future가 다른 곳에서 해결 될 때까지 기다릴 것임을 뜻합니다.</p>
<p>콜백 기반 코드를 async/await와 함께 사용하려면 asyncio의 Future 객체가 필요합니다.</p>
<p>일반적으로 응용 프로그램 수준 코드에서 Future 객체를 만들 <strong>필요는 없습니다</strong>.</p>
<p>때때로 라이브러리와 일부 asyncio API에 의해 노출되는 Future 객체를 기다릴 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">function_that_returns_a_future_object</span><span class="p">()</span>

    <span class="c1"># 이것도 유효합니다:</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="n">function_that_returns_a_future_object</span><span class="p">(),</span>
        <span class="n">some_python_coroutine</span><span class="p">()</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Future 객체를 반환하는 저수준 함수의 좋은 예는 <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a>입니다.</p>
</div>
<div class="section" id="running-an-asyncio-program">
<h2><a class="toc-backref" href="#id3">asyncio 프로그램 실행하기</a><a class="headerlink" href="#running-an-asyncio-program" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="asyncio.run">
<code class="descclassname">asyncio.</code><code class="descname">run</code><span class="sig-paren">(</span><em>coro</em>, <em>*</em>, <em>debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.run" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 전달된 코루틴을 실행하고, asyncio 이벤트 루프와 <em>비동기 제너레이터의 파이널리제이션</em>을 관리합니다.</p>
<p>다른 asyncio 이벤트 루프가 같은 스레드에서 실행 중일 때, 이 함수를 호출 할 수 없습니다.</p>
<p><em>debug</em>이 <code class="docutils literal notranslate"><span class="pre">True</span></code>면, 이벤트 루프가 디버그 모드로 실행됩니다.</p>
<p>이 함수는 항상 새 이벤트 루프를 만들고 끝에 이벤트 루프를 닫습니다. asyncio 프로그램의 메인 진입 지점으로 사용해야하고, 이상적으로는 한 번만 호출해야합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가: </span><strong>중요:</strong> 이 함수는 파이썬 3.7에서 <a class="reference internal" href="../glossary.html#term-provisional-api"><span class="xref std std-term">잠정적으로</span></a> asyncio에 추가되었습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="creating-tasks">
<h2><a class="toc-backref" href="#id4">태스크 만들기</a><a class="headerlink" href="#creating-tasks" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="asyncio.create_task">
<code class="descclassname">asyncio.</code><code class="descname">create_task</code><span class="sig-paren">(</span><em>coro</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.create_task" title="정의 주소">¶</a></dt>
<dd><p><em>coro</em> <a class="reference internal" href="#coroutine"><span class="std std-ref">코루틴</span></a>을 <a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>로 감싸고 실행을 예약합니다. Task 객체를 반환합니다.</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a>에 의해 반환 된 루프에서 태스크가 실행되고, 현재 스레드에 실행중인 루프가없으면 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생합니다.</p>
<p>이 함수는 <strong>파이썬 3.7에서 추가되었습니다</strong>. 파이썬 3.7 이전 버전에서는, 대신 저수준 <a class="reference internal" href="asyncio-future.html#asyncio.ensure_future" title="asyncio.ensure_future"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.ensure_future()</span></code></a> 함수를 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">coro</span><span class="p">():</span>
    <span class="o">...</span>

<span class="c1"># 파이썬 3.7+ 에서</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">coro</span><span class="p">())</span>
<span class="o">...</span>

<span class="c1"># 이것은 모든 파이썬 버전에서 작동하지만 읽기 쉽지 않습니다</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">coro</span><span class="p">())</span>
<span class="o">...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="sleeping">
<h2><a class="toc-backref" href="#id5">잠자기</a><a class="headerlink" href="#sleeping" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="asyncio.sleep">
<em class="property">coroutine </em><code class="descclassname">asyncio.</code><code class="descname">sleep</code><span class="sig-paren">(</span><em>delay</em>, <em>result=None</em>, <em>*</em>, <em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.sleep" title="정의 주소">¶</a></dt>
<dd><p><em>delay</em> 초 동안 블록합니다.</p>
<p><em>result</em>가 제공되면, 코루틴이 완료될 때 호출자에게 반환됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">sleep()</span></code>은 항상 현재 태스크를 일시 중단해서 다른 태스크를 실행할 수 있도록 합니다.</p>
<p><em>loop</em> 인자는 폐지되었고 파이썬 3.10에서 삭제 예정입니다.</p>
<p id="asyncio-example-sleep">5초 동안 현재 날짜를 매초 표시하는 코루틴의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">display_date</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">end_time</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">display_date</span><span class="p">())</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="running-tasks-concurrently">
<h2><a class="toc-backref" href="#id6">동시에 태스크 실행하기</a><a class="headerlink" href="#running-tasks-concurrently" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="asyncio.gather">
<em class="property">awaitable </em><code class="descclassname">asyncio.</code><code class="descname">gather</code><span class="sig-paren">(</span><em>*aws</em>, <em>loop=None</em>, <em>return_exceptions=False</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.gather" title="정의 주소">¶</a></dt>
<dd><p><em>aws</em> 시퀀스에 있는 <a class="reference internal" href="#asyncio-awaitables"><span class="std std-ref">어웨이터블 객체</span></a>를 <em>동시에</em> 실행합니다.</p>
<p><em>aws</em>에 있는 어웨이터블이 코루틴이면 자동으로 태스크로 예약됩니다.</p>
<p>모든 어웨이터블이 성공적으로 완료되면, 결과는 반환 된 값들이 합쳐진 리스트입니다. 결과 값의 순서는 <em>aws</em>에 있는 어웨이터블의 순서와 일치합니다.</p>
<p><em>return_exceptions</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>(기본값)면, 첫 번째 발생한 예외가 <code class="docutils literal notranslate"><span class="pre">gather()</span></code>를 기다리는 태스크로 즉시 전파됩니다. <em>aws</em> 시퀀스의 다른 어웨이터블은 <strong>취소되지 않고</strong> 계속 실행됩니다.</p>
<p><em>return_exceptions</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>면, 예외는 성공적인 결과처럼 처리되고, 결과 리스트에 집계됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">gather()</span></code>가 <em>취소되면</em>, 모든 제출된 (아직 완료되지 않은) 어웨이터블도 <em>취소됩니다</em>.</p>
<p><em>aws</em> 시퀀스의 Task나 Future가 <em>취소되면</em>, 그 것이 <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a>를 일으킨 것처럼 처리됩니다 -- 이때 <code class="docutils literal notranslate"><span class="pre">gather()</span></code> 호출은 취소되지 <strong>않습니다</strong>. 이것은 제출 된 태스크/퓨처 하나를 취소하는 것이 다른 다른 태스크/퓨처를 취소하게되는 것을 막기 위한 것입니다.</p>
<p id="asyncio-example-gather">예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Task </span><span class="si">{name}</span><span class="s2">: Compute factorial(</span><span class="si">{i}</span><span class="s2">)...&quot;</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">*=</span> <span class="n">i</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Task </span><span class="si">{name}</span><span class="s2">: factorial(</span><span class="si">{number}</span><span class="s2">) = </span><span class="si">{f}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 3개의 호출을 *동시에* 예약합니다:</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
        <span class="n">factorial</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
    <span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

<span class="c1"># 기대되는 출력:</span>
<span class="c1">#</span>
<span class="c1">#     Task A: Compute factorial(2)...</span>
<span class="c1">#     Task B: Compute factorial(2)...</span>
<span class="c1">#     Task C: Compute factorial(2)...</span>
<span class="c1">#     Task A: factorial(2) = 2</span>
<span class="c1">#     Task B: Compute factorial(3)...</span>
<span class="c1">#     Task C: Compute factorial(3)...</span>
<span class="c1">#     Task B: factorial(3) = 6</span>
<span class="c1">#     Task C: Compute factorial(4)...</span>
<span class="c1">#     Task C: factorial(4) = 24</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>gather</em> 자체가 취소되면, <em>return_exceptions</em>와 관계없이 취소가 전파됩니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="shielding-from-cancellation">
<h2><a class="toc-backref" href="#id7">취소로부터 보호하기</a><a class="headerlink" href="#shielding-from-cancellation" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="asyncio.shield">
<em class="property">awaitable </em><code class="descclassname">asyncio.</code><code class="descname">shield</code><span class="sig-paren">(</span><em>aw</em>, <em>*</em>, <em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.shield" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio-awaitables"><span class="std std-ref">어웨이터블 객체</span></a>를 <a class="reference internal" href="#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">취소</span></code></a>로부터 보호합니다.</p>
<p><em>aw</em>가 코루틴이면 자동으로 태스크로 예약됩니다.</p>
<p>다음 문장:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="k">await</span> <span class="n">shield</span><span class="p">(</span><span class="n">something</span><span class="p">())</span>
</pre></div>
</div>
<p>은 다음과 동등합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="k">await</span> <span class="n">something</span><span class="p">()</span>
</pre></div>
</div>
<p><em>단</em>, 그 것을 포함하는 코루틴이 취소되면, <code class="docutils literal notranslate"><span class="pre">something()</span></code>에서 실행중인 태스크는 취소되지 않는다는 것만 예외입니다. <code class="docutils literal notranslate"><span class="pre">something()</span></code>의 관점에서는, 취소가 일어나지 않았습니다. 호출자는 여전히 취소되었고, &quot;await&quot; 표현식은 여전히 <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a>를 발생시킵니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">something()</span></code>가 다른 수단(즉, 그 안에서 스스로)에 의해 취소되면, <code class="docutils literal notranslate"><span class="pre">shield()</span></code>도 취소됩니다.</p>
<p>취소를 완전히 무시하려면(권장되지 않습니다), 다음과 같이 <code class="docutils literal notranslate"><span class="pre">shield()</span></code> 함수를 try/except 절과 결합해야합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="k">await</span> <span class="n">shield</span><span class="p">(</span><span class="n">something</span><span class="p">())</span>
<span class="k">except</span> <span class="n">CancelledError</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="timeouts">
<h2><a class="toc-backref" href="#id8">시간 제한</a><a class="headerlink" href="#timeouts" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="asyncio.wait_for">
<em class="property">coroutine </em><code class="descclassname">asyncio.</code><code class="descname">wait_for</code><span class="sig-paren">(</span><em>aw</em>, <em>timeout</em>, <em>*</em>, <em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.wait_for" title="정의 주소">¶</a></dt>
<dd><p><em>aw</em> <a class="reference internal" href="#asyncio-awaitables"><span class="std std-ref">어웨이터블</span></a>이 제한된 시간내에 완료 될 때까지 기다립니다.</p>
<p><em>aw</em>가 코루틴이면 자동으로 태스크로 예약됩니다.</p>
<p><em>timeout</em>은 <code class="docutils literal notranslate"><span class="pre">None</span></code> 또는 대기 할 float 나 int 초 수입니다. <em>timeout</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면 퓨처가 완료 될 때까지 블록합니다.</p>
<p>시간 초과가 발생하면, 태스크를 취소하고 <a class="reference internal" href="asyncio-exceptions.html#asyncio.TimeoutError" title="asyncio.TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.TimeoutError</span></code></a>를 발생시킵니다.</p>
<p>태스크 <a class="reference internal" href="#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">취소</span></code></a>를 피하려면, <a class="reference internal" href="#asyncio.shield" title="asyncio.shield"><code class="xref py py-func docutils literal notranslate"><span class="pre">shield()</span></code></a>로 감싸십시오.</p>
<p>이 함수는 퓨처가 실제로 취소 될 때까지 대기하므로, 총 대기 시간이 <em>timeout</em>을 초과 할 수 있습니다.</p>
<p>대기가 취소되면, 퓨처 <em>aw</em>도 취소됩니다.</p>
<p><em>loop</em> 인자는 폐지되었고 파이썬 3.10에서 삭제 예정입니다.</p>
<p id="asyncio-example-waitfor">예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">eternity</span><span class="p">():</span>
    <span class="c1"># 1시간 동안 잠잡니다</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;yay!&#39;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 최대 1초간 대기합니다</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">eternity</span><span class="p">(),</span> <span class="n">timeout</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;timeout!&#39;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

<span class="c1"># 기대되는 출력:</span>
<span class="c1">#</span>
<span class="c1">#     timeout!</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>시간 초과로 인해 <em>aw</em>가 취소되면, <code class="docutils literal notranslate"><span class="pre">wait_for</span></code>는 <em>aw</em>가 취소 될 때까지 대기합니다. 이전에는 <a class="reference internal" href="asyncio-exceptions.html#asyncio.TimeoutError" title="asyncio.TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.TimeoutError</span></code></a>가 즉시 발생했습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="waiting-primitives">
<h2><a class="toc-backref" href="#id9">대기 프리미티브</a><a class="headerlink" href="#waiting-primitives" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="asyncio.wait">
<em class="property">coroutine </em><code class="descclassname">asyncio.</code><code class="descname">wait</code><span class="sig-paren">(</span><em>aws</em>, <em>*</em>, <em>loop=None</em>, <em>timeout=None</em>, <em>return_when=ALL_COMPLETED</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.wait" title="정의 주소">¶</a></dt>
<dd><p><em>aws</em> 집합에 있는 <a class="reference internal" href="#asyncio-awaitables"><span class="std std-ref">어웨이터블 객체</span></a>를 동시에 실행하고, <em>return_when</em>에 의해 지정된 조건이 만족될 때까지 블록합니다.</p>
<p>If any awaitable in <em>aws</em> is a coroutine, it is automatically
scheduled as a Task.  Passing coroutines objects to
<code class="docutils literal notranslate"><span class="pre">wait()</span></code> directly is deprecated as it leads to
<a class="reference internal" href="#asyncio-example-wait-coroutine"><span class="std std-ref">confusing behavior</span></a>.</p>
<p>두 집합의 태스크/퓨처를 반환합니다: <code class="docutils literal notranslate"><span class="pre">(done,</span> <span class="pre">pending)</span></code>.</p>
<p>사용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">done</span><span class="p">,</span> <span class="n">pending</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
</pre></div>
</div>
<p><em>loop</em> 인자는 폐지되었고 파이썬 3.10에서 삭제 예정입니다.</p>
<p><em>timeout</em>(float나 int)을 지정하면, 반환하기 전에 대기 할 최대 시간(초)을 제어할 수 있습니다.</p>
<p>이 함수는 <a class="reference internal" href="asyncio-exceptions.html#asyncio.TimeoutError" title="asyncio.TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.TimeoutError</span></code></a>를 발생시키지 않음에 유의하십시오. 시간 초과가 발생할 때 완료되지 않은 퓨처나 태스크는 단순히 두 번째 집합으로 반환됩니다.</p>
<p><em>return_when</em>는 이 함수가 언제 반환해야하는지 나타냅니다. 다음 상수 중 하나여야 합니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">상수</th>
<th class="head">설명</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="xref py py-const docutils literal notranslate"><span class="pre">FIRST_COMPLETED</span></code></td>
<td>퓨처가 하나라도 끝나거나 취소될 때 함수가 반환됩니다.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-const docutils literal notranslate"><span class="pre">FIRST_EXCEPTION</span></code></td>
<td>퓨처가 하나라도 예외를 일으켜 끝나면 함수가 반환됩니다. 어떤 퓨처도 예외를 일으키지 않으면 <code class="xref py py-const docutils literal notranslate"><span class="pre">ALL_COMPLETED</span></code>와 같습니다.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-const docutils literal notranslate"><span class="pre">ALL_COMPLETED</span></code></td>
<td>모든 퓨처가 끝나거나 취소되면 함수가 반환됩니다.</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#asyncio.wait_for" title="asyncio.wait_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_for()</span></code></a>와 달리, <code class="docutils literal notranslate"><span class="pre">wait()</span></code>는 시간 초과가 발생할 때 퓨처를 취소하지 않습니다.</p>
<div class="admonition note" id="asyncio-example-wait-coroutine">
<p class="first admonition-title">주석</p>
<p><code class="docutils literal notranslate"><span class="pre">wait()</span></code>는 코루틴을 태스크로 자동 예약하고, 나중에 묵시적으로 생성된 Task 객체를 <code class="docutils literal notranslate"><span class="pre">(done,</span> <span class="pre">pending)</span></code> 집합으로 반환합니다. 따라서 다음 코드는 기대한대로 작동하지 않습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">42</span>

<span class="n">coro</span> <span class="o">=</span> <span class="n">foo</span><span class="p">()</span>
<span class="n">done</span><span class="p">,</span> <span class="n">pending</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">({</span><span class="n">coro</span><span class="p">})</span>

<span class="k">if</span> <span class="n">coro</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
    <span class="c1"># 이 분기는 절대 실행되지 않습니다!</span>
</pre></div>
</div>
<p>위의 조각을 고치는 방법은 다음과 같습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">42</span>

<span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">foo</span><span class="p">())</span>
<span class="n">done</span><span class="p">,</span> <span class="n">pending</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">({</span><span class="n">task</span><span class="p">})</span>

<span class="k">if</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
    <span class="c1"># 이제 모든 것이 예상대로 작동합니다.</span>
</pre></div>
</div>
<p class="last">코루틴 객체를 <code class="docutils literal notranslate"><span class="pre">wait()</span></code>로 직접 전달하는 것은 폐지되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="asyncio.as_completed">
<code class="descclassname">asyncio.</code><code class="descname">as_completed</code><span class="sig-paren">(</span><em>aws</em>, <em>*</em>, <em>loop=None</em>, <em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.as_completed" title="정의 주소">¶</a></dt>
<dd><p><em>aws</em> 집합에 있는 <a class="reference internal" href="#asyncio-awaitables"><span class="std std-ref">어웨이터블 객체</span></a>를 동시에 실행합니다. <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a> 객체의 이터레이터를 반환합니다. 반환된 각 Future 객체는 남아있는 어웨이터블 집합의 가장 빠른 결과를 나타냅니다.</p>
<p>모든 퓨처가 완료되기 전에 시간 초과가 발생하면 <a class="reference internal" href="asyncio-exceptions.html#asyncio.TimeoutError" title="asyncio.TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">asyncio.TimeoutError</span></code></a>를 발생시킵니다.</p>
<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">aws</span><span class="p">):</span>
    <span class="n">earliest_result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">f</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="scheduling-from-other-threads">
<h2><a class="toc-backref" href="#id10">다른 스레드에서 예약하기</a><a class="headerlink" href="#scheduling-from-other-threads" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="asyncio.run_coroutine_threadsafe">
<code class="descclassname">asyncio.</code><code class="descname">run_coroutine_threadsafe</code><span class="sig-paren">(</span><em>coro</em>, <em>loop</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.run_coroutine_threadsafe" title="정의 주소">¶</a></dt>
<dd><p>주어진 이벤트 루프에 코루틴을 제출합니다. 스레드 안전합니다.</p>
<p>다른 OS 스레드에서 결과를 기다리는 <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Future" title="concurrent.futures.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.Future</span></code></a>를 반환합니다.</p>
<p>이 함수는 이벤트 루프가 실행중인 스레드가 아닌, 다른 OS 스레드에서 호출하기위한 것입니다. 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 코루틴을 만듭니다</span>
<span class="n">coro</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># 주어진 루프로 코루틴을 제출합니다</span>
<span class="n">future</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">run_coroutine_threadsafe</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># 선택적 시간제한 인자로 결과를 기다립니다</span>
<span class="k">assert</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p>코루틴에서 예외가 발생하면, 반환된 Future에 통지됩니다. 또한 이벤트 루프에서 태스크를 취소하는 데 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
<span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The coroutine took too long, cancelling the task...&#39;</span><span class="p">)</span>
    <span class="n">future</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The coroutine raised an exception: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The coroutine returned: </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
<p>설명서의 <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">동시성과 다중 스레드</span></a> 절을 참조하십시오.</p>
<p>다른 asyncio 함수와 달리, 이 함수는 <em>loop</em> 인자가 명시적으로 전달되어야합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5.1에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="introspection">
<h2><a class="toc-backref" href="#id11">인트로스팩션</a><a class="headerlink" href="#introspection" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="asyncio.current_task">
<code class="descclassname">asyncio.</code><code class="descname">current_task</code><span class="sig-paren">(</span><em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.current_task" title="정의 주소">¶</a></dt>
<dd><p>Return the currently running <a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> instance, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if
no task is running.</p>
<p>If <em>loop</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code> <a class="reference internal" href="asyncio-eventloop.html#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a> is used to get
the current loop.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="asyncio.all_tasks">
<code class="descclassname">asyncio.</code><code class="descname">all_tasks</code><span class="sig-paren">(</span><em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.all_tasks" title="정의 주소">¶</a></dt>
<dd><p>Return a set of not yet finished <a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> objects run by
the loop.</p>
<p>If <em>loop</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, <a class="reference internal" href="asyncio-eventloop.html#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a> is used for getting
current loop.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="task-object">
<h2><a class="toc-backref" href="#id12">Task Object</a><a class="headerlink" href="#task-object" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="asyncio.Task">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">Task</code><span class="sig-paren">(</span><em>coro</em>, <em>*</em>, <em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task" title="정의 주소">¶</a></dt>
<dd><p>A <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future-like</span></code></a> object that runs a Python
<a class="reference internal" href="#coroutine"><span class="std std-ref">coroutine</span></a>.  Not thread-safe.</p>
<p>Tasks are used to run coroutines in event loops.
If a coroutine awaits on a Future, the Task suspends
the execution of the coroutine and waits for the completion
of the Future.  When the Future is <em>done</em>, the execution of
the wrapped coroutine resumes.</p>
<p>Event loops use cooperative scheduling: an event loop runs
one Task at a time.  While a Task awaits for the completion of a
Future, the event loop runs other Tasks, callbacks, or performs
IO operations.</p>
<p>Use the high-level <a class="reference internal" href="#asyncio.create_task" title="asyncio.create_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_task()</span></code></a> function to create
Tasks, or the low-level <a class="reference internal" href="asyncio-eventloop.html#asyncio.loop.create_task" title="asyncio.loop.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_task()</span></code></a> or
<a class="reference internal" href="asyncio-future.html#asyncio.ensure_future" title="asyncio.ensure_future"><code class="xref py py-func docutils literal notranslate"><span class="pre">ensure_future()</span></code></a> functions.  Manual instantiation of Tasks
is discouraged.</p>
<p>To cancel a running Task use the <a class="reference internal" href="#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel()</span></code></a> method.  Calling it
will cause the Task to throw a <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> exception into
the wrapped coroutine.  If a coroutine is awaiting on a Future
object during cancellation, the Future object will be cancelled.</p>
<p><a class="reference internal" href="#asyncio.Task.cancelled" title="asyncio.Task.cancelled"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancelled()</span></code></a> can be used to check if the Task was cancelled.
The method returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the wrapped coroutine did not
suppress the <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> exception and was actually
cancelled.</p>
<p><a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a> inherits from <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a> all of its
APIs except <a class="reference internal" href="asyncio-future.html#asyncio.Future.set_result" title="asyncio.Future.set_result"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.set_result()</span></code></a> and
<a class="reference internal" href="asyncio-future.html#asyncio.Future.set_exception" title="asyncio.Future.set_exception"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.set_exception()</span></code></a>.</p>
<p>Tasks support the <a class="reference internal" href="contextvars.html#module-contextvars" title="contextvars: Context Variables"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a> module.  When a Task
is created it copies the current context and later runs its
coroutine in the copied context.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>Added support for the <a class="reference internal" href="contextvars.html#module-contextvars" title="contextvars: Context Variables"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a> module.</p>
</div>
<dl class="method">
<dt id="asyncio.Task.cancel">
<code class="descname">cancel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.cancel" title="정의 주소">¶</a></dt>
<dd><p>Request the Task to be cancelled.</p>
<p>This arranges for a <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> exception to be thrown
into the wrapped coroutine on the next cycle of the event loop.</p>
<p>The coroutine then has a chance to clean up or even deny the
request by suppressing the exception with a <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> ...
... <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">CancelledError</span></code> ... <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> block.
Therefore, unlike <a class="reference internal" href="asyncio-future.html#asyncio.Future.cancel" title="asyncio.Future.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.cancel()</span></code></a>, <a class="reference internal" href="#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.cancel()</span></code></a> does
not guarantee that the Task will be cancelled, although
suppressing cancellation completely is not common and is actively
discouraged.</p>
<p id="asyncio-example-task-cancel">The following example illustrates how coroutines can intercept
the cancellation request:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">cancel_me</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cancel_me(): before sleep&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Wait for 1 hour</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cancel_me(): cancel sleep&#39;</span><span class="p">)</span>
        <span class="k">raise</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cancel_me(): after sleep&#39;</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Create a &quot;cancel_me&quot; Task</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">cancel_me</span><span class="p">())</span>

    <span class="c1"># Wait for 1 second</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">task</span>
    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;main(): cancel_me is cancelled now&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>

<span class="c1"># Expected output:</span>
<span class="c1">#</span>
<span class="c1">#     cancel_me(): before sleep</span>
<span class="c1">#     cancel_me(): cancel sleep</span>
<span class="c1">#     cancel_me(): after sleep</span>
<span class="c1">#     main(): cancel_me is cancelled now</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Task.cancelled">
<code class="descname">cancelled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.cancelled" title="정의 주소">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the Task is <em>cancelled</em>.</p>
<p>The Task is <em>cancelled</em> when the cancellation was requested with
<a class="reference internal" href="#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel()</span></code></a> and the wrapped coroutine propagated the
<a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> exception thrown into it.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Task.done">
<code class="descname">done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.done" title="정의 주소">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the Task is <em>done</em>.</p>
<p>A Task is <em>done</em> when the wrapped coroutine either returned
a value, raised an exception, or the Task was cancelled.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Task.result">
<code class="descname">result</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.result" title="정의 주소">¶</a></dt>
<dd><p>Return the result of the Task.</p>
<p>If the Task is <em>done</em>, the result of the wrapped coroutine
is returned (or if the coroutine raised an exception, that
exception is re-raised.)</p>
<p>If the Task has been <em>cancelled</em>, this method raises
a <a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> exception.</p>
<p>If the Task's result isn't yet available, this method raises
a <a class="reference internal" href="asyncio-exceptions.html#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidStateError</span></code></a> exception.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Task.exception">
<code class="descname">exception</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.exception" title="정의 주소">¶</a></dt>
<dd><p>Return the exception of the Task.</p>
<p>If the wrapped coroutine raised an exception that exception
is returned.  If the wrapped coroutine returned normally
this method returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>If the Task has been <em>cancelled</em>, this method raises a
<a class="reference internal" href="asyncio-exceptions.html#asyncio.CancelledError" title="asyncio.CancelledError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CancelledError</span></code></a> exception.</p>
<p>If the Task isn't <em>done</em> yet, this method raises an
<a class="reference internal" href="asyncio-exceptions.html#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidStateError</span></code></a> exception.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Task.add_done_callback">
<code class="descname">add_done_callback</code><span class="sig-paren">(</span><em>callback</em>, <em>*</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.add_done_callback" title="정의 주소">¶</a></dt>
<dd><p>Add a callback to be run when the Task is <em>done</em>.</p>
<p>This method should only be used in low-level callback-based code.</p>
<p>See the documentation of <a class="reference internal" href="asyncio-future.html#asyncio.Future.add_done_callback" title="asyncio.Future.add_done_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.add_done_callback()</span></code></a>
for more details.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Task.remove_done_callback">
<code class="descname">remove_done_callback</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.remove_done_callback" title="정의 주소">¶</a></dt>
<dd><p>Remove <em>callback</em> from the callbacks list.</p>
<p>This method should only be used in low-level callback-based code.</p>
<p>See the documentation of <a class="reference internal" href="asyncio-future.html#asyncio.Future.remove_done_callback" title="asyncio.Future.remove_done_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Future.remove_done_callback()</span></code></a>
for more details.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Task.get_stack">
<code class="descname">get_stack</code><span class="sig-paren">(</span><em>*</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.get_stack" title="정의 주소">¶</a></dt>
<dd><p>Return the list of stack frames for this Task.</p>
<p>If the wrapped coroutine is not done, this returns the stack
where it is suspended.  If the coroutine has completed
successfully or was cancelled, this returns an empty list.
If the coroutine was terminated by an exception, this returns
the list of traceback frames.</p>
<p>The frames are always ordered from oldest to newest.</p>
<p>Only one stack frame is returned for a suspended coroutine.</p>
<p>The optional <em>limit</em> argument sets the maximum number of frames
to return; by default all available frames are returned.
The ordering of the returned list differs depending on whether
a stack or a traceback is returned: the newest frames of a
stack are returned, but the oldest frames of a traceback are
returned.  (This matches the behavior of the traceback module.)</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Task.print_stack">
<code class="descname">print_stack</code><span class="sig-paren">(</span><em>*</em>, <em>limit=None</em>, <em>file=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.print_stack" title="정의 주소">¶</a></dt>
<dd><p>Print the stack or traceback for this Task.</p>
<p>This produces output similar to that of the traceback module
for the frames retrieved by <a class="reference internal" href="#asyncio.Task.get_stack" title="asyncio.Task.get_stack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_stack()</span></code></a>.</p>
<p>The <em>limit</em> argument is passed to <a class="reference internal" href="#asyncio.Task.get_stack" title="asyncio.Task.get_stack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_stack()</span></code></a> directly.</p>
<p>The <em>file</em> argument is an I/O stream to which the output
is written; by default output is written to <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a>.</p>
</dd></dl>

<dl class="classmethod">
<dt id="asyncio.Task.all_tasks">
<em class="property">classmethod </em><code class="descname">all_tasks</code><span class="sig-paren">(</span><em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.all_tasks" title="정의 주소">¶</a></dt>
<dd><p>Return a set of all tasks for an event loop.</p>
<p>By default all tasks for the current event loop are returned.
If <em>loop</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the <a class="reference internal" href="asyncio-eventloop.html#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a> function
is used to get the current loop.</p>
<p>This method is <strong>deprecated</strong> and will be removed in
Python 3.9.  Use the <a class="reference internal" href="#asyncio.all_tasks" title="asyncio.all_tasks"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.all_tasks()</span></code></a> function instead.</p>
</dd></dl>

<dl class="classmethod">
<dt id="asyncio.Task.current_task">
<em class="property">classmethod </em><code class="descname">current_task</code><span class="sig-paren">(</span><em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.current_task" title="정의 주소">¶</a></dt>
<dd><p>Return the currently running task or <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>If <em>loop</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the <a class="reference internal" href="asyncio-eventloop.html#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a> function
is used to get the current loop.</p>
<p>This method is <strong>deprecated</strong> and will be removed in
Python 3.9.  Use the <a class="reference internal" href="#asyncio.current_task" title="asyncio.current_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.current_task()</span></code></a> function
instead.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="generator-based-coroutines">
<span id="asyncio-generator-based-coro"></span><h2><a class="toc-backref" href="#id13">Generator-based Coroutines</a><a class="headerlink" href="#generator-based-coroutines" title="제목 주소">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">Support for generator-based coroutines is <strong>deprecated</strong> and
is scheduled for removal in Python 3.10.</p>
</div>
<p>Generator-based coroutines predate async/await syntax.  They are
Python generators that use <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> expressions to await
on Futures and other coroutines.</p>
<p>Generator-based coroutines should be decorated with
<a class="reference internal" href="#asyncio.coroutine" title="asyncio.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;asyncio.coroutine</span></code></a>, although this is not
enforced.</p>
<dl class="function">
<dt id="asyncio.coroutine">
<code class="descclassname">&#64;</code><code class="descclassname">asyncio.</code><code class="descname">coroutine</code><a class="headerlink" href="#asyncio.coroutine" title="정의 주소">¶</a></dt>
<dd><p>Decorator to mark generator-based coroutines.</p>
<p>This decorator enables legacy generator-based coroutines to be
compatible with async/await code:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">old_style_coroutine</span><span class="p">():</span>
    <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">await</span> <span class="n">old_style_coroutine</span><span class="p">()</span>
</pre></div>
</div>
<p>This decorator is <strong>deprecated</strong> and is scheduled for removal in
Python 3.10.</p>
<p>This decorator should not be used for <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>
coroutines.</p>
</dd></dl>

<dl class="function">
<dt id="asyncio.iscoroutine">
<code class="descclassname">asyncio.</code><code class="descname">iscoroutine</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.iscoroutine" title="정의 주소">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>obj</em> is a <a class="reference internal" href="#coroutine"><span class="std std-ref">coroutine object</span></a>.</p>
<p>This method is different from <a class="reference internal" href="inspect.html#inspect.iscoroutine" title="inspect.iscoroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.iscoroutine()</span></code></a> because
it returns <code class="docutils literal notranslate"><span class="pre">True</span></code> for generator-based coroutines.</p>
</dd></dl>

<dl class="function">
<dt id="asyncio.iscoroutinefunction">
<code class="descclassname">asyncio.</code><code class="descname">iscoroutinefunction</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.iscoroutinefunction" title="정의 주소">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>func</em> is a <a class="reference internal" href="#coroutine"><span class="std std-ref">coroutine function</span></a>.</p>
<p>This method is different from <a class="reference internal" href="inspect.html#inspect.iscoroutinefunction" title="inspect.iscoroutinefunction"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.iscoroutinefunction()</span></code></a>
because it returns <code class="docutils literal notranslate"><span class="pre">True</span></code> for generator-based coroutine functions
decorated with <a class="reference internal" href="#asyncio.coroutine" title="asyncio.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;coroutine</span></code></a>.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">코루틴과 태스크</a><ul>
<li><a class="reference internal" href="#coroutines">코루틴</a></li>
<li><a class="reference internal" href="#awaitables">어웨이터블</a></li>
<li><a class="reference internal" href="#running-an-asyncio-program">asyncio 프로그램 실행하기</a></li>
<li><a class="reference internal" href="#creating-tasks">태스크 만들기</a></li>
<li><a class="reference internal" href="#sleeping">잠자기</a></li>
<li><a class="reference internal" href="#running-tasks-concurrently">동시에 태스크 실행하기</a></li>
<li><a class="reference internal" href="#shielding-from-cancellation">취소로부터 보호하기</a></li>
<li><a class="reference internal" href="#timeouts">시간 제한</a></li>
<li><a class="reference internal" href="#waiting-primitives">대기 프리미티브</a></li>
<li><a class="reference internal" href="#scheduling-from-other-threads">다른 스레드에서 예약하기</a></li>
<li><a class="reference internal" href="#introspection">인트로스팩션</a></li>
<li><a class="reference internal" href="#task-object">Task Object</a></li>
<li><a class="reference internal" href="#generator-based-coroutines">Generator-based Coroutines</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="asyncio.html"
                        title="이전 장"><code class="docutils literal notranslate"><span class="pre">asyncio</span></code> --- 비동기 I/O</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="asyncio-stream.html"
                        title="다음 장">Streams</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="asyncio-stream.html" title="Streams"
             >다음</a> |</li>
        <li class="right" >
          <a href="asyncio.html" title="asyncio --- 비동기 I/O"
             >이전</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">설명서 </a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >네트워킹과 프로세스 간 통신</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" ><code class="docutils literal notranslate"><span class="pre">asyncio</span></code> --- 비동기 I/O</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2018, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2018, Flowdas &amp; 역자. All rights reserved.
    <br />
    <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.1 를 사용해서 만들었습니다.
    </div>

  </body>
</html>