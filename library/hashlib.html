
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>hashlib --- 보안 해시와 메시지 요약 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="hmac --- 메시지 인증을 위한 키 해싱" href="hmac.html" />
    <link rel="prev" title="암호화 서비스" href="crypto.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/hashlib.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="hmac.html" title="hmac --- 메시지 인증을 위한 키 해싱"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="crypto.html" title="암호화 서비스"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="crypto.html" accesskey="U">암호화 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-hashlib">
<span id="hashlib-secure-hashes-and-message-digests"></span><h1><a class="reference internal" href="#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> --- 보안 해시와 메시지 요약<a class="headerlink" href="#module-hashlib" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/hashlib.py">Lib/hashlib.py</a></p>
<span class="target" id="index-0"></span><hr class="docutils" />
<p>이 모듈은 다양한 보안 해시(secure hash)와 메시지 요약(message digest) 알고리즘에 대한 공통 인터페이스를 구현합니다. RSA의 MD5 알고리즘(Internet <span class="target" id="index-9"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1321.html"><strong>RFC 1321</strong></a>에서 정의됩니다)뿐만 아니라 FIPS 보안 해시 알고리즘 SHA1, SHA224, SHA256, SHA384 및 SHA512(FIPS 180-2에 정의됩니다)가 포함됩니다. &quot;보안 해시&quot;와 &quot;메시지 다이제스트&quot;라는 용어는 서로 바꿔 사용할 수 있습니다. 오래된 알고리즘들은 메시지 요약이라고 불립니다. 현대 용어는 보안 해시입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>adler32나 crc32 해시 함수를 원한다면, <a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 모듈에 있습니다.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>일부 알고리즘은 해시 충돌 약점(hash collision weaknesses)이 알려져 있습니다, 끝에 있는 &quot;더 보기&quot; 섹션을 참조하십시오.</p>
</div>
<div class="section" id="hash-algorithms">
<span id="id1"></span><h2>해시 알고리즘<a class="headerlink" href="#hash-algorithms" title="제목 주소">¶</a></h2>
<p><em class="dfn">해시(hash)</em>의 유형마다 이름이 지정된 생성자 메서드가 있습니다. 모두 같은 간단한 인터페이스를 갖는 해시 객체를 반환합니다. 예를 들어: SHA-256 해시 객체를 만들려면 <code class="xref py py-func docutils literal notranslate"><span class="pre">sha256()</span></code>을 사용하십시오. 이제 <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> 메서드를 사용하여 이 객체에 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>(보통 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>)를 공급할 수 있습니다. 언제든지 <code class="xref py py-meth docutils literal notranslate"><span class="pre">digest()</span></code>나 <code class="xref py py-meth docutils literal notranslate"><span class="pre">hexdigest()</span></code> 메서드를 사용하여 지금까지 공급된 데이터의 연결에 대한 <em class="dfn">요약(digest)</em>을 요청할 수 있습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>다중 스레딩 성능을 향상하기 위해, 객체 생성이나 갱신 시 2047바이트보다 큰 데이터에 대해 파이썬 <a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>이 해제됩니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>해시는 문자가 아닌 바이트에서 작동하므로, 문자열 객체를 <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code>에 공급하는 것은 지원되지 않습니다.</p>
</div>
<p id="index-2">이 모듈에 항상 존재하는 해시 알고리즘의 생성자는 <code class="xref py py-func docutils literal notranslate"><span class="pre">sha1()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha224()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha256()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha384()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha512()</span></code>, <a class="reference internal" href="#hashlib.blake2b" title="hashlib.blake2b"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2b()</span></code></a> 및 <a class="reference internal" href="#hashlib.blake2s" title="hashlib.blake2s"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2s()</span></code></a>입니다. <code class="xref py py-func docutils literal notranslate"><span class="pre">md5()</span></code>는 일반적으로 사용할 수 있지만, 드문 &quot;FIPS 호환&quot; 파이썬 빌드를 사용하는 경우에는 빠지거나 차단될 수 있습니다. 파이썬이 플랫폼에서 사용하는 OpenSSL 라이브러리에 따라 추가 알고리즘을 사용할 수도 있습니다. 대부분의 플랫폼에서 <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_224()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_256()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_384()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_512()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">shake_128()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">shake_256()</span></code>도 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가: </span>SHA3(Keccak)과 SHAKE 생성자 <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_224()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_256()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_384()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_512()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">shake_128()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">shake_256()</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가: </span><a class="reference internal" href="#hashlib.blake2b" title="hashlib.blake2b"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2b()</span></code></a>와 <a class="reference internal" href="#hashlib.blake2s" title="hashlib.blake2s"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2s()</span></code></a>가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>모든 hashlib 생성자는 기본값이 <code class="docutils literal notranslate"><span class="pre">True</span></code>인 키워드 전용 인자 <em>usedforsecurity</em>를 취합니다. 값이 거짓이면 제한된 환경에서 안전하지 않고 차단된 해싱 알고리즘 사용을 허락합니다. <code class="docutils literal notranslate"><span class="pre">False</span></code>는 해싱 알고리즘이 보안 문맥에서 사용되지 않음을 나타냅니다, 예를 들어 암호화가 아닌 단방향 압축 함수로.</p>
<p>Hashlib는 이제 OpenSSL 1.1.1 이상의 SHA3와 SHAKE를 사용합니다.</p>
</div>
<p>예를 들어, 바이트 문자열 <code class="docutils literal notranslate"><span class="pre">b'Nobody</span> <span class="pre">inspects</span> <span class="pre">the</span> <span class="pre">spammish</span> <span class="pre">repetition'</span></code>의 요약을 얻으려면 다음을 수행하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hashlib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Nobody inspects&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot; the spammish repetition&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
<span class="go">b&#39;\x03\x1e\xdd}Ae\x15\x93\xc5\xfe\\\x00o\xa5u+7\xfd\xdf\xf7\xbcN\x84:\xa6\xaf\x0c\x95\x0fK\x94\x06&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">digest_size</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">block_size</span>
<span class="go">64</span>
</pre></div>
</div>
<p>더 압축하면:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hashlib</span><span class="o">.</span><span class="n">sha224</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Nobody inspects the spammish repetition&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;a4337bc45a8fc544c03f52dc550cd6e1e87021bc896588bd79e901e2&#39;</span>
</pre></div>
</div>
<dl class="function">
<dt id="hashlib.new">
<code class="sig-prename descclassname">hashlib.</code><code class="sig-name descname">new</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <span class="optional">[</span><em class="sig-param">data</em>, <span class="optional">]</span><em class="sig-param">*</em>, <em class="sig-param">usedforsecurity=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.new" title="정의 주소">¶</a></dt>
<dd><p>원하는 알고리즘의 문자열 <em>name</em>을 첫 번째 매개 변수로 취하는 일반 생성자입니다. 또한 위에 나열된 해시뿐만 아니라 OpenSSL 라이브러리가 제공할 수 있는 다른 알고리즘에 대한 액세스를 허용하기 위해 존재합니다. 이름 붙은 생성자는 <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a>보다 훨씬 빠르므로 선호해야 합니다.</p>
</dd></dl>

<p>OpenSSL에서 제공하는 알고리즘으로 <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a> 사용하기:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;ripemd160&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Nobody inspects the spammish repetition&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;cc4a5ce1b3df48aec5d22d1f16b894a0b894eccc&#39;</span>
</pre></div>
</div>
<p>hashlib는 다음과 같은 상수 어트리뷰트를 제공합니다:</p>
<dl class="data">
<dt id="hashlib.algorithms_guaranteed">
<code class="sig-prename descclassname">hashlib.</code><code class="sig-name descname">algorithms_guaranteed</code><a class="headerlink" href="#hashlib.algorithms_guaranteed" title="정의 주소">¶</a></dt>
<dd><p>모든 플랫폼에서 이 모듈이 지원하도록 보장된 해시 알고리즘의 이름을 포함하는 집합. 'md5'는 일부 업스트림 공급자가 이를 제외하는 이상한 &quot;FIPS 호환&quot; 파이썬 빌드를 제공하지만, 이 목록에 있음에 유의하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="hashlib.algorithms_available">
<code class="sig-prename descclassname">hashlib.</code><code class="sig-name descname">algorithms_available</code><a class="headerlink" href="#hashlib.algorithms_available" title="정의 주소">¶</a></dt>
<dd><p>실행 중인 파이썬 인터프리터에서 사용 가능한 해시 알고리즘의 이름이 포함된 집합. 이 이름들은 <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a>에 전달될 때 인식됩니다. <a class="reference internal" href="#hashlib.algorithms_guaranteed" title="hashlib.algorithms_guaranteed"><code class="xref py py-attr docutils literal notranslate"><span class="pre">algorithms_guaranteed</span></code></a>는 항상 부분 집합입니다. 이 집합에서 같은 알고리즘이 다른 이름으로 여러 번 나타날 수 있습니다 (OpenSSL 덕분입니다).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<p>다음 값은 생성자가 반환한 해시 객체의 상수 어트리뷰트로 제공됩니다:</p>
<dl class="data">
<dt id="hashlib.hash.digest_size">
<code class="sig-prename descclassname">hash.</code><code class="sig-name descname">digest_size</code><a class="headerlink" href="#hashlib.hash.digest_size" title="정의 주소">¶</a></dt>
<dd><p>결과 해시의 바이트 단위의 크기.</p>
</dd></dl>

<dl class="data">
<dt id="hashlib.hash.block_size">
<code class="sig-prename descclassname">hash.</code><code class="sig-name descname">block_size</code><a class="headerlink" href="#hashlib.hash.block_size" title="정의 주소">¶</a></dt>
<dd><p>해시 알고리즘의 바이트 단위의 내부 블록 크기.</p>
</dd></dl>

<p>해시 객체에는 다음과 같은 어트리뷰트가 있습니다:</p>
<dl class="attribute">
<dt id="hashlib.hash.name">
<code class="sig-prename descclassname">hash.</code><code class="sig-name descname">name</code><a class="headerlink" href="#hashlib.hash.name" title="정의 주소">¶</a></dt>
<dd><p>이 해시의 규범적 이름, 항상 소문자이며 항상 이 유형의 다른 해시를 만들기 위한 <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a>에 대한 매개 변수로 적합합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>name 어트리뷰트는 처음부터 CPython에 존재했지만, 파이썬 3.4 이전에는 공식적으로 지정되지 않아서, 일부 플랫폼에는 존재하지 않을 수 있습니다.</p>
</div>
</dd></dl>

<p>해시 객체에는 다음과 같은 메서드가 있습니다:</p>
<dl class="method">
<dt id="hashlib.hash.update">
<code class="sig-prename descclassname">hash.</code><code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.hash.update" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>로 해시 객체를 갱신합니다. 반복되는 호출은 모든 인자를 이어붙인 단일 호출과 동등합니다: <code class="docutils literal notranslate"><span class="pre">m.update(a);</span> <span class="pre">m.update(b)</span></code>는 <code class="docutils literal notranslate"><span class="pre">m.update(a+b)</span></code>와 동등합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span>파이썬 GIL은 OpenSSL에서 제공하는 해시 알고리즘을 사용할 때 2047바이트보다 큰 데이터에 대한 해시 갱신이 수행되는 동안 다른 스레드를 실행할 수 있도록 해제됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="hashlib.hash.digest">
<code class="sig-prename descclassname">hash.</code><code class="sig-name descname">digest</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.hash.digest" title="정의 주소">¶</a></dt>
<dd><p>지금까지 <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> 메서드에 전달된 데이터의 요약을 반환합니다. 이것은 <a class="reference internal" href="#hashlib.hash.digest_size" title="hashlib.hash.digest_size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">digest_size</span></code></a> 크기의 바이트열 객체이며 0에서 255까지의 전체 범위에 있는 바이트를 포함할 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="hashlib.hash.hexdigest">
<code class="sig-prename descclassname">hash.</code><code class="sig-name descname">hexdigest</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.hash.hexdigest" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#hashlib.hash.digest" title="hashlib.hash.digest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">digest()</span></code></a>와 유사하지만, 요약은 16진수 숫자만 포함하는 두 배 길이의 문자열 객체로 반환됩니다. 전자 메일이나 기타 바이너리가 아닌 환경에서 값을 안전하게 교환하는 데 사용할 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="hashlib.hash.copy">
<code class="sig-prename descclassname">hash.</code><code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.hash.copy" title="정의 주소">¶</a></dt>
<dd><p>해시 객체의 사본(&quot;복제본&quot;)을 반환합니다. 이것은 공통된 초기 부분 문자열을 공유하는 데이터의 요약을 효율적으로 계산하는 데 사용될 수 있습니다.</p>
</dd></dl>

</div>
<div class="section" id="shake-variable-length-digests">
<h2>SHAKE 가변 길이 요약<a class="headerlink" href="#shake-variable-length-digests" title="제목 주소">¶</a></h2>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">shake_128()</span></code>과 <code class="xref py py-func docutils literal notranslate"><span class="pre">shake_256()</span></code> 알고리즘은 length_in_bits//2 (최대 128이나 256) 비트의 보안성으로 가변 길이 요약을 제공합니다. 따라서 digest 메서드에는 길이(length)가 필요합니다. 최대 길이는 SHAKE 알고리즘에 의해 제한되지 않습니다.</p>
<dl class="method">
<dt id="hashlib.shake.digest">
<code class="sig-prename descclassname">shake.</code><code class="sig-name descname">digest</code><span class="sig-paren">(</span><em class="sig-param">length</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.shake.digest" title="정의 주소">¶</a></dt>
<dd><p>지금까지 <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> 메서드에 전달된 데이터의 요약을 반환합니다. 이것은 <em>length</em> 크기의 바이트열 객체이며 0에서 255까지의 전체 범위에 있는 바이트를 포함할 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="hashlib.shake.hexdigest">
<code class="sig-prename descclassname">shake.</code><code class="sig-name descname">hexdigest</code><span class="sig-paren">(</span><em class="sig-param">length</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.shake.hexdigest" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#hashlib.shake.digest" title="hashlib.shake.digest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">digest()</span></code></a>와 유사하지만, 요약은 16진수 숫자만 포함하는 두 배 길이의 문자열 객체로 반환됩니다. 전자 메일이나 기타 바이너리가 아닌 환경에서 값을 안전하게 교환하는 데 사용할 수 있습니다.</p>
</dd></dl>

</div>
<div class="section" id="key-derivation">
<h2>키 파생<a class="headerlink" href="#key-derivation" title="제목 주소">¶</a></h2>
<p>키 파생(key derivation)과 키 확장(key stretching) 알고리즘은 안전한 암호 해싱을 위해 설계되었습니다. <code class="docutils literal notranslate"><span class="pre">sha1(password)</span></code>와 같은 순진한 알고리즘은 무차별 대입 공격에 내성이 없습니다. 올바른 암호 해싱 함수는 조정할 수 있고, 느리고, <a class="reference external" href="https://en.wikipedia.org/wiki/Salt_%28cryptography%29">솔트(salt)</a>를 포함해야 합니다.</p>
<dl class="function">
<dt id="hashlib.pbkdf2_hmac">
<code class="sig-prename descclassname">hashlib.</code><code class="sig-name descname">pbkdf2_hmac</code><span class="sig-paren">(</span><em class="sig-param">hash_name</em>, <em class="sig-param">password</em>, <em class="sig-param">salt</em>, <em class="sig-param">iterations</em>, <em class="sig-param">dklen=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.pbkdf2_hmac" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 PKCS#5 암호 기반 키 파생 함수 2를 제공합니다. 의사 난수 함수로 HMAC을 사용합니다.</p>
<p>문자열 <em>hash_name</em>은 원하는 HMAC을 위한 해시 요약 알고리즘의 이름입니다, 예를 들어 'sha1'이나 'sha256'. <em>password</em>와 <em>salt</em>는 바이트 버퍼로 해석됩니다. 응용 프로그램과 라이브러리는 <em>password</em>를 적당한 길이(예를 들어 1024)로 제한해야 합니다. <em>salt</em>는 적절한 소스(예를 들어 <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a>)로부터 온 약 16이나 그 이상의 바이트여야 합니다.</p>
<p><em>iterations</em>의 수는 해시 알고리즘과 컴퓨팅 성능에 따라 선택해야 합니다. 2013년 현재, 적어도 100,000회의 SHA-256 반복이 제안됩니다.</p>
<p><em>dklen</em>은 파생 키의 길이입니다. <em>dklen</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면 해시 알고리즘 <em>hash_name</em>의 요약 크기가 사용됩니다, 예를 들어 SHA-512의 경우 64.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hashlib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dk</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">pbkdf2_hmac</span><span class="p">(</span><span class="s1">&#39;sha256&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;password&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;salt&#39;</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dk</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;0394a2ede332c9a13eb82e9b24631604c31df978b4e2f0fbd2c549944f9d79a5&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><em>pbkdf2_hmac</em>의 빠른 구현은 OpenSSL에서 제공됩니다. 파이썬 구현은 인라인 버전의 <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a>을 사용합니다. 약 3배 느리고 GIL을 해제하지 않습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="hashlib.scrypt">
<code class="sig-prename descclassname">hashlib.</code><code class="sig-name descname">scrypt</code><span class="sig-paren">(</span><em class="sig-param">password</em>, <em class="sig-param">*</em>, <em class="sig-param">salt</em>, <em class="sig-param">n</em>, <em class="sig-param">r</em>, <em class="sig-param">p</em>, <em class="sig-param">maxmem=0</em>, <em class="sig-param">dklen=64</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.scrypt" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <span class="target" id="index-10"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7914.html"><strong>RFC 7914</strong></a>에 정의된 대로 scrypt 암호 기반 키 파생 함수를 제공합니다.</p>
<p><em>password</em>와 <em>salt</em>는 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>여야 합니다. 응용 프로그램과 라이브러리는 <em>password</em>를 적당한 길이(예를 들어 1024)로 제한해야 합니다. <em>salt</em>는 적절한 소스(예를 들어 <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a>)로부터 온 약 16이나 그 이상의 바이트여야 합니다.</p>
<p><em>n</em>은 CPU/ 메모리 비용 계수, <em>r</em>은 블록 크기, <em>p</em>는 병렬화 계수이고 <em>maxmem</em>은 메모리를 제한합니다 (OpenSSL 1.1.0의 기본값은 32 MiB 입니다). <em>dklen</em>은 파생 키의 길이입니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: OpenSSL 1.1+.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="blake2">
<h2>BLAKE2<a class="headerlink" href="#blake2" title="제목 주소">¶</a></h2>
<p id="index-4"><a class="reference external" href="https://blake2.net">BLAKE2</a>는 <span class="target" id="index-11"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7693.html"><strong>RFC 7693</strong></a>에 정의된 암호화 해시 함수로, 두 가지 방식으로 제공됩니다:</p>
<ul class="simple">
<li><p><strong>BLAKE2b</strong>, 64비트 플랫폼에 최적화되어 있으며 1에서 64바이트 사이의 모든 크기의 요약을 생성합니다,</p></li>
<li><p><strong>BLAKE2s</strong>, 8비트에서 32비트 플랫폼에 최적화되어 있으며 1에서 32바이트 사이의 모든 크기의 요약을 생성합니다.</p></li>
</ul>
<p>BLAKE2는 <strong>키 모드(keyed mode)</strong> (<a class="reference external" href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC</a>의 더 빠르고 간단한 대체), <strong>솔트 해싱(salted hashing)</strong>, <strong>개인화(personalization)</strong> 및 <strong>트리 해싱(tree hashing)</strong>을 지원합니다.</p>
<p>이 모듈의 해시 객체는 표준 라이브러리의 <a class="reference internal" href="#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 객체의 API를 따릅니다.</p>
<div class="section" id="creating-hash-objects">
<h3>해시 객체 만들기<a class="headerlink" href="#creating-hash-objects" title="제목 주소">¶</a></h3>
<p>생성자 함수를 호출하여 새 해시 객체를 만듭니다:</p>
<dl class="function">
<dt id="hashlib.blake2b">
<code class="sig-prename descclassname">hashlib.</code><code class="sig-name descname">blake2b</code><span class="sig-paren">(</span><em class="sig-param">data=b''</em>, <em class="sig-param">*</em>, <em class="sig-param">digest_size=64</em>, <em class="sig-param">key=b''</em>, <em class="sig-param">salt=b''</em>, <em class="sig-param">person=b''</em>, <em class="sig-param">fanout=1</em>, <em class="sig-param">depth=1</em>, <em class="sig-param">leaf_size=0</em>, <em class="sig-param">node_offset=0</em>, <em class="sig-param">node_depth=0</em>, <em class="sig-param">inner_size=0</em>, <em class="sig-param">last_node=False</em>, <em class="sig-param">usedforsecurity=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.blake2b" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="hashlib.blake2s">
<code class="sig-prename descclassname">hashlib.</code><code class="sig-name descname">blake2s</code><span class="sig-paren">(</span><em class="sig-param">data=b''</em>, <em class="sig-param">*</em>, <em class="sig-param">digest_size=32</em>, <em class="sig-param">key=b''</em>, <em class="sig-param">salt=b''</em>, <em class="sig-param">person=b''</em>, <em class="sig-param">fanout=1</em>, <em class="sig-param">depth=1</em>, <em class="sig-param">leaf_size=0</em>, <em class="sig-param">node_offset=0</em>, <em class="sig-param">node_depth=0</em>, <em class="sig-param">inner_size=0</em>, <em class="sig-param">last_node=False</em>, <em class="sig-param">usedforsecurity=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.blake2s" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>이 함수는 BLAKE2b나 BLAKE2s를 계산하기위한 해당 해시 객체를 반환합니다. 선택적으로 다음과 같은 일반 매개 변수를 취합니다:</p>
<ul class="simple">
<li><p><em>data</em>: 해시 할 초기 데이터 청크, <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>여야 합니다. 위치 인자로만 전달될 수 있습니다.</p></li>
<li><p><em>digest_size</em>: 바이트 단위의 출력 요약 크기.</p></li>
<li><p><em>key</em>: 키 해싱을 위한 키 (BLAKE2b의 경우 최대 64바이트, BLAKE2s의 경우 최대 32바이트).</p></li>
<li><p><em>salt</em>: 무작위 해싱을 위한 솔트 (BLAKE2b의 경우 최대 16바이트, BLAKE2s의 경우 최대 8바이트).</p></li>
<li><p><em>person</em>: 개인화 문자열 (BLAKE2b의 경우 최대 16바이트, BLAKE2s의 경우 최대 8바이트).</p></li>
</ul>
<p>다음 표는 일반 매개 변수의 제한(바이트 단위)을 보여줍니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 24%" />
<col style="width: 17%" />
<col style="width: 20%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>해시</p></th>
<th class="head"><p>digest_size</p></th>
<th class="head"><p>len(key)</p></th>
<th class="head"><p>len(salt)</p></th>
<th class="head"><p>len(person)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BLAKE2b</p></td>
<td><p>64</p></td>
<td><p>64</p></td>
<td><p>16</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-odd"><td><p>BLAKE2s</p></td>
<td><p>32</p></td>
<td><p>32</p></td>
<td><p>8</p></td>
<td><p>8</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>BLAKE2 명세는 솔트와 개인화 매개 변수에 대해 상수 길이를 정의하지만, 편의상, 이 구현에서는 지정된 길이까지 모든 크기의 바이트 문자열을 받아들입니다. 매개 변수의 길이가 지정된 길이보다 작으면, 0으로 채워지므로, 예를 들어 <code class="docutils literal notranslate"><span class="pre">b'salt'</span></code>와 <code class="docutils literal notranslate"><span class="pre">b'salt\x00'</span></code>은 같은 값입니다. (<em>key</em>의 경우에는 해당하지 않습니다.)</p>
</div>
<p>이 크기는 아래 설명된 모듈 <a class="reference internal" href="#constants">상수</a>로 제공됩니다.</p>
<p>생성자 함수는 다음 트리 해싱 매개 변수도 받아들입니다:</p>
<ul class="simple">
<li><p><em>fanout</em>: 팬아웃 (0에서 255, 무제한이면 0, 순차적 모드(sequential mode)이면 1).</p></li>
<li><p><em>depth</em>: 트리의 최대 깊이 (1에서 255, 무제한이면 255, 순차적 모드이면 1).</p></li>
<li><p><em>leaf_size</em>: 리프의 최대 바이트 길이 (0에서 2**32-1, 무제한이거나 순차적 모드이면 0).</p></li>
<li><p><em>node_offset</em>: 노드 오프셋 (BLAKE2b의 경우 0에서 2**64-1, BLAKE2s의 경우 0에서 2**48-1, 첫 번째, 가장 왼쪽, 리프 또는 순차적 모드이면 0).</p></li>
<li><p><em>node_depth</em>: 노드 깊이 (0에서 255, 리프나 순차적 모드이면 0).</p></li>
<li><p><em>inner_size</em>: 내부 요약 크기 (BLAKE2b의 경우 0에서 64, BLAKE2s의 경우 0에서 32, 순차적 모드이면 0).</p></li>
<li><p><em>last_node</em>: 처리된 노드가 마지막 노드인지를 나타내는 불리언 (순차적 모드이면 <cite>False</cite>).</p></li>
</ul>
<div class="figure align-default">
<img alt="Explanation of tree mode parameters." src="../_images/hashlib-blake2-tree.png" />
</div>
<p>트리 해싱에 대한 포괄적인 리뷰는 <a class="reference external" href="https://blake2.net/blake2_20130129.pdf">BLAKE2 명세</a>의 섹션 2.10을 참조하십시오.</p>
</div>
<div class="section" id="constants">
<h3>상수<a class="headerlink" href="#constants" title="제목 주소">¶</a></h3>
<dl class="data">
<dt id="hashlib.blake2b.SALT_SIZE">
<code class="sig-prename descclassname">blake2b.</code><code class="sig-name descname">SALT_SIZE</code><a class="headerlink" href="#hashlib.blake2b.SALT_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="hashlib.blake2s.SALT_SIZE">
<code class="sig-prename descclassname">blake2s.</code><code class="sig-name descname">SALT_SIZE</code><a class="headerlink" href="#hashlib.blake2s.SALT_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>솔트 길이 (생성자가 허용하는 최대 길이).</p>
<dl class="data">
<dt id="hashlib.blake2b.PERSON_SIZE">
<code class="sig-prename descclassname">blake2b.</code><code class="sig-name descname">PERSON_SIZE</code><a class="headerlink" href="#hashlib.blake2b.PERSON_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="hashlib.blake2s.PERSON_SIZE">
<code class="sig-prename descclassname">blake2s.</code><code class="sig-name descname">PERSON_SIZE</code><a class="headerlink" href="#hashlib.blake2s.PERSON_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>개인화 문자열 길이 (생성자가 허용하는 최대 길이).</p>
<dl class="data">
<dt id="hashlib.blake2b.MAX_KEY_SIZE">
<code class="sig-prename descclassname">blake2b.</code><code class="sig-name descname">MAX_KEY_SIZE</code><a class="headerlink" href="#hashlib.blake2b.MAX_KEY_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="hashlib.blake2s.MAX_KEY_SIZE">
<code class="sig-prename descclassname">blake2s.</code><code class="sig-name descname">MAX_KEY_SIZE</code><a class="headerlink" href="#hashlib.blake2s.MAX_KEY_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>최대 키 크기.</p>
<dl class="data">
<dt id="hashlib.blake2b.MAX_DIGEST_SIZE">
<code class="sig-prename descclassname">blake2b.</code><code class="sig-name descname">MAX_DIGEST_SIZE</code><a class="headerlink" href="#hashlib.blake2b.MAX_DIGEST_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="hashlib.blake2s.MAX_DIGEST_SIZE">
<code class="sig-prename descclassname">blake2s.</code><code class="sig-name descname">MAX_DIGEST_SIZE</code><a class="headerlink" href="#hashlib.blake2s.MAX_DIGEST_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>해시 함수가 출력할 수 있는 최대 요약 크기.</p>
</div>
<div class="section" id="examples">
<h3>예<a class="headerlink" href="#examples" title="제목 주소">¶</a></h3>
<div class="section" id="simple-hashing">
<h4>간단한 해싱<a class="headerlink" href="#simple-hashing" title="제목 주소">¶</a></h4>
<p>어떤 데이터의 해시를 계산하려면, 먼저 적절한 생성자 함수(<a class="reference internal" href="#hashlib.blake2b" title="hashlib.blake2b"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2b()</span></code></a>나 <a class="reference internal" href="#hashlib.blake2s" title="hashlib.blake2s"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2s()</span></code></a>)를 호출하여 해시 객체를 생성한 다음, 객체에서 <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code>를 호출하여 데이터로 갱신하고, 마지막으로 <code class="xref py py-meth docutils literal notranslate"><span class="pre">digest()</span></code>(또는 16진수 인코딩 문자열의 경우 <code class="xref py py-meth docutils literal notranslate"><span class="pre">hexdigest()</span></code>)를 호출하여 객체에서 요약을 가져와야 합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183&#39;</span>
</pre></div>
</div>
<p>줄여서, 첫 번째 데이터 청크를 위치 인자로 생성자에 전달하여 직접 갱신할 수 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2b</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183&#39;</span>
</pre></div>
</div>
<p>해시를 반복적으로 갱신하는 데 필요한 만큼 <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hash.update()</span></code></a>를 호출할 수 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="sa">b</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;world&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="using-different-digest-sizes">
<h4>다른 요약 크기 사용하기<a class="headerlink" href="#using-different-digest-sizes" title="제목 주소">¶</a></h4>
<p>BLAKE2는 BLAKE2b의 경우 최대 64바이트, BLAKE2s의 경우 최대 32바이트까지 요약 크기를 구성할 수 있습니다. 예를 들어, 출력 크기를 변경하지 않고 SHA-1을 BLAKE2b로 바꾸려면, BLAKE2b에 20바이트 요약을 생성하도록 지시할 수 있습니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Replacing SHA1 with the more secure function&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;d24f26cf8de66472d58d4e1b1774b4c9158b1f4c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">digest_size</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
<span class="go">20</span>
</pre></div>
</div>
<p>요약 크기가 다른 해시 객체의 출력은 완전히 다릅니다 (짧은 해시는 긴 해시의 접두사가 <em>아닙니다</em>); BLAKE2b와 BLAKE2s는 출력 길이가 같더라도 다른 출력을 생성합니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span><span class="p">,</span> <span class="n">blake2s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;6fa1d8fcfd719046d762&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">11</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;eb6ec15daf9546254f0809&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2s</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;1bf21a98c78a1c376ae9&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2s</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">11</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;567004bf96e4a25773ebf4&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="keyed-hashing">
<h4>키 해싱<a class="headerlink" href="#keyed-hashing" title="제목 주소">¶</a></h4>
<p>키 해싱(keyed hashing)은 <a class="reference external" href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">해시 기반 메시지 인증 코드(HMAC - Hash-based message authentication code)</a>을 더 빠르고 간단하게 대체하는 인증에 사용할 수 있습니다. BLAKE2는 BLAKE에서 상속된 비구별성(indifferentiability) 속성 덕분에 접두사-MAC 모드에서 안전하게 사용할 수 있습니다.</p>
<p>이 예는 키 <code class="docutils literal notranslate"><span class="pre">b'pseudorandom</span> <span class="pre">key'</span></code>로 메시지 <code class="docutils literal notranslate"><span class="pre">b'message</span> <span class="pre">data'</span></code>에 대한 (16진 인코딩된) 128비트 인증 코드를 얻는 방법을 보여줍니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;pseudorandom key&#39;</span><span class="p">,</span> <span class="n">digest_size</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;message data&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;3d363ff7401e02026f4a4687d4863ced&#39;</span>
</pre></div>
</div>
<p>실용적인 예로, 웹 응용 프로그램은 사용자에게 전송된 쿠키에 대칭적으로 서명한 후 나중에 변조되지 않았는지 확인할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hmac</span> <span class="k">import</span> <span class="n">compare_digest</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SECRET_KEY</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;pseudorandomly generated server secret key&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AUTH_SIZE</span> <span class="o">=</span> <span class="mi">16</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="n">cookie</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="n">AUTH_SIZE</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">SECRET_KEY</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cookie</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="n">cookie</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">good_sig</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">cookie</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">compare_digest</span><span class="p">(</span><span class="n">good_sig</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cookie</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;user-alice&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">cookie</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">,</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cookie</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span> <span class="n">sig</span><span class="p">))</span>
<span class="go">user-alice,b&#39;43b3c982cf697e0c5ab22172d1ca7421&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verify</span><span class="p">(</span><span class="n">cookie</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verify</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;user-bob&#39;</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verify</span><span class="p">(</span><span class="n">cookie</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;0102030405060708090a0b0c0d0e0f00&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>네이티브 키 해싱 모드가 있더라도, 물론 BLAKE2를 <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a> 모듈을 사용하여 HMAC 구성에 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hmac</span><span class="o">,</span> <span class="nn">hashlib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;secret key&#39;</span><span class="p">,</span> <span class="n">digestmod</span><span class="o">=</span><span class="n">hashlib</span><span class="o">.</span><span class="n">blake2s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;message&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;e3c8102868d28b5ff85fc35dda07329970d1a01e273c37481326fe0c861c8142&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="randomized-hashing">
<h4>무작위 해싱<a class="headerlink" href="#randomized-hashing" title="제목 주소">¶</a></h4>
<p><em>salt</em> 매개 변수를 설정하면 해시 함수에 무작위화를 도입할 수 있습니다. 무작위 해싱은 디지털 서명에 사용된 해시 함수에 대한 충돌 공격(collision attacks)을 방지하는 데 유용합니다.</p>
<blockquote>
<div><p>무작위 해싱은 한 당사자(메시지 준비자)가 두 번째 당사자(메시지 서명자)가 서명할 메시지의 전부나 일부를 생성하는 상황을 위해 설계되었습니다. 메시지 준비자가 암호화 해시 함수 충돌(즉, 같은 해시값을 생성하는 두 메시지)을 찾을 수 있으면, 같은 해시값과 디지털 서명을 생성하는 의미 있는 메시지 버전을 준비할 수 있지만, 결과는 다릅니다 (예를 들어, 계정으로 $10 대신에 $1,000,000을 이체하는 행위). 암호화 해시 함수는 주요 목표로 충돌 내성을 갖도록 설계되었지만, 현재 암호화 해시 함수 공격에 대한 집중으로 인해 주어진 암호화 해시 함수가 예상보다 적은 충돌 내성을 제공할 수 있습니다. 무작위 해싱은 준비자가 디지털 서명 생성 프로세스 동안 궁극적으로 같은 해시값을 산출하는 두 개 이상의 메시지를 생성할 가능성을 줄여서, 서명자에게 추가적인 보호를 제공합니다 -- 설사 해시 함수의 충돌을 찾는 것이 실용적이더라도. 그러나, 무작위 해싱을 사용하면 메시지의 모든 부분을 서명자가 준비할 때 디지털 서명이 제공하는 보안의 양을 줄일 수 있습니다.</p>
<p>(<a class="reference external" href="https://csrc.nist.gov/publications/detail/sp/800-106/final">NIST SP-800-106 &quot;Randomized Hashing for Digital Signatures&quot;</a>)</p>
</div></blockquote>
<p>BLAKE2에서 솔트는 각 압축 함수에 대한 입력이 아니라 초기화 중에 해시 함수에 대한 일회성 입력으로 처리됩니다.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>BLAKE2나 SHA-256과 같은 기타 범용 암호화 해시 함수를 사용하는 <em>솔트 해싱(salted hashing)</em>(또는 그냥 해싱)은 암호(password) 해싱에 적합하지 않습니다. 자세한 정보는 <a class="reference external" href="https://blake2.net/#qa">BLAKE2 FAQ</a>를 참조하십시오.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;some message&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 첫 번째 해시를 무작위 솔트로 계산합니다.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">salt1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="n">blake2b</span><span class="o">.</span><span class="n">SALT_SIZE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h1</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">salt</span><span class="o">=</span><span class="n">salt1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 두 번째 해시를 다른 무작위 솔트로 계산합니다.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">salt2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="n">blake2b</span><span class="o">.</span><span class="n">SALT_SIZE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h2</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">salt</span><span class="o">=</span><span class="n">salt2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h2</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 요약이 다릅니다.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h1</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span> <span class="o">!=</span> <span class="n">h2</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="personalization">
<h4>개인화<a class="headerlink" href="#personalization" title="제목 주소">¶</a></h4>
<p>때로는 해시 함수가 다른 목적으로 같은 입력에 대해 다른 요약을 생성하도록 강제하는 것이 유용합니다. Skein 해시 함수의 저자를 인용합니다:</p>
<blockquote>
<div><p>모든 응용 프로그램 설계자는 이렇게 하는 것을 진지하게 고려하도록 권장합니다; 우리는 유사하거나 관련된 데이터에 대해 두 해시 계산이 수행되었기 때문에, 프로토콜의 한 부분에서 계산된 해시가 완전히 다른 부분에서 사용될 수 있는 프로토콜을 많이 보았으며, 공격자는 응용 프로그램이 해시 입력을 갖게 만들도록 강제할 수 있습니다. 프로토콜에 사용된 각 해시 함수를 개인화하면 이러한 유형의 공격이 중단됩니다.</p>
<p>(<a class="reference external" href="http://www.skein-hash.info/sites/default/files/skein1.3.pdf">The Skein Hash Function Family</a>,
p. 21)</p>
</div></blockquote>
<p>BLAKE2는 바이트열을 <em>person</em> 인자에 전달하여 개인화할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FILES_HASH_PERSON</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;MyApp Files Hash&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BLOCK_HASH_PERSON</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;MyApp Block Hash&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">person</span><span class="o">=</span><span class="n">FILES_HASH_PERSON</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;the same content&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;20d9cd024d4fb086aae819a1432dd2466de12947831b75c5a30cf2676095d3b4&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">person</span><span class="o">=</span><span class="n">BLOCK_HASH_PERSON</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;the same content&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;cf68fb5761b9c44e7878bfb2c4c9aea52264a80b75005e65619778de59f383a3&#39;</span>
</pre></div>
</div>
<p>키 모드와 함께 개인화를 사용하여, 한 키에서 다른 키들을 파생시킬 수도 있습니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">base64</span> <span class="k">import</span> <span class="n">b64decode</span><span class="p">,</span> <span class="n">b64encode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orig_key</span> <span class="o">=</span> <span class="n">b64decode</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Rm5EPJai72qcK3RGBpW3vPNfZy5OZothY+kHY6h21KM=&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc_key</span> <span class="o">=</span> <span class="n">blake2s</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">orig_key</span><span class="p">,</span> <span class="n">person</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;kEncrypt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mac_key</span> <span class="o">=</span> <span class="n">blake2s</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">orig_key</span><span class="p">,</span> <span class="n">person</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;kMAC&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b64encode</span><span class="p">(</span><span class="n">enc_key</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">rbPb15S/Z9t+agffno5wuhB77VbRi6F9Iv2qIxU7WHw=</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b64encode</span><span class="p">(</span><span class="n">mac_key</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">G9GtHFE1YluXY1zWPlYk1e/nWfu0WSEb0KRcjhDeP/o=</span>
</pre></div>
</div>
</div>
<div class="section" id="tree-mode">
<h4>트리 모드<a class="headerlink" href="#tree-mode" title="제목 주소">¶</a></h4>
<p>다음은 두 개의 리프 노드를 갖는 최소 트리를 해싱하는 예입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>  <span class="mi">10</span>
 <span class="o">/</span>  \
<span class="mi">00</span>  <span class="mi">01</span>
</pre></div>
</div>
<p>이 예는 64바이트 내부 요약을 사용하고, 32바이트 최종 요약을 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FANOUT</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DEPTH</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LEAF_SIZE</span> <span class="o">=</span> <span class="mi">4096</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">INNER_SIZE</span> <span class="o">=</span> <span class="mi">64</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">6000</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 왼쪽 리프</span>
<span class="gp">... </span><span class="n">h00</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">LEAF_SIZE</span><span class="p">],</span> <span class="n">fanout</span><span class="o">=</span><span class="n">FANOUT</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">DEPTH</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">leaf_size</span><span class="o">=</span><span class="n">LEAF_SIZE</span><span class="p">,</span> <span class="n">inner_size</span><span class="o">=</span><span class="n">INNER_SIZE</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">node_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">last_node</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 오른쪽 리프</span>
<span class="gp">... </span><span class="n">h01</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">LEAF_SIZE</span><span class="p">:],</span> <span class="n">fanout</span><span class="o">=</span><span class="n">FANOUT</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">DEPTH</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">leaf_size</span><span class="o">=</span><span class="n">LEAF_SIZE</span><span class="p">,</span> <span class="n">inner_size</span><span class="o">=</span><span class="n">INNER_SIZE</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">node_offset</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">node_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">last_node</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 루트 노드</span>
<span class="gp">... </span><span class="n">h10</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">fanout</span><span class="o">=</span><span class="n">FANOUT</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">DEPTH</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">leaf_size</span><span class="o">=</span><span class="n">LEAF_SIZE</span><span class="p">,</span> <span class="n">inner_size</span><span class="o">=</span><span class="n">INNER_SIZE</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">node_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">last_node</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h10</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">h00</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h10</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">h01</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h10</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;3ad2a9b37c6070e374c7a8c508fe20ca86b6ed54e286e93a0318e95e881db5aa&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="credits">
<h3>크레딧<a class="headerlink" href="#credits" title="제목 주소">¶</a></h3>
<p><a class="reference external" href="https://blake2.net">BLAKE2</a>는 <em>Jean-Philippe Aumasson</em>, <em>Luca Henzen</em>, <em>Willi Meier</em> 및 <em>Raphael C.-W. Phan</em>이 만든 <a class="reference external" href="https://en.wikipedia.org/wiki/NIST_hash_function_competition">SHA-3</a> 파이널리스트 <a class="reference external" href="https://131002.net/blake/">BLAKE</a>를 기반으로 <em>Jean-Philippe Aumasson</em>, <em>Samuel Neves</em>, <em>Zooko Wilcox-O'Hearn</em> 및 <em>Christian Winnerlein</em>이 설계했습니다.</p>
<p><em>Daniel J.  Bernstein</em>이 설계한 <a class="reference external" href="https://cr.yp.to/chacha.html">ChaCha</a> 암호(cipher)의 핵심 알고리즘을 사용합니다.</p>
<p>표준 라이브러리 구현은 <a class="reference external" href="https://pythonhosted.org/pyblake2/">pyblake2</a> 모듈에 기반합니다. 이것은 <em>Samuel Neves</em>가 작성한 C 구현을 기반으로 <em>Dmitry Chestnykh</em>가 작성했습니다. 이 설명서는 <a class="reference external" href="https://pythonhosted.org/pyblake2/">pyblake2</a>에서 복사했으며 <em>Dmitry Chestnykh</em>가 작성했습니다.</p>
<p>C 코드는 <em>Christian Heimes</em>가 파이썬 용으로 부분적으로 재작성했습니다.</p>
<p>다음 공개 도메인 기부는 C 해시 함수 구현, 확장 코드 및 이 설명서 모두에 적용됩니다:</p>
<blockquote>
<div><p>법률에 따라 가능한 범위 내에서, 저자(들)는 이 소프트웨어에 대한 모든 저작권과 관련되고 둘러싼 권리를 전 세계 공개 도메인에 기부했습니다. 이 소프트웨어는 보증 없이 배포됩니다.</p>
<p>이 소프트웨어와 함께 CC0 Public Domain Dedication의 사본을 받았어야 합니다. 그렇지 않으면, <a class="reference external" href="https://creativecommons.org/publicdomain/zero/1.0/">https://creativecommons.org/publicdomain/zero/1.0/</a> 을 참조하십시오.</p>
</div></blockquote>
<p>다음과 같은 사람들은 Creative Commons Public Domain Dedication 1.0 Universal에 따라 개발을 돕거나 프로젝트와 공개 도메인에 변경에 기여했습니다:</p>
<ul class="simple">
<li><p><em>Alexandr Sokolovskiy</em></p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt>모듈 <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a></dt><dd><p>해시를 사용하여 메시지 인증 코드를 생성하는 모듈.</p>
</dd>
<dt>모듈 <a class="reference internal" href="base64.html#module-base64" title="base64: RFC 3548: Base16, Base32, Base64 Data Encodings; Base85 and Ascii85"><code class="xref py py-mod docutils literal notranslate"><span class="pre">base64</span></code></a></dt><dd><p>바이너리가 아닌 환경을 위해 바이너리 해시를 인코딩하는 다른 방법.</p>
</dd>
<dt><a class="reference external" href="https://blake2.net">https://blake2.net</a></dt><dd><p>공식 BLAKE2 웹 사이트.</p>
</dd>
<dt><a class="reference external" href="https://csrc.nist.gov/csrc/media/publications/fips/180/2/archive/2002-08-01/documents/fips180-2.pdf">https://csrc.nist.gov/csrc/media/publications/fips/180/2/archive/2002-08-01/documents/fips180-2.pdf</a></dt><dd><p>Secure Hash Algorithms에 관한 FIPS 180-2 발행물.</p>
</dd>
<dt><a class="reference external" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function#Cryptographic_hash_algorithms">https://en.wikipedia.org/wiki/Cryptographic_hash_function#Cryptographic_hash_algorithms</a></dt><dd><p>어떤 알고리즘에 알려진 문제가 있고 그것이 사용에 어떤 의미가 있는지에 대한 정보가 포함된 위키피디아 기사.</p>
</dd>
<dt><a class="reference external" href="https://www.ietf.org/rfc/rfc2898.txt">https://www.ietf.org/rfc/rfc2898.txt</a></dt><dd><p>PKCS #5: Password-Based Cryptography Specification Version 2.0</p>
</dd>
</dl>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code> --- 보안 해시와 메시지 요약</a><ul>
<li><a class="reference internal" href="#hash-algorithms">해시 알고리즘</a></li>
<li><a class="reference internal" href="#shake-variable-length-digests">SHAKE 가변 길이 요약</a></li>
<li><a class="reference internal" href="#key-derivation">키 파생</a></li>
<li><a class="reference internal" href="#blake2">BLAKE2</a><ul>
<li><a class="reference internal" href="#creating-hash-objects">해시 객체 만들기</a></li>
<li><a class="reference internal" href="#constants">상수</a></li>
<li><a class="reference internal" href="#examples">예</a><ul>
<li><a class="reference internal" href="#simple-hashing">간단한 해싱</a></li>
<li><a class="reference internal" href="#using-different-digest-sizes">다른 요약 크기 사용하기</a></li>
<li><a class="reference internal" href="#keyed-hashing">키 해싱</a></li>
<li><a class="reference internal" href="#randomized-hashing">무작위 해싱</a></li>
<li><a class="reference internal" href="#personalization">개인화</a></li>
<li><a class="reference internal" href="#tree-mode">트리 모드</a></li>
</ul>
</li>
<li><a class="reference internal" href="#credits">크레딧</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="crypto.html"
                        title="이전 장">암호화 서비스</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="hmac.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code> --- 메시지 인증을 위한 키 해싱</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="hmac.html" title="hmac --- 메시지 인증을 위한 키 해싱"
             >다음</a> |</li>
        <li class="right" >
          <a href="crypto.html" title="암호화 서비스"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="crypto.html" >암호화 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>