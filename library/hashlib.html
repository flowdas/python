
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>hashlib --- 보안 해시와 메시지 요약 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="hmac --- 메시지 인증을 위한 키 해싱" href="hmac.html" />
    <link rel="prev" title="암호화 서비스" href="crypto.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/hashlib.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="hmac.html" title="hmac --- 메시지 인증을 위한 키 해싱"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="crypto.html" title="암호화 서비스"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="crypto.html" accesskey="U">암호화 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-hashlib">
<span id="hashlib-secure-hashes-and-message-digests"></span><h1><a class="reference internal" href="#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> --- 보안 해시와 메시지 요약<a class="headerlink" href="#module-hashlib" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/hashlib.py">Lib/hashlib.py</a></p>
<span class="target" id="index-0"></span><hr class="docutils" />
<p>이 모듈은 다양한 보안 해시(secure hash)와 메시지 요약(message digest) 알고리즘에 대한 공통 인터페이스를 구현합니다. RSA의 MD5 알고리즘(Internet <span class="target" id="index-9"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1321.html"><strong>RFC 1321</strong></a>에서 정의됩니다)뿐만 아니라 FIPS 보안 해시 알고리즘 SHA1, SHA224, SHA256, SHA384 및 SHA512(FIPS 180-2에 정의됩니다)가 포함됩니다. &quot;보안 해시&quot;와 &quot;메시지 다이제스트&quot;라는 용어는 서로 바꿔 사용할 수 있습니다. 오래된 알고리즘들은 메시지 요약이라고 불립니다. 현대 용어는 보안 해시입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>adler32나 crc32 해시 함수를 원한다면, <a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 모듈에 있습니다.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>일부 알고리즘은 해시 충돌 약점(hash collision weaknesses)이 알려져 있습니다, 끝에 있는 &quot;더 보기&quot; 섹션을 참조하십시오.</p>
</div>
<div class="section" id="hash-algorithms">
<span id="id1"></span><h2>해시 알고리즘<a class="headerlink" href="#hash-algorithms" title="제목 주소">¶</a></h2>
<p><em class="dfn">해시(hash)</em>의 각 유형마다 이름이 지정된 생성자 메서드가 있습니다. 모두 같은 간단한 인터페이스를 갖는 해시 객체를 반환합니다. 예를 들어: SHA-256 해시 객체를 만들려면 <code class="xref py py-func docutils literal notranslate"><span class="pre">sha256()</span></code>을 사용하십시오. 이제 <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> 메서드를 사용하여 이 객체에 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>(보통 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>)를 공급할 수 있습니다. 언제든지 <code class="xref py py-meth docutils literal notranslate"><span class="pre">digest()</span></code>나 <code class="xref py py-meth docutils literal notranslate"><span class="pre">hexdigest()</span></code> 메서드를 사용하여 지금까지 공급된 데이터의 연결에 대한 <em class="dfn">요약(digest)</em>을 요청할 수 있습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>다중 스레딩 성능을 향상시키기 위해, 객체 생성이나 갱신 시 2047 바이트보다 큰 데이터에 대해 파이썬 <a class="reference internal" href="../glossary.html#term-gil"><span class="xref std std-term">GIL</span></a>이 해제됩니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>해시는 문자가 아닌 바이트에서 작동하므로, 문자열 객체를 <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code>에 공급하는 것은 지원되지 않습니다.</p>
</div>
<p id="index-2">이 모듈에 항상 존재하는 해시 알고리즘의 생성자는 <code class="xref py py-func docutils literal notranslate"><span class="pre">sha1()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha224()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha256()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha384()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha512()</span></code>, <a class="reference internal" href="#hashlib.blake2b" title="hashlib.blake2b"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2b()</span></code></a> 및 <a class="reference internal" href="#hashlib.blake2s" title="hashlib.blake2s"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2s()</span></code></a>입니다. <code class="xref py py-func docutils literal notranslate"><span class="pre">md5()</span></code>는 일반적으로 사용 가능하지만, 드문 &quot;FIPS 호환&quot; 파이썬 빌드를 사용하는 경우에는 빠질 수 있습니다. 파이썬이 플랫폼에서 사용하는 OpenSSL 라이브러리에 따라 추가 알고리즘을 사용할 수도 있습니다. 대부분의 플랫폼에서 <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_224()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_256()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_384()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_512()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">shake_128()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">shake_256()</span></code>도 사용할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가: </span>SHA3(Keccak)와 및 SHAKE 생성자 <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_224()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_256()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_384()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sha3_512()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">shake_128()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">shake_256()</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가: </span><a class="reference internal" href="#hashlib.blake2b" title="hashlib.blake2b"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2b()</span></code></a>와 <a class="reference internal" href="#hashlib.blake2s" title="hashlib.blake2s"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2s()</span></code></a>가 추가되었습니다.</p>
</div>
<p>예를 들어, 바이트 문자열 <code class="docutils literal notranslate"><span class="pre">b'Nobody</span> <span class="pre">inspects</span> <span class="pre">the</span> <span class="pre">spammish</span> <span class="pre">repetition'</span></code>의 요약을 얻으려면 다음을 수행하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hashlib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Nobody inspects&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot; the spammish repetition&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
<span class="go">b&#39;\x03\x1e\xdd}Ae\x15\x93\xc5\xfe\\\x00o\xa5u+7\xfd\xdf\xf7\xbcN\x84:\xa6\xaf\x0c\x95\x0fK\x94\x06&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">digest_size</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">block_size</span>
<span class="go">64</span>
</pre></div>
</div>
<p>더 압축하면:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hashlib</span><span class="o">.</span><span class="n">sha224</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Nobody inspects the spammish repetition&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;a4337bc45a8fc544c03f52dc550cd6e1e87021bc896588bd79e901e2&#39;</span>
</pre></div>
</div>
<dl class="function">
<dt id="hashlib.new">
<code class="sig-prename descclassname">hashlib.</code><code class="sig-name descname">new</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="optional">[</span>, <em class="sig-param">data</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.new" title="정의 주소">¶</a></dt>
<dd><p>원하는 알고리즘의 문자열 <em>name</em>을 첫 번째 매개 변수로 취하는 일반 생성자입니다. 또한 위에 나열된 해시뿐만 아니라 OpenSSL 라이브러리가 제공할 수 있는 다른 알고리즘에 대한 액세스를 허용하기 위해 존재합니다. 이름 붙은 생성자는 <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a>보다 훨씬 빠르므로 선호해야 합니다.</p>
</dd></dl>

<p>OpenSSL에서 제공하는 알고리즘으로 <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a> 사용하기:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;ripemd160&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Nobody inspects the spammish repetition&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;cc4a5ce1b3df48aec5d22d1f16b894a0b894eccc&#39;</span>
</pre></div>
</div>
<p>hashlib는 다음과 같은 상수 어트리뷰트를 제공합니다:</p>
<dl class="data">
<dt id="hashlib.algorithms_guaranteed">
<code class="sig-prename descclassname">hashlib.</code><code class="sig-name descname">algorithms_guaranteed</code><a class="headerlink" href="#hashlib.algorithms_guaranteed" title="정의 주소">¶</a></dt>
<dd><p>모든 플랫폼에서 이 모듈이 지원하도록 보장된 해시 알고리즘의 이름을 포함하는 집합. 'md5'는 일부 업스트림 공급자가 이를 제외하는 이상한 &quot;FIPS 호환&quot; 파이썬 빌드를 제공하지만 이 목록에 있음에 유의하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="hashlib.algorithms_available">
<code class="sig-prename descclassname">hashlib.</code><code class="sig-name descname">algorithms_available</code><a class="headerlink" href="#hashlib.algorithms_available" title="정의 주소">¶</a></dt>
<dd><p>실행중인 파이썬 인터프리터에서 사용 가능한 해시 알고리즘의 이름이 포함된 집합. 이 이름들은 <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a>에 전달될 때 인식됩니다. <a class="reference internal" href="#hashlib.algorithms_guaranteed" title="hashlib.algorithms_guaranteed"><code class="xref py py-attr docutils literal notranslate"><span class="pre">algorithms_guaranteed</span></code></a>는 항상 부분 집합입니다. 이 집합에서 같은 알고리즘이 다른 이름으로 여러 번 나타날 수 있습니다 (OpenSSL 덕분입니다).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<p>다음 값은 생성자가 반환한 해시 객체의 상수 어트리뷰트로 제공됩니다:</p>
<dl class="data">
<dt id="hashlib.hash.digest_size">
<code class="sig-prename descclassname">hash.</code><code class="sig-name descname">digest_size</code><a class="headerlink" href="#hashlib.hash.digest_size" title="정의 주소">¶</a></dt>
<dd><p>결과 해시의 바이트 단위의 크기.</p>
</dd></dl>

<dl class="data">
<dt id="hashlib.hash.block_size">
<code class="sig-prename descclassname">hash.</code><code class="sig-name descname">block_size</code><a class="headerlink" href="#hashlib.hash.block_size" title="정의 주소">¶</a></dt>
<dd><p>해시 알고리즘의 바이트 단위의 내부 블록 크기.</p>
</dd></dl>

<p>해시 객체에는 다음과 같은 어트리뷰트가 있습니다:</p>
<dl class="attribute">
<dt id="hashlib.hash.name">
<code class="sig-prename descclassname">hash.</code><code class="sig-name descname">name</code><a class="headerlink" href="#hashlib.hash.name" title="정의 주소">¶</a></dt>
<dd><p>이 해시의 규범적 이름, 항상 소문자이며 항상 이 유형의 다른 해시를 만들기 위한 <a class="reference internal" href="#hashlib.new" title="hashlib.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a>에 대한 매개 변수로 적합합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>name 어트리뷰트는 처음부터 CPython에 존재했지만, 파이썬 3.4 이전에는 공식적으로 지정되지 않아서, 일부 플랫폼에는 존재하지 않을 수 있습니다.</p>
</div>
</dd></dl>

<p>해시 객체에는 다음과 같은 메서드가 있습니다:</p>
<dl class="method">
<dt id="hashlib.hash.update">
<code class="sig-prename descclassname">hash.</code><code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.hash.update" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>로 해시 객체를 갱신합니다. 반복되는 호출은 모든 인자를 이어붙인 단일 호출과 동등합니다: <code class="docutils literal notranslate"><span class="pre">m.update(a);</span> <span class="pre">m.update(b)</span></code>는 <code class="docutils literal notranslate"><span class="pre">m.update(a+b)</span></code>와 동등합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.1에서 변경: </span>파이썬 GIL은 OpenSSL에서 제공하는 해시 알고리즘을 사용할 때 2047 바이트보다 큰 데이터에 대한 해시 갱신이 수행되는 동안 다른 스레드를 실행할 수 있도록 해제됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="hashlib.hash.digest">
<code class="sig-prename descclassname">hash.</code><code class="sig-name descname">digest</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.hash.digest" title="정의 주소">¶</a></dt>
<dd><p>지금까지 <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> 메서드에 전달된 데이터의 요약을 반환합니다. 이것은 <a class="reference internal" href="#hashlib.hash.digest_size" title="hashlib.hash.digest_size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">digest_size</span></code></a> 크기의 바이트열 객체이며 0에서 255까지의 전체 범위에 있는 바이트를 포함할 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="hashlib.hash.hexdigest">
<code class="sig-prename descclassname">hash.</code><code class="sig-name descname">hexdigest</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.hash.hexdigest" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#hashlib.hash.digest" title="hashlib.hash.digest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">digest()</span></code></a>와 유사하지만, 요약은 16진수 숫자만 포함하는 두 배 길이의 문자열 객체로 반환됩니다. 전자 메일이나 기타 바이너리가 아닌 환경에서 값을 안전하게 교환하는 데 사용할 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="hashlib.hash.copy">
<code class="sig-prename descclassname">hash.</code><code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.hash.copy" title="정의 주소">¶</a></dt>
<dd><p>해시 객체의 사본(&quot;복제본&quot;)을 반환합니다. 이것은 공통된 초기 부분 문자열을 공유하는 데이터의 요약을 효율적으로 계산하는 데 사용될 수 있습니다.</p>
</dd></dl>

</div>
<div class="section" id="shake-variable-length-digests">
<h2>SHAKE 가변 길이 요약<a class="headerlink" href="#shake-variable-length-digests" title="제목 주소">¶</a></h2>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">shake_128()</span></code>과 <code class="xref py py-func docutils literal notranslate"><span class="pre">shake_256()</span></code> 알고리즘은 length_in_bits//2 (최대 128이나 256) 비트의 보안성으로 가변 길이 요약을 제공합니다. 따라서 digest 메서드에는 길이(length)가 필요합니다. 최대 길이는 SHAKE 알고리즘에 의해 제한되지 않습니다.</p>
<dl class="method">
<dt id="hashlib.shake.digest">
<code class="sig-prename descclassname">shake.</code><code class="sig-name descname">digest</code><span class="sig-paren">(</span><em class="sig-param">length</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.shake.digest" title="정의 주소">¶</a></dt>
<dd><p>지금까지 <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> 메서드에 전달된 데이터의 요약을 반환합니다. 이것은 <em>length</em> 크기의 바이트열 객체이며 0에서 255까지의 전체 범위에 있는 바이트를 포함할 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="hashlib.shake.hexdigest">
<code class="sig-prename descclassname">shake.</code><code class="sig-name descname">hexdigest</code><span class="sig-paren">(</span><em class="sig-param">length</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.shake.hexdigest" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#hashlib.shake.digest" title="hashlib.shake.digest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">digest()</span></code></a>와 유사하지만, 요약은 16진수 숫자만 포함하는 두 배 길이의 문자열 객체로 반환됩니다. 전자 메일이나 기타 바이너리가 아닌 환경에서 값을 안전하게 교환하는 데 사용할 수 있습니다.</p>
</dd></dl>

</div>
<div class="section" id="key-derivation">
<h2>키 파생<a class="headerlink" href="#key-derivation" title="제목 주소">¶</a></h2>
<p>키 파생(key derivation)과 키 확장(key stretching) 알고리즘은 안전한 암호 해싱을 위해 설계되었습니다. <code class="docutils literal notranslate"><span class="pre">sha1(password)</span></code>와 같은 순진한 알고리즘은 무차별 대입 공격에 내성이 없습니다. 올바른 암호 해싱 함수는 조정 가능하고, 느리고, <a class="reference external" href="https://en.wikipedia.org/wiki/Salt_%28cryptography%29">솔트(salt)</a>를 포함해야 합니다.</p>
<dl class="function">
<dt id="hashlib.pbkdf2_hmac">
<code class="sig-prename descclassname">hashlib.</code><code class="sig-name descname">pbkdf2_hmac</code><span class="sig-paren">(</span><em class="sig-param">hash_name</em>, <em class="sig-param">password</em>, <em class="sig-param">salt</em>, <em class="sig-param">iterations</em>, <em class="sig-param">dklen=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.pbkdf2_hmac" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 PKCS#5 암호 기반 키 파생 함수 2를 제공합니다. 의사 난수 함수로 HMAC을 사용합니다.</p>
<p>문자열 <em>hash_name</em>은 원하는 HMAC을 위한 해시 요약 알고리즘의 이름입니다, 예를 들어 'sha1'이나 'sha256'. <em>password</em>와 <em>salt</em>는 바이트 버퍼로 해석됩니다. 응용 프로그램과 라이브러리는 <em>password</em>를 적당한 길이(예를 들어 1024)로 제한해야 합니다. <em>salt</em>는 적절한 소스(예를 들어 <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a>)로부터 온 약 16이나 그 이상의 바이트여야 합니다.</p>
<p><em>iterations</em>의 수는 해시 알고리즘과 컴퓨팅 성능에 따라 선택해야합니다. 2013년 현재, 적어도 100,000회의 SHA-256 반복이 제안됩니다.</p>
<p><em>dklen</em>은 파생 키의 길이입니다. <em>dklen</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면 해시 알고리즘 <em>hash_name</em>의 요약 크기가 사용됩니다, 예를 들어 SHA-512의 경우 64.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hashlib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dk</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">pbkdf2_hmac</span><span class="p">(</span><span class="s1">&#39;sha256&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;password&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;salt&#39;</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dk</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;0394a2ede332c9a13eb82e9b24631604c31df978b4e2f0fbd2c549944f9d79a5&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><em>pbkdf2_hmac</em>의 빠른 구현은 OpenSSL에서 제공됩니다. 파이썬 구현은 인라인 버전의 <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a>을 사용합니다. 약 3배 느리고 GIL을 해제하지 않습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="hashlib.scrypt">
<code class="sig-prename descclassname">hashlib.</code><code class="sig-name descname">scrypt</code><span class="sig-paren">(</span><em class="sig-param">password</em>, <em class="sig-param">*</em>, <em class="sig-param">salt</em>, <em class="sig-param">n</em>, <em class="sig-param">r</em>, <em class="sig-param">p</em>, <em class="sig-param">maxmem=0</em>, <em class="sig-param">dklen=64</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.scrypt" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <span class="target" id="index-10"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7914.html"><strong>RFC 7914</strong></a>에 정의된 대로 scrypt 암호 기반 키 파생 함수를 제공합니다.</p>
<p><em>password</em>와 <em>salt</em>는 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>여야 합니다. 응용 프로그램과 라이브러리는 <em>password</em>를 적당한 길이(예를 들어 1024)로 제한해야 합니다. <em>salt</em>는 적절한 소스(예를 들어 <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a>)로부터 온 약 16이나 그 이상의 바이트여야 합니다.</p>
<p><em>n</em>은 CPU/ 메모리 비용 계수, <em>r</em>은 블록 크기, <em>p</em>는 병렬화 계수이고 <em>maxmem</em>은 메모리를 제한합니다 (OpenSSL 1.1.0의 기본값은 32 MiB 입니다). <em>dklen</em>은 파생 키의 길이입니다.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">가용성</span></a>: OpenSSL 1.1+.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="blake2">
<h2>BLAKE2<a class="headerlink" href="#blake2" title="제목 주소">¶</a></h2>
<p id="index-4"><a class="reference external" href="https://blake2.net">BLAKE2</a>는 <span class="target" id="index-11"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7693.html"><strong>RFC 7693</strong></a>에 정의된 암호화 해시 함수로, 두 가지 방식으로 제공됩니다:</p>
<ul class="simple">
<li><p><strong>BLAKE2b</strong>, 64비트 플랫폼에 최적화되어 있으며 1에서 64바이트 사이의 모든 크기의 요약을 생성합니다,</p></li>
<li><p><strong>BLAKE2</strong>, 8비트에서 32비트 플랫폼에 최적화되어 있으며 1에서 32바이트 사이의 모든 크기의 요약을 생성합니다.</p></li>
</ul>
<p>BLAKE2는 <strong>키 모드(keyed mode)</strong> (<a class="reference external" href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC</a>의 더 빠르고 간단한 대체), <strong>솔트 해싱(salted hashing)</strong>, <strong>개인화(personalization)</strong> 및 <strong>트리 해싱(tree hashing)</strong>을 지원합니다.</p>
<p>이 모듈의 해시 객체는 표준 라이브러리의 <a class="reference internal" href="#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 객체의 API를 따릅니다.</p>
<div class="section" id="creating-hash-objects">
<h3>해시 객체 만들기<a class="headerlink" href="#creating-hash-objects" title="제목 주소">¶</a></h3>
<p>생성자 함수를 호출하여 새 해시 객체를 만듭니다:</p>
<dl class="function">
<dt id="hashlib.blake2b">
<code class="sig-prename descclassname">hashlib.</code><code class="sig-name descname">blake2b</code><span class="sig-paren">(</span><em class="sig-param">data=b''</em>, <em class="sig-param">*</em>, <em class="sig-param">digest_size=64</em>, <em class="sig-param">key=b''</em>, <em class="sig-param">salt=b''</em>, <em class="sig-param">person=b''</em>, <em class="sig-param">fanout=1</em>, <em class="sig-param">depth=1</em>, <em class="sig-param">leaf_size=0</em>, <em class="sig-param">node_offset=0</em>, <em class="sig-param">node_depth=0</em>, <em class="sig-param">inner_size=0</em>, <em class="sig-param">last_node=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.blake2b" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="hashlib.blake2s">
<code class="sig-prename descclassname">hashlib.</code><code class="sig-name descname">blake2s</code><span class="sig-paren">(</span><em class="sig-param">data=b''</em>, <em class="sig-param">*</em>, <em class="sig-param">digest_size=32</em>, <em class="sig-param">key=b''</em>, <em class="sig-param">salt=b''</em>, <em class="sig-param">person=b''</em>, <em class="sig-param">fanout=1</em>, <em class="sig-param">depth=1</em>, <em class="sig-param">leaf_size=0</em>, <em class="sig-param">node_offset=0</em>, <em class="sig-param">node_depth=0</em>, <em class="sig-param">inner_size=0</em>, <em class="sig-param">last_node=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hashlib.blake2s" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>이 함수는 BLAKE2b나 BLAKE2s를 계산하기위한 해당 해시 객체를 반환합니다. 선택적으로 다음과 같은 일반 매개 변수를 취합니다:</p>
<ul class="simple">
<li><p><em>data</em>: 해시 할 초기 데이터 청크, <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">바이트열류 객체</span></a>여야 합니다. 위치 인자로만 전달될 수 있습니다.</p></li>
<li><p><em>digest_size</em>: 바이트 단위의 출력 요약 크기.</p></li>
<li><p><em>key</em>: 키 해싱을 위한 키 (BLAKE2b의 경우 최대 64바이트, BLAKE2s의 경우 최대 32바이트).</p></li>
<li><p><em>salt</em>: 무작위 해싱을 위한 솔트 (BLAKE2b의 경우 최대 16바이트, BLAKE2s의 경우 최대 8바이트).</p></li>
<li><p><em>person</em>: 개인화 문자열 (BLAKE2b의 경우 최대 16바이트, BLAKE2s의 경우 최대 8바이트).</p></li>
</ul>
<p>다음 표는 일반 매개 변수의 제한(바이트 단위)을 보여줍니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 24%" />
<col style="width: 17%" />
<col style="width: 20%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>해시</p></th>
<th class="head"><p>digest_size</p></th>
<th class="head"><p>len(key)</p></th>
<th class="head"><p>len(salt)</p></th>
<th class="head"><p>len(person)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BLAKE2b</p></td>
<td><p>64</p></td>
<td><p>64</p></td>
<td><p>16</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-odd"><td><p>BLAKE2s</p></td>
<td><p>32</p></td>
<td><p>32</p></td>
<td><p>8</p></td>
<td><p>8</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>BLAKE2 명세는 솔트와 개인화 매개 변수에 대해 상수 길이를 정의하지만, 편의상 이 구현에서는 지정된 길이까지 모든 크기의 바이트 문자열을 받아들입니다. 매개 변수의 길이가 지정된 길이보다 작으면, 0으로 채워 지므로, 예를 들어 <code class="docutils literal notranslate"><span class="pre">b'salt'</span></code>와 <code class="docutils literal notranslate"><span class="pre">b'salt\x00'</span></code>은 같은 값입니다. (<em>key</em>의 경우에는 해당되지 않습니다.)</p>
</div>
<p>이 크기는 아래 설명된 모듈 <a class="reference internal" href="#constants">상수</a>로 제공됩니다.</p>
<p>생성자 함수는 다음 트리 해싱 매개 변수도 받아들입니다:</p>
<ul class="simple">
<li><p><em>fanout</em>: 팬 아웃 (0 에서 255, 무제한이면 0, 순차적 모드(sequential mode)이면 1).</p></li>
<li><p><em>depth</em>: 트리의 최대 심도 (1 에서 255, 무제한이면 255, 순차적 모드이면 1).</p></li>
<li><p><em>leaf_size</em>: 리프의 최대 바이트 길이 (0 에서 2**32-1, 무제한이거나 순차적 모드이면 0).</p></li>
<li><p><em>node_offset</em>: 노드 오프셋 (BLAKE2b의 경우 0 에서 2**64-1, BLAKE2s의 경우 0 에서 2**48-1, 첫 번째, 가장 왼쪽, 리프 또는 순차적 모드이면 0).</p></li>
<li><p><em>node_depth</em>: 노드 깊이 (0 에서 255, 리프나 순차적 모드이면 0).</p></li>
<li><p><em>inner_size</em>: 내부 요약 크기 (BLAKE2b의 경우 0 에서 64, BLAKE2s의 경우 0 에서 32, 순차적 모드이면 0).</p></li>
<li><p><em>last_node</em>: 처리된 노드가 마지막 노드인지를 나타내는 불리언 (순차적 모드이면 <cite>False</cite>).</p></li>
</ul>
<div class="figure align-default">
<img alt="Explanation of tree mode parameters." src="../_images/hashlib-blake2-tree.png" />
</div>
<p>트리 해싱에 대한 포괄적인 리뷰는 <a class="reference external" href="https://blake2.net/blake2_20130129.pdf">BLAKE2 명세</a>의 섹션 2.10을 참조하십시오.</p>
</div>
<div class="section" id="constants">
<h3>상수<a class="headerlink" href="#constants" title="제목 주소">¶</a></h3>
<dl class="data">
<dt id="hashlib.blake2b.SALT_SIZE">
<code class="sig-prename descclassname">blake2b.</code><code class="sig-name descname">SALT_SIZE</code><a class="headerlink" href="#hashlib.blake2b.SALT_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="hashlib.blake2s.SALT_SIZE">
<code class="sig-prename descclassname">blake2s.</code><code class="sig-name descname">SALT_SIZE</code><a class="headerlink" href="#hashlib.blake2s.SALT_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>솔트 길이 (생성자가 허용하는 최대 길이).</p>
<dl class="data">
<dt id="hashlib.blake2b.PERSON_SIZE">
<code class="sig-prename descclassname">blake2b.</code><code class="sig-name descname">PERSON_SIZE</code><a class="headerlink" href="#hashlib.blake2b.PERSON_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="hashlib.blake2s.PERSON_SIZE">
<code class="sig-prename descclassname">blake2s.</code><code class="sig-name descname">PERSON_SIZE</code><a class="headerlink" href="#hashlib.blake2s.PERSON_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>개인화 문자열 길이 (생성자가 허용하는 최대 길이).</p>
<dl class="data">
<dt id="hashlib.blake2b.MAX_KEY_SIZE">
<code class="sig-prename descclassname">blake2b.</code><code class="sig-name descname">MAX_KEY_SIZE</code><a class="headerlink" href="#hashlib.blake2b.MAX_KEY_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="hashlib.blake2s.MAX_KEY_SIZE">
<code class="sig-prename descclassname">blake2s.</code><code class="sig-name descname">MAX_KEY_SIZE</code><a class="headerlink" href="#hashlib.blake2s.MAX_KEY_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>최대 키 크기.</p>
<dl class="data">
<dt id="hashlib.blake2b.MAX_DIGEST_SIZE">
<code class="sig-prename descclassname">blake2b.</code><code class="sig-name descname">MAX_DIGEST_SIZE</code><a class="headerlink" href="#hashlib.blake2b.MAX_DIGEST_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="hashlib.blake2s.MAX_DIGEST_SIZE">
<code class="sig-prename descclassname">blake2s.</code><code class="sig-name descname">MAX_DIGEST_SIZE</code><a class="headerlink" href="#hashlib.blake2s.MAX_DIGEST_SIZE" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<p>해시 함수가 출력할 수 있는 최대 요약 크기.</p>
</div>
<div class="section" id="examples">
<h3>예<a class="headerlink" href="#examples" title="제목 주소">¶</a></h3>
<div class="section" id="simple-hashing">
<h4>Simple hashing<a class="headerlink" href="#simple-hashing" title="제목 주소">¶</a></h4>
<p>To calculate hash of some data, you should first construct a hash object by
calling the appropriate constructor function (<a class="reference internal" href="#hashlib.blake2b" title="hashlib.blake2b"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2b()</span></code></a> or
<a class="reference internal" href="#hashlib.blake2s" title="hashlib.blake2s"><code class="xref py py-func docutils literal notranslate"><span class="pre">blake2s()</span></code></a>), then update it with the data by calling <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> on the
object, and, finally, get the digest out of the object by calling
<code class="xref py py-meth docutils literal notranslate"><span class="pre">digest()</span></code> (or <code class="xref py py-meth docutils literal notranslate"><span class="pre">hexdigest()</span></code> for hex-encoded string).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183&#39;</span>
</pre></div>
</div>
<p>As a shortcut, you can pass the first chunk of data to update directly to the
constructor as the positional argument:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2b</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183&#39;</span>
</pre></div>
</div>
<p>You can call <a class="reference internal" href="#hashlib.hash.update" title="hashlib.hash.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hash.update()</span></code></a> as many times as you need to iteratively
update the hash:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="sa">b</span><span class="s1">&#39;Hello&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;world&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="using-different-digest-sizes">
<h4>Using different digest sizes<a class="headerlink" href="#using-different-digest-sizes" title="제목 주소">¶</a></h4>
<p>BLAKE2 has configurable size of digests up to 64 bytes for BLAKE2b and up to 32
bytes for BLAKE2s. For example, to replace SHA-1 with BLAKE2b without changing
the size of output, we can tell BLAKE2b to produce 20-byte digests:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Replacing SHA1 with the more secure function&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;d24f26cf8de66472d58d4e1b1774b4c9158b1f4c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">digest_size</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
<span class="go">20</span>
</pre></div>
</div>
<p>Hash objects with different digest sizes have completely different outputs
(shorter hashes are <em>not</em> prefixes of longer hashes); BLAKE2b and BLAKE2s
produce different outputs even if the output length is the same:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span><span class="p">,</span> <span class="n">blake2s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;6fa1d8fcfd719046d762&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">11</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;eb6ec15daf9546254f0809&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2s</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;1bf21a98c78a1c376ae9&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blake2s</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">11</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;567004bf96e4a25773ebf4&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="keyed-hashing">
<h4>Keyed hashing<a class="headerlink" href="#keyed-hashing" title="제목 주소">¶</a></h4>
<p>Keyed hashing can be used for authentication as a faster and simpler
replacement for <a class="reference external" href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">Hash-based message authentication code</a> (HMAC).
BLAKE2 can be securely used in prefix-MAC mode thanks to the
indifferentiability property inherited from BLAKE.</p>
<p>This example shows how to get a (hex-encoded) 128-bit authentication code for
message <code class="docutils literal notranslate"><span class="pre">b'message</span> <span class="pre">data'</span></code> with key <code class="docutils literal notranslate"><span class="pre">b'pseudorandom</span> <span class="pre">key'</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;pseudorandom key&#39;</span><span class="p">,</span> <span class="n">digest_size</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;message data&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;3d363ff7401e02026f4a4687d4863ced&#39;</span>
</pre></div>
</div>
<p>As a practical example, a web application can symmetrically sign cookies sent
to users and later verify them to make sure they weren't tampered with:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hmac</span> <span class="k">import</span> <span class="n">compare_digest</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SECRET_KEY</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;pseudorandomly generated server secret key&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AUTH_SIZE</span> <span class="o">=</span> <span class="mi">16</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="n">cookie</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="n">AUTH_SIZE</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">SECRET_KEY</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cookie</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="n">cookie</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">good_sig</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">cookie</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">compare_digest</span><span class="p">(</span><span class="n">good_sig</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cookie</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;user-alice&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">cookie</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">,</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cookie</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span> <span class="n">sig</span><span class="p">))</span>
<span class="go">user-alice,b&#39;43b3c982cf697e0c5ab22172d1ca7421&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verify</span><span class="p">(</span><span class="n">cookie</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verify</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;user-bob&#39;</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verify</span><span class="p">(</span><span class="n">cookie</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;0102030405060708090a0b0c0d0e0f00&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Even though there's a native keyed hashing mode, BLAKE2 can, of course, be used
in HMAC construction with <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a> module:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hmac</span><span class="o">,</span> <span class="nn">hashlib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;secret key&#39;</span><span class="p">,</span> <span class="n">digestmod</span><span class="o">=</span><span class="n">hashlib</span><span class="o">.</span><span class="n">blake2s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;message&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;e3c8102868d28b5ff85fc35dda07329970d1a01e273c37481326fe0c861c8142&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="randomized-hashing">
<h4>Randomized hashing<a class="headerlink" href="#randomized-hashing" title="제목 주소">¶</a></h4>
<p>By setting <em>salt</em> parameter users can introduce randomization to the hash
function. Randomized hashing is useful for protecting against collision attacks
on the hash function used in digital signatures.</p>
<blockquote>
<div><p>Randomized hashing is designed for situations where one party, the message
preparer, generates all or part of a message to be signed by a second
party, the message signer. If the message preparer is able to find
cryptographic hash function collisions (i.e., two messages producing the
same hash value), then they might prepare meaningful versions of the message
that would produce the same hash value and digital signature, but with
different results (e.g., transferring $1,000,000 to an account, rather than
$10). Cryptographic hash functions have been designed with collision
resistance as a major goal, but the current concentration on attacking
cryptographic hash functions may result in a given cryptographic hash
function providing less collision resistance than expected. Randomized
hashing offers the signer additional protection by reducing the likelihood
that a preparer can generate two or more messages that ultimately yield the
same hash value during the digital signature generation process --- even if
it is practical to find collisions for the hash function. However, the use
of randomized hashing may reduce the amount of security provided by a
digital signature when all portions of the message are prepared
by the signer.</p>
<p>(<a class="reference external" href="https://csrc.nist.gov/publications/detail/sp/800-106/final">NIST SP-800-106 &quot;Randomized Hashing for Digital Signatures&quot;</a>)</p>
</div></blockquote>
<p>In BLAKE2 the salt is processed as a one-time input to the hash function during
initialization, rather than as an input to each compression function.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p><em>Salted hashing</em> (or just hashing) with BLAKE2 or any other general-purpose
cryptographic hash function, such as SHA-256, is not suitable for hashing
passwords.  See <a class="reference external" href="https://blake2.net/#qa">BLAKE2 FAQ</a> for more
information.</p>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;some message&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calculate the first hash with a random salt.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">salt1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="n">blake2b</span><span class="o">.</span><span class="n">SALT_SIZE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h1</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">salt</span><span class="o">=</span><span class="n">salt1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calculate the second hash with a different random salt.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">salt2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="n">blake2b</span><span class="o">.</span><span class="n">SALT_SIZE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h2</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">salt</span><span class="o">=</span><span class="n">salt2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h2</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The digests are different.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h1</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span> <span class="o">!=</span> <span class="n">h2</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="personalization">
<h4>Personalization<a class="headerlink" href="#personalization" title="제목 주소">¶</a></h4>
<p>Sometimes it is useful to force hash function to produce different digests for
the same input for different purposes. Quoting the authors of the Skein hash
function:</p>
<blockquote>
<div><p>We recommend that all application designers seriously consider doing this;
we have seen many protocols where a hash that is computed in one part of
the protocol can be used in an entirely different part because two hash
computations were done on similar or related data, and the attacker can
force the application to make the hash inputs the same. Personalizing each
hash function used in the protocol summarily stops this type of attack.</p>
<p>(<a class="reference external" href="http://www.skein-hash.info/sites/default/files/skein1.3.pdf">The Skein Hash Function Family</a>,
p. 21)</p>
</div></blockquote>
<p>BLAKE2 can be personalized by passing bytes to the <em>person</em> argument:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FILES_HASH_PERSON</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;MyApp Files Hash&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BLOCK_HASH_PERSON</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;MyApp Block Hash&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">person</span><span class="o">=</span><span class="n">FILES_HASH_PERSON</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;the same content&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;20d9cd024d4fb086aae819a1432dd2466de12947831b75c5a30cf2676095d3b4&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">person</span><span class="o">=</span><span class="n">BLOCK_HASH_PERSON</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;the same content&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;cf68fb5761b9c44e7878bfb2c4c9aea52264a80b75005e65619778de59f383a3&#39;</span>
</pre></div>
</div>
<p>Personalization together with the keyed mode can also be used to derive different
keys from a single one.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">base64</span> <span class="k">import</span> <span class="n">b64decode</span><span class="p">,</span> <span class="n">b64encode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orig_key</span> <span class="o">=</span> <span class="n">b64decode</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Rm5EPJai72qcK3RGBpW3vPNfZy5OZothY+kHY6h21KM=&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enc_key</span> <span class="o">=</span> <span class="n">blake2s</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">orig_key</span><span class="p">,</span> <span class="n">person</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;kEncrypt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mac_key</span> <span class="o">=</span> <span class="n">blake2s</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">orig_key</span><span class="p">,</span> <span class="n">person</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;kMAC&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b64encode</span><span class="p">(</span><span class="n">enc_key</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">rbPb15S/Z9t+agffno5wuhB77VbRi6F9Iv2qIxU7WHw=</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b64encode</span><span class="p">(</span><span class="n">mac_key</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">G9GtHFE1YluXY1zWPlYk1e/nWfu0WSEb0KRcjhDeP/o=</span>
</pre></div>
</div>
</div>
<div class="section" id="tree-mode">
<h4>Tree mode<a class="headerlink" href="#tree-mode" title="제목 주소">¶</a></h4>
<p>Here's an example of hashing a minimal tree with two leaf nodes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>  <span class="mi">10</span>
 <span class="o">/</span>  \
<span class="mi">00</span>  <span class="mi">01</span>
</pre></div>
</div>
<p>This example uses 64-byte internal digests, and returns the 32-byte final
digest:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">blake2b</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FANOUT</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DEPTH</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LEAF_SIZE</span> <span class="o">=</span> <span class="mi">4096</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">INNER_SIZE</span> <span class="o">=</span> <span class="mi">64</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">6000</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Left leaf</span>
<span class="gp">... </span><span class="n">h00</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">LEAF_SIZE</span><span class="p">],</span> <span class="n">fanout</span><span class="o">=</span><span class="n">FANOUT</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">DEPTH</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">leaf_size</span><span class="o">=</span><span class="n">LEAF_SIZE</span><span class="p">,</span> <span class="n">inner_size</span><span class="o">=</span><span class="n">INNER_SIZE</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">node_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">last_node</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Right leaf</span>
<span class="gp">... </span><span class="n">h01</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">LEAF_SIZE</span><span class="p">:],</span> <span class="n">fanout</span><span class="o">=</span><span class="n">FANOUT</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">DEPTH</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">leaf_size</span><span class="o">=</span><span class="n">LEAF_SIZE</span><span class="p">,</span> <span class="n">inner_size</span><span class="o">=</span><span class="n">INNER_SIZE</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">node_offset</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">node_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">last_node</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Root node</span>
<span class="gp">... </span><span class="n">h10</span> <span class="o">=</span> <span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">fanout</span><span class="o">=</span><span class="n">FANOUT</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">DEPTH</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">leaf_size</span><span class="o">=</span><span class="n">LEAF_SIZE</span><span class="p">,</span> <span class="n">inner_size</span><span class="o">=</span><span class="n">INNER_SIZE</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">node_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">node_depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">last_node</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h10</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">h00</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h10</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">h01</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h10</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;3ad2a9b37c6070e374c7a8c508fe20ca86b6ed54e286e93a0318e95e881db5aa&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="credits">
<h3>Credits<a class="headerlink" href="#credits" title="제목 주소">¶</a></h3>
<p><a class="reference external" href="https://blake2.net">BLAKE2</a> was designed by <em>Jean-Philippe Aumasson</em>, <em>Samuel Neves</em>, <em>Zooko
Wilcox-O'Hearn</em>, and <em>Christian Winnerlein</em> based on <a class="reference external" href="https://en.wikipedia.org/wiki/NIST_hash_function_competition">SHA-3</a> finalist <a class="reference external" href="https://131002.net/blake/">BLAKE</a>
created by <em>Jean-Philippe Aumasson</em>, <em>Luca Henzen</em>, <em>Willi Meier</em>, and
<em>Raphael C.-W. Phan</em>.</p>
<p>It uses core algorithm from <a class="reference external" href="https://cr.yp.to/chacha.html">ChaCha</a> cipher designed by <em>Daniel J.  Bernstein</em>.</p>
<p>The stdlib implementation is based on <a class="reference external" href="https://pythonhosted.org/pyblake2/">pyblake2</a> module. It was written by
<em>Dmitry Chestnykh</em> based on C implementation written by <em>Samuel Neves</em>. The
documentation was copied from <a class="reference external" href="https://pythonhosted.org/pyblake2/">pyblake2</a> and written by <em>Dmitry Chestnykh</em>.</p>
<p>The C code was partly rewritten for Python by <em>Christian Heimes</em>.</p>
<p>The following public domain dedication applies for both C hash function
implementation, extension code, and this documentation:</p>
<blockquote>
<div><p>To the extent possible under law, the author(s) have dedicated all copyright
and related and neighboring rights to this software to the public domain
worldwide. This software is distributed without any warranty.</p>
<p>You should have received a copy of the CC0 Public Domain Dedication along
with this software. If not, see
<a class="reference external" href="https://creativecommons.org/publicdomain/zero/1.0/">https://creativecommons.org/publicdomain/zero/1.0/</a>.</p>
</div></blockquote>
<p>The following people have helped with development or contributed their changes
to the project and the public domain according to the Creative Commons Public
Domain Dedication 1.0 Universal:</p>
<ul class="simple">
<li><p><em>Alexandr Sokolovskiy</em></p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt>Module <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a></dt><dd><p>A module to generate message authentication codes using hashes.</p>
</dd>
<dt>Module <a class="reference internal" href="base64.html#module-base64" title="base64: RFC 3548: Base16, Base32, Base64 Data Encodings; Base85 and Ascii85"><code class="xref py py-mod docutils literal notranslate"><span class="pre">base64</span></code></a></dt><dd><p>Another way to encode binary hashes for non-binary environments.</p>
</dd>
<dt><a class="reference external" href="https://blake2.net">https://blake2.net</a></dt><dd><p>Official BLAKE2 website.</p>
</dd>
<dt><a class="reference external" href="https://csrc.nist.gov/csrc/media/publications/fips/180/2/archive/2002-08-01/documents/fips180-2.pdf">https://csrc.nist.gov/csrc/media/publications/fips/180/2/archive/2002-08-01/documents/fips180-2.pdf</a></dt><dd><p>The FIPS 180-2 publication on Secure Hash Algorithms.</p>
</dd>
<dt><a class="reference external" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function#Cryptographic_hash_algorithms">https://en.wikipedia.org/wiki/Cryptographic_hash_function#Cryptographic_hash_algorithms</a></dt><dd><p>Wikipedia article with information on which algorithms have known issues and
what that means regarding their use.</p>
</dd>
<dt><a class="reference external" href="https://www.ietf.org/rfc/rfc2898.txt">https://www.ietf.org/rfc/rfc2898.txt</a></dt><dd><p>PKCS #5: Password-Based Cryptography Specification Version 2.0</p>
</dd>
</dl>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code> --- 보안 해시와 메시지 요약</a><ul>
<li><a class="reference internal" href="#hash-algorithms">해시 알고리즘</a></li>
<li><a class="reference internal" href="#shake-variable-length-digests">SHAKE 가변 길이 요약</a></li>
<li><a class="reference internal" href="#key-derivation">키 파생</a></li>
<li><a class="reference internal" href="#blake2">BLAKE2</a><ul>
<li><a class="reference internal" href="#creating-hash-objects">해시 객체 만들기</a></li>
<li><a class="reference internal" href="#constants">상수</a></li>
<li><a class="reference internal" href="#examples">예</a><ul>
<li><a class="reference internal" href="#simple-hashing">Simple hashing</a></li>
<li><a class="reference internal" href="#using-different-digest-sizes">Using different digest sizes</a></li>
<li><a class="reference internal" href="#keyed-hashing">Keyed hashing</a></li>
<li><a class="reference internal" href="#randomized-hashing">Randomized hashing</a></li>
<li><a class="reference internal" href="#personalization">Personalization</a></li>
<li><a class="reference internal" href="#tree-mode">Tree mode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#credits">Credits</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="crypto.html"
                        title="이전 장">암호화 서비스</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="hmac.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code> --- 메시지 인증을 위한 키 해싱</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="hmac.html" title="hmac --- 메시지 인증을 위한 키 해싱"
             >다음</a> |</li>
        <li class="right" >
          <a href="crypto.html" title="암호화 서비스"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="crypto.html" >암호화 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>