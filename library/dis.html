
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>dis --- 파이썬 바이트 코드 역 어셈블러 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="pickletools --- 피클 개발자를 위한 도구" href="pickletools.html" />
    <link rel="prev" title="compileall --- 파이썬 라이브러리 바이트 컴파일하기" href="compileall.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/dis.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="pickletools.html" title="pickletools --- 피클 개발자를 위한 도구"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="compileall.html" title="compileall --- 파이썬 라이브러리 바이트 컴파일하기"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="language.html" accesskey="U">파이썬 언어 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-dis">
<span id="dis-disassembler-for-python-bytecode"></span><h1><a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code></a> --- 파이썬 바이트 코드 역 어셈블러<a class="headerlink" href="#module-dis" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/dis.py">Lib/dis.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code></a> 모듈은 CPython <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">바이트 코드</span></a>를 역 어셈블링하여 분석을 지원합니다. 이 모듈이 입력으로 취하는 CPython 바이트 코드는 파일 <code class="file docutils literal notranslate"><span class="pre">Include/opcode.h</span></code>에 정의되어 있으며 컴파일러와 인터프리터에서 사용됩니다.</p>
<div class="impl-detail compound">
<p class="compound-first"><strong>CPython implementation detail:</strong> 바이트 코드는 CPython 인터프리터의 구현 세부 사항입니다. 파이썬 버전 간에 바이트 코드가 추가, 제거 또는 변경되지 않을 것이라는 보장은 없습니다. 이 모듈을 사용하는 것이 파이썬 VM이나 파이썬 릴리스에 걸쳐 작동할 것으로 생각하지 말아야합니다.</p>
<div class="compound-last versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>각 명령어마다 2바이트를 사용합니다. 이전에는 바이트 수가 명령어에 따라 달랐습니다.</p>
</div>
</div>
<p>예: 주어진 함수 <code class="xref py py-func docutils literal notranslate"><span class="pre">myfunc()</span></code>에 대해:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">myfunc</span><span class="p">(</span><span class="n">alist</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
</pre></div>
</div>
<p>다음 명령을 사용하여 <code class="xref py py-func docutils literal notranslate"><span class="pre">myfunc()</span></code>의 역 어셈블리를 표시할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">myfunc</span><span class="p">)</span>
<span class="go">  2           0 LOAD_GLOBAL              0 (len)</span>
<span class="go">              2 LOAD_FAST                0 (alist)</span>
<span class="go">              4 CALL_FUNCTION            1</span>
<span class="go">              6 RETURN_VALUE</span>
</pre></div>
</div>
<p>(&quot;2&quot;는 줄 번호입니다).</p>
<div class="section" id="bytecode-analysis">
<h2>바이트 코드 분석<a class="headerlink" href="#bytecode-analysis" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<p>바이트 코드 분석 API는 컴파일 된 코드의 세부 사항에 쉽게 액세스 할 수 있도록 하는 <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bytecode</span></code></a> 객체로 파이썬 코드 조각을 감쌀 수 있도록 합니다.</p>
<dl class="class">
<dt id="dis.Bytecode">
<em class="property">class </em><code class="sig-prename descclassname">dis.</code><code class="sig-name descname">Bytecode</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">*</em>, <em class="sig-param">first_line=None</em>, <em class="sig-param">current_offset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dis.Bytecode" title="정의 주소">¶</a></dt>
<dd><p>함수, 제너레이터, 비동기 제너레이터, 코루틴, 메서드, 소스 코드 문자열 또는 (<a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>에서 반환된) 코드 객체에 해당하는 바이트 코드를 분석합니다.</p>
<p>이것은 아래에 나열된 많은 함수, 특히 <a class="reference internal" href="#dis.get_instructions" title="dis.get_instructions"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_instructions()</span></code></a>를 둘러싼 편리한 래퍼입니다, <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bytecode</span></code></a> 인스턴스를 이터레이트하면 바이트 코드 연산이 <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Instruction</span></code></a> 인스턴스로 산출되기 때문입니다.</p>
<p><em>first_line</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면, 역 어셈블된 코드에서 첫 번째 소스 줄에 대해 보고해야 하는 줄 번호를 나타냅니다. 그렇지 않으면, 소스 줄 정보(있다면)를 역 어셈블 된 코드 객체에서 직접 취합니다.</p>
<p><em>current_offset</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면, 역 어셈블 된 코드의 명령어 오프셋을 나타냅니다. 이를 설정하면, <a class="reference internal" href="#dis.Bytecode.dis" title="dis.Bytecode.dis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dis()</span></code></a>가 지정된 옵코드(opcode)에 대해 &quot;현재 명령어&quot; 마커를 표시합니다.</p>
<dl class="method">
<dt id="dis.Bytecode.from_traceback">
<em class="property">classmethod </em><code class="sig-name descname">from_traceback</code><span class="sig-paren">(</span><em class="sig-param">tb</em><span class="sig-paren">)</span><a class="headerlink" href="#dis.Bytecode.from_traceback" title="정의 주소">¶</a></dt>
<dd><p>주어진 트레이스백에서 <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bytecode</span></code></a> 인스턴스를 구성하고, <em>current_offset</em>을 예외를 일으킨 명령어로 설정합니다.</p>
</dd></dl>

<dl class="data">
<dt id="dis.Bytecode.codeobj">
<code class="sig-name descname">codeobj</code><a class="headerlink" href="#dis.Bytecode.codeobj" title="정의 주소">¶</a></dt>
<dd><p>컴파일 된 코드 객체.</p>
</dd></dl>

<dl class="data">
<dt id="dis.Bytecode.first_line">
<code class="sig-name descname">first_line</code><a class="headerlink" href="#dis.Bytecode.first_line" title="정의 주소">¶</a></dt>
<dd><p>코드 객체의 첫 번째 소스 줄 (사용 가능하다면)</p>
</dd></dl>

<dl class="method">
<dt id="dis.Bytecode.dis">
<code class="sig-name descname">dis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dis.Bytecode.dis" title="정의 주소">¶</a></dt>
<dd><p>바이트 코드 연산의 포맷된 보기를 반환합니다 (<a class="reference internal" href="#dis.dis" title="dis.dis"><code class="xref py py-func docutils literal notranslate"><span class="pre">dis.dis()</span></code></a>가 인쇄하는 것과 같지만, 여러 줄 문자열로 반환됩니다).</p>
</dd></dl>

<dl class="method">
<dt id="dis.Bytecode.info">
<code class="sig-name descname">info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dis.Bytecode.info" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#dis.code_info" title="dis.code_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">code_info()</span></code></a>처럼, 코드 객체에 대한 자세한 정보가 포함된 포맷된 여러 줄 문자열을 반환합니다.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이제 코루틴과 비동기 제너레이터 객체를 처리할 수 있습니다.</p>
</div>
</dd></dl>

<p>예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bytecode</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="n">Bytecode</span><span class="p">(</span><span class="n">myfunc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">bytecode</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">opname</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">LOAD_GLOBAL</span>
<span class="go">LOAD_FAST</span>
<span class="go">CALL_FUNCTION</span>
<span class="go">RETURN_VALUE</span>
</pre></div>
</div>
</div>
<div class="section" id="analysis-functions">
<h2>분석 함수<a class="headerlink" href="#analysis-functions" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code></a> 모듈은 또한 입력을 원하는 출력으로 직접 변환하는 다음 분석 함수를 정의합니다. 단일 작업만 수행해서, 중간 분석 객체가 유용하지 않을 때 유용할 수 있습니다:</p>
<dl class="function">
<dt id="dis.code_info">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">code_info</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#dis.code_info" title="정의 주소">¶</a></dt>
<dd><p>제공된 함수, 제너레이터, 비동기 제너레이터, 코루틴, 메서드, 소스 코드 문자열 또는 코드 객체에 대한 자세한 코드 객체 정보가 포함된 포맷된 여러 줄 문자열을 반환합니다.</p>
<p>코드 정보 문자열의 정확한 내용은 구현에 따라 달라지며 파이썬 VM이나 파이썬 릴리스에 걸쳐 임의로 변경될 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이제 코루틴과 비동기 제너레이터 객체를 처리할 수 있습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="dis.show_code">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">show_code</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">*</em>, <em class="sig-param">file=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dis.show_code" title="정의 주소">¶</a></dt>
<dd><p>제공된 함수, 메서드, 소스 코드 문자열 또는 코드 객체에 대한 자세한 코드 객체 정보를 <em>file</em>(또는 <em>file</em>이 지정되지 않으면 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>)로 인쇄합니다.</p>
<p>이것은 <code class="docutils literal notranslate"><span class="pre">print(code_info(x),</span> <span class="pre">file=file)</span></code>의 편리한 축약 형으로, 인터프리터 프롬프트에서의 대화식 탐색을 위한 것입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><em>file</em> 매개 변수를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="dis.dis">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">dis</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">*</em>, <em class="sig-param">file=None</em>, <em class="sig-param">depth=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dis.dis" title="정의 주소">¶</a></dt>
<dd><p><em>x</em> 객체를 역 어셈블합니다. <em>x</em>는 모듈, 클래스, 메서드, 함수, 제너레이터, 비동기 제너레이터, 코루틴, 코드 객체, 소스 코드 문자열 또는 원시 바이트 코드의 바이트 시퀀스를 나타낼 수 있습니다. 모듈의 경우, 모든 함수를 역 어셈블합니다. 클래스의 경우, 모든 메서드(클래스와 정적 메서드를 포함합니다)를 역 어셈블합니다. 코드 객체나 원시 바이트 코드 시퀀스의 경우, 바이트 코드 명령어 당 한 줄을 인쇄합니다. 또한 중첩 코드 객체(컴프리헨션, 제너레이터 표현식 및 중첩 함수의 코드와 중첩 클래스을 만드는데 사용된 코드)를 재귀적으로 역 어셈블합니다. 문자열은 역 어셈블되기 전에 먼저 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 내장 함수를 사용하여 코드 객체로 컴파일됩니다. 객체가 제공되지 않으면, 이 함수는 마지막 트레이스백을 역 어셈블합니다.</p>
<p>역 어셈블리는 제공된다면 제공된 <em>file</em> 인자에, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>에 텍스트로 기록됩니다.</p>
<p>재귀의 최대 깊이는 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아닌 한 <em>depth</em>에 의해 제한됩니다. <code class="docutils literal notranslate"><span class="pre">depth=0</span></code>은 재귀가 없음을 의미합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><em>file</em> 매개 변수를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>재귀 역 어셈블을 구현하고 <em>depth</em> 매개 변수를 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이제 코루틴과 비동기 제너레이터 객체를 처리할 수 있습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="dis.distb">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">distb</code><span class="sig-paren">(</span><em class="sig-param">tb=None</em>, <em class="sig-param">*</em>, <em class="sig-param">file=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dis.distb" title="정의 주소">¶</a></dt>
<dd><p>트레이스백의 최상단 함수를 역 어셈블합니다. 전달되지 않으면 마지막 트레이스백을 사용합니다. 예외를 일으키는 명령어가 표시됩니다.</p>
<p>역 어셈블리는 제공된다면 제공된 <em>file</em> 인자에, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>에 텍스트로 기록됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><em>file</em> 매개 변수를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="dis.disassemble">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">disassemble</code><span class="sig-paren">(</span><em class="sig-param">code</em>, <em class="sig-param">lasti=-1</em>, <em class="sig-param">*</em>, <em class="sig-param">file=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dis.disassemble" title="정의 주소">¶</a></dt>
<dt id="dis.disco">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">disco</code><span class="sig-paren">(</span><em class="sig-param">code</em>, <em class="sig-param">lasti=-1</em>, <em class="sig-param">*</em>, <em class="sig-param">file=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dis.disco" title="정의 주소">¶</a></dt>
<dd><p>코드 객체를 역 어셈블하고, <em>lasti</em>가 제공되면 마지막 명령어를 표시합니다. 출력은 다음 열로 나뉩니다:</p>
<ol class="arabic simple">
<li><p>줄 번호, 각 줄의 첫 번째 명령어에 표시됩니다</p></li>
<li><p>현재 명령어, <code class="docutils literal notranslate"><span class="pre">--&gt;</span></code>로 표시됩니다,</p></li>
<li><p>레이블이있는 명령어, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>로 표시됩니다,</p></li>
<li><p>명령어의 주소,</p></li>
<li><p>연산 코드 이름,</p></li>
<li><p>연산 매개 변수, 그리고</p></li>
<li><p>괄호 안에 있는 매개 변수의 해석.</p></li>
</ol>
<p>매개 변수 해석은 지역과 전역 변수 이름, 상수 값, 분기 대상 및 비교 연산자를 인식합니다.</p>
<p>역 어셈블리는 제공된다면 제공된 <em>file</em> 인자에, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>에 텍스트로 기록됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><em>file</em> 매개 변수를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="dis.get_instructions">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">get_instructions</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">*</em>, <em class="sig-param">first_line=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dis.get_instructions" title="정의 주소">¶</a></dt>
<dd><p>제공된 함수, 메서드, 소스 코드 문자열 또는 코드 객체의 명령어들에 대한 이터레이터를 반환합니다.</p>
<p>이터레이터는 제공된 코드의 각 연산에 대한 세부 정보를 제공하는 <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Instruction</span></code></a> 네임드 튜플의 연속을 생성합니다.</p>
<p><em>first_line</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이 아니면, 역 어셈블된 코드에서 첫 번째 소스 줄에 대해 보고해야 하는 줄 번호를 나타냅니다. 그렇지 않으면, 소스 줄 정보(있다면)를 역 어셈블 된 코드 객체에서 직접 취합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="dis.findlinestarts">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">findlinestarts</code><span class="sig-paren">(</span><em class="sig-param">code</em><span class="sig-paren">)</span><a class="headerlink" href="#dis.findlinestarts" title="정의 주소">¶</a></dt>
<dd><p>이 제너레이터 함수는 코드 객체 <em>code</em>의 <code class="docutils literal notranslate"><span class="pre">co_firstlineno</span></code>와 <code class="docutils literal notranslate"><span class="pre">co_lnotab</span></code> 어트리뷰트를 사용하여 소스 코드에서 줄의 시작을 가리키는 오프셋을 찾습니다. <code class="docutils literal notranslate"><span class="pre">(offset,</span> <span class="pre">lineno)</span></code> 쌍으로 생성됩니다. <code class="docutils literal notranslate"><span class="pre">co_lnotab</span></code> 형식과 디코딩 방법은 <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Objects/lnotab_notes.txt">Objects/lnotab_notes.txt</a>를 참조하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>줄 번호가 줄어들 수 있습니다. 전에는, 언제나 증가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="dis.findlabels">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">findlabels</code><span class="sig-paren">(</span><em class="sig-param">code</em><span class="sig-paren">)</span><a class="headerlink" href="#dis.findlabels" title="정의 주소">¶</a></dt>
<dd><p>코드 객체 <em>code</em>에서 점프 대상인 모든 오프셋을 감지하고, 이러한 오프셋의 리스트를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="dis.stack_effect">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">stack_effect</code><span class="sig-paren">(</span><em class="sig-param">opcode</em>, <em class="sig-param">oparg=None</em>, <em class="sig-param">*</em>, <em class="sig-param">jump=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dis.stack_effect" title="정의 주소">¶</a></dt>
<dd><p>인자 <em>oparg</em>를 갖는 <em>opcode</em>의 스택 효과를 계산합니다.</p>
<p>코드에 점프 대상이 있고 <em>jump</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, <a class="reference internal" href="#dis.stack_effect" title="dis.stack_effect"><code class="xref py py-func docutils literal notranslate"><span class="pre">stack_effect()</span></code></a>는 점프의 스택 효과를 반환합니다. <em>jump</em>가 <code class="docutils literal notranslate"><span class="pre">False</span></code>이면, 점프하지 않는 스택 효과를 반환합니다. <em>jump</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>(기본값)이면, 두 경우의 최대 스택 효과를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><em>jump</em> 매개 변수를 추가했습니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="python-bytecode-instructions">
<span id="bytecodes"></span><h2>파이썬 바이트 코드 명령어<a class="headerlink" href="#python-bytecode-instructions" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#dis.get_instructions" title="dis.get_instructions"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_instructions()</span></code></a> 함수와 <a class="reference internal" href="#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bytecode</span></code></a> 클래스는 바이트 코드 명령어의 세부 사항을 <a class="reference internal" href="#dis.Instruction" title="dis.Instruction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Instruction</span></code></a> 인스턴스로 제공합니다:</p>
<dl class="class">
<dt id="dis.Instruction">
<em class="property">class </em><code class="sig-prename descclassname">dis.</code><code class="sig-name descname">Instruction</code><a class="headerlink" href="#dis.Instruction" title="정의 주소">¶</a></dt>
<dd><p>바이트 코드 연산에 대한 세부 사항</p>
<dl class="data">
<dt id="dis.Instruction.opcode">
<code class="sig-name descname">opcode</code><a class="headerlink" href="#dis.Instruction.opcode" title="정의 주소">¶</a></dt>
<dd><p>연산의 숫자 코드, 아래 나열된 옵코드 값과 <a class="reference internal" href="#opcode-collections"><span class="std std-ref">옵코드 모음</span></a>에 있는 바이트 코드 값에 해당합니다.</p>
</dd></dl>

<dl class="data">
<dt id="dis.Instruction.opname">
<code class="sig-name descname">opname</code><a class="headerlink" href="#dis.Instruction.opname" title="정의 주소">¶</a></dt>
<dd><p>연산의 사람이 읽을 수 있는 이름</p>
</dd></dl>

<dl class="data">
<dt id="dis.Instruction.arg">
<code class="sig-name descname">arg</code><a class="headerlink" href="#dis.Instruction.arg" title="정의 주소">¶</a></dt>
<dd><p>연산에 대한 숫자 인자 (있다면), 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

<dl class="data">
<dt id="dis.Instruction.argval">
<code class="sig-name descname">argval</code><a class="headerlink" href="#dis.Instruction.argval" title="정의 주소">¶</a></dt>
<dd><p>해석된(resolved) arg 값 (알고있다면), 그렇지 않으면 arg와 같습니다</p>
</dd></dl>

<dl class="data">
<dt id="dis.Instruction.argrepr">
<code class="sig-name descname">argrepr</code><a class="headerlink" href="#dis.Instruction.argrepr" title="정의 주소">¶</a></dt>
<dd><p>연산 인자에 대한 사람이 읽을 수 있는 설명</p>
</dd></dl>

<dl class="data">
<dt id="dis.Instruction.offset">
<code class="sig-name descname">offset</code><a class="headerlink" href="#dis.Instruction.offset" title="정의 주소">¶</a></dt>
<dd><p>바이트 코드 시퀀스 내에서 연산의 시작 인덱스</p>
</dd></dl>

<dl class="data">
<dt id="dis.Instruction.starts_line">
<code class="sig-name descname">starts_line</code><a class="headerlink" href="#dis.Instruction.starts_line" title="정의 주소">¶</a></dt>
<dd><p>이 옵코드에 의해 시작된 줄 (있다면), 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

<dl class="data">
<dt id="dis.Instruction.is_jump_target">
<code class="sig-name descname">is_jump_target</code><a class="headerlink" href="#dis.Instruction.is_jump_target" title="정의 주소">¶</a></dt>
<dd><p>다른 코드가 여기로 점프하면 <code class="docutils literal notranslate"><span class="pre">True</span></code>, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code></p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<p>파이썬 컴파일러는 현재 다음 바이트 코드 명령어를 생성합니다.</p>
<p><strong>일반 명령어</strong></p>
<dl class="opcode">
<dt id="opcode-NOP">
<code class="sig-name descname">NOP</code><a class="headerlink" href="#opcode-NOP" title="정의 주소">¶</a></dt>
<dd><p>아무것도 하지 않는 코드. 바이트 코드 최적화기에서 자리 표시자로 사용됩니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-POP_TOP">
<code class="sig-name descname">POP_TOP</code><a class="headerlink" href="#opcode-POP_TOP" title="정의 주소">¶</a></dt>
<dd><p>스택 최상단 (TOS) 항목을 제거합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-ROT_TWO">
<code class="sig-name descname">ROT_TWO</code><a class="headerlink" href="#opcode-ROT_TWO" title="정의 주소">¶</a></dt>
<dd><p>두 개의 최상위 스택 항목을 자리바꿈합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-ROT_THREE">
<code class="sig-name descname">ROT_THREE</code><a class="headerlink" href="#opcode-ROT_THREE" title="정의 주소">¶</a></dt>
<dd><p>두 번째와 세 번째 스택 항목을 한 자리 위로 들어 올리고, 최상단 항목을 세 번째 자리로 내립니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-ROT_FOUR">
<code class="sig-name descname">ROT_FOUR</code><a class="headerlink" href="#opcode-ROT_FOUR" title="정의 주소">¶</a></dt>
<dd><p>두 번째, 세 번째 및 네 번째 스택 항목을 한 자리 위로 들어 올리고, 최상단 항목을 네 번째 자리로 내립니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-DUP_TOP">
<code class="sig-name descname">DUP_TOP</code><a class="headerlink" href="#opcode-DUP_TOP" title="정의 주소">¶</a></dt>
<dd><p>스택 최상단의 참조를 복제합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-DUP_TOP_TWO">
<code class="sig-name descname">DUP_TOP_TWO</code><a class="headerlink" href="#opcode-DUP_TOP_TWO" title="정의 주소">¶</a></dt>
<dd><p>같은 순서를 유지하면서, 스택 최상단의 두 참조를 복제합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<p><strong>단항 연산</strong></p>
<p>단항 연산은 스택의 최상단을 취하고, 연산을 적용한 다음, 결과를 스택에 다시 푸시합니다.</p>
<dl class="opcode">
<dt id="opcode-UNARY_POSITIVE">
<code class="sig-name descname">UNARY_POSITIVE</code><a class="headerlink" href="#opcode-UNARY_POSITIVE" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">+TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-UNARY_NEGATIVE">
<code class="sig-name descname">UNARY_NEGATIVE</code><a class="headerlink" href="#opcode-UNARY_NEGATIVE" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">-TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-UNARY_NOT">
<code class="sig-name descname">UNARY_NOT</code><a class="headerlink" href="#opcode-UNARY_NOT" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">not</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-UNARY_INVERT">
<code class="sig-name descname">UNARY_INVERT</code><a class="headerlink" href="#opcode-UNARY_INVERT" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">~TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-GET_ITER">
<code class="sig-name descname">GET_ITER</code><a class="headerlink" href="#opcode-GET_ITER" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">iter(TOS)</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-GET_YIELD_FROM_ITER">
<code class="sig-name descname">GET_YIELD_FROM_ITER</code><a class="headerlink" href="#opcode-GET_YIELD_FROM_ITER" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span></code>가 <a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">제너레이터 이터레이터</span></a>나 <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a> 객체이면 그대로 둡니다. 그렇지 않으면, <code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">iter(TOS)</span></code>를 구현합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<p><strong>이항 연산</strong></p>
<p>이항 연산은 스택에서 스택 최상단(TOS)과 두 번째 최상단 스택 항목(TOS1)을 제거합니다. 연산을 수행하고, 결과를 다시 스택에 넣습니다.</p>
<dl class="opcode">
<dt id="opcode-BINARY_POWER">
<code class="sig-name descname">BINARY_POWER</code><a class="headerlink" href="#opcode-BINARY_POWER" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">**</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BINARY_MULTIPLY">
<code class="sig-name descname">BINARY_MULTIPLY</code><a class="headerlink" href="#opcode-BINARY_MULTIPLY" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">*</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BINARY_MATRIX_MULTIPLY">
<code class="sig-name descname">BINARY_MATRIX_MULTIPLY</code><a class="headerlink" href="#opcode-BINARY_MATRIX_MULTIPLY" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">&#64;</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BINARY_FLOOR_DIVIDE">
<code class="sig-name descname">BINARY_FLOOR_DIVIDE</code><a class="headerlink" href="#opcode-BINARY_FLOOR_DIVIDE" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">//</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BINARY_TRUE_DIVIDE">
<code class="sig-name descname">BINARY_TRUE_DIVIDE</code><a class="headerlink" href="#opcode-BINARY_TRUE_DIVIDE" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">/</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BINARY_MODULO">
<code class="sig-name descname">BINARY_MODULO</code><a class="headerlink" href="#opcode-BINARY_MODULO" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">%</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BINARY_ADD">
<code class="sig-name descname">BINARY_ADD</code><a class="headerlink" href="#opcode-BINARY_ADD" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">+</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BINARY_SUBTRACT">
<code class="sig-name descname">BINARY_SUBTRACT</code><a class="headerlink" href="#opcode-BINARY_SUBTRACT" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">-</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BINARY_SUBSCR">
<code class="sig-name descname">BINARY_SUBSCR</code><a class="headerlink" href="#opcode-BINARY_SUBSCR" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1[TOS]</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BINARY_LSHIFT">
<code class="sig-name descname">BINARY_LSHIFT</code><a class="headerlink" href="#opcode-BINARY_LSHIFT" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">&lt;&lt;</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BINARY_RSHIFT">
<code class="sig-name descname">BINARY_RSHIFT</code><a class="headerlink" href="#opcode-BINARY_RSHIFT" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">&gt;&gt;</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BINARY_AND">
<code class="sig-name descname">BINARY_AND</code><a class="headerlink" href="#opcode-BINARY_AND" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">&amp;</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BINARY_XOR">
<code class="sig-name descname">BINARY_XOR</code><a class="headerlink" href="#opcode-BINARY_XOR" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">^</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BINARY_OR">
<code class="sig-name descname">BINARY_OR</code><a class="headerlink" href="#opcode-BINARY_OR" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">|</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<p><strong>제자리 연산</strong></p>
<p>제자리(in-place) 연산은 TOS와 TOS1을 제거하고, 스택에 결과를 다시 푸시한다는 점에서 이항 연산과 같습니다. 그러나 TOS1이 이를 지원하면 연산이 제자리에서 수행되며, 결과 TOS는 원래 TOS1일 수 있습니다 (하지만 꼭 그럴 필요는 없습니다).</p>
<dl class="opcode">
<dt id="opcode-INPLACE_POWER">
<code class="sig-name descname">INPLACE_POWER</code><a class="headerlink" href="#opcode-INPLACE_POWER" title="정의 주소">¶</a></dt>
<dd><p>제자리 <code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">**</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-INPLACE_MULTIPLY">
<code class="sig-name descname">INPLACE_MULTIPLY</code><a class="headerlink" href="#opcode-INPLACE_MULTIPLY" title="정의 주소">¶</a></dt>
<dd><p>제자리 <code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">*</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-INPLACE_MATRIX_MULTIPLY">
<code class="sig-name descname">INPLACE_MATRIX_MULTIPLY</code><a class="headerlink" href="#opcode-INPLACE_MATRIX_MULTIPLY" title="정의 주소">¶</a></dt>
<dd><p>제자리 <code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">&#64;</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-INPLACE_FLOOR_DIVIDE">
<code class="sig-name descname">INPLACE_FLOOR_DIVIDE</code><a class="headerlink" href="#opcode-INPLACE_FLOOR_DIVIDE" title="정의 주소">¶</a></dt>
<dd><p>제자리 <code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">//</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-INPLACE_TRUE_DIVIDE">
<code class="sig-name descname">INPLACE_TRUE_DIVIDE</code><a class="headerlink" href="#opcode-INPLACE_TRUE_DIVIDE" title="정의 주소">¶</a></dt>
<dd><p>제자리 <code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">/</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-INPLACE_MODULO">
<code class="sig-name descname">INPLACE_MODULO</code><a class="headerlink" href="#opcode-INPLACE_MODULO" title="정의 주소">¶</a></dt>
<dd><p>제자리 <code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">%</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-INPLACE_ADD">
<code class="sig-name descname">INPLACE_ADD</code><a class="headerlink" href="#opcode-INPLACE_ADD" title="정의 주소">¶</a></dt>
<dd><p>제자리 <code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">+</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-INPLACE_SUBTRACT">
<code class="sig-name descname">INPLACE_SUBTRACT</code><a class="headerlink" href="#opcode-INPLACE_SUBTRACT" title="정의 주소">¶</a></dt>
<dd><p>제자리 <code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">-</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-INPLACE_LSHIFT">
<code class="sig-name descname">INPLACE_LSHIFT</code><a class="headerlink" href="#opcode-INPLACE_LSHIFT" title="정의 주소">¶</a></dt>
<dd><p>제자리 <code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">&lt;&lt;</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-INPLACE_RSHIFT">
<code class="sig-name descname">INPLACE_RSHIFT</code><a class="headerlink" href="#opcode-INPLACE_RSHIFT" title="정의 주소">¶</a></dt>
<dd><p>제자리 <code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">&gt;&gt;</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-INPLACE_AND">
<code class="sig-name descname">INPLACE_AND</code><a class="headerlink" href="#opcode-INPLACE_AND" title="정의 주소">¶</a></dt>
<dd><p>제자리 <code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">&amp;</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-INPLACE_XOR">
<code class="sig-name descname">INPLACE_XOR</code><a class="headerlink" href="#opcode-INPLACE_XOR" title="정의 주소">¶</a></dt>
<dd><p>제자리 <code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">^</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-INPLACE_OR">
<code class="sig-name descname">INPLACE_OR</code><a class="headerlink" href="#opcode-INPLACE_OR" title="정의 주소">¶</a></dt>
<dd><p>제자리 <code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS1</span> <span class="pre">|</span> <span class="pre">TOS</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-STORE_SUBSCR">
<code class="sig-name descname">STORE_SUBSCR</code><a class="headerlink" href="#opcode-STORE_SUBSCR" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS1[TOS]</span> <span class="pre">=</span> <span class="pre">TOS2</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-DELETE_SUBSCR">
<code class="sig-name descname">DELETE_SUBSCR</code><a class="headerlink" href="#opcode-DELETE_SUBSCR" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">TOS1[TOS]</span></code>를 구현합니다.</p>
</dd></dl>

<p><strong>코루틴 옵코드</strong></p>
<dl class="opcode">
<dt id="opcode-GET_AWAITABLE">
<code class="sig-name descname">GET_AWAITABLE</code><a class="headerlink" href="#opcode-GET_AWAITABLE" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">get_awaitable(TOS)</span></code>를 구현합니다. 여기서 <code class="docutils literal notranslate"><span class="pre">o</span></code>가 코루틴 객체나 CO_ITERABLE_COROUTINE 플래그를 가진 제너레이터 객체이면 <code class="docutils literal notranslate"><span class="pre">get_awaitable(o)</span></code>는 <code class="docutils literal notranslate"><span class="pre">o</span></code>를 반환합니다, 또는 <code class="docutils literal notranslate"><span class="pre">o.__await__</span></code>를 해석(resolve)합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-GET_AITER">
<code class="sig-name descname">GET_AITER</code><a class="headerlink" href="#opcode-GET_AITER" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">TOS</span> <span class="pre">=</span> <span class="pre">TOS.__aiter__()</span></code>를 구현합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><code class="docutils literal notranslate"><span class="pre">__aiter__</span></code>로부터 어웨이터블 객체를 반환하는 것은 더는 지원되지 않습니다.</p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-GET_ANEXT">
<code class="sig-name descname">GET_ANEXT</code><a class="headerlink" href="#opcode-GET_ANEXT" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">PUSH(get_awaitable(TOS.__anext__()))</span></code>를 구현합니다. <code class="docutils literal notranslate"><span class="pre">get_awaitable</span></code>에 대한 자세한 내용은 <code class="docutils literal notranslate"><span class="pre">GET_AWAITABLE</span></code>을 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-END_ASYNC_FOR">
<code class="sig-name descname">END_ASYNC_FOR</code><a class="headerlink" href="#opcode-END_ASYNC_FOR" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 루프를 종료합니다. 다음 항목을 어웨이트할 때 발생하는 예외를 처리합니다. TOS가 <a class="reference internal" href="exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a>이면 스택에서 7개의 값을 팝하고 두 번째 세개를 사용하여 예외 상태를 복원합니다. 그렇지 않으면 스택에서 세 값을 사용하여 예외를 다시 발생시킵니다. 예외 처리기 블록이 블록 스택에서 제거됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BEFORE_ASYNC_WITH">
<code class="sig-name descname">BEFORE_ASYNC_WITH</code><a class="headerlink" href="#opcode-BEFORE_ASYNC_WITH" title="정의 주소">¶</a></dt>
<dd><p>스택 최상단의 객체에서 <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code>와 <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code>를 해석(resolve)합니다. <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code>와 <code class="docutils literal notranslate"><span class="pre">__aenter__()</span></code>의 결과를 스택으로 푸시합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-SETUP_ASYNC_WITH">
<code class="sig-name descname">SETUP_ASYNC_WITH</code><a class="headerlink" href="#opcode-SETUP_ASYNC_WITH" title="정의 주소">¶</a></dt>
<dd><p>새 프레임 객체를 만듭니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<p><strong>기타 옵코드</strong></p>
<dl class="opcode">
<dt id="opcode-PRINT_EXPR">
<code class="sig-name descname">PRINT_EXPR</code><a class="headerlink" href="#opcode-PRINT_EXPR" title="정의 주소">¶</a></dt>
<dd><p>대화식 모드를 위한 표현식 문을 구현합니다. 스택에서 TOS가 제거되고 인쇄됩니다. 비 대화식 모드에서, 표현식 문은 <a class="reference internal" href="#opcode-POP_TOP"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">POP_TOP</span></code></a>로 종료됩니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-SET_ADD">
<code class="sig-name descname">SET_ADD</code><span class="sig-paren">(</span><em class="sig-param">i</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-SET_ADD" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">set.add(TOS1[-i],</span> <span class="pre">TOS)</span></code>를 호출합니다. 집합 컴프리헨션을 구현하는 데 사용됩니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-LIST_APPEND">
<code class="sig-name descname">LIST_APPEND</code><span class="sig-paren">(</span><em class="sig-param">i</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-LIST_APPEND" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">list.append(TOS[-i],</span> <span class="pre">TOS)</span></code>를 호출합니다. 리스트 컴프리헨션을 구현하는 데 사용됩니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-MAP_ADD">
<code class="sig-name descname">MAP_ADD</code><span class="sig-paren">(</span><em class="sig-param">i</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-MAP_ADD" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">dict.__setitem__(TOS1[-i],</span> <span class="pre">TOS1,</span> <span class="pre">TOS)</span></code>를 호출합니다. 딕셔너리 컴프리헨션을 구현하는 데 사용됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>맵 값은 TOS이고 맵 키는 TOS1입니다. 전에는, 이것들이 반대였습니다.</p>
</div>
</dd></dl>

<p>모든 <a class="reference internal" href="#opcode-SET_ADD"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">SET_ADD</span></code></a>, <a class="reference internal" href="#opcode-LIST_APPEND"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">LIST_APPEND</span></code></a> 및 <a class="reference internal" href="#opcode-MAP_ADD"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">MAP_ADD</span></code></a> 명령어에 대해, 추가된 값이나 키/값 쌍이 팝되는 반면, 컨테이너 객체는 스택에 남아 있어서 루프의 추가 이터레이션에 사용할 수 있습니다.</p>
<dl class="opcode">
<dt id="opcode-RETURN_VALUE">
<code class="sig-name descname">RETURN_VALUE</code><a class="headerlink" href="#opcode-RETURN_VALUE" title="정의 주소">¶</a></dt>
<dd><p>TOS를 함수 호출자에게 반환합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-YIELD_VALUE">
<code class="sig-name descname">YIELD_VALUE</code><a class="headerlink" href="#opcode-YIELD_VALUE" title="정의 주소">¶</a></dt>
<dd><p>TOS를 팝하고 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a>에서 그것을 산출합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-YIELD_FROM">
<code class="sig-name descname">YIELD_FROM</code><a class="headerlink" href="#opcode-YIELD_FROM" title="정의 주소">¶</a></dt>
<dd><p>TOS를 팝하고 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a>에서 서브 이터레이터로 그것에 위임합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-SETUP_ANNOTATIONS">
<code class="sig-name descname">SETUP_ANNOTATIONS</code><a class="headerlink" href="#opcode-SETUP_ANNOTATIONS" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">locals()</span></code>에 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code>가 정의되어 있는지 확인합니다, 그렇지 않으면 비어있는 <code class="docutils literal notranslate"><span class="pre">dict</span></code>로 설정됩니다. 이 옵코드는 클래스나 모듈 본문에 <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">변수 어노테이션</span></a>이 정적으로 포함될 때만 생성됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-IMPORT_STAR">
<code class="sig-name descname">IMPORT_STAR</code><a class="headerlink" href="#opcode-IMPORT_STAR" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">'_'</span></code>로 시작하지 않는 모든 심볼을 모듈 TOS에서 지역 이름 공간으로 직접 로드합니다. 모든 이름을 로드한 후 모듈이 팝됩니다. 이 옵코드는 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code>를 구현합니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-POP_BLOCK">
<code class="sig-name descname">POP_BLOCK</code><a class="headerlink" href="#opcode-POP_BLOCK" title="정의 주소">¶</a></dt>
<dd><p>블록 스택에서 하나의 블록을 제거합니다. 프레임마다, 블록 스택이 있습니다, <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문을 나타내는 것과 같은 것들입니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-POP_EXCEPT">
<code class="sig-name descname">POP_EXCEPT</code><a class="headerlink" href="#opcode-POP_EXCEPT" title="정의 주소">¶</a></dt>
<dd><p>블록 스택에서 하나의 블록을 제거합니다. 팝된 블록은 예외 처리기에 진입할 때 묵시적으로 만들어진 예외 처리기 블록이어야합니다. 프레임 스택에서 추가적인 값들을 팝하는 것에 더해, 마지막 3개의 팝된 값이 예외 상태를 복원하는 데 사용됩니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-POP_FINALLY">
<code class="sig-name descname">POP_FINALLY</code><span class="sig-paren">(</span><em class="sig-param">preserve_tos</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-POP_FINALLY" title="정의 주소">¶</a></dt>
<dd><p>값 스택과 블록 스택을 정리합니다. <em>preserve_tos</em>가 <code class="docutils literal notranslate"><span class="pre">0</span></code>이 아니면 TOS가 먼저 스택에서 팝되고 다른 스택 연산을 수행한 후 스택으로 푸시됩니다:</p>
<ul class="simple">
<li><p>TOS가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>이거나 정수(<a class="reference internal" href="#opcode-BEGIN_FINALLY"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BEGIN_FINALLY</span></code></a>나 <a class="reference internal" href="#opcode-CALL_FINALLY"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CALL_FINALLY</span></code></a>로 푸시된)이면 스택에서 팝됩니다.</p></li>
<li><p>TOS가 예외 형(예외가 발생했을 때 푸시된)이면 스택에서 6개의 값이 팝됩니다, 마지막 3개의 팝된 값이 예외 상태를 복원하는 데 사용됩니다. 예외 처리기 블록이 블록 스택에서 제거됩니다.</p></li>
</ul>
<p><a class="reference internal" href="#opcode-END_FINALLY"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">END_FINALLY</span></code></a>와 비슷하지만, 바이트 코드 카운터를 변경하거나 예외를 발생시키지 않습니다. <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 블록에 있는 <a class="reference internal" href="../reference/simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a>, <a class="reference internal" href="../reference/simple_stmts.html#continue"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">continue</span></code></a> 및 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>을 구현하는 데 사용됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BEGIN_FINALLY">
<code class="sig-name descname">BEGIN_FINALLY</code><a class="headerlink" href="#opcode-BEGIN_FINALLY" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#opcode-END_FINALLY"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">END_FINALLY</span></code></a>, <a class="reference internal" href="#opcode-POP_FINALLY"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">POP_FINALLY</span></code></a>, <a class="reference internal" href="#opcode-WITH_CLEANUP_START"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">WITH_CLEANUP_START</span></code></a> 및 <a class="reference internal" href="#opcode-WITH_CLEANUP_FINISH"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">WITH_CLEANUP_FINISH</span></code></a>에서 사용하기 위해 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>을 스택으로 푸시합니다. <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 블록을 시작합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-END_FINALLY">
<code class="sig-name descname">END_FINALLY</code><a class="headerlink" href="#opcode-END_FINALLY" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절을 종료합니다. 인터프리터는 TOS의 값에 따라 예외를 다시 발생시켜야하는지 또는 실행을 계속해야하는지 기억합니다.</p>
<ul class="simple">
<li><p>TOS가 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>(<a class="reference internal" href="#opcode-BEGIN_FINALLY"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BEGIN_FINALLY</span></code></a>에 의해 푸시된)이면 다음 명령어부터 계속합니다. TOS가 팝됩니다.</p></li>
<li><p>TOS가 정수(<a class="reference internal" href="#opcode-CALL_FINALLY"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CALL_FINALLY</span></code></a>에 의해 푸시된)이면, 바이트 코드 카운터를 TOS로 설정합니다. TOS가 팝됩니다.</p></li>
<li><p>TOS가 예외 형(예외가 발생했을 때 푸시된)이면 스택에서 6개의 값이 팝되고, 처음 3개의 팝된 값이 예외를 다시 발생시키는 데 사용되고 마지막 3개의 팝된 값이 예외 상태를 복원하는 데 사용됩니다. 예외 처리기 블록이 블록 스택에서 제거됩니다.</p></li>
</ul>
</dd></dl>

<dl class="opcode">
<dt id="opcode-LOAD_BUILD_CLASS">
<code class="sig-name descname">LOAD_BUILD_CLASS</code><a class="headerlink" href="#opcode-LOAD_BUILD_CLASS" title="정의 주소">¶</a></dt>
<dd><p><code class="xref py py-func docutils literal notranslate"><span class="pre">builtins.__build_class__()</span></code>를 스택으로 푸시합니다. 나중에 클래스를 생성하기 위해 <a class="reference internal" href="#opcode-CALL_FUNCTION"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CALL_FUNCTION</span></code></a>에 의해 호출됩니다.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-SETUP_WITH">
<code class="sig-name descname">SETUP_WITH</code><span class="sig-paren">(</span><em class="sig-param">delta</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-SETUP_WITH" title="정의 주소">¶</a></dt>
<dd><p>This opcode performs several operations before a with block starts.  First,
it loads <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> from the context manager and pushes it onto
the stack for later use by <a class="reference internal" href="#opcode-WITH_CLEANUP_START"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">WITH_CLEANUP_START</span></code></a>.  Then,
<a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> is called, and a finally block pointing to <em>delta</em>
is pushed.  Finally, the result of calling the <code class="docutils literal notranslate"><span class="pre">__enter__()</span></code> method is pushed onto
the stack.  The next opcode will either ignore it (<a class="reference internal" href="#opcode-POP_TOP"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">POP_TOP</span></code></a>), or
store it in (a) variable(s) (<a class="reference internal" href="#opcode-STORE_FAST"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">STORE_FAST</span></code></a>, <a class="reference internal" href="#opcode-STORE_NAME"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">STORE_NAME</span></code></a>, or
<a class="reference internal" href="#opcode-UNPACK_SEQUENCE"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">UNPACK_SEQUENCE</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-WITH_CLEANUP_START">
<code class="sig-name descname">WITH_CLEANUP_START</code><a class="headerlink" href="#opcode-WITH_CLEANUP_START" title="정의 주소">¶</a></dt>
<dd><p>Starts cleaning up the stack when a <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement block exits.</p>
<p>At the top of the stack are either <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (pushed by
<a class="reference internal" href="#opcode-BEGIN_FINALLY"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BEGIN_FINALLY</span></code></a>) or 6 values pushed if an exception has been
raised in the with block.  Below is the context manager's
<a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> or <a class="reference internal" href="../reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a> bound method.</p>
<p>If TOS is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, calls <code class="docutils literal notranslate"><span class="pre">SECOND(None,</span> <span class="pre">None,</span> <span class="pre">None)</span></code>,
removes the function from the stack, leaving TOS, and pushes <code class="docutils literal notranslate"><span class="pre">None</span></code>
to the stack.  Otherwise calls <code class="docutils literal notranslate"><span class="pre">SEVENTH(TOP,</span> <span class="pre">SECOND,</span> <span class="pre">THIRD)</span></code>,
shifts the bottom 3 values of the stack down, replaces the empty spot
with <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and pushes TOS.  Finally pushes the result of the call.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-WITH_CLEANUP_FINISH">
<code class="sig-name descname">WITH_CLEANUP_FINISH</code><a class="headerlink" href="#opcode-WITH_CLEANUP_FINISH" title="정의 주소">¶</a></dt>
<dd><p>Finishes cleaning up the stack when a <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement block exits.</p>
<p>TOS is result of <code class="docutils literal notranslate"><span class="pre">__exit__()</span></code> or <code class="docutils literal notranslate"><span class="pre">__aexit__()</span></code> function call pushed
by <a class="reference internal" href="#opcode-WITH_CLEANUP_START"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">WITH_CLEANUP_START</span></code></a>.  SECOND is <code class="docutils literal notranslate"><span class="pre">None</span></code> or an exception type
(pushed when an exception has been raised).</p>
<p>Pops two values from the stack.  If SECOND is not None and TOS is true
unwinds the EXCEPT_HANDLER block which was created when the exception
was caught and pushes <code class="docutils literal notranslate"><span class="pre">NULL</span></code> to the stack.</p>
</dd></dl>

<p>All of the following opcodes use their arguments.</p>
<dl class="opcode">
<dt id="opcode-STORE_NAME">
<code class="sig-name descname">STORE_NAME</code><span class="sig-paren">(</span><em class="sig-param">namei</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-STORE_NAME" title="정의 주소">¶</a></dt>
<dd><p>Implements <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">TOS</span></code>. <em>namei</em> is the index of <em>name</em> in the attribute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code> of the code object. The compiler tries to use
<a class="reference internal" href="#opcode-STORE_FAST"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">STORE_FAST</span></code></a> or <a class="reference internal" href="#opcode-STORE_GLOBAL"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">STORE_GLOBAL</span></code></a> if possible.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-DELETE_NAME">
<code class="sig-name descname">DELETE_NAME</code><span class="sig-paren">(</span><em class="sig-param">namei</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-DELETE_NAME" title="정의 주소">¶</a></dt>
<dd><p>Implements <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">name</span></code>, where <em>namei</em> is the index into <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code>
attribute of the code object.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-UNPACK_SEQUENCE">
<code class="sig-name descname">UNPACK_SEQUENCE</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-UNPACK_SEQUENCE" title="정의 주소">¶</a></dt>
<dd><p>Unpacks TOS into <em>count</em> individual values, which are put onto the stack
right-to-left.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-UNPACK_EX">
<code class="sig-name descname">UNPACK_EX</code><span class="sig-paren">(</span><em class="sig-param">counts</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-UNPACK_EX" title="정의 주소">¶</a></dt>
<dd><p>Implements assignment with a starred target: Unpacks an iterable in TOS into
individual values, where the total number of values can be smaller than the
number of items in the iterable: one of the new values will be a list of all
leftover items.</p>
<p>The low byte of <em>counts</em> is the number of values before the list value, the
high byte of <em>counts</em> the number of values after it.  The resulting values
are put onto the stack right-to-left.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-STORE_ATTR">
<code class="sig-name descname">STORE_ATTR</code><span class="sig-paren">(</span><em class="sig-param">namei</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-STORE_ATTR" title="정의 주소">¶</a></dt>
<dd><p>Implements <code class="docutils literal notranslate"><span class="pre">TOS.name</span> <span class="pre">=</span> <span class="pre">TOS1</span></code>, where <em>namei</em> is the index of name in
<code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code>.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-DELETE_ATTR">
<code class="sig-name descname">DELETE_ATTR</code><span class="sig-paren">(</span><em class="sig-param">namei</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-DELETE_ATTR" title="정의 주소">¶</a></dt>
<dd><p>Implements <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">TOS.name</span></code>, using <em>namei</em> as index into <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code>.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-STORE_GLOBAL">
<code class="sig-name descname">STORE_GLOBAL</code><span class="sig-paren">(</span><em class="sig-param">namei</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-STORE_GLOBAL" title="정의 주소">¶</a></dt>
<dd><p>Works as <a class="reference internal" href="#opcode-STORE_NAME"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">STORE_NAME</span></code></a>, but stores the name as a global.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-DELETE_GLOBAL">
<code class="sig-name descname">DELETE_GLOBAL</code><span class="sig-paren">(</span><em class="sig-param">namei</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-DELETE_GLOBAL" title="정의 주소">¶</a></dt>
<dd><p>Works as <a class="reference internal" href="#opcode-DELETE_NAME"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">DELETE_NAME</span></code></a>, but deletes a global name.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-LOAD_CONST">
<code class="sig-name descname">LOAD_CONST</code><span class="sig-paren">(</span><em class="sig-param">consti</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-LOAD_CONST" title="정의 주소">¶</a></dt>
<dd><p>Pushes <code class="docutils literal notranslate"><span class="pre">co_consts[consti]</span></code> onto the stack.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-LOAD_NAME">
<code class="sig-name descname">LOAD_NAME</code><span class="sig-paren">(</span><em class="sig-param">namei</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-LOAD_NAME" title="정의 주소">¶</a></dt>
<dd><p>Pushes the value associated with <code class="docutils literal notranslate"><span class="pre">co_names[namei]</span></code> onto the stack.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BUILD_TUPLE">
<code class="sig-name descname">BUILD_TUPLE</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-BUILD_TUPLE" title="정의 주소">¶</a></dt>
<dd><p>Creates a tuple consuming <em>count</em> items from the stack, and pushes the
resulting tuple onto the stack.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BUILD_LIST">
<code class="sig-name descname">BUILD_LIST</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-BUILD_LIST" title="정의 주소">¶</a></dt>
<dd><p>Works as <a class="reference internal" href="#opcode-BUILD_TUPLE"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BUILD_TUPLE</span></code></a>, but creates a list.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BUILD_SET">
<code class="sig-name descname">BUILD_SET</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-BUILD_SET" title="정의 주소">¶</a></dt>
<dd><p>Works as <a class="reference internal" href="#opcode-BUILD_TUPLE"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BUILD_TUPLE</span></code></a>, but creates a set.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BUILD_MAP">
<code class="sig-name descname">BUILD_MAP</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-BUILD_MAP" title="정의 주소">¶</a></dt>
<dd><p>Pushes a new dictionary object onto the stack.  Pops <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">count</span></code> items
so that the dictionary holds <em>count</em> entries:
<code class="docutils literal notranslate"><span class="pre">{...,</span> <span class="pre">TOS3:</span> <span class="pre">TOS2,</span> <span class="pre">TOS1:</span> <span class="pre">TOS}</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>The dictionary is created from stack items instead of creating an
empty dictionary pre-sized to hold <em>count</em> items.</p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BUILD_CONST_KEY_MAP">
<code class="sig-name descname">BUILD_CONST_KEY_MAP</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-BUILD_CONST_KEY_MAP" title="정의 주소">¶</a></dt>
<dd><p>The version of <a class="reference internal" href="#opcode-BUILD_MAP"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BUILD_MAP</span></code></a> specialized for constant keys.  <em>count</em>
values are consumed from the stack.  The top element on the stack contains
a tuple of keys.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BUILD_STRING">
<code class="sig-name descname">BUILD_STRING</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-BUILD_STRING" title="정의 주소">¶</a></dt>
<dd><p>Concatenates <em>count</em> strings from the stack and pushes the resulting string
onto the stack.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BUILD_TUPLE_UNPACK">
<code class="sig-name descname">BUILD_TUPLE_UNPACK</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-BUILD_TUPLE_UNPACK" title="정의 주소">¶</a></dt>
<dd><p>Pops <em>count</em> iterables from the stack, joins them in a single tuple,
and pushes the result.  Implements iterable unpacking in tuple
displays <code class="docutils literal notranslate"><span class="pre">(*x,</span> <span class="pre">*y,</span> <span class="pre">*z)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BUILD_TUPLE_UNPACK_WITH_CALL">
<code class="sig-name descname">BUILD_TUPLE_UNPACK_WITH_CALL</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-BUILD_TUPLE_UNPACK_WITH_CALL" title="정의 주소">¶</a></dt>
<dd><p>This is similar to <a class="reference internal" href="#opcode-BUILD_TUPLE_UNPACK"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BUILD_TUPLE_UNPACK</span></code></a>,
but is used for <code class="docutils literal notranslate"><span class="pre">f(*x,</span> <span class="pre">*y,</span> <span class="pre">*z)</span></code> call syntax. The stack item at position
<code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">+</span> <span class="pre">1</span></code> should be the corresponding callable <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BUILD_LIST_UNPACK">
<code class="sig-name descname">BUILD_LIST_UNPACK</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-BUILD_LIST_UNPACK" title="정의 주소">¶</a></dt>
<dd><p>This is similar to <a class="reference internal" href="#opcode-BUILD_TUPLE_UNPACK"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BUILD_TUPLE_UNPACK</span></code></a>, but pushes a list
instead of tuple.  Implements iterable unpacking in list
displays <code class="docutils literal notranslate"><span class="pre">[*x,</span> <span class="pre">*y,</span> <span class="pre">*z]</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BUILD_SET_UNPACK">
<code class="sig-name descname">BUILD_SET_UNPACK</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-BUILD_SET_UNPACK" title="정의 주소">¶</a></dt>
<dd><p>This is similar to <a class="reference internal" href="#opcode-BUILD_TUPLE_UNPACK"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BUILD_TUPLE_UNPACK</span></code></a>, but pushes a set
instead of tuple.  Implements iterable unpacking in set
displays <code class="docutils literal notranslate"><span class="pre">{*x,</span> <span class="pre">*y,</span> <span class="pre">*z}</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BUILD_MAP_UNPACK">
<code class="sig-name descname">BUILD_MAP_UNPACK</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-BUILD_MAP_UNPACK" title="정의 주소">¶</a></dt>
<dd><p>Pops <em>count</em> mappings from the stack, merges them into a single dictionary,
and pushes the result.  Implements dictionary unpacking in dictionary
displays <code class="docutils literal notranslate"><span class="pre">{**x,</span> <span class="pre">**y,</span> <span class="pre">**z}</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BUILD_MAP_UNPACK_WITH_CALL">
<code class="sig-name descname">BUILD_MAP_UNPACK_WITH_CALL</code><span class="sig-paren">(</span><em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-BUILD_MAP_UNPACK_WITH_CALL" title="정의 주소">¶</a></dt>
<dd><p>This is similar to <a class="reference internal" href="#opcode-BUILD_MAP_UNPACK"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BUILD_MAP_UNPACK</span></code></a>,
but is used for <code class="docutils literal notranslate"><span class="pre">f(**x,</span> <span class="pre">**y,</span> <span class="pre">**z)</span></code> call syntax.  The stack item at
position <code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">+</span> <span class="pre">2</span></code> should be the corresponding callable <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>The position of the callable is determined by adding 2 to the opcode
argument instead of encoding it in the second byte of the argument.</p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-LOAD_ATTR">
<code class="sig-name descname">LOAD_ATTR</code><span class="sig-paren">(</span><em class="sig-param">namei</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-LOAD_ATTR" title="정의 주소">¶</a></dt>
<dd><p>Replaces TOS with <code class="docutils literal notranslate"><span class="pre">getattr(TOS,</span> <span class="pre">co_names[namei])</span></code>.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-COMPARE_OP">
<code class="sig-name descname">COMPARE_OP</code><span class="sig-paren">(</span><em class="sig-param">opname</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-COMPARE_OP" title="정의 주소">¶</a></dt>
<dd><p>Performs a Boolean operation.  The operation name can be found in
<code class="docutils literal notranslate"><span class="pre">cmp_op[opname]</span></code>.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-IMPORT_NAME">
<code class="sig-name descname">IMPORT_NAME</code><span class="sig-paren">(</span><em class="sig-param">namei</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-IMPORT_NAME" title="정의 주소">¶</a></dt>
<dd><p>Imports the module <code class="docutils literal notranslate"><span class="pre">co_names[namei]</span></code>.  TOS and TOS1 are popped and provide
the <em>fromlist</em> and <em>level</em> arguments of <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>.  The module
object is pushed onto the stack.  The current namespace is not affected: for
a proper import statement, a subsequent <a class="reference internal" href="#opcode-STORE_FAST"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">STORE_FAST</span></code></a> instruction
modifies the namespace.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-IMPORT_FROM">
<code class="sig-name descname">IMPORT_FROM</code><span class="sig-paren">(</span><em class="sig-param">namei</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-IMPORT_FROM" title="정의 주소">¶</a></dt>
<dd><p>Loads the attribute <code class="docutils literal notranslate"><span class="pre">co_names[namei]</span></code> from the module found in TOS. The
resulting object is pushed onto the stack, to be subsequently stored by a
<a class="reference internal" href="#opcode-STORE_FAST"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">STORE_FAST</span></code></a> instruction.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-JUMP_FORWARD">
<code class="sig-name descname">JUMP_FORWARD</code><span class="sig-paren">(</span><em class="sig-param">delta</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-JUMP_FORWARD" title="정의 주소">¶</a></dt>
<dd><p>Increments bytecode counter by <em>delta</em>.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-POP_JUMP_IF_TRUE">
<code class="sig-name descname">POP_JUMP_IF_TRUE</code><span class="sig-paren">(</span><em class="sig-param">target</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-POP_JUMP_IF_TRUE" title="정의 주소">¶</a></dt>
<dd><p>If TOS is true, sets the bytecode counter to <em>target</em>.  TOS is popped.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-POP_JUMP_IF_FALSE">
<code class="sig-name descname">POP_JUMP_IF_FALSE</code><span class="sig-paren">(</span><em class="sig-param">target</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-POP_JUMP_IF_FALSE" title="정의 주소">¶</a></dt>
<dd><p>If TOS is false, sets the bytecode counter to <em>target</em>.  TOS is popped.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-JUMP_IF_TRUE_OR_POP">
<code class="sig-name descname">JUMP_IF_TRUE_OR_POP</code><span class="sig-paren">(</span><em class="sig-param">target</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-JUMP_IF_TRUE_OR_POP" title="정의 주소">¶</a></dt>
<dd><p>If TOS is true, sets the bytecode counter to <em>target</em> and leaves TOS on the
stack.  Otherwise (TOS is false), TOS is popped.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-JUMP_IF_FALSE_OR_POP">
<code class="sig-name descname">JUMP_IF_FALSE_OR_POP</code><span class="sig-paren">(</span><em class="sig-param">target</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-JUMP_IF_FALSE_OR_POP" title="정의 주소">¶</a></dt>
<dd><p>If TOS is false, sets the bytecode counter to <em>target</em> and leaves TOS on the
stack.  Otherwise (TOS is true), TOS is popped.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-JUMP_ABSOLUTE">
<code class="sig-name descname">JUMP_ABSOLUTE</code><span class="sig-paren">(</span><em class="sig-param">target</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-JUMP_ABSOLUTE" title="정의 주소">¶</a></dt>
<dd><p>Set bytecode counter to <em>target</em>.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-FOR_ITER">
<code class="sig-name descname">FOR_ITER</code><span class="sig-paren">(</span><em class="sig-param">delta</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-FOR_ITER" title="정의 주소">¶</a></dt>
<dd><p>TOS is an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>.  Call its <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> method.  If
this yields a new value, push it on the stack (leaving the iterator below
it).  If the iterator indicates it is exhausted TOS is popped, and the byte
code counter is incremented by <em>delta</em>.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-LOAD_GLOBAL">
<code class="sig-name descname">LOAD_GLOBAL</code><span class="sig-paren">(</span><em class="sig-param">namei</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-LOAD_GLOBAL" title="정의 주소">¶</a></dt>
<dd><p>Loads the global named <code class="docutils literal notranslate"><span class="pre">co_names[namei]</span></code> onto the stack.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-SETUP_FINALLY">
<code class="sig-name descname">SETUP_FINALLY</code><span class="sig-paren">(</span><em class="sig-param">delta</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-SETUP_FINALLY" title="정의 주소">¶</a></dt>
<dd><p>Pushes a try block from a try-finally or try-except clause onto the block
stack.  <em>delta</em> points to the finally block or the first except block.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-CALL_FINALLY">
<code class="sig-name descname">CALL_FINALLY</code><span class="sig-paren">(</span><em class="sig-param">delta</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-CALL_FINALLY" title="정의 주소">¶</a></dt>
<dd><p>Pushes the address of the next instruction onto the stack and increments
bytecode counter by <em>delta</em>.  Used for calling the finally block as a
&quot;subroutine&quot;.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-LOAD_FAST">
<code class="sig-name descname">LOAD_FAST</code><span class="sig-paren">(</span><em class="sig-param">var_num</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-LOAD_FAST" title="정의 주소">¶</a></dt>
<dd><p>Pushes a reference to the local <code class="docutils literal notranslate"><span class="pre">co_varnames[var_num]</span></code> onto the stack.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-STORE_FAST">
<code class="sig-name descname">STORE_FAST</code><span class="sig-paren">(</span><em class="sig-param">var_num</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-STORE_FAST" title="정의 주소">¶</a></dt>
<dd><p>Stores TOS into the local <code class="docutils literal notranslate"><span class="pre">co_varnames[var_num]</span></code>.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-DELETE_FAST">
<code class="sig-name descname">DELETE_FAST</code><span class="sig-paren">(</span><em class="sig-param">var_num</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-DELETE_FAST" title="정의 주소">¶</a></dt>
<dd><p>Deletes local <code class="docutils literal notranslate"><span class="pre">co_varnames[var_num]</span></code>.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-LOAD_CLOSURE">
<code class="sig-name descname">LOAD_CLOSURE</code><span class="sig-paren">(</span><em class="sig-param">i</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-LOAD_CLOSURE" title="정의 주소">¶</a></dt>
<dd><p>Pushes a reference to the cell contained in slot <em>i</em> of the cell and free
variable storage.  The name of the variable is <code class="docutils literal notranslate"><span class="pre">co_cellvars[i]</span></code> if <em>i</em> is
less than the length of <em>co_cellvars</em>.  Otherwise it is <code class="docutils literal notranslate"><span class="pre">co_freevars[i</span> <span class="pre">-</span>
<span class="pre">len(co_cellvars)]</span></code>.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-LOAD_DEREF">
<code class="sig-name descname">LOAD_DEREF</code><span class="sig-paren">(</span><em class="sig-param">i</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-LOAD_DEREF" title="정의 주소">¶</a></dt>
<dd><p>Loads the cell contained in slot <em>i</em> of the cell and free variable storage.
Pushes a reference to the object the cell contains on the stack.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-LOAD_CLASSDEREF">
<code class="sig-name descname">LOAD_CLASSDEREF</code><span class="sig-paren">(</span><em class="sig-param">i</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-LOAD_CLASSDEREF" title="정의 주소">¶</a></dt>
<dd><p>Much like <a class="reference internal" href="#opcode-LOAD_DEREF"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">LOAD_DEREF</span></code></a> but first checks the locals dictionary before
consulting the cell.  This is used for loading free variables in class
bodies.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-STORE_DEREF">
<code class="sig-name descname">STORE_DEREF</code><span class="sig-paren">(</span><em class="sig-param">i</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-STORE_DEREF" title="정의 주소">¶</a></dt>
<dd><p>Stores TOS into the cell contained in slot <em>i</em> of the cell and free variable
storage.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-DELETE_DEREF">
<code class="sig-name descname">DELETE_DEREF</code><span class="sig-paren">(</span><em class="sig-param">i</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-DELETE_DEREF" title="정의 주소">¶</a></dt>
<dd><p>Empties the cell contained in slot <em>i</em> of the cell and free variable storage.
Used by the <a class="reference internal" href="../reference/simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> statement.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-RAISE_VARARGS">
<code class="sig-name descname">RAISE_VARARGS</code><span class="sig-paren">(</span><em class="sig-param">argc</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-RAISE_VARARGS" title="정의 주소">¶</a></dt>
<dd><p>Raises an exception using one of the 3 forms of the <code class="docutils literal notranslate"><span class="pre">raise</span></code> statement,
depending on the value of <em>argc</em>:</p>
<ul class="simple">
<li><p>0: <code class="docutils literal notranslate"><span class="pre">raise</span></code> (re-raise previous exception)</p></li>
<li><p>1: <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">TOS</span></code> (raise exception instance or type at <code class="docutils literal notranslate"><span class="pre">TOS</span></code>)</p></li>
<li><p>2: <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">TOS1</span> <span class="pre">from</span> <span class="pre">TOS</span></code> (raise exception instance or type at <code class="docutils literal notranslate"><span class="pre">TOS1</span></code>
with <code class="docutils literal notranslate"><span class="pre">__cause__</span></code> set to <code class="docutils literal notranslate"><span class="pre">TOS</span></code>)</p></li>
</ul>
</dd></dl>

<dl class="opcode">
<dt id="opcode-CALL_FUNCTION">
<code class="sig-name descname">CALL_FUNCTION</code><span class="sig-paren">(</span><em class="sig-param">argc</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-CALL_FUNCTION" title="정의 주소">¶</a></dt>
<dd><p>Calls a callable object with positional arguments.
<em>argc</em> indicates the number of positional arguments.
The top of the stack contains positional arguments, with the right-most
argument on top.  Below the arguments is a callable object to call.
<code class="docutils literal notranslate"><span class="pre">CALL_FUNCTION</span></code> pops all arguments and the callable object off the stack,
calls the callable object with those arguments, and pushes the return value
returned by the callable object.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>This opcode is used only for calls with positional arguments.</p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-CALL_FUNCTION_KW">
<code class="sig-name descname">CALL_FUNCTION_KW</code><span class="sig-paren">(</span><em class="sig-param">argc</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-CALL_FUNCTION_KW" title="정의 주소">¶</a></dt>
<dd><p>Calls a callable object with positional (if any) and keyword arguments.
<em>argc</em> indicates the total number of positional and keyword arguments.
The top element on the stack contains a tuple of keyword argument names.
Below that are keyword arguments in the order corresponding to the tuple.
Below that are positional arguments, with the right-most parameter on
top.  Below the arguments is a callable object to call.
<code class="docutils literal notranslate"><span class="pre">CALL_FUNCTION_KW</span></code> pops all arguments and the callable object off the stack,
calls the callable object with those arguments, and pushes the return value
returned by the callable object.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>Keyword arguments are packed in a tuple instead of a dictionary,
<em>argc</em> indicates the total number of arguments.</p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-CALL_FUNCTION_EX">
<code class="sig-name descname">CALL_FUNCTION_EX</code><span class="sig-paren">(</span><em class="sig-param">flags</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-CALL_FUNCTION_EX" title="정의 주소">¶</a></dt>
<dd><p>Calls a callable object with variable set of positional and keyword
arguments.  If the lowest bit of <em>flags</em> is set, the top of the stack
contains a mapping object containing additional keyword arguments.
Below that is an iterable object containing positional arguments and
a callable object to call.  <a class="reference internal" href="#opcode-BUILD_MAP_UNPACK_WITH_CALL"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BUILD_MAP_UNPACK_WITH_CALL</span></code></a> and
<a class="reference internal" href="#opcode-BUILD_TUPLE_UNPACK_WITH_CALL"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">BUILD_TUPLE_UNPACK_WITH_CALL</span></code></a> can be used for merging multiple
mapping objects and iterables containing arguments.
Before the callable is called, the mapping object and iterable object
are each &quot;unpacked&quot; and their contents passed in as keyword and
positional arguments respectively.
<code class="docutils literal notranslate"><span class="pre">CALL_FUNCTION_EX</span></code> pops all arguments and the callable object off the stack,
calls the callable object with those arguments, and pushes the return value
returned by the callable object.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-LOAD_METHOD">
<code class="sig-name descname">LOAD_METHOD</code><span class="sig-paren">(</span><em class="sig-param">namei</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-LOAD_METHOD" title="정의 주소">¶</a></dt>
<dd><p>Loads a method named <code class="docutils literal notranslate"><span class="pre">co_names[namei]</span></code> from the TOS object. TOS is popped.
This bytecode distinguishes two cases: if TOS has a method with the correct
name, the bytecode pushes the unbound method and TOS. TOS will be used as
the first argument (<code class="docutils literal notranslate"><span class="pre">self</span></code>) by <a class="reference internal" href="#opcode-CALL_METHOD"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">CALL_METHOD</span></code></a> when calling the
unbound method. Otherwise, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and the object return by the attribute
lookup are pushed.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-CALL_METHOD">
<code class="sig-name descname">CALL_METHOD</code><span class="sig-paren">(</span><em class="sig-param">argc</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-CALL_METHOD" title="정의 주소">¶</a></dt>
<dd><p>Calls a method.  <em>argc</em> is the number of positional arguments.
Keyword arguments are not supported.  This opcode is designed to be used
with <a class="reference internal" href="#opcode-LOAD_METHOD"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">LOAD_METHOD</span></code></a>.  Positional arguments are on top of the stack.
Below them, the two items described in <a class="reference internal" href="#opcode-LOAD_METHOD"><code class="xref std std-opcode docutils literal notranslate"><span class="pre">LOAD_METHOD</span></code></a> are on the
stack (either <code class="docutils literal notranslate"><span class="pre">self</span></code> and an unbound method object or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and an
arbitrary callable). All of them are popped and the return value is pushed.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-MAKE_FUNCTION">
<code class="sig-name descname">MAKE_FUNCTION</code><span class="sig-paren">(</span><em class="sig-param">argc</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-MAKE_FUNCTION" title="정의 주소">¶</a></dt>
<dd><p>Pushes a new function object on the stack.  From bottom to top, the consumed
stack must consist of values if the argument carries a specified flag value</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0x01</span></code> a tuple of default values for positional-only and
positional-or-keyword parameters in positional order</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x02</span></code> a dictionary of keyword-only parameters' default values</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x04</span></code> an annotation dictionary</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x08</span></code> a tuple containing cells for free variables, making a closure</p></li>
<li><p>the code associated with the function (at TOS1)</p></li>
<li><p>the <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">qualified name</span></a> of the function (at TOS)</p></li>
</ul>
</dd></dl>

<dl class="opcode">
<dt id="opcode-BUILD_SLICE">
<code class="sig-name descname">BUILD_SLICE</code><span class="sig-paren">(</span><em class="sig-param">argc</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-BUILD_SLICE" title="정의 주소">¶</a></dt>
<dd><p id="index-0">Pushes a slice object on the stack.  <em>argc</em> must be 2 or 3.  If it is 2,
<code class="docutils literal notranslate"><span class="pre">slice(TOS1,</span> <span class="pre">TOS)</span></code> is pushed; if it is 3, <code class="docutils literal notranslate"><span class="pre">slice(TOS2,</span> <span class="pre">TOS1,</span> <span class="pre">TOS)</span></code> is
pushed. See the <a class="reference internal" href="functions.html#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a> built-in function for more information.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-EXTENDED_ARG">
<code class="sig-name descname">EXTENDED_ARG</code><span class="sig-paren">(</span><em class="sig-param">ext</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-EXTENDED_ARG" title="정의 주소">¶</a></dt>
<dd><p>Prefixes any opcode which has an argument too big to fit into the default one
byte. <em>ext</em> holds an additional byte which act as higher bits in the argument.
For each opcode, at most three prefixal <code class="docutils literal notranslate"><span class="pre">EXTENDED_ARG</span></code> are allowed, forming
an argument from two-byte to four-byte.</p>
</dd></dl>

<dl class="opcode">
<dt id="opcode-FORMAT_VALUE">
<code class="sig-name descname">FORMAT_VALUE</code><span class="sig-paren">(</span><em class="sig-param">flags</em><span class="sig-paren">)</span><a class="headerlink" href="#opcode-FORMAT_VALUE" title="정의 주소">¶</a></dt>
<dd><p>Used for implementing formatted literal strings (f-strings).  Pops
an optional <em>fmt_spec</em> from the stack, then a required <em>value</em>.
<em>flags</em> is interpreted as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(flags</span> <span class="pre">&amp;</span> <span class="pre">0x03)</span> <span class="pre">==</span> <span class="pre">0x00</span></code>: <em>value</em> is formatted as-is.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(flags</span> <span class="pre">&amp;</span> <span class="pre">0x03)</span> <span class="pre">==</span> <span class="pre">0x01</span></code>: call <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> on <em>value</em> before
formatting it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(flags</span> <span class="pre">&amp;</span> <span class="pre">0x03)</span> <span class="pre">==</span> <span class="pre">0x02</span></code>: call <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> on <em>value</em> before
formatting it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(flags</span> <span class="pre">&amp;</span> <span class="pre">0x03)</span> <span class="pre">==</span> <span class="pre">0x03</span></code>: call <a class="reference internal" href="functions.html#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a> on <em>value</em> before
formatting it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(flags</span> <span class="pre">&amp;</span> <span class="pre">0x04)</span> <span class="pre">==</span> <span class="pre">0x04</span></code>: pop <em>fmt_spec</em> from the stack and use
it, else use an empty <em>fmt_spec</em>.</p></li>
</ul>
<p>Formatting is performed using <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Format()</span></code>.  The
result is pushed on the stack.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="opcode">
<dt id="opcode-HAVE_ARGUMENT">
<code class="sig-name descname">HAVE_ARGUMENT</code><a class="headerlink" href="#opcode-HAVE_ARGUMENT" title="정의 주소">¶</a></dt>
<dd><p>This is not really an opcode.  It identifies the dividing line between
opcodes which don't use their argument and those that do
(<code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">HAVE_ARGUMENT</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">HAVE_ARGUMENT</span></code>, respectively).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>Now every instruction has an argument, but opcodes <code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">HAVE_ARGUMENT</span></code>
ignore it. Before, only opcodes <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">HAVE_ARGUMENT</span></code> had an argument.</p>
</div>
</dd></dl>

</div>
<div class="section" id="opcode-collections">
<span id="id1"></span><h2>옵코드 모음<a class="headerlink" href="#opcode-collections" title="제목 주소">¶</a></h2>
<p>These collections are provided for automatic introspection of bytecode
instructions:</p>
<dl class="data">
<dt id="dis.opname">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">opname</code><a class="headerlink" href="#dis.opname" title="정의 주소">¶</a></dt>
<dd><p>Sequence of operation names, indexable using the bytecode.</p>
</dd></dl>

<dl class="data">
<dt id="dis.opmap">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">opmap</code><a class="headerlink" href="#dis.opmap" title="정의 주소">¶</a></dt>
<dd><p>Dictionary mapping operation names to bytecodes.</p>
</dd></dl>

<dl class="data">
<dt id="dis.cmp_op">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">cmp_op</code><a class="headerlink" href="#dis.cmp_op" title="정의 주소">¶</a></dt>
<dd><p>Sequence of all compare operation names.</p>
</dd></dl>

<dl class="data">
<dt id="dis.hasconst">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">hasconst</code><a class="headerlink" href="#dis.hasconst" title="정의 주소">¶</a></dt>
<dd><p>Sequence of bytecodes that access a constant.</p>
</dd></dl>

<dl class="data">
<dt id="dis.hasfree">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">hasfree</code><a class="headerlink" href="#dis.hasfree" title="정의 주소">¶</a></dt>
<dd><p>Sequence of bytecodes that access a free variable (note that 'free' in this
context refers to names in the current scope that are referenced by inner
scopes or names in outer scopes that are referenced from this scope.  It does
<em>not</em> include references to global or builtin scopes).</p>
</dd></dl>

<dl class="data">
<dt id="dis.hasname">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">hasname</code><a class="headerlink" href="#dis.hasname" title="정의 주소">¶</a></dt>
<dd><p>Sequence of bytecodes that access an attribute by name.</p>
</dd></dl>

<dl class="data">
<dt id="dis.hasjrel">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">hasjrel</code><a class="headerlink" href="#dis.hasjrel" title="정의 주소">¶</a></dt>
<dd><p>Sequence of bytecodes that have a relative jump target.</p>
</dd></dl>

<dl class="data">
<dt id="dis.hasjabs">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">hasjabs</code><a class="headerlink" href="#dis.hasjabs" title="정의 주소">¶</a></dt>
<dd><p>Sequence of bytecodes that have an absolute jump target.</p>
</dd></dl>

<dl class="data">
<dt id="dis.haslocal">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">haslocal</code><a class="headerlink" href="#dis.haslocal" title="정의 주소">¶</a></dt>
<dd><p>Sequence of bytecodes that access a local variable.</p>
</dd></dl>

<dl class="data">
<dt id="dis.hascompare">
<code class="sig-prename descclassname">dis.</code><code class="sig-name descname">hascompare</code><a class="headerlink" href="#dis.hascompare" title="정의 주소">¶</a></dt>
<dd><p>Sequence of bytecodes of Boolean operations.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code> --- 파이썬 바이트 코드 역 어셈블러</a><ul>
<li><a class="reference internal" href="#bytecode-analysis">바이트 코드 분석</a></li>
<li><a class="reference internal" href="#analysis-functions">분석 함수</a></li>
<li><a class="reference internal" href="#python-bytecode-instructions">파이썬 바이트 코드 명령어</a></li>
<li><a class="reference internal" href="#opcode-collections">옵코드 모음</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="compileall.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">compileall</span></code> --- 파이썬 라이브러리 바이트 컴파일하기</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="pickletools.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickletools</span></code> --- 피클 개발자를 위한 도구</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="pickletools.html" title="pickletools --- 피클 개발자를 위한 도구"
             >다음</a> |</li>
        <li class="right" >
          <a href="compileall.html" title="compileall --- 파이썬 라이브러리 바이트 컴파일하기"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="language.html" >파이썬 언어 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>