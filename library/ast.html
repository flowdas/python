
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>ast --- 추상 구문 트리 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="symtable --- 컴파일러 심볼 테이블 액세스" href="symtable.html" />
    <link rel="prev" title="parser --- Access Python parse trees" href="parser.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/ast.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="symtable.html" title="symtable --- 컴파일러 심볼 테이블 액세스"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="parser.html" title="parser --- Access Python parse trees"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="language.html" accesskey="U">파이썬 언어 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-ast">
<span id="ast-abstract-syntax-trees"></span><h1><a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> --- 추상 구문 트리<a class="headerlink" href="#module-ast" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/ast.py">Lib/ast.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 모듈은 파이썬 응용 프로그램이 파이썬 추상 구문 문법의 트리를 처리하는 데 도움을 줍니다. 추상 구문 자체는 각 파이썬 릴리스마다 바뀔 수 있습니다; 이 모듈은 프로그래밍 방식으로 현재 문법의 모양을 찾는 데 도움이 됩니다.</p>
<p><code class="xref py py-data docutils literal notranslate"><span class="pre">ast.PyCF_ONLY_AST</span></code>를 플래그로 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 내장 함수에 전달하거나, 이 모듈에서 제공된 <a class="reference internal" href="#ast.parse" title="ast.parse"><code class="xref py py-func docutils literal notranslate"><span class="pre">parse()</span></code></a> 도우미를 사용하여 추상 구문 트리를 생성할 수 있습니다. 결과는 클래스가 모두 <a class="reference internal" href="#ast.AST" title="ast.AST"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.AST</span></code></a>에서 상속되는 객체들의 트리가 됩니다. 내장 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 함수를 사용하여 추상 구문 트리를 파이썬 코드 객체로 컴파일할 수 있습니다.</p>
<div class="section" id="node-classes">
<h2>노드 클래스<a class="headerlink" href="#node-classes" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="ast.AST">
<em class="property">class </em><code class="sig-prename descclassname">ast.</code><code class="sig-name descname">AST</code><a class="headerlink" href="#ast.AST" title="정의 주소">¶</a></dt>
<dd><p>이것은 모든 AST 노드 클래스의 베이스입니다. 실제 노드 클래스는 <code class="file docutils literal notranslate"><span class="pre">Parser/Python.asdl</span></code> 파일에서 파생되며, 이 파일의 내용은 <a class="reference internal" href="#abstract-grammar"><span class="std std-ref">아래</span></a>에서 볼 수 있습니다. <code class="xref py py-mod docutils literal notranslate"><span class="pre">_ast</span></code> C 모듈에 정의되어 있으며 <a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a>로 다시 내보내집니다.</p>
<p>추상 문법의 각 좌변 심볼마다 하나의 클래스가 정의되어 있습니다 (예를 들어, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.stmt</span></code>나 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.expr</span></code>). 또한, 우변의 생성자마다 하나의 클래스가 정의되어 있습니다; 이 클래스는 좌변 트리의 클래스에서 상속됩니다. 예를 들어, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.BinOp</span></code>는 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.expr</span></code>에서 상속됩니다. 대안을 갖는 생성 규칙(일명 &quot;합&quot;)의 경우, 좌변 클래스는 추상입니다: 특정 생성자 노드의 인스턴스만 만들어집니다.</p>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><dl class="attribute">
<dt id="ast.AST._fields">
<code class="sig-name descname">_fields</code><a class="headerlink" href="#ast.AST._fields" title="정의 주소">¶</a></dt>
<dd><p>각 구상 클래스에는 모든 자식 노드의 이름을 제공하는 어트리뷰트 <a class="reference internal" href="#ast.AST._fields" title="ast.AST._fields"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields</span></code></a>가 있습니다.</p>
<p>구상 클래스의 각 인스턴스에는 각 자식 노드마다 문법에 정의된 형의 어트리뷰트가 하나씩 있습니다. 예를 들어, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.BinOp</span></code> 인스턴스는 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.expr</span></code> 형의 어트리뷰트 <code class="xref py py-attr docutils literal notranslate"><span class="pre">left</span></code>를 갖습니다.</p>
<p>문법에서 이러한 어트리뷰트가 선택적으로 표시되면 (물음표를 사용해서), 값은 <code class="docutils literal notranslate"><span class="pre">None</span></code>일 수 있습니다. 어트리뷰트가 0개 이상의 값을 가질 수 있으면 (애스터리스크로 표시됩니다), 값은 파이썬 리스트로 표현됩니다. <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>로 AST를 컴파일할 때 가능한 모든 어트리뷰트가 존재하고 유효한 값을 가져야 합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="ast.AST.lineno">
<code class="sig-name descname">lineno</code><a class="headerlink" href="#ast.AST.lineno" title="정의 주소">¶</a></dt>
<dt id="ast.AST.col_offset">
<code class="sig-name descname">col_offset</code><a class="headerlink" href="#ast.AST.col_offset" title="정의 주소">¶</a></dt>
<dt id="ast.AST.end_lineno">
<code class="sig-name descname">end_lineno</code><a class="headerlink" href="#ast.AST.end_lineno" title="정의 주소">¶</a></dt>
<dt id="ast.AST.end_col_offset">
<code class="sig-name descname">end_col_offset</code><a class="headerlink" href="#ast.AST.end_col_offset" title="정의 주소">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.expr</span></code>과 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.stmt</span></code> 서브 클래스의 인스턴스에는 <a class="reference internal" href="#ast.AST.lineno" title="ast.AST.lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code></a>, <a class="reference internal" href="#ast.AST.col_offset" title="ast.AST.col_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code></a>, <a class="reference internal" href="#ast.AST.lineno" title="ast.AST.lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code></a> 및 <a class="reference internal" href="#ast.AST.col_offset" title="ast.AST.col_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code></a> 어트리뷰트가 있습니다. <a class="reference internal" href="#ast.AST.lineno" title="ast.AST.lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code></a>와 <a class="reference internal" href="#ast.AST.end_lineno" title="ast.AST.end_lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">end_lineno</span></code></a>는 소스 텍스트 스팬의 첫 번째와 마지막 줄 번호(1-인덱싱이라서 첫 번째 줄은 줄 1입니다)이고 <a class="reference internal" href="#ast.AST.col_offset" title="ast.AST.col_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code></a>과 <a class="reference internal" href="#ast.AST.end_col_offset" title="ast.AST.end_col_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">end_col_offset</span></code></a>은 노드를 생성한 첫 번째와 마지막 토큰의 해당 UTF-8 바이트 오프셋입니다. 구문 분석기가 UTF-8을 내부적으로 사용하기 때문에 UTF-8 오프셋이 기록됩니다.</p>
<p>종료 위치는 컴파일러에 필요하지 않아서 선택 사항입니다. 종료 오프셋은 마지막 심볼 <em>뒤</em>입니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">source_line[node.col_offset</span> <span class="pre">:</span> <span class="pre">node.end_col_offset]</span></code>를 사용하여 한 줄 표현식 노드의 소스 세그먼트를 가져올 수 있습니다.</p>
</dd></dl>

<p><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.T</span></code> 클래스의 생성자는 다음과 같이 인자를 구문 분석합니다:</p>
<ul class="simple">
<li><p>위치 인자가 있으면, <code class="xref py py-attr docutils literal notranslate"><span class="pre">T._fields</span></code>에 있는 항목 수만큼 있어야 합니다; 이러한 이름의 어트리뷰트로 대입될 것입니다.</p></li>
<li><p>키워드 인자가 있으면, 같은 이름의 어트리뷰트를 지정된 값으로 설정합니다.</p></li>
</ul>
<p>예를 들어, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.UnaryOp</span></code> 노드를 만들고 채우려면, 다음과 같이 할 수 있습니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">node</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">UnaryOp</span><span class="p">()</span>
<span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">USub</span><span class="p">()</span>
<span class="n">node</span><span class="o">.</span><span class="n">operand</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span>
<span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">lineno</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">col_offset</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">node</span><span class="o">.</span><span class="n">lineno</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">node</span><span class="o">.</span><span class="n">col_offset</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>또는 더 간결하게</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">node</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">UnaryOp</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">USub</span><span class="p">(),</span> <span class="n">ast</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">lineno</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">col_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                   <span class="n">lineno</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">col_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.8부터 폐지: </span><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Constant</span></code> 클래스는 이제 모든 상수에 사용됩니다; 이전 클래스 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Num</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.NameConstant</span></code> 및 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Ellipsis</span></code>는 계속 사용할 수 있지만, 향후 파이썬 릴리스에서 제거될 예정입니다.</p>
</div>
</div>
<div class="section" id="abstract-grammar">
<span id="id1"></span><h2>추상 문법<a class="headerlink" href="#abstract-grammar" title="제목 주소">¶</a></h2>
<p>추상 문법은 현재 다음과 같이 정의됩니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-- ASDL&#39;s 5 builtin types are:
-- identifier, int, string, object, constant

module Python
{
    mod = Module(stmt* body, type_ignore *type_ignores)
        | Interactive(stmt* body)
        | Expression(expr body)
        | FunctionType(expr* argtypes, expr returns)

        -- not really an actual node but useful in Jython&#39;s typesystem.
        | Suite(stmt* body)

    stmt = FunctionDef(identifier name, arguments args,
                       stmt* body, expr* decorator_list, expr? returns,
                       string? type_comment)
          | AsyncFunctionDef(identifier name, arguments args,
                             stmt* body, expr* decorator_list, expr? returns,
                             string? type_comment)

          | ClassDef(identifier name,
             expr* bases,
             keyword* keywords,
             stmt* body,
             expr* decorator_list)
          | Return(expr? value)

          | Delete(expr* targets)
          | Assign(expr* targets, expr value, string? type_comment)
          | AugAssign(expr target, operator op, expr value)
          -- &#39;simple&#39; indicates that we annotate simple name without parens
          | AnnAssign(expr target, expr annotation, expr? value, int simple)

          -- use &#39;orelse&#39; because else is a keyword in target languages
          | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
          | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
          | While(expr test, stmt* body, stmt* orelse)
          | If(expr test, stmt* body, stmt* orelse)
          | With(withitem* items, stmt* body, string? type_comment)
          | AsyncWith(withitem* items, stmt* body, string? type_comment)

          | Raise(expr? exc, expr? cause)
          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)
          | Assert(expr test, expr? msg)

          | Import(alias* names)
          | ImportFrom(identifier? module, alias* names, int? level)

          | Global(identifier* names)
          | Nonlocal(identifier* names)
          | Expr(expr value)
          | Pass | Break | Continue

          -- XXX Jython will be different
          -- col_offset is the byte offset in the utf8 string the parser uses
          attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

          -- BoolOp() can use left &amp; right?
    expr = BoolOp(boolop op, expr* values)
         | NamedExpr(expr target, expr value)
         | BinOp(expr left, operator op, expr right)
         | UnaryOp(unaryop op, expr operand)
         | Lambda(arguments args, expr body)
         | IfExp(expr test, expr body, expr orelse)
         | Dict(expr* keys, expr* values)
         | Set(expr* elts)
         | ListComp(expr elt, comprehension* generators)
         | SetComp(expr elt, comprehension* generators)
         | DictComp(expr key, expr value, comprehension* generators)
         | GeneratorExp(expr elt, comprehension* generators)
         -- the grammar constrains where yield expressions can occur
         | Await(expr value)
         | Yield(expr? value)
         | YieldFrom(expr value)
         -- need sequences for compare to distinguish between
         -- x &lt; 4 &lt; 3 and (x &lt; 4) &lt; 3
         | Compare(expr left, cmpop* ops, expr* comparators)
         | Call(expr func, expr* args, keyword* keywords)
         | FormattedValue(expr value, int? conversion, expr? format_spec)
         | JoinedStr(expr* values)
         | Constant(constant value, string? kind)

         -- the following expression can appear in assignment context
         | Attribute(expr value, identifier attr, expr_context ctx)
         | Subscript(expr value, slice slice, expr_context ctx)
         | Starred(expr value, expr_context ctx)
         | Name(identifier id, expr_context ctx)
         | List(expr* elts, expr_context ctx)
         | Tuple(expr* elts, expr_context ctx)

          -- col_offset is the byte offset in the utf8 string the parser uses
          attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

    expr_context = Load | Store | Del | AugLoad | AugStore | Param

    slice = Slice(expr? lower, expr? upper, expr? step)
          | ExtSlice(slice* dims)
          | Index(expr value)

    boolop = And | Or

    operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift
                 | RShift | BitOr | BitXor | BitAnd | FloorDiv

    unaryop = Invert | Not | UAdd | USub

    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn

    comprehension = (expr target, expr iter, expr* ifs, int is_async)

    excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)
                    attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

    arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,
                 expr* kw_defaults, arg? kwarg, expr* defaults)

    arg = (identifier arg, expr? annotation, string? type_comment)
           attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

    -- keyword arguments supplied to call (NULL identifier for **kwargs)
    keyword = (identifier? arg, expr value)

    -- import name with optional &#39;as&#39; alias.
    alias = (identifier name, identifier? asname)

    withitem = (expr context_expr, expr? optional_vars)

    type_ignore = TypeIgnore(int lineno, string tag)
}
</pre></div>
</div>
</div>
<div class="section" id="ast-helpers">
<h2><a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 도우미<a class="headerlink" href="#ast-helpers" title="제목 주소">¶</a></h2>
<p>노드 클래스 외에도, <a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 모듈은 추상 구문 트리를 탐색하기 위해 다음 유틸리티 함수와 클래스를 정의합니다:</p>
<dl class="function">
<dt id="ast.parse">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">parse</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">filename='&lt;unknown&gt;'</em>, <em class="sig-param">mode='exec'</em>, <em class="sig-param">*</em>, <em class="sig-param">type_comments=False</em>, <em class="sig-param">feature_version=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.parse" title="정의 주소">¶</a></dt>
<dd><p>소스를 AST 노드로 구문 분석합니다. <code class="docutils literal notranslate"><span class="pre">compile(source,</span> <span class="pre">filename,</span> <span class="pre">mode,</span> <span class="pre">ast.PyCF_ONLY_AST)</span></code>와 동등합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">type_comments=True</span></code>가 제공되면, 구문 분석기는 <span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>와 <span class="target" id="index-9"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>에 지정된 형 주석을 확인하고 반환하도록 수정됩니다. 이는 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>에 전달된 플래그에 <code class="xref py py-data docutils literal notranslate"><span class="pre">ast.PyCF_TYPE_COMMENTS</span></code>를 추가하는 것과 같습니다. 이것은 잘못 배치된 형 주석에 대한 문법 에러를 보고합니다. 이 플래그가 없으면, 형 주석은 무시되고, 선택한 AST 노드의 <code class="docutils literal notranslate"><span class="pre">type_comment</span></code> 필드는 항상 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. 또한, <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">type:</span> <span class="pre">ignore</span></code> 주석의 위치는 <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code>의 <code class="docutils literal notranslate"><span class="pre">type_ignores</span></code> 어트리뷰트로 반환됩니다 (그렇지 않으면 항상 빈 리스트입니다).</p>
<p>또한, <code class="docutils literal notranslate"><span class="pre">mode</span></code>가 <code class="docutils literal notranslate"><span class="pre">'func_type'</span></code>이면, 입력 문법은 <span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> &quot;서명 형 주석&quot;에 따라 수정됩니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">(str,</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">List[str]</span></code>.</p>
<p>또한, <code class="docutils literal notranslate"><span class="pre">feature_version</span></code>을 튜플 <code class="docutils literal notranslate"><span class="pre">(major,</span> <span class="pre">minor)</span></code>로 설정하면 해당 파이썬 버전의 문법을 사용하여 구문 분석을 시도합니다. 현재 <code class="docutils literal notranslate"><span class="pre">major</span></code>는 <code class="docutils literal notranslate"><span class="pre">3</span></code>과 같아야 합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">feature_version=(3,</span> <span class="pre">4)</span></code>를 설정하면 변수 이름으로 <code class="docutils literal notranslate"><span class="pre">async</span></code>와 <code class="docutils literal notranslate"><span class="pre">await</span></code>를 사용할 수 있습니다. 가장 낮은 지원 버전은 <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">4)</span></code>입니다; 가장 높은 것은 <code class="docutils literal notranslate"><span class="pre">sys.version_info[0:2]</span></code>입니다.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>파이썬 AST 컴파일러의 스택 깊이 제한으로 인해 충분히 크고/복잡한 문자열로 파이썬 인터프리터가 충돌하도록 만들 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><code class="docutils literal notranslate"><span class="pre">type_comments</span></code>, <code class="docutils literal notranslate"><span class="pre">mode='func_type'</span></code> 및 <code class="docutils literal notranslate"><span class="pre">feature_version</span></code>추가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.literal_eval">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">literal_eval</code><span class="sig-paren">(</span><em class="sig-param">node_or_string</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.literal_eval" title="정의 주소">¶</a></dt>
<dd><p>파이썬 리터럴 이나 컨테이너 디스플레이를 포함하는 표현식 노드나 문자열을 안전하게 평가합니다. 제공된 문자열이나 노드는 다음과 같은 파이썬 리터럴 구조로만 구성될 수 있습니다: 문자열, 바이트열, 숫자, 튜플, 리스트, 딕셔너리, 집합, 불리언 및 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>값을 직접 구문 분석할 필요 없이 신뢰할 수 없는 소스의 파이썬 값을 포함하는 문자열을 안전하게 평가하는 데 사용할 수 있습니다. 예를 들어 연산자나 인덱싱이 개입한, 임의의 복잡한 표현식을 평가할 수 없습니다.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>파이썬 AST 컴파일러의 스택 깊이 제한으로 인해 충분히 크고/복잡한 문자열로 파이썬 인터프리터가 충돌하도록 만들 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>이제 바이트열과 집합 리터럴을 허용합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.get_docstring">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">get_docstring</code><span class="sig-paren">(</span><em class="sig-param">node</em>, <em class="sig-param">clean=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.get_docstring" title="정의 주소">¶</a></dt>
<dd><p>주어진 <em>node</em>(<code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionDef</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncFunctionDef</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ClassDef</span></code> 또는 <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code> 노드이어야 합니다)의 독스트링이나, 독스트링이 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. <em>clean</em>이 참이면, <a class="reference internal" href="inspect.html#inspect.cleandoc" title="inspect.cleandoc"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.cleandoc()</span></code></a>으로 독스트링의 들여쓰기를 정리합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncFunctionDef</span></code> 가 이제 지원됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.get_source_segment">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">get_source_segment</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">node</em>, <em class="sig-param">*</em>, <em class="sig-param">padded=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.get_source_segment" title="정의 주소">¶</a></dt>
<dd><p><em>node</em>를 생성한 <em>source</em>의 소스 코드 세그먼트를 가져옵니다. 일부 위치 정보(<code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">end_lineno</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code> 또는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">end_col_offset</span></code>)가 없으면, <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<p><em>padded</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면, 여러 줄 문장의 첫 번째 줄은 원래 위치와 일치하도록 스페이스로 채워집니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.fix_missing_locations">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">fix_missing_locations</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.fix_missing_locations" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>로 노드 트리를 컴파일할 때, 컴파일러는 지원하는 모든 노드에 대해 <code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code>와 <code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code> 어트리뷰트를 기대합니다. 생성된 노드를 채울 때는 이것이 다소 지루하므로, 이 도우미는 이러한 어트리뷰트를 재귀적으로 아직 설정되지 않은 위치에 부모 노드의 값으로 설정하여 추가합니다. <em>node</em>부터 재귀적으로 작동합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ast.increment_lineno">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">increment_lineno</code><span class="sig-paren">(</span><em class="sig-param">node</em>, <em class="sig-param">n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.increment_lineno" title="정의 주소">¶</a></dt>
<dd><p><em>node</em>에서 시작하는 트리에서 각 노드의 줄 번호와 끝 줄 번호를 <em>n</em>만큼 증가시킵니다. 파일의 다른 위치로 &quot;코드를 이동&quot;하는 데 유용합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ast.copy_location">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">copy_location</code><span class="sig-paren">(</span><em class="sig-param">new_node</em>, <em class="sig-param">old_node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.copy_location" title="정의 주소">¶</a></dt>
<dd><p>가능하면 소스 위치(<code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">end_lineno</span></code> 및 <code class="xref py py-attr docutils literal notranslate"><span class="pre">end_col_offset</span></code>)를 <em>old_node</em>에서 <em>new_node</em>로 복사하고, <em>new_node</em>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ast.iter_fields">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">iter_fields</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.iter_fields" title="정의 주소">¶</a></dt>
<dd><p><em>node</em>에 존재하는 <code class="docutils literal notranslate"><span class="pre">node._fields</span></code>의 각 필드에 대해 <code class="docutils literal notranslate"><span class="pre">(fieldname,</span> <span class="pre">value)</span></code> 튜플을 산출합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ast.iter_child_nodes">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">iter_child_nodes</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.iter_child_nodes" title="정의 주소">¶</a></dt>
<dd><p><em>node</em>의 모든 직접 자식 노드, 즉 노드인 모든 필드와 노드 리스트인 필드의 모든 항목을 산출합니다.</p>
</dd></dl>

<dl class="function">
<dt id="ast.walk">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">walk</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.walk" title="정의 주소">¶</a></dt>
<dd><p><em>node</em>로 시작하는 트리(<em>node</em> 자체를 포함합니다)의 모든 자손 노드를 지정된 순서 없이 재귀적으로 산출합니다. 이는 노드를 제자리에서 수정하고 문맥을 신경 쓰지 않을 때 유용합니다.</p>
</dd></dl>

<dl class="class">
<dt id="ast.NodeVisitor">
<em class="property">class </em><code class="sig-prename descclassname">ast.</code><code class="sig-name descname">NodeVisitor</code><a class="headerlink" href="#ast.NodeVisitor" title="정의 주소">¶</a></dt>
<dd><p>추상 구문 트리를 걷고 발견된 모든 노드에 대해 방문자 함수를 호출하는 노드 방문자 베이스 클래스. 이 함수는 <a class="reference internal" href="#ast.NodeVisitor.visit" title="ast.NodeVisitor.visit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">visit()</span></code></a> 메서드에 의해 전달되는 값을 반환할 수 있습니다.</p>
<p>이 클래스는 서브 클래싱하고자 하는 것이며, 서브 클래스는 방문자 메서드를 추가합니다.</p>
<dl class="method">
<dt id="ast.NodeVisitor.visit">
<code class="sig-name descname">visit</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.NodeVisitor.visit" title="정의 주소">¶</a></dt>
<dd><p>노드를 방문합니다. 기본 구현은 <code class="samp docutils literal notranslate"><span class="pre">self.visit_</span><em><span class="pre">classname</span></em></code>이라는 메서드를 호출하는데, 여기서 <em>classname</em> 은 노드 클래스의 이름입니다. 또는 이 메서드가 없으면 <a class="reference internal" href="#ast.NodeVisitor.generic_visit" title="ast.NodeVisitor.generic_visit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generic_visit()</span></code></a>를 호출합니다.</p>
</dd></dl>

<dl class="method">
<dt id="ast.NodeVisitor.generic_visit">
<code class="sig-name descname">generic_visit</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.NodeVisitor.generic_visit" title="정의 주소">¶</a></dt>
<dd><p>이 방문자는 노드의 자식에 대해 <a class="reference internal" href="#ast.NodeVisitor.visit" title="ast.NodeVisitor.visit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">visit()</span></code></a>를 호출합니다.</p>
<p>방문자가 <a class="reference internal" href="#ast.NodeVisitor.generic_visit" title="ast.NodeVisitor.generic_visit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generic_visit()</span></code></a>를 호출하거나 직접 방문하지 않는 한, 사용자 정의 방문자 메서드가 있는 노드의 자식 노드는 방문 되지 않음에 유의하십시오.</p>
</dd></dl>

<p>탐색 중에 노드에 변경 사항을 적용하려면 <a class="reference internal" href="#ast.NodeVisitor" title="ast.NodeVisitor"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeVisitor</span></code></a>를 사용하지 마십시오. 이를 위해 수정을 허락하는 특수한 방문자(<a class="reference internal" href="#ast.NodeTransformer" title="ast.NodeTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeTransformer</span></code></a>)가 있습니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.8부터 폐지: </span>메서드 <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Num()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Str()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Bytes()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_NameConstant()</span></code> 및 <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Ellipsis()</span></code>는 이제 폐지되었고 향후 파이썬 버전에서는 호출되지 않을 것입니다. 모든 상수 노드를 처리하려면 <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Constant()</span></code> 메서드를 추가하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="ast.NodeTransformer">
<em class="property">class </em><code class="sig-prename descclassname">ast.</code><code class="sig-name descname">NodeTransformer</code><a class="headerlink" href="#ast.NodeTransformer" title="정의 주소">¶</a></dt>
<dd><p>추상 구문 트리를 걷고 노드 수정을 허락하는 <a class="reference internal" href="#ast.NodeVisitor" title="ast.NodeVisitor"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeVisitor</span></code></a> 서브 클래스.</p>
<p><a class="reference internal" href="#ast.NodeTransformer" title="ast.NodeTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeTransformer</span></code></a>는 AST를 걷고 방문자 메서드의 반환 값을 사용하여 이전 노드를 바꾸거나 제거합니다. 방문자 메서드의 반환 값이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, 노드가 그 위치에서 제거되고, 그렇지 않으면 반환 값으로 치환됩니다. 반환 값은 원래 노드일 수 있으며, 이때는 치환이 일어나지 않습니다.</p>
<p>다음은 모든 이름 조회(<code class="docutils literal notranslate"><span class="pre">foo</span></code>)를 <code class="docutils literal notranslate"><span class="pre">data['foo']</span></code>로 다시 쓰는 변환기 예제입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RewriteName</span><span class="p">(</span><span class="n">NodeTransformer</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">visit_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Subscript</span><span class="p">(</span>
            <span class="n">value</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span>
            <span class="nb">slice</span><span class="o">=</span><span class="n">Index</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">Constant</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)),</span>
            <span class="n">ctx</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span>
        <span class="p">),</span> <span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
<p>작업 중인 노드에 자식 노드가 있으면 자식 노드를 직접 변환하거나 노드에 대한 <code class="xref py py-meth docutils literal notranslate"><span class="pre">generic_visit()</span></code> 메서드를 먼저 호출해야 함을 염두에 두십시오.</p>
<p>문장의 컬렉션의 일부인 노드의 경우 (모든 문장 노드에 적용됩니다), 방문자는 단일 노드가 아닌 노드 리스트를 반환 할 수도 있습니다.</p>
<p><a class="reference internal" href="#ast.NodeTransformer" title="ast.NodeTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeTransformer</span></code></a>가 위치 정보(가령 <code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code>)를 제공하지 않고 (원래 트리의 일부가 아닌) 새 노드를 도입하면, 위치 정보를 다시 계산하려면 <a class="reference internal" href="#ast.fix_missing_locations" title="ast.fix_missing_locations"><code class="xref py py-func docutils literal notranslate"><span class="pre">fix_missing_locations()</span></code></a>를 새 서브 트리로 호출해야 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;eval&#39;</span><span class="p">)</span>
<span class="n">new_tree</span> <span class="o">=</span> <span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">RewriteName</span><span class="p">()</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
</pre></div>
</div>
<p>일반적으로 다음과 같이 변환기를 사용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">node</span> <span class="o">=</span> <span class="n">YourTransformer</span><span class="p">()</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.dump">
<code class="sig-prename descclassname">ast.</code><code class="sig-name descname">dump</code><span class="sig-paren">(</span><em class="sig-param">node</em>, <em class="sig-param">annotate_fields=True</em>, <em class="sig-param">include_attributes=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.dump" title="정의 주소">¶</a></dt>
<dd><p><em>node</em>에서 포맷된 트리 덤프를 반환합니다. 이것은 주로 디버깅 목적으로 유용합니다. <em>annotate_fields</em>가 참이면 (기본값), 반환된 문자열에 필드의 이름과 값이 표시됩니다. <em>annotate_fields</em>가 거짓이면, 모호하지 않은 필드 이름을 생략하여 결과 문자열이 더 간결해집니다. 줄 번호와 열 오프셋과 같은 어트리뷰트는 기본적으로 덤프 되지 않습니다. 원한다면, <em>include_attributes</em>를 참으로 설정할 수 있습니다.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference external" href="https://greentreesnakes.readthedocs.io/">Green Tree Snakes</a>, 파이썬 AST로 작업하는 것에 대한 자세한 내용이 있는 외부 문서 리소스.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code> --- 추상 구문 트리</a><ul>
<li><a class="reference internal" href="#node-classes">노드 클래스</a></li>
<li><a class="reference internal" href="#abstract-grammar">추상 문법</a></li>
<li><a class="reference internal" href="#ast-helpers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code> 도우미</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="parser.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code> --- Access Python parse trees</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="symtable.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symtable</span></code> --- 컴파일러 심볼 테이블 액세스</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="symtable.html" title="symtable --- 컴파일러 심볼 테이블 액세스"
             >다음</a> |</li>
        <li class="right" >
          <a href="parser.html" title="parser --- Access Python parse trees"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="language.html" >파이썬 언어 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>