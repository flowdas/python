
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>ast --- 추상 구문 트리 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="symtable --- 컴파일러 심볼 테이블 액세스" href="symtable.html" />
    <link rel="prev" title="parser --- Access Python parse trees" href="parser.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/ast.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="symtable.html" title="symtable --- 컴파일러 심볼 테이블 액세스"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="parser.html" title="parser --- Access Python parse trees"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="language.html" accesskey="U">파이썬 언어 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-ast">
<span id="ast-abstract-syntax-trees"></span><h1><a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> --- 추상 구문 트리<a class="headerlink" href="#module-ast" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/ast.py">Lib/ast.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 모듈은 파이썬 응용 프로그램이 파이썬 추상 구문 문법의 트리를 처리하는데 도움을 줍니다. 추상 구문 자체는 각 파이썬 릴리스마다 바뀔 수 있습니다; 이 모듈은 프로그래밍 방식으로 현재 문법의 모양을 찾는 데 도움이됩니다.</p>
<p><code class="xref py py-data docutils literal notranslate"><span class="pre">ast.PyCF_ONLY_AST</span></code>를 플래그로 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 내장 함수에 전달하거나, 이 모듈에서 제공된 <a class="reference internal" href="#ast.parse" title="ast.parse"><code class="xref py py-func docutils literal notranslate"><span class="pre">parse()</span></code></a> 도우미를 사용하여 추상 구문 트리를 생성할 수 있습니다. 결과는 클래스가 모두 <a class="reference internal" href="#ast.AST" title="ast.AST"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.AST</span></code></a>에서 상속되는 객체들의 트리가 됩니다. 내장 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 함수를 사용하여 추상 구문 트리를 파이썬 코드 객체로 컴파일할 수 있습니다.</p>
<div class="section" id="node-classes">
<h2>노드 클래스<a class="headerlink" href="#node-classes" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="ast.AST">
<em class="property">class </em><code class="descclassname">ast.</code><code class="descname">AST</code><a class="headerlink" href="#ast.AST" title="정의 주소">¶</a></dt>
<dd><p>이것은 모든 AST 노드 클래스의 베이스입니다. 실제 노드 클래스는 <code class="file docutils literal notranslate"><span class="pre">Parser/Python.asdl</span></code> 파일에서 파생되며, 이 파일의 내용은 <a class="reference internal" href="#abstract-grammar"><span class="std std-ref">아래</span></a>에서 볼 수 있습니다. <code class="xref py py-mod docutils literal notranslate"><span class="pre">_ast</span></code> C 모듈에 정의되어 있으며 <a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a>로 다시 내보내집니다.</p>
<p>추상 문법의 각 좌변 심볼마다 하나의 클래스가 정의되어 있습니다 (예를 들어, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.stmt</span></code>나 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.expr</span></code>). 또한, 우변의 각 생성자마다 하나의 클래스가 정의되어 있습니다; 이 클래스는 좌변 트리의 클래스에서 상속됩니다. 예를 들어, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.BinOp</span></code>는 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.expr</span></code>에서 상속됩니다. 대안을 갖는 생성 규칙(일명 &quot;합&quot;)의 경우, 좌변 클래스는 추상입니다: 특정 생성자 노드의 인스턴스 만 만들어집니다.</p>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><dl class="attribute">
<dt id="ast.AST._fields">
<code class="descname">_fields</code><a class="headerlink" href="#ast.AST._fields" title="정의 주소">¶</a></dt>
<dd><p>각 구상 클래스에는 모든 자식 노드의 이름을 제공하는 어트리뷰트 <a class="reference internal" href="#ast.AST._fields" title="ast.AST._fields"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields</span></code></a>가 있습니다.</p>
<p>구상 클래스의 각 인스턴스에는 각 자식 노드마다 문법에 정의된 형의 어트리뷰트가 하나씩 있습니다. 예를 들어, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.BinOp</span></code> 인스턴스는 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.expr</span></code> 형의 어트리뷰트 <code class="xref py py-attr docutils literal notranslate"><span class="pre">left</span></code>를 갖습니다.</p>
<p>문법에서 이러한 어트리뷰트가 선택적으로 표시되면 (물음표를 사용해서), 값은 <code class="docutils literal notranslate"><span class="pre">None</span></code> 일 수 있습니다. 어트리뷰트가 0개 이상의 값을 가질 수 있으면 (애스터리스크로 표시됩니다), 값은 파이썬 리스트로 표현됩니다. <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>로 AST를 컴파일할 때 가능한 모든 어트리뷰트가 존재하고 유효한 값을 가져야합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="ast.AST.lineno">
<code class="descname">lineno</code><a class="headerlink" href="#ast.AST.lineno" title="정의 주소">¶</a></dt>
<dt id="ast.AST.col_offset">
<code class="descname">col_offset</code><a class="headerlink" href="#ast.AST.col_offset" title="정의 주소">¶</a></dt>
<dt id="ast.AST.end_lineno">
<code class="descname">end_lineno</code><a class="headerlink" href="#ast.AST.end_lineno" title="정의 주소">¶</a></dt>
<dt id="ast.AST.end_col_offset">
<code class="descname">end_col_offset</code><a class="headerlink" href="#ast.AST.end_col_offset" title="정의 주소">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.expr</span></code>과 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.stmt</span></code> 서브 클래스의 인스턴스에는 <a class="reference internal" href="#ast.AST.lineno" title="ast.AST.lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code></a>, <a class="reference internal" href="#ast.AST.col_offset" title="ast.AST.col_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code></a>, <a class="reference internal" href="#ast.AST.lineno" title="ast.AST.lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code></a> 및 <a class="reference internal" href="#ast.AST.col_offset" title="ast.AST.col_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code></a> 어트리뷰트가 있습니다. <a class="reference internal" href="#ast.AST.lineno" title="ast.AST.lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code></a>와 <a class="reference internal" href="#ast.AST.end_lineno" title="ast.AST.end_lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">end_lineno</span></code></a>는 소스 텍스트 스팬의 첫 번째와 마지막 줄 번호(1-인덱싱이라서 첫 번째 줄은 줄 1 입니다)이고 <a class="reference internal" href="#ast.AST.col_offset" title="ast.AST.col_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code></a>과 <a class="reference internal" href="#ast.AST.end_col_offset" title="ast.AST.end_col_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">end_col_offset</span></code></a>은 노드를 생성한 첫 번째와 마지막 토큰의 해당 UTF-8 바이트 오프셋입니다. 구문 분석기가 UTF-8을 내부적으로 사용하기 때문에 UTF-8 오프셋이 기록됩니다.</p>
<p>종료 위치는 컴파일러에 필요하지 않아서 선택 사항입니다. 종료 오프셋은 마지막 심볼 <em>뒤</em>입니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">source_line[node.col_offset</span> <span class="pre">:</span> <span class="pre">node.end_col_offset]</span></code>를 사용하여 한 줄 표현식 노드의 소스 세그먼트를 가져올 수 있습니다.</p>
</dd></dl>

<p><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.T</span></code> 클래스의 생성자는 다음과 같이 인자를 구문 분석합니다:</p>
<ul class="simple">
<li><p>위치 인자가 있으면, <code class="xref py py-attr docutils literal notranslate"><span class="pre">T._fields</span></code>에 있는 항목 수만큼 있어야합니다; 이러한 이름의 어트리뷰트로 대입될 것입니다.</p></li>
<li><p>키워드 인자가 있으면, 같은 이름의 어트리뷰트를 지정된 값으로 설정합니다.</p></li>
</ul>
<p>예를 들어, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.UnaryOp</span></code> 노드를 만들고 채우려면, 다음과 같이 할 수 있습니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">node</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">UnaryOp</span><span class="p">()</span>
<span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">USub</span><span class="p">()</span>
<span class="n">node</span><span class="o">.</span><span class="n">operand</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">Constant</span><span class="p">()</span>
<span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">lineno</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">col_offset</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">node</span><span class="o">.</span><span class="n">lineno</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">node</span><span class="o">.</span><span class="n">col_offset</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>또는 더 간결하게</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">node</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">UnaryOp</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">USub</span><span class="p">(),</span> <span class="n">ast</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">lineno</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">col_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                   <span class="n">lineno</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">col_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.8부터 폐지: </span><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Constant</span></code> 클래스는 이제 모든 상수에 사용됩니다; 이전 클래스 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Num</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.NameConstant</span></code> 및 <code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Ellipsis</span></code>는 계속 사용할 수 있지만, 향후 파이썬 릴리스에서 제거될 예정입니다.</p>
</div>
</div>
<div class="section" id="abstract-grammar">
<span id="id1"></span><h2>추상 문법<a class="headerlink" href="#abstract-grammar" title="제목 주소">¶</a></h2>
<p>추상 문법은 현재 다음과 같이 정의됩니다:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-- ASDL&#39;s 5 builtin types are:
-- identifier, int, string, object, constant

module Python
{
    mod = Module(stmt* body, type_ignore *type_ignores)
        | Interactive(stmt* body)
        | Expression(expr body)
        | FunctionType(expr* argtypes, expr returns)

        -- not really an actual node but useful in Jython&#39;s typesystem.
        | Suite(stmt* body)

    stmt = FunctionDef(identifier name, arguments args,
                       stmt* body, expr* decorator_list, expr? returns,
                       string? type_comment)
          | AsyncFunctionDef(identifier name, arguments args,
                             stmt* body, expr* decorator_list, expr? returns,
                             string? type_comment)

          | ClassDef(identifier name,
             expr* bases,
             keyword* keywords,
             stmt* body,
             expr* decorator_list)
          | Return(expr? value)

          | Delete(expr* targets)
          | Assign(expr* targets, expr value, string? type_comment)
          | AugAssign(expr target, operator op, expr value)
          -- &#39;simple&#39; indicates that we annotate simple name without parens
          | AnnAssign(expr target, expr annotation, expr? value, int simple)

          -- use &#39;orelse&#39; because else is a keyword in target languages
          | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
          | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
          | While(expr test, stmt* body, stmt* orelse)
          | If(expr test, stmt* body, stmt* orelse)
          | With(withitem* items, stmt* body, string? type_comment)
          | AsyncWith(withitem* items, stmt* body, string? type_comment)

          | Raise(expr? exc, expr? cause)
          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)
          | Assert(expr test, expr? msg)

          | Import(alias* names)
          | ImportFrom(identifier? module, alias* names, int? level)

          | Global(identifier* names)
          | Nonlocal(identifier* names)
          | Expr(expr value)
          | Pass | Break | Continue

          -- XXX Jython will be different
          -- col_offset is the byte offset in the utf8 string the parser uses
          attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

          -- BoolOp() can use left &amp; right?
    expr = BoolOp(boolop op, expr* values)
         | NamedExpr(expr target, expr value)
         | BinOp(expr left, operator op, expr right)
         | UnaryOp(unaryop op, expr operand)
         | Lambda(arguments args, expr body)
         | IfExp(expr test, expr body, expr orelse)
         | Dict(expr* keys, expr* values)
         | Set(expr* elts)
         | ListComp(expr elt, comprehension* generators)
         | SetComp(expr elt, comprehension* generators)
         | DictComp(expr key, expr value, comprehension* generators)
         | GeneratorExp(expr elt, comprehension* generators)
         -- the grammar constrains where yield expressions can occur
         | Await(expr value)
         | Yield(expr? value)
         | YieldFrom(expr value)
         -- need sequences for compare to distinguish between
         -- x &lt; 4 &lt; 3 and (x &lt; 4) &lt; 3
         | Compare(expr left, cmpop* ops, expr* comparators)
         | Call(expr func, expr* args, keyword* keywords)
         | FormattedValue(expr value, int? conversion, expr? format_spec)
         | JoinedStr(expr* values)
         | Constant(constant value, string? kind)

         -- the following expression can appear in assignment context
         | Attribute(expr value, identifier attr, expr_context ctx)
         | Subscript(expr value, slice slice, expr_context ctx)
         | Starred(expr value, expr_context ctx)
         | Name(identifier id, expr_context ctx)
         | List(expr* elts, expr_context ctx)
         | Tuple(expr* elts, expr_context ctx)

          -- col_offset is the byte offset in the utf8 string the parser uses
          attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

    expr_context = Load | Store | Del | AugLoad | AugStore | Param

    slice = Slice(expr? lower, expr? upper, expr? step)
          | ExtSlice(slice* dims)
          | Index(expr value)

    boolop = And | Or

    operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift
                 | RShift | BitOr | BitXor | BitAnd | FloorDiv

    unaryop = Invert | Not | UAdd | USub

    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn

    comprehension = (expr target, expr iter, expr* ifs, int is_async)

    excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)
                    attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

    arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,
                 expr* kw_defaults, arg? kwarg, expr* defaults)

    arg = (identifier arg, expr? annotation, string? type_comment)
           attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)

    -- keyword arguments supplied to call (NULL identifier for **kwargs)
    keyword = (identifier? arg, expr value)

    -- import name with optional &#39;as&#39; alias.
    alias = (identifier name, identifier? asname)

    withitem = (expr context_expr, expr? optional_vars)

    type_ignore = TypeIgnore(int lineno, string tag)
}
</pre></div>
</div>
</div>
<div class="section" id="ast-helpers">
<h2><a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 도우미<a class="headerlink" href="#ast-helpers" title="제목 주소">¶</a></h2>
<p>Apart from the node classes, the <a class="reference internal" href="#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> module defines these utility functions
and classes for traversing abstract syntax trees:</p>
<dl class="function">
<dt id="ast.parse">
<code class="descclassname">ast.</code><code class="descname">parse</code><span class="sig-paren">(</span><em>source</em>, <em>filename='&lt;unknown&gt;'</em>, <em>mode='exec'</em>, <em>*</em>, <em>type_comments=False</em>, <em>feature_version=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.parse" title="정의 주소">¶</a></dt>
<dd><p>Parse the source into an AST node.  Equivalent to <code class="docutils literal notranslate"><span class="pre">compile(source,</span>
<span class="pre">filename,</span> <span class="pre">mode,</span> <span class="pre">ast.PyCF_ONLY_AST)</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">type_comments=True</span></code> is given, the parser is modified to check
and return type comments as specified by <span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> and <span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>.
This is equivalent to adding <code class="xref py py-data docutils literal notranslate"><span class="pre">ast.PyCF_TYPE_COMMENTS</span></code> to the
flags passed to <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>.  This will report syntax errors
for misplaced type comments.  Without this flag, type comments will
be ignored, and the <code class="docutils literal notranslate"><span class="pre">type_comment</span></code> field on selected AST nodes
will always be <code class="docutils literal notranslate"><span class="pre">None</span></code>.  In addition, the locations of <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">type:</span>
<span class="pre">ignore</span></code> comments will be returned as the <code class="docutils literal notranslate"><span class="pre">type_ignores</span></code>
attribute of <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code> (otherwise it is always an empty list).</p>
<p>In addition, if <code class="docutils literal notranslate"><span class="pre">mode</span></code> is <code class="docutils literal notranslate"><span class="pre">'func_type'</span></code>, the input syntax is
modified to correspond to <span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> &quot;signature type comments&quot;,
e.g. <code class="docutils literal notranslate"><span class="pre">(str,</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">List[str]</span></code>.</p>
<p>Also, setting <code class="docutils literal notranslate"><span class="pre">feature_version</span></code> to a tuple <code class="docutils literal notranslate"><span class="pre">(major,</span> <span class="pre">minor)</span></code>
will attempt to parse using that Python version's grammar.
Currently <code class="docutils literal notranslate"><span class="pre">major</span></code> must equal to <code class="docutils literal notranslate"><span class="pre">3</span></code>.  For example, setting
<code class="docutils literal notranslate"><span class="pre">feature_version=(3,</span> <span class="pre">4)</span></code> will allow the use of <code class="docutils literal notranslate"><span class="pre">async</span></code> and
<code class="docutils literal notranslate"><span class="pre">await</span></code> as variable names.  The lowest supported version is
<code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">4)</span></code>; the highest is <code class="docutils literal notranslate"><span class="pre">sys.version_info[0:2]</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>It is possible to crash the Python interpreter with a
sufficiently large/complex string due to stack depth limitations
in Python's AST compiler.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>Added <code class="docutils literal notranslate"><span class="pre">type_comments</span></code>, <code class="docutils literal notranslate"><span class="pre">mode='func_type'</span></code> and <code class="docutils literal notranslate"><span class="pre">feature_version</span></code>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.literal_eval">
<code class="descclassname">ast.</code><code class="descname">literal_eval</code><span class="sig-paren">(</span><em>node_or_string</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.literal_eval" title="정의 주소">¶</a></dt>
<dd><p>Safely evaluate an expression node or a string containing a Python literal or
container display.  The string or node provided may only consist of the
following Python literal structures: strings, bytes, numbers, tuples, lists,
dicts, sets, booleans, and <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>This can be used for safely evaluating strings containing Python values from
untrusted sources without the need to parse the values oneself.  It is not
capable of evaluating arbitrarily complex expressions, for example involving
operators or indexing.</p>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p>It is possible to crash the Python interpreter with a
sufficiently large/complex string due to stack depth limitations
in Python's AST compiler.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span>Now allows bytes and set literals.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.get_docstring">
<code class="descclassname">ast.</code><code class="descname">get_docstring</code><span class="sig-paren">(</span><em>node</em>, <em>clean=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.get_docstring" title="정의 주소">¶</a></dt>
<dd><p>Return the docstring of the given <em>node</em> (which must be a
<code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionDef</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncFunctionDef</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ClassDef</span></code>,
or <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code> node), or <code class="docutils literal notranslate"><span class="pre">None</span></code> if it has no docstring.
If <em>clean</em> is true, clean up the docstring's indentation with
<a class="reference internal" href="inspect.html#inspect.cleandoc" title="inspect.cleandoc"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.cleandoc()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncFunctionDef</span></code> is now supported.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.get_source_segment">
<code class="descclassname">ast.</code><code class="descname">get_source_segment</code><span class="sig-paren">(</span><em>source</em>, <em>node</em>, <em>*</em>, <em>padded=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.get_source_segment" title="정의 주소">¶</a></dt>
<dd><p>Get source code segment of the <em>source</em> that generated <em>node</em>.
If some location information (<code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">end_lineno</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code>, or <code class="xref py py-attr docutils literal notranslate"><span class="pre">end_col_offset</span></code>) is missing, return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>If <em>padded</em> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the first line of a multi-line statement will
be padded with spaces to match its original position.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.fix_missing_locations">
<code class="descclassname">ast.</code><code class="descname">fix_missing_locations</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.fix_missing_locations" title="정의 주소">¶</a></dt>
<dd><p>When you compile a node tree with <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>, the compiler expects
<code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code> attributes for every node that supports
them.  This is rather tedious to fill in for generated nodes, so this helper
adds these attributes recursively where not already set, by setting them to
the values of the parent node.  It works recursively starting at <em>node</em>.</p>
</dd></dl>

<dl class="function">
<dt id="ast.increment_lineno">
<code class="descclassname">ast.</code><code class="descname">increment_lineno</code><span class="sig-paren">(</span><em>node</em>, <em>n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.increment_lineno" title="정의 주소">¶</a></dt>
<dd><p>Increment the line number and end line number of each node in the tree
starting at <em>node</em> by <em>n</em>. This is useful to &quot;move code&quot; to a different
location in a file.</p>
</dd></dl>

<dl class="function">
<dt id="ast.copy_location">
<code class="descclassname">ast.</code><code class="descname">copy_location</code><span class="sig-paren">(</span><em>new_node</em>, <em>old_node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.copy_location" title="정의 주소">¶</a></dt>
<dd><p>Copy source location (<code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">col_offset</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">end_lineno</span></code>,
and <code class="xref py py-attr docutils literal notranslate"><span class="pre">end_col_offset</span></code>) from <em>old_node</em> to <em>new_node</em> if possible,
and return <em>new_node</em>.</p>
</dd></dl>

<dl class="function">
<dt id="ast.iter_fields">
<code class="descclassname">ast.</code><code class="descname">iter_fields</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.iter_fields" title="정의 주소">¶</a></dt>
<dd><p>Yield a tuple of <code class="docutils literal notranslate"><span class="pre">(fieldname,</span> <span class="pre">value)</span></code> for each field in <code class="docutils literal notranslate"><span class="pre">node._fields</span></code>
that is present on <em>node</em>.</p>
</dd></dl>

<dl class="function">
<dt id="ast.iter_child_nodes">
<code class="descclassname">ast.</code><code class="descname">iter_child_nodes</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.iter_child_nodes" title="정의 주소">¶</a></dt>
<dd><p>Yield all direct child nodes of <em>node</em>, that is, all fields that are nodes
and all items of fields that are lists of nodes.</p>
</dd></dl>

<dl class="function">
<dt id="ast.walk">
<code class="descclassname">ast.</code><code class="descname">walk</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.walk" title="정의 주소">¶</a></dt>
<dd><p>Recursively yield all descendant nodes in the tree starting at <em>node</em>
(including <em>node</em> itself), in no specified order.  This is useful if you only
want to modify nodes in place and don't care about the context.</p>
</dd></dl>

<dl class="class">
<dt id="ast.NodeVisitor">
<em class="property">class </em><code class="descclassname">ast.</code><code class="descname">NodeVisitor</code><a class="headerlink" href="#ast.NodeVisitor" title="정의 주소">¶</a></dt>
<dd><p>A node visitor base class that walks the abstract syntax tree and calls a
visitor function for every node found.  This function may return a value
which is forwarded by the <a class="reference internal" href="#ast.NodeVisitor.visit" title="ast.NodeVisitor.visit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">visit()</span></code></a> method.</p>
<p>This class is meant to be subclassed, with the subclass adding visitor
methods.</p>
<dl class="method">
<dt id="ast.NodeVisitor.visit">
<code class="descname">visit</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.NodeVisitor.visit" title="정의 주소">¶</a></dt>
<dd><p>Visit a node.  The default implementation calls the method called
<code class="samp docutils literal notranslate"><span class="pre">self.visit_</span><em><span class="pre">classname</span></em></code> where <em>classname</em> is the name of the node
class, or <a class="reference internal" href="#ast.NodeVisitor.generic_visit" title="ast.NodeVisitor.generic_visit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generic_visit()</span></code></a> if that method doesn't exist.</p>
</dd></dl>

<dl class="method">
<dt id="ast.NodeVisitor.generic_visit">
<code class="descname">generic_visit</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.NodeVisitor.generic_visit" title="정의 주소">¶</a></dt>
<dd><p>This visitor calls <a class="reference internal" href="#ast.NodeVisitor.visit" title="ast.NodeVisitor.visit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">visit()</span></code></a> on all children of the node.</p>
<p>Note that child nodes of nodes that have a custom visitor method won't be
visited unless the visitor calls <a class="reference internal" href="#ast.NodeVisitor.generic_visit" title="ast.NodeVisitor.generic_visit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generic_visit()</span></code></a> or visits them
itself.</p>
</dd></dl>

<p>Don't use the <a class="reference internal" href="#ast.NodeVisitor" title="ast.NodeVisitor"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeVisitor</span></code></a> if you want to apply changes to nodes
during traversal.  For this a special visitor exists
(<a class="reference internal" href="#ast.NodeTransformer" title="ast.NodeTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeTransformer</span></code></a>) that allows modifications.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.8부터 폐지: </span>Methods <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Num()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Str()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Bytes()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_NameConstant()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Ellipsis()</span></code> are deprecated
now and will not be called in future Python versions.  Add the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">visit_Constant()</span></code> method to handle all constant nodes.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="ast.NodeTransformer">
<em class="property">class </em><code class="descclassname">ast.</code><code class="descname">NodeTransformer</code><a class="headerlink" href="#ast.NodeTransformer" title="정의 주소">¶</a></dt>
<dd><p>A <a class="reference internal" href="#ast.NodeVisitor" title="ast.NodeVisitor"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeVisitor</span></code></a> subclass that walks the abstract syntax tree and
allows modification of nodes.</p>
<p>The <a class="reference internal" href="#ast.NodeTransformer" title="ast.NodeTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeTransformer</span></code></a> will walk the AST and use the return value of
the visitor methods to replace or remove the old node.  If the return value
of the visitor method is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the node will be removed from its
location, otherwise it is replaced with the return value.  The return value
may be the original node in which case no replacement takes place.</p>
<p>Here is an example transformer that rewrites all occurrences of name lookups
(<code class="docutils literal notranslate"><span class="pre">foo</span></code>) to <code class="docutils literal notranslate"><span class="pre">data['foo']</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RewriteName</span><span class="p">(</span><span class="n">NodeTransformer</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">visit_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">copy_location</span><span class="p">(</span><span class="n">Subscript</span><span class="p">(</span>
            <span class="n">value</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span>
            <span class="nb">slice</span><span class="o">=</span><span class="n">Index</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">Constant</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)),</span>
            <span class="n">ctx</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span>
        <span class="p">),</span> <span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
<p>Keep in mind that if the node you're operating on has child nodes you must
either transform the child nodes yourself or call the <code class="xref py py-meth docutils literal notranslate"><span class="pre">generic_visit()</span></code>
method for the node first.</p>
<p>For nodes that were part of a collection of statements (that applies to all
statement nodes), the visitor may also return a list of nodes rather than
just a single node.</p>
<p>Usually you use the transformer like this:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">node</span> <span class="o">=</span> <span class="n">YourTransformer</span><span class="p">()</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="ast.dump">
<code class="descclassname">ast.</code><code class="descname">dump</code><span class="sig-paren">(</span><em>node</em>, <em>annotate_fields=True</em>, <em>include_attributes=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ast.dump" title="정의 주소">¶</a></dt>
<dd><p>Return a formatted dump of the tree in <em>node</em>.  This is mainly useful for
debugging purposes.  If <em>annotate_fields</em> is true (by default),
the returned string will show the names and the values for fields.
If <em>annotate_fields</em> is false, the result string will be more compact by
omitting unambiguous field names.  Attributes such as line
numbers and column offsets are not dumped by default.  If this is wanted,
<em>include_attributes</em> can be set to true.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference external" href="https://greentreesnakes.readthedocs.io/">Green Tree Snakes</a>, an external documentation resource, has good
details on working with Python ASTs.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code> --- 추상 구문 트리</a><ul>
<li><a class="reference internal" href="#node-classes">노드 클래스</a></li>
<li><a class="reference internal" href="#abstract-grammar">추상 문법</a></li>
<li><a class="reference internal" href="#ast-helpers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code> 도우미</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="parser.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code> --- Access Python parse trees</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="symtable.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symtable</span></code> --- 컴파일러 심볼 테이블 액세스</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="symtable.html" title="symtable --- 컴파일러 심볼 테이블 액세스"
             >다음</a> |</li>
        <li class="right" >
          <a href="parser.html" title="parser --- Access Python parse trees"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="language.html" >파이썬 언어 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>