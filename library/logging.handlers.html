
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>logging.handlers --- 로깅 처리기 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="getpass --- 이식성 있는 암호 입력" href="getpass.html" />
    <link rel="prev" title="logging.config --- 로깅 구성" href="logging.config.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/logging.handlers.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="getpass.html" title="getpass --- 이식성 있는 암호 입력"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="logging.config.html" title="logging.config --- 로깅 구성"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">일반 운영 체제 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-logging.handlers">
<span id="logging-handlers-logging-handlers"></span><h1><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> --- 로깅 처리기<a class="headerlink" href="#module-logging.handlers" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/logging/handlers.py">Lib/logging/handlers.py</a></p>
<div class="sidebar">
<p class="sidebar-title">Important</p>
<p>이 페이지에는 레퍼런스 정보만 있습니다. 자습서는 다음을 참조하십시오</p>
<ul class="simple">
<li><p><a class="reference internal" href="../howto/logging.html#logging-basic-tutorial"><span class="std std-ref">기초 자습서</span></a></p></li>
<li><p><a class="reference internal" href="../howto/logging.html#logging-advanced-tutorial"><span class="std std-ref">고급 자습서</span></a></p></li>
<li><p><a class="reference internal" href="../howto/logging-cookbook.html#logging-cookbook"><span class="std std-ref">로깅 요리책</span></a></p></li>
</ul>
</div>
<hr class="docutils" />
<p>다음과 같은 유용한 처리기가 패키지에서 제공됩니다. 3개의 처리기(<a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a>, <a class="reference internal" href="#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a>, <a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">NullHandler</span></code></a>)는 실제로는 <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 모듈 자체에 정의되어 있지만, 다른 처리기들과 함께 여기에서 설명합니다.</p>
<div class="section" id="streamhandler">
<span id="stream-handler"></span><h2>StreamHandler<a class="headerlink" href="#streamhandler" title="제목 주소">¶</a></h2>
<p>핵심 <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 패키지에 있는 <a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a> 클래스는 <em>sys.stdout</em>, <em>sys.stderr</em> 또는 임의의 파일류 객체(또는 더 정확하게, <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>와 <code class="xref py py-meth docutils literal notranslate"><span class="pre">flush()</span></code> 메서드를 지원하는 모든 객체)와 같은 스트림으로 로깅 출력을 보냅니다.</p>
<dl class="class">
<dt id="logging.StreamHandler">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">StreamHandler</code><span class="sig-paren">(</span><em>stream=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.StreamHandler" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a> 클래스의 새로운 인스턴스를 반환합니다. <em>stream</em> 이 지정되면, 인스턴스는 그것을 로그 출력용으로 사용합니다; 그렇지 않으면, <em>sys.stderr</em> 이 사용됩니다.</p>
<dl class="method">
<dt id="logging.StreamHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.StreamHandler.emit" title="정의 주소">¶</a></dt>
<dd><p>포매터가 지정되면, 레코드를 포맷하는 데 사용됩니다. 그런 다음 레코드는 종결자(terminator)와 함께 스트림에 기록됩니다. 예외 정보가 있으면, <a class="reference internal" href="traceback.html#traceback.print_exception" title="traceback.print_exception"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.print_exception()</span></code></a>을 사용하여 포맷한 후 스트림에 덧붙입니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.StreamHandler.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.StreamHandler.flush" title="정의 주소">¶</a></dt>
<dd><p>스트림의 <a class="reference internal" href="#logging.StreamHandler.flush" title="logging.StreamHandler.flush"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flush()</span></code></a> 메서드를 호출해서 플러시 합니다. <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> 메서드는 <a class="reference internal" href="logging.html#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> 에서 상속되고, 출력이 없으므로, 명시적 <a class="reference internal" href="#logging.StreamHandler.flush" title="logging.StreamHandler.flush"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flush()</span></code></a> 호출이 필요할 수도 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.StreamHandler.setStream">
<code class="descname">setStream</code><span class="sig-paren">(</span><em>stream</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.StreamHandler.setStream" title="정의 주소">¶</a></dt>
<dd><p>지정한 값이 현재 값과 다르면, 인스턴스의 스트림을 지정된 값으로 설정합니다. 새 스트림이 설정되기 전에 이전 스트림이 플러시 됩니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>stream</strong> -- 처리기가 사용할 스트림.</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>스트림이 변경되면 이전 스트림, 그렇지 않으면 <em>None</em>.</p>
</dd>
</dl>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><code class="docutils literal notranslate"><span class="pre">StreamHandler</span></code> 클래스는 이제 포맷된 레코드를 스트림에 쓸 때 종결자로 사용되는 <code class="docutils literal notranslate"><span class="pre">terminator</span></code> 어트리뷰트(기본 값 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>)를 갖습니다. 이 개행 문자 종료를 원하지 않는다면, 처리기 인스턴스의 <code class="docutils literal notranslate"><span class="pre">terminator</span></code> 어트리뷰트를 빈 문자열로 설정할 수 있습니다. 이전 버전에서는, 종결자가 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 로 하드 코딩되었습니다.</p>
</div>
</div>
<div class="section" id="filehandler">
<span id="file-handler"></span><h2>FileHandler<a class="headerlink" href="#filehandler" title="제목 주소">¶</a></h2>
<p>핵심 <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 패키지에 있는 <a class="reference internal" href="#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a> 클래스는 로깅 출력을 디스크 파일로 보냅니다. <a class="reference internal" href="#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a> 에서 출력 기능을 상속받습니다.</p>
<dl class="class">
<dt id="logging.FileHandler">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">FileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='a'</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.FileHandler" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a> 클래스의 새로운 인스턴스를 반환합니다. 지정된 파일이 열리고 로깅을 위한 스트림으로 사용됩니다. <em>mode</em> 가 지정되지 않으면, <code class="xref py py-const docutils literal notranslate"><span class="pre">'a'</span></code> 가 사용됩니다. <em>encoding</em> 이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아니면, <em>encoding</em>을 사용하여 파일을 엽니다. <em>delay</em> 가 참이면, 파일 열기는 <a class="reference internal" href="#logging.FileHandler.emit" title="logging.FileHandler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a>의 첫 번째 호출이 있을 때까지 연기됩니다. 기본적으로, 파일은 제한 없이 커집니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>문자열 값뿐만 아니라, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> 객체도 <em>filename</em> 인자로 허용됩니다.</p>
</div>
<dl class="method">
<dt id="logging.FileHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.FileHandler.close" title="정의 주소">¶</a></dt>
<dd><p>파일을 닫습니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.FileHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.FileHandler.emit" title="정의 주소">¶</a></dt>
<dd><p>레코드를 파일에 출력합니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nullhandler">
<span id="null-handler"></span><h2>NullHandler<a class="headerlink" href="#nullhandler" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.1에 추가.</span></p>
</div>
<p>핵심 <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 패키지에 있는 <a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">NullHandler</span></code></a> 클래스는 포맷이나 출력을 일절 하지 않습니다. 기본적으로 라이브러리 개발자가 사용하는 'no-op' 처리기입니다.</p>
<dl class="class">
<dt id="logging.NullHandler">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">NullHandler</code><a class="headerlink" href="#logging.NullHandler" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">NullHandler</span></code></a> 클래스의 새로운 인스턴스를 반환합니다.</p>
<dl class="method">
<dt id="logging.NullHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.NullHandler.emit" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 아무것도 하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.NullHandler.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.NullHandler.handle" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 아무것도 하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.NullHandler.createLock">
<code class="descname">createLock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.NullHandler.createLock" title="정의 주소">¶</a></dt>
<dd><p>액세스를 직렬화해야 하는 하부 I/O가 없으므로, 이 메서드는 록으로 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 반환합니다.</p>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="#logging.NullHandler" title="logging.NullHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">NullHandler</span></code></a> 사용법에 대한 더 많은 정보는 <a class="reference internal" href="../howto/logging.html#library-config"><span class="std std-ref">라이브러리 로깅 구성</span></a>를 참조하세요.</p>
</div>
<div class="section" id="watchedfilehandler">
<span id="watched-file-handler"></span><h2>WatchedFileHandler<a class="headerlink" href="#watchedfilehandler" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 모듈에 있는 <a class="reference internal" href="#logging.handlers.WatchedFileHandler" title="logging.handlers.WatchedFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">WatchedFileHandler</span></code></a> 클래스는 로깅 중인 파일을 감시하는 <code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code> 입니다. 파일이 변경되면, 닫은 후에 같은 이름의 파일을 다시 엽니다.</p>
<p>로그 파일 회전을 수행하는 <em>newsyslog</em> 나 <em>logrotate</em> 와 같은 프로그램의 사용으로 인해 파일이 변경될 수 있습니다. 유닉스/리눅스에서 사용하기 위한 이 처리기는 마지막 출력 이후에 파일이 변경되었는지 감시합니다. (파일의 장치나 inode가 변경되면 파일이 변경된 것으로 간주합니다.) 파일이 변경되면, 이전 파일 스트림이 닫히고, 새 스트림을 얻기 위해 파일을 엽니다.</p>
<p>이 처리기는 윈도우에서 사용하기에 적합하지 않습니다. 윈도우에서는 열린 로그 파일을 이동하거나 이름을 변경할 수 없어서 - logging은 파일을 배타적 록으로 엽니다 - 이런 처리기가 필요하지 않기 때문입니다. 또한 <em>ST_INO</em> 는 윈도우에서 지원되지 않습니다; <a class="reference internal" href="os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">stat()</span></code></a>는 항상 이 값에 대해 0을 반환합니다.</p>
<dl class="class">
<dt id="logging.handlers.WatchedFileHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">WatchedFileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='a'</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.WatchedFileHandler" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.WatchedFileHandler" title="logging.handlers.WatchedFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">WatchedFileHandler</span></code></a> 클래스의 새 인스턴스를 반환합니다. 지정된 파일이 열리고 로깅을 위한 스트림으로 사용됩니다. <em>mode</em> 가 지정되지 않으면, <code class="xref py py-const docutils literal notranslate"><span class="pre">'a'</span></code> 가 사용됩니다. <em>encoding</em> 이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아니면, <em>encoding</em>을 사용하여 파일을 엽니다. <em>delay</em> 가 참이면, 파일 열기는 <a class="reference internal" href="#logging.handlers.WatchedFileHandler.emit" title="logging.handlers.WatchedFileHandler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a>의 첫 번째 호출이 있을 때까지 연기됩니다. 기본적으로, 파일은 제한 없이 커집니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>문자열 값뿐만 아니라, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> 객체도 <em>filename</em> 인자로 허용됩니다.</p>
</div>
<dl class="method">
<dt id="logging.handlers.WatchedFileHandler.reopenIfNeeded">
<code class="descname">reopenIfNeeded</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.WatchedFileHandler.reopenIfNeeded" title="정의 주소">¶</a></dt>
<dd><p>파일이 변경되었는지 확인합니다. 그렇다면, 기존 스트림을 플러시 한 후 닫고, 파일을 다시 엽니다. 일반적으로 레코드를 파일로 출력하기 전에 수행합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.WatchedFileHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.WatchedFileHandler.emit" title="정의 주소">¶</a></dt>
<dd><p>레코드를 파일에 출력하지만, 파일이 변경되었을 때 다시 열기 위해 <a class="reference internal" href="#logging.handlers.WatchedFileHandler.reopenIfNeeded" title="logging.handlers.WatchedFileHandler.reopenIfNeeded"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reopenIfNeeded()</span></code></a>를 먼저 호출합니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="baserotatinghandler">
<span id="base-rotating-handler"></span><h2>BaseRotatingHandler<a class="headerlink" href="#baserotatinghandler" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 모듈에 있는 <a class="reference internal" href="#logging.handlers.BaseRotatingHandler" title="logging.handlers.BaseRotatingHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseRotatingHandler</span></code></a> 클래스는 회전하는 파일 처리기들(<a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatingFileHandler</span></code></a>와 <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimedRotatingFileHandler</span></code></a>)의 베이스 클래스입니다. 이 클래스의 인스턴스를 만들 필요는 없지만, 재정의가 필요할 수 있는 어트리뷰트와 메서드가 있습니다.</p>
<dl class="class">
<dt id="logging.handlers.BaseRotatingHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">BaseRotatingHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BaseRotatingHandler" title="정의 주소">¶</a></dt>
<dd><p>매개 변수는 <code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code> 와 같습니다. 어트리뷰트는 다음과 같습니다:</p>
<dl class="attribute">
<dt id="logging.handlers.BaseRotatingHandler.namer">
<code class="descname">namer</code><a class="headerlink" href="#logging.handlers.BaseRotatingHandler.namer" title="정의 주소">¶</a></dt>
<dd><p>이 어트리뷰트가 콜러블로 설정되면, <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotation_filename" title="logging.handlers.BaseRotatingHandler.rotation_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotation_filename()</span></code></a> 메서드는 이 콜러블에 위임합니다. 콜러블로 전달되는 매개 변수는 <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotation_filename" title="logging.handlers.BaseRotatingHandler.rotation_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotation_filename()</span></code></a>로 전달되는 것입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>namer 함수는 롤오버 중에 꽤 자주 호출되므로, 가능한 한 간단하고 빨라야 합니다. 또한, 주어진 입력에 대해 매번 같은 출력을 반환해야 합니다, 그렇지 않으면 롤오버 동작이 예상대로 작동하지 않을 수 있습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="logging.handlers.BaseRotatingHandler.rotator">
<code class="descname">rotator</code><a class="headerlink" href="#logging.handlers.BaseRotatingHandler.rotator" title="정의 주소">¶</a></dt>
<dd><p>이 어트리뷰트가 콜러블로 설정되면, <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotate" title="logging.handlers.BaseRotatingHandler.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate()</span></code></a> 메서드는 이 콜러블에 위임합니다. 콜러블로 전달되는 매개 변수는 <a class="reference internal" href="#logging.handlers.BaseRotatingHandler.rotate" title="logging.handlers.BaseRotatingHandler.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate()</span></code></a>로 전달되는 것입니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.BaseRotatingHandler.rotation_filename">
<code class="descname">rotation_filename</code><span class="sig-paren">(</span><em>default_name</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BaseRotatingHandler.rotation_filename" title="정의 주소">¶</a></dt>
<dd><p>회전할 때 로그 파일의 파일명을 수정합니다.</p>
<p>사용자 정의 파일명을 제공할 수 있게 하려고 제공됩니다.</p>
<p>기본 구현은 처리기의 'namer' 어트리뷰트를(콜러블이라면) 호출하는데, 기본 이름을 전달합니다. 어트리뷰트가 콜러블이 아니면 (기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다), 이름은 변경되지 않고 반환됩니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>default_name</strong> -- 로그 파일의 기본 이름.</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.BaseRotatingHandler.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>source</em>, <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BaseRotatingHandler.rotate" title="정의 주소">¶</a></dt>
<dd><p>회전할 때, 현재 로그를 회전합니다.</p>
<p>기본 구현은 처리기의 'rotator' 어트리뷰트를(콜러블이라면) 호출하는데, source와 dest 인자를 전달합니다. 어트리뷰트가 콜러블이 아니면 (기본값은 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다), source를 dest 로 단순히 이름을 바꿉니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source</strong> -- 소스 파일명. 이것은 일반적으로 기본 파일명입니다, 예를 들어 'test.log'.</p></li>
<li><p><strong>dest</strong> -- 대상 파일명. 이것은 일반적으로 소스가 회전되는 곳입니다, 예를 들어 'test.log.1'.</p></li>
</ul>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<p>어트리뷰트가 존재하는 이유는 서브 클래싱해야 할 필요를 줄이는 것입니다 - <a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatingFileHandler</span></code></a>와 <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimedRotatingFileHandler</span></code></a> 의 인스턴스에 같은 콜러블을 사용할 수 있습니다. namer 나 rotator 콜러블이 예외를 발생시키면, <code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code> 동안 발생하는 다른 예외와 같은 방식으로 처리됩니다, 즉 처리기의 <code class="xref py py-meth docutils literal notranslate"><span class="pre">handleError()</span></code> 메서드를 통해.</p>
<p>회전 처리를 더 크게 변경해야 하면, 메서드를 재정의할 수 있습니다.</p>
<p>예는 <a class="reference internal" href="../howto/logging-cookbook.html#cookbook-rotator-namer"><span class="std std-ref">rotator와 namer를 사용해서 로그 회전 처리하기</span></a>를 보십시오.</p>
</div>
<div class="section" id="rotatingfilehandler">
<span id="rotating-file-handler"></span><h2>RotatingFileHandler<a class="headerlink" href="#rotatingfilehandler" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 모듈에 있는 <a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatingFileHandler</span></code></a> 클래스는 디스크 로그 파일 회전을 지원합니다.</p>
<dl class="class">
<dt id="logging.handlers.RotatingFileHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">RotatingFileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='a'</em>, <em>maxBytes=0</em>, <em>backupCount=0</em>, <em>encoding=None</em>, <em>delay=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.RotatingFileHandler" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.RotatingFileHandler" title="logging.handlers.RotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatingFileHandler</span></code></a> 클래스의 새로운 인스턴스를 반환합니다. 지정된 파일이 열리고 로깅을 위한 스트림으로 사용됩니다. <em>mode</em> 가 지정되지 않으면, <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 가 사용됩니다. <em>encoding</em> 이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아니면, <em>encoding</em>을 사용하여 파일을 엽니다. <em>delay</em> 가 참이면, 파일 열기는 <a class="reference internal" href="#logging.handlers.RotatingFileHandler.emit" title="logging.handlers.RotatingFileHandler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a>의 첫 번째 호출이 있을 때까지 연기됩니다. 기본적으로, 파일은 제한 없이 커집니다.</p>
<p>미리 결정된 크기에서 파일을 <em class="dfn">롤오버 (rollover)</em> 하기 위해 <em>maxBytes</em> 와 <em>backupCount</em> 값을 사용할 수 있습니다. 크기가 초과하려고 할 때, 파일이 닫히고 출력을 위해 새 파일이 조용히 열립니다. 롤오버는 현재 로그 파일이 거의 <em>maxBytes</em> 길이일 때마다 발생합니다; 그러나 <em>maxBytes</em> 나 <em>backupCount</em> 가 0이면 롤오버가 발생하지 않으므로, 일반적으로 <em>backupCount</em> 를 1 이상으로 설정하고, 0이 아닌 <em>maxBytes</em>를 사용하기를 원할 겁니다. <em>backupCount</em> 가 0이 아니면, 시스템은 파일명에 확장자 '.1', '.2' 등을 추가하여 지난 로그 파일을 저장합니다. 예를 들어, <em>backupCount</em> 가 5이고 기본 파일명이 <code class="file docutils literal notranslate"><span class="pre">app.log</span></code> 면, <code class="file docutils literal notranslate"><span class="pre">app.log</span></code>, <code class="file docutils literal notranslate"><span class="pre">app.log.1</span></code>, <code class="file docutils literal notranslate"><span class="pre">app.log.2</span></code>부터 <code class="file docutils literal notranslate"><span class="pre">app.log.5</span></code> 까지의 파일을 얻게 됩니다. 기록되는 파일은 항상 <code class="file docutils literal notranslate"><span class="pre">app.log</span></code> 입니다. 이 파일이 채워지면, 닫히고 <code class="file docutils literal notranslate"><span class="pre">app.log.1</span></code> 로 이름이 변경됩니다, 그리고 파일 <code class="file docutils literal notranslate"><span class="pre">app.log.1</span></code>, <code class="file docutils literal notranslate"><span class="pre">app.log.2</span></code> 등이 존재하면, 이것들도 각기 <code class="file docutils literal notranslate"><span class="pre">app.log.2</span></code>, <code class="file docutils literal notranslate"><span class="pre">app.log.3</span></code> 등으로 이름이 변경됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>문자열 값뿐만 아니라, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> 객체도 <em>filename</em> 인자로 허용됩니다.</p>
</div>
<dl class="method">
<dt id="logging.handlers.RotatingFileHandler.doRollover">
<code class="descname">doRollover</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.RotatingFileHandler.doRollover" title="정의 주소">¶</a></dt>
<dd><p>위에서 설명한 대로 롤오버를 수행합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.RotatingFileHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.RotatingFileHandler.emit" title="정의 주소">¶</a></dt>
<dd><p>앞에서 설명한 대로 롤오버를 처리하면서, 파일에 레코드를 출력합니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="timedrotatingfilehandler">
<span id="timed-rotating-file-handler"></span><h2>TimedRotatingFileHandler<a class="headerlink" href="#timedrotatingfilehandler" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 모듈에 있는 <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimedRotatingFileHandler</span></code></a> 클래스는 특정 시간 간격의 디스크 로그 파일 회전을 지원합니다.</p>
<dl class="class">
<dt id="logging.handlers.TimedRotatingFileHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">TimedRotatingFileHandler</code><span class="sig-paren">(</span><em>filename</em>, <em>when='h'</em>, <em>interval=1</em>, <em>backupCount=0</em>, <em>encoding=None</em>, <em>delay=False</em>, <em>utc=False</em>, <em>atTime=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.TimedRotatingFileHandler" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimedRotatingFileHandler</span></code></a> 클래스의 새로운 인스턴스를 반환합니다. 지정된 파일이 열리고 로깅을 위한 스트림으로 사용됩니다. 회전 시 파일명 접미사도 설정합니다. <em>when</em> 과 <em>interval</em> 에 따라 회전이 일어납니다.</p>
<p><em>when</em> 을 사용하여 <em>interval</em> 의 유형을 지정할 수 있습니다. 가능한 값의 목록은 아래와 같습니다. 대소 문자를 구분하지 않는다는 것에 유의하세요.</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 23%" />
<col style="width: 41%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>값</p></th>
<th class="head"><p>interval의 유형</p></th>
<th class="head"><p><em>atTime</em> 이 사용되는지와 사용되는 방식</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'S'</span></code></p></td>
<td><p>초</p></td>
<td><p>무시됩니다</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'M'</span></code></p></td>
<td><p>분</p></td>
<td><p>무시됩니다</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'H'</span></code></p></td>
<td><p>시간</p></td>
<td><p>무시됩니다</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'D'</span></code></p></td>
<td><p>일</p></td>
<td><p>무시됩니다</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'W0'-'W6'</span></code></p></td>
<td><p>요일 (0=월요일)</p></td>
<td><p>최초 롤오버 시간을 계산하는 데 사용됩니다</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'midnight'</span></code></p></td>
<td><p><em>atTime</em> 을 지정하지 않으면 자정에, 그렇지 않으면 <em>atTime</em> 에 롤오버 합니다</p></td>
<td><p>최초 롤오버 시간을 계산하는 데 사용됩니다</p></td>
</tr>
</tbody>
</table>
<p>요일 기반 회전을 사용할 때, 월요일은 'W0', 화요일은 'W1', 등등 일요일은 'W6'까지 지정하십시오. 이 경우, <em>interval</em> 에 전달된 값은 사용되지 않습니다.</p>
<p>시스템은 파일명에 확장자를 추가하여 지난 로그 파일을 저장합니다. 확장자는 날짜와 시간 기반이며, 롤오버 간격에 따라 strftime 형식 <code class="docutils literal notranslate"><span class="pre">%Y-%m-%d_%H-%M-%S</span></code> 이나 그 앞부분을 사용합니다.</p>
<p>다음 롤오버 시간을 처음 계산할 때 (처리기가 만들어질 때), 기존 로그 파일의 마지막 수정 시간 또는 (없으면) 현재 시각이 다음 회전이 발생할 때를 계산하는 데 사용됩니다.</p>
<p><em>utc</em> 인자가 참이면, UTC 시간이 사용됩니다; 그렇지 않으면 현지 시간이 사용됩니다.</p>
<p><em>backupCount</em> 가 0이 아니면, 최대 <em>backupCount</em> 개의 파일이 보관되고, 롤오버가 발생할 때 더 많은 파일이 생성되면 가장 오래된 파일이 삭제됩니다. 삭제 논리는 interval을 사용하여 삭제할 파일을 결정하므로, interval을 변경하면 오래된 파일이 남아있을 수 있습니다.</p>
<p><em>delay</em> 가 참이면, 파일 열기는 <a class="reference internal" href="#logging.handlers.TimedRotatingFileHandler.emit" title="logging.handlers.TimedRotatingFileHandler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a>에 대한 첫 번째 호출까지 지연됩니다.</p>
<p><em>atTime</em> 이 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아니면, 반드시 <code class="docutils literal notranslate"><span class="pre">datetime.time</span></code> 인스턴스여야 하는데, 롤오버가 &quot;자정에&quot; 또는 &quot;특정 요일에&quot; 발생하도록 설정된 경우에 롤오버가 발생하는 시간을 지정합니다. 이 경우, <em>atTime</em> 값은 <em>최초</em> 롤오버를 계산하는 데 사용되며, 이후 롤오버는 일반적인 간격 계산을 통해 계산됩니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>최초 롤오버 시간의 계산은 처리기가 초기화될 때 수행됩니다. 후속 롤오버 시간 계산은 롤오버가 발생하는 경우에만 수행되며, 롤오버는 출력을 내보낼 때만 발생합니다. 이것을 명심하지 않으면, 혼란이 생길 수 있습니다. 예를 들어, &quot;매분&quot; 간격을 설정하면, 이것이 항상 1분 간격의 (파일명을 갖는) 로그 파일들을 보게 된다는 것을 뜻하지는 않습니다; 응용 프로그램을 실행하는 동안, 로그 출력이 1분당 한 번보다 더 자주 <em>발생하면</em>, 1분 간격의 로그 파일을 볼 것으로 예상할 수 있습니다. 반면, (가령) 로깅 메시지가 5분마다 한 번만 출력되면, 출력이 없는 (따라서 롤오버가 없는) 분에 해당하는 파일 시간의 틈이 생깁니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><em>atTime</em> 매개 변수가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>문자열 값뿐만 아니라, <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> 객체도 <em>filename</em> 인자로 허용됩니다.</p>
</div>
<dl class="method">
<dt id="logging.handlers.TimedRotatingFileHandler.doRollover">
<code class="descname">doRollover</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.TimedRotatingFileHandler.doRollover" title="정의 주소">¶</a></dt>
<dd><p>위에서 설명한 대로 롤오버를 수행합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.TimedRotatingFileHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.TimedRotatingFileHandler.emit" title="정의 주소">¶</a></dt>
<dd><p>위에서 설명한 대로 롤오버를 처리하면서, 파일에 레코드를 출력합니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sockethandler">
<span id="socket-handler"></span><h2>SocketHandler<a class="headerlink" href="#sockethandler" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 모듈에 있는 <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketHandler</span></code></a> 클래스는 로깅 출력을 네트워크 소켓에 보냅니다. 베이스 클래스는 TCP 소켓을 사용합니다.</p>
<dl class="class">
<dt id="logging.handlers.SocketHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">SocketHandler</code><span class="sig-paren">(</span><em>host</em>, <em>port</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler" title="정의 주소">¶</a></dt>
<dd><p><em>host</em> 와 <em>port</em>로 주어진 주소의 원격 기계와 통신하기 위한, <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketHandler</span></code></a> 클래스의 새로운 인스턴스를 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">port</span></code>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 지정되면, <code class="docutils literal notranslate"><span class="pre">host</span></code>의 값을 사용하여 유닉스 도메인 소켓이 만들어집니다 - 그렇지 않으면 TCP 소켓이 만들어집니다.</p>
</div>
<dl class="method">
<dt id="logging.handlers.SocketHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.close" title="정의 주소">¶</a></dt>
<dd><p>소켓을 닫습니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.emit" title="정의 주소">¶</a></dt>
<dd><p>레코드의 어트리뷰트 딕셔너리를 피클하고 바이너리 형식으로 소켓에 씁니다. 소켓에 에러가 있으면 조용히 패킷을 버립니다. 이전에 연결이 끊어졌으면, 연결을 다시 맺습니다. 수신 단에서 레코드를 <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>로 역 피클 하려면, <a class="reference internal" href="logging.html#logging.makeLogRecord" title="logging.makeLogRecord"><code class="xref py py-func docutils literal notranslate"><span class="pre">makeLogRecord()</span></code></a> 함수를 사용하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.handleError">
<code class="descname">handleError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.handleError" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.SocketHandler.emit" title="logging.handlers.SocketHandler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a> 중에 발생한 에러를 처리합니다. 가장 큰 원인은 연결이 끊어지는 것입니다. 다음 이벤트에서 다시 시도할 수 있도록 소켓을 닫습니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.makeSocket">
<code class="descname">makeSocket</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.makeSocket" title="정의 주소">¶</a></dt>
<dd><p>이것은 서브 클래스가 원하는 소켓의 정확한 유형을 정의 할 수 있게 하는 팩토리 메서드입니다. 기본 구현은 TCP 소켓(<a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code></a>)을 만듭니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.makePickle">
<code class="descname">makePickle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.makePickle" title="정의 주소">¶</a></dt>
<dd><p>레코드의 어트리뷰트 딕셔너리를 바이너리 형식으로 피클하고 길이를 앞에 붙여서, 소켓을 통해 전송할 준비가 된 상태로 반환합니다. 이 연산의 세부 사항은 다음과 동등합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record_attr_dict</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">datalen</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&gt;L&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="k">return</span> <span class="n">datalen</span> <span class="o">+</span> <span class="n">data</span>
</pre></div>
</div>
<p>피클은 완전히 안전하지 않습니다. 보안이 염려되면, 이 메서드를 재정의하여 더욱 안전한 메커니즘을 구현할 수 있습니다. 예를 들어, HMAC를 사용하여 피클에 서명한 다음 수신 단에서 확인하거나, 수신 단에서 전역 객체의 역 피클링을 비활성화할 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.send">
<code class="descname">send</code><span class="sig-paren">(</span><em>packet</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.send" title="정의 주소">¶</a></dt>
<dd><p>피클 된 바이트열 <em>packet</em> 을 소켓으로 보냅니다. 보내진 바이트열의 형식은 <a class="reference internal" href="#logging.handlers.SocketHandler.makePickle" title="logging.handlers.SocketHandler.makePickle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makePickle()</span></code></a>의 설명서에 있습니다.</p>
<p>이 함수는 네트워크가 붐빌 때 발생할 수 있는 부분 전송을 허용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SocketHandler.createSocket">
<code class="descname">createSocket</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.createSocket" title="정의 주소">¶</a></dt>
<dd><p>소켓을 만들려고 합니다; 실패 시, 지수 백 오프 알고리즘을 사용합니다. 최초 실패 시 처리기는 보내려는 메시지를 버립니다. 후속 메시지가 같은 인스턴스에 의해 처리될 때, 일정한 시간이 지날 때까지 연결을 시도하지 않습니다. 기본 파라미터를 쓸 때, 최초 지연은 1초이고, 지연 후에도 연결을 만들 수 없으면, 처리기가 최대 30초가 될 때까지 매번 지연 시간을 두 배로 늘립니다.</p>
<p>이 동작은 다음 처리기 어트리뷰트에 의해 제어됩니다:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">retryStart</span></code> (최초 지연, 기본값은 1.0 초).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">retryFactor</span></code> (배율, 기본값은 2.0).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">retryMax</span></code> (최대 지연, 기본값은 30.0 초).</p></li>
</ul>
<p>이것은, 처리기가 사용된 <em>후에</em> 원격 수신기가 시작되면, 메시지가 손실될 수 있음을 뜻합니다 (처리기가 지연이 경과 할 때까지 연결을 시도하지조차 않고, 지연 기간에 메시지를 조용히 버리기 때문입니다).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="datagramhandler">
<span id="datagram-handler"></span><h2>DatagramHandler<a class="headerlink" href="#datagramhandler" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 모듈에 있는 <a class="reference internal" href="#logging.handlers.DatagramHandler" title="logging.handlers.DatagramHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">DatagramHandler</span></code></a> 클래스는 UDP 소켓을 통해 로깅 메시지를 보낼 수 있도록 <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketHandler</span></code></a>를 상속합니다.</p>
<dl class="class">
<dt id="logging.handlers.DatagramHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">DatagramHandler</code><span class="sig-paren">(</span><em>host</em>, <em>port</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.DatagramHandler" title="정의 주소">¶</a></dt>
<dd><p><em>host</em> 와 <em>port</em>로 주어진 주소의 원격 기계와 통신하기 위한, <a class="reference internal" href="#logging.handlers.DatagramHandler" title="logging.handlers.DatagramHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">DatagramHandler</span></code></a> 클래스의 새로운 인스턴스를 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">port</span></code>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 지정되면, <code class="docutils literal notranslate"><span class="pre">host</span></code>의 값을 사용하여 유닉스 도메인 소켓이 만들어집니다 - 그렇지 않으면 UDP 소켓이 만들어집니다.</p>
</div>
<dl class="method">
<dt id="logging.handlers.DatagramHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.DatagramHandler.emit" title="정의 주소">¶</a></dt>
<dd><p>레코드의 어트리뷰트 딕셔너리를 피클하고 바이너리 형식으로 소켓에 씁니다. 소켓에 에러가 있으면 조용히 패킷을 버립니다. 수신 단에서 레코드를 <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>로 역 피클 하려면, <a class="reference internal" href="logging.html#logging.makeLogRecord" title="logging.makeLogRecord"><code class="xref py py-func docutils literal notranslate"><span class="pre">makeLogRecord()</span></code></a> 함수를 사용하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.DatagramHandler.makeSocket">
<code class="descname">makeSocket</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.DatagramHandler.makeSocket" title="정의 주소">¶</a></dt>
<dd><p>UDP 소켓(<a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_DGRAM</span></code></a>)을 만들기 위해 <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketHandler</span></code></a>의 팩토리 메서드가 여기에서 재정의되었습니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.DatagramHandler.send">
<code class="descname">send</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.DatagramHandler.send" title="정의 주소">¶</a></dt>
<dd><p>피클 된 바이트열을 소켓으로 보냅니다. 보낸 바이트열의 형식은 <a class="reference internal" href="#logging.handlers.SocketHandler.makePickle" title="logging.handlers.SocketHandler.makePickle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SocketHandler.makePickle()</span></code></a> 설명서에 있습니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sysloghandler">
<span id="syslog-handler"></span><h2>SysLogHandler<a class="headerlink" href="#sysloghandler" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 모듈에 있는 <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SysLogHandler</span></code></a> 클래스는 원격 또는 로컬 유닉스 syslog로 로깅 메시지를 보내는 것을 지원합니다.</p>
<dl class="class">
<dt id="logging.handlers.SysLogHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">SysLogHandler</code><span class="sig-paren">(</span><em>address=('localhost'</em>, <em>SYSLOG_UDP_PORT)</em>, <em>facility=LOG_USER</em>, <em>socktype=socket.SOCK_DGRAM</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code> 튜플 형태의 <em>address</em>로 주어진 주소의 원격 유닉스 기계와 통신하기 위한 <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SysLogHandler</span></code></a> 클래스의 새 인스턴스를 돌려줍니다. <em>address</em> 를 지정하지 않으면 <code class="docutils literal notranslate"><span class="pre">('localhost',</span> <span class="pre">514)</span></code>가 사용됩니다. 주소는 소켓을 여는 데 사용됩니다. <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code> 튜플을 제공하는 대신, 주소를 문자열로 제공할 수 있습니다, 예를 들어 '/dev/log'. 이 경우, 메시지를 syslog로 보내는데 유닉스 도메인 소켓이 사용됩니다. <em>facility</em> 가 지정되지 않으면, <code class="xref py py-const docutils literal notranslate"><span class="pre">LOG_USER</span></code>가 사용됩니다. 열리는 소켓의 유형은 <em>socktype</em> 인자에 따라 달라지며, 기본값은 <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_DGRAM</span></code></a>이고, 따라서 UDP 소켓이 열립니다. TCP 소켓을 열려면 (rsyslog와 같은 최신 syslog 데몬을 사용할 때), <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code></a> 값을 지정하십시오.</p>
<p>서버가 UDP 포트 514에서 수신을 기다리지 않으면, <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SysLogHandler</span></code></a>가 작동하지 않는 것처럼 보일 수 있습니다. 이 경우, 도메인 소켓에 대해 사용해야 하는 주소를 확인하십시오 - 이는 시스템에 따라 다릅니다. 예를 들어 리눅스에서는 보통 '/dev/log' 이지만 OS/X에서는 '/var/run/syslog' 입니다. 플랫폼을 확인하고 적절한 주소를 사용해야 합니다 (응용 프로그램을 여러 플랫폼에서 실행해야 하는 경우 실행 시간에 검사를 수행해야 할 수도 있습니다). 윈도우에서는, UDP 옵션을 사용해야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>socktype</em> 이 추가되었습니다.</p>
</div>
<dl class="method">
<dt id="logging.handlers.SysLogHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler.close" title="정의 주소">¶</a></dt>
<dd><p>원격 호스트로의 소켓을 닫습니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SysLogHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler.emit" title="정의 주소">¶</a></dt>
<dd><p>레코드가 포맷된 다음, syslog 서버로 전송됩니다. 예외 정보가 있으면, 서버로 보내 지지 <em>않습니다</em>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2.1에서 변경: </span>(<a class="reference external" href="https://bugs.python.org/issue12168">bpo-12168</a>를 보세요.) 이전 버전에서, syslog 데몬으로 보낸 메시지는 NUL 바이트로 항상 종료되었는데, 이전 버전의 데몬에서 관련 사양(<span class="target" id="index-2"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5424.html"><strong>RFC 5424</strong></a>)에 없는데도 불구하고 NUL 종료 메시지를 요구했기 때문입니다. 최신 버전의 데몬은 NUL 바이트를 기대하지는 않지만, 있는 경우 이를 제거하고, 더 최근의 (RFC 5424와 더 가깝게 일치하는) 데몬은 NUL 바이트를 메시지 일부로 전달합니다.</p>
<p>이러한 모든 다른 데몬 동작에 직면하여 syslog 메시지를 더욱 쉽게 처리할 수 있도록, NUL 바이트를 추가하는 작업은 클래스 수준 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">append_nul</span></code>을 사용하여 구성할 수 있게 만들었습니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">True</span></code>(기존 동작 유지)이지만, 특정 인스턴스가 NUL 종결자를 추가하지 <em>않도록</em> <code class="docutils literal notranslate"><span class="pre">SysLogHandler</span></code> 인스턴스에서 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 설정할 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>(<a class="reference external" href="https://bugs.python.org/issue12419">bpo-12419</a>를 보세요.) 이전 버전에서는, 메시지 소스를 식별하는 &quot;ident&quot; 나 &quot;tag&quot; 접두사를 위한 기능이 없었습니다. 이제는 클래스 수준의 어트리뷰트를 사용하여 지정할 수 있습니다, <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>을 기본값으로 사용하여 기존 동작을 유지하지만, <code class="docutils literal notranslate"><span class="pre">SysLogHandler</span></code> 인스턴스에서 재정의하여 해당 인스턴스가 처리하는 모든 메시지에 ident를 추가하도록 할 수 있습니다. 제공된 ident는 바이트열이 아닌 텍스트여야 하며 그대로 메시지 앞에 추가됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SysLogHandler.encodePriority">
<code class="descname">encodePriority</code><span class="sig-paren">(</span><em>facility</em>, <em>priority</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler.encodePriority" title="정의 주소">¶</a></dt>
<dd><p>시설(facility)과 우선순위를 정수로 인코딩합니다. 문자열이나 정수를 전달할 수 있습니다 - 문자열이 전달되면, 내부 매핑 딕셔너리를 사용하여 정수로 변환합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">LOG_</span></code> 기호 값은 <a class="reference internal" href="#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SysLogHandler</span></code></a>에 정의되고 <code class="docutils literal notranslate"><span class="pre">sys/syslog.h</span></code> 헤더 파일에 정의된 값을 그대로 옮깁니다.</p>
<p><strong>우선순위</strong></p>
<table class="docutils align-center">
<colgroup>
<col style="width: 63%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>이름 (문자열)</p></th>
<th class="head"><p>기호 값</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">alert</span></code></p></td>
<td><p>LOG_ALERT</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">crit</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">critical</span></code></p></td>
<td><p>LOG_CRIT</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">debug</span></code></p></td>
<td><p>LOG_DEBUG</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">emerg</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">panic</span></code></p></td>
<td><p>LOG_EMERG</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">err</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">error</span></code></p></td>
<td><p>LOG_ERR</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">info</span></code></p></td>
<td><p>LOG_INFO</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">notice</span></code></p></td>
<td><p>LOG_NOTICE</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">warn</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">warning</span></code></p></td>
<td><p>LOG_WARNING</p></td>
</tr>
</tbody>
</table>
<p><strong>시설</strong></p>
<table class="docutils align-center">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>이름 (문자열)</p></th>
<th class="head"><p>기호 값</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">auth</span></code></p></td>
<td><p>LOG_AUTH</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">authpriv</span></code></p></td>
<td><p>LOG_AUTHPRIV</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cron</span></code></p></td>
<td><p>LOG_CRON</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">daemon</span></code></p></td>
<td><p>LOG_DAEMON</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ftp</span></code></p></td>
<td><p>LOG_FTP</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">kern</span></code></p></td>
<td><p>LOG_KERN</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lpr</span></code></p></td>
<td><p>LOG_LPR</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mail</span></code></p></td>
<td><p>LOG_MAIL</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">news</span></code></p></td>
<td><p>LOG_NEWS</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">syslog</span></code></p></td>
<td><p>LOG_SYSLOG</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">user</span></code></p></td>
<td><p>LOG_USER</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">uucp</span></code></p></td>
<td><p>LOG_UUCP</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">local0</span></code></p></td>
<td><p>LOG_LOCAL0</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">local1</span></code></p></td>
<td><p>LOG_LOCAL1</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">local2</span></code></p></td>
<td><p>LOG_LOCAL2</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">local3</span></code></p></td>
<td><p>LOG_LOCAL3</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">local4</span></code></p></td>
<td><p>LOG_LOCAL4</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">local5</span></code></p></td>
<td><p>LOG_LOCAL5</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">local6</span></code></p></td>
<td><p>LOG_LOCAL6</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">local7</span></code></p></td>
<td><p>LOG_LOCAL7</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SysLogHandler.mapPriority">
<code class="descname">mapPriority</code><span class="sig-paren">(</span><em>levelname</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SysLogHandler.mapPriority" title="정의 주소">¶</a></dt>
<dd><p>로깅 수준 이름을 syslog 우선순위 이름으로 매핑합니다. 사용자 정의 수준을 사용하거나 기본 알고리즘이 여러분의 요구에 적합하지 않으면, 이 값을 재정의해야 할 수 있습니다. 기본 알고리즘은 <code class="docutils literal notranslate"><span class="pre">DEBUG</span></code>, <code class="docutils literal notranslate"><span class="pre">INFO</span></code>, <code class="docutils literal notranslate"><span class="pre">WARNING</span></code>, <code class="docutils literal notranslate"><span class="pre">ERROR</span></code> 및 <code class="docutils literal notranslate"><span class="pre">CRITICAL</span></code>을 동등한 syslog 이름으로 매핑하고, 다른 모든 수준 이름은 'warning'으로 매핑합니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nteventloghandler">
<span id="nt-eventlog-handler"></span><h2>NTEventLogHandler<a class="headerlink" href="#nteventloghandler" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 모듈에 있는 <a class="reference internal" href="#logging.handlers.NTEventLogHandler" title="logging.handlers.NTEventLogHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">NTEventLogHandler</span></code></a> 클래스는 로깅 메시지를 로컬 윈도우 NT, 윈도우 2000 또는 윈도우 XP 이벤트 로그로 보내는 것을 지원합니다. 사용할 수 있으려면 먼저 Mark Hammond의 파이썬 용 Win32 확장이 설치되어 있어야 합니다.</p>
<dl class="class">
<dt id="logging.handlers.NTEventLogHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">NTEventLogHandler</code><span class="sig-paren">(</span><em>appname</em>, <em>dllname=None</em>, <em>logtype='Application'</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.NTEventLogHandler" title="logging.handlers.NTEventLogHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">NTEventLogHandler</span></code></a> 클래스의 새 인스턴스를 반환합니다. <em>appname</em> 은 이벤트 로그에 나타나는 응용 프로그램 이름을 정의하는 데 사용됩니다. 이 이름을 사용하여 적절한 레지스트리 항목이 만들어집니다. <em>dllname</em> 은 로그에 보관할 메시지 정의를 포함하는 .dll 또는 .exe의 완전히 정규화된 경로명을 제공해야 합니다 (지정되지 않으면, <code class="docutils literal notranslate"><span class="pre">'win32service.pyd'</span></code>이 사용됩니다 - 이것은 Win32 확장과 함께 설치되며 몇 가지 기본 자리 표시자 메시지 정의를 포함합니다. 이 자리 표시자를 사용하면 전체 메시지 소스가 로그에 보관되므로 이벤트 로그가 커진다는 것에 유의하십시오. 간략한 로그를 원하면, 이벤트 로그에서 사용할 원하는 메시지 정의가 포함된 .dll 또는 .exe의 이름을 전달해야 합니다). <em>logtype</em> 은 <code class="docutils literal notranslate"><span class="pre">'Application'</span></code>, <code class="docutils literal notranslate"><span class="pre">'System'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'Security'</span></code> 중 하나이며, 기본값은 <code class="docutils literal notranslate"><span class="pre">'Application'</span></code>입니다.</p>
<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.close" title="정의 주소">¶</a></dt>
<dd><p>이 시점에서, 이벤트 로그 항목의 소스로서의 응용 프로그램 이름을 레지스트리에서 제거할 수 있습니다. 그러나, 이렇게 하면, 이벤트 로그 뷰어에서 의도한 대로 이벤트를 볼 수 없게 됩니다 - 이벤트 로그 뷰어는 .dll 이름을 가져오기 위해 레지스트리에 액세스할 수 있어야 합니다. 현재 버전은 그렇게 하지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.emit" title="정의 주소">¶</a></dt>
<dd><p>메시지 ID, 이벤트 범주 및 이벤트 유형을 결정한 다음, 메시지를 NT 이벤트 로그에 기록합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.getEventCategory">
<code class="descname">getEventCategory</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.getEventCategory" title="정의 주소">¶</a></dt>
<dd><p>레코드의 이벤트 범주를 반환합니다. 여러분 자신의 범주를 지정하려면, 이것을 재정의하십시오. 이 버전은 0을 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.getEventType">
<code class="descname">getEventType</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.getEventType" title="정의 주소">¶</a></dt>
<dd><p>레코드의 이벤트 유형을 반환합니다. 여러분 자신의 유형을 지정하려면, 이것을 재정의하십시오. 이 버전은 처리기의 typemap 어트리뷰트를 사용하여 매핑하는데, <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>에서 <code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> 및 <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code>에 대한 매핑이 포함된 딕셔너리로 설정됩니다. 여러분 자신의 수준을 사용한다면, 이 메서드를 재정의하거나 처리기의 <em>typemap</em> 어트리뷰트에 적절한 딕셔너리를 배치해야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.NTEventLogHandler.getMessageID">
<code class="descname">getMessageID</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.NTEventLogHandler.getMessageID" title="정의 주소">¶</a></dt>
<dd><p>레코드의 메시지 ID를 반환합니다. 여러분 자신의 메시지를 사용한다면, 로거에 전달된 <em>msg</em>를 포맷 문자열이 아닌 ID로 사용할 수 있습니다. 그런 다음 여기에서 딕셔너리 조회를 사용하여 메시지 ID를 가져올 수 있습니다. 이 버전은 <code class="file docutils literal notranslate"><span class="pre">win32service.pyd</span></code>의 기본 메시지 ID인 1을 반환합니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="smtphandler">
<span id="smtp-handler"></span><h2>SMTPHandler<a class="headerlink" href="#smtphandler" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 모듈에 있는 <a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTPHandler</span></code></a> 클래스는 SMTP를 통해 전자 메일 주소로 로깅 메시지를 보내는 것을 지원합니다.</p>
<dl class="class">
<dt id="logging.handlers.SMTPHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">SMTPHandler</code><span class="sig-paren">(</span><em>mailhost</em>, <em>fromaddr</em>, <em>toaddrs</em>, <em>subject</em>, <em>credentials=None</em>, <em>secure=None</em>, <em>timeout=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SMTPHandler" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTPHandler</span></code></a> 클래스의 새 인스턴스를 반환합니다. 인스턴스는 전자 메일의 보내는 주소, 받는 주소와 제목 줄을 사용하여 초기화됩니다. <em>toaddrs</em> 는 문자열 리스트여야 합니다. 비표준 SMTP 포트를 지정하려면, <em>mailhost</em> 인자에 (host, port) 튜플 형식을 사용하십시오. 문자열을 사용하면 표준 SMTP 포트가 사용됩니다. SMTP 서버가 인증을 요구하면, <em>credentials</em> 인자에 (username, password) 튜플을 지정할 수 있습니다.</p>
<p>보안 프로토콜(TLS)의 사용을 지정하려면, <em>secure</em> 인자에 튜플을 전달하십시오. 이것은 인증 자격 증명(credentials)이 제공될 때만 사용됩니다. 튜플은 빈 튜플이거나, 키 파일 이름을 가진 단일 값 튜플이거나, 키 파일과 인증서 파일의 이름을 가진 2-튜플이어야 합니다. (이 튜플은 <a class="reference internal" href="smtplib.html#smtplib.SMTP.starttls" title="smtplib.SMTP.starttls"><code class="xref py py-meth docutils literal notranslate"><span class="pre">smtplib.SMTP.starttls()</span></code></a> 메서드에 전달됩니다.)</p>
<p><em>timeout</em> 인자를 사용하여 SMTP 서버와의 통신에 시간제한을 지정할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가: </span><em>timeout</em> 인자가 추가되었습니다.</p>
</div>
<dl class="method">
<dt id="logging.handlers.SMTPHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SMTPHandler.emit" title="정의 주소">¶</a></dt>
<dd><p>레코드를 포맷하고 지정된 주소로 보냅니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.SMTPHandler.getSubject">
<code class="descname">getSubject</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SMTPHandler.getSubject" title="정의 주소">¶</a></dt>
<dd><p>레코드에 종속적인 제목 줄을 지정하려면, 이 메서드를 재정의하십시오.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="memoryhandler">
<span id="memory-handler"></span><h2>MemoryHandler<a class="headerlink" href="#memoryhandler" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 모듈에 있는 <a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryHandler</span></code></a> 클래스는 메모리에 로깅 레코드를 버퍼링하고, 주기적으로 <em class="dfn">대상 (target)</em> 처리기로 플러시 하는 것을 지원합니다. 플러시는 버퍼가 꽉 찼거나 특정 심각도 이상의 이벤트가 발생할 때마다 발생합니다.</p>
<p><a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryHandler</span></code></a>는 추상 클래스이면서, 더 일반적인 <a class="reference internal" href="#logging.handlers.BufferingHandler" title="logging.handlers.BufferingHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferingHandler</span></code></a>의 서브 클래스입니다. 이것은 레코드 로깅을 메모리에 버퍼링합니다. 각 레코드가 버퍼에 추가될 때마다, <code class="xref py py-meth docutils literal notranslate"><span class="pre">shouldFlush()</span></code>를 호출하여 버퍼를 플러시 할지 확인합니다. 필요하면, <code class="xref py py-meth docutils literal notranslate"><span class="pre">flush()</span></code>가 플러시를 수행할 것으로 기대합니다.</p>
<dl class="class">
<dt id="logging.handlers.BufferingHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">BufferingHandler</code><span class="sig-paren">(</span><em>capacity</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BufferingHandler" title="정의 주소">¶</a></dt>
<dd><p>지정된 용량(capacity)의 버퍼로 처리기를 초기화합니다. 여기서 <em>capacity</em>는 버퍼링 된 로깅 레코드 수를 의미합니다.</p>
<dl class="method">
<dt id="logging.handlers.BufferingHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BufferingHandler.emit" title="정의 주소">¶</a></dt>
<dd><p>레코드를 버퍼에 추가합니다. <a class="reference internal" href="#logging.handlers.BufferingHandler.shouldFlush" title="logging.handlers.BufferingHandler.shouldFlush"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shouldFlush()</span></code></a>가 참을 반환하면 <a class="reference internal" href="#logging.handlers.BufferingHandler.flush" title="logging.handlers.BufferingHandler.flush"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flush()</span></code></a>를 호출하여 버퍼를 처리합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.BufferingHandler.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BufferingHandler.flush" title="정의 주소">¶</a></dt>
<dd><p>사용자 정의 플러시 동작을 구현하기 위해 재정의할 수 있습니다. 이 버전은 버퍼를 비우기만 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.BufferingHandler.shouldFlush">
<code class="descname">shouldFlush</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.BufferingHandler.shouldFlush" title="정의 주소">¶</a></dt>
<dd><p>버퍼의 용량이 찼으면 참을 반환합니다. 이 메서드는 사용자 정의 플러시 전략을 구현하기 위해 재정의될 수 있습니다.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="logging.handlers.MemoryHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">MemoryHandler</code><span class="sig-paren">(</span><em>capacity</em>, <em>flushLevel=ERROR</em>, <em>target=None</em>, <em>flushOnClose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryHandler</span></code></a> 클래스의 새 인스턴스를 반환합니다. 인스턴스는 <em>capacity</em>(버퍼 된 레코드 수)의 버퍼 크기로 초기화됩니다. <em>flushLevel</em>을 지정하지 않으면, <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code>가 사용됩니다. <em>target</em> 이 지정되지 않으면, 이 처리기가 유용한 것을 하기 전에, <a class="reference internal" href="#logging.handlers.MemoryHandler.setTarget" title="logging.handlers.MemoryHandler.setTarget"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setTarget()</span></code></a>를 사용해 대상을 설정할 필요가 있습니다. <em>flushOnClose</em> 가 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 지정되면, 처리기가 닫힐 때 버퍼가 플러시 되지 <em>않습니다</em>. 지정되지 않거나 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 지정되면, 처리기가 닫힐 때 버퍼를 플러시 하는 이전 동작이 발생합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><em>flushOnClose</em> 매개 변수가 추가되었습니다.</p>
</div>
<dl class="method">
<dt id="logging.handlers.MemoryHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler.close" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.MemoryHandler.flush" title="logging.handlers.MemoryHandler.flush"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flush()</span></code></a>를 호출하고, 대상(target)을 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정하고, 버퍼를 비웁니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.MemoryHandler.flush">
<code class="descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler.flush" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.MemoryHandler" title="logging.handlers.MemoryHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryHandler</span></code></a>의 경우, 플러시는 버퍼링 된 레코드가 있다면 대상으로 보내는 것을 뜻합니다. 이때 버퍼도 지워집니다. 다른 행동을 원하면 재정의하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.MemoryHandler.setTarget">
<code class="descname">setTarget</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler.setTarget" title="정의 주소">¶</a></dt>
<dd><p>이 처리기의 대상 처리기를 설정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.MemoryHandler.shouldFlush">
<code class="descname">shouldFlush</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.MemoryHandler.shouldFlush" title="정의 주소">¶</a></dt>
<dd><p>버퍼 가득 참이나 레코드가 <em>flushLevel</em> 이상을 만드는지 확인합니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="httphandler">
<span id="http-handler"></span><h2>HTTPHandler<a class="headerlink" href="#httphandler" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 모듈에 있는 <a class="reference internal" href="#logging.handlers.HTTPHandler" title="logging.handlers.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a> 클래스는 <code class="docutils literal notranslate"><span class="pre">GET</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">POST</span></code> 를 사용해서 로깅 메시지를 웹 서버로 보내는 것을 지원합니다.</p>
<dl class="class">
<dt id="logging.handlers.HTTPHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">HTTPHandler</code><span class="sig-paren">(</span><em>host</em>, <em>url</em>, <em>method='GET'</em>, <em>secure=False</em>, <em>credentials=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.HTTPHandler" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.HTTPHandler" title="logging.handlers.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a> 클래스의 새 인스턴스를 반환합니다. <em>host</em> 는 특정 포트 번호를 사용해야 하면 <code class="docutils literal notranslate"><span class="pre">host:port</span></code> 형식일 수 있습니다. <em>method</em> 를 지정하지 않으면 <code class="docutils literal notranslate"><span class="pre">GET</span></code>이 사용됩니다. <em>secure</em> 가 참이면, HTTPS 연결이 사용됩니다. <em>context</em> 매개 변수는 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 인스턴스로 설정되어, HTTPS 연결에 사용되는 SSL 설정을 구성할 수 있습니다. <em>credentials</em> 가 지정되면, 기본 인증을 사용하여 HTTP 'Authorization' 헤더에 배치되는 사용자 ID와 암호로 구성된 2-튜플이어야 합니다. credentials를 지정하면, 사용자 ID와 암호가 단순 텍스트로 전달되지 않도록 secure=True를 지정해야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><em>context</em> 매개 변수가 추가되었습니다.</p>
</div>
<dl class="method">
<dt id="logging.handlers.HTTPHandler.mapLogRecord">
<code class="descname">mapLogRecord</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.HTTPHandler.mapLogRecord" title="정의 주소">¶</a></dt>
<dd><p>URL 인코딩되어 웹 서버로 전송되는, <code class="docutils literal notranslate"><span class="pre">record</span></code>에 기반한 딕셔너리를 제공합니다. 기본 구현은 <code class="docutils literal notranslate"><span class="pre">record.__dict__</span></code>를 반환합니다. 이 메서드는 재정의할 수 있는데, 예를 들어 <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>의 일부만 웹 서버로 보내지거나, 서버로 보내는 내용에 대한 보다 구체적인 사용자 정의가 필요한 경우입니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.HTTPHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.HTTPHandler.emit" title="정의 주소">¶</a></dt>
<dd><p>URL 인코딩된 딕셔너리로 웹 서버에 레코드를 보냅니다. <a class="reference internal" href="#logging.handlers.HTTPHandler.mapLogRecord" title="logging.handlers.HTTPHandler.mapLogRecord"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mapLogRecord()</span></code></a> 메서드가 레코드를 전송할 딕셔너리로 변환하는 데 사용됩니다.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">참고</p>
<p>웹 서버로 보내기 위해 레코드를 준비하는 것은, 일반 포매팅 연산과 같지 않으므로, <a class="reference internal" href="logging.html#logging.Handler.setFormatter" title="logging.Handler.setFormatter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setFormatter()</span></code></a>를 사용해서 <a class="reference internal" href="#logging.handlers.HTTPHandler" title="logging.handlers.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a>의 <a class="reference internal" href="logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a>를 지정하는 것은 효과가 없습니다. <a class="reference internal" href="logging.html#logging.Handler.format" title="logging.Handler.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">format()</span></code></a>을 호출하는 대신, 이 처리기는 <a class="reference internal" href="#logging.handlers.HTTPHandler.mapLogRecord" title="logging.handlers.HTTPHandler.mapLogRecord"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mapLogRecord()</span></code></a>를 호출한 다음, <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a>를 호출하여 웹 서버로 보내기에 적합한 형식으로 딕셔너리를 인코딩합니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="queuehandler">
<span id="queue-handler"></span><h2>QueueHandler<a class="headerlink" href="#queuehandler" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 모듈에 있는 <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueHandler</span></code></a> 클래스는, <a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">queue</span></code></a> 나 <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 모듈에 구현된 것과 같은 큐에 로깅 메시지를 보내는 것을 지원합니다.</p>
<p><a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueListener</span></code></a> 클래스와 함께, <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueHandler</span></code></a>를 사용하여 처리기가 로깅을 수행하는 스레드와 다른 스레드에서 작업을 수행하도록 할 수 있습니다. 이는 클라이언트를 처리하는 스레드가 가능한 한 신속하게 응답하고, 느린 작업(가령 <a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTPHandler</span></code></a>를 통해 전자 메일 보내기)은 별도의 스레드에서 수행되어야 하는 웹 응용 프로그램과 다른 서비스 응용 프로그램에서 중요합니다.</p>
<dl class="class">
<dt id="logging.handlers.QueueHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">QueueHandler</code><span class="sig-paren">(</span><em>queue</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueHandler" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueHandler</span></code></a> 클래스의 새 인스턴스를 반환합니다. 인스턴스는 메시지를 보낼 큐로 초기화됩니다. <em>queue</em>는 임의의 큐류(queue-like) 객체일 수 있습니다; 메시지를 보내는 방법을 알아야 하는 <a class="reference internal" href="#logging.handlers.QueueHandler.enqueue" title="logging.handlers.QueueHandler.enqueue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">enqueue()</span></code></a> 메서드가 있는 그대로 사용합니다. 큐는 작업 추적 API를 갖도록 <em>요구되지</em> 않아서, <em>queue</em>에 <a class="reference internal" href="queue.html#queue.SimpleQueue" title="queue.SimpleQueue"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleQueue</span></code></a> 인스턴스를 사용할 수 있습니다.</p>
<dl class="method">
<dt id="logging.handlers.QueueHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueHandler.emit" title="정의 주소">¶</a></dt>
<dd><p>LogRecord를 준비한 결과를 큐에 넣습니다. 예외가 발생하면 (예를 들어, 유한(bounded) 큐가 다 차서), <a class="reference internal" href="logging.html#logging.Handler.handleError" title="logging.Handler.handleError"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handleError()</span></code></a> 메서드가 호출되어 에러를 처리합니다. 이로 인해 레코드가 조용히 버려지거나 (<code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.raiseExceptions</span></code>가 <code class="docutils literal notranslate"><span class="pre">False</span></code> 인 경우), 메시지가 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>에 인쇄됩니다 (<code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.raiseExceptions</span></code>가 <code class="docutils literal notranslate"><span class="pre">True</span></code> 인 경우).</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueHandler.prepare">
<code class="descname">prepare</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueHandler.prepare" title="정의 주소">¶</a></dt>
<dd><p>큐에 넣기 위해 레코드를 준비합니다. 이 메서드에 의해 반환된 객체는 큐에 들어갑니다.</p>
<p>기본 구현은 메시지, 인자와 있다면 예외 정보를 병합하도록 레코드를 포맷합니다. 또한, 역 피클 할 수 없는 항목들을 레코드에서 직접(in-place) 제거합니다.</p>
<p>레코드를 dict 나 JSON 문자열로 변환하거나, 원본을 그대로 두고 레코드의 수정 된 복사본을 보내길 원한다면 이 메서드를 재정의할 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueHandler.enqueue">
<code class="descname">enqueue</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueHandler.enqueue" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">put_nowait()</span></code>를 사용하여 큐에 레코드를 넣습니다; 블로킹 동작이나 시간제한이나, 사용자 정의 큐 구현을 사용하려면 이 메서드를 재정의할 수 있습니다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="queuelistener">
<span id="queue-listener"></span><h2>QueueListener<a class="headerlink" href="#queuelistener" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<p><a class="reference internal" href="#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a> 모듈에 있는 <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueListener</span></code></a> 클래스는 <a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">queue</span></code></a> 나 <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 모듈에 구현된 것과 같은 큐에서 로깅 메시지를 수신하는 것을 지원합니다. 메시지는 내부 스레드의 큐에서 수신되고 처리를 위해 같은 스레드에서 하나 이상의 처리기로 전달됩니다. <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueListener</span></code></a> 자체는 처리기가 아니지만, <a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueHandler</span></code></a> 와 함께 사용되기 때문에 여기에 설명되어 있습니다.</p>
<p><a class="reference internal" href="#logging.handlers.QueueHandler" title="logging.handlers.QueueHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueHandler</span></code></a> 클래스와 함께, <a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueListener</span></code></a>를 사용하여 처리기가 로깅을 수행하는 스레드와 다른 스레드에서 작업을 수행하도록 할 수 있습니다. 이는 클라이언트를 처리하는 스레드가 가능한 한 신속하게 응답하고, 느린 작업(가령 <a class="reference internal" href="#logging.handlers.SMTPHandler" title="logging.handlers.SMTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTPHandler</span></code></a>를 통해 전자 메일 보내기)은 별도의 스레드에서 수행되어야 하는 웹 응용 프로그램과 다른 서비스 응용 프로그램에서 중요합니다.</p>
<dl class="class">
<dt id="logging.handlers.QueueListener">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">QueueListener</code><span class="sig-paren">(</span><em>queue</em>, <em>*handlers</em>, <em>respect_handler_level=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#logging.handlers.QueueListener" title="logging.handlers.QueueListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueListener</span></code></a> 클래스의 새 인스턴스를 반환합니다. 인스턴스는 메시지를 보내는 큐와 큐에 있는 항목을 처리할 처리기의 리스트로 초기화됩니다. 큐는 임의의 큐류(queue-like) 객체일 수 있습니다; 메시지를 꺼내는 방법을 알아야 하는 <a class="reference internal" href="#logging.handlers.QueueListener.dequeue" title="logging.handlers.QueueListener.dequeue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dequeue()</span></code></a> 메서드가 있는 그대로 사용합니다. 큐는 작업 추적 API를 갖도록 <em>요구되지</em> 않아서 (가능하면 사용됩니다), <em>queue</em>에 <a class="reference internal" href="queue.html#queue.SimpleQueue" title="queue.SimpleQueue"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleQueue</span></code></a> 인스턴스를 사용할 수 있습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">respect_handler_level</span></code>이 <code class="docutils literal notranslate"><span class="pre">True</span></code> 면, 처리기에 메시지를 전달할지를 결정할 때, 처리기의 수준이 존중됩니다 (메시지의 수준과 비교); 그렇지 않으면, 이전 파이썬 버전과 같게 동작합니다 - 항상 각 메시지를 모든 처리기에 전달합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><code class="docutils literal notranslate"><span class="pre">respect_handler_levels</span></code> 인자가 추가되었습니다.</p>
</div>
<dl class="method">
<dt id="logging.handlers.QueueListener.dequeue">
<code class="descname">dequeue</code><span class="sig-paren">(</span><em>block</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.dequeue" title="정의 주소">¶</a></dt>
<dd><p>레코드를 큐에서 꺼내 반환합니다. 선택적으로 블록 됩니다.</p>
<p>기본 구현은 <code class="docutils literal notranslate"><span class="pre">get()</span></code>을 사용합니다. 시간제한을 사용하거나 사용자 정의 큐 구현을 사용하려면 이 메서드를 재정의할 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.prepare">
<code class="descname">prepare</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.prepare" title="정의 주소">¶</a></dt>
<dd><p>처리를 위해 레코드를 준비합니다.</p>
<p>이 구현은 단지 전달된 레코드를 반환합니다. 사용자 정의 직렬화를 수행하거나 처리기에 전달하기 전에 레코드를 조작해야 하면, 이 메서드를 재정의할 수 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.handle" title="정의 주소">¶</a></dt>
<dd><p>레코드를 처리합니다.</p>
<p>이것은 단지 모든 처리기로 레코드를 제공합니다. 처리기에 전달되는 실제 객체는 <a class="reference internal" href="#logging.handlers.QueueListener.prepare" title="logging.handlers.QueueListener.prepare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prepare()</span></code></a>에서 반환된 객체입니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.start">
<code class="descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.start" title="정의 주소">¶</a></dt>
<dd><p>수신기를 시작합니다.</p>
<p>이것은 처리하기 위해 큐에서 LogRecord를 관찰하는 배경 스레드를 시작합니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.stop" title="정의 주소">¶</a></dt>
<dd><p>수신기를 정지합니다.</p>
<p>스레드가 종료하도록 요청한 다음, 스레드가 종료할 때까지 대기합니다. 응용 프로그램이 종료되기 전에 이 함수를 호출하지 않으면, 레코드가 큐에 남아있을 수 있고, 이것들은 처리되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="logging.handlers.QueueListener.enqueue_sentinel">
<code class="descname">enqueue_sentinel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.QueueListener.enqueue_sentinel" title="정의 주소">¶</a></dt>
<dd><p>수신자에게 종료하도록 알리기 위해 큐에 종료 신호(sentinel)를 씁니다. 이 구현은 <code class="docutils literal notranslate"><span class="pre">put_nowait()</span></code>를 사용합니다. 시간제한을 사용하거나 사용자 정의 큐 구현을 사용하려면 이 메서드를 재정의할 수 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt>모듈 <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a></dt><dd><p>logging 모듈에 관한 API 레퍼런스.</p>
</dd>
<dt>모듈 <a class="reference internal" href="logging.config.html#module-logging.config" title="logging.config: Configuration of the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code></a></dt><dd><p>logging 모듈용 구성 API.</p>
</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code> --- 로깅 처리기</a><ul>
<li><a class="reference internal" href="#streamhandler">StreamHandler</a></li>
<li><a class="reference internal" href="#filehandler">FileHandler</a></li>
<li><a class="reference internal" href="#nullhandler">NullHandler</a></li>
<li><a class="reference internal" href="#watchedfilehandler">WatchedFileHandler</a></li>
<li><a class="reference internal" href="#baserotatinghandler">BaseRotatingHandler</a></li>
<li><a class="reference internal" href="#rotatingfilehandler">RotatingFileHandler</a></li>
<li><a class="reference internal" href="#timedrotatingfilehandler">TimedRotatingFileHandler</a></li>
<li><a class="reference internal" href="#sockethandler">SocketHandler</a></li>
<li><a class="reference internal" href="#datagramhandler">DatagramHandler</a></li>
<li><a class="reference internal" href="#sysloghandler">SysLogHandler</a></li>
<li><a class="reference internal" href="#nteventloghandler">NTEventLogHandler</a></li>
<li><a class="reference internal" href="#smtphandler">SMTPHandler</a></li>
<li><a class="reference internal" href="#memoryhandler">MemoryHandler</a></li>
<li><a class="reference internal" href="#httphandler">HTTPHandler</a></li>
<li><a class="reference internal" href="#queuehandler">QueueHandler</a></li>
<li><a class="reference internal" href="#queuelistener">QueueListener</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="logging.config.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code> --- 로깅 구성</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="getpass.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">getpass</span></code> --- 이식성 있는 암호 입력</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="getpass.html" title="getpass --- 이식성 있는 암호 입력"
             >다음</a> |</li>
        <li class="right" >
          <a href="logging.config.html" title="logging.config --- 로깅 구성"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >일반 운영 체제 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2019, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2019, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>