
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>smtplib --- SMTP 프로토콜 클라이언트 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="smtpd --- SMTP Server" href="smtpd.html" />
    <link rel="prev" title="nntplib --- NNTP protocol client" href="nntplib.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/smtplib.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="smtpd.html" title="smtpd --- SMTP Server"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="nntplib.html" title="nntplib --- NNTP protocol client"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-smtplib">
<span id="smtplib-smtp-protocol-client"></span><h1><a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> --- SMTP 프로토콜 클라이언트<a class="headerlink" href="#module-smtplib" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/smtplib.py">Lib/smtplib.py</a></p>
<hr class="docutils" id="index-0" />
<p><a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> 모듈은 SMTP나 ESMTP 리스너 데몬을 사용하여 모든 인터넷 기계로 메일을 보내는 데 사용할 수 있는 SMTP 클라이언트 세션 객체를 정의합니다. SMTP와 ESMTP 연산에 대한 자세한 내용은 <span class="target" id="index-16"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc821.html"><strong>RFC 821</strong></a>(Simple Mail Transfer Protocol)과 <span class="target" id="index-17"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1869.html"><strong>RFC 1869</strong></a>(SMTP Service Extensions)를 참조하십시오.</p>
<dl class="class">
<dt id="smtplib.SMTP">
<em class="property">class </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTP</code><span class="sig-paren">(</span><em class="sig-param">host=''</em>, <em class="sig-param">port=0</em>, <em class="sig-param">local_hostname=None</em>, <span class="optional">[</span><em class="sig-param">timeout</em>, <span class="optional">]</span><em class="sig-param">source_address=None</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 인스턴스는 SMTP 연결을 캡슐화합니다. SMTP와 ESMTP 연산의 전체 레퍼토리를 지원하는 메서드가 있습니다. 선택적 호스트와 포트 매개 변수가 제공되면, 초기화 중에 해당 매개 변수로 SMTP <a class="reference internal" href="#smtplib.SMTP.connect" title="smtplib.SMTP.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> 메서드가 호출됩니다. 지정되면, HELO/EHLO 명령에서 <em>local_hostname</em>이 로컬 호스트의 FQDN으로 사용됩니다. 그렇지 않으면 <a class="reference internal" href="socket.html#socket.getfqdn" title="socket.getfqdn"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.getfqdn()</span></code></a>을 사용하여 로컬 호스트명을 찾습니다. <a class="reference internal" href="#smtplib.SMTP.connect" title="smtplib.SMTP.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> 호출이 성공 코드 이외의 것을 반환하면 <a class="reference internal" href="#smtplib.SMTPConnectError" title="smtplib.SMTPConnectError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPConnectError</span></code></a>가 발생합니다. 선택적 <em>timeout</em> 매개 변수는 연결 시도와 같은 블로킹 연산을 위한 시간제한을 초로 지정합니다 (지정하지 않으면, 전역 기본 시간제한 설정이 사용됩니다). 시간제한이 만료되면 <a class="reference internal" href="socket.html#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.timeout</span></code></a>이 발생합니다. 선택적 source_address 매개 변수는 여러 네트워크 인터페이스가 있는 기계의 특정 소스 주소 그리고/또는 특정 소스 TCP 포트에 바인딩 할 수 있도록 합니다. 연결 전에 소켓이 소스 주소로 바인드할 2-튜플 (host, port)를 취합니다. 생략되면 (또는 호스트나 포트가 각각 <code class="docutils literal notranslate"><span class="pre">''</span></code> 및/또는 0이면) OS 기본 동작이 사용됩니다.</p>
<p>일반적인 사용을 위해서는, 초기화/연결, <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a> 및 <a class="reference internal" href="#smtplib.SMTP.quit" title="smtplib.SMTP.quit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SMTP.quit()</span></code></a> 메서드 만 필요합니다. 아래에 예가 포함되어 있습니다.</p>
<p><a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 클래스는 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문을 지원합니다. 이처럼 사용되면, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 문이 종료될 때 SMTP <code class="docutils literal notranslate"><span class="pre">QUIT</span></code> 명령이 자동으로 발행됩니다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">smtplib</span> <span class="k">import</span> <span class="n">SMTP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">SMTP</span><span class="p">(</span><span class="s2">&quot;domain.org&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">smtp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">smtp</span><span class="o">.</span><span class="n">noop</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">(250, b&#39;Ok&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">data</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">smtplib.send</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>source_address 인자가 추가되었습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가: </span>SMTPUTF8 확장(<span class="target" id="index-18"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6531.html"><strong>RFC 6531</strong></a>)이 이제 지원됩니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="smtplib.SMTP_SSL">
<em class="property">class </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTP_SSL</code><span class="sig-paren">(</span><em class="sig-param">host=''</em>, <em class="sig-param">port=0</em>, <em class="sig-param">local_hostname=None</em>, <em class="sig-param">keyfile=None</em>, <em class="sig-param">certfile=None</em>, <span class="optional">[</span><em class="sig-param">timeout</em>, <span class="optional">]</span><em class="sig-param">context=None</em>, <em class="sig-param">source_address=None</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP_SSL" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#smtplib.SMTP_SSL" title="smtplib.SMTP_SSL"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP_SSL</span></code></a> 인스턴스는 <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 인스턴스와 정확히 같게 작동합니다. 연결 시작시 SSL이 필요하고 <code class="xref py py-meth docutils literal notranslate"><span class="pre">starttls()</span></code> 사용이 적합하지 않은 상황에서는 <a class="reference internal" href="#smtplib.SMTP_SSL" title="smtplib.SMTP_SSL"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP_SSL</span></code></a>을 사용해야합니다. <em>host</em>를 지정하지 않으면, 로컬 호스트가 사용됩니다. <em>port</em>가 0이면, 표준 SMTP-over-SSL 포트(465)가 사용됩니다. 선택적 인자 <em>local_hostname</em>, <em>timeout</em> 및 <em>source_address</em>는 <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 클래스에서와 같은 의미를 갖습니다. 역시 선택적인 <em>context</em>는 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>를 포함할 수 있으며 보안 연결의 다양한 측면을 구성하도록 합니다. 모범 사례는 <a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">보안 고려 사항</span></a>을 읽으십시오.</p>
<p><em>keyfile</em>과 <em>certfile</em>은 <em>context</em>의 레거시 대안이며, SSL 연결을 위한 PEM 형식 개인 키와 인증서 체인 파일을 가리킬 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><em>context</em>가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>source_address 인자가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>이 클래스는 이제 <a class="reference internal" href="ssl.html#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ssl.SSLContext.check_hostname</span></code></a>과 <em>서버 이름 표시(Server Name Indication)</em>로 호스트명 확인을 지원합니다 (<a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal notranslate"><span class="pre">ssl.HAS_SNI</span></code></a>를 참조하십시오).</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.6부터 폐지: </span><em>keyfile</em>과 <em>certfile</em>은 폐지되었고 <em>context</em>로 대체되었습니다. 대신 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a>을 사용하거나, <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>가 시스템의 신뢰할 수 있는 CA 인증서를 선택하도록 하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="smtplib.LMTP">
<em class="property">class </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">LMTP</code><span class="sig-paren">(</span><em class="sig-param">host=''</em>, <em class="sig-param">port=LMTP_PORT</em>, <em class="sig-param">local_hostname=None</em>, <em class="sig-param">source_address=None</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.LMTP" title="정의 주소">¶</a></dt>
<dd><p>ESMTP와 매우 유사한 LMTP 프로토콜은 표준 SMTP 클라이언트를 기반으로합니다. LMTP에 유닉스 소켓을 사용하는 것이 일반적이라서, <code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code> 메서드는 일반 host:port 서버뿐만 아니라 이를 지원해야합니다. 선택적 인자 local_hostname과 source_address는 <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 클래스에서와 같은 의미를 갖습니다. 유닉스 소켓을 지정하려면, <em>host</em>에 '/'로 시작하는 절대 경로를 사용해야합니다.</p>
<p>일반 SMTP 메커니즘을 사용하여 인증이 지원됩니다. 유닉스 소켓을 사용할 때, LMTP는 일반적으로 인증을 지원하지 않거나 요구하지 않지만, 여러분의 상황에서는 다를 수 있습니다.</p>
</dd></dl>

<p>훌륭한 예외 모음도 정의되어 있습니다:</p>
<dl class="exception">
<dt id="smtplib.SMTPException">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPException</code><a class="headerlink" href="#smtplib.SMTPException" title="정의 주소">¶</a></dt>
<dd><p>이 모듈에서 제공하는 다른 모든 예외에 대한 베이스 예외 클래스 인 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 서브 클래스.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>SMTPException이 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 서브 클래스가 되었습니다.</p>
</div>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPServerDisconnected">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPServerDisconnected</code><a class="headerlink" href="#smtplib.SMTPServerDisconnected" title="정의 주소">¶</a></dt>
<dd><p>이 예외는 예기치 않게 서버와의 연결이 끊어 지거나, 서버에 연결하기 전에 <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 인스턴스를 사용하려고 할 때 발생합니다.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPResponseException">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPResponseException</code><a class="headerlink" href="#smtplib.SMTPResponseException" title="정의 주소">¶</a></dt>
<dd><p>SMTP 에러 코드가 포함된 모든 예외의 베이스 클래스. 이러한 예외는 SMTP 서버가 에러 코드를 반환하는 일부 경우에 생성됩니다. 에러 코드는 에러의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">smtp_code</span></code> 어트리뷰트에 저장되며, <code class="xref py py-attr docutils literal notranslate"><span class="pre">smtp_error</span></code> 어트리뷰트는 에러 메시지로 설정됩니다.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPSenderRefused">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPSenderRefused</code><a class="headerlink" href="#smtplib.SMTPSenderRefused" title="정의 주소">¶</a></dt>
<dd><p>발신자 주소가 거부되었습니다. 모든 <a class="reference internal" href="#smtplib.SMTPResponseException" title="smtplib.SMTPResponseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPResponseException</span></code></a> 예외에 의해 설정된 어트리뷰트 외에도, 이것은 'sender'를 SMTP 서버가 거부한 문자열로 설정합니다.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPRecipientsRefused">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPRecipientsRefused</code><a class="headerlink" href="#smtplib.SMTPRecipientsRefused" title="정의 주소">¶</a></dt>
<dd><p>모든 수신자 주소가 거부되었습니다. 각 수신자의 에러는 <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SMTP.sendmail()</span></code></a>이 반환하는 것과 정확히 같은 종류의 딕셔너리인 <code class="xref py py-attr docutils literal notranslate"><span class="pre">recipients</span></code> 어트리뷰트를 통해 액세스 할 수 있습니다.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPDataError">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPDataError</code><a class="headerlink" href="#smtplib.SMTPDataError" title="정의 주소">¶</a></dt>
<dd><p>SMTP 서버가 메시지 데이터 수락을 거부했습니다.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPConnectError">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPConnectError</code><a class="headerlink" href="#smtplib.SMTPConnectError" title="정의 주소">¶</a></dt>
<dd><p>서버와의 연결을 설정하는 동안 에러가 발생했습니다.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPHeloError">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPHeloError</code><a class="headerlink" href="#smtplib.SMTPHeloError" title="정의 주소">¶</a></dt>
<dd><p>서버가 <code class="docutils literal notranslate"><span class="pre">HELO</span></code> 메시지를 거부했습니다.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPNotSupportedError">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPNotSupportedError</code><a class="headerlink" href="#smtplib.SMTPNotSupportedError" title="정의 주소">¶</a></dt>
<dd><p>시도한 명령이나 옵션이 서버에서 지원되지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPAuthenticationError">
<em class="property">exception </em><code class="sig-prename descclassname">smtplib.</code><code class="sig-name descname">SMTPAuthenticationError</code><a class="headerlink" href="#smtplib.SMTPAuthenticationError" title="정의 주소">¶</a></dt>
<dd><p>SMTP 인증이 잘못되었습니다. 서버가 제공된 username/password 조합을 수락하지 않았을 가능성이 높습니다.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-4"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc821.html"><strong>RFC 821</strong></a> - Simple Mail Transfer Protocol</dt><dd><p>SMTP의 프로토콜 정의. 이 문서는 SMTP의 모델, 운영 절차 및 프로토콜 세부 사항을 다룹니다.</p>
</dd>
<dt><span class="target" id="index-5"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1869.html"><strong>RFC 1869</strong></a> - SMTP Service Extensions</dt><dd><p>SMTP를 위한 ESMTP 확장의 정의. 이 문서는 새로운 명령으로 SMTP를 확장하고 서버에서 제공하는 명령의 동적 발견을 지원하는 프레임워크에 대해 설명하고, 몇 가지 추가 명령을 정의합니다.</p>
</dd>
</dl>
</div>
<div class="section" id="smtp-objects">
<span id="id1"></span><h2>SMTP 객체<a class="headerlink" href="#smtp-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 인스턴스에는 다음과 같은 메서드가 있습니다:</p>
<dl class="method">
<dt id="smtplib.SMTP.set_debuglevel">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">set_debuglevel</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.set_debuglevel" title="정의 주소">¶</a></dt>
<dd><p>디버그 출력 수준을 설정합니다. <em>level</em>의 값이 1이나 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면 연결과 서버와 주고받는 모든 메시지에 대한 디버그 메시지가 생성됩니다. <em>level</em>의 값이 2이면 이러한 메시지에 타임스탬프가 추가됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>디버그 수준 2를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.docmd">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">docmd</code><span class="sig-paren">(</span><em class="sig-param">cmd</em>, <em class="sig-param">args=''</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.docmd" title="정의 주소">¶</a></dt>
<dd><p>서버에 <em>cmd</em> 명령을 전송합니다. 선택적 인자 <em>args</em>는 단순히 공백으로 구분하여 명령에 이어붙입니다.</p>
<p>숫자 응답 코드와 실제 응답 줄로 구성된 2-튜플을 반환합니다 (여러 줄 응답은 하나의 긴 줄로 결합됩니다).</p>
<p>일반적인 작업에서 이 메서드를 명시적으로 호출할 필요는 없습니다. 다른 메서드를 구현하는 데 사용되며 개인적인 확장을 테스트하는 데 유용할 수 있습니다.</p>
<p>응답을 기다리는 동안 서버와의 연결이 끊어지면, <a class="reference internal" href="#smtplib.SMTPServerDisconnected" title="smtplib.SMTPServerDisconnected"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPServerDisconnected</span></code></a>가 발생합니다.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.connect">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">connect</code><span class="sig-paren">(</span><em class="sig-param">host='localhost'</em>, <em class="sig-param">port=0</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.connect" title="정의 주소">¶</a></dt>
<dd><p>Connect to a host on a given port.  The defaults are to connect to the local
host at the standard SMTP port (25). If the hostname ends with a colon (<code class="docutils literal notranslate"><span class="pre">':'</span></code>)
followed by a number, that suffix will be stripped off and the number
interpreted as the port number to use. This method is automatically invoked by
the constructor if a host is specified during instantiation.  Returns a
2-tuple of the response code and message sent by the server in its
connection response.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">host</span></code>, <code class="docutils literal notranslate"><span class="pre">port</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">smtplib.connect</span></code>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.helo">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">helo</code><span class="sig-paren">(</span><em class="sig-param">name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.helo" title="정의 주소">¶</a></dt>
<dd><p>Identify yourself to the SMTP server using <code class="docutils literal notranslate"><span class="pre">HELO</span></code>.  The hostname argument
defaults to the fully qualified domain name of the local host.
The message returned by the server is stored as the <code class="xref py py-attr docutils literal notranslate"><span class="pre">helo_resp</span></code> attribute
of the object.</p>
<p>In normal operation it should not be necessary to call this method explicitly.
It will be implicitly called by the <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a> when necessary.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.ehlo">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">ehlo</code><span class="sig-paren">(</span><em class="sig-param">name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.ehlo" title="정의 주소">¶</a></dt>
<dd><p>Identify yourself to an ESMTP server using <code class="docutils literal notranslate"><span class="pre">EHLO</span></code>.  The hostname argument
defaults to the fully qualified domain name of the local host.  Examine the
response for ESMTP option and store them for use by <a class="reference internal" href="#smtplib.SMTP.has_extn" title="smtplib.SMTP.has_extn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_extn()</span></code></a>.
Also sets several informational attributes: the message returned by
the server is stored as the <code class="xref py py-attr docutils literal notranslate"><span class="pre">ehlo_resp</span></code> attribute, <code class="xref py py-attr docutils literal notranslate"><span class="pre">does_esmtp</span></code>
is set to true or false depending on whether the server supports ESMTP, and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">esmtp_features</span></code> will be a dictionary containing the names of the
SMTP service extensions this server supports, and their parameters (if any).</p>
<p>Unless you wish to use <a class="reference internal" href="#smtplib.SMTP.has_extn" title="smtplib.SMTP.has_extn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_extn()</span></code></a> before sending mail, it should not be
necessary to call this method explicitly.  It will be implicitly called by
<a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a> when necessary.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.ehlo_or_helo_if_needed">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">ehlo_or_helo_if_needed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.ehlo_or_helo_if_needed" title="정의 주소">¶</a></dt>
<dd><p>This method calls <a class="reference internal" href="#smtplib.SMTP.ehlo" title="smtplib.SMTP.ehlo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ehlo()</span></code></a> and/or <a class="reference internal" href="#smtplib.SMTP.helo" title="smtplib.SMTP.helo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">helo()</span></code></a> if there has been no
previous <code class="docutils literal notranslate"><span class="pre">EHLO</span></code> or <code class="docutils literal notranslate"><span class="pre">HELO</span></code> command this session.  It tries ESMTP <code class="docutils literal notranslate"><span class="pre">EHLO</span></code>
first.</p>
<dl class="simple">
<dt><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPHeloError</span></code></a></dt><dd><p>The server didn't reply properly to the <code class="docutils literal notranslate"><span class="pre">HELO</span></code> greeting.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.has_extn">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">has_extn</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.has_extn" title="정의 주소">¶</a></dt>
<dd><p>Return <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> if <em>name</em> is in the set of SMTP service extensions returned
by the server, <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> otherwise. Case is ignored.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.verify">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">verify</code><span class="sig-paren">(</span><em class="sig-param">address</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.verify" title="정의 주소">¶</a></dt>
<dd><p>Check the validity of an address on this server using SMTP <code class="docutils literal notranslate"><span class="pre">VRFY</span></code>. Returns a
tuple consisting of code 250 and a full <span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> address (including human
name) if the user address is valid. Otherwise returns an SMTP error code of 400
or greater and an error string.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>Many sites disable SMTP <code class="docutils literal notranslate"><span class="pre">VRFY</span></code> in order to foil spammers.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.login">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">login</code><span class="sig-paren">(</span><em class="sig-param">user</em>, <em class="sig-param">password</em>, <em class="sig-param">*</em>, <em class="sig-param">initial_response_ok=True</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.login" title="정의 주소">¶</a></dt>
<dd><p>Log in on an SMTP server that requires authentication. The arguments are the
username and the password to authenticate with. If there has been no previous
<code class="docutils literal notranslate"><span class="pre">EHLO</span></code> or <code class="docutils literal notranslate"><span class="pre">HELO</span></code> command this session, this method tries ESMTP <code class="docutils literal notranslate"><span class="pre">EHLO</span></code>
first. This method will return normally if the authentication was successful, or
may raise the following exceptions:</p>
<dl class="simple">
<dt><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPHeloError</span></code></a></dt><dd><p>The server didn't reply properly to the <code class="docutils literal notranslate"><span class="pre">HELO</span></code> greeting.</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPAuthenticationError" title="smtplib.SMTPAuthenticationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPAuthenticationError</span></code></a></dt><dd><p>The server didn't accept the username/password combination.</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> command is not supported by the server.</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPException" title="smtplib.SMTPException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPException</span></code></a></dt><dd><p>No suitable authentication method was found.</p>
</dd>
</dl>
<p>Each of the authentication methods supported by <a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> are tried in
turn if they are advertised as supported by the server.  See <a class="reference internal" href="#smtplib.SMTP.auth" title="smtplib.SMTP.auth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">auth()</span></code></a>
for a list of supported authentication methods.  <em>initial_response_ok</em> is
passed through to <a class="reference internal" href="#smtplib.SMTP.auth" title="smtplib.SMTP.auth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">auth()</span></code></a>.</p>
<p>Optional keyword argument <em>initial_response_ok</em> specifies whether, for
authentication methods that support it, an &quot;initial response&quot; as specified
in <span class="target" id="index-7"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4954.html"><strong>RFC 4954</strong></a> can be sent along with the <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> command, rather than
requiring a challenge/response.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a> may be raised, and the
<em>initial_response_ok</em> parameter was added.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.auth">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">auth</code><span class="sig-paren">(</span><em class="sig-param">mechanism</em>, <em class="sig-param">authobject</em>, <em class="sig-param">*</em>, <em class="sig-param">initial_response_ok=True</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.auth" title="정의 주소">¶</a></dt>
<dd><p>Issue an <code class="docutils literal notranslate"><span class="pre">SMTP</span></code> <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> command for the specified authentication
<em>mechanism</em>, and handle the challenge response via <em>authobject</em>.</p>
<p><em>mechanism</em> specifies which authentication mechanism is to
be used as argument to the <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> command; the valid values are
those listed in the <code class="docutils literal notranslate"><span class="pre">auth</span></code> element of <code class="xref py py-attr docutils literal notranslate"><span class="pre">esmtp_features</span></code>.</p>
<p><em>authobject</em> must be a callable object taking an optional single argument:</p>
<blockquote>
<div><p>data = authobject(challenge=None)</p>
</div></blockquote>
<p>If optional keyword argument <em>initial_response_ok</em> is true,
<code class="docutils literal notranslate"><span class="pre">authobject()</span></code> will be called first with no argument.  It can return the
<span class="target" id="index-8"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4954.html"><strong>RFC 4954</strong></a> &quot;initial response&quot; ASCII <code class="docutils literal notranslate"><span class="pre">str</span></code> which will be encoded and sent with
the <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> command as below.  If the <code class="docutils literal notranslate"><span class="pre">authobject()</span></code> does not support an
initial response (e.g. because it requires a challenge), it should return
<code class="docutils literal notranslate"><span class="pre">None</span></code> when called with <code class="docutils literal notranslate"><span class="pre">challenge=None</span></code>.  If <em>initial_response_ok</em> is
false, then <code class="docutils literal notranslate"><span class="pre">authobject()</span></code> will not be called first with <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>If the initial response check returns <code class="docutils literal notranslate"><span class="pre">None</span></code>, or if <em>initial_response_ok</em> is
false, <code class="docutils literal notranslate"><span class="pre">authobject()</span></code> will be called to process the server's challenge
response; the <em>challenge</em> argument it is passed will be a <code class="docutils literal notranslate"><span class="pre">bytes</span></code>.  It
should return ASCII <code class="docutils literal notranslate"><span class="pre">str</span></code> <em>data</em> that will be base64 encoded and sent to the
server.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">SMTP</span></code> class provides <code class="docutils literal notranslate"><span class="pre">authobjects</span></code> for the <code class="docutils literal notranslate"><span class="pre">CRAM-MD5</span></code>, <code class="docutils literal notranslate"><span class="pre">PLAIN</span></code>,
and <code class="docutils literal notranslate"><span class="pre">LOGIN</span></code> mechanisms; they are named <code class="docutils literal notranslate"><span class="pre">SMTP.auth_cram_md5</span></code>,
<code class="docutils literal notranslate"><span class="pre">SMTP.auth_plain</span></code>, and <code class="docutils literal notranslate"><span class="pre">SMTP.auth_login</span></code> respectively.  They all require
that the <code class="docutils literal notranslate"><span class="pre">user</span></code> and <code class="docutils literal notranslate"><span class="pre">password</span></code> properties of the <code class="docutils literal notranslate"><span class="pre">SMTP</span></code> instance are
set to appropriate values.</p>
<p>User code does not normally need to call <code class="docutils literal notranslate"><span class="pre">auth</span></code> directly, but can instead
call the <a class="reference internal" href="#smtplib.SMTP.login" title="smtplib.SMTP.login"><code class="xref py py-meth docutils literal notranslate"><span class="pre">login()</span></code></a> method, which will try each of the above mechanisms
in turn, in the order listed.  <code class="docutils literal notranslate"><span class="pre">auth</span></code> is exposed to facilitate the
implementation of authentication methods not (or not yet) supported
directly by <a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.starttls">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">starttls</code><span class="sig-paren">(</span><em class="sig-param">keyfile=None</em>, <em class="sig-param">certfile=None</em>, <em class="sig-param">context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.starttls" title="정의 주소">¶</a></dt>
<dd><p>Put the SMTP connection in TLS (Transport Layer Security) mode.  All SMTP
commands that follow will be encrypted.  You should then call <a class="reference internal" href="#smtplib.SMTP.ehlo" title="smtplib.SMTP.ehlo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ehlo()</span></code></a>
again.</p>
<p>If <em>keyfile</em> and <em>certfile</em> are provided, they are used to create an
<a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a>.</p>
<p>Optional <em>context</em> parameter is an <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> object; This is
an alternative to using a keyfile and a certfile and if specified both
<em>keyfile</em> and <em>certfile</em> should be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>If there has been no previous <code class="docutils literal notranslate"><span class="pre">EHLO</span></code> or <code class="docutils literal notranslate"><span class="pre">HELO</span></code> command this session,
this method tries ESMTP <code class="docutils literal notranslate"><span class="pre">EHLO</span></code> first.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.6부터 폐지: </span><em>keyfile</em>과 <em>certfile</em>은 폐지되었고 <em>context</em>로 대체되었습니다. 대신 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a>을 사용하거나, <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>가 시스템의 신뢰할 수 있는 CA 인증서를 선택하도록 하십시오.</p>
</div>
<dl class="simple">
<dt><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPHeloError</span></code></a></dt><dd><p>The server didn't reply properly to the <code class="docutils literal notranslate"><span class="pre">HELO</span></code> greeting.</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a></dt><dd><p>The server does not support the STARTTLS extension.</p>
</dd>
<dt><a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a></dt><dd><p>SSL/TLS support is not available to your Python interpreter.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><em>context</em>가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>The method now supports hostname check with
<code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.check_hostname</span></code> and <em>Server Name Indicator</em> (see
<a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_SNI</span></code></a>).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>The error raised for lack of STARTTLS support is now the
<a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a> subclass instead of the base
<a class="reference internal" href="#smtplib.SMTPException" title="smtplib.SMTPException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPException</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.sendmail">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">sendmail</code><span class="sig-paren">(</span><em class="sig-param">from_addr</em>, <em class="sig-param">to_addrs</em>, <em class="sig-param">msg</em>, <em class="sig-param">mail_options=()</em>, <em class="sig-param">rcpt_options=()</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.sendmail" title="정의 주소">¶</a></dt>
<dd><p>Send mail.  The required arguments are an <span class="target" id="index-9"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> from-address string, a list
of <span class="target" id="index-10"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> to-address strings (a bare string will be treated as a list with 1
address), and a message string.  The caller may pass a list of ESMTP options
(such as <code class="docutils literal notranslate"><span class="pre">8bitmime</span></code>) to be used in <code class="docutils literal notranslate"><span class="pre">MAIL</span> <span class="pre">FROM</span></code> commands as <em>mail_options</em>.
ESMTP options (such as <code class="docutils literal notranslate"><span class="pre">DSN</span></code> commands) that should be used with all <code class="docutils literal notranslate"><span class="pre">RCPT</span></code>
commands can be passed as <em>rcpt_options</em>.  (If you need to use different ESMTP
options to different recipients you have to use the low-level methods such as
<code class="xref py py-meth docutils literal notranslate"><span class="pre">mail()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">rcpt()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">data()</span></code> to send the message.)</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>The <em>from_addr</em> and <em>to_addrs</em> parameters are used to construct the message
envelope used by the transport agents.  <code class="docutils literal notranslate"><span class="pre">sendmail</span></code> does not modify the
message headers in any way.</p>
</div>
<p><em>msg</em> may be a string containing characters in the ASCII range, or a byte
string.  A string is encoded to bytes using the ascii codec, and lone <code class="docutils literal notranslate"><span class="pre">\r</span></code>
and <code class="docutils literal notranslate"><span class="pre">\n</span></code> characters are converted to <code class="docutils literal notranslate"><span class="pre">\r\n</span></code> characters.  A byte string is
not modified.</p>
<p>If there has been no previous <code class="docutils literal notranslate"><span class="pre">EHLO</span></code> or <code class="docutils literal notranslate"><span class="pre">HELO</span></code> command this session, this
method tries ESMTP <code class="docutils literal notranslate"><span class="pre">EHLO</span></code> first. If the server does ESMTP, message size and
each of the specified options will be passed to it (if the option is in the
feature set the server advertises).  If <code class="docutils literal notranslate"><span class="pre">EHLO</span></code> fails, <code class="docutils literal notranslate"><span class="pre">HELO</span></code> will be tried
and ESMTP options suppressed.</p>
<p>This method will return normally if the mail is accepted for at least one
recipient. Otherwise it will raise an exception.  That is, if this method does
not raise an exception, then someone should get your mail. If this method does
not raise an exception, it returns a dictionary, with one entry for each
recipient that was refused.  Each entry contains a tuple of the SMTP error code
and the accompanying error message sent by the server.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> is included in <em>mail_options</em>, and the server supports it,
<em>from_addr</em> and <em>to_addrs</em> may contain non-ASCII characters.</p>
<p>This method may raise the following exceptions:</p>
<dl class="simple">
<dt><a class="reference internal" href="#smtplib.SMTPRecipientsRefused" title="smtplib.SMTPRecipientsRefused"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPRecipientsRefused</span></code></a></dt><dd><p>All recipients were refused.  Nobody got the mail.  The <code class="xref py py-attr docutils literal notranslate"><span class="pre">recipients</span></code>
attribute of the exception object is a dictionary with information about the
refused recipients (like the one returned when at least one recipient was
accepted).</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPHeloError</span></code></a></dt><dd><p>The server didn't reply properly to the <code class="docutils literal notranslate"><span class="pre">HELO</span></code> greeting.</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPSenderRefused" title="smtplib.SMTPSenderRefused"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPSenderRefused</span></code></a></dt><dd><p>The server didn't accept the <em>from_addr</em>.</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPDataError" title="smtplib.SMTPDataError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPDataError</span></code></a></dt><dd><p>The server replied with an unexpected error code (other than a refusal of a
recipient).</p>
</dd>
<dt><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> was given in the <em>mail_options</em> but is not supported by the
server.</p>
</dd>
</dl>
<p>Unless otherwise noted, the connection will be open even after an exception is
raised.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.2에서 변경: </span><em>msg</em> may be a byte string.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> support added, and <a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a> may be
raised if <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> is specified but the server does not support it.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.send_message">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">send_message</code><span class="sig-paren">(</span><em class="sig-param">msg</em>, <em class="sig-param">from_addr=None</em>, <em class="sig-param">to_addrs=None</em>, <em class="sig-param">mail_options=()</em>, <em class="sig-param">rcpt_options=()</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.send_message" title="정의 주소">¶</a></dt>
<dd><p>This is a convenience method for calling <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a> with the message
represented by an <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.message.Message</span></code></a> object.  The arguments have
the same meaning as for <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a>, except that <em>msg</em> is a <code class="docutils literal notranslate"><span class="pre">Message</span></code>
object.</p>
<p>If <em>from_addr</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code> or <em>to_addrs</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">send_message</span></code> fills
those arguments with addresses extracted from the headers of <em>msg</em> as
specified in <span class="target" id="index-11"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>: <em>from_addr</em> is set to the <em class="mailheader">Sender</em>
field if it is present, and otherwise to the <em class="mailheader">From</em> field.
<em>to_addrs</em> combines the values (if any) of the <em class="mailheader">To</em>,
<em class="mailheader">Cc</em>, and <em class="mailheader">Bcc</em> fields from <em>msg</em>.  If exactly one
set of <em class="mailheader">Resent-*</em> headers appear in the message, the regular
headers are ignored and the <em class="mailheader">Resent-*</em> headers are used instead.
If the message contains more than one set of <em class="mailheader">Resent-*</em> headers,
a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised, since there is no way to unambiguously detect
the most recent set of <em class="mailheader">Resent-</em> headers.</p>
<p><code class="docutils literal notranslate"><span class="pre">send_message</span></code> serializes <em>msg</em> using
<a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a> with <code class="docutils literal notranslate"><span class="pre">\r\n</span></code> as the <em>linesep</em>, and
calls <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a> to transmit the resulting message.  Regardless of the
values of <em>from_addr</em> and <em>to_addrs</em>, <code class="docutils literal notranslate"><span class="pre">send_message</span></code> does not transmit any
<em class="mailheader">Bcc</em> or <em class="mailheader">Resent-Bcc</em> headers that may appear
in <em>msg</em>.  If any of the addresses in <em>from_addr</em> and <em>to_addrs</em> contain
non-ASCII characters and the server does not advertise <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> support,
an <code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupported</span></code> error is raised.  Otherwise the <code class="docutils literal notranslate"><span class="pre">Message</span></code> is
serialized with a clone of its <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> with the
<a class="reference internal" href="email.policy.html#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a> attribute set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, and
<code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> and <code class="docutils literal notranslate"><span class="pre">BODY=8BITMIME</span></code> are added to <em>mail_options</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가: </span>Support for internationalized addresses (<code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code>).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.quit">
<code class="sig-prename descclassname">SMTP.</code><code class="sig-name descname">quit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.quit" title="정의 주소">¶</a></dt>
<dd><p>Terminate the SMTP session and close the connection.  Return the result of
the SMTP <code class="docutils literal notranslate"><span class="pre">QUIT</span></code> command.</p>
</dd></dl>

<p>Low-level methods corresponding to the standard SMTP/ESMTP commands <code class="docutils literal notranslate"><span class="pre">HELP</span></code>,
<code class="docutils literal notranslate"><span class="pre">RSET</span></code>, <code class="docutils literal notranslate"><span class="pre">NOOP</span></code>, <code class="docutils literal notranslate"><span class="pre">MAIL</span></code>, <code class="docutils literal notranslate"><span class="pre">RCPT</span></code>, and <code class="docutils literal notranslate"><span class="pre">DATA</span></code> are also supported.
Normally these do not need to be called directly, so they are not documented
here.  For details, consult the module code.</p>
</div>
<div class="section" id="smtp-example">
<span id="id2"></span><h2>SMTP Example<a class="headerlink" href="#smtp-example" title="제목 주소">¶</a></h2>
<p>This example prompts the user for addresses needed in the message envelope ('To'
and 'From' addresses), and the message to be delivered.  Note that the headers
to be included with the message must be included in the message as entered; this
example doesn't do any processing of the <span class="target" id="index-12"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> headers.  In particular, the
'To' and 'From' addresses must be included in the message headers explicitly.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">smtplib</span>

<span class="k">def</span> <span class="nf">prompt</span><span class="p">(</span><span class="n">prompt</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">input</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

<span class="n">fromaddr</span> <span class="o">=</span> <span class="n">prompt</span><span class="p">(</span><span class="s2">&quot;From: &quot;</span><span class="p">)</span>
<span class="n">toaddrs</span>  <span class="o">=</span> <span class="n">prompt</span><span class="p">(</span><span class="s2">&quot;To: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter message, end with ^D (Unix) or ^Z (Windows):&quot;</span><span class="p">)</span>

<span class="c1"># Add the From: and To: headers at the start!</span>
<span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;From: </span><span class="si">%s</span><span class="se">\r\n</span><span class="s2">To: </span><span class="si">%s</span><span class="se">\r\n\r\n</span><span class="s2">&quot;</span>
       <span class="o">%</span> <span class="p">(</span><span class="n">fromaddr</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">toaddrs</span><span class="p">)))</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">+</span> <span class="n">line</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Message length is&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">set_debuglevel</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">sendmail</span><span class="p">(</span><span class="n">fromaddr</span><span class="p">,</span> <span class="n">toaddrs</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>In general, you will want to use the <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> package's features to
construct an email message, which you can then send
via <a class="reference internal" href="#smtplib.SMTP.send_message" title="smtplib.SMTP.send_message"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_message()</span></code></a>; see <a class="reference internal" href="email.examples.html#email-examples"><span class="std std-ref">email: 예제</span></a>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code> --- SMTP 프로토콜 클라이언트</a><ul>
<li><a class="reference internal" href="#smtp-objects">SMTP 객체</a></li>
<li><a class="reference internal" href="#smtp-example">SMTP Example</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="nntplib.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nntplib</span></code> --- NNTP protocol client</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="smtpd.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtpd</span></code> --- SMTP Server</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="smtpd.html" title="smtpd --- SMTP Server"
             >다음</a> |</li>
        <li class="right" >
          <a href="nntplib.html" title="nntplib --- NNTP protocol client"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>