
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>smtplib --- SMTP 프로토콜 클라이언트 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="smtpd --- SMTP Server" href="smtpd.html" />
    <link rel="prev" title="nntplib --- NNTP protocol client" href="nntplib.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/smtplib.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="smtpd.html" title="smtpd --- SMTP Server"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="nntplib.html" title="nntplib --- NNTP protocol client"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-smtplib">
<span id="smtplib-smtp-protocol-client"></span><h1><a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> --- SMTP 프로토콜 클라이언트<a class="headerlink" href="#module-smtplib" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/smtplib.py">Lib/smtplib.py</a></p>
<hr class="docutils" id="index-0" />
<p><a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> 모듈은 SMTP나 ESMTP 리스너 데몬을 사용하여 모든 인터넷 기계로 메일을 보내는 데 사용할 수 있는 SMTP 클라이언트 세션 객체를 정의합니다. SMTP와 ESMTP 연산에 대한 자세한 내용은 <span class="target" id="index-23"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc821.html"><strong>RFC 821</strong></a>(Simple Mail Transfer Protocol)과 <span class="target" id="index-24"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1869.html"><strong>RFC 1869</strong></a>(SMTP Service Extensions)를 참조하십시오.</p>
<dl class="class">
<dt id="smtplib.SMTP">
<em class="property">class </em><code class="descclassname">smtplib.</code><code class="descname">SMTP</code><span class="sig-paren">(</span><em>host=''</em>, <em>port=0</em>, <em>local_hostname=None</em>, <span class="optional">[</span><em>timeout</em>, <span class="optional">]</span><em>source_address=None</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 인스턴스는 SMTP 연결을 캡슐화합니다. SMTP와 ESMTP 연산의 전체 레퍼토리를 지원하는 메서드가 있습니다. 선택적 호스트와 포트 매개 변수가 제공되면, 초기화 중에 해당 매개 변수로 SMTP <a class="reference internal" href="#smtplib.SMTP.connect" title="smtplib.SMTP.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> 메서드가 호출됩니다. 지정되면, HELO/EHLO 명령에서 <em>local_hostname</em>이 로컬 호스트의 FQDN으로 사용됩니다. 그렇지 않으면 <a class="reference internal" href="socket.html#socket.getfqdn" title="socket.getfqdn"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.getfqdn()</span></code></a>을 사용하여 로컬 호스트 이름을 찾습니다. <a class="reference internal" href="#smtplib.SMTP.connect" title="smtplib.SMTP.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> 호출이 성공 코드 이외의 것을 반환하면 <a class="reference internal" href="#smtplib.SMTPConnectError" title="smtplib.SMTPConnectError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPConnectError</span></code></a>가 발생합니다. 선택적 <em>timeout</em> 매개 변수는 연결 시도와 같은 블로킹 연산을 위한 시간제한을 초로 지정합니다 (지정하지 않으면, 전역 기본 시간제한 설정이 사용됩니다). 시간제한이 만료되면 <a class="reference internal" href="socket.html#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.timeout</span></code></a>이 발생합니다. 선택적 source_address 매개 변수는 여러 네트워크 인터페이스가 있는 기계의 특정 소스 주소 그리고/또는 특정 소스 TCP 포트에 바인딩 할 수 있도록 합니다. 연결 전에 소켓이 소스 주소로 바인드 할 2-튜플 (host, port)를 취합니다. 생략되면 (또는 호스트나 포트가 각각 <code class="docutils literal notranslate"><span class="pre">''</span></code> 및/또는 0이면) OS 기본 동작이 사용됩니다.</p>
<p>일반적인 사용을 위해서는, 초기화/연결, <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a> 및 <a class="reference internal" href="#smtplib.SMTP.quit" title="smtplib.SMTP.quit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SMTP.quit()</span></code></a> 메서드 만 필요합니다. 아래에 예가 포함되어 있습니다.</p>
<p><a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 클래스는 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문을 지원합니다. 이처럼 사용되면, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 문이 종료될 때 SMTP <code class="docutils literal notranslate"><span class="pre">QUIT</span></code> 명령이 자동으로 발행됩니다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">smtplib</span> <span class="k">import</span> <span class="n">SMTP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">SMTP</span><span class="p">(</span><span class="s2">&quot;domain.org&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">smtp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">smtp</span><span class="o">.</span><span class="n">noop</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">(250, b&#39;Ok&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">data</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">smtplib.send</span></code>를 발생시킵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>source_address 인자가 추가되었습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가: </span>SMTPUTF8 확장(<span class="target" id="index-25"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6531.html"><strong>RFC 6531</strong></a>)이 이제 지원됩니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="smtplib.SMTP_SSL">
<em class="property">class </em><code class="descclassname">smtplib.</code><code class="descname">SMTP_SSL</code><span class="sig-paren">(</span><em>host=''</em>, <em>port=0</em>, <em>local_hostname=None</em>, <em>keyfile=None</em>, <em>certfile=None</em>, <span class="optional">[</span><em>timeout</em>, <span class="optional">]</span><em>context=None</em>, <em>source_address=None</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP_SSL" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#smtplib.SMTP_SSL" title="smtplib.SMTP_SSL"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP_SSL</span></code></a> 인스턴스는 <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 인스턴스와 정확히 같게 작동합니다. 연결 시작 시 SSL이 필요하고 <code class="xref py py-meth docutils literal notranslate"><span class="pre">starttls()</span></code> 사용이 적합하지 않은 상황에서는 <a class="reference internal" href="#smtplib.SMTP_SSL" title="smtplib.SMTP_SSL"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP_SSL</span></code></a>을 사용해야 합니다. <em>host</em>를 지정하지 않으면, 로컬 호스트가 사용됩니다. <em>port</em>가 0이면, 표준 SMTP-over-SSL 포트(465)가 사용됩니다. 선택적 인자 <em>local_hostname</em>, <em>timeout</em> 및 <em>source_address</em>는 <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 클래스에서와 같은 의미입니다. 역시 선택적인 <em>context</em>는 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>를 포함할 수 있으며 보안 연결의 다양한 측면을 구성하도록 합니다. 모범 사례는 <a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">보안 고려 사항</span></a>을 읽으십시오.</p>
<p><em>keyfile</em>과 <em>certfile</em>은 <em>context</em>의 레거시 대안이며, SSL 연결을 위한 PEM 형식 개인 키와 인증서 체인 파일을 가리킬 수 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><em>context</em>가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span>source_address 인자가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>이 클래스는 이제 <a class="reference internal" href="ssl.html#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ssl.SSLContext.check_hostname</span></code></a>과 <em>서버 이름 표시(Server Name Indication)</em>로 호스트 이름 확인을 지원합니다 (<a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal notranslate"><span class="pre">ssl.HAS_SNI</span></code></a>를 참조하십시오).</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">버전 3.6 폐지: </span><em>keyfile</em>과 <em>certfile</em>은 폐지되었고 <em>context</em>로 대체되었습니다. 대신 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a>을 사용하거나, <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>가 시스템의 신뢰할 수 있는 CA 인증서를 선택하도록 하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="smtplib.LMTP">
<em class="property">class </em><code class="descclassname">smtplib.</code><code class="descname">LMTP</code><span class="sig-paren">(</span><em>host=''</em>, <em>port=LMTP_PORT</em>, <em>local_hostname=None</em>, <em>source_address=None</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.LMTP" title="정의 주소">¶</a></dt>
<dd><p>ESMTP와 매우 유사한 LMTP 프로토콜은 표준 SMTP 클라이언트를 기반으로 합니다. LMTP에 유닉스 소켓을 사용하는 것이 일반적이라서, <code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code> 메서드는 일반 host:port 서버뿐만 아니라 이를 지원해야 합니다. 선택적 인자 local_hostname과 source_address는 <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 클래스에서와 같은 의미입니다. 유닉스 소켓을 지정하려면, <em>host</em>에 '/'로 시작하는 절대 경로를 사용해야 합니다.</p>
<p>일반 SMTP 메커니즘을 사용하여 인증이 지원됩니다. 유닉스 소켓을 사용할 때, LMTP는 일반적으로 인증을 지원하지 않거나 요구하지 않지만, 여러분의 상황에서는 다를 수 있습니다.</p>
</dd></dl>

<p>훌륭한 예외 모음도 정의되어 있습니다:</p>
<dl class="exception">
<dt id="smtplib.SMTPException">
<em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPException</code><a class="headerlink" href="#smtplib.SMTPException" title="정의 주소">¶</a></dt>
<dd><p>이 모듈에서 제공하는 다른 모든 예외에 대한 베이스 예외 클래스인 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 서브 클래스.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>SMTPException이 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>의 서브 클래스가 되었습니다.</p>
</div>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPServerDisconnected">
<em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPServerDisconnected</code><a class="headerlink" href="#smtplib.SMTPServerDisconnected" title="정의 주소">¶</a></dt>
<dd><p>이 예외는 예기치 않게 서버와의 연결이 끊어지거나, 서버에 연결하기 전에 <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 인스턴스를 사용하려고 할 때 발생합니다.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPResponseException">
<em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPResponseException</code><a class="headerlink" href="#smtplib.SMTPResponseException" title="정의 주소">¶</a></dt>
<dd><p>SMTP 에러 코드가 포함된 모든 예외의 베이스 클래스. 이러한 예외는 SMTP 서버가 에러 코드를 반환하는 일부 경우에 생성됩니다. 에러 코드는 에러의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">smtp_code</span></code> 어트리뷰트에 저장되며, <code class="xref py py-attr docutils literal notranslate"><span class="pre">smtp_error</span></code> 어트리뷰트는 에러 메시지로 설정됩니다.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPSenderRefused">
<em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPSenderRefused</code><a class="headerlink" href="#smtplib.SMTPSenderRefused" title="정의 주소">¶</a></dt>
<dd><p>발신자 주소가 거부되었습니다. 모든 <a class="reference internal" href="#smtplib.SMTPResponseException" title="smtplib.SMTPResponseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPResponseException</span></code></a> 예외에 의해 설정된 어트리뷰트 외에도, 이것은 'sender'를 SMTP 서버가 거부한 문자열로 설정합니다.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPRecipientsRefused">
<em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPRecipientsRefused</code><a class="headerlink" href="#smtplib.SMTPRecipientsRefused" title="정의 주소">¶</a></dt>
<dd><p>모든 수신자 주소가 거부되었습니다. 각 수신자의 에러는 <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SMTP.sendmail()</span></code></a>이 반환하는 것과 정확히 같은 종류의 딕셔너리인 <code class="xref py py-attr docutils literal notranslate"><span class="pre">recipients</span></code> 어트리뷰트를 통해 액세스 할 수 있습니다.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPDataError">
<em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPDataError</code><a class="headerlink" href="#smtplib.SMTPDataError" title="정의 주소">¶</a></dt>
<dd><p>SMTP 서버가 메시지 데이터 수락을 거부했습니다.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPConnectError">
<em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPConnectError</code><a class="headerlink" href="#smtplib.SMTPConnectError" title="정의 주소">¶</a></dt>
<dd><p>서버와의 연결을 설정하는 동안 에러가 발생했습니다.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPHeloError">
<em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPHeloError</code><a class="headerlink" href="#smtplib.SMTPHeloError" title="정의 주소">¶</a></dt>
<dd><p>서버가 <code class="docutils literal notranslate"><span class="pre">HELO</span></code> 메시지를 거부했습니다.</p>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPNotSupportedError">
<em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPNotSupportedError</code><a class="headerlink" href="#smtplib.SMTPNotSupportedError" title="정의 주소">¶</a></dt>
<dd><p>시도한 명령이나 옵션이 서버에서 지원되지 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="smtplib.SMTPAuthenticationError">
<em class="property">exception </em><code class="descclassname">smtplib.</code><code class="descname">SMTPAuthenticationError</code><a class="headerlink" href="#smtplib.SMTPAuthenticationError" title="정의 주소">¶</a></dt>
<dd><p>SMTP 인증이 잘못되었습니다. 서버가 제공된 username/password 조합을 수락하지 않았을 가능성이 높습니다.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<dl class="last docutils">
<dt><span class="target" id="index-4"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc821.html"><strong>RFC 821</strong></a> - Simple Mail Transfer Protocol</dt>
<dd>SMTP의 프로토콜 정의. 이 문서는 SMTP의 모델, 운영 절차 및 프로토콜 세부 사항을 다룹니다.</dd>
<dt><span class="target" id="index-5"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1869.html"><strong>RFC 1869</strong></a> - SMTP Service Extensions</dt>
<dd>SMTP를 위한 ESMTP 확장의 정의. 이 문서는 새로운 명령으로 SMTP를 확장하고 서버에서 제공하는 명령의 동적 발견을 지원하는 프레임워크에 관해 설명하고, 몇 가지 추가 명령을 정의합니다.</dd>
</dl>
</div>
<div class="section" id="smtp-objects">
<span id="id1"></span><h2>SMTP 객체<a class="headerlink" href="#smtp-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code></a> 인스턴스에는 다음과 같은 메서드가 있습니다:</p>
<dl class="method">
<dt id="smtplib.SMTP.set_debuglevel">
<code class="descclassname">SMTP.</code><code class="descname">set_debuglevel</code><span class="sig-paren">(</span><em>level</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.set_debuglevel" title="정의 주소">¶</a></dt>
<dd><p>디버그 출력 수준을 설정합니다. <em>level</em>의 값이 1이나 <code class="docutils literal notranslate"><span class="pre">True</span></code>이면 연결과 서버와 주고받는 모든 메시지에 대한 디버그 메시지가 생성됩니다. <em>level</em>의 값이 2이면 이러한 메시지에 타임 스탬프가 추가됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>디버그 수준 2를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.docmd">
<code class="descclassname">SMTP.</code><code class="descname">docmd</code><span class="sig-paren">(</span><em>cmd</em>, <em>args=''</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.docmd" title="정의 주소">¶</a></dt>
<dd><p>서버에 <em>cmd</em> 명령을 전송합니다. 선택적 인자 <em>args</em>는 단순히 공백으로 구분하여 명령에 이어붙입니다.</p>
<p>숫자 응답 코드와 실제 응답 줄로 구성된 2-튜플을 반환합니다 (여러 줄 응답은 하나의 긴 줄로 결합합니다).</p>
<p>일반적인 작업에서 이 메서드를 명시적으로 호출할 필요는 없습니다. 다른 메서드를 구현하는 데 사용되며 개인적인 확장을 테스트하는 데 유용할 수 있습니다.</p>
<p>응답을 기다리는 동안 서버와의 연결이 끊어지면, <a class="reference internal" href="#smtplib.SMTPServerDisconnected" title="smtplib.SMTPServerDisconnected"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPServerDisconnected</span></code></a> 가 발생합니다.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.connect">
<code class="descclassname">SMTP.</code><code class="descname">connect</code><span class="sig-paren">(</span><em>host='localhost'</em>, <em>port=0</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.connect" title="정의 주소">¶</a></dt>
<dd><p>지정된 포트(port)의 호스트(host)에 연결합니다. 기본값은 표준 SMTP 포트(25)로 로컬 호스트에 연결하는 것입니다. 호스트 이름이 콜론(<code class="docutils literal notranslate"><span class="pre">':'</span></code>)으로 끝나고 그 뒤에 숫자가 오면 해당 접미사가 제거되고 숫자는 사용할 포트 번호로 해석됩니다. 이 메서드는 인스턴스 화 중에 호스트가 지정되면 생성자에 의해 자동으로 호출됩니다. 연결 응답에서 서버가 보낸 응답 코드와 메시지의 2-튜플을 반환합니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">host</span></code>, <code class="docutils literal notranslate"><span class="pre">port</span></code>로 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">smtplib.connect</span></code>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.helo">
<code class="descclassname">SMTP.</code><code class="descname">helo</code><span class="sig-paren">(</span><em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.helo" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">HELO</span></code> 를 사용하여 SMTP 서버에 자신을 식별합니다. hostname 인자의 기본값은 로컬 호스트의 완전히 정규화된 도메인 이름(fully qualified domain name)입니다. 서버가 반환한 메시지는 객체의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">helo_resp</span></code> 어트리뷰트로 저장됩니다.</p>
<p>정상적인 작업에서는 이 메서드를 명시적으로 호출할 필요가 없습니다. 필요할 때 <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a>에 의해 묵시적으로 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.ehlo">
<code class="descclassname">SMTP.</code><code class="descname">ehlo</code><span class="sig-paren">(</span><em>name=''</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.ehlo" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">EHLO</span></code>를 사용하여 ESMTP 서버에 자신을 식별합니다. hostname 인자의 기본값은 로컬 호스트의 완전히 정규화된 도메인 이름(fully qualified domain name)입니다. ESMTP 옵션에 대한 응답을 검사하고 <a class="reference internal" href="#smtplib.SMTP.has_extn" title="smtplib.SMTP.has_extn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_extn()</span></code></a>에서 사용할 수 있도록 저장합니다. 또한 여러 정보 어트리뷰트를 설정합니다: 서버가 반환한 메시지는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ehlo_resp</span></code> 어트리뷰트로 저장되고, 서버가 ESMTP를 지원하는지에 따라 <code class="xref py py-attr docutils literal notranslate"><span class="pre">does_esmtp</span></code>가 참이나 거짓으로 설정되며, <code class="xref py py-attr docutils literal notranslate"><span class="pre">esmtp_features</span></code>는 이 서버가 지원하는 SMTP 서비스 확장의 이름과 그 매개 변수(있다면)를 포함하는 딕셔너리가 됩니다.</p>
<p>메일을 보내기 전에 <a class="reference internal" href="#smtplib.SMTP.has_extn" title="smtplib.SMTP.has_extn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_extn()</span></code></a>을 사용하고 싶지 않은 한, 이 메서드를 명시적으로 호출할 필요는 없습니다. 필요할 때 <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a>에 의해 묵시적으로 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.ehlo_or_helo_if_needed">
<code class="descclassname">SMTP.</code><code class="descname">ehlo_or_helo_if_needed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.ehlo_or_helo_if_needed" title="정의 주소">¶</a></dt>
<dd><p>이 세션에서 앞선 <code class="docutils literal notranslate"><span class="pre">EHLO</span></code>나 <code class="docutils literal notranslate"><span class="pre">HELO</span></code> 명령이 없으면, 이 메서드는 <a class="reference internal" href="#smtplib.SMTP.ehlo" title="smtplib.SMTP.ehlo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ehlo()</span></code></a> 및/또는 <a class="reference internal" href="#smtplib.SMTP.helo" title="smtplib.SMTP.helo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">helo()</span></code></a>를 호출합니다. ESMTP <code class="docutils literal notranslate"><span class="pre">EHLO</span></code>를 먼저 시도합니다.</p>
<dl class="docutils">
<dt><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPHeloError</span></code></a></dt>
<dd>서버가 <code class="docutils literal notranslate"><span class="pre">HELO</span></code> 인사에 올바르게 응답하지 않았습니다.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.has_extn">
<code class="descclassname">SMTP.</code><code class="descname">has_extn</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.has_extn" title="정의 주소">¶</a></dt>
<dd><p><em>name</em>이 서버가 반환한 SMTP 서비스 확장 집합에 있으면 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>를 반환합니다. 대소 문자는 무시됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.verify">
<code class="descclassname">SMTP.</code><code class="descname">verify</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.verify" title="정의 주소">¶</a></dt>
<dd><p>SMTP <code class="docutils literal notranslate"><span class="pre">VRFY</span></code>를 사용하여 이 서버에서 주소의 유효성을 확인합니다. 사용자 주소가 유효하면 코드 250과 전체 <span class="target" id="index-26"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> 주소(사람 이름 포함)로 구성된 튜플을 반환합니다. 그렇지 않으면 400 이상의 SMTP 에러 코드와 에러 문자열을 반환합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">많은 사이트에서 스패머를 제거하기 위해 SMTP <code class="docutils literal notranslate"><span class="pre">VRFY</span></code>를 비활성화합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.login">
<code class="descclassname">SMTP.</code><code class="descname">login</code><span class="sig-paren">(</span><em>user</em>, <em>password</em>, <em>*</em>, <em>initial_response_ok=True</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.login" title="정의 주소">¶</a></dt>
<dd><p>인증이 필요한 SMTP 서버에 로그인합니다. 인자는 인증할 사용자 이름과 비밀번호입니다. 이 세션에 앞선 <code class="docutils literal notranslate"><span class="pre">EHLO</span></code>나 <code class="docutils literal notranslate"><span class="pre">HELO</span></code> 명령이 없었으면, 이 메서드는 ESMTP <code class="docutils literal notranslate"><span class="pre">EHLO</span></code>를 먼저 시도합니다. 인증에 성공하면 이 메서드는 정상적으로 반환하고, 그렇지 않으면 다음 예외를 발생시킬 수 있습니다:</p>
<dl class="docutils">
<dt><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPHeloError</span></code></a></dt>
<dd>서버가 <code class="docutils literal notranslate"><span class="pre">HELO</span></code> 인사에 올바르게 응답하지 않았습니다.</dd>
<dt><a class="reference internal" href="#smtplib.SMTPAuthenticationError" title="smtplib.SMTPAuthenticationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPAuthenticationError</span></code></a></dt>
<dd>서버가 사용자 이름/비밀번호 조합을 수락하지 않았습니다.</dd>
<dt><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a></dt>
<dd>서버가 <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> 명령을 지원하지 않습니다.</dd>
<dt><a class="reference internal" href="#smtplib.SMTPException" title="smtplib.SMTPException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPException</span></code></a></dt>
<dd>적합한 인증 메서드가 없습니다.</dd>
</dl>
<p><a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a>가 지원하는 각 인증 메서드는 서버가 지원하는 것으로 광고되면 차례로 시도됩니다. 지원되는 인증 메서드 목록은 <a class="reference internal" href="#smtplib.SMTP.auth" title="smtplib.SMTP.auth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">auth()</span></code></a>를 참조하십시오. <em>initial_response_ok</em>는 <a class="reference internal" href="#smtplib.SMTP.auth" title="smtplib.SMTP.auth"><code class="xref py py-meth docutils literal notranslate"><span class="pre">auth()</span></code></a>로 전달됩니다.</p>
<p>선택적 키워드 인자 <em>initial_response_ok</em>는, 이를 지원하는 인증 메서드의 경우, 챌린지/응답을 요구하지 않고 <span class="target" id="index-27"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4954.html"><strong>RFC 4954</strong></a>에 지정된 &quot;초기 응답(initial response)&quot;을 <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> 명령과 함께 보낼 수 있는지를 지정합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a> 가 발생할 수 있고, <em>initial_response_ok</em> 매개 변수가 추가되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.auth">
<code class="descclassname">SMTP.</code><code class="descname">auth</code><span class="sig-paren">(</span><em>mechanism</em>, <em>authobject</em>, <em>*</em>, <em>initial_response_ok=True</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.auth" title="정의 주소">¶</a></dt>
<dd><p>지정된 인증 <em>메커니즘(mechanism)</em>으로 <code class="docutils literal notranslate"><span class="pre">SMTP</span></code> <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> 명령을 발행하고, <em>authobject</em>를 통해 챌린지 응답을 처리합니다.</p>
<p><em>mechanism</em>은 <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> 명령의 인자로 사용할 인증 메커니즘을 지정합니다; 유효한 값은 <code class="xref py py-attr docutils literal notranslate"><span class="pre">esmtp_features</span></code>의 <code class="docutils literal notranslate"><span class="pre">auth</span></code> 요소에 나열된 값입니다.</p>
<p><em>authobject</em>는 선택적 단일 인자를 취하는 콜러블 객체여야 합니다:</p>
<blockquote>
<div>data = authobject(challenge=None)</div></blockquote>
<p>선택적 키워드 인자 <em>initial_response_ok</em>가 참이면, 인자 없이 <code class="docutils literal notranslate"><span class="pre">authobject()</span></code>가 먼저 호출됩니다. 이것은 <span class="target" id="index-28"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4954.html"><strong>RFC 4954</strong></a> &quot;초기 응답(initial response)&quot; ASCII <code class="docutils literal notranslate"><span class="pre">str</span></code>을 반환할 수 있으며, 이는 아래와 같이 <code class="docutils literal notranslate"><span class="pre">AUTH</span></code> 명령으로 인코딩되고 전송됩니다. <code class="docutils literal notranslate"><span class="pre">authobject()</span></code>가 초기 응답을 지원하지 않으면 (예를 들어 챌린지가 필요하기 때문에), <code class="docutils literal notranslate"><span class="pre">challenge=None</span></code>으로 호출될 때 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환해야 합니다. <em>initial_response_ok</em>가 거짓이면, <code class="docutils literal notranslate"><span class="pre">authobject()</span></code>는 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 먼저 호출되지 않습니다.</p>
<p>초기 응답 확인이 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환하거나, <em>initial_response_ok</em>가 거짓이면, 서버의 챌린지 응답을 처리하기 위해 <code class="docutils literal notranslate"><span class="pre">authobject()</span></code>가 호출됩니다; 전달된 <em>challenge</em> 인자는 <code class="docutils literal notranslate"><span class="pre">bytes</span></code>입니다. base64로 인코딩되어 서버로 전송될 ASCII <code class="docutils literal notranslate"><span class="pre">str</span></code> <em>data</em>를 반환해야 합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">SMTP</span></code> 클래스는 <code class="docutils literal notranslate"><span class="pre">CRAM-MD5</span></code>, <code class="docutils literal notranslate"><span class="pre">PLAIN</span></code> 및 <code class="docutils literal notranslate"><span class="pre">LOGIN</span></code> 메커니즘을 위한 <code class="docutils literal notranslate"><span class="pre">authobjects</span></code>를 제공합니다. 그것들은 각각 <code class="docutils literal notranslate"><span class="pre">SMTP.auth_cram_md5</span></code>, <code class="docutils literal notranslate"><span class="pre">SMTP.auth_plain</span></code> 및 <code class="docutils literal notranslate"><span class="pre">SMTP.auth_login</span></code>으로 명명됩니다. 모두 <code class="docutils literal notranslate"><span class="pre">SMTP</span></code> 인스턴스의 <code class="docutils literal notranslate"><span class="pre">user</span></code>와 <code class="docutils literal notranslate"><span class="pre">password</span></code> 프로퍼티가 적절한 값으로 설정되어 있도록 요구합니다.</p>
<p>사용자 코드는 일반적으로 <code class="docutils literal notranslate"><span class="pre">auth</span></code>를 직접 호출할 필요는 없지만, 대신 <a class="reference internal" href="#smtplib.SMTP.login" title="smtplib.SMTP.login"><code class="xref py py-meth docutils literal notranslate"><span class="pre">login()</span></code></a> 메서드를 호출할 수는 있는데, 위의 각 메커니즘을 나열된 순서대로 시도합니다. <code class="docutils literal notranslate"><span class="pre">auth</span></code>는 <a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a>가 직접 지원하지 않는 (또는 아직 지원하지 않는) 인증 메서드를 쉽게 구현할 수 있도록 노출되어 있습니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.starttls">
<code class="descclassname">SMTP.</code><code class="descname">starttls</code><span class="sig-paren">(</span><em>keyfile=None</em>, <em>certfile=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.starttls" title="정의 주소">¶</a></dt>
<dd><p>SMTP 연결을 TLS (Transport Layer Security) 모드로 전환합니다. 뒤따르는 모든 SMTP 명령은 암호화됩니다. 그런 다음 <a class="reference internal" href="#smtplib.SMTP.ehlo" title="smtplib.SMTP.ehlo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ehlo()</span></code></a>를 다시 호출해야 합니다.</p>
<p><em>keyfile</em>과 <em>certfile</em>이 제공되면, <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a>를 만드는 데 사용됩니다.</p>
<p>선택적 <em>context</em> 매개 변수는 <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 객체입니다; 이것은 keyfile과 certfile대신 사용할 수 있으며 <em>keyfile</em>과 <em>certfile</em>이 모두 지정되면 <code class="docutils literal notranslate"><span class="pre">None</span></code>이어야 합니다.</p>
<p>이 세션에 앞선 <code class="docutils literal notranslate"><span class="pre">EHLO</span></code>나 <code class="docutils literal notranslate"><span class="pre">HELO</span></code> 명령이 없었으면, 이 메서드는 ESMTP <code class="docutils literal notranslate"><span class="pre">EHLO</span></code>를 먼저 시도합니다.</p>
<div class="deprecated">
<p><span class="versionmodified">버전 3.6 폐지: </span><em>keyfile</em>과 <em>certfile</em>은 폐지되었고 <em>context</em>로 대체되었습니다. 대신 <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a>을 사용하거나, <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>가 시스템의 신뢰할 수 있는 CA 인증서를 선택하도록 하십시오.</p>
</div>
<dl class="docutils">
<dt><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPHeloError</span></code></a></dt>
<dd>서버가 <code class="docutils literal notranslate"><span class="pre">HELO</span></code> 인사에 올바르게 응답하지 않았습니다.</dd>
<dt><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a></dt>
<dd>서버가 STARTTLS 확장을 지원하지 않습니다.</dd>
<dt><a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a></dt>
<dd>파이썬 인터프리터가 SSL/TLS를 지원하지 않습니다.</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><em>context</em>가 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>이 메서드는 이제 <code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.check_hostname</span></code>과 <em>서버 이름 표시(Server Name Indicator)</em>로 호스트 이름 확인을 지원합니다 (<a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_SNI</span></code></a>를 참조하십시오).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>STARTTLS 지원 부족으로 발생한 에러는 이제 베이스 <a class="reference internal" href="#smtplib.SMTPException" title="smtplib.SMTPException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPException</span></code></a> 대신 <a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a> 서브 클래스입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.sendmail">
<code class="descclassname">SMTP.</code><code class="descname">sendmail</code><span class="sig-paren">(</span><em>from_addr</em>, <em>to_addrs</em>, <em>msg</em>, <em>mail_options=()</em>, <em>rcpt_options=()</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.sendmail" title="정의 주소">¶</a></dt>
<dd><p>메일을 보냅니다. 필수 인자는 <span class="target" id="index-29"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> from-address 문자열, <span class="target" id="index-30"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> to-address 문자열의 리스트 (단순 문자열은 주소가 한 개인 리스트로 처리됩니다) 및 메시지 문자열입니다. 호출자는 <code class="docutils literal notranslate"><span class="pre">MAIL</span> <span class="pre">FROM</span></code> 명령에 사용되는 ESMTP 옵션 (가령 <code class="docutils literal notranslate"><span class="pre">8bitmime</span></code>) 리스트를 <em>mail_options</em>로 전달할 수 있습니다. 모든 <code class="docutils literal notranslate"><span class="pre">RCPT</span></code> 명령과 함께 사용해야 하는 ESMTP 옵션(가령 <code class="docutils literal notranslate"><span class="pre">DSN</span></code> 명령)을 <em>rcpt_options</em>로 전달할 수 있습니다. (다른 수신자에게 다른 ESMTP 옵션을 사용해야 하면 메시지를 보내는 데 <code class="xref py py-meth docutils literal notranslate"><span class="pre">mail()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">rcpt()</span></code> 및 <code class="xref py py-meth docutils literal notranslate"><span class="pre">data()</span></code>와 같은 저수준 메서드를 사용해야 합니다.)</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><em>from_addr</em>과 <em>to_addrs</em> 매개 변수는 전송 에이전트가 사용하는 메시지 봉투(envelope)를 구성하는 데 사용됩니다. <code class="docutils literal notranslate"><span class="pre">sendmail</span></code>은 어떤 방식으로든 메시지 헤더를 수정하지 않습니다.</p>
</div>
<p><em>msg</em>는 ASCII 범위의 문자를 포함하는 문자열이거나, 바이트 문자열일 수 있습니다. 문자열은 ascii 코덱을 사용하여 바이트열로 인코딩되며, 독립된 <code class="docutils literal notranslate"><span class="pre">\r</span></code>과 <code class="docutils literal notranslate"><span class="pre">\n</span></code> 문자는 <code class="docutils literal notranslate"><span class="pre">\r\n</span></code> 문자로 변환됩니다. 바이트 문자열은 수정되지 않습니다.</p>
<p>이 세션에 앞선 <code class="docutils literal notranslate"><span class="pre">EHLO</span></code>나 <code class="docutils literal notranslate"><span class="pre">HELO</span></code> 명령이 없었으면, 이 메서드는 ESMTP <code class="docutils literal notranslate"><span class="pre">EHLO</span></code>를 먼저 시도합니다. 서버가 ESMTP를 지원하면, 메시지 크기와 지정된 각 옵션이 전달됩니다 (옵션이 서버가 광고한 기능 집합에 있다면). <code class="docutils literal notranslate"><span class="pre">EHLO</span></code>가 실패하면, <code class="docutils literal notranslate"><span class="pre">HELO</span></code>가 시도되고 ESMTP 옵션이 억제됩니다.</p>
<p>이 메서드는 적어도 한 명의 수신자에게 메일이 수락되면 정상적으로 반환됩니다. 그렇지 않으면 예외가 발생합니다. 즉, 이 메서드로 예외가 발생하지 않으면 누군가 메일을 받아야 합니다. 이 메서드에서 예외가 발생하지 않으면, 거부된 각 수신자에 대해 하나의 항목이 있는 딕셔너리를 반환합니다. 각 항목에는 서버에서 보낸 SMTP 에러 코드와 해당 에러 메시지의 튜플이 포함됩니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code>이 <em>mail_options</em>에 포함되어 있고, 서버가 이를 지원하면, <em>from_addr</em>과 <em>to_addrs</em>는 ASCII가 아닌 문자를 포함할 수 있습니다.</p>
<p>이 메서드는 다음과 같은 예외를 발생시킬 수 있습니다:</p>
<dl class="docutils">
<dt><a class="reference internal" href="#smtplib.SMTPRecipientsRefused" title="smtplib.SMTPRecipientsRefused"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPRecipientsRefused</span></code></a></dt>
<dd>모든 수신자가 거부되었습니다. 아무도 메일을 받지 못했습니다. 예외 객체의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">recipients</span></code> 어트리뷰트는 거부된 수신자에 대한 정보가 있는 딕셔너리입니다 (적어도 한 명의 수신자가 수락되었을 때 반환되는 것과 같습니다).</dd>
<dt><a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPHeloError</span></code></a></dt>
<dd>서버가 <code class="docutils literal notranslate"><span class="pre">HELO</span></code> 인사에 올바르게 응답하지 않았습니다.</dd>
<dt><a class="reference internal" href="#smtplib.SMTPSenderRefused" title="smtplib.SMTPSenderRefused"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPSenderRefused</span></code></a></dt>
<dd>서버가 <em>from_addr</em>을 수락하지 않았습니다.</dd>
<dt><a class="reference internal" href="#smtplib.SMTPDataError" title="smtplib.SMTPDataError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPDataError</span></code></a></dt>
<dd>서버가 예기치 않은 에러 코드(수신자 거부는 제외하고)로 응답했습니다.</dd>
<dt><a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a></dt>
<dd><code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code>이 <em>mail_options</em>에 제공되었지만, 서버에서 지원되지 않습니다.</dd>
</dl>
<p>달리 명시되지 않는 한, 예외가 발생한 후에도 연결은 열려있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><em>msg</em>는 바이트 문자열일 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span><code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> 지원이 추가되었으며, <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code>이 지정되었지만, 서버가 지원하지 않으면 <a class="reference internal" href="#smtplib.SMTPNotSupportedError" title="smtplib.SMTPNotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupportedError</span></code></a> 가 발생할 수 있습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.send_message">
<code class="descclassname">SMTP.</code><code class="descname">send_message</code><span class="sig-paren">(</span><em>msg</em>, <em>from_addr=None</em>, <em>to_addrs=None</em>, <em>mail_options=()</em>, <em>rcpt_options=()</em><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.send_message" title="정의 주소">¶</a></dt>
<dd><p>이는 <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.message.Message</span></code></a> 객체로 표현되는 메시지로 <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a>을 호출하는 편의 메서드입니다. 인자는 <em>msg</em>가 <code class="docutils literal notranslate"><span class="pre">Message</span></code> 객체라는 점을 제외하고 <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a>과 같은 의미입니다.</p>
<p><em>from_addr</em>이 <code class="docutils literal notranslate"><span class="pre">None</span></code>이거나 <em>to_addrs</em>가 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면, <code class="docutils literal notranslate"><span class="pre">send_message</span></code>는 <span class="target" id="index-31"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a> 에 지정된 대로 <em>msg</em>의 헤더에서 추출된 주소로 해당 인자를 채웁니다: <em>from_addr</em>은 <em class="mailheader">Sender</em> 필드가 있으면 이것으로 설정되고, 그렇지 않으면 <em class="mailheader">From</em> 필드로 설정됩니다. <em>to_addrs</em>는 (있다면) <em>msg</em>의 <em class="mailheader">To</em>, <em class="mailheader">Cc</em> 및 <em class="mailheader">Bcc</em> 필드 값을 결합합니다. 정확히 하나의 <em class="mailheader">Resent-*</em> 헤더 집합이 메시지에 등장하면, 일반 헤더는 무시되고 <em class="mailheader">Resent-*</em> 헤더가 대신 사용됩니다. 메시지에 둘 이상의 <em class="mailheader">Resent-*</em> 헤더 집합이 포함되면, 가장 최근의 <em class="mailheader">Resent-</em> 헤더 집합을 모호하지 않게 감지할 방법이 없어서 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">send_message</span></code>는 <code class="docutils literal notranslate"><span class="pre">\r\n</span></code>을 <em>linesep</em>으로 사용하여 <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a>를 통해 <em>msg</em>를 직렬화하고, <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmail()</span></code></a>을 호출하여 결과 메시지를 전송합니다. <em>from_addr</em>과 <em>to_addrs</em>의 값과 관계없이 <code class="docutils literal notranslate"><span class="pre">send_message</span></code>는 <em>msg</em>에 나타날 수 있는 <em class="mailheader">Bcc</em>나 <em class="mailheader">Resent-Bcc</em> 헤더를 전송하지 않습니다. <em>from_addr</em>과 <em>to_addrs</em>의 주소 중 하나에 ASCII가 아닌 문자가 포함되어 있고 서버가 <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> 지원을 광고하지 않으면, <code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPNotSupported</span></code> 에러가 발생합니다. 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">Message</span></code>는 <a class="reference internal" href="email.policy.html#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a> 어트리뷰트가 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정된 자신의 <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a>의 복제본으로 직렬화되고, <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> 과 <code class="docutils literal notranslate"><span class="pre">BODY=8BITMIME</span></code>이 <em>mail_options</em>에 추가됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.5에 추가: </span>국제화된 주소 (<code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code>) 지원.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="smtplib.SMTP.quit">
<code class="descclassname">SMTP.</code><code class="descname">quit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#smtplib.SMTP.quit" title="정의 주소">¶</a></dt>
<dd><p>SMTP 세션을 종료하고 연결을 닫습니다. SMTP <code class="docutils literal notranslate"><span class="pre">QUIT</span></code> 명령의 결과를 반환합니다.</p>
</dd></dl>

<p>표준 SMTP/ESMTP 명령 <code class="docutils literal notranslate"><span class="pre">HELP</span></code>, <code class="docutils literal notranslate"><span class="pre">RSET</span></code>, <code class="docutils literal notranslate"><span class="pre">NOOP</span></code>, <code class="docutils literal notranslate"><span class="pre">MAIL</span></code>, <code class="docutils literal notranslate"><span class="pre">RCPT</span></code> 및 <code class="docutils literal notranslate"><span class="pre">DATA</span></code>에 해당하는 저수준 메서드도 지원됩니다. 일반적으로 이들은 직접 호출할 필요가 없어서, 여기에 설명되어 있지 않습니다. 자세한 내용은, 모듈 코드를 참조하십시오.</p>
</div>
<div class="section" id="smtp-example">
<span id="id2"></span><h2>SMTP 예<a class="headerlink" href="#smtp-example" title="제목 주소">¶</a></h2>
<p>이 예에서는 메시지 봉투(envelope)에 필요한 주소('To'와 'From' 주소)와 전달할 메시지를 사용자에게 요구합니다. 메시지에 포함할 헤더는 입력한 대로 메시지에 포함됨에 유의하십시오; 이 예제는 <span class="target" id="index-32"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html"><strong>RFC 822</strong></a> 헤더를 처리하지 않습니다. 특히, 'To'와 'From' 주소는 메시지 헤더에 명시적으로 포함되어야 합니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">smtplib</span>

<span class="k">def</span> <span class="nf">prompt</span><span class="p">(</span><span class="n">prompt</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">input</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

<span class="n">fromaddr</span> <span class="o">=</span> <span class="n">prompt</span><span class="p">(</span><span class="s2">&quot;From: &quot;</span><span class="p">)</span>
<span class="n">toaddrs</span>  <span class="o">=</span> <span class="n">prompt</span><span class="p">(</span><span class="s2">&quot;To: &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter message, end with ^D (Unix) or ^Z (Windows):&quot;</span><span class="p">)</span>

<span class="c1"># From: 과 To: 헤더를 시작에 넣습니다!</span>
<span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;From: </span><span class="si">%s</span><span class="se">\r\n</span><span class="s2">To: </span><span class="si">%s</span><span class="se">\r\n\r\n</span><span class="s2">&quot;</span>
       <span class="o">%</span> <span class="p">(</span><span class="n">fromaddr</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">toaddrs</span><span class="p">)))</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">+</span> <span class="n">line</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Message length is&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

<span class="n">server</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">set_debuglevel</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">sendmail</span><span class="p">(</span><span class="n">fromaddr</span><span class="p">,</span> <span class="n">toaddrs</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
<span class="n">server</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">일반적으로, <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 패키지의 기능을 사용하여 전자 메일 메시지를 만들고자 할 것이고, 그런 다음 <a class="reference internal" href="#smtplib.SMTP.send_message" title="smtplib.SMTP.send_message"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_message()</span></code></a>를 통해 보낼 수 있습니다; <a class="reference internal" href="email.examples.html#email-examples"><span class="std std-ref">email: 예제</span></a>를 참조하십시오.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">smtplib</span></code> --- SMTP 프로토콜 클라이언트</a><ul>
<li><a class="reference internal" href="#smtp-objects">SMTP 객체</a></li>
<li><a class="reference internal" href="#smtp-example">SMTP 예</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="nntplib.html"
                        title="이전 장"><code class="docutils literal notranslate"><span class="pre">nntplib</span></code> --- NNTP protocol client</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="smtpd.html"
                        title="다음 장"><code class="docutils literal notranslate"><span class="pre">smtpd</span></code> --- SMTP Server</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="smtpd.html" title="smtpd --- SMTP Server"
             >다음</a> |</li>
        <li class="right" >
          <a href="nntplib.html" title="nntplib --- NNTP protocol client"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >인터넷 프로토콜과 지원</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>