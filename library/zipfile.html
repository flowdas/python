
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>zipfile --- ZIP 아카이브 작업 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="tarfile --- tar 아카이브 파일 읽기와 쓰기" href="tarfile.html" />
    <link rel="prev" title="lzma --- LZMA 알고리즘을 사용한 압축" href="lzma.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/zipfile.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="tarfile.html" title="tarfile --- tar 아카이브 파일 읽기와 쓰기"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="lzma.html" title="lzma --- LZMA 알고리즘을 사용한 압축"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="archiving.html" accesskey="U">데이터 압축 및 보관</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-zipfile">
<span id="zipfile-work-with-zip-archives"></span><h1><a class="reference internal" href="#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> --- ZIP 아카이브 작업<a class="headerlink" href="#module-zipfile" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/zipfile.py">Lib/zipfile.py</a></p>
<hr class="docutils" />
<p>ZIP 파일 형식은 흔히 쓰이는 아카이브와 압축 표준입니다. 이 모듈은 ZIP 파일을 만들고, 읽고, 쓰고, 추가하고, 나열하는 도구를 제공합니다. 이 모듈의 고급 사용을 위해서는 <a class="reference external" href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT">PKZIP Application Note</a>에 정의된 형식의 이해가 필요합니다.</p>
<p>이 모듈은 현재 다중 디스크 ZIP 파일을 처리하지 않습니다. ZIP64 확장을 사용하는 ZIP 파일(즉, 크기가 4GiB 이상인 ZIP 파일)을 처리할 수 있습니다. ZIP 아카이브에 있는 암호화된 파일의 암호 해독을 지원하지만, 현재 암호화된 파일을 만들 수는 없습니다. C가 아닌 네이티브 파이썬으로 구현되므로 해독 속도가 매우 느립니다.</p>
<p>이 모듈은 다음 항목을 정의합니다:</p>
<dl class="exception">
<dt id="zipfile.BadZipFile">
<em class="property">exception </em><code class="descclassname">zipfile.</code><code class="descname">BadZipFile</code><a class="headerlink" href="#zipfile.BadZipFile" title="정의 주소">¶</a></dt>
<dd><p>잘못된 ZIP 파일로 인해 발생하는 에러.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="zipfile.BadZipfile">
<em class="property">exception </em><code class="descclassname">zipfile.</code><code class="descname">BadZipfile</code><a class="headerlink" href="#zipfile.BadZipfile" title="정의 주소">¶</a></dt>
<dd><p>이전 파이썬 버전과의 호환성을 위한, <a class="reference internal" href="#zipfile.BadZipFile" title="zipfile.BadZipFile"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BadZipFile</span></code></a>의 별칭.</p>
<div class="deprecated">
<p><span class="versionmodified">버전 3.2 폐지.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="zipfile.LargeZipFile">
<em class="property">exception </em><code class="descclassname">zipfile.</code><code class="descname">LargeZipFile</code><a class="headerlink" href="#zipfile.LargeZipFile" title="정의 주소">¶</a></dt>
<dd><p>ZIP 파일에 ZIP64 기능이 필요하지만 활성화되지 않았을 때 발생하는 에러.</p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">zipfile.</code><code class="descname">ZipFile</code></dt>
<dd><p>ZIP 파일을 읽고 쓰는 클래스. 생성자 세부 사항은 <a class="reference internal" href="#zipfile-objects"><span class="std std-ref">ZipFile 객체</span></a> 섹션을 참조하십시오.</p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">zipfile.</code><code class="descname">Path</code></dt>
<dd><p>zip 파일을 위한 pathlib 호환 래퍼. 자세한 내용은 <a class="reference internal" href="#path-objects"><span class="std std-ref">Path 객체</span></a> 섹션을 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">zipfile.</code><code class="descname">PyZipFile</code></dt>
<dd><p>파이썬 라이브러리를 포함하는 ZIP 아카이브를 만들기 위한 클래스.</p>
</dd></dl>

<dl class="class">
<dt id="zipfile.ZipInfo">
<em class="property">class </em><code class="descclassname">zipfile.</code><code class="descname">ZipInfo</code><span class="sig-paren">(</span><em>filename='NoName'</em>, <em>date_time=(1980</em>, <em>1</em>, <em>1</em>, <em>0</em>, <em>0</em>, <em>0)</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipInfo" title="정의 주소">¶</a></dt>
<dd><p>아카이브 멤버에 관한 정보를 나타내는 데 사용되는 클래스. 이 클래스의 인스턴스는 <a class="reference internal" href="#zipfile.ZipFile" title="zipfile.ZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipFile</span></code></a> 객체의 <a class="reference internal" href="#zipfile.ZipFile.getinfo" title="zipfile.ZipFile.getinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getinfo()</span></code></a>와 <a class="reference internal" href="#zipfile.ZipFile.infolist" title="zipfile.ZipFile.infolist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">infolist()</span></code></a> 메서드에 의해 반환됩니다. <a class="reference internal" href="#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> 모듈의 대부분 사용자는 이것들을 만들 필요는 없고, 이 모듈에서 만든 것들을 사용하기만 합니다. <em>filename</em>은 아카이브 멤버의 전체 이름이어야 하고, <em>date_time</em>은 파일을 마지막으로 수정한 시간을 기술하는 6개의 필드를 포함하는 튜플이어야 합니다; 필드는 <a class="reference internal" href="#zipinfo-objects"><span class="std std-ref">ZipInfo 객체</span></a> 섹션에 설명되어 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="zipfile.is_zipfile">
<code class="descclassname">zipfile.</code><code class="descname">is_zipfile</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.is_zipfile" title="정의 주소">¶</a></dt>
<dd><p><em>filename</em>이 매직 번호에 기반하여 유효한 ZIP 파일이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다. <em>filename</em>은 파일이거나 파일류 객체일 수도 있습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.1으로 변경: </span>파일과 파일류 객체를 지원합니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="zipfile.ZIP_STORED">
<code class="descclassname">zipfile.</code><code class="descname">ZIP_STORED</code><a class="headerlink" href="#zipfile.ZIP_STORED" title="정의 주소">¶</a></dt>
<dd><p>압축되지 않은 아카이브 멤버를 위한 숫자 상수.</p>
</dd></dl>

<dl class="data">
<dt id="zipfile.ZIP_DEFLATED">
<code class="descclassname">zipfile.</code><code class="descname">ZIP_DEFLATED</code><a class="headerlink" href="#zipfile.ZIP_DEFLATED" title="정의 주소">¶</a></dt>
<dd><p>일반적인 ZIP 압축 방법을 위한 숫자 상수. <a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 모듈이 필요합니다.</p>
</dd></dl>

<dl class="data">
<dt id="zipfile.ZIP_BZIP2">
<code class="descclassname">zipfile.</code><code class="descname">ZIP_BZIP2</code><a class="headerlink" href="#zipfile.ZIP_BZIP2" title="정의 주소">¶</a></dt>
<dd><p>BZIP2 압축 방법을 위한 숫자 상수. <a class="reference internal" href="bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a> 모듈이 필요합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="zipfile.ZIP_LZMA">
<code class="descclassname">zipfile.</code><code class="descname">ZIP_LZMA</code><a class="headerlink" href="#zipfile.ZIP_LZMA" title="정의 주소">¶</a></dt>
<dd><p>LZMA 압축 방법을 위한 숫자 상수. <a class="reference internal" href="lzma.html#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lzma</span></code></a> 모듈이 필요합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.3에 추가.</span></p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">ZIP 파일 형식 명세에는 2001년 이후 bzip2 압축, 2006년 이후 LZMA 압축 지원이 포함되어 있습니다. 그러나, 일부 도구(이전 파이썬 릴리스도 포함합니다)는 이러한 압축 방법을 지원하지 않으며, ZIP 파일 처리를 완전히 거부하거나, 개별 파일을 추출하는 데 실패합니다.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">더 보기</p>
<dl class="last docutils">
<dt><a class="reference external" href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT">PKZIP Application Note</a></dt>
<dd>사용된 형식과 알고리즘의 저자인 Phil Katz의 ZIP 파일 형식에 대한 설명서.</dd>
<dt><a class="reference external" href="http://www.info-zip.org/">Info-ZIP 홈페이지</a></dt>
<dd>Info-ZIP 프로젝트의 ZIP 아카이브 프로그램과 개발 라이브러리에 관한 정보.</dd>
</dl>
</div>
<div class="section" id="zipfile-objects">
<span id="id1"></span><h2>ZipFile 객체<a class="headerlink" href="#zipfile-objects" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="zipfile.ZipFile">
<em class="property">class </em><code class="descclassname">zipfile.</code><code class="descname">ZipFile</code><span class="sig-paren">(</span><em>file</em>, <em>mode='r'</em>, <em>compression=ZIP_STORED</em>, <em>allowZip64=True</em>, <em>compresslevel=None</em>, <em>*</em>, <em>strict_timestamps=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipFile" title="정의 주소">¶</a></dt>
<dd><p>ZIP 파일을 엽니다, 여기서 <em>file</em>은 파일에 대한 경로 (문자열), 파일류 객체 또는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>일 수 있습니다.</p>
<p><em>mode</em> 매개 변수는 기존 파일을 읽으려면 <code class="docutils literal notranslate"><span class="pre">'r'</span></code>, 새 파일을 자르고 쓰려면 <code class="docutils literal notranslate"><span class="pre">'w'</span></code>, 기존 파일에 추가하려면 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, 새 파일을 독점적으로 작성하고 쓰려면 <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 이어야 합니다. <em>mode</em>가 <code class="docutils literal notranslate"><span class="pre">'x'</span></code>이고 <em>file</em>이 기존 파일을 참조하면, <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileExistsError</span></code></a> 가 발생합니다. <em>mode</em>가 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>이고 <em>file</em>이 기존 ZIP 파일을 참조하면, 추가 파일이 이곳으로 추가됩니다. <em>file</em>이 ZIP 파일을 참조하지 않으면, 새 ZIP 아카이브를 파일에 덧붙입니다(append). 이는 ZIP 아카이브를 다른 파일(가령 <code class="file docutils literal notranslate"><span class="pre">python.exe</span></code>)에 추가하기 위한 것입니다. <em>mode</em>가 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>이고 파일이 아예 존재하지 않으면, 파일이 만들어집니다. <em>mode</em>가 <code class="docutils literal notranslate"><span class="pre">'r'</span></code>이나 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>이면, 파일은 탐색 가능(seekable)해야 합니다.</p>
<p><em>compression</em>은 아카이브를 기록할 때 사용할 ZIP 압축 방법이며, <a class="reference internal" href="#zipfile.ZIP_STORED" title="zipfile.ZIP_STORED"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_STORED</span></code></a>, <a class="reference internal" href="#zipfile.ZIP_DEFLATED" title="zipfile.ZIP_DEFLATED"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_DEFLATED</span></code></a>, <a class="reference internal" href="#zipfile.ZIP_BZIP2" title="zipfile.ZIP_BZIP2"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_BZIP2</span></code></a> 또는 <a class="reference internal" href="#zipfile.ZIP_LZMA" title="zipfile.ZIP_LZMA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_LZMA</span></code></a> 이어야 합니다; 인식할 수 없는 값은 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 를 발생시킵니다. <a class="reference internal" href="#zipfile.ZIP_DEFLATED" title="zipfile.ZIP_DEFLATED"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_DEFLATED</span></code></a>, <a class="reference internal" href="#zipfile.ZIP_BZIP2" title="zipfile.ZIP_BZIP2"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_BZIP2</span></code></a> 또는 <a class="reference internal" href="#zipfile.ZIP_LZMA" title="zipfile.ZIP_LZMA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_LZMA</span></code></a>가 지정되었지만, 해당 모듈(<a class="reference internal" href="zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a>, <a class="reference internal" href="bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a> 또는 <a class="reference internal" href="lzma.html#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lzma</span></code></a>)을 사용할 수 없으면 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생합니다. 기본값은 <a class="reference internal" href="#zipfile.ZIP_STORED" title="zipfile.ZIP_STORED"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_STORED</span></code></a>입니다.</p>
<p><em>allowZip64</em>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>(기본값)이면 zipfile은 ZIP 파일이 4GiB보다 클 때 ZIP64 확장을 사용하는 ZIP 파일을 만듭니다. <code class="docutils literal notranslate"><span class="pre">false</span></code>이면 ZIP 파일에 ZIP64 확장자가 필요할 때 <a class="reference internal" href="#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a>은 예외를 발생시킵니다.</p>
<p><em>compresslevel</em> 매개 변수는 파일을 아카이브에 기록할 때 사용할 압축 수준을 제어합니다. <a class="reference internal" href="#zipfile.ZIP_STORED" title="zipfile.ZIP_STORED"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_STORED</span></code></a>나 <a class="reference internal" href="#zipfile.ZIP_LZMA" title="zipfile.ZIP_LZMA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_LZMA</span></code></a>를 사용할 때는 효과가 없습니다. <a class="reference internal" href="#zipfile.ZIP_DEFLATED" title="zipfile.ZIP_DEFLATED"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_DEFLATED</span></code></a>를 사용할 때는 <code class="docutils literal notranslate"><span class="pre">0</span></code>에서 <code class="docutils literal notranslate"><span class="pre">9</span></code>까지의 정수가 허용됩니다 (자세한 내용은 <a class="reference internal" href="zlib.html#zlib.compressobj" title="zlib.compressobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">zlib</span></code></a>를 참조하십시오). <a class="reference internal" href="#zipfile.ZIP_BZIP2" title="zipfile.ZIP_BZIP2"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_BZIP2</span></code></a>를 사용할 때는 <code class="docutils literal notranslate"><span class="pre">1</span></code>부터 <code class="docutils literal notranslate"><span class="pre">9</span></code>까지의 정수가 허용됩니다 (자세한 내용은 <a class="reference internal" href="bz2.html#bz2.BZ2File" title="bz2.BZ2File"><code class="xref py py-class docutils literal notranslate"><span class="pre">bz2</span></code></a>를 참조하십시오).</p>
<p><em>strict_timestamps</em> 인자를 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 설정하면, 1980-01-01 이전의 zip 파일을 허용하는 대신 타임 스탬프를 1980-01-01로 설정합니다. 2107-12-31 이후의 파일에 대해서도 비슷한 동작이 발생하며, 타임 스탬프는 역시 한곗값으로 설정됩니다.</p>
<p>파일이 <code class="docutils literal notranslate"><span class="pre">'w'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 모드로 만들어졌고 아카이브에 아무런 파일도 추가하지 않고 <a class="reference internal" href="#zipfile.ZipFile.close" title="zipfile.ZipFile.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">닫히면</span></code></a>, 비어있는 아카이브에 적합한 ZIP 구조가 파일에 기록됩니다.</p>
<p>ZipFile은 또한 컨텍스트 관리자이므로 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문을 지원합니다. 이 예에서, <em>myzip</em>은 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 문 스위트가 완료된 후에 닫힙니다 -- 예외가 발생할 때조차 그렇습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ZipFile</span><span class="p">(</span><span class="s1">&#39;spam.zip&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">myzip</span><span class="p">:</span>
    <span class="n">myzip</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;eggs.txt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span><a class="reference internal" href="#zipfile.ZipFile" title="zipfile.ZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipFile</span></code></a>을 컨텍스트 관리자로 사용하는 기능이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.3으로 변경: </span><a class="reference internal" href="bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bzip2</span></code></a>와 <a class="reference internal" href="lzma.html#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lzma</span></code></a> 압축에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>ZIP64 확장은 기본적으로 활성화됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.5으로 변경: </span>탐색할 수 없는(unseekable) 스트림으로의 쓰기 지원을 추가했습니다. <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 모드에 대한 지원이 추가되었습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>이전에는, 인식할 수 없는 compression 값에 대해 평범한 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6.2으로 변경: </span><em>file</em> 매개 변수는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span><em>compresslevel</em> 매개 변수를 추가했습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.8에 추가: </span><em>strict_timestamps</em> 키워드 전용 인자</p>
</div>
</dd></dl>

<dl class="method">
<dt id="zipfile.ZipFile.close">
<code class="descclassname">ZipFile.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipFile.close" title="정의 주소">¶</a></dt>
<dd><p>아카이브 파일을 닫습니다. 프로그램을 종료하기 전에 <a class="reference internal" href="#zipfile.ZipFile.close" title="zipfile.ZipFile.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>를 호출해야 합니다. 그렇지 않으면 필수 레코드가 기록되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="zipfile.ZipFile.getinfo">
<code class="descclassname">ZipFile.</code><code class="descname">getinfo</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipFile.getinfo" title="정의 주소">¶</a></dt>
<dd><p>아카이브 멤버 <em>name</em>에 관한 정보가 있는 <a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 객체를 반환합니다. 현재 아카이브에 포함되지 않은 이름에 대해 <a class="reference internal" href="#zipfile.ZipFile.getinfo" title="zipfile.ZipFile.getinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getinfo()</span></code></a>를 호출하면 <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>가 발생합니다.</p>
</dd></dl>

<dl class="method">
<dt id="zipfile.ZipFile.infolist">
<code class="descclassname">ZipFile.</code><code class="descname">infolist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipFile.infolist" title="정의 주소">¶</a></dt>
<dd><p>아카이브의 각 멤버에 대한 <a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 객체를 포함하는 리스트를 반환합니다. 기존 아카이브가 열린 경우 객체는 디스크의 실제 ZIP 파일에 있는 항목과 순서가 같습니다.</p>
</dd></dl>

<dl class="method">
<dt id="zipfile.ZipFile.namelist">
<code class="descclassname">ZipFile.</code><code class="descname">namelist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipFile.namelist" title="정의 주소">¶</a></dt>
<dd><p>아카이브 멤버의 리스트를 이름으로 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="zipfile.ZipFile.open">
<code class="descclassname">ZipFile.</code><code class="descname">open</code><span class="sig-paren">(</span><em>name</em>, <em>mode='r'</em>, <em>pwd=None</em>, <em>*</em>, <em>force_zip64=False</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipFile.open" title="정의 주소">¶</a></dt>
<dd><p>아카이브 멤버를 바이너리 파일류 객체로 액세스합니다. <em>name</em>은 아카이브 내의 파일 이름이거나 <a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 객체일 수 있습니다. 포함될 때 <em>mode</em> 매개 변수는 <code class="docutils literal notranslate"><span class="pre">'r'</span></code>(기본값)이거나 <code class="docutils literal notranslate"><span class="pre">'w'</span></code> 이어야 합니다. <em>pwd</em>는 암호화된 ZIP 파일을 해독하는 데 사용되는 비밀번호입니다.</p>
<p><a class="reference internal" href="#zipfile.ZipFile.open" title="zipfile.ZipFile.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a>은 컨텍스트 관리자이기도 하므로 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문을 지원합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ZipFile</span><span class="p">(</span><span class="s1">&#39;spam.zip&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">myzip</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">myzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;eggs.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">myfile</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">myfile</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</pre></div>
</div>
<p><em>mode</em> <code class="docutils literal notranslate"><span class="pre">'r'</span></code>에서 파일류 객체(<code class="docutils literal notranslate"><span class="pre">ZipExtFile</span></code>)는 읽기 전용이며 다음 메서드를 제공합니다: <a class="reference internal" href="io.html#io.BufferedIOBase.read" title="io.BufferedIOBase.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>, <a class="reference internal" href="io.html#io.IOBase.readline" title="io.IOBase.readline"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a>, <a class="reference internal" href="io.html#io.IOBase.readlines" title="io.IOBase.readlines"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readlines()</span></code></a>, <a class="reference internal" href="io.html#io.IOBase.seek" title="io.IOBase.seek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code></a>, <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tell()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a>. 이러한 객체는 ZipFile과 독립적으로 작동할 수 있습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">mode='w'</span></code>에서, <a class="reference internal" href="io.html#io.BufferedIOBase.write" title="io.BufferedIOBase.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> 메서드를 지원하는 쓰기 가능한 파일 핸들이 반환됩니다. 쓰기 가능한 파일 핸들이 열려있는 동안, ZIP 파일에서 다른 파일을 읽거나 쓰려고 시도하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<p>파일을 기록할 때, 파일 크기를 미리 알 수 없지만 2GiB를 초과할 수 있으면, 헤더 형식이 큰 파일을 지원할 수 있도록 <code class="docutils literal notranslate"><span class="pre">force_zip64=True</span></code>를 전달하십시오. 파일 크기가 미리 알려졌으면, <a class="reference internal" href="#zipfile.ZipInfo.file_size" title="zipfile.ZipInfo.file_size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">file_size</span></code></a>가 설정된 <a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 객체를 구성하고, 이를 <em>name</em> 매개 변수로 사용하십시오.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><a class="reference internal" href="#zipfile.ZipFile.open" title="zipfile.ZipFile.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a>, <a class="reference internal" href="#zipfile.ZipFile.read" title="zipfile.ZipFile.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> 및 <a class="reference internal" href="#zipfile.ZipFile.extract" title="zipfile.ZipFile.extract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extract()</span></code></a> 메서드는 파일명이나 <a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 객체를 취할 수 있습니다. 중복 이름을 가진 멤버가 포함된 ZIP 파일을 읽으려고 할 때 이 점에 감사할 것입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><code class="docutils literal notranslate"><span class="pre">mode='U'</span></code> 지원이 제거되었습니다. <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">유니버설 줄 넘김</span></a> 모드로 압축된 텍스트 파일을 읽으려면 <a class="reference internal" href="io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOWrapper</span></code></a>를 사용하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>이제 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">mode='w'</span></code> 옵션으로 파일을 아카이브에 기록하는 데 사용될 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>닫힌 ZipFile에 <a class="reference internal" href="#zipfile.ZipFile.open" title="zipfile.ZipFile.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a>을 호출하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 이전에는, <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생했습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="zipfile.ZipFile.extract">
<code class="descclassname">ZipFile.</code><code class="descname">extract</code><span class="sig-paren">(</span><em>member</em>, <em>path=None</em>, <em>pwd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipFile.extract" title="정의 주소">¶</a></dt>
<dd><p>아카이브에서 현재 작업 디렉터리로 멤버를 추출합니다. <em>member</em>는 전체 이름이거나 <a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 객체여야 합니다. 파일 정보는 최대한 정확하게 추출됩니다. <em>path</em>는 추출할 다른 디렉터리를 지정합니다. <em>member</em>는 파일 이름이나 <a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 객체일 수 있습니다. <em>pwd</em>는 암호화된 파일에 사용되는 비밀번호입니다.</p>
<p>만들어진 정규화된 경로(디렉터리나 새 파일)를 반환합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">멤버 파일명이 절대 경로이면, 드라이브/UNC 공유 지점(sharepoint)과 선행 (역) 슬래시가 제거됩니다, 예를 들어: <code class="docutils literal notranslate"><span class="pre">///foo/bar</span></code>는 유닉스에서 <code class="docutils literal notranslate"><span class="pre">foo/bar</span></code>가 되고, 윈도우에서 <code class="docutils literal notranslate"><span class="pre">C:\foo\bar</span></code>는 <code class="docutils literal notranslate"><span class="pre">foo\bar</span></code>가 됩니다. 그리고 멤버 파일명의 모든 <code class="docutils literal notranslate"><span class="pre">&quot;..&quot;</span></code> 구성 요소가 제거됩니다, 예를 들어: <code class="docutils literal notranslate"><span class="pre">../../foo../../ba..r</span></code>은 <code class="docutils literal notranslate"><span class="pre">foo../ba..r</span></code>이 됩니다. 윈도우에서 잘못된 문자(<code class="docutils literal notranslate"><span class="pre">:</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code> 및 <code class="docutils literal notranslate"><span class="pre">*</span></code>)는 밑줄(<code class="docutils literal notranslate"><span class="pre">_</span></code>)로 대체됩니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>닫힌 ZipFile에서 <a class="reference internal" href="#zipfile.ZipFile.extract" title="zipfile.ZipFile.extract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extract()</span></code></a>를 호출하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 이전에는 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6.2으로 변경: </span><em>path</em> 매개 변수는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="zipfile.ZipFile.extractall">
<code class="descclassname">ZipFile.</code><code class="descname">extractall</code><span class="sig-paren">(</span><em>path=None</em>, <em>members=None</em>, <em>pwd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipFile.extractall" title="정의 주소">¶</a></dt>
<dd><p>아카이브에서 현재 작업 디렉터리로 모든 멤버를 추출합니다. <em>path</em>는 추출할 다른 디렉터리를 지정합니다. <em>members</em>는 선택적이며 <a class="reference internal" href="#zipfile.ZipFile.namelist" title="zipfile.ZipFile.namelist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">namelist()</span></code></a>가 반환한 리스트의 부분 집합이어야 합니다. <em>pwd</em>는 암호화된 파일에 사용되는 비밀번호입니다.</p>
<div class="admonition warning">
<p class="first admonition-title">경고</p>
<p class="last">사전 검사 없이 신뢰할 수 없는 출처의 아카이브를 추출하지 마십시오. 파일이 <em>path</em> 밖에 만들어질 수 있습니다, 예를 들어 <code class="docutils literal notranslate"><span class="pre">&quot;/&quot;</span></code>로 시작하는 절대 파일명을 가진 멤버나 두 점 <code class="docutils literal notranslate"><span class="pre">&quot;..&quot;</span></code>을 포함하는 파일명. 이 모듈은 이를 방지하려고 시도합니다. <a class="reference internal" href="#zipfile.ZipFile.extract" title="zipfile.ZipFile.extract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extract()</span></code></a> 참고를 참조하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>닫힌 ZipFile에서 <a class="reference internal" href="#zipfile.ZipFile.extractall" title="zipfile.ZipFile.extractall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extractall()</span></code></a>을 호출하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 이전에는 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6.2으로 변경: </span><em>path</em> 매개 변수는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="zipfile.ZipFile.printdir">
<code class="descclassname">ZipFile.</code><code class="descname">printdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipFile.printdir" title="정의 주소">¶</a></dt>
<dd><p>아카이브의 목차를 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>으로 인쇄합니다.</p>
</dd></dl>

<dl class="method">
<dt id="zipfile.ZipFile.setpassword">
<code class="descclassname">ZipFile.</code><code class="descname">setpassword</code><span class="sig-paren">(</span><em>pwd</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipFile.setpassword" title="정의 주소">¶</a></dt>
<dd><p>암호화된 파일을 추출하기 위해 <em>pwd</em>를 기본 비밀번호로 설정합니다.</p>
</dd></dl>

<dl class="method">
<dt id="zipfile.ZipFile.read">
<code class="descclassname">ZipFile.</code><code class="descname">read</code><span class="sig-paren">(</span><em>name</em>, <em>pwd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipFile.read" title="정의 주소">¶</a></dt>
<dd><p>아카이브에서 파일 <em>name</em>의 바이트열을 반환합니다. <em>name</em>은 아카이브의 파일 이름이나 <a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 객체입니다. 아카이브는 읽기(read)나 추가(append)로 열려 있어야 합니다. <em>pwd</em>는 암호화된 파일에 사용되는 비밀번호이며, 지정되면 <a class="reference internal" href="#zipfile.ZipFile.setpassword" title="zipfile.ZipFile.setpassword"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setpassword()</span></code></a>로 설정된 기본 비밀번호를 대체합니다. <a class="reference internal" href="#zipfile.ZIP_STORED" title="zipfile.ZIP_STORED"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_STORED</span></code></a>, <a class="reference internal" href="#zipfile.ZIP_DEFLATED" title="zipfile.ZIP_DEFLATED"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_DEFLATED</span></code></a>, <a class="reference internal" href="#zipfile.ZIP_BZIP2" title="zipfile.ZIP_BZIP2"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_BZIP2</span></code></a> 또는 <a class="reference internal" href="#zipfile.ZIP_LZMA" title="zipfile.ZIP_LZMA"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_LZMA</span></code></a> 이외의 압축 방법을 사용하는 ZipFile에서 <a class="reference internal" href="#zipfile.ZipFile.read" title="zipfile.ZipFile.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>를 호출하면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 가 발생합니다. 해당 압축 모듈을 사용할 수 없는 경우에도 에러가 발생합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>닫힌 ZipFile에서 <a class="reference internal" href="#zipfile.ZipFile.read" title="zipfile.ZipFile.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>를 호출하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 이전에는 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생했습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="zipfile.ZipFile.testzip">
<code class="descclassname">ZipFile.</code><code class="descname">testzip</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipFile.testzip" title="정의 주소">¶</a></dt>
<dd><p>아카이브의 모든 파일을 읽고 CRC와 파일 헤더를 확인합니다. 첫 번째 불량 파일의 이름을 반환하거나, <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span>닫힌 ZipFile에서 <a class="reference internal" href="#zipfile.ZipFile.testzip" title="zipfile.ZipFile.testzip"><code class="xref py py-meth docutils literal notranslate"><span class="pre">testzip()</span></code></a>을 호출하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 이전에는 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생했습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="zipfile.ZipFile.write">
<code class="descclassname">ZipFile.</code><code class="descname">write</code><span class="sig-paren">(</span><em>filename</em>, <em>arcname=None</em>, <em>compress_type=None</em>, <em>compresslevel=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipFile.write" title="정의 주소">¶</a></dt>
<dd><p><em>filename</em>이라는 파일을 아카이브에 기록하고, 아카이브 이름으로 <em>arcname</em>을 지정합니다 (기본적으로, <em>filename</em>과 같지만, 드라이브 문자가 없고 선행 경로 구분 기호가 제거됩니다). 주어지면, <em>compress_type</em>은 새 항목에 대해 생성자의 <em>compression</em> 매개 변수에 제공된 값을 대체합니다. 마찬가지로, <em>compresslevel</em>은 주어지면 생성자를 대체합니다. 아카이브는 <code class="docutils literal notranslate"><span class="pre">'w'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 모드로 열려 있어야 합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">아카이브 이름은 아카이브 루트에 상대적이어야 합니다. 즉, 경로 구분 기호로 시작해서는 안 됩니다.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">arcname</span></code>(또는 <code class="docutils literal notranslate"><span class="pre">arcname</span></code>이 제공되지 않으면 <code class="docutils literal notranslate"><span class="pre">filename</span></code>)에 널 바이트가 포함되어 있으면, 아카이브의 파일 이름이 널 바이트에서 잘립니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><code class="docutils literal notranslate"><span class="pre">'r'</span></code> 모드로 만들어진 ZipFile이나 닫힌 ZipFile에서 <a class="reference internal" href="#zipfile.ZipFile.write" title="zipfile.ZipFile.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a>를 호출하면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 이전에는 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생했습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="zipfile.ZipFile.writestr">
<code class="descclassname">ZipFile.</code><code class="descname">writestr</code><span class="sig-paren">(</span><em>zinfo_or_arcname</em>, <em>data</em>, <em>compress_type=None</em>, <em>compresslevel=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipFile.writestr" title="정의 주소">¶</a></dt>
<dd><p>파일을 아카이브에 기록합니다. 내용은 <em>data</em>이며, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>이나 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 인스턴스일 수 있습니다; <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>이면 먼저 UTF-8로 인코딩됩니다. <em>zinfo_or_arcname</em>은 아카이브에 제공될 파일 이름이거나 <a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 인스턴스입니다. 인스턴스이면 최소한 파일명, 날짜 및 시간을 지정해야 합니다. 이름이면, 날짜와 시간이 현재 날짜와 시간으로 설정됩니다. 아카이브는 <code class="docutils literal notranslate"><span class="pre">'w'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 모드로 열려 있어야 합니다.</p>
<p>주어지면, <em>compress_type</em>은 새 항목에 대해 생성자의 <em>compression</em> 매개 변수에 제공되거나 <em>zinfo_or_arcname</em>(<a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 인스턴스인 경우)의 값을 대체합니다. 마찬가지로, <em>compresslevel</em>은 주어지면 생성자를 대체합니다.</p>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last"><a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 인스턴스를 <em>zinfo_or_arcname</em> 매개 변수로 전달할 때, 사용되는 압축 방법은 주어진 <a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 인스턴스의 <em>compress_type</em> 멤버에 지정된 압축 방법입니다. 기본적으로, <a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 생성자는 이 멤버를 <a class="reference internal" href="#zipfile.ZIP_STORED" title="zipfile.ZIP_STORED"><code class="xref py py-const docutils literal notranslate"><span class="pre">ZIP_STORED</span></code></a>로 설정합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.2으로 변경: </span><em>compress_type</em> 인자.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6으로 변경: </span><code class="docutils literal notranslate"><span class="pre">'r'</span></code> 모드로 만들어진 ZipFile이나 닫힌 ZipFile에서 <a class="reference internal" href="#zipfile.ZipFile.writestr" title="zipfile.ZipFile.writestr"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writestr()</span></code></a>을 호출하면, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다. 이전에는 <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생했습니다.</p>
</div>
</dd></dl>

<p>다음과 같은 데이터 어트리뷰트도 사용할 수 있습니다:</p>
<dl class="attribute">
<dt id="zipfile.ZipFile.filename">
<code class="descclassname">ZipFile.</code><code class="descname">filename</code><a class="headerlink" href="#zipfile.ZipFile.filename" title="정의 주소">¶</a></dt>
<dd><p>ZIP 파일의 이름.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipFile.debug">
<code class="descclassname">ZipFile.</code><code class="descname">debug</code><a class="headerlink" href="#zipfile.ZipFile.debug" title="정의 주소">¶</a></dt>
<dd><p>사용할 디버그 출력 수준. 이것은 <code class="docutils literal notranslate"><span class="pre">0</span></code>(기본값, 출력 없음)에서 <code class="docutils literal notranslate"><span class="pre">3</span></code>(가장 많은 출력)으로 설정될 수 있습니다. 디버깅 정보는 <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>에 기록됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipFile.comment">
<code class="descclassname">ZipFile.</code><code class="descname">comment</code><a class="headerlink" href="#zipfile.ZipFile.comment" title="정의 주소">¶</a></dt>
<dd><p>ZIP 파일에 연관되는 주석은 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체입니다. <code class="docutils literal notranslate"><span class="pre">'w'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> 모드로 만들어진 <a class="reference internal" href="#zipfile.ZipFile" title="zipfile.ZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipFile</span></code></a> 인스턴스에 주석을 대입하면, 65535바이트를 넘지 않아야 합니다. 이보다 긴 주석은 잘립니다.</p>
</dd></dl>

</div>
<div class="section" id="path-objects">
<span id="id2"></span><h2>Path 객체<a class="headerlink" href="#path-objects" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="zipfile.Path">
<em class="property">class </em><code class="descclassname">zipfile.</code><code class="descname">Path</code><span class="sig-paren">(</span><em>root</em>, <em>at=''</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.Path" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">root</span></code> zip 파일(<a class="reference internal" href="#zipfile.ZipFile" title="zipfile.ZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipFile</span></code></a> 생성자에 전달하기에 적합한 <a class="reference internal" href="#zipfile.ZipFile" title="zipfile.ZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipFile</span></code></a> 인스턴스나 <code class="docutils literal notranslate"><span class="pre">file</span></code>일 수 있습니다)에서 Path 객체를 생성합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">at</span></code>은 zip 파일 내에서 이 Path의 위치를 지정합니다, 예를 들어 'dir/file.txt', 'dir/' 또는 ''. 기본값은 빈 문자열이며, 루트를 나타냅니다.</p>
</dd></dl>

<p>Path 객체는 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> 객체의 다음 기능을 노출합니다:</p>
<p><code class="docutils literal notranslate"><span class="pre">/</span></code> 연산자를 사용하여 Path 객체를 순회할 수 있습니다.</p>
<dl class="attribute">
<dt id="zipfile.Path.name">
<code class="descclassname">Path.</code><code class="descname">name</code><a class="headerlink" href="#zipfile.Path.name" title="정의 주소">¶</a></dt>
<dd><p>최종 경로 구성 요소.</p>
</dd></dl>

<dl class="method">
<dt id="zipfile.Path.open">
<code class="descclassname">Path.</code><code class="descname">open</code><span class="sig-paren">(</span><em>*</em>, <em>**</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.Path.open" title="정의 주소">¶</a></dt>
<dd><p>현재 경로에서 <a class="reference internal" href="#zipfile.ZipFile.open" title="zipfile.ZipFile.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ZipFile.open()</span></code></a>을 호출합니다. <a class="reference internal" href="#zipfile.ZipFile.open" title="zipfile.ZipFile.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ZipFile.open()</span></code></a>과 같은 인자를 받아들입니다.</p>
<div class="admonition caution">
<p class="first admonition-title">조심</p>
<p class="last">이 함수의 서명은 파이썬 3.9에서 호환되지 않는 방식으로 변경됩니다. 향후 호환될 버전을 위해서, 제삼자 zipp.Path 패키지 (3.0 이상) 사용을 고려하십시오.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="zipfile.Path.iterdir">
<code class="descclassname">Path.</code><code class="descname">iterdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.Path.iterdir" title="정의 주소">¶</a></dt>
<dd><p>현재 디렉터리의 자식을 열거합니다.</p>
</dd></dl>

<dl class="method">
<dt id="zipfile.Path.is_dir">
<code class="descclassname">Path.</code><code class="descname">is_dir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.Path.is_dir" title="정의 주소">¶</a></dt>
<dd><p>현재 컨텍스트가 디렉터리를 참조하면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="zipfile.Path.is_file">
<code class="descclassname">Path.</code><code class="descname">is_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.Path.is_file" title="정의 주소">¶</a></dt>
<dd><p>현재 컨텍스트가 파일을 참조하면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="zipfile.Path.exists">
<code class="descclassname">Path.</code><code class="descname">exists</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.Path.exists" title="정의 주소">¶</a></dt>
<dd><p>현재 컨텍스트가 zip 파일에 있는 파일이나 디렉터리를 참조하면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="method">
<dt id="zipfile.Path.read_text">
<code class="descclassname">Path.</code><code class="descname">read_text</code><span class="sig-paren">(</span><em>*</em>, <em>**</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.Path.read_text" title="정의 주소">¶</a></dt>
<dd><p>현재 파일을 유니코드 텍스트로 읽습니다. 위치와 키워드 인자는 <a class="reference internal" href="io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOWrapper</span></code></a>로 전달됩니다 (컨텍스트에 의해 암시되는 <code class="docutils literal notranslate"><span class="pre">buffer</span></code> 제외).</p>
</dd></dl>

<dl class="method">
<dt id="zipfile.Path.read_bytes">
<code class="descclassname">Path.</code><code class="descname">read_bytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.Path.read_bytes" title="정의 주소">¶</a></dt>
<dd><p>현재 파일을 바이트열로 읽습니다.</p>
</dd></dl>

</div>
<div class="section" id="pyzipfile-objects">
<span id="id3"></span><h2>PyZipFile 객체<a class="headerlink" href="#pyzipfile-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#zipfile.PyZipFile" title="zipfile.PyZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyZipFile</span></code></a> 생성자는 <a class="reference internal" href="#zipfile.ZipFile" title="zipfile.ZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipFile</span></code></a> 생성자와 같은 매개 변수와 하나의 추가 매개 변수 <em>optimize</em>를 취합니다.</p>
<dl class="class">
<dt id="zipfile.PyZipFile">
<em class="property">class </em><code class="descclassname">zipfile.</code><code class="descname">PyZipFile</code><span class="sig-paren">(</span><em>file</em>, <em>mode='r'</em>, <em>compression=ZIP_STORED</em>, <em>allowZip64=True</em>, <em>optimize=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.PyZipFile" title="정의 주소">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified">버전 3.2에 추가: </span><em>optimize</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.4으로 변경: </span>ZIP64 확장은 기본적으로 활성화됩니다.</p>
</div>
<p>인스턴스에는 <a class="reference internal" href="#zipfile.ZipFile" title="zipfile.ZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipFile</span></code></a> 객체의 메서드들 외에 한 가지 추가 메서드가 있습니다:</p>
<dl class="method">
<dt id="zipfile.PyZipFile.writepy">
<code class="descname">writepy</code><span class="sig-paren">(</span><em>pathname</em>, <em>basename=''</em>, <em>filterfunc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.PyZipFile.writepy" title="정의 주소">¶</a></dt>
<dd><p>파일 <code class="file docutils literal notranslate"><span class="pre">*.py</span></code>를 검색하고 해당 파일을 아카이브에 추가합니다.</p>
<p><a class="reference internal" href="#zipfile.PyZipFile" title="zipfile.PyZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyZipFile</span></code></a>에 대한 <em>optimize</em> 매개 변수가 제공되지 않았거나 <code class="docutils literal notranslate"><span class="pre">-1</span></code>이면, 해당 파일은 <code class="file docutils literal notranslate"><span class="pre">*.pyc</span></code> 파일이며, 필요하면 컴파일합니다.</p>
<p><a class="reference internal" href="#zipfile.PyZipFile" title="zipfile.PyZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyZipFile</span></code></a>에 대한 <em>optimize</em> 매개 변수가 <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">2</span></code>이면, 해당 최적화 수준(<a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>을 참조하십시오)의  파일 만 아카이브에 추가되며, 필요하면 컴파일합니다.</p>
<p><em>pathname</em>이 파일이면, 파일 이름은 <code class="file docutils literal notranslate"><span class="pre">.py</span></code>로 끝나야하며, 단지 그 (해당 <code class="file docutils literal notranslate"><span class="pre">*.pyc</span></code>) 파일 만 최상위 수준에 추가됩니다 (경로 정보 없음). <em>pathname</em>이 <code class="file docutils literal notranslate"><span class="pre">.py</span></code>로 끝나지 않는 파일이면, <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>가 발생합니다. 디렉터리이고, 디렉터리가 패키지 디렉터리가 아니면, 모든 파일 <code class="file docutils literal notranslate"><span class="pre">*.pyc</span></code>가 최상위 수준에 추가됩니다. 디렉터리가 패키지 디렉터리이면, 모든 <code class="file docutils literal notranslate"><span class="pre">*.pyc</span></code>가 패키지 이름의 파일 경로 아래에 추가되고, 서브 디렉터리가 패키지 디렉터리이면, 이들 모두도 재귀적으로 정렬된 순서로 추가됩니다.</p>
<p><em>basename</em>은 내부 전용입니다.</p>
<p><em>filterfunc</em>가 주어지면, 단일 문자열 인자를 취하는 함수여야 합니다. 아카이브에 추가되기 전에 각 경로(개별 전체 파일 경로를 포함합니다)를 전달합니다. <em>filterfunc</em>가 거짓 값을 반환하면, 경로가 추가되지 않으며, 디렉터리이면 내용이 무시됩니다. 예를 들어, 테스트 파일이 모두 <code class="docutils literal notranslate"><span class="pre">test</span></code> 디렉터리에 있거나 문자열 <code class="docutils literal notranslate"><span class="pre">test_</span></code>로 시작하면, <em>filterfunc</em>를 사용하여 해당 파일들을 제외할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">zf</span> <span class="o">=</span> <span class="n">PyZipFile</span><span class="p">(</span><span class="s1">&#39;myprog.zip&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">notests</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">fn</span> <span class="o">==</span> <span class="s1">&#39;test&#39;</span> <span class="ow">or</span> <span class="n">fn</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;test_&#39;</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zf</span><span class="o">.</span><span class="n">writepy</span><span class="p">(</span><span class="s1">&#39;myprog&#39;</span><span class="p">,</span> <span class="n">filterfunc</span><span class="o">=</span><span class="n">notests</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#zipfile.PyZipFile.writepy" title="zipfile.PyZipFile.writepy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writepy()</span></code></a> 메서드는 다음과 같은 파일 이름으로 아카이브를 만듭니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">string</span><span class="o">.</span><span class="n">pyc</span>                   <span class="c1"># 최상위 이름</span>
<span class="n">test</span><span class="o">/</span><span class="fm">__init__</span><span class="o">.</span><span class="n">pyc</span>            <span class="c1"># 패키지 디렉터리</span>
<span class="n">test</span><span class="o">/</span><span class="n">testall</span><span class="o">.</span><span class="n">pyc</span>             <span class="c1"># 모듈 test.testall</span>
<span class="n">test</span><span class="o">/</span><span class="n">bogus</span><span class="o">/</span><span class="fm">__init__</span><span class="o">.</span><span class="n">pyc</span>      <span class="c1"># 서브 패키지 디렉터리</span>
<span class="n">test</span><span class="o">/</span><span class="n">bogus</span><span class="o">/</span><span class="n">myfile</span><span class="o">.</span><span class="n">pyc</span>        <span class="c1"># 서브 모듈 test.bogus.myfile</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.4에 추가: </span><em>filterfunc</em> 매개 변수.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6.2으로 변경: </span><em>pathname</em> 매개 변수는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.7으로 변경: </span>재귀는 디렉터리 항목을 정렬합니다.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="zipinfo-objects">
<span id="id4"></span><h2>ZipInfo 객체<a class="headerlink" href="#zipinfo-objects" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 클래스의 인스턴스는 <a class="reference internal" href="#zipfile.ZipFile" title="zipfile.ZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipFile</span></code></a> 객체의 <a class="reference internal" href="#zipfile.ZipFile.getinfo" title="zipfile.ZipFile.getinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getinfo()</span></code></a>와 <a class="reference internal" href="#zipfile.ZipFile.infolist" title="zipfile.ZipFile.infolist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">infolist()</span></code></a> 메서드가 반환합니다. 각 객체는 ZIP 아카이브의 단일 멤버에 대한 정보를 저장합니다.</p>
<p>파일 시스템 파일의 <a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 인스턴스를 만드는 클래스 메서드가 하나 있습니다:</p>
<dl class="classmethod">
<dt id="zipfile.ZipInfo.from_file">
<em class="property">classmethod </em><code class="descclassname">ZipInfo.</code><code class="descname">from_file</code><span class="sig-paren">(</span><em>filename</em>, <em>arcname=None</em>, <em>*</em>, <em>strict_timestamps=True</em><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipInfo.from_file" title="정의 주소">¶</a></dt>
<dd><p>zip 파일에 파일을 추가할 수 있도록, 파일 시스템의 파일에 대한 <a class="reference internal" href="#zipfile.ZipInfo" title="zipfile.ZipInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code></a> 인스턴스를 생성합니다.</p>
<p><em>filename</em>은 파일 시스템에서 파일이나 디렉터리의 경로여야 합니다.</p>
<p><em>arcname</em>이 지정되면, 아카이브 내에서의 이름으로 사용됩니다. <em>arcname</em>을 지정하지 않으면, 이름은 <em>filename</em>과 같지만, 드라이브 문자와 선행 경로 구분 기호가 제거됩니다.</p>
<p><em>strict_timestamps</em> 인자를 <code class="docutils literal notranslate"><span class="pre">False</span></code>로 설정하면, 1980-01-01 이전의 zip 파일을 허용하는 대신 타임 스탬프를 1980-01-01로 설정합니다. 2107-12-31 이후의 파일에 대해서도 비슷한 동작이 발생하며, 타임 스탬프는 역시 한곗값으로 설정됩니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 3.6.2으로 변경: </span><em>filename</em> 매개 변수는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>를 받아들입니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">버전 3.8에 추가: </span><em>strict_timestamps</em> 키워드 전용 인자</p>
</div>
</dd></dl>

<p>인스턴스에는 다음과 같은 메서드와 어트리뷰트가 있습니다:</p>
<dl class="method">
<dt id="zipfile.ZipInfo.is_dir">
<code class="descclassname">ZipInfo.</code><code class="descname">is_dir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#zipfile.ZipInfo.is_dir" title="정의 주소">¶</a></dt>
<dd><p>이 아카이브 멤버가 디렉터리이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<p>이것은 항목 이름을 사용합니다: 디렉터리는 항상 <code class="docutils literal notranslate"><span class="pre">/</span></code>로 끝나야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.filename">
<code class="descclassname">ZipInfo.</code><code class="descname">filename</code><a class="headerlink" href="#zipfile.ZipInfo.filename" title="정의 주소">¶</a></dt>
<dd><p>아카이브에서의 파일의 이름.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.date_time">
<code class="descclassname">ZipInfo.</code><code class="descname">date_time</code><a class="headerlink" href="#zipfile.ZipInfo.date_time" title="정의 주소">¶</a></dt>
<dd><p>아카이브 멤버를 마지막으로 수정한 시간과 날짜. 이것은 6개의 값으로 구성된 튜플입니다:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">인덱스</th>
<th class="head">값</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">0</span></code></td>
<td>연도 (&gt;= 1980)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">1</span></code></td>
<td>월 (1에서 시작)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">2</span></code></td>
<td>월 중 일 (1에서 시작)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">3</span></code></td>
<td>시간 (0에서 시작)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">4</span></code></td>
<td>분 (0에서 시작)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">5</span></code></td>
<td>초 (0에서 시작)</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">주석</p>
<p class="last">ZIP 파일 형식은 1980년 이전의 타임 스탬프를 지원하지 않습니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.compress_type">
<code class="descclassname">ZipInfo.</code><code class="descname">compress_type</code><a class="headerlink" href="#zipfile.ZipInfo.compress_type" title="정의 주소">¶</a></dt>
<dd><p>아카이브 멤버의 압축 유형.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.comment">
<code class="descclassname">ZipInfo.</code><code class="descname">comment</code><a class="headerlink" href="#zipfile.ZipInfo.comment" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체로 제공되는 개별 아카이브 멤버에 대한 주석.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.extra">
<code class="descclassname">ZipInfo.</code><code class="descname">extra</code><a class="headerlink" href="#zipfile.ZipInfo.extra" title="정의 주소">¶</a></dt>
<dd><p>확장 필드 데이터. <a class="reference external" href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT">PKZIP Application Note</a>는 이 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체에 포함된 데이터의 내부 구조에 대한 주석을 포함합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.create_system">
<code class="descclassname">ZipInfo.</code><code class="descname">create_system</code><a class="headerlink" href="#zipfile.ZipInfo.create_system" title="정의 주소">¶</a></dt>
<dd><p>ZIP 아카이브를 만든 시스템.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.create_version">
<code class="descclassname">ZipInfo.</code><code class="descname">create_version</code><a class="headerlink" href="#zipfile.ZipInfo.create_version" title="정의 주소">¶</a></dt>
<dd><p>ZIP 아카이브를 만든 PKZIP 버전.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.extract_version">
<code class="descclassname">ZipInfo.</code><code class="descname">extract_version</code><a class="headerlink" href="#zipfile.ZipInfo.extract_version" title="정의 주소">¶</a></dt>
<dd><p>아카이브를 추출하기 위해 필요한 PKZIP 버전.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.reserved">
<code class="descclassname">ZipInfo.</code><code class="descname">reserved</code><a class="headerlink" href="#zipfile.ZipInfo.reserved" title="정의 주소">¶</a></dt>
<dd><p>반드시 0이어야 합니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.flag_bits">
<code class="descclassname">ZipInfo.</code><code class="descname">flag_bits</code><a class="headerlink" href="#zipfile.ZipInfo.flag_bits" title="정의 주소">¶</a></dt>
<dd><p>ZIP 플래그 비트.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.volume">
<code class="descclassname">ZipInfo.</code><code class="descname">volume</code><a class="headerlink" href="#zipfile.ZipInfo.volume" title="정의 주소">¶</a></dt>
<dd><p>파일 헤더의 볼륨 번호.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.internal_attr">
<code class="descclassname">ZipInfo.</code><code class="descname">internal_attr</code><a class="headerlink" href="#zipfile.ZipInfo.internal_attr" title="정의 주소">¶</a></dt>
<dd><p>내부 어트리뷰트.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.external_attr">
<code class="descclassname">ZipInfo.</code><code class="descname">external_attr</code><a class="headerlink" href="#zipfile.ZipInfo.external_attr" title="정의 주소">¶</a></dt>
<dd><p>외부 파일 어트리뷰트.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.header_offset">
<code class="descclassname">ZipInfo.</code><code class="descname">header_offset</code><a class="headerlink" href="#zipfile.ZipInfo.header_offset" title="정의 주소">¶</a></dt>
<dd><p>파일 헤더의 바이트 오프셋.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.CRC">
<code class="descclassname">ZipInfo.</code><code class="descname">CRC</code><a class="headerlink" href="#zipfile.ZipInfo.CRC" title="정의 주소">¶</a></dt>
<dd><p>압축되지 않은 파일의 CRC-32.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.compress_size">
<code class="descclassname">ZipInfo.</code><code class="descname">compress_size</code><a class="headerlink" href="#zipfile.ZipInfo.compress_size" title="정의 주소">¶</a></dt>
<dd><p>압축된 데이터의 크기.</p>
</dd></dl>

<dl class="attribute">
<dt id="zipfile.ZipInfo.file_size">
<code class="descclassname">ZipInfo.</code><code class="descname">file_size</code><a class="headerlink" href="#zipfile.ZipInfo.file_size" title="정의 주소">¶</a></dt>
<dd><p>압축되지 않은 파일의 크기.</p>
</dd></dl>

</div>
<div class="section" id="command-line-interface">
<span id="zipfile-commandline"></span><h2>명령 줄 인터페이스<a class="headerlink" href="#command-line-interface" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> 모듈은 ZIP 아카이브와 상호 작용하기 위한 간단한 명령 줄 인터페이스를 제공합니다.</p>
<p>새 ZIP 아카이브를 만들려면 <a class="reference internal" href="#cmdoption-zipfile-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c</span></code></a> 옵션 뒤에 이름을 지정한 다음 포함해야 할 파일 이름을 나열하십시오:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m zipfile -c monty.zip spam.txt eggs.txt
</pre></div>
</div>
<p>디렉터리 전달도 허용됩니다:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m zipfile -c monty.zip life-of-brian_1979/
</pre></div>
</div>
<p>ZIP 아카이브를 지정된 디렉터리로 추출하려면, <a class="reference internal" href="#cmdoption-zipfile-e"><code class="xref std std-option docutils literal notranslate"><span class="pre">-e</span></code></a> 옵션을 사용하십시오:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m zipfile -e monty.zip target-dir/
</pre></div>
</div>
<p>ZIP 아카이브에 있는 파일 목록을 보려면, <a class="reference internal" href="#cmdoption-zipfile-l"><code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code></a> 옵션을 사용하십시오:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m zipfile -l monty.zip
</pre></div>
</div>
<div class="section" id="command-line-options">
<h3>명령 줄 옵션<a class="headerlink" href="#command-line-options" title="제목 주소">¶</a></h3>
<dl class="cmdoption">
<dt id="cmdoption-zipfile-l">
<code class="descname">-l</code><code class="descclassname"> &lt;zipfile&gt;</code><a class="headerlink" href="#cmdoption-zipfile-l" title="정의 주소">¶</a></dt>
<dt id="cmdoption-zipfile-list">
<code class="descname">--list</code><code class="descclassname"> &lt;zipfile&gt;</code><a class="headerlink" href="#cmdoption-zipfile-list" title="정의 주소">¶</a></dt>
<dd><p>zip 파일에 있는 파일을 나열합니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-zipfile-c">
<code class="descname">-c</code><code class="descclassname"> &lt;zipfile&gt; &lt;source1&gt; ... &lt;sourceN&gt;</code><a class="headerlink" href="#cmdoption-zipfile-c" title="정의 주소">¶</a></dt>
<dt id="cmdoption-zipfile-create">
<code class="descname">--create</code><code class="descclassname"> &lt;zipfile&gt; &lt;source1&gt; ... &lt;sourceN&gt;</code><a class="headerlink" href="#cmdoption-zipfile-create" title="정의 주소">¶</a></dt>
<dd><p>소스 파일로 zip 파일을 만듭니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-zipfile-e">
<code class="descname">-e</code><code class="descclassname"> &lt;zipfile&gt; &lt;output_dir&gt;</code><a class="headerlink" href="#cmdoption-zipfile-e" title="정의 주소">¶</a></dt>
<dt id="cmdoption-zipfile-extract">
<code class="descname">--extract</code><code class="descclassname"> &lt;zipfile&gt; &lt;output_dir&gt;</code><a class="headerlink" href="#cmdoption-zipfile-extract" title="정의 주소">¶</a></dt>
<dd><p>zip 파일을 대상 디렉터리로 추출합니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-zipfile-t">
<code class="descname">-t</code><code class="descclassname"> &lt;zipfile&gt;</code><a class="headerlink" href="#cmdoption-zipfile-t" title="정의 주소">¶</a></dt>
<dt id="cmdoption-zipfile-test">
<code class="descname">--test</code><code class="descclassname"> &lt;zipfile&gt;</code><a class="headerlink" href="#cmdoption-zipfile-test" title="정의 주소">¶</a></dt>
<dd><p>zip 파일이 유효한지 테스트합니다.</p>
</dd></dl>

</div>
</div>
<div class="section" id="decompression-pitfalls">
<h2>압축 해제 함정<a class="headerlink" href="#decompression-pitfalls" title="제목 주소">¶</a></h2>
<p>아래 나열된 일부 함정으로 인해 zipfile 모듈에서의 추출이 실패할 수 있습니다.</p>
<div class="section" id="from-file-itself">
<h3>파일 자체에서<a class="headerlink" href="#from-file-itself" title="제목 주소">¶</a></h3>
<p>잘못된 암호 / CRC 체크섬 / ZIP 형식 또는 지원되지 않는 압축 방법 / 암호 해독으로 인해 압축 해제에 실패할 수 있습니다.</p>
</div>
<div class="section" id="file-system-limitations">
<h3>파일 시스템 제한<a class="headerlink" href="#file-system-limitations" title="제목 주소">¶</a></h3>
<p>다른 파일 시스템의 제한을 초과하면 압축 해제에 실패할 수 있습니다. 가령 디렉터리 항목에 허용되는 문자, 파일 이름 길이, 경로명 길이, 단일 파일 크기 및 파일 수 등.</p>
</div>
<div class="section" id="resources-limitations">
<h3>자원 제한<a class="headerlink" href="#resources-limitations" title="제목 주소">¶</a></h3>
<p>메모리나 디스크 볼륨이 부족하면 압축 해제에 실패합니다. 예를 들어, 압축 해제 폭탄(일명 <a class="reference external" href="https://en.wikipedia.org/wiki/Zip_bomb">ZIP bomb</a>)을 zipfile 라이브러리에 적용하면 디스크 볼륨이 소진될 수 있습니다.</p>
</div>
<div class="section" id="interruption">
<h3>중단<a class="headerlink" href="#interruption" title="제목 주소">¶</a></h3>
<p>Ctrl-C 누르기나 압축 해제 프로세스를 죽이는 것과 같은 압축 해제 중 중단으로 인해 아카이브 압축 해제가 불완전할 수 있습니다.</p>
</div>
<div class="section" id="default-behaviors-of-extraction">
<h3>추출의 기본 동작<a class="headerlink" href="#default-behaviors-of-extraction" title="제목 주소">¶</a></h3>
<p>기본 추출 동작을 모르면 예기치 않은 압축 해제 결과가 발생할 수 있습니다. 예를 들어, 같은 아카이브를 두 번 추출하면, 묻지 않고 파일을 덮어씁니다.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">zipfile</span></code> --- ZIP 아카이브 작업</a><ul>
<li><a class="reference internal" href="#zipfile-objects">ZipFile 객체</a></li>
<li><a class="reference internal" href="#path-objects">Path 객체</a></li>
<li><a class="reference internal" href="#pyzipfile-objects">PyZipFile 객체</a></li>
<li><a class="reference internal" href="#zipinfo-objects">ZipInfo 객체</a></li>
<li><a class="reference internal" href="#command-line-interface">명령 줄 인터페이스</a><ul>
<li><a class="reference internal" href="#command-line-options">명령 줄 옵션</a></li>
</ul>
</li>
<li><a class="reference internal" href="#decompression-pitfalls">압축 해제 함정</a><ul>
<li><a class="reference internal" href="#from-file-itself">파일 자체에서</a></li>
<li><a class="reference internal" href="#file-system-limitations">파일 시스템 제한</a></li>
<li><a class="reference internal" href="#resources-limitations">자원 제한</a></li>
<li><a class="reference internal" href="#interruption">중단</a></li>
<li><a class="reference internal" href="#default-behaviors-of-extraction">추출의 기본 동작</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="lzma.html"
                        title="이전 장"><code class="docutils literal notranslate"><span class="pre">lzma</span></code> --- LZMA 알고리즘을 사용한 압축</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="tarfile.html"
                        title="다음 장"><code class="docutils literal notranslate"><span class="pre">tarfile</span></code> --- tar 아카이브 파일 읽기와 쓰기</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="tarfile.html" title="tarfile --- tar 아카이브 파일 읽기와 쓰기"
             >다음</a> |</li>
        <li class="right" >
          <a href="lzma.html" title="lzma --- LZMA 알고리즘을 사용한 압축"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="archiving.html" >데이터 압축 및 보관</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="바로 가기" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>