
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>dataclasses --- 데이터 클래스 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="contextlib --- Utilities for with-statement contexts" href="contextlib.html" />
    <link rel="prev" title="warnings --- 경고 제어" href="warnings.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/dataclasses.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="contextlib.html" title="contextlib --- Utilities for with-statement contexts"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="warnings.html" title="warnings --- 경고 제어"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="python.html" accesskey="U">파이썬 실행시간 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-dataclasses">
<span id="dataclasses-data-classes"></span><h1><a class="reference internal" href="#module-dataclasses" title="dataclasses: Generate special methods on user-defined classes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dataclasses</span></code></a> --- 데이터 클래스<a class="headerlink" href="#module-dataclasses" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/dataclasses.py">Lib/dataclasses.py</a></p>
<hr class="docutils" />
<p>이 모듈은 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 나 <a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 과 같은 생성된 <a class="reference internal" href="../glossary.html#term-special-method"><span class="xref std std-term">특수 메서드</span></a> 를 사용자 정의 클래스에 자동으로 추가하는 데코레이터와 함수를 제공합니다. 원래 <span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0557"><strong>PEP 557</strong></a> 에 설명되어 있습니다.</p>
<p>생성된 메서드에서 사용할 멤버 변수는 <span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> 형 어노테이션을 사용하여 정의됩니다. 예를 들어, 이 코드는:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">InventoryItem</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;인벤토리에 있는 항목을 추적하는 클래스.&#39;&#39;&#39;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">unit_price</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">quantity_on_hand</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">total_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_price</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantity_on_hand</span>
</pre></div>
</div>
<p>다른 것 중에서도, 다음과 같은 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 를 추가합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unit_price</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">quantity_on_hand</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">unit_price</span> <span class="o">=</span> <span class="n">unit_price</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">quantity_on_hand</span> <span class="o">=</span> <span class="n">quantity_on_hand</span>
</pre></div>
</div>
<p>이 메서드는 클래스에 자동으로 추가됩니다: 위의 <code class="docutils literal notranslate"><span class="pre">InventoryItem</span></code> 정의에서 직접 지정되지는 않았습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
<div class="admonition-flowdas admonition">
<p class="admonition-title">flowdas</p>
<p>파이썬 3.6 을 위한 <a class="reference external" href="https://pypi.org/project/dataclasses/">역 이식</a> 도
제공됩니다. 하지만, <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">변수 어노테이션</span></a>을 필요로
하는 모듈이기 때문에, 파이썬 3.5 나 그 이전 버전에서는 지원할 방법이 없습니다.</p>
</div>
<div class="section" id="module-level-decorators-classes-and-functions">
<h2>모듈 수준의 데코레이터, 클래스 및 함수<a class="headerlink" href="#module-level-decorators-classes-and-functions" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="dataclasses.dataclass">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">dataclass</code><span class="sig-paren">(</span><em class="sig-param">*</em>, <em class="sig-param">init=True</em>, <em class="sig-param">repr=True</em>, <em class="sig-param">eq=True</em>, <em class="sig-param">order=False</em>, <em class="sig-param">unsafe_hash=False</em>, <em class="sig-param">frozen=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.dataclass" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 (아래에서 설명하는) 생성된 <a class="reference internal" href="../glossary.html#term-special-method"><span class="xref std std-term">특수 메서드</span></a>를 클래스에 추가하는데 사용되는 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">데코레이터</span></a> 입니다.</p>
<p><a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 데코레이터는 클래스를 검사하여 필드를 찾습니다. 필드는 <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">형 어노테이션</span></a>을 가진 클래스 변수로 정의됩니다. 아래에 설명된 두 가지 예외를 제외하고는, <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 는 변수 어노테이션에 지정된 형을 검사하지 않습니다.</p>
<p>생성된 모든 메서드의 필드 순서는 클래스 정의에 나타나는 순서입니다.</p>
<p><a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 데코레이터는 여러 &quot;던더(dunder)&quot; 메서드들을 클래스에 추가하는데, 아래에서 설명합니다. 추가할 메서드가 클래스에 이미 존재하면, 동작은 아래에 설명된 대로 매개변수에 따라 다릅니다. 데코레이터는 호출된 클래스와 같은 클래스를 반환합니다; 새 클래스가 만들어지지 않습니다.</p>
<p><a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 가 매개변수 없는 단순한 데코레이터로 사용되면, 이 서명에 문서화 된 기본값들이 제공된 것처럼 행동합니다. 즉, 다음 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 의 세 가지 용법은 동등합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="o">...</span>

<span class="nd">@dataclass</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="o">...</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">frozen</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
   <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 의 매개변수는 다음과 같습니다:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">init</span></code>: 참(기본값)이면, <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드가 생성됩니다.</p>
<p>클래스가 이미 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 를 정의했으면, 이 매개변수는 무시됩니다.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">repr</span></code>: 참(기본값)이면, <a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 메서드가 생성됩니다. 생성된 repr 문자열은 클래스 이름과 각 필드의 이름과 repr 을 갖습니다. 각 필드는 클래스에 정의된 순서대로 표시됩니다. repr에서 제외하도록 표시된 필드는 포함되지 않습니다. 예를 들어: 예 :<code class="docutils literal notranslate"><span class="pre">InventoryItem(name='widget',</span> <span class="pre">unit_price=3.0,</span> <span class="pre">quantity_on_hand=10)</span></code>.</p>
<p>클래스가 이미 <a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 을 정의했으면, 이 매개변수는 무시됩니다.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">eq</span></code>: 참(기본값)이면, <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 메서드가 생성됩니다. 이 메서드는 클래스를 필드의 튜플인 것처럼 순서대로 비교합니다. 비교되는 두 인스턴스는 같은 형이어야 합니다.</p>
<p>클래스가 이미 <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 정의했으면, 이 매개변수는 무시됩니다.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">order</span></code>: 참이면 (기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code>), <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> 메서드가 생성됩니다. 이것들은 클래스를 필드의 튜플인 것처럼 순서대로 비교합니다. 비교되는 두 인스턴스는 같은 형이어야 합니다. <code class="docutils literal notranslate"><span class="pre">order</span></code> 가 참이고 <code class="docutils literal notranslate"><span class="pre">eq</span></code> 가 거짓이면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 가 발생합니다.</p>
<p>클래스가 이미 <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> 중 하나를 정의하고 있다면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 가 발생합니다.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">unsafe_hash</span></code>: <code class="docutils literal notranslate"><span class="pre">False</span></code> (기본값) 면 : <code class="docutils literal notranslate"><span class="pre">eq</span></code> 와 <code class="docutils literal notranslate"><span class="pre">frozen</span></code> 의 설정에 따라 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드가 생성됩니다.</p>
<p><a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 는 내장 <a class="reference internal" href="functions.html#hash" title="hash"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hash()</span></code></a> 에 의해 사용되며, 딕셔너리와 집합 같은 해시 컬렉션에 객체가 추가될 때 사용됩니다. <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 갖는다는 것은 클래스의 인스턴스가 불변이라는 것을 의미합니다. 가변성은 프로그래머의 의도, <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 의 존재와 행동, <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 데코레이터의 <code class="docutils literal notranslate"><span class="pre">eq</span></code> 와 <code class="docutils literal notranslate"><span class="pre">frozen</span></code> 플래그의 값에 의존하는 복잡한 성질입니다.</p>
<p>기본적으로, <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 는 안전하지 않다면 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드를 묵시적으로 추가하지 않습니다. 기존에 명시적으로 정의된 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드를 추가하거나 변경하지도 않습니다. <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 문서에서 설명된 대로, 클래스 어트리뷰트를 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> 로 설정하는 것은 파이썬에 특별한 의미가 있습니다.</p>
<p><a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 가 명시적으로 정의되어 있지 않거나 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정된 경우, <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 는 묵시적 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드를 <em>추가할 수 있습니다</em>. 권장하지는 않지만, <code class="docutils literal notranslate"><span class="pre">unsafe_hash=True</span></code> 로 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 가 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드를 만들도록 강제할 수 있습니다. 이것은 당신의 클래스가 논리적으로 불변이지만, 그런데도 변경될 수 있는 경우 일 수 있습니다. 이는 특수한 사용 사례이므로 신중하게 고려해야 합니다.</p>
<p>다음은 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드의 묵시적 생성을 관장하는 규칙입니다. 데이터 클래스에 명시적 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드를 가지면서 <code class="docutils literal notranslate"><span class="pre">unsafe_hash=True</span></code> 를 설정할 수는 없습니다; 그러면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 가 발생합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">eq</span></code> 와 <code class="docutils literal notranslate"><span class="pre">frozen</span></code> 이 모두 참이면, 기본적으로 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 는 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드를 만듭니다. <code class="docutils literal notranslate"><span class="pre">eq</span></code> 가 참이고 <code class="docutils literal notranslate"><span class="pre">frozen</span></code> 이 거짓이면, <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정되어 해시 불가능하다고 표시됩니다(가변이기 때문입니다). 만약 <code class="docutils literal notranslate"><span class="pre">eq</span></code> 가 거짓이면, <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 건드리지 않는데, 슈퍼 클래스의 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 가 사용된다는 뜻이 됩니다 (슈퍼 클래스가 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 라면, id 기반 해싱으로 돌아간다는 뜻입니다).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">frozen</span></code>: 참이면 (기본값은 <code class="docutils literal notranslate"><span class="pre">False</span></code>), 필드에 대입하면 예외를 발생시킵니다. 이것은 읽기 전용 고정 인스턴스를 흉내 냅니다. <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 또는 <a class="reference internal" href="../reference/datamodel.html#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a> 이 클래스에 정의되어 있다면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 가 발생합니다. 아래 토론을 참조하십시오.</p></li>
</ul>
<p>필드는 선택적으로 일반적인 파이썬 문법을 사용하여 기본값을 지정할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span>       <span class="c1"># &#39;a&#39; 에는 기본값이 없습니다</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># &#39;b&#39; 에 기본값을 대입합니다</span>
</pre></div>
</div>
<p>이 예제에서, <code class="docutils literal notranslate"><span class="pre">a</span></code> 와 <code class="docutils literal notranslate"><span class="pre">b</span></code> 모두 추가된 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드에 포함되는데, 이런 식으로 정의됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
</pre></div>
</div>
<p>기본값이 없는 필드가 기본값이 있는 필드 뒤에 오는 경우 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 가 발생합니다. 이것은 단일 클래스에서 일어날 수도 있고, 클래스 상속의 결과일 때도 마찬가지입니다.</p>
</dd></dl>

<dl class="function">
<dt id="dataclasses.field">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">field</code><span class="sig-paren">(</span><em class="sig-param">*</em>, <em class="sig-param">default=MISSING</em>, <em class="sig-param">default_factory=MISSING</em>, <em class="sig-param">repr=True</em>, <em class="sig-param">hash=None</em>, <em class="sig-param">init=True</em>, <em class="sig-param">compare=True</em>, <em class="sig-param">metadata=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.field" title="정의 주소">¶</a></dt>
<dd><p>일반적이고 간단한 사용 사례의 경우 다른 기능은 필요하지 않습니다. 그러나 필드별로 추가 정보가 필요한 일부 데이터 클래스 기능이 있습니다. 추가 정보에 대한 필요성을 충족시키기 위해, 기본 필드 값을 제공된 <a class="reference internal" href="#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code></a> 함수 호출로 바꿀 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">mylist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">mylist</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>위에서 보인 것처럼, <code class="docutils literal notranslate"><span class="pre">MISSING</span></code> 값은 <code class="docutils literal notranslate"><span class="pre">default</span></code> 와 <code class="docutils literal notranslate"><span class="pre">default_factory</span></code> 매개변수가 제공되는지를 탐지하는데 사용되는 표지 객체입니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 <code class="docutils literal notranslate"><span class="pre">default</span></code> 에 유효한 값이기 때문에 이 표지가 사용됩니다. 어떤 코드도 <code class="docutils literal notranslate"><span class="pre">MISSING</span></code> 값을 직접 사용해서는 안 됩니다.</p>
<p><a class="reference internal" href="#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code></a> 의 매개변수는 다음과 같습니다:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">default</span></code>: 제공되면, 이 필드의 기본값이 됩니다. 이것은 <a class="reference internal" href="#dataclasses.field" title="dataclasses.field"><code class="xref py py-meth docutils literal notranslate"><span class="pre">field()</span></code></a> 호출 자체가 기본값의 정상 위치를 대체하기 때문에 필요합니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">default_factory</span></code>: 제공되면, 이 필드의 기본값이 필요할 때 호출되는 인자가 없는 콜러블이어야 합니다. 여러 용도 중에서도, 이것은 아래에서 논의되는 것처럼 가변 기본값을 가진 필드를 지정하는 데 사용될 수 있습니다. <code class="docutils literal notranslate"><span class="pre">default</span></code> 와 <code class="docutils literal notranslate"><span class="pre">default_factory</span></code> 를 모두 지정하는 것은 에러입니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">init</span></code>: 참(기본값)이면, 이 필드는 생성된 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드의 매개변수로 포함됩니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">repr</span></code>: 참(기본값)이면, 이 필드는 생성된 <a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 메서드가 돌려주는 문자열에 포함됩니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compare</span></code>: 참(기본값)이면, 이 필드는 생성된 같음 및 비교 메서드(<a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> 등)에 포함됩니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hash</span></code>: 이것은 bool 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code> 일 수 있습니다. 참이면, 이 필드는 생성된 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드에 포함됩니다. <code class="docutils literal notranslate"><span class="pre">None</span></code> (기본값) 이면, <code class="docutils literal notranslate"><span class="pre">compare</span></code> 의 값을 사용합니다. 이것은 일반적으로 기대되는 행동입니다. 필드가 비교에 사용되면 해시에서 고려해야 합니다. 이 값을 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이외의 값으로 설정하는 것은 권장하지 않습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">hash=False</span></code> 이지만 <code class="docutils literal notranslate"><span class="pre">compare=True</span></code> 로 설정하는 한 가지 가능한 이유는, 동등 비교에 포함되는 필드가 해시값을 계산하는 데 비용이 많이 들고, 형의 해시값에 이바지하는 다른 필드가 있는 경우입니다. 필드가 해시에서 제외된 경우에도 비교에는 계속 사용됩니다.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">metadata</span></code>: 매핑이나 None이 될 수 있습니다. None은 빈 딕셔너리로 취급됩니다. 이 값은 <a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-func docutils literal notranslate"><span class="pre">MappingProxyType()</span></code></a> 로 감싸져서 읽기 전용으로 만들어지고, <a class="reference internal" href="#dataclasses.Field" title="dataclasses.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> 객체에 노출됩니다. 데이터 클래스에서는 전혀 사용되지 않으며, 제삼자 확장 메커니즘으로 제공됩니다. 여러 제삼자는 이름 공간으로 사용할 자신만의 키를 가질 수 있습니다.</p></li>
</ul>
<p>필드의 기본값이 <a class="reference internal" href="#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code></a> 호출로 지정되면, 이 필드의 클래스 어트리뷰트는 지정한 <code class="docutils literal notranslate"><span class="pre">default</span></code> 값으로 대체됩니다. <code class="docutils literal notranslate"><span class="pre">default</span></code> 가 제공되지 않으면 클래스 어트리뷰트는 삭제됩니다. 그 의도는, <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 데코레이터 실행 후에, 기본값 자체가 지정된 것처럼 클래스 어트리뷰트가 모드 필드의 기본값을 갖도록 만드는 것입니다. 예를 들어, 이렇게 한 후에는:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">t</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div>
</div>
<p>클래스 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">C.z</span></code> 는 <code class="docutils literal notranslate"><span class="pre">10</span></code> 이 되고, 클래스 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">C.t</span></code> 는 <code class="docutils literal notranslate"><span class="pre">20</span></code> 이 되고, 클래스 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">C.x</span></code> 와 <code class="docutils literal notranslate"><span class="pre">C.y</span></code> 는 설정되지 않게 됩니다.</p>
</dd></dl>

<dl class="class">
<dt id="dataclasses.Field">
<em class="property">class </em><code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">Field</code><a class="headerlink" href="#dataclasses.Field" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#dataclasses.Field" title="dataclasses.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> 객체는 정의된 각 필드를 설명합니다. 이 객체는 내부적으로 생성되며 <a class="reference internal" href="#dataclasses.fields" title="dataclasses.fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">fields()</span></code></a> 모듈 수준 메서드(아래 참조)가 돌려줍니다. 사용자는 직접 <a class="reference internal" href="#dataclasses.Field" title="dataclasses.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> 인스턴스 객체를 만들어서는 안 됩니다. 문서화 된 어트리뷰트는 다음과 같습니다:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: 필드의 이름.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: 필드의 형.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">default</span></code>, <code class="docutils literal notranslate"><span class="pre">default_factory</span></code>, <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">repr</span></code>, <code class="docutils literal notranslate"><span class="pre">hash</span></code>, <code class="docutils literal notranslate"><span class="pre">compare</span></code>, <code class="docutils literal notranslate"><span class="pre">metadata</span></code> 는 <a class="reference internal" href="#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code></a> 선언에서와 같은 의미와 값을 가지고 있습니다.</p></li>
</ul>
</div></blockquote>
<p>다른 어트리뷰트도 있을 수 있지만, 내부적인 것이므로 검사하거나 의존해서는 안 됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="dataclasses.fields">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">fields</code><span class="sig-paren">(</span><em class="sig-param">class_or_instance</em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.fields" title="정의 주소">¶</a></dt>
<dd><p>데이터 클래스의 필드들을 정의하는 <a class="reference internal" href="#dataclasses.Field" title="dataclasses.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> 객체들의 튜플을 돌려줍니다. 데이터 클래스나 데이터 클래스의 인스턴스를 받아들입니다. 데이터 클래스 나 데이터 클래스의 인스턴스를 전달하지 않으면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 돌려줍니다. <code class="docutils literal notranslate"><span class="pre">ClassVar</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">InitVar</span></code> 인 의사 필드는 반환하지 않습니다.</p>
</dd></dl>

<dl class="function">
<dt id="dataclasses.asdict">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">asdict</code><span class="sig-paren">(</span><em class="sig-param">instance</em>, <em class="sig-param">*</em>, <em class="sig-param">dict_factory=dict</em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.asdict" title="정의 주소">¶</a></dt>
<dd><p>데이터 클래스 <code class="docutils literal notranslate"><span class="pre">instance</span></code> 를 딕셔너리로 변환합니다 (팩토리 함수 <code class="docutils literal notranslate"><span class="pre">dict_factory</span></code> 를 사용합니다). 각 데이터 클래스는 각 필드를 <code class="docutils literal notranslate"><span class="pre">name:</span> <span class="pre">value</span></code> 쌍으로 갖는 딕셔너리로 변환됩니다. 데이터 클래스, 딕셔너리, 리스트 및 튜플은 재귀적으로 변환됩니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
     <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
     <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
     <span class="n">mylist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Point</span><span class="p">]</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">asdict</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">([</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="k">assert</span> <span class="n">asdict</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;mylist&#39;</span><span class="p">:</span> <span class="p">[{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}]}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">instance</span></code> 가 데이터 클래스 인스턴스가 아닌 경우 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="dataclasses.astuple">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">astuple</code><span class="sig-paren">(</span><em class="sig-param">instance</em>, <em class="sig-param">*</em>, <em class="sig-param">tuple_factory=tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.astuple" title="정의 주소">¶</a></dt>
<dd><p>데이터 클래스 <code class="docutils literal notranslate"><span class="pre">instance</span></code> 를 튜플로 변환합니다 (팩토리 함수 <code class="docutils literal notranslate"><span class="pre">tuple_factory</span></code> 를 사용합니다). 각 데이터 클래스는 각 필드 값들의 튜플로 변환됩니다. 데이터 클래스, 딕셔너리, 리스트 및 튜플은 재귀적으로 변환됩니다.</p>
<p>이전 예에서 계속하면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">astuple</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">astuple</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">instance</span></code> 가 데이터 클래스 인스턴스가 아닌 경우 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="function">
<dt id="dataclasses.make_dataclass">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">make_dataclass</code><span class="sig-paren">(</span><em class="sig-param">cls_name</em>, <em class="sig-param">fields</em>, <em class="sig-param">*</em>, <em class="sig-param">bases=()</em>, <em class="sig-param">namespace=None</em>, <em class="sig-param">init=True</em>, <em class="sig-param">repr=True</em>, <em class="sig-param">eq=True</em>, <em class="sig-param">order=False</em>, <em class="sig-param">unsafe_hash=False</em>, <em class="sig-param">frozen=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.make_dataclass" title="정의 주소">¶</a></dt>
<dd><p>새로운 데이터 클래스를 만드는데, 이름은 <code class="docutils literal notranslate"><span class="pre">cls_name</span></code> 이고, <code class="docutils literal notranslate"><span class="pre">fields</span></code> 에 정의된 필드들을 갖고, <code class="docutils literal notranslate"><span class="pre">bases</span></code> 에 주어진 베이스 클래스들을 갖고, <code class="docutils literal notranslate"><span class="pre">namespace</span></code> 로 주어진 이름 공간으로 초기화됩니다. <code class="docutils literal notranslate"><span class="pre">fields</span></code> 는 요소가 <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">type)</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">type,</span> <span class="pre">Field)</span></code> 인 이터러블입니다. <code class="docutils literal notranslate"><span class="pre">name</span></code> 만 제공되면 <code class="docutils literal notranslate"><span class="pre">typing.Any</span></code> 가 <code class="docutils literal notranslate"><span class="pre">type</span></code> 으로 사용됩니다. <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">repr</span></code>, <code class="docutils literal notranslate"><span class="pre">eq</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span></code>, <code class="docutils literal notranslate"><span class="pre">unsafe_hash</span></code>, <code class="docutils literal notranslate"><span class="pre">frozen</span></code> 의 값은 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 에서와 같은 의미가 있습니다.</p>
<p>이 함수가 꼭 필요하지는 않습니다. 임의의 파이썬 메커니즘으로 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 을 갖는 새 클래스를 만든 후에 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 함수를 적용하면 데이터 클래스로 변환되기 때문입니다. 이 함수는 편의상 제공됩니다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="n">make_dataclass</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span>
                   <span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                     <span class="s1">&#39;y&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">))],</span>
                   <span class="n">namespace</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;add_one&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">})</span>
</pre></div>
</div>
<p>는 다음과 동등합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="s1">&#39;typing.Any&#39;</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="dataclasses.replace">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">instance</em>, <em class="sig-param">**changes</em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.replace" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">instance</span></code> 와 같은 형의 새 객체를 만드는데, 필드를 <code class="docutils literal notranslate"><span class="pre">changes</span></code> 의 값들로 대체합니다. <code class="docutils literal notranslate"><span class="pre">instance</span></code> 가 데이터 클래스가 아니라면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 발생시킵니다. <code class="docutils literal notranslate"><span class="pre">changes</span></code> 의 값이 필드를 지정하지 않으면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 발생시킵니다.</p>
<p>새로 반환된 객체는 데이터 클래스의 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드를 호출하여 생성됩니다. 이렇게 함으로써 (있는 경우) <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code> 의 호출을 보장합니다.</p>
<p>기본값을 가지지 않는 초기화 전용 변수가 존재한다면, <a class="reference internal" href="#dataclasses.replace" title="dataclasses.replace"><code class="xref py py-func docutils literal notranslate"><span class="pre">replace()</span></code></a> 호출에 반드시 지정해서 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 와 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code> 에 전달 될 수 있도록 해야 합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">changes</span></code> 가 <code class="docutils literal notranslate"><span class="pre">init=False</span></code> 를 갖는 것으로 정의된 필드를 포함하는 것은 에러입니다. 이 경우 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 가 발생합니다.</p>
<p><a class="reference internal" href="#dataclasses.replace" title="dataclasses.replace"><code class="xref py py-func docutils literal notranslate"><span class="pre">replace()</span></code></a>를 호출하는 동안 <code class="docutils literal notranslate"><span class="pre">init=False</span></code> 필드가 어떻게 작동하는지 미리 경고합니다. 그것들은 소스 객체로부터 복사되는 것이 아니라, (초기화되기는 한다면) <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code> 에서 초기화됩니다. <code class="docutils literal notranslate"><span class="pre">init=False</span></code> 필드는 거의 사용되지 않으리라고 예상합니다. 사용된다면, 대체 클래스 생성자를 사용하거나, 인스턴스 복사를 처리하는 사용자 정의 <code class="docutils literal notranslate"><span class="pre">replace()</span></code> (또는 비슷하게 이름 지어진) 메서드를 사용하는 것이 좋을 것입니다.</p>
</dd></dl>

<dl class="function">
<dt id="dataclasses.is_dataclass">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">is_dataclass</code><span class="sig-paren">(</span><em class="sig-param">class_or_instance</em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.is_dataclass" title="정의 주소">¶</a></dt>
<dd><p>매개변수가 데이터 클래스나 데이터 클래스의 인스턴스면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환하고, 그렇지 않으면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
<p>(데이터 클래스 자체가 아니라) 데이터 클래스의 인스턴스인지 알아야 한다면 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">isinstance(obj,</span> <span class="pre">type)</span></code> 검사를 추가하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_dataclass_instance</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">is_dataclass</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="post-init-processing">
<h2>초기화 후처리<a class="headerlink" href="#post-init-processing" title="제목 주소">¶</a></h2>
<p>클래스에 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code> 가 정의된 경우, 생성된 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 코드는 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code> 메서드를 호출합니다. 일반적으로 <code class="docutils literal notranslate"><span class="pre">self.__post_init__()</span></code> 로 호출됩니다. 그러나, <code class="docutils literal notranslate"><span class="pre">InitVar</span></code> 필드가 정의되어 있으면, 클래스에 정의된 순서대로 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code> 로 전달됩니다. <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드가 생성되지 않으면, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code> 가 자동으로 호출되지 않습니다.</p>
<p>다른 용도 중에서도, 하나나 그 이상의 다른 필드에 의존하는 필드 값을 초기화하는데 사용할 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
</pre></div>
</div>
<p>매개변수를 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code> 에 전달하는 방법은 초기화 전용 변수에 대한 아래 섹션을 참조하십시오. 또한 <a class="reference internal" href="#dataclasses.replace" title="dataclasses.replace"><code class="xref py py-func docutils literal notranslate"><span class="pre">replace()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">init=False</span></code> 필드를 처리하는 방식에 관한 경고를 보십시오.</p>
</div>
<div class="section" id="class-variables">
<h2>클래스 변수<a class="headerlink" href="#class-variables" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 가 실제로 필드의 형을 검사하는 두 곳 중 하나는 필드가 <span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> 에 정의된 클래스 변수인지를 확인하는 것입니다. 필드의 형이 <code class="docutils literal notranslate"><span class="pre">typing.ClassVar</span></code> 인지 검사합니다. 필드가 <code class="docutils literal notranslate"><span class="pre">ClassVar</span></code> 인 경우, 필드로 취급되지 않고 데이터 클래스 메커니즘에서 무시됩니다. 이런 <code class="docutils literal notranslate"><span class="pre">ClassVar</span></code> 의사 필드는 모듈 수준 <a class="reference internal" href="#dataclasses.fields" title="dataclasses.fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">fields()</span></code></a> 함수에 의해 반환되지 않습니다.</p>
</div>
<div class="section" id="init-only-variables">
<h2>초기화 전용 변수<a class="headerlink" href="#init-only-variables" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 가 형 어노테이션을 검사하는 다른 한 곳은 필드가 초기화 전용 변수인지 확인하는 것입니다. 필드의 형이 <code class="docutils literal notranslate"><span class="pre">dataclasses.InitVar</span></code> 인지 검사합니다. 필드가 <code class="docutils literal notranslate"><span class="pre">InitVar</span></code> 인 경우, 초기화 전용 변수라고 불리는 의사 필드로 간주합니다. 실제 필드가 아니므로, 모듈 수준 <a class="reference internal" href="#dataclasses.fields" title="dataclasses.fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">fields()</span></code></a> 함수에 의해 반환되지 않습니다. 초기화 전용 필드는 생성된 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드의 매개변수로 추가되며, 선택적인 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code> 메서드로 전달됩니다. 이 외에 데이터 클래스에서 사용되는 곳은 없습니다.</p>
<p>예를 들어, 클래스를 만들 때 값이 제공되지 않으면, 필드가 데이터베이스로부터 초기화된다고 가정합시다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">i</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">j</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">database</span><span class="p">:</span> <span class="n">InitVar</span><span class="p">[</span><span class="n">DatabaseType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">database</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">database</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s1">&#39;j&#39;</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">database</span><span class="o">=</span><span class="n">my_database</span><span class="p">)</span>
</pre></div>
</div>
<p>이 경우, <a class="reference internal" href="#dataclasses.fields" title="dataclasses.fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">fields()</span></code></a> 는 <code class="docutils literal notranslate"><span class="pre">i</span></code> 와 <code class="docutils literal notranslate"><span class="pre">j</span></code> 를 위한 <a class="reference internal" href="#dataclasses.Field" title="dataclasses.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> 객체를 반환하지만, <code class="docutils literal notranslate"><span class="pre">database</span></code> 는 반환하지 않습니다.</p>
</div>
<div class="section" id="frozen-instances">
<h2>고정 인스턴스<a class="headerlink" href="#frozen-instances" title="제목 주소">¶</a></h2>
<p>정말로 불변인 파이썬 객체를 만드는 것은 불가능합니다. 그러나, <code class="docutils literal notranslate"><span class="pre">frozen=True</span></code> 를 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 데코레이터에 전달함으로써 불변성을 흉내 낼 수 있습니다. 이 경우, 데이터 클래스는 <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 과 <a class="reference internal" href="../reference/datamodel.html#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a> 메서드를 클래스에 추가합니다. 이 메서드는 호출될 때 <a class="reference internal" href="#dataclasses.FrozenInstanceError" title="dataclasses.FrozenInstanceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FrozenInstanceError</span></code></a> 를 발생시킵니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">frozen=True</span></code> 를 사용할 때 약간의 성능 저하가 있습니다: <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 는 필드를 초기화하는데 간단한 대입을 사용할 수 없고, <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__setattr__()</span></code></a> 을 사용해야 합니다.</p>
</div>
<div class="section" id="inheritance">
<h2>계승<a class="headerlink" href="#inheritance" title="제목 주소">¶</a></h2>
<p>데이터 클래스가 <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dataclass()</span></code></a> 데코레이터에 의해 생성될 때, 클래스의 모든 베이스 클래스들을 MRO 역순(즉, <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 에서 시작해서)으로 조사하고, 발견되는 데이터 클래스마다 그 베이스 클래스의 필드들을 순서 있는 필드 매핑에 추가합니다. 모든 생성된 메서드들은 이 합쳐지고 계산된 순서 있는 필드 매핑을 사용합니다. 필드들이 삽입 순서이기 때문에, 파생 클래스는 베이스 클래스를 재정의합니다. 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="mf">15.0</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div>
</div>
<p>필드의 최종 목록은 순서대로 <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> 입니다. <code class="docutils literal notranslate"><span class="pre">x</span></code> 의 최종 형은 클래스 <code class="docutils literal notranslate"><span class="pre">C</span></code> 에서 지정된 <code class="docutils literal notranslate"><span class="pre">int</span></code> 입니다.</p>
<p>생성된 <code class="docutils literal notranslate"><span class="pre">C</span></code> 의 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드는 이렇게 됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
</pre></div>
</div>
</div>
<div class="section" id="default-factory-functions">
<h2>기본 팩토리 함수<a class="headerlink" href="#default-factory-functions" title="제목 주소">¶</a></h2>
<blockquote>
<div><p><a class="reference internal" href="#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">default_factory</span></code> 를 지정하면, 필드의 기본값이 필요할 때 인자 없이 호출됩니다. 예를 들어, 리스트의 새 인스턴스를 만들려면, 이렇게 하세요:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mylist</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
</pre></div>
</div>
<p>필드가 (<code class="docutils literal notranslate"><span class="pre">init=False</span></code> 를 사용해서) <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 에서 제외되고, 그 필드가 <code class="docutils literal notranslate"><span class="pre">default_factory</span></code> 를 지정하면, 생성된 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 함수는 항상 기본 팩토리 함수를 호출합니다. 이는 필드에 초기화 값을 제공할 수 있는 다른 방법이 없기 때문입니다.</p>
</div></blockquote>
</div>
<div class="section" id="mutable-default-values">
<h2>가변 기본값<a class="headerlink" href="#mutable-default-values" title="제목 주소">¶</a></h2>
<blockquote>
<div><p>파이썬은 기본 멤버 변숫값을 클래스 어트리뷰트에 저장합니다. 데이터 클래스를 사용하지 않는 이 예제를 생각해보세요:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

<span class="n">o1</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">o2</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">o1</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">o2</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">o1</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">o1</span><span class="o">.</span><span class="n">x</span> <span class="ow">is</span> <span class="n">o2</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<p>클래스 <code class="docutils literal notranslate"><span class="pre">C</span></code> 의 두 인스턴스는 예상대로 같은 클래스 변수 <code class="docutils literal notranslate"><span class="pre">x</span></code> 를 공유합니다.</p>
<p>데이터 클래스를 사용해서, <em>만약</em> 이 코드가 올바르다면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">element</span>
</pre></div>
</div>
<p>비슷한 코드를 생성합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">element</span>

<span class="k">assert</span> <span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">x</span> <span class="ow">is</span> <span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<p>이것은 클래스 <code class="docutils literal notranslate"><span class="pre">C</span></code> 를 사용한 원래 예제와 같은 문제를 가지고 있습니다. 즉, 클래스 인스턴스를 만들 때 <code class="docutils literal notranslate"><span class="pre">x</span></code> 에 대한 값을 지정하지 않는 클래스 <code class="docutils literal notranslate"><span class="pre">D</span></code> 의 두 인스턴스는 같은 <code class="docutils literal notranslate"><span class="pre">x</span></code> 를 공유합니다. 데이터 클래스는 일반적인 파이썬 클래스 생성을 사용하기 때문에, 이 동작 역시 공유합니다. 데이터 클래스가 이 조건을 감지하는 일반적인 방법은 없습니다. 대신, 데이터 클래스는 <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">dict</span></code>, <code class="docutils literal notranslate"><span class="pre">set</span></code> 형의 기본 매개변수를 탐지하면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 발생시킵니다. 이것은 부분적인 해결책이지만, 흔한 오류로부터 보호합니다.</p>
<p>기본 팩토리 함수를 사용하면 필드의 기본값으로 가변형의 새 인스턴스를 만들 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="exceptions">
<h2>예외<a class="headerlink" href="#exceptions" title="제목 주소">¶</a></h2>
<dl class="exception">
<dt id="dataclasses.FrozenInstanceError">
<em class="property">exception </em><code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">FrozenInstanceError</code><a class="headerlink" href="#dataclasses.FrozenInstanceError" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">frozen=True</span></code> 로 정의된 데이터 클래스에서 묵시적으로 정의된 <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 또는 <a class="reference internal" href="../reference/datamodel.html#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a> 이 호출 될 때 발생합니다.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dataclasses</span></code> --- 데이터 클래스</a><ul>
<li><a class="reference internal" href="#module-level-decorators-classes-and-functions">모듈 수준의 데코레이터, 클래스 및 함수</a></li>
<li><a class="reference internal" href="#post-init-processing">초기화 후처리</a></li>
<li><a class="reference internal" href="#class-variables">클래스 변수</a></li>
<li><a class="reference internal" href="#init-only-variables">초기화 전용 변수</a></li>
<li><a class="reference internal" href="#frozen-instances">고정 인스턴스</a></li>
<li><a class="reference internal" href="#inheritance">계승</a></li>
<li><a class="reference internal" href="#default-factory-functions">기본 팩토리 함수</a></li>
<li><a class="reference internal" href="#mutable-default-values">가변 기본값</a></li>
<li><a class="reference internal" href="#exceptions">예외</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="warnings.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code> --- 경고 제어</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="contextlib.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code> --- Utilities for <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code>-statement contexts</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="contextlib.html" title="contextlib --- Utilities for with-statement contexts"
             >다음</a> |</li>
        <li class="right" >
          <a href="warnings.html" title="warnings --- 경고 제어"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="python.html" >파이썬 실행시간 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>