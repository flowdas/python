
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>inspect --- 라이브 객체 검사 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="site --- 사이트별 구성 훅" href="site.html" />
    <link rel="prev" title="gc --- 가비지 수거기 인터페이스" href="gc.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/inspect.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="site.html" title="site --- 사이트별 구성 훅"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="gc.html" title="gc --- 가비지 수거기 인터페이스"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="python.html" accesskey="U">파이썬 실행시간 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-inspect">
<span id="inspect-inspect-live-objects"></span><h1><a class="reference internal" href="#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> --- 라이브 객체 검사<a class="headerlink" href="#module-inspect" title="제목 주소">¶</a></h1>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/inspect.py">Lib/inspect.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 모듈은 모듈, 클래스, 메서드, 함수, 트레이스백, 프레임 객체 및 코드 객체와 같은 라이브 객체에 대한 정보를 얻는 데 도움이 되는 몇 가지 유용한 함수를 제공합니다. 예를 들어, 클래스의 내용을 검사하거나, 메서드의 소스 코드를 꺼내오거나, 함수의 인자 리스트를 추출하고 포맷하거나, 자세한 트레이스백을 표시하는 데 필요한 모든 정보를 얻는 데 도움이 될 수 있습니다.</p>
<p>이 모듈은 4가지 종류의 주요 서비스를 제공합니다: 형 검사, 소스 코드 가져오기, 클래스와 함수 검사, 인터프리터 스택 검사.</p>
<div class="section" id="types-and-members">
<span id="inspect-types"></span><h2>형과 멤버<a class="headerlink" href="#types-and-members" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#inspect.getmembers" title="inspect.getmembers"><code class="xref py py-func docutils literal notranslate"><span class="pre">getmembers()</span></code></a> 함수는 클래스나 모듈과 같은 객체의 멤버를 검색합니다. 이름이 &quot;is&quot;로 시작하는 함수는 주로 <a class="reference internal" href="#inspect.getmembers" title="inspect.getmembers"><code class="xref py py-func docutils literal notranslate"><span class="pre">getmembers()</span></code></a>의 두 번째 인자로 쓰기에 편리하도록 제공됩니다. 또한 다음과 같은 특수 어트리뷰트를 언제 찾을 수 있는지 결정하는 데 도움이 됩니다:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 33%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>형</p></th>
<th class="head"><p>어트리뷰트</p></th>
<th class="head"><p>설명</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>모듈</p></td>
<td><p>__doc__</p></td>
<td><p>도큐멘테이션 문자열</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>__file__</p></td>
<td><p>파일명 (내장 모듈에는 없습니다)</p></td>
</tr>
<tr class="row-even"><td><p>클래스</p></td>
<td><p>__doc__</p></td>
<td><p>도큐멘테이션 문자열</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>__name__</p></td>
<td><p>이 클래스가 정의된 이름</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>__qualname__</p></td>
<td><p>정규화된 이름</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>__module__</p></td>
<td><p>이 클래스가 정의된 모듈의 이름</p></td>
</tr>
<tr class="row-even"><td><p>메서드</p></td>
<td><p>__doc__</p></td>
<td><p>도큐멘테이션 문자열</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>__name__</p></td>
<td><p>이 메서드가 정의된 이름</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>__qualname__</p></td>
<td><p>정규화된 이름</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>__func__</p></td>
<td><p>메서드의 구현을 포함하는 함수 객체</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>__self__</p></td>
<td><p>이 메서드가 연결된 인스턴스, 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>__module__</p></td>
<td><p>이 메서드가 정의된 모듈의 이름</p></td>
</tr>
<tr class="row-even"><td><p>함수</p></td>
<td><p>__doc__</p></td>
<td><p>도큐멘테이션 문자열</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>__name__</p></td>
<td><p>이 함수가 정의된 이름</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>__qualname__</p></td>
<td><p>정규화된 이름</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>__code__</p></td>
<td><p>컴파일된 함수 <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">바이트 코드</span></a>를 포함하는 코드 객체</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>__defaults__</p></td>
<td><p>위치나 키워드 매개 변수에 대한 기본값의 튜플</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>__kwdefaults__</p></td>
<td><p>키워드 전용 매개 변수의 기본값 매핑</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>__globals__</p></td>
<td><p>이 함수가 정의된 전역 이름 공간</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>__annotations__</p></td>
<td><p>매개 변수 이름에서 어노테이션으로의 매핑; <code class="docutils literal notranslate"><span class="pre">&quot;return&quot;</span></code> 키는 반환 값 어노테이션을 위해 예약되어 있습니다.</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>__module__</p></td>
<td><p>이 함수가 정의된 모듈의 이름</p></td>
</tr>
<tr class="row-odd"><td><p>트레이스백</p></td>
<td><p>tb_frame</p></td>
<td><p>이 수준의 프레임 객체</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>tb_lasti</p></td>
<td><p>바이트 코드에서 마지막으로 시도한 명령의 인덱스</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>tb_lineno</p></td>
<td><p>파이썬 소스 코드의 현재 줄 번호</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>tb_next</p></td>
<td><p>(이 수준에서 호출된) 다음 내부(inner) 트레이스백 객체</p></td>
</tr>
<tr class="row-odd"><td><p>프레임</p></td>
<td><p>f_back</p></td>
<td><p>다음 외부(outer) 프레임 객체 (이 프레임의 호출자)</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>f_builtins</p></td>
<td><p>이 프레임이 보는 내장 이름 공간</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>f_code</p></td>
<td><p>이 프레임에서 실행되는 코드 객체</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>f_globals</p></td>
<td><p>이 프레임이 보는 전역 이름 공간</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>f_lasti</p></td>
<td><p>바이트 코드에서 마지막으로 시도한 명령의 인덱스</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>f_lineno</p></td>
<td><p>파이썬 소스 코드의 현재 줄 번호</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>f_locals</p></td>
<td><p>이 프레임이 보는 지역 이름 공간</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>f_trace</p></td>
<td><p>이 프레임의 추적 함수(tracing function), 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>코드</p></td>
<td><p>co_argcount</p></td>
<td><p>인자 개수 (키워드 전용 인자, * 또는 ** 인자는 포함하지 않습니다)</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>co_code</p></td>
<td><p>컴파일된 날 바이트 코드의 문자열</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>co_cellvars</p></td>
<td><p>(포함하는 스코프가 참조하는) 셀 변수 이름의 튜플</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>co_consts</p></td>
<td><p>바이트 코드에서 사용되는 상수의 튜플</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>co_filename</p></td>
<td><p>이 코드 객체가 만들어진 파일의 이름</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>co_firstlineno</p></td>
<td><p>파이썬 소스 코드의 첫 줄 번호</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>co_flags</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">CO_*</span></code> 플래그의 비트맵, <a class="reference internal" href="#inspect-module-co-flags"><span class="std std-ref">여기</span></a>를 더 읽어보십시오</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>co_lnotab</p></td>
<td><p>줄 번호에서 바이트 코드 인덱스로의 인코딩된 매핑</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>co_freevars</p></td>
<td><p>(함수의 클로저를 통해 참조되는) 자유 변수(free variables) 이름의 튜플</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>co_posonlyargcount</p></td>
<td><p>위치 전용 인자의 개수</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>co_kwonlyargcount</p></td>
<td><p>키워드 전용 인자의 개수 (** 인자는 제외합니다)</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>co_name</p></td>
<td><p>이 코드 객체가 정의된 이름</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>co_names</p></td>
<td><p>지역 변수 이름의 튜플</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>co_nlocals</p></td>
<td><p>지역 변수의 개수</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>co_stacksize</p></td>
<td><p>필요한 가상 기계 스택 공간</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>co_varnames</p></td>
<td><p>인자와 지역 변수  이름의 튜플</p></td>
</tr>
<tr class="row-odd"><td><p>제너레이터</p></td>
<td><p>__name__</p></td>
<td><p>이름</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>__qualname__</p></td>
<td><p>정규화된 이름</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>gi_frame</p></td>
<td><p>프레임</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>gi_running</p></td>
<td><p>제너레이터가 실행 중입니까?</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>gi_code</p></td>
<td><p>코드</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>gi_yieldfrom</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>에 의해 이터레이트 중인 객체, 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>코루틴</p></td>
<td><p>__name__</p></td>
<td><p>이름</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>__qualname__</p></td>
<td><p>정규화된 이름</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>cr_await</p></td>
<td><p>어웨이트 중인 객체, 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>cr_frame</p></td>
<td><p>프레임</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>cr_running</p></td>
<td><p>코루틴이 실행 중입니까?</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>cr_code</p></td>
<td><p>코드</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>cr_origin</p></td>
<td><p>코루틴이 생성된 곳, 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>. <a class="reference internal" href="sys.html#sys.set_coroutine_origin_tracking_depth" title="sys.set_coroutine_origin_tracking_depth"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.set_coroutine_origin_tracking_depth()</span></code></a>를 참조하세요</p></td>
</tr>
<tr class="row-even"><td><p>내장</p></td>
<td><p>__doc__</p></td>
<td><p>도큐멘테이션 문자열</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>__name__</p></td>
<td><p>이 함수나 메서드의 원래 이름</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>__qualname__</p></td>
<td><p>정규화된 이름</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>__self__</p></td>
<td><p>메서드가 연결된 인스턴스, 또는 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><code class="docutils literal notranslate"><span class="pre">__qualname__</span></code>과 <code class="docutils literal notranslate"><span class="pre">gi_yieldfrom</span></code> 어트리뷰트를 제너레이터에 추가합니다.</p>
<p>제너레이터의 <code class="docutils literal notranslate"><span class="pre">__name__</span></code> 어트리뷰트는 이제 코드 이름 대신 함수 이름에서 설정되며, 이제 수정할 수 있습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>코루틴에 <code class="docutils literal notranslate"><span class="pre">cr_origin</span></code> 어트리뷰트를 추가합니다.</p>
</div>
<dl class="function">
<dt id="inspect.getmembers">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getmembers</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="optional">[</span>, <em class="sig-param">predicate</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getmembers" title="정의 주소">¶</a></dt>
<dd><p>이름으로 정렬된 <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> 쌍의 리스트로 객체(object)의 모든 멤버를 반환합니다. 각 멤버의 <code class="docutils literal notranslate"><span class="pre">value</span></code> 객체로 호출될 선택적 <em>predicate</em> 인자가 제공되면, predicate가 참값을 반환하는 멤버만 포함됩니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#inspect.getmembers" title="inspect.getmembers"><code class="xref py py-func docutils literal notranslate"><span class="pre">getmembers()</span></code></a>는 인자가 클래스이고 해당 클래스 어트리뷰트가 메타 클래스의 사용자 정의 <a class="reference internal" href="../reference/datamodel.html#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__dir__()</span></code></a>에서 나열될 때만 메타 클래스에 정의된 클래스 어트리뷰트를 반환합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.getmodulename">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getmodulename</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getmodulename" title="정의 주소">¶</a></dt>
<dd><p>감싸고 있는 패키지 이름 없이, 파일 경로(<em>path</em>)가 가리키는 모듈의 이름을 반환합니다. 파일 확장자는 <a class="reference internal" href="importlib.html#importlib.machinery.all_suffixes" title="importlib.machinery.all_suffixes"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.machinery.all_suffixes()</span></code></a>의 모든 항목에 대해 점검됩니다. 일치하면, 확장명이 제거된 최종 경로 구성 요소가 반환됩니다. 그렇지 않으면, <code class="docutils literal notranslate"><span class="pre">None</span></code>이 반환됩니다.</p>
<p>이 함수는 <em>오직</em> 실제 파이썬 모듈로 의미 있는 이름만 반환합니다. 잠재적으로 파이썬 패키지를 가리키는 경로는 여전히 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>이 함수는 <a class="reference internal" href="importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a>에 직접 기반합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.ismodule">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">ismodule</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.ismodule" title="정의 주소">¶</a></dt>
<dd><p>객체가 모듈이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.isclass">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">isclass</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.isclass" title="정의 주소">¶</a></dt>
<dd><p>객체가 (내장이거나 파이썬 코드로 만든) 클래스이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.ismethod">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">ismethod</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.ismethod" title="정의 주소">¶</a></dt>
<dd><p>객체가 파이썬으로 작성된 연결된(bound) 메서드면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.isfunction">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">isfunction</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.isfunction" title="정의 주소">¶</a></dt>
<dd><p>객체가 파이썬 함수이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다. <a class="reference internal" href="../glossary.html#term-lambda"><span class="xref std std-term">람다</span></a> 표현식으로 만든 함수를 포함합니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.isgeneratorfunction">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">isgeneratorfunction</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.isgeneratorfunction" title="정의 주소">¶</a></dt>
<dd><p>객체가 파이썬 제너레이터 함수이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>래핑 된 함수가 파이썬 제너레이터 함수일 때 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>로 래핑 된 함수는 이제 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.isgenerator">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">isgenerator</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.isgenerator" title="정의 주소">¶</a></dt>
<dd><p>객체가 제너레이터이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.iscoroutinefunction">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">iscoroutinefunction</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.iscoroutinefunction" title="정의 주소">¶</a></dt>
<dd><p>객체가 <a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">코루틴 함수</span></a>(<a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 문법으로 정의된 함수)이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>래핑 된 함수가 <a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">코루틴 함수</span></a>일 때 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>로 래핑 된 함수는 이제 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.iscoroutine">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">iscoroutine</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.iscoroutine" title="정의 주소">¶</a></dt>
<dd><p>객체가 <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 함수가 만든 <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a>이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.isawaitable">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">isawaitable</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.isawaitable" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식에서 객체를 사용할 수 있으면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<p>제너레이터 기반 코루틴을 일반 제너레이터와 구별하는 데 사용할 수도 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
    <span class="k">yield</span>
<span class="nd">@types</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">gen_coro</span><span class="p">():</span>
    <span class="k">yield</span>

<span class="k">assert</span> <span class="ow">not</span> <span class="n">isawaitable</span><span class="p">(</span><span class="n">gen</span><span class="p">())</span>
<span class="k">assert</span> <span class="n">isawaitable</span><span class="p">(</span><span class="n">gen_coro</span><span class="p">())</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.isasyncgenfunction">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">isasyncgenfunction</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.isasyncgenfunction" title="정의 주소">¶</a></dt>
<dd><p>객체가 <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">비동기 제너레이터</span></a> 함수이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다, 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">def</span> <span class="nf">agen</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">yield</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="o">.</span><span class="n">isasyncgenfunction</span><span class="p">(</span><span class="n">agen</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span>래핑 된 함수가 <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">비동기 제너레이터</span></a> 함수일 때 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>로 래핑 된 함수는 이제 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.isasyncgen">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">isasyncgen</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.isasyncgen" title="정의 주소">¶</a></dt>
<dd><p>객체가 <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> 함수가 만든 <a class="reference internal" href="../glossary.html#term-asynchronous-generator-iterator"><span class="xref std std-term">비동기 제너레이터 이터레이터</span></a>이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.istraceback">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">istraceback</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.istraceback" title="정의 주소">¶</a></dt>
<dd><p>객체가 트레이스백이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.isframe">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">isframe</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.isframe" title="정의 주소">¶</a></dt>
<dd><p>객체가 프레임이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.iscode">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">iscode</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.iscode" title="정의 주소">¶</a></dt>
<dd><p>객체가 코드이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.isbuiltin">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">isbuiltin</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.isbuiltin" title="정의 주소">¶</a></dt>
<dd><p>객체가 내장 함수나 연결된(bound) 내장 메서드이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.isroutine">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">isroutine</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.isroutine" title="정의 주소">¶</a></dt>
<dd><p>객체가 사용자 정의이거나 내장 함수나 메서드이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.isabstract">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">isabstract</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.isabstract" title="정의 주소">¶</a></dt>
<dd><p>객체가 추상 베이스 클래스이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.ismethoddescriptor">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">ismethoddescriptor</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.ismethoddescriptor" title="정의 주소">¶</a></dt>
<dd><p>객체가 메서드 디스크립터이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환하지만, <a class="reference internal" href="#inspect.ismethod" title="inspect.ismethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">ismethod()</span></code></a>, <a class="reference internal" href="#inspect.isclass" title="inspect.isclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">isclass()</span></code></a>, <a class="reference internal" href="#inspect.isfunction" title="inspect.isfunction"><code class="xref py py-func docutils literal notranslate"><span class="pre">isfunction()</span></code></a> 또는 <a class="reference internal" href="#inspect.isbuiltin" title="inspect.isbuiltin"><code class="xref py py-func docutils literal notranslate"><span class="pre">isbuiltin()</span></code></a>이 참일 때는 그렇지 않습니다.</p>
<p>예를 들어, 이것은 <code class="docutils literal notranslate"><span class="pre">int.__add__</span></code>에 대해서 참입니다. 이 테스트를 통과한 객체에는 <a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 메서드가 있지만 <a class="reference internal" href="../reference/datamodel.html#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> 메서드는 없습니다. 하지만 그 외의 어트리뷰트 집합은 달라집니다. <a class="reference internal" href="stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 어트리뷰트는 보통 존재하고, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code>도 종종 그렇습니다.</p>
<p>다른 테스트 중 하나를 통과하는 디스크립터로 구현된 메서드는 <a class="reference internal" href="#inspect.ismethoddescriptor" title="inspect.ismethoddescriptor"><code class="xref py py-func docutils literal notranslate"><span class="pre">ismethoddescriptor()</span></code></a> 테스트에서 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다. 단순히 다른 테스트가 더 많은 것을 약속하기 때문입니다 -- 예를 들어, 객체가 <a class="reference internal" href="#inspect.ismethod" title="inspect.ismethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">ismethod()</span></code></a>를 통과할 때 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> 어트리뷰트(등)가 있다고 기대할 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.isdatadescriptor">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">isdatadescriptor</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.isdatadescriptor" title="정의 주소">¶</a></dt>
<dd><p>객체가 데이터 디스크립터이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<p>데이터 디스크립터에는 <a class="reference internal" href="../reference/datamodel.html#object.__set__" title="object.__set__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__set__</span></code></a>이나 <a class="reference internal" href="../reference/datamodel.html#object.__delete__" title="object.__delete__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__delete__</span></code></a> 메서드가 있습니다. 예는 (파이썬으로 정의한) 프로퍼티, getset 및 멤버입니다. 뒤의 두 가지는 C로 정의되며 해당 형에 대해 더 구체적인 테스트가 있으며, 이는 다른 파이썬 구현에서도 지원됩니다. 일반적으로 데이터 디스크립터는 <a class="reference internal" href="stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>과 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 어트리뷰트를 갖지만 (프로퍼티, getet 및 멤버는 이 두 어트리뷰트를 모두 갖습니다), 이것이 보장되지는 않습니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.isgetsetdescriptor">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">isgetsetdescriptor</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.isgetsetdescriptor" title="정의 주소">¶</a></dt>
<dd><p>객체가 getset 디스크립터이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> getset은 <a class="reference internal" href="../c-api/structures.html#c.PyGetSetDef" title="PyGetSetDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyGetSetDef</span></code></a> 구조체를 통해 확장 모듈에서 정의된 어트리뷰트입니다. 이러한 형이 없는 파이썬 구현에서, 이 메서드는 항상 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.ismemberdescriptor">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">ismemberdescriptor</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.ismemberdescriptor" title="정의 주소">¶</a></dt>
<dd><p>객체가 멤버 디스크립터이면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환합니다.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> 멤버 디스크립터는 <a class="reference internal" href="../c-api/structures.html#c.PyMemberDef" title="PyMemberDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemberDef</span></code></a> 구조체를 통해 확장 모듈에서 정의된 어트리뷰트입니다. 이러한 형이 없는 파이썬 구현에서, 이 메서드는 항상 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 반환합니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="retrieving-source-code">
<span id="inspect-source"></span><h2>소스 코드 가져오기<a class="headerlink" href="#retrieving-source-code" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="inspect.getdoc">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getdoc</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getdoc" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#inspect.cleandoc" title="inspect.cleandoc"><code class="xref py py-func docutils literal notranslate"><span class="pre">cleandoc()</span></code></a>으로 정리된 객체의 독스트링을 가져옵니다. 객체가 독스트링을 제공하지 않고 객체가 클래스, 메서드, 프로퍼티 또는 디스크립터이면, 상속 계층 구조에서 독스트링을 가져옵니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이제 재정의되지 않으면 독스트링이 상속됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.getcomments">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getcomments</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getcomments" title="정의 주소">¶</a></dt>
<dd><p>객체의 소스 코드 바로 앞(클래스, 함수 또는 메서드일 때)이나 파이썬 소스 파일의 최상단 (객체가 모듈일 때) 주석 줄들을 단일 문자열로 반환합니다. 객체의 소스 코드를 사용할 수 없으면, <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다. 객체가 C나 대화식 셸에서 정의될 때 이런 일이 일어날 수 있습니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.getfile">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getfile</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getfile" title="정의 주소">¶</a></dt>
<dd><p>객체가 정의된 (텍스트나 바이너리) 파일의 이름을 반환합니다. 객체가 내장 모듈, 클래스 또는 함수이면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>로 실패합니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.getmodule">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getmodule</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getmodule" title="정의 주소">¶</a></dt>
<dd><p>객체가 정의된 모듈을 추측합니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.getsourcefile">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getsourcefile</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getsourcefile" title="정의 주소">¶</a></dt>
<dd><p>객체가 정의된 파이썬 소스 파일의 이름을 반환합니다. 객체가 내장 모듈, 클래스 또는 함수이면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>로 실패합니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.getsourcelines">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getsourcelines</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getsourcelines" title="정의 주소">¶</a></dt>
<dd><p>객체의 소스 줄의 리스트와 시작 줄 번호를 반환합니다. 인자는 모듈, 클래스, 메서드, 함수, 트레이스백, 프레임 또는 코드 객체일 수 있습니다. 소스 코드는 객체에 해당하는 줄 리스트로 반환되며 줄 번호는 원본 소스 파일에서 첫 번째 코드 줄이 발견되는 위치를 나타냅니다. 소스 코드를 가져올 수 없으면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다. 이제 IOError는 OSError의 별칭입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.getsource">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getsource</code><span class="sig-paren">(</span><em class="sig-param">object</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getsource" title="정의 주소">¶</a></dt>
<dd><p>객체의 소스 코드 텍스트를 반환합니다. 인자는 모듈, 클래스, 메서드, 함수, 트레이스백, 프레임 또는 코드 객체일 수 있습니다. 소스 코드는 단일 문자열로 반환됩니다. 소스 코드를 가져올 수 없으면 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span><a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a> 대신 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>가 발생합니다. 이제 IOError는 OSError의 별칭입니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.cleandoc">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">cleandoc</code><span class="sig-paren">(</span><em class="sig-param">doc</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.cleandoc" title="정의 주소">¶</a></dt>
<dd><p>코드 블록과 일치하도록 들여쓰기 된 독스트링에서 들여쓰기를 정리합니다.</p>
<p>모든 선행 공백이 첫 번째 줄에서 제거됩니다. 두 번째 줄부터 균일하게 제거할 수 있는 선행 공백이 제거됩니다. 시작과 끝의 빈 줄은 그다음에 제거됩니다. 또한, 모든 탭이 스페이스로 확장됩니다.</p>
</dd></dl>

</div>
<div class="section" id="introspecting-callables-with-the-signature-object">
<span id="inspect-signature-object"></span><h2>Signature 객체로 콜러블 검사하기<a class="headerlink" href="#introspecting-callables-with-the-signature-object" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
<p>Signature 객체는 콜러블 객체의 호출 서명과 반환 값 어노테이션을 나타냅니다. Signature 객체를 가져오려면, <a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">signature()</span></code></a> 함수를 사용하십시오.</p>
<dl class="function">
<dt id="inspect.signature">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">signature</code><span class="sig-paren">(</span><em class="sig-param">callable</em>, <em class="sig-param">*</em>, <em class="sig-param">follow_wrapped=True</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.signature" title="정의 주소">¶</a></dt>
<dd><p>주어진 <code class="docutils literal notranslate"><span class="pre">callable</span></code>에 대한 <a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> 객체를 반환합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
<span class="go">&#39;(a, *, b:int, **kwargs)&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="go">&#39;b:int&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">annotation</span>
<span class="go">&lt;class &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>일반 함수와 클래스에서 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> 객체에 이르기까지 광범위한 파이썬 콜러블을 받아들입니다.</p>
<p>서명을 제공할 수 없으면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생하고, 해당 객체 형이 지원되지 않으면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생합니다.</p>
<p>함수 서명에서 슬래시(/)는 그 앞의 매개 변수가 위치 전용임을 나타냅니다. 자세한 내용은 <a class="reference internal" href="../faq/programming.html#faq-positional-only-arguments"><span class="std std-ref">위치 전용 인자에 관한 FAQ 항목</span></a>을 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가: </span><code class="docutils literal notranslate"><span class="pre">follow_wrapped</span></code> 매개 변수. 구체적으로 <code class="docutils literal notranslate"><span class="pre">callable</span></code>의 서명을 가져오려면 <code class="docutils literal notranslate"><span class="pre">False</span></code>를 전달하십시오 (데코레이트 된 콜러블의 래핑을 풀기 위해 <code class="docutils literal notranslate"><span class="pre">callable.__wrapped__</span></code>를 사용하지 않게 됩니다).</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>특정 파이썬 구현에서 일부 콜러블은 검사할 수 없습니다. 예를 들어, CPython에서, C로 정의된 일부 내장 함수는 인자에 대한 메타 데이터를 제공하지 않습니다.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="inspect.Signature">
<em class="property">class </em><code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">Signature</code><span class="sig-paren">(</span><em class="sig-param">parameters=None</em>, <em class="sig-param">*</em>, <em class="sig-param">return_annotation=Signature.empty</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.Signature" title="정의 주소">¶</a></dt>
<dd><p>Signature 객체는 함수의 호출 서명과 반환 값 어노테이션을 나타냅니다. 함수가 받아들이는 각 매개 변수에 대해 <a class="reference internal" href="#inspect.Signature.parameters" title="inspect.Signature.parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parameters</span></code></a> 컬렉션에 <a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> 객체를 저장합니다.</p>
<p>선택적 <em>parameters</em> 인자는 <a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> 객체의 시퀀스이며, 중복된 이름을 가진 매개 변수가 없는지, 매개 변수가 올바른 순서인지 (즉, 위치 전용이 먼저 온 후, 위치-키워드가 그다음에 오는지), 기본값이 있는 매개 변수가 그렇지 않은 매개 변수 뒤에 오는지 검사합니다.</p>
<p>임의의 파이썬 객체일 수 있는, 선택적 <em>return_annotation</em> 인자는 콜러블의 &quot;반환 값&quot; 어노테이션입니다.</p>
<p>Signature 객체는 <em>불변(immutable)</em>입니다. 수정된 사본을 만들려면 <a class="reference internal" href="#inspect.Signature.replace" title="inspect.Signature.replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.replace()</span></code></a>를 사용하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>Signature 객체는 피클 가능하고 해시 가능합니다.</p>
</div>
<dl class="attribute">
<dt id="inspect.Signature.empty">
<code class="sig-name descname">empty</code><a class="headerlink" href="#inspect.Signature.empty" title="정의 주소">¶</a></dt>
<dd><p>반환 값 어노테이션이 없음을 지정하는 특수 클래스 수준 마커입니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="inspect.Signature.parameters">
<code class="sig-name descname">parameters</code><a class="headerlink" href="#inspect.Signature.parameters" title="정의 주소">¶</a></dt>
<dd><p>매개 변수 이름에서 해당 <a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> 객체로의 순서 있는 매핑. 키워드 전용 매개 변수를 포함하여, 매개 변수는 엄격한 정의 순서대로 나타납니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>실제로 파이썬 3에서 항상 유지되었습니다만, 파이썬은 버전 3.7부터 키워드 전용 매개 변수의 선언 순서를 유지한다는 것을 명시적으로 보장합니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="inspect.Signature.return_annotation">
<code class="sig-name descname">return_annotation</code><a class="headerlink" href="#inspect.Signature.return_annotation" title="정의 주소">¶</a></dt>
<dd><p>콜러블의 &quot;반환 값&quot; 어노테이션. 콜러블에 &quot;반환 값&quot; 어노테이션이 없으면, 이 어트리뷰트는 <a class="reference internal" href="#inspect.Signature.empty" title="inspect.Signature.empty"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Signature.empty</span></code></a>로 설정됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="inspect.Signature.bind">
<code class="sig-name descname">bind</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.Signature.bind" title="정의 주소">¶</a></dt>
<dd><p>위치와 키워드 인자에서 매개 변수로의 매핑을 만듭니다. <code class="docutils literal notranslate"><span class="pre">*args</span></code>와 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>가 서명과 일치하면 <a class="reference internal" href="#inspect.BoundArguments" title="inspect.BoundArguments"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoundArguments</span></code></a>를 반환하고, 그렇지 않으면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="inspect.Signature.bind_partial">
<code class="sig-name descname">bind_partial</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.Signature.bind_partial" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#inspect.Signature.bind" title="inspect.Signature.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.bind()</span></code></a>와 같은 방식으로 작동하지만, 일부 필수 인자를 생략 할 수 있습니다 (<a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> 동작을 흉내 냅니다). <a class="reference internal" href="#inspect.BoundArguments" title="inspect.BoundArguments"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoundArguments</span></code></a>를 반환하거나, 전달된 인자가 서명과 일치하지 않으면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="inspect.Signature.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">*[, parameters][, return_annotation]</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.Signature.replace" title="정의 주소">¶</a></dt>
<dd><p>replace가 호출된 인스턴스를 기반으로 새 Signature 인스턴스를 만듭니다. 다른 <code class="docutils literal notranslate"><span class="pre">parameters</span></code>나 <code class="docutils literal notranslate"><span class="pre">return_annotation</span></code> 또는 둘 모두를 전달하여 기반 서명의 해당 속성을 재정의할 수 있습니다. 복사된 Signature에서 return_annotation을 제거하려면, <a class="reference internal" href="#inspect.Signature.empty" title="inspect.Signature.empty"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Signature.empty</span></code></a>를 전달하십시오.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">return_annotation</span><span class="o">=</span><span class="s2">&quot;new return anno&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">new_sig</span><span class="p">)</span>
<span class="go">&quot;(a, b) -&gt; &#39;new return anno&#39;&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="inspect.Signature.from_callable">
<em class="property">classmethod </em><code class="sig-name descname">from_callable</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">*</em>, <em class="sig-param">follow_wrapped=True</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.Signature.from_callable" title="정의 주소">¶</a></dt>
<dd><p>주어진 콜러블 <code class="docutils literal notranslate"><span class="pre">obj</span></code>에 대한 <a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> (또는 이의 서브 클래스) 객체를 반환합니다. <code class="docutils literal notranslate"><span class="pre">__wrapped__</span></code> 체인의 래핑을 풀지 않고 <code class="docutils literal notranslate"><span class="pre">obj</span></code>의 서명을 얻으려면 <code class="docutils literal notranslate"><span class="pre">follow_wrapped=False</span></code>를 전달하십시오.</p>
<p>이 메서드는 <a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a>의 서브 클래싱을 단순화합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MySignature</span><span class="p">(</span><span class="n">Signature</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">sig</span> <span class="o">=</span> <span class="n">MySignature</span><span class="o">.</span><span class="n">from_callable</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span>
<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">MySignature</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="inspect.Parameter">
<em class="property">class </em><code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">Parameter</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">kind</em>, <em class="sig-param">*</em>, <em class="sig-param">default=Parameter.empty</em>, <em class="sig-param">annotation=Parameter.empty</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.Parameter" title="정의 주소">¶</a></dt>
<dd><p>Parameter 객체는 <em>불변(immutable)</em>입니다. Parameter 객체를 수정하는 대신, 수정된 사본을 만들려면 <a class="reference internal" href="#inspect.Parameter.replace" title="inspect.Parameter.replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Parameter.replace()</span></code></a>를 사용하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>Parameter 객체는 피클 가능하고 해시 가능합니다.</p>
</div>
<dl class="attribute">
<dt id="inspect.Parameter.empty">
<code class="sig-name descname">empty</code><a class="headerlink" href="#inspect.Parameter.empty" title="정의 주소">¶</a></dt>
<dd><p>기본값과 어노테이션이 없음을 지정하는 특수 클래스 수준 마커.</p>
</dd></dl>

<dl class="attribute">
<dt id="inspect.Parameter.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#inspect.Parameter.name" title="정의 주소">¶</a></dt>
<dd><p>문자열로 표현한 매개 변수의 이름. 이름은 유효한 파이썬 식별자여야 합니다.</p>
<div class="impl-detail compound">
<p class="compound-first"><strong>CPython implementation detail:</strong> CPython은 컴프리헨션과 제너레이터 표현식을 구현하는 데 사용되는 코드 객체에서 <code class="docutils literal notranslate"><span class="pre">.0</span></code> 형식의 묵시적 매개 변수 이름을 생성합니다.</p>
<div class="compound-last versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>이 매개 변수 이름은 이 모듈에서 <code class="docutils literal notranslate"><span class="pre">implicit0</span></code>과 같은 이름으로 노출됩니다.</p>
</div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="inspect.Parameter.default">
<code class="sig-name descname">default</code><a class="headerlink" href="#inspect.Parameter.default" title="정의 주소">¶</a></dt>
<dd><p>매개 변수의 기본값. 매개 변수에 기본값이 없으면, 이 어트리뷰트는 <a class="reference internal" href="#inspect.Parameter.empty" title="inspect.Parameter.empty"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Parameter.empty</span></code></a>로 설정됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="inspect.Parameter.annotation">
<code class="sig-name descname">annotation</code><a class="headerlink" href="#inspect.Parameter.annotation" title="정의 주소">¶</a></dt>
<dd><p>매개 변수의 어노테이션. 매개 변수에 어노테이션이 없으면, 이 어트리뷰트는 <a class="reference internal" href="#inspect.Parameter.empty" title="inspect.Parameter.empty"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Parameter.empty</span></code></a>로 설정됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="inspect.Parameter.kind">
<code class="sig-name descname">kind</code><a class="headerlink" href="#inspect.Parameter.kind" title="정의 주소">¶</a></dt>
<dd><p>인자 값이 매개 변수에 연결되는 방법을 설명합니다. 가능한 값은 다음과 같습니다 (<code class="docutils literal notranslate"><span class="pre">Parameter.KEYWORD_ONLY</span></code>처럼 <a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a>를 통해 액세스할 수 있습니다):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>이름</p></th>
<th class="head"><p>의미</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>POSITIONAL_ONLY</em></p></td>
<td><p>위치 인자로만 값을 제공해야 합니다. 위치 전용 매개 변수는 파이썬 함수 정의에서 <code class="docutils literal notranslate"><span class="pre">/</span></code> 항목 (있다면) 앞에 나오는 매개 변수입니다.</p></td>
</tr>
<tr class="row-odd"><td><p><em>POSITIONAL_OR_KEYWORD</em></p></td>
<td><p>값은 키워드나 위치 인자로 제공될 수 있습니다 (이것이 파이썬으로 구현된 함수의 표준 연결 동작입니다).</p></td>
</tr>
<tr class="row-even"><td><p><em>VAR_POSITIONAL</em></p></td>
<td><p>다른 매개 변수에 연결되지 않은 위치 인자의 튜플. 이것은 파이썬 함수 정의의 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 매개 변수에 해당합니다.</p></td>
</tr>
<tr class="row-odd"><td><p><em>KEYWORD_ONLY</em></p></td>
<td><p>키워드 인자로만 값을 제공해야 합니다. 키워드 전용 매개 변수는 파이썬 함수 정의에서 <code class="docutils literal notranslate"><span class="pre">*</span></code>나 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 항목 다음에 나오는 매개 변수입니다.</p></td>
</tr>
<tr class="row-even"><td><p><em>VAR_KEYWORD</em></p></td>
<td><p>다른 매개 변수에 연결되지 않은 키워드 인자의 딕셔너리. 이것은 파이썬 함수 정의의 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> 매개 변수에 해당합니다.</p></td>
</tr>
</tbody>
</table>
<p>예: 기본값이 없는 모든 키워드 전용 인자를 인쇄합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span> <span class="ow">and</span>
<span class="gp">... </span>                       <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Parameter:&#39;</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
<span class="go">Parameter: c</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="inspect.Parameter.kind.description">
<code class="sig-prename descclassname">kind.</code><code class="sig-name descname">description</code><a class="headerlink" href="#inspect.Parameter.kind.description" title="정의 주소">¶</a></dt>
<dd><p>Parameter.kind의 열거형 값을 설명합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
<p>예: 모든 인자의 설명을 인쇄합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">kind</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
<span class="go">positional or keyword</span>
<span class="go">positional or keyword</span>
<span class="go">keyword-only</span>
<span class="go">keyword-only</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="inspect.Parameter.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">*[, name][, kind][, default][, annotation]</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.Parameter.replace" title="정의 주소">¶</a></dt>
<dd><blockquote>
<div><p>replace가 호출된 인스턴스를 기반으로 새 Parameter 인스턴스를 만듭니다. <a class="reference internal" href="#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a> 어트리뷰트를 재정의하려면, 해당 인자를 전달하십시오. Parameter에서 기본값이나 어노테이션, 또는 둘 다 제거하려면 <a class="reference internal" href="#inspect.Parameter.empty" title="inspect.Parameter.empty"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Parameter.empty</span></code></a>를 전달하십시오.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">Parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
<span class="go">&#39;foo=42&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">replace</span><span class="p">())</span> <span class="c1"># &#39;param&#39;의 얕은 사본을 만듭니다</span>
<span class="go">&#39;foo=42&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="s1">&#39;spam&#39;</span><span class="p">))</span>
<span class="go">&quot;foo:&#39;spam&#39;&quot;</span>
</pre></div>
</div>
</div></blockquote>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>파이썬 3.3에서, <code class="docutils literal notranslate"><span class="pre">kind</span></code>가 <code class="docutils literal notranslate"><span class="pre">POSITIONAL_ONLY</span></code>로 설정되었을 때 Parameter 객체의 <code class="docutils literal notranslate"><span class="pre">name</span></code>을 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정할 수 있었습니다. 이는 더는 허용되지 않습니다.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="inspect.BoundArguments">
<em class="property">class </em><code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">BoundArguments</code><a class="headerlink" href="#inspect.BoundArguments" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#inspect.Signature.bind" title="inspect.Signature.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.bind()</span></code></a>나 <a class="reference internal" href="#inspect.Signature.bind_partial" title="inspect.Signature.bind_partial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.bind_partial()</span></code></a> 호출의 결과. 인자에서 함수의 매개 변수로의 매핑을 보관합니다.</p>
<dl class="attribute">
<dt id="inspect.BoundArguments.arguments">
<code class="sig-name descname">arguments</code><a class="headerlink" href="#inspect.BoundArguments.arguments" title="정의 주소">¶</a></dt>
<dd><p>매개 변수 이름에서 인자 값으로의 가변 매핑. 명시적으로 연결된 인자만 포함합니다. <a class="reference internal" href="#inspect.BoundArguments.arguments" title="inspect.BoundArguments.arguments"><code class="xref py py-attr docutils literal notranslate"><span class="pre">arguments</span></code></a>의 변경 사항은 <a class="reference internal" href="#inspect.BoundArguments.args" title="inspect.BoundArguments.args"><code class="xref py py-attr docutils literal notranslate"><span class="pre">args</span></code></a>와 <a class="reference internal" href="#inspect.BoundArguments.kwargs" title="inspect.BoundArguments.kwargs"><code class="xref py py-attr docutils literal notranslate"><span class="pre">kwargs</span></code></a>에 반영됩니다.</p>
<p>인자 처리 목적으로 <a class="reference internal" href="#inspect.Signature.parameters" title="inspect.Signature.parameters"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Signature.parameters</span></code></a>와 함께 사용해야 합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#inspect.Signature.bind" title="inspect.Signature.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.bind()</span></code></a>나 <a class="reference internal" href="#inspect.Signature.bind_partial" title="inspect.Signature.bind_partial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.bind_partial()</span></code></a>이 기본값에 의존하는 인자는 건너뜁니다. 그러나, 필요하다면 <a class="reference internal" href="#inspect.BoundArguments.apply_defaults" title="inspect.BoundArguments.apply_defaults"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BoundArguments.apply_defaults()</span></code></a>를 사용하여 추가하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span><a class="reference internal" href="#inspect.BoundArguments.arguments" title="inspect.BoundArguments.arguments"><code class="xref py py-attr docutils literal notranslate"><span class="pre">arguments</span></code></a>는 이제 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 형입니다. 이전에는, <a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 형이었습니다.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="inspect.BoundArguments.args">
<code class="sig-name descname">args</code><a class="headerlink" href="#inspect.BoundArguments.args" title="정의 주소">¶</a></dt>
<dd><p>위치 인자 값의 튜플. <a class="reference internal" href="#inspect.BoundArguments.arguments" title="inspect.BoundArguments.arguments"><code class="xref py py-attr docutils literal notranslate"><span class="pre">arguments</span></code></a> 어트리뷰트에서 동적으로 계산됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="inspect.BoundArguments.kwargs">
<code class="sig-name descname">kwargs</code><a class="headerlink" href="#inspect.BoundArguments.kwargs" title="정의 주소">¶</a></dt>
<dd><p>키워드 인자 값의 딕셔너리. <a class="reference internal" href="#inspect.BoundArguments.arguments" title="inspect.BoundArguments.arguments"><code class="xref py py-attr docutils literal notranslate"><span class="pre">arguments</span></code></a> 어트리뷰트에서 동적으로 계산됩니다.</p>
</dd></dl>

<dl class="attribute">
<dt id="inspect.BoundArguments.signature">
<code class="sig-name descname">signature</code><a class="headerlink" href="#inspect.BoundArguments.signature" title="정의 주소">¶</a></dt>
<dd><p>부모 <a class="reference internal" href="#inspect.Signature" title="inspect.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">Signature</span></code></a> 객체에 대한 참조.</p>
</dd></dl>

<dl class="method">
<dt id="inspect.BoundArguments.apply_defaults">
<code class="sig-name descname">apply_defaults</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#inspect.BoundArguments.apply_defaults" title="정의 주소">¶</a></dt>
<dd><p>누락된 인자에 대한 기본값을 설정합니다.</p>
<p>가변 위치 인자(<code class="docutils literal notranslate"><span class="pre">*args</span></code>)의 기본값은 빈 튜플입니다.</p>
<p>가변 변수 키워드 인자(<code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>)의 기본값은 빈 딕셔너리입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s1">&#39;ham&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ba</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ba</span><span class="o">.</span><span class="n">apply_defaults</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ba</span><span class="o">.</span><span class="n">arguments</span>
<span class="go">{&#39;a&#39;: &#39;spam&#39;, &#39;b&#39;: &#39;ham&#39;, &#39;args&#39;: ()}</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<p><a class="reference internal" href="#inspect.BoundArguments.args" title="inspect.BoundArguments.args"><code class="xref py py-attr docutils literal notranslate"><span class="pre">args</span></code></a>와 <a class="reference internal" href="#inspect.BoundArguments.kwargs" title="inspect.BoundArguments.kwargs"><code class="xref py py-attr docutils literal notranslate"><span class="pre">kwargs</span></code></a> 프로퍼티를 사용하여 함수를 호출할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="o">...</span>

<span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="n">ba</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">test</span><span class="p">(</span><span class="o">*</span><span class="n">ba</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">ba</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0362"><strong>PEP 362</strong></a> - 함수 Signature 객체.</dt><dd><p>자세한 명세, 구현 세부 사항 및 예</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="classes-and-functions">
<span id="inspect-classes-functions"></span><h2>클래스와 함수<a class="headerlink" href="#classes-and-functions" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="inspect.getclasstree">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getclasstree</code><span class="sig-paren">(</span><em class="sig-param">classes</em>, <em class="sig-param">unique=False</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getclasstree" title="정의 주소">¶</a></dt>
<dd><p>주어진 클래스 리스트를 중첩된 리스트의 계층 구조로 배치합니다. 중첩된 리스트가 나타나면, 리스트 바로 앞에 나오는 항목의 클래스에서 파생된 클래스를 포함합니다. 각 항목은 클래스와 베이스 클래스의 튜플을 포함하는 2-튜플입니다. <em>unique</em> 인자가 참이면, 주어진 리스트의 각 클래스가 반환된 구조에 정확히 하나의 항목으로 나타납니다. 그렇지 않으면, 다중 상속을 사용하는 클래스와 그 자식들이 여러 번 나타납니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.getargspec">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getargspec</code><span class="sig-paren">(</span><em class="sig-param">func</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getargspec" title="정의 주소">¶</a></dt>
<dd><p>파이썬 함수 매개 변수의 이름과 기본값을 가져옵니다. <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> <code class="docutils literal notranslate"><span class="pre">ArgSpec(args,</span> <span class="pre">varargs,</span> <span class="pre">keywords,</span> <span class="pre">defaults)</span></code>가 반환됩니다. <em>args</em>는 매개 변수 이름의 리스트입니다. <em>varargs</em>와 <em>keywords</em>는 <code class="docutils literal notranslate"><span class="pre">*</span></code>와 <code class="docutils literal notranslate"><span class="pre">**</span></code> 매개 변수의 이름이거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. <em>defaults</em>는 기본 인자 값의 튜플이거나 기본 인자가 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다; 이 튜플에 <em>n</em> 개의 요소가 있으면, <em>args</em>에 나열된 마지막 <em>n</em> 요소에 해당합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.0부터 폐지: </span>개정된 API의 <a class="reference internal" href="#inspect.getfullargspec" title="inspect.getfullargspec"><code class="xref py py-func docutils literal notranslate"><span class="pre">getfullargspec()</span></code></a>을 사용하십시오. 이것은 일반적으로 드롭인 대체이면서, 함수 어노테이션과 키워드 전용 매개 변수도 올바르게 처리합니다.</p>
<p>또는, <a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">signature()</span></code></a>와 <a class="reference internal" href="#inspect-signature-object"><span class="std std-ref">Signature 객체</span></a>를 사용하십시오. 콜러블에 대한 보다 구조적인 내부 검사(introspection) API를 제공합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.getfullargspec">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getfullargspec</code><span class="sig-paren">(</span><em class="sig-param">func</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getfullargspec" title="정의 주소">¶</a></dt>
<dd><p>파이썬 함수 매개 변수의 이름과 기본값을 가져옵니다. <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a>이 반환됩니다:</p>
<p><code class="docutils literal notranslate"><span class="pre">FullArgSpec(args,</span> <span class="pre">varargs,</span> <span class="pre">varkw,</span> <span class="pre">defaults,</span> <span class="pre">kwonlyargs,</span> <span class="pre">kwonlydefaults,</span>
<span class="pre">annotations)</span></code></p>
<p><em>args</em>는 위치 매개 변수 이름의 리스트입니다. <em>varargs</em>는 <code class="docutils literal notranslate"><span class="pre">*</span></code> 매개 변수의 이름이거나 임의의 위치 인자가 허용되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. <em>varkw</em>는 <code class="docutils literal notranslate"><span class="pre">**</span></code> 매개 변수의 이름이거나 임의의 키워드 인자가 허용되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. <em>defaults</em>는 마지막 <em>n</em> 개의 위치 매개 변수에 해당하는 기본 인자 값의 <em>n</em>-튜플이거나, 이러한 기본값이 정의되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. <em>kwonlyargs</em>는 선언 순서를 따르는 키워드 전용 매개 변수 이름 리스트입니다. <em>kwonlydefaults</em>는 <em>kwonlyargs</em>의 매개 변수 이름에서 인자가 제공되지 않을 때 사용되는 기본값으로의 딕셔너리 매핑입니다. <em>annotations</em>는 매개 변수 이름에서 어노테이션으로의 딕셔너리 매핑입니다. 특수키 <code class="docutils literal notranslate"><span class="pre">&quot;return&quot;</span></code>은 함수 반환 값 어노테이션(있다면)을 보고하는 데 사용됩니다.</p>
<p><a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">signature()</span></code></a>와 <a class="reference internal" href="#inspect-signature-object"><span class="std std-ref">Signature 객체</span></a>가 콜러블 내부 검사에 권장되는 API를 제공하고, 확장 모듈 API에서 종종 등장하는 추가 동작(위치 전용 인자와 같은)을 지원함에 유의하십시오. 이 함수는 주로 파이썬 2 <code class="docutils literal notranslate"><span class="pre">inspect</span></code> 모듈 API와의 호환성을 유지해야 하는 코드에서 사용하기 위해 유지됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span>이 함수는 이제 <a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">signature()</span></code></a>를 기반으로 하지만, 여전히 <code class="docutils literal notranslate"><span class="pre">__wrapped__</span></code> 어트리뷰트를 무시하고 연결된(bound) 메서드의 서명 출력에 이미 연결된 첫 번째 매개 변수를 포함합니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span>이 메서드는 이전에 파이썬 3.5에서 <a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">signature()</span></code></a>로 대신하면서 폐지된 것으로 문서화되었지만, 레거시 <a class="reference internal" href="#inspect.getargspec" title="inspect.getargspec"><code class="xref py py-func docutils literal notranslate"><span class="pre">getargspec()</span></code></a> API에서 마이그레이션 하는 단일 소스 파이썬 2/3 코드를 위한 명확하게 지원되는 표준 인터페이스를 복원하기 위해 이 결정을 번복했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>실제로 파이썬 3에서 항상 유지되었습니다만, 파이썬은 버전 3.7부터 키워드 전용 매개 변수의 선언 순서를 유지한다는 것을 명시적으로 보장합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.getargvalues">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getargvalues</code><span class="sig-paren">(</span><em class="sig-param">frame</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getargvalues" title="정의 주소">¶</a></dt>
<dd><p>특정 프레임으로 전달된 인자에 대한 정보를 얻습니다. <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> <code class="docutils literal notranslate"><span class="pre">ArgInfo(args,</span> <span class="pre">varargs,</span> <span class="pre">keywords,</span> <span class="pre">locals)</span></code>가 반환됩니다. <em>args</em>는 인자 이름의 리스트입니다. <em>varargs</em>와 <em>keywords</em>는 <code class="docutils literal notranslate"><span class="pre">*</span></code>와 <code class="docutils literal notranslate"><span class="pre">**</span></code> 인자의 이름이거나 <code class="docutils literal notranslate"><span class="pre">None</span></code>입니다. <em>locals</em>는 주어진 프레임의 지역 딕셔너리입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 함수는 실수로 파이썬 3.5에서 폐지된 것으로 표시되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.formatargspec">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">formatargspec</code><span class="sig-paren">(</span><em class="sig-param">args</em><span class="optional">[</span>, <em class="sig-param">varargs</em>, <em class="sig-param">varkw</em>, <em class="sig-param">defaults</em>, <em class="sig-param">kwonlyargs</em>, <em class="sig-param">kwonlydefaults</em>, <em class="sig-param">annotations</em><span class="optional">[</span>, <em class="sig-param">formatarg</em>, <em class="sig-param">formatvarargs</em>, <em class="sig-param">formatvarkw</em>, <em class="sig-param">formatvalue</em>, <em class="sig-param">formatreturns</em>, <em class="sig-param">formatannotations</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#inspect.formatargspec" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#inspect.getfullargspec" title="inspect.getfullargspec"><code class="xref py py-func docutils literal notranslate"><span class="pre">getfullargspec()</span></code></a> 이 반환한 값으로 예쁜 인자 명세를 포맷합니다.</p>
<p>처음 7개의 인자는 (<code class="docutils literal notranslate"><span class="pre">args</span></code>, <code class="docutils literal notranslate"><span class="pre">varargs</span></code>, <code class="docutils literal notranslate"><span class="pre">varkw</span></code>, <code class="docutils literal notranslate"><span class="pre">defaults</span></code>, <code class="docutils literal notranslate"><span class="pre">kwonlyargs</span></code>, <code class="docutils literal notranslate"><span class="pre">kwonlydefaults</span></code>, <code class="docutils literal notranslate"><span class="pre">annotations</span></code>) 입니다.</p>
<p>다른 6개의 인자는 인자 이름, <code class="docutils literal notranslate"><span class="pre">*</span></code> 인자 이름, <code class="docutils literal notranslate"><span class="pre">**</span></code> 인자 이름, 기본값, 반환 값 어노테이션 및 개별 어노테이션을 각각 문자열로 변환하기 위해 호출되는 함수입니다.</p>
<p>예를 들면:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">formatargspec</span><span class="p">,</span> <span class="n">getfullargspec</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">formatargspec</span><span class="p">(</span><span class="o">*</span><span class="n">getfullargspec</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="go">&#39;(a: int, b: float)&#39;</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.5부터 폐지: </span><a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">signature()</span></code></a>와 <a class="reference internal" href="#inspect-signature-object"><span class="std std-ref">Signature 객체</span></a>를 사용하십시오. 콜러블에 대한 더 나은 내부 검사 API를 제공합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.formatargvalues">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">formatargvalues</code><span class="sig-paren">(</span><em class="sig-param">args</em><span class="optional">[</span>, <em class="sig-param">varargs</em>, <em class="sig-param">varkw</em>, <em class="sig-param">locals</em>, <em class="sig-param">formatarg</em>, <em class="sig-param">formatvarargs</em>, <em class="sig-param">formatvarkw</em>, <em class="sig-param">formatvalue</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#inspect.formatargvalues" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#inspect.getargvalues" title="inspect.getargvalues"><code class="xref py py-func docutils literal notranslate"><span class="pre">getargvalues()</span></code></a>가 반환한 4개의 값으로 예쁜 인자 명세를 포맷합니다. format* 인자는 해당 이름과 값을 문자열로 변환하기 위해 호출되는 선택적 포매팅 함수입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 함수는 실수로 파이썬 3.5에서 폐지된 것으로 표시되었습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.getmro">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getmro</code><span class="sig-paren">(</span><em class="sig-param">cls</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getmro" title="정의 주소">¶</a></dt>
<dd><p>클래스 cls의 베이스 클래스의 튜플(cls를 포함합니다)을 메서드 결정 순서로 반환합니다. 이 튜플에는 클래스가 두 번 이상 나타나지 않습니다. 메서드 결정 순서는 cls의 형에 따라 다릅니다. 매우 독특한 사용자 정의 메타 형을 사용하지 않는 한, cls는 튜플의 첫 번째 요소가 됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.getcallargs">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getcallargs</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getcallargs" title="정의 주소">¶</a></dt>
<dd><p><em>args</em>와 <em>kwds</em>를 마치 이들로 호출된 것처럼 파이썬 함수나 메서드 <em>func</em>의 인자 이름에 연결합니다. 연결된 메서드의 경우, 첫 번째 인자(일반적으로 <code class="docutils literal notranslate"><span class="pre">self</span></code>라고 합니다)도 해당 인스턴스에 연결합니다. 인자 이름(있다면, <code class="docutils literal notranslate"><span class="pre">*</span></code>와 <code class="docutils literal notranslate"><span class="pre">**</span></code> 인자의 이름도 포함합니다)을 <em>args</em>와 <em>kwds</em>의 값으로 매핑하는 딕셔너리가 반환됩니다. <em>func</em>를 잘못 호출하는 경우, 즉 호환되지 않는 서명으로 인해 <code class="docutils literal notranslate"><span class="pre">func(*args,</span> <span class="pre">**kwds)</span></code>가 예외를 발생시키게 될 때마다, 같은 형의 예외가 같거나 유사한 메시지로 발생합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">getcallargs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">**</span><span class="n">named</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcallargs</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;named&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;pos&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)}</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcallargs</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;named&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;pos&#39;</span><span class="p">:</span> <span class="p">()}</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcallargs</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">f() missing 1 required positional argument: &#39;a&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.5부터 폐지: </span>대신 <a class="reference internal" href="#inspect.Signature.bind" title="inspect.Signature.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.bind()</span></code></a>와 <a class="reference internal" href="#inspect.Signature.bind_partial" title="inspect.Signature.bind_partial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Signature.bind_partial()</span></code></a>을 사용하십시오.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.getclosurevars">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getclosurevars</code><span class="sig-paren">(</span><em class="sig-param">func</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getclosurevars" title="정의 주소">¶</a></dt>
<dd><p>파이썬 함수나 메서드 <em>func</em>에 있는 외부 이름 참조에서 현재 값으로의 매핑을 얻습니다. <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> <code class="docutils literal notranslate"><span class="pre">ClosureVars(nonlocals,</span> <span class="pre">globals,</span> <span class="pre">builtins,</span> <span class="pre">unbound)</span></code>가 반환됩니다. <em>nonlocals</em>는 참조된 이름을 어휘 클로저(closure) 변수로, <em>globals</em>는 함수의 모듈 전역으로, <em>builtins</em>는 함수 바디에서 볼 수 있는 내장으로 매핑합니다. <em>unbound</em>는 현재 모듈 전역과 내장에서 전혀 결정할 수 없는 함수에서 참조된 이름 집합입니다.</p>
<p><em>func</em>가 파이썬 함수나 메서드가 아니면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.unwrap">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">unwrap</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*</em>, <em class="sig-param">stop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.unwrap" title="정의 주소">¶</a></dt>
<dd><p><em>func</em>로 래핑 된 객체를 가져옵니다. 체인의 마지막 객체를 반환하는 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__wrapped__</span></code> 어트리뷰트의 체인을 따라갑니다.</p>
<p><em>stop</em>은 래퍼 체인의 객체를 유일한 인자로 받아들이는 선택적 콜백으로, 콜백이 참값을 반환할 때 언 래핑을 조기에 종료 할 수 있도록 합니다. 콜백이 참값을 반환하지 않으면, 체인의 마지막 객체가 평소처럼 반환됩니다. 예를 들어, <a class="reference internal" href="#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">signature()</span></code></a>는 이것을 사용하여 체인에 있는 객체에 <code class="docutils literal notranslate"><span class="pre">__signature__</span></code> 어트리뷰트가 정의되면 언 래핑을 중지합니다.</p>
<p>순환이 발견되면 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="the-interpreter-stack">
<span id="inspect-stack"></span><h2>인터프리터 스택<a class="headerlink" href="#the-interpreter-stack" title="제목 주소">¶</a></h2>
<p>다음 함수가 &quot;프레임 레코드&quot;를 반환할 때, 각 레코드는 <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> <code class="docutils literal notranslate"><span class="pre">FrameInfo(frame,</span> <span class="pre">filename,</span> <span class="pre">lineno,</span> <span class="pre">function,</span> <span class="pre">code_context,</span> <span class="pre">index)</span></code>입니다. 튜플에는 프레임 객체, 파일명, 현재 줄의 줄 번호, 함수 이름, 소스 코드의 문맥(context) 줄 리스트 및 그 리스트 내에서의 현재 줄의 인덱스가 포함됩니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>튜플 대신 네임드 튜플을 반환합니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이러한 함수가 반환하는 프레임 레코드의 첫 번째 요소에서 발견되는 것처럼, 프레임 객체에 대한 참조를 유지하면 프로그램이 참조 순환을 만들 수 있습니다. 일단 참조 순환이 생성되면, 파이썬의 선택적 순환 검출기가 활성화되어 있어도, 순환을 형성하는 객체에서 액세스 할 수 있는 모든 객체의 수명이 훨씬 더 길어질 수 있습니다. 이러한 순환을 만들어야만 하면, 명시적으로 끊어서 객체의 지연된 파괴와 메모리 소비 증가를 피하는 것이 중요합니다.</p>
<p>순환 감지기가 이를 잡기는 하겠지만, <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 절에서 순환을 제거하여 프레임(과 지역 변수)의 파괴를 결정적(deterministic)으로 만들 수 있습니다. 파이썬을 컴파일할 때나 <a class="reference internal" href="gc.html#gc.disable" title="gc.disable"><code class="xref py py-func docutils literal notranslate"><span class="pre">gc.disable()</span></code></a>을 사용해서 순환 감지기를 비활성화했을 때도 중요합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">handle_stackframe_without_leak</span><span class="p">():</span>
    <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># frame으로 뭔가 합니다</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">frame</span>
</pre></div>
</div>
<p>프레임을 계속 유지하려면 (예를 들어 나중에 트레이스백을 인쇄하려고) <a class="reference internal" href="../reference/datamodel.html#frame.clear" title="frame.clear"><code class="xref py py-meth docutils literal notranslate"><span class="pre">frame.clear()</span></code></a> 메서드를 사용하여 참조 순환을 끊을 수도 있습니다.</p>
</div>
<p>이 함수들 대부분이 지원하는 선택적 <em>context</em> 인자는 반환할 문맥(context) 줄 수를 지정합니다. 이 줄들은 현재 줄을 중심으로 합니다.</p>
<dl class="function">
<dt id="inspect.getframeinfo">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getframeinfo</code><span class="sig-paren">(</span><em class="sig-param">frame</em>, <em class="sig-param">context=1</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getframeinfo" title="정의 주소">¶</a></dt>
<dd><p>프레임이나 트레이스백 객체에 대한 정보를 얻습니다. <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> <code class="docutils literal notranslate"><span class="pre">Traceback(filename,</span> <span class="pre">lineno,</span> <span class="pre">function,</span> <span class="pre">code_context,</span> <span class="pre">index)</span></code>가 반환됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="inspect.getouterframes">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getouterframes</code><span class="sig-paren">(</span><em class="sig-param">frame</em>, <em class="sig-param">context=1</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getouterframes" title="정의 주소">¶</a></dt>
<dd><p>frame과 모든 외부(outer) 프레임에 대한 프레임 레코드 리스트를 얻습니다. 이 프레임들은 <em>frame</em>을 만들도록 한 호출을 나타냅니다. 반환된 리스트의 첫 번째 항목은 <em>frame</em>을 나타냅니다; 마지막 항목은 <em>frame</em>의 스택에서 가장 바깥쪽 호출을 나타냅니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> <code class="docutils literal notranslate"><span class="pre">FrameInfo(frame,</span> <span class="pre">filename,</span> <span class="pre">lineno,</span> <span class="pre">function,</span> <span class="pre">code_context,</span> <span class="pre">index)</span></code>의 리스트가 반환됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.getinnerframes">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getinnerframes</code><span class="sig-paren">(</span><em class="sig-param">traceback</em>, <em class="sig-param">context=1</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getinnerframes" title="정의 주소">¶</a></dt>
<dd><p>traceback의 프레임과 모든 내부(inner) 프레임에 대한 프레임 레코드 리스트를 얻습니다. 이 프레임들은 <em>frame</em>의 결과로 만들어진 호출을 나타냅니다. 리스트의 첫 번째 항목은 <em>traceback</em>을 나타냅니다; 마지막 항목은 예외가 발생한 위치를 나타냅니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> <code class="docutils literal notranslate"><span class="pre">FrameInfo(frame,</span> <span class="pre">filename,</span> <span class="pre">lineno,</span> <span class="pre">function,</span> <span class="pre">code_context,</span> <span class="pre">index)</span></code>의 리스트가 반환됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.currentframe">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">currentframe</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#inspect.currentframe" title="정의 주소">¶</a></dt>
<dd><p>호출자의 스택 프레임에 대한 프레임 객체를 반환합니다.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> 이 함수는 인터프리터의 파이썬 스택 프레임 지원에 의존하며, 모든 파이썬 구현에서 제공된다고 보장되는 것은 아닙니다. 파이썬 스택 프레임 지원이 없는 구현에서 실행하면, 이 함수는 <code class="docutils literal notranslate"><span class="pre">None</span></code>을 반환합니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.stack">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">stack</code><span class="sig-paren">(</span><em class="sig-param">context=1</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.stack" title="정의 주소">¶</a></dt>
<dd><p>호출자의 스택에 대한 프레임 레코드 리스트를 반환합니다. 반환된 리스트의 첫 번째 항목은 호출자를 나타냅니다; 마지막 항목은 스택에서 가장 바깥쪽 호출을 나타냅니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> <code class="docutils literal notranslate"><span class="pre">FrameInfo(frame,</span> <span class="pre">filename,</span> <span class="pre">lineno,</span> <span class="pre">function,</span> <span class="pre">code_context,</span> <span class="pre">index)</span></code>의 리스트가 반환됩니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.trace">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">trace</code><span class="sig-paren">(</span><em class="sig-param">context=1</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.trace" title="정의 주소">¶</a></dt>
<dd><p>현재 프레임과 현재 처리 중인 예외가 발생한 프레임 사이의 스택에 대한 프레임 레코드 리스트를 반환합니다. 리스트의 첫 번째 항목은 호출자를 나타냅니다; 마지막 항목은 예외가 발생한 위치를 나타냅니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span><a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">네임드 튜플</span></a> <code class="docutils literal notranslate"><span class="pre">FrameInfo(frame,</span> <span class="pre">filename,</span> <span class="pre">lineno,</span> <span class="pre">function,</span> <span class="pre">code_context,</span> <span class="pre">index)</span></code>의 리스트가 반환됩니다.</p>
</div>
</dd></dl>

</div>
<div class="section" id="fetching-attributes-statically">
<h2>정적으로 어트리뷰트 가져오기<a class="headerlink" href="#fetching-attributes-statically" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a>과 <a class="reference internal" href="functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a>은 모두 어트리뷰트를 가져오거나 존재하는지 확인할 때 코드 실행을 유발할 수 있습니다. 프로퍼티와 같은 디스크립터가 호출되고 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>과 <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a>가 호출될 수 있습니다.</p>
<p>문서화 도구처럼 수동적인(passive) 검사를 원할 때는 불편할 수 있습니다. <a class="reference internal" href="#inspect.getattr_static" title="inspect.getattr_static"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr_static()</span></code></a>은 <a class="reference internal" href="functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a>과 같은 서명을 갖지만 어트리뷰트를 가져올 때 코드 실행을 피합니다.</p>
<dl class="function">
<dt id="inspect.getattr_static">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getattr_static</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">attr</em>, <em class="sig-param">default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getattr_static" title="정의 주소">¶</a></dt>
<dd><p>디스크립터 프로토콜, <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 또는 <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a>를 통한 동적 조회를 일으키지 않고 어트리뷰트를 조회합니다.</p>
<p>참고: 이 함수는 getattr이 가져올 수 있는 모든 어트리뷰트를 조회하지 못할 수 있으며 (가령 동적으로 만들어진 어트리뷰트), getattr이 가져올 수 없는 어트리뷰트를 찾을 수 있습니다 (가령 AttributeError를 발생시키는 디스크립터). 또한 인스턴스 멤버 대신 디스크립터 객체를 반환할 수도 있습니다.</p>
<p>인스턴스 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>가 다른 멤버(예를 들어 프로퍼티)에 의해 가려지면 이 함수는 인스턴스 멤버를 찾을 수 없습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<p><a class="reference internal" href="#inspect.getattr_static" title="inspect.getattr_static"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr_static()</span></code></a>은 디스크립터를 해석하지 않습니다, 예를 들어 C로 구현된 객체의 슬롯 디스크립터나 getset 디스크립터. 하부 어트리뷰트 대신 디스크립터 객체가 반환됩니다.</p>
<p>다음과 같은 코드로 이를 처리할 수 있습니다. 임의의 getset 디스크립터에 대해 이를 호출하면 코드 실행이 유발될 수 있음에 유의하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 내장 디스크립터 형을 해석하기 위한 예제 코드</span>
<span class="k">class</span> <span class="nc">_foo</span><span class="p">:</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span>

<span class="n">slot_descriptor</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">_foo</span><span class="o">.</span><span class="n">foo</span><span class="p">)</span>
<span class="n">getset_descriptor</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="n">wrapper_descriptor</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;__add__&#39;</span><span class="p">])</span>
<span class="n">descriptor_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">slot_descriptor</span><span class="p">,</span> <span class="n">getset_descriptor</span><span class="p">,</span> <span class="n">wrapper_descriptor</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">getattr_static</span><span class="p">(</span><span class="n">some_object</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">in</span> <span class="n">descriptor_types</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="fm">__get__</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="c1"># 디스크립터는 AttributeError를 발생 시켜 하부 값이</span>
        <span class="c1"># 없음을 나타냅니다. 이 경우 디스크립터 자체가 수행해야 합니다.</span>
        <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="current-state-of-generators-and-coroutines">
<h2>제너레이터와 코루틴의 현재 상태<a class="headerlink" href="#current-state-of-generators-and-coroutines" title="제목 주소">¶</a></h2>
<p>코루틴 스케줄러를 구현할 때와 기타 제너레이터의 고급 사용을 위해, 제너레이터가 현재 실행 중인지, 시작, 재개 또는 실행을 대기하는 중인지, 또는 이미 종료되었는지를 판별하는 것이 유용합니다. <a class="reference internal" href="#inspect.getgeneratorstate" title="inspect.getgeneratorstate"><code class="xref py py-func docutils literal notranslate"><span class="pre">getgeneratorstate()</span></code></a>를 사용하면 제너레이터의 현재 상태를 쉽게 확인할 수 있습니다.</p>
<dl class="function">
<dt id="inspect.getgeneratorstate">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getgeneratorstate</code><span class="sig-paren">(</span><em class="sig-param">generator</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getgeneratorstate" title="정의 주소">¶</a></dt>
<dd><p>제너레이터-이터레이터의 현재 상태를 가져옵니다.</p>
<dl class="simple">
<dt>가능한 상태는 다음과 같습니다:</dt><dd><ul class="simple">
<li><p>GEN_CREATED: 실행 시작을 기다리는 중입니다.</p></li>
<li><p>GEN_RUNNING: 현재 인터프리터에서 실행 중입니다.</p></li>
<li><p>GEN_SUSPENDED: 현재 일드(yield) 표현식에서 일시 중지되었습니다.</p></li>
<li><p>GEN_CLOSED: 실행이 완료되었습니다.</p></li>
</ul>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.getcoroutinestate">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getcoroutinestate</code><span class="sig-paren">(</span><em class="sig-param">coroutine</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getcoroutinestate" title="정의 주소">¶</a></dt>
<dd><p>코루틴 객체의 현재 상태를 가져옵니다. 이 함수는 <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 함수가 만든 코루틴 객체와 함께 사용하기 위한 것이지만, <code class="docutils literal notranslate"><span class="pre">cr_running</span></code>과 <code class="docutils literal notranslate"><span class="pre">cr_frame</span></code> 어트리뷰트가 있는 임의의 코루틴류 객체를 허용합니다.</p>
<dl class="simple">
<dt>가능한 상태는 다음과 같습니다:</dt><dd><ul class="simple">
<li><p>CORO_CREATED: 실행 시작을 기다리는 중입니다.</p></li>
<li><p>CORO_RUNNING: 현재 인터프리터에서 실행 중입니다.</p></li>
<li><p>CORO_SUSPENDED: 현재 어웨이트(await) 표현식에서 일시 중지되었습니다.</p></li>
<li><p>CORO_CLOSED: 실행이 완료되었습니다.</p></li>
</ul>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<p>제너레이터의 현재 내부 상태도 조회할 수 있습니다. 이는 주로 내부 상태가 예상대로 갱신되었는지 확인하는 테스트 목적으로 유용합니다:</p>
<dl class="function">
<dt id="inspect.getgeneratorlocals">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getgeneratorlocals</code><span class="sig-paren">(</span><em class="sig-param">generator</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getgeneratorlocals" title="정의 주소">¶</a></dt>
<dd><p><em>generator</em>의 라이브 로컬 변수에서 그것의 현재 값으로의 매핑을 얻습니다. 변수 이름을 값으로 매핑하는 딕셔너리가 반환됩니다. 이것은 제너레이터 바디에서 <a class="reference internal" href="functions.html#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a>를 호출하는 것과 동등하며, 같은 경고가 모두 적용됩니다.</p>
<p><em>generator</em>가 현재 연결된 프레임이 없는 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">제너레이터</span></a>이면, 빈 딕셔너리가 반환됩니다. <em>generator</em>가 파이썬 제너레이터 객체가 아니면 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>가 발생합니다.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> 이 함수는 내부 검사를 위해 파이썬 스택 프레임을 노출하는 제너레이터에 의존하며, 모든 파이썬 구현에서 보장되는 것은 아닙니다. 그럴 경우, 이 함수는 항상 빈 딕셔너리를 반환합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="inspect.getcoroutinelocals">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">getcoroutinelocals</code><span class="sig-paren">(</span><em class="sig-param">coroutine</em><span class="sig-paren">)</span><a class="headerlink" href="#inspect.getcoroutinelocals" title="정의 주소">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="#inspect.getgeneratorlocals" title="inspect.getgeneratorlocals"><code class="xref py py-func docutils literal notranslate"><span class="pre">getgeneratorlocals()</span></code></a>와 유사하지만, <a class="reference internal" href="../reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 함수가 만든 코루틴 객체에 작동합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="code-objects-bit-flags">
<span id="inspect-module-co-flags"></span><h2>코드 객체 비트 플래그<a class="headerlink" href="#code-objects-bit-flags" title="제목 주소">¶</a></h2>
<p>파이썬 코드 객체에는 <code class="docutils literal notranslate"><span class="pre">co_flags</span></code> 어트리뷰트가 있으며, 이는 다음 플래그의 비트맵입니다:</p>
<dl class="data">
<dt id="inspect.CO_OPTIMIZED">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">CO_OPTIMIZED</code><a class="headerlink" href="#inspect.CO_OPTIMIZED" title="정의 주소">¶</a></dt>
<dd><p>코드 객체는 빠른 locals(fast locals)를 사용하여 최적화되었습니다.</p>
</dd></dl>

<dl class="data">
<dt id="inspect.CO_NEWLOCALS">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">CO_NEWLOCALS</code><a class="headerlink" href="#inspect.CO_NEWLOCALS" title="정의 주소">¶</a></dt>
<dd><p>설정되면, 코드 객체가 실행될 때 프레임의 <code class="docutils literal notranslate"><span class="pre">f_locals</span></code>에 대한 새 딕셔너리가 만들어집니다.</p>
</dd></dl>

<dl class="data">
<dt id="inspect.CO_VARARGS">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">CO_VARARGS</code><a class="headerlink" href="#inspect.CO_VARARGS" title="정의 주소">¶</a></dt>
<dd><p>코드 객체에는 (<code class="docutils literal notranslate"><span class="pre">*args</span></code> 같은) 가변 위치 매개 변수가 있습니다.</p>
</dd></dl>

<dl class="data">
<dt id="inspect.CO_VARKEYWORDS">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">CO_VARKEYWORDS</code><a class="headerlink" href="#inspect.CO_VARKEYWORDS" title="정의 주소">¶</a></dt>
<dd><p>코드 객체에는 (<code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> 같은) 가변 키워드 매개 변수가 있습니다.</p>
</dd></dl>

<dl class="data">
<dt id="inspect.CO_NESTED">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">CO_NESTED</code><a class="headerlink" href="#inspect.CO_NESTED" title="정의 주소">¶</a></dt>
<dd><p>코드 객체가 중첩 함수일 때 이 플래그가 설정됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="inspect.CO_GENERATOR">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">CO_GENERATOR</code><a class="headerlink" href="#inspect.CO_GENERATOR" title="정의 주소">¶</a></dt>
<dd><p>코드 객체가 제너레이터 함수일 때, 즉 코드 객체가 실행될 때 제너레이터 객체를 반환할 때 이 플래그가 설정됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="inspect.CO_NOFREE">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">CO_NOFREE</code><a class="headerlink" href="#inspect.CO_NOFREE" title="정의 주소">¶</a></dt>
<dd><p>자유 변수(free variable)와 셀 변수(cell variable)가 없으면 이 플래그가 설정됩니다.</p>
</dd></dl>

<dl class="data">
<dt id="inspect.CO_COROUTINE">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">CO_COROUTINE</code><a class="headerlink" href="#inspect.CO_COROUTINE" title="정의 주소">¶</a></dt>
<dd><p>코드 객체가 코루틴 함수일 때 이 플래그가 설정됩니다. 코드 객체가 실행될 때 코루틴 객체를 반환합니다. 자세한 내용은 <span class="target" id="index-9"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a>를 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="inspect.CO_ITERABLE_COROUTINE">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">CO_ITERABLE_COROUTINE</code><a class="headerlink" href="#inspect.CO_ITERABLE_COROUTINE" title="정의 주소">¶</a></dt>
<dd><p>이 플래그는 제너레이터를 제너레이터 기반 코루틴으로 변환하는 데 사용됩니다. 이 플래그가 있는 제너레이터 객체는 <code class="docutils literal notranslate"><span class="pre">await</span></code> 표현식에 사용될 수 있으며, 코루틴 객체를 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> 할 수 있습니다. 자세한 내용은 <span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a>를 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="inspect.CO_ASYNC_GENERATOR">
<code class="sig-prename descclassname">inspect.</code><code class="sig-name descname">CO_ASYNC_GENERATOR</code><a class="headerlink" href="#inspect.CO_ASYNC_GENERATOR" title="정의 주소">¶</a></dt>
<dd><p>코드 객체가 비동기 제너레이터 함수일 때 이 플래그가 설정됩니다. 코드 객체가 실행될 때 비동기 제너레이터 객체가 반환됩니다. 자세한 내용은 <span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0525"><strong>PEP 525</strong></a>를 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 플래그들은 CPython에만 해당하며, 다른 파이썬 구현에서는 정의되지 않을 수 있습니다. 또한 플래그는 구현 세부 사항이며, 향후 파이썬 배포에서 제거되거나 폐지될 수 있습니다. 모든 내부 검사에는 <a class="reference internal" href="#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 모듈의 공개 API를 사용하는 것이 좋습니다.</p>
</div>
</div>
<div class="section" id="command-line-interface">
<span id="inspect-module-cli"></span><h2>명령 줄 인터페이스<a class="headerlink" href="#command-line-interface" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 모듈은 명령 줄에서 기본 내부 검사 기능을 제공하기도 합니다.</p>
<p>기본적으로, 모듈의 이름을 받아들이고 해당 모듈의 소스를 인쇄합니다. 콜론과 대상 객체의 정규화된 이름을 덧붙여, 대신 모듈 내의 클래스나 함수를 인쇄 할 수 있습니다.</p>
<dl class="cmdoption">
<dt id="cmdoption-inspect-details">
<code class="sig-name descname">--details</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-inspect-details" title="정의 주소">¶</a></dt>
<dd><p>소스 코드 대신에 지정된 객체에 대한 정보를 인쇄합니다</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code> --- 라이브 객체 검사</a><ul>
<li><a class="reference internal" href="#types-and-members">형과 멤버</a></li>
<li><a class="reference internal" href="#retrieving-source-code">소스 코드 가져오기</a></li>
<li><a class="reference internal" href="#introspecting-callables-with-the-signature-object">Signature 객체로 콜러블 검사하기</a></li>
<li><a class="reference internal" href="#classes-and-functions">클래스와 함수</a></li>
<li><a class="reference internal" href="#the-interpreter-stack">인터프리터 스택</a></li>
<li><a class="reference internal" href="#fetching-attributes-statically">정적으로 어트리뷰트 가져오기</a></li>
<li><a class="reference internal" href="#current-state-of-generators-and-coroutines">제너레이터와 코루틴의 현재 상태</a></li>
<li><a class="reference internal" href="#code-objects-bit-flags">코드 객체 비트 플래그</a></li>
<li><a class="reference internal" href="#command-line-interface">명령 줄 인터페이스</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="gc.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code> --- 가비지 수거기 인터페이스</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="site.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code> --- 사이트별 구성 훅</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="site.html" title="site --- 사이트별 구성 훅"
             >다음</a> |</li>
        <li class="right" >
          <a href="gc.html" title="gc --- 가비지 수거기 인터페이스"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="python.html" >파이썬 실행시간 서비스</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>