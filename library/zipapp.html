
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>zipapp --- 실행 가능한 파이썬 zip 아카이브 관리 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="파이썬 실행시간 서비스" href="python.html" />
    <link rel="prev" title="venv --- 가상 환경 생성" href="venv.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/zipapp.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="python.html" title="파이썬 실행시간 서비스"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="venv.html" title="venv --- 가상 환경 생성"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="distribution.html" accesskey="U">소프트웨어 패키징 및 배포</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-zipapp">
<span id="zipapp-manage-executable-python-zip-archives"></span><h1><a class="reference internal" href="#module-zipapp" title="zipapp: Manage executable Python zip archives"><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipapp</span></code></a> --- 실행 가능한 파이썬 zip 아카이브 관리<a class="headerlink" href="#module-zipapp" title="제목 주소">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/zipapp.py">Lib/zipapp.py</a></p>
<hr class="docutils" id="index-0" />
<p>이 모듈은 <a class="reference internal" href="../using/cmdline.html#using-on-interface-options"><span class="std std-ref">파이썬 인터프리터가 직접 실행할</span></a> 수 있는 파이썬 코드를 포함하는 zip 파일 생성을 관리하는 도구를 제공합니다. 이 모듈은 <a class="reference internal" href="#zipapp-command-line-interface"><span class="std std-ref">명령 줄 인터페이스</span></a>와 <a class="reference internal" href="#zipapp-python-api"><span class="std std-ref">파이썬 API</span></a>를 모두 제공합니다.</p>
<div class="section" id="basic-example">
<h2>기본 예<a class="headerlink" href="#basic-example" title="제목 주소">¶</a></h2>
<p>다음 예제는 <a class="reference internal" href="#zipapp-command-line-interface"><span class="std std-ref">명령 줄 인터페이스</span></a>를 사용하여 파이썬 코드가 포함된 디렉터리에서 실행 가능 아카이브를 만드는 방법을 보여줍니다. 실행하면, 아카이브가 아카이브의 모듈 <code class="docutils literal notranslate"><span class="pre">myapp</span></code>에서 <code class="docutils literal notranslate"><span class="pre">main</span></code> 함수를 실행합니다.</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m zipapp myapp -m <span class="s2">&quot;myapp:main&quot;</span>
<span class="gp">$</span> python myapp.pyz
<span class="go">&lt;output from myapp&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="command-line-interface">
<span id="zipapp-command-line-interface"></span><h2>명령 줄 인터페이스<a class="headerlink" href="#command-line-interface" title="제목 주소">¶</a></h2>
<p>명령 줄에서 프로그램으로 호출될 때, 다음 형식이 사용됩니다:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m zipapp <span class="nb">source</span> <span class="o">[</span>options<span class="o">]</span>
</pre></div>
</div>
<p><em>source</em>가 디렉터리면, <em>source</em>의 내용으로부터 아카이브를 만듭니다. <em>source</em>가 파일이면, 아카이브여야 하며, 대상 아카이브로 복사됩니다 (또는 --info 옵션이 지정되면 셔뱅(shebang) 줄의 내용이 표시됩니다).</p>
<p>다음과 같은 옵션이 이해됩니다:</p>
<dl class="cmdoption">
<dt id="cmdoption-zipapp-o">
<code class="sig-name descname">-o</code><code class="sig-prename descclassname"> &lt;output&gt;</code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--output</code><code class="sig-prename descclassname">=&lt;output&gt;</code><a class="headerlink" href="#cmdoption-zipapp-o" title="정의 주소">¶</a></dt>
<dd><p>출력을 <em>output</em>이라는 이름의 파일에 씁니다. 이 옵션을 지정하지 않으면, 출력 파일명은 입력 <em>source</em>와 같고, 확장자 <code class="docutils literal notranslate"><span class="pre">.pyz</span></code>가 추가됩니다. 명시적인 파일명이 제공되면, 그대로 사용됩니다 (그래서 필요하면 <code class="docutils literal notranslate"><span class="pre">.pyz</span></code> 확장자를 포함해야 합니다).</p>
<p><em>source</em>가 아카이브이면 반드시 출력 파일명을 지정해야 합니다 (그리고 이 경우, <em>output</em>은 <em>source</em>와 달라야 합니다).</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-zipapp-p">
<code class="sig-name descname">-p</code><code class="sig-prename descclassname"> &lt;interpreter&gt;</code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--python</code><code class="sig-prename descclassname">=&lt;interpreter&gt;</code><a class="headerlink" href="#cmdoption-zipapp-p" title="정의 주소">¶</a></dt>
<dd><p>실행할 명령으로 <em>interpreter</em>를 지정하여 <code class="docutils literal notranslate"><span class="pre">#!</span></code> 줄을 아카이브에 추가합니다. 또한, POSIX에서, 아카이브를 실행 파일로 만듭니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">#!</span></code> 줄을 쓰지 않고, 파일을 실행 파일로 만들지 않는 것입니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-zipapp-m">
<code class="sig-name descname">-m</code><code class="sig-prename descclassname"> &lt;mainfn&gt;</code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--main</code><code class="sig-prename descclassname">=&lt;mainfn&gt;</code><a class="headerlink" href="#cmdoption-zipapp-m" title="정의 주소">¶</a></dt>
<dd><p>아카이브에 <em>mainfn</em>을 실행하는 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 파일을 씁니다. <em>mainfn</em> 인자는 &quot;pkg.mod:fn&quot; 형식이어야 합니다. 여기서 &quot;pkg.mod&quot;는 아카이브의 패키지/모듈이며, &quot;fn&quot;은 주어진 모듈에 있는 콜러블입니다. <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 파일은 그 콜러블을 실행합니다.</p>
<p>아카이브를 복사할 때 <a class="reference internal" href="#cmdoption-zipapp-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">--main</span></code></a>을 지정할 수 없습니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-zipapp-c">
<code class="sig-name descname">-c</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--compress</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-zipapp-c" title="정의 주소">¶</a></dt>
<dd><p>디플레이트(deflate) 메서드로 파일을 압축하여, 출력 파일의 크기를 줄입니다. 기본적으로, 파일은 아카이브에 압축되지 않은 상태로 저장됩니다.</p>
<p>아카이브를 복사할 때 <a class="reference internal" href="#cmdoption-zipapp-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">--compress</span></code></a>는 효과가 없습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-zipapp-info">
<code class="sig-name descname">--info</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-zipapp-info" title="정의 주소">¶</a></dt>
<dd><p>진단 목적으로, 아카이브에 내장된 인터프리터를 표시합니다. 이 경우, 다른 옵션은 무시되고 SOURCE는 디렉터리가 아닌 아카이브여야 합니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-zipapp-h">
<code class="sig-name descname">-h</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--help</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-zipapp-h" title="정의 주소">¶</a></dt>
<dd><p>간단한 사용법 메시지를 인쇄하고 종료합니다.</p>
</dd></dl>

</div>
<div class="section" id="python-api">
<span id="zipapp-python-api"></span><h2>파이썬 API<a class="headerlink" href="#python-api" title="제목 주소">¶</a></h2>
<p>이 모듈은 두 개의 편의 함수를 정의합니다:</p>
<dl class="function">
<dt id="zipapp.create_archive">
<code class="sig-prename descclassname">zipapp.</code><code class="sig-name descname">create_archive</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">target=None</em>, <em class="sig-param">interpreter=None</em>, <em class="sig-param">main=None</em>, <em class="sig-param">filter=None</em>, <em class="sig-param">compressed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#zipapp.create_archive" title="정의 주소">¶</a></dt>
<dd><p><em>source</em>로 응용 프로그램 아카이브를 만듭니다. 소스는 다음 중 하나일 수 있습니다:</p>
<ul class="simple">
<li><p>디렉터리 이름, 또는 디렉터리를 참조하는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>. 이 경우 해당 디렉터리의 내용으로 새 응용 프로그램 아카이브가 만들어집니다.</p></li>
<li><p>기존 응용 프로그램 아카이브 파일의 이름, 또는 이러한 파일을 참조하는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>. 이 경우 파일이 대상(target)으로 복사됩니다 (<em>interpreter</em> 인자에 제공된 값을 반영하도록 수정하면서). 필요하면, 파일 이름에 <code class="docutils literal notranslate"><span class="pre">.pyz</span></code> 확장자가 포함되어야 합니다.</p></li>
<li><p>바이너리 모드에서 읽기로 열린 파일 객체. 파일의 내용은 응용 프로그램 아카이브여야 하며, 파일 객체는 아카이브의 시작 부분에 위치한 것으로 가정합니다.</p></li>
</ul>
<p><em>target</em> 인자는 결과 아카이브가 기록될 위치를 결정합니다:</p>
<ul class="simple">
<li><p>파일 이름이거나 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>이면, 아카이브가 그 파일에 기록됩니다.</p></li>
<li><p>열린 파일 객체면, 그 파일 객체에 아카이브가 기록되며, 파일은 바이너리 모드로 쓰기로 열려 있어야 합니다.</p></li>
<li><p>target이 생략되면 (또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면), 소스(source)는 디렉터리여야 하며 대상은 <code class="docutils literal notranslate"><span class="pre">.pyz</span></code> 확장자가 추가된 소스와 이름이 같은 파일이 됩니다.</p></li>
</ul>
<p><em>interpreter</em> 인자는 아카이브가 실행될 파이썬 인터프리터의 이름을 지정합니다. 아카이브 시작 부분에 &quot;셔뱅(shebang)&quot; 줄로 기록됩니다. POSIX에서는 이를 OS가 해석하고, 윈도우에서는 파이썬 런처가 이를 처리합니다. <em>interpreter</em>를 생략하면 셔뱅 줄이 기록되지 않습니다. interpreter가 지정되고 target이 파일명이면, target 파일의 실행 가능 비트가 설정됩니다.</p>
<p><em>main</em> 인자는 아카이브의 메인 프로그램으로 사용될 콜러블의 이름을 지정합니다. 소스가 디렉터리이고 소스에 아직 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 파일이 없을 때만 지정할 수 있습니다. <em>main</em> 인자는 &quot;pkg.module:callable&quot; 형식이어야 하며 아카이브는 &quot;pkg.module&quot;을 임포트 하고 인자 없이 지정된 콜러블을 실행해서 실행됩니다. 소스가 디렉터리이고 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 파일을 포함하지 않을 때 <em>main</em>을 생략하는 것은 에러입니다, 그렇지 않으면 결과 아카이브가 실행 가능하지 않기 때문입니다.</p>
<p>선택적 <em>filter</em> 인자는 추가되는 파일의 (소스 디렉터리에 상대적인) 경로를 나타내는 Path 객체가 전달되는 콜백 함수를 지정합니다. 파일을 추가하려면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환해야 합니다.</p>
<p>선택적 <em>compressed</em> 인자는 파일을 압축할지를 결정합니다. <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정하면, 아카이브의 파일이 디플레이트(deflate) 메서드로 압축됩니다; 그렇지 않으면 파일이 압축되지 않은 상태로 저장됩니다. 기존 아카이브를 복사할 때는 이 인자가 효과가 없습니다.</p>
<p><em>source</em>나 <em>target</em>에 파일 객체가 지정되면, create_archive를 호출한 후 파일 객체를 닫는 것은 호출자의 책임입니다.</p>
<p>기존 아카이브를 복사할 때, 제공된 파일 객체에는 <code class="docutils literal notranslate"><span class="pre">read</span></code>와 <code class="docutils literal notranslate"><span class="pre">readline</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">write</span></code> 메서드만 필요합니다. 디렉터리에서 아카이브를 만들 때, 대상이 파일 객체면 <code class="docutils literal notranslate"><span class="pre">zipfile.ZipFile</span></code> 클래스로 전달되며, 해당 클래스에 필요한 메서드를 제공해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span><em>filter</em>와 <em>compressed</em> 인자를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="zipapp.get_interpreter">
<code class="sig-prename descclassname">zipapp.</code><code class="sig-name descname">get_interpreter</code><span class="sig-paren">(</span><em class="sig-param">archive</em><span class="sig-paren">)</span><a class="headerlink" href="#zipapp.get_interpreter" title="정의 주소">¶</a></dt>
<dd><p>아카이브 시작 부분에서 <code class="docutils literal notranslate"><span class="pre">#!</span></code> 줄에 지정된 인터프리터를 반환합니다. <code class="docutils literal notranslate"><span class="pre">#!</span></code> 줄이 없으면, <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환합니다. <em>archive</em> 인자는 파일명이나 바이너리 모드로 읽기로 열린 파일류 객체일 수 있습니다. 아카이브가 시작 부분에 위치한 것으로 가정합니다.</p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="zipapp-examples"></span><h2>예<a class="headerlink" href="#examples" title="제목 주소">¶</a></h2>
<p>디렉터리를 아카이브로 패킹하고, 실행합니다.</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m zipapp myapp
<span class="gp">$</span> python myapp.pyz
<span class="go">&lt;output from myapp&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#zipapp.create_archive" title="zipapp.create_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_archive()</span></code></a> 함수를 사용하여 같은 작업을 수행할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">zipapp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipapp</span><span class="o">.</span><span class="n">create_archive</span><span class="p">(</span><span class="s1">&#39;myapp&#39;</span><span class="p">,</span> <span class="s1">&#39;myapp.pyz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>POSIX에서 응용 프로그램을 직접 실행할 수 있게 만들려면, 사용할 인터프리터를 지정하십시오.</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m zipapp myapp -p <span class="s2">&quot;/usr/bin/env python&quot;</span>
<span class="gp">$</span> ./myapp.pyz
<span class="go">&lt;output from myapp&gt;</span>
</pre></div>
</div>
<p>기존 아카이브에서 셔뱅 줄을 바꾸려면, <a class="reference internal" href="#zipapp.create_archive" title="zipapp.create_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_archive()</span></code></a> 함수를 사용하여 수정된 아카이브를 만드십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">zipapp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipapp</span><span class="o">.</span><span class="n">create_archive</span><span class="p">(</span><span class="s1">&#39;old_archive.pyz&#39;</span><span class="p">,</span> <span class="s1">&#39;new_archive.pyz&#39;</span><span class="p">,</span> <span class="s1">&#39;/usr/bin/python3&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>파일을 제자리에서 갱신하려면, <code class="xref py py-class docutils literal notranslate"><span class="pre">BytesIO</span></code> 객체를 사용하여 메모리에서 치환을 수행한 다음, 나중에 소스를 덮어씁니다. 파일을 제자리에서 덮어쓰면 에러로 인해 원본 파일을 손실할 위험이 있음에 유의하십시오. 이 코드는 이러한 에러에 대한 보호는 없지만, 프로덕션 코드는 이를 방지해야 합니다. 또한, 이 방법은 아카이브가 메모리에 올라올 수 있을 때만 작동합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">zipapp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">temp</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipapp</span><span class="o">.</span><span class="n">create_archive</span><span class="p">(</span><span class="s1">&#39;myapp.pyz&#39;</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="s1">&#39;/usr/bin/python2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;myapp.pyz&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="specifying-the-interpreter">
<span id="zipapp-specifying-the-interpreter"></span><h2>인터프리터 지정하기<a class="headerlink" href="#specifying-the-interpreter" title="제목 주소">¶</a></h2>
<p>인터프리터를 지정한 다음 응용 프로그램 아카이브를 배포한다면, 사용된 인터프리터가 이식성 있는지 확인할 필요가 있음에 유의하십시오. 윈도우 용 파이썬 런처는 가장 일반적인 POSIX <code class="docutils literal notranslate"><span class="pre">#!</span></code> 줄 형식을 지원하지만, 고려해야 할 다른 문제가 있습니다:</p>
<ul class="simple">
<li><p>&quot;/usr/bin/env python&quot;(또는 &quot;/usr/bin/python&quot;과 같은 &quot;python&quot; 명령의 다른 형식)을 사용한다면, 사용자에게 기본적으로 파이썬 2나 파이썬 3이 있을 수 있음을 고려해야 하고, 두 버전에서 작동하도록 코드를 작성하십시오.</p></li>
<li><p>&quot;/usr/bin/env python3&quot;과 같이 명시적인 버전을 사용하면 해당 버전이 없는 사용자에게는 응용 프로그램이 작동하지 않습니다. (여러분의 코드를 파이썬 2 호환으로 만들지 않았다면 이것이 여러분이 원하는 것일 수 있습니다).</p></li>
<li><p>&quot;파이썬 X.Y 이상&quot;이라고 말할 방법이 없어서, &quot;/usr/bin/env python3.4&quot;처럼 정확한 버전을 사용할 때는 주의하십시오. 예를 들어 파이썬 3.5 사용자를 위해서는 셔뱅 줄을 변경해야 합니다.</p></li>
</ul>
<p>일반적으로, 여러분의 코드가 파이썬 2나 3중 어느 것으로 작성되었는지에 따라 &quot;/usr/bin/env python2&quot;나 &quot;/usr/bin/env python3&quot;을 사용해야 합니다.</p>
</div>
<div class="section" id="creating-standalone-applications-with-zipapp">
<h2>zipapp으로 독립형 응용 프로그램 만들기<a class="headerlink" href="#creating-standalone-applications-with-zipapp" title="제목 주소">¶</a></h2>
<p><a class="reference internal" href="#module-zipapp" title="zipapp: Manage executable Python zip archives"><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipapp</span></code></a> 모듈을 사용하면, 시스템에 적합한 버전의 파이썬만 설치되어있는 최종 사용자에게 배포 할 수 있는 필요한 모든 것이 담긴 파이썬 프로그램을 만들 수 있습니다. 이 작업의 핵심은 응용 프로그램 코드와 함께 모든 응용 프로그램의 종속성을 아카이브에 묶는 것입니다.</p>
<p>독립형 아카이브를 만드는 단계는 다음과 같습니다:</p>
<ol class="arabic">
<li><p>정상적으로 디렉터리에 응용 프로그램을 만드십시오, 그러면 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 파일과 모든 지원 응용 프로그램 코드를 포함하는 <code class="docutils literal notranslate"><span class="pre">myapp</span></code> 디렉터리를 얻게 됩니다.</p></li>
<li><p>pip을 사용하여 모든 응용 프로그램의 종속성을 <code class="docutils literal notranslate"><span class="pre">myapp</span></code> 디렉터리에 설치하십시오:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m pip install -r requirements.txt --target myapp
</pre></div>
</div>
<p>(이것은 <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> 파일에 프로젝트 요구 사항이 있다고 가정합니다 - 그렇지 않으면, pip 명령 줄에 종속성을 수동으로 나열할 수 있습니다).</p>
</li>
<li><p>선택적으로, <code class="docutils literal notranslate"><span class="pre">myapp</span></code> 디렉터리에 pip이 만든 <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code> 디렉터리를 삭제합니다. 이것들은 pip이 패키지를 관리하는 데 필요한 메타 데이터를 담고 있으면, pip을 더는 사용하지 않을 것이기 때문에 필요하지 않습니다 - 남겨두더라도 아무런 해를 끼치지는 않습니다.</p></li>
<li><p>다음과 같이 응용 프로그램을 패키징하십시오:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m zipapp -p <span class="s2">&quot;interpreter&quot;</span> myapp
</pre></div>
</div>
</li>
</ol>
<p>그러면 독립형 실행 파일이 생성되며, 사용 가능한 적절한 인터프리터가 있는 모든 시스템에서 실행할 수 있습니다. 자세한 내용은 <a class="reference internal" href="#zipapp-specifying-the-interpreter"><span class="std std-ref">인터프리터 지정하기</span></a>를 참조하십시오. 단일 파일로 사용자에게 제공될 수 있습니다.</p>
<p>유닉스에서, <code class="docutils literal notranslate"><span class="pre">myapp.pyz</span></code> 파일은 그대로 실행 파일입니다. &quot;평범한&quot; 명령 이름을 선호하면, 파일 이름을 변경하여 <code class="docutils literal notranslate"><span class="pre">.pyz</span></code> 확장자를 제거할 수 있습니다. 윈도우에서, 파이썬 인터프리터가 설치될 때 <code class="docutils literal notranslate"><span class="pre">.pyz</span></code>와 <code class="docutils literal notranslate"><span class="pre">.pyzw</span></code> 파일 확장자를 등록한다는 점에서  <code class="docutils literal notranslate"><span class="pre">myapp.pyz[w]</span></code> 파일은 실행 파일입니다.</p>
<div class="section" id="making-a-windows-executable">
<h3>윈도우 실행 파일 만들기<a class="headerlink" href="#making-a-windows-executable" title="제목 주소">¶</a></h3>
<p>윈도우에서, <code class="docutils literal notranslate"><span class="pre">.pyz</span></code> 확장자의 등록은 선택 사항입니다, 더군다나 등록된 확장자를 &quot;투명하게&quot; 인식하지 못하는 특정 장소가 있습니다 (가장 간단한 예는 <code class="docutils literal notranslate"><span class="pre">subprocess.run(['myapp'])</span></code>이 응용 프로그램을 찾지 못하는 것입니다 - 확장자를 명시적으로 지정해야 합니다) .</p>
<p>따라서 윈도우에서는, 종종 zipapp에서 실행 파일을 만드는 것이 좋습니다. C 컴파일러가 필요하지만, 비교적 쉽습니다. 기본 접근법은 zip 파일의 앞에 임의의 데이터가 추가될 수 있고, 윈도우 exe 파일에는 임의의 데이터가 뒤에 추가될 수 있다는 사실에 의존합니다. 따라서 적절한 런처를 만들고 <code class="docutils literal notranslate"><span class="pre">.pyz</span></code> 파일을 그 끝에 붙임으로써, 응용 프로그램을 실행하는 단일 파일 실행 파일이 생깁니다.</p>
<p>적합한 런처는 다음처럼 간단할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#define Py_LIMITED_API 1</span>
<span class="c1">#include &quot;Python.h&quot;</span>

<span class="c1">#define WIN32_LEAN_AND_MEAN</span>
<span class="c1">#include &lt;windows.h&gt;</span>

<span class="c1">#ifdef WINDOWS</span>
<span class="nb">int</span> <span class="n">WINAPI</span> <span class="n">wWinMain</span><span class="p">(</span>
    <span class="n">HINSTANCE</span> <span class="n">hInstance</span><span class="p">,</span>      <span class="o">/*</span> <span class="n">handle</span> <span class="n">to</span> <span class="n">current</span> <span class="n">instance</span> <span class="o">*/</span>
    <span class="n">HINSTANCE</span> <span class="n">hPrevInstance</span><span class="p">,</span>  <span class="o">/*</span> <span class="n">handle</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">instance</span> <span class="o">*/</span>
    <span class="n">LPWSTR</span> <span class="n">lpCmdLine</span><span class="p">,</span>         <span class="o">/*</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">command</span> <span class="n">line</span> <span class="o">*/</span>
    <span class="nb">int</span> <span class="n">nCmdShow</span>              <span class="o">/*</span> <span class="n">show</span> <span class="n">state</span> <span class="n">of</span> <span class="n">window</span> <span class="o">*/</span>
<span class="p">)</span>
<span class="c1">#else</span>
<span class="nb">int</span> <span class="n">wmain</span><span class="p">()</span>
<span class="c1">#endif</span>
<span class="p">{</span>
    <span class="n">wchar_t</span> <span class="o">**</span><span class="n">myargv</span> <span class="o">=</span> <span class="n">_alloca</span><span class="p">((</span><span class="n">__argc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">wchar_t</span><span class="o">*</span><span class="p">));</span>
    <span class="n">myargv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__wargv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">myargv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">__wargv</span><span class="p">,</span> <span class="n">__argc</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">wchar_t</span> <span class="o">*</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">Py_Main</span><span class="p">(</span><span class="n">__argc</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">myargv</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">WINDOWS</span></code> 전처리기 기호를 정의하면, GUI 실행 파일을 만들고, 그렇지 않으면 콘솔 실행 파일을 만듭니다.</p>
<p>실행 파일을 컴파일하려면, 그냥 표준 MSVC 명령 줄 도구를 사용하거나 distutils가 파이썬 소스를 컴파일하는 방법을 알고 있다는 사실을 활용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">distutils.ccompiler</span> <span class="k">import</span> <span class="n">new_compiler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">distutils.sysconfig</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="k">import</span> <span class="n">Path</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">src</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">cc</span> <span class="o">=</span> <span class="n">new_compiler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">exe</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">stem</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">cc</span><span class="o">.</span><span class="n">add_include_dir</span><span class="p">(</span><span class="n">distutils</span><span class="o">.</span><span class="n">sysconfig</span><span class="o">.</span><span class="n">get_python_inc</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">cc</span><span class="o">.</span><span class="n">add_library_dir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">base_exec_prefix</span><span class="p">,</span> <span class="s1">&#39;libs&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c1"># 먼저 CLI 실행 파일</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">objs</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">compile</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">src</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">cc</span><span class="o">.</span><span class="n">link_executable</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="n">exe</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c1"># 이제 GUI 실행 파일</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">cc</span><span class="o">.</span><span class="n">define_macro</span><span class="p">(</span><span class="s1">&#39;WINDOWS&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">objs</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">compile</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">src</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">cc</span><span class="o">.</span><span class="n">link_executable</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="n">exe</span> <span class="o">+</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">compile</span><span class="p">(</span><span class="s2">&quot;zastub.c&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>결과 런처는 &quot;제한된 ABI&quot;를 사용해서, 모든 버전의 파이썬 3.x에서 변경 없이 실행됩니다. 파이썬(<code class="docutils literal notranslate"><span class="pre">python3.dll</span></code>)이 사용자의 <code class="docutils literal notranslate"><span class="pre">PATH</span></code>에 있기만 하면 됩니다.</p>
<p>완전 독립형 배포를 위해서는, 응용 프로그램을 덧붙인 런처와 함께 파이썬 &quot;내장(embedded)&quot; 배포를 번들로 배포할 수 있습니다. 적절한 아키텍처(32비트나 64비트)를 갖는 모든 PC에서 실행됩니다.</p>
</div>
<div class="section" id="caveats">
<h3>경고<a class="headerlink" href="#caveats" title="제목 주소">¶</a></h3>
<p>응용 프로그램을 단일 파일로 묶는 과정에는 몇 가지 제한이 있습니다. 전부는 아니더라도 대부분의 경우 응용 프로그램을 크게 변경하지 않고도 해결할 수 있습니다.</p>
<ol class="arabic simple">
<li><p>응용 프로그램이 C 확장을 포함하는 패키지에 의존하면, 해당 패키지는 zip 파일에서 실행할 수 없습니다 (이것은 OS 제한 사항인데, OS 로더가 로드 할 수 있으려면 실행 코드는 파일 시스템에 있어야만 합니다). 이 경우, zip 파일에서 해당 종속성을 제외하고, 사용자가 파일을 설치하도록 요구하거나, zip 파일과 함께 제공하고 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code>에 코드를 추가하여 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>에 압축 해제된 모듈을 포함하는 디렉터리를 포함할 수 있습니다. 이 경우, 대상 아키텍처에 적합한 바이너리를 제공해야 합니다 (그리고 아마도 사용자 컴퓨터를 기반으로 실행 시간에 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>에 추가할 올바른 버전을 선택해야 합니다).</p></li>
<li><p>위에서 설명한 대로 윈도우 실행 파일을 제공하는 경우, 사용자의 PATH에 <code class="docutils literal notranslate"><span class="pre">python3.dll</span></code>이 있는지 (설치 프로그램의 기본 동작이 아님) 확인하거나 응용 프로그램과 함께 내장 배포를 번들로 제공해야 합니다.</p></li>
<li><p>위에서 제안한 런처는 파이썬 내장(embedding) API를 사용합니다. 이는 여러분의 응용 프로그램에서, <code class="docutils literal notranslate"><span class="pre">sys.executable</span></code>이 일반적인 파이썬 인터프리터가 <em>아니라</em> 여러분의 응용 프로그램이 된다는 뜻입니다. 코드와 종속성은 이 가능성에 대비해야 합니다. 예를 들어, 응용 프로그램에서 <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 모듈을 사용하면, 표준 파이썬 인터프리터를 찾을 위치를 모듈에 알리기 위해 <a class="reference internal" href="multiprocessing.html#multiprocessing.set_executable" title="multiprocessing.set_executable"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiprocessing.set_executable()</span></code></a>을 호출해야 합니다.</p></li>
</ol>
</div>
</div>
<div class="section" id="the-python-zip-application-archive-format">
<h2>파이썬 Zip 응용 프로그램 아카이브 형식<a class="headerlink" href="#the-python-zip-application-archive-format" title="제목 주소">¶</a></h2>
<p>파이썬은 버전 2.6부터 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 파일이 포함된 zip 파일을 실행할 수 있었습니다. 파이썬에서 실행되려면, 응용 프로그램 아카이브는 응용 프로그램의 진입점으로 실행될 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 파일이 포함된 표준 zip 파일이어야 합니다. 모든 파이썬 스크립트와 마찬가지로, 스크립트의 부모(이 경우 zip 파일)가 <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>에 배치되므로 zip 파일에서 추가 모듈을 임포트 할 수 있습니다.</p>
<p>zip 파일 형식은 임의의 데이터를 zip 파일 앞에 추가할 수 있도록 합니다. zip 응용 프로그램 형식은 이 기능을 사용하여 표준 POSIX &quot;셔뱅(shebang)&quot; 줄을 파일 앞에 추가합니다 (<code class="docutils literal notranslate"><span class="pre">#!/path/to/interpreter</span></code>).</p>
<p>따라서 공식적으로 파이썬 zip 응용 프로그램 형식은 다음과 같습니다:</p>
<ol class="arabic simple">
<li><p>문자 <code class="docutils literal notranslate"><span class="pre">b'#!'</span></code>, 인터프리터 이름, 개행 (<code class="docutils literal notranslate"><span class="pre">b'\n'</span></code>) 문자를 포함하는 선택적 셔뱅(shebang) 줄. 인터프리터 이름은 OS &quot;셔뱅&quot; 처리가 허용하는 모든 것, 또는 윈도우의 파이썬 런처일 수 있습니다. 인터프리터는 윈도우에서는 UTF-8로, POSIX에서는 <a class="reference internal" href="sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code></a>으로 인코딩되어야 합니다.</p></li>
<li><p><a class="reference internal" href="zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> 모듈에 의해 생성된 표준 zip 파일 데이터. zipfile 내용은 <em>반드시</em> <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code>라는 파일을 포함해야 합니다 (zip 파일의 &quot;루트&quot;에 있어야 합니다 - 즉, 서브 디렉터리에 있을 수 없습니다). zip 파일 데이터는 압축되거나 그렇지 않을 수 있습니다.</p></li>
</ol>
<p>응용 프로그램 아카이브에 셔뱅 줄이 있으면, POSIX 시스템에서 직접 실행될 수 있도록 실행 파일 비트를 설정할 수 있습니다.</p>
<p>이 모듈의 도구를 사용하여 응용 프로그램 아카이브를 만들 필요는 없습니다 - 모듈은 편의를 위한 것입니다. 하지만 어떤 방법으로 만들었든 위 형식의 아카이브는 파이썬에서 허용됩니다.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipapp</span></code> --- 실행 가능한 파이썬 zip 아카이브 관리</a><ul>
<li><a class="reference internal" href="#basic-example">기본 예</a></li>
<li><a class="reference internal" href="#command-line-interface">명령 줄 인터페이스</a></li>
<li><a class="reference internal" href="#python-api">파이썬 API</a></li>
<li><a class="reference internal" href="#examples">예</a></li>
<li><a class="reference internal" href="#specifying-the-interpreter">인터프리터 지정하기</a></li>
<li><a class="reference internal" href="#creating-standalone-applications-with-zipapp">zipapp으로 독립형 응용 프로그램 만들기</a><ul>
<li><a class="reference internal" href="#making-a-windows-executable">윈도우 실행 파일 만들기</a></li>
<li><a class="reference internal" href="#caveats">경고</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-python-zip-application-archive-format">파이썬 Zip 응용 프로그램 아카이브 형식</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="venv.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code> --- 가상 환경 생성</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="python.html"
                        title="다음 장">파이썬 실행시간 서비스</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="python.html" title="파이썬 실행시간 서비스"
             >다음</a> |</li>
        <li class="right" >
          <a href="venv.html" title="venv --- 가상 환경 생성"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="distribution.html" >소프트웨어 패키징 및 배포</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2021, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2021, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>