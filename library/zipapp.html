
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>zipapp --- 실행 가능한 파이썬 zip 아카이브 관리 &#8212; 파이썬 설명서 주석판</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="파이썬 설명서 주석판에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="파이썬 실행시간 서비스" href="python.html" />
    <link rel="prev" title="venv --- 가상 환경 생성" href="venv.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://python.flowdas.com/library/zipapp.html" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112027364-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-112027364-1');
    </script>
    <style>
      div.admonition-flowdas {
        border-radius: 3px;
        background-color: #ffc;
        border: 1px solid #ff6;
      }
    </style>

    
      
      <script type="text/javascript" src="../_static/switchers.js"></script>
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="python.html" title="파이썬 실행시간 서비스"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="venv.html" title="venv --- 가상 환경 생성"
             accesskey="P">이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="distribution.html" accesskey="U">소프트웨어 패키징 및 배포</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-zipapp">
<span id="zipapp-manage-executable-python-zip-archives"></span><h1><a class="reference internal" href="#module-zipapp" title="zipapp: Manage executable Python zip archives"><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipapp</span></code></a> --- 실행 가능한 파이썬 zip 아카이브 관리<a class="headerlink" href="#module-zipapp" title="제목 주소">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.8/Lib/zipapp.py">Lib/zipapp.py</a></p>
<hr class="docutils" id="index-0" />
<p>이 모듈은 <a class="reference internal" href="../using/cmdline.html#using-on-interface-options"><span class="std std-ref">파이썬 인터프리터가 직접 실행할</span></a> 수 있는 파이썬 코드를 포함하는 zip 파일 생성을 관리하는 도구를 제공합니다. 이 모듈은 <a class="reference internal" href="#zipapp-command-line-interface"><span class="std std-ref">명령 줄 인터페이스</span></a>와 <a class="reference internal" href="#zipapp-python-api"><span class="std std-ref">파이썬 API</span></a>를 모두 제공합니다.</p>
<div class="section" id="basic-example">
<h2>기본 예<a class="headerlink" href="#basic-example" title="제목 주소">¶</a></h2>
<p>다음 예제는 <a class="reference internal" href="#zipapp-command-line-interface"><span class="std std-ref">명령 줄 인터페이스</span></a>를 사용하여 파이썬 코드가 포함된 디렉터리에서 실행 가능 아카이브를 만드는 방법을 보여줍니다. 실행하면, 아카이브가 아카이브의 모듈 <code class="docutils literal notranslate"><span class="pre">myapp</span></code>에서 <code class="docutils literal notranslate"><span class="pre">main</span></code> 함수를 실행합니다.</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m zipapp myapp -m <span class="s2">&quot;myapp:main&quot;</span>
<span class="gp">$</span> python myapp.pyz
<span class="go">&lt;output from myapp&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="command-line-interface">
<span id="zipapp-command-line-interface"></span><h2>명령 줄 인터페이스<a class="headerlink" href="#command-line-interface" title="제목 주소">¶</a></h2>
<p>명령 줄에서 프로그램으로 호출될 때, 다음 형식이 사용됩니다:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m zipapp <span class="nb">source</span> <span class="o">[</span>options<span class="o">]</span>
</pre></div>
</div>
<p><em>source</em>가 디렉터리면, <em>source</em>의 내용으로부터 아카이브를 만듭니다. <em>source</em>가 파일이면, 아카이브여야 하며, 대상 아카이브로 복사됩니다 (또는 --info 옵션이 지정되면 셔뱅(shebang) 줄의 내용이 표시됩니다).</p>
<p>다음과 같은 옵션이 이해됩니다:</p>
<dl class="cmdoption">
<dt id="cmdoption-zipapp-o">
<code class="sig-name descname">-o</code><code class="sig-prename descclassname"> &lt;output&gt;</code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--output</code><code class="sig-prename descclassname">=&lt;output&gt;</code><a class="headerlink" href="#cmdoption-zipapp-o" title="정의 주소">¶</a></dt>
<dd><p>출력을 <em>output</em>이라는 이름의 파일에 씁니다. 이 옵션을 지정하지 않으면, 출력 파일명은 입력 <em>source</em>와 같고, 확장자 <code class="docutils literal notranslate"><span class="pre">.pyz</span></code>가 추가됩니다. 명시적인 파일명이 제공되면, 그대로 사용됩니다 (그래서 필요하면 <code class="docutils literal notranslate"><span class="pre">.pyz</span></code> 확장자를 포함해야 합니다).</p>
<p><em>source</em>가 아카이브이면 반드시 출력 파일명을 지정해야 합니다 (그리고 이 경우, <em>output</em>은 <em>source</em>와 달라야 합니다).</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-zipapp-p">
<code class="sig-name descname">-p</code><code class="sig-prename descclassname"> &lt;interpreter&gt;</code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--python</code><code class="sig-prename descclassname">=&lt;interpreter&gt;</code><a class="headerlink" href="#cmdoption-zipapp-p" title="정의 주소">¶</a></dt>
<dd><p>실행할 명령으로 <em>interpreter</em>를 지정하여 <code class="docutils literal notranslate"><span class="pre">#!</span></code> 줄을 아카이브에 추가합니다. 또한, POSIX에서, 아카이브를 실행 파일로 만듭니다. 기본값은 <code class="docutils literal notranslate"><span class="pre">#!</span></code> 줄을 쓰지 않고, 파일을 실행 파일로 만들지 않는 것입니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-zipapp-m">
<code class="sig-name descname">-m</code><code class="sig-prename descclassname"> &lt;mainfn&gt;</code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--main</code><code class="sig-prename descclassname">=&lt;mainfn&gt;</code><a class="headerlink" href="#cmdoption-zipapp-m" title="정의 주소">¶</a></dt>
<dd><p>아카이브에 <em>mainfn</em>을 실행하는 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 파일을 씁니다. <em>mainfn</em> 인자는 &quot;pkg.mod:fn&quot; 형식이어야 합니다. 여기서 &quot;pkg.mod&quot;는 아카이브의 패키지/모듈이며, &quot;fn&quot;은 주어진 모듈에 있는 콜러블입니다. <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 파일은 그 콜러블을 실행합니다.</p>
<p>아카이브를 복사할 때 <a class="reference internal" href="#cmdoption-zipapp-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">--main</span></code></a>을 지정할 수 없습니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-zipapp-c">
<code class="sig-name descname">-c</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--compress</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-zipapp-c" title="정의 주소">¶</a></dt>
<dd><p>디플레이트(deflate) 메서드로 파일을 압축하여, 출력 파일의 크기를 줄입니다. 기본적으로, 파일은 아카이브에 압축되지 않은 상태로 저장됩니다.</p>
<p>아카이브를 복사할 때 <a class="reference internal" href="#cmdoption-zipapp-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">--compress</span></code></a>는 효과가 없습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가.</span></p>
</div>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-zipapp-info">
<code class="sig-name descname">--info</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-zipapp-info" title="정의 주소">¶</a></dt>
<dd><p>진단 목적으로, 아카이브에 내장된 인터프리터를 표시합니다. 이 경우, 다른 옵션은 무시되고 SOURCE는 디렉터리가 아닌 아카이브여야 합니다.</p>
</dd></dl>

<dl class="cmdoption">
<dt id="cmdoption-zipapp-h">
<code class="sig-name descname">-h</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--help</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-zipapp-h" title="정의 주소">¶</a></dt>
<dd><p>간단한 사용법 메시지를 인쇄하고 종료합니다.</p>
</dd></dl>

</div>
<div class="section" id="python-api">
<span id="zipapp-python-api"></span><h2>파이썬 API<a class="headerlink" href="#python-api" title="제목 주소">¶</a></h2>
<p>이 모듈은 두 개의 편의 함수를 정의합니다:</p>
<dl class="function">
<dt id="zipapp.create_archive">
<code class="sig-prename descclassname">zipapp.</code><code class="sig-name descname">create_archive</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">target=None</em>, <em class="sig-param">interpreter=None</em>, <em class="sig-param">main=None</em>, <em class="sig-param">filter=None</em>, <em class="sig-param">compressed=False</em><span class="sig-paren">)</span><a class="headerlink" href="#zipapp.create_archive" title="정의 주소">¶</a></dt>
<dd><p><em>source</em>로 응용 프로그램 아카이브를 만듭니다. 소스는 다음 중 하나일 수 있습니다:</p>
<ul class="simple">
<li><p>디렉터리 이름, 또는 디렉터리를 참조하는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>. 이 경우 해당 디렉터리의 내용으로 새 응용 프로그램 아카이브가 만들어집니다.</p></li>
<li><p>기존 응용 프로그램 아카이브 파일의 이름, 또는 이러한 파일을 참조하는 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>. 이 경우 파일이 대상(target)으로 복사됩니다 (<em>interpreter</em> 인자에 제공된 값을 반영하도록 수정하면서). 필요하면, 파일 이름에 <code class="docutils literal notranslate"><span class="pre">.pyz</span></code> 확장자가 포함되어야 합니다.</p></li>
<li><p>바이너리 모드에서 읽기로 열린 파일 객체. 파일의 내용은 응용 프로그램 아카이브여야 하며, 파일 객체는 아카이브의 시작 부분에 위치한 것으로 가정합니다.</p></li>
</ul>
<p><em>target</em> 인자는 결과 아카이브가 기록될 위치를 결정합니다:</p>
<ul class="simple">
<li><p>파일 이름이거나 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">경로류 객체</span></a>이면, 아카이브가 그 파일에 기록됩니다.</p></li>
<li><p>열린 파일 객체면, 그 파일 객체에 아카이브가 기록되며, 파일은 바이너리 모드로 쓰기로 열려 있어야 합니다.</p></li>
<li><p>target이 생략되면 (또는 <code class="docutils literal notranslate"><span class="pre">None</span></code>이면), 소스(source)는 디렉터리여야 하며 대상은 <code class="docutils literal notranslate"><span class="pre">.pyz</span></code> 확장자가 추가된 소스와 이름이 같은 파일이 됩니다.</p></li>
</ul>
<p><em>interpreter</em> 인자는 아카이브가 실행될 파이썬 인터프리터의 이름을 지정합니다. 아카이브 시작 부분에 &quot;셔뱅(shebang)&quot; 줄로 기록됩니다. POSIX에서는 이를 OS가 해석하고, 윈도우에서는 파이썬 런처가 이를 처리합니다. <em>interpreter</em>를 생략하면 셔뱅 줄이 기록되지 않습니다. interpreter가 지정되고 target이 파일명이면, target 파일의 실행 가능 비트가 설정됩니다.</p>
<p><em>main</em> 인자는 아카이브의 메인 프로그램으로 사용될 콜러블의 이름을 지정합니다. 소스가 디렉터리이고 소스에 아직 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 파일이 없을 때만 지정할 수 있습니다. <em>main</em> 인자는 &quot;pkg.module:callable&quot; 형식이어야 하며 아카이브는 &quot;pkg.module&quot;을 임포트 하고 인자 없이 지정된 콜러블을 실행해서 실행됩니다. 소스가 디렉터리이고 <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> 파일을 포함하지 않을 때 <em>main</em>을 생략하는 것은 에러입니다, 그렇지 않으면 결과 아카이브가 실행 가능하지 않기 때문입니다.</p>
<p>선택적 <em>filter</em> 인자는 추가되는 파일의 (소스 디렉터리에 상대적인) 경로를 나타내는 Path 객체가 전달되는 콜백 함수를 지정합니다. 파일을 추가하려면 <code class="docutils literal notranslate"><span class="pre">True</span></code>를 반환해야 합니다.</p>
<p>선택적 <em>compressed</em> 인자는 파일을 압축할지를 결정합니다. <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정하면, 아카이브의 파일이 디플레이트(deflate) 메서드로 압축됩니다; 그렇지 않으면 파일이 압축되지 않은 상태로 저장됩니다. 기존 아카이브를 복사할 때는 이 인자가 효과가 없습니다.</p>
<p><em>source</em>나 <em>target</em>에 파일 객체가 지정되면, create_archive를 호출한 후 파일 객체를 닫는 것은 호출자의 책임입니다.</p>
<p>기존 아카이브를 복사할 때, 제공된 파일 객체에는 <code class="docutils literal notranslate"><span class="pre">read</span></code>와 <code class="docutils literal notranslate"><span class="pre">readline</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">write</span></code> 메서드만 필요합니다. 디렉터리에서 아카이브를 만들 때, 대상이 파일 객체면 <code class="docutils literal notranslate"><span class="pre">zipfile.ZipFile</span></code> 클래스로 전달되며, 해당 클래스에 필요한 메서드를 제공해야 합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span><em>filter</em>와 <em>compressed</em> 인자를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="zipapp.get_interpreter">
<code class="sig-prename descclassname">zipapp.</code><code class="sig-name descname">get_interpreter</code><span class="sig-paren">(</span><em class="sig-param">archive</em><span class="sig-paren">)</span><a class="headerlink" href="#zipapp.get_interpreter" title="정의 주소">¶</a></dt>
<dd><p>아카이브 시작 부분에서 <code class="docutils literal notranslate"><span class="pre">#!</span></code> 줄에 지정된 인터프리터를 반환합니다. <code class="docutils literal notranslate"><span class="pre">#!</span></code> 줄이 없으면, <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>을 반환합니다. <em>archive</em> 인자는 파일명이나 바이너리 모드로 읽기로 열린 파일류 객체일 수 있습니다. 아카이브가 시작 부분에 위치한 것으로 가정합니다.</p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="zipapp-examples"></span><h2>예<a class="headerlink" href="#examples" title="제목 주소">¶</a></h2>
<p>디렉터리를 아카이브로 패킹하고, 실행합니다.</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m zipapp myapp
<span class="gp">$</span> python myapp.pyz
<span class="go">&lt;output from myapp&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#zipapp.create_archive" title="zipapp.create_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_archive()</span></code></a> 함수를 사용하여 같은 작업을 수행할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">zipapp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipapp</span><span class="o">.</span><span class="n">create_archive</span><span class="p">(</span><span class="s1">&#39;myapp.pyz&#39;</span><span class="p">,</span> <span class="s1">&#39;myapp&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>POSIX에서 응용 프로그램을 직접 실행할 수 있게 만들려면, 사용할 인터프리터를 지정하십시오.</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m zipapp myapp -p <span class="s2">&quot;/usr/bin/env python&quot;</span>
<span class="gp">$</span> ./myapp.pyz
<span class="go">&lt;output from myapp&gt;</span>
</pre></div>
</div>
<p>기존 아카이브에서 셔뱅 줄을 바꾸려면, <a class="reference internal" href="#zipapp.create_archive" title="zipapp.create_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_archive()</span></code></a> 함수를 사용하여 수정된 아카이브를 만드십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">zipapp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipapp</span><span class="o">.</span><span class="n">create_archive</span><span class="p">(</span><span class="s1">&#39;old_archive.pyz&#39;</span><span class="p">,</span> <span class="s1">&#39;new_archive.pyz&#39;</span><span class="p">,</span> <span class="s1">&#39;/usr/bin/python3&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>파일을 제자리에서 갱신하려면, <code class="xref py py-class docutils literal notranslate"><span class="pre">BytesIO</span></code> 객체를 사용하여 메모리에서 치환을 수행한 다음, 나중에 소스를 덮어씁니다. 파일을 제자리에서 덮어쓰면 에러로 인해 원본 파일을 손실할 위험이 있음에 유의하십시오. 이 코드는 이러한 에러에 대한 보호는 없지만, 프로덕션 코드는 이를 방지해야 합니다. 또한, 이 방법은 아카이브가 메모리에 올라올 수 있을 때만 작동합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">zipapp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">temp</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipapp</span><span class="o">.</span><span class="n">create_archive</span><span class="p">(</span><span class="s1">&#39;myapp.pyz&#39;</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="s1">&#39;/usr/bin/python2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;myapp.pyz&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="specifying-the-interpreter">
<span id="zipapp-specifying-the-interpreter"></span><h2>Specifying the Interpreter<a class="headerlink" href="#specifying-the-interpreter" title="제목 주소">¶</a></h2>
<p>Note that if you specify an interpreter and then distribute your application
archive, you need to ensure that the interpreter used is portable.  The Python
launcher for Windows supports most common forms of POSIX <code class="docutils literal notranslate"><span class="pre">#!</span></code> line, but there
are other issues to consider:</p>
<ul class="simple">
<li><p>If you use &quot;/usr/bin/env python&quot; (or other forms of the &quot;python&quot; command,
such as &quot;/usr/bin/python&quot;), you need to consider that your users may have
either Python 2 or Python 3 as their default, and write your code to work
under both versions.</p></li>
<li><p>If you use an explicit version, for example &quot;/usr/bin/env python3&quot; your
application will not work for users who do not have that version.  (This
may be what you want if you have not made your code Python 2 compatible).</p></li>
<li><p>There is no way to say &quot;python X.Y or later&quot;, so be careful of using an
exact version like &quot;/usr/bin/env python3.4&quot; as you will need to change your
shebang line for users of Python 3.5, for example.</p></li>
</ul>
<p>Typically, you should use an &quot;/usr/bin/env python2&quot; or &quot;/usr/bin/env python3&quot;,
depending on whether your code is written for Python 2 or 3.</p>
</div>
<div class="section" id="creating-standalone-applications-with-zipapp">
<h2>Creating Standalone Applications with zipapp<a class="headerlink" href="#creating-standalone-applications-with-zipapp" title="제목 주소">¶</a></h2>
<p>Using the <a class="reference internal" href="#module-zipapp" title="zipapp: Manage executable Python zip archives"><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipapp</span></code></a> module, it is possible to create self-contained Python
programs, which can be distributed to end users who only need to have a
suitable version of Python installed on their system.  The key to doing this
is to bundle all of the application's dependencies into the archive, along
with the application code.</p>
<p>The steps to create a standalone archive are as follows:</p>
<ol class="arabic">
<li><p>Create your application in a directory as normal, so you have a <code class="docutils literal notranslate"><span class="pre">myapp</span></code>
directory containing a <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> file, and any supporting application
code.</p></li>
<li><p>Install all of your application's dependencies into the <code class="docutils literal notranslate"><span class="pre">myapp</span></code> directory,
using pip:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m pip install -r requirements.txt --target myapp
</pre></div>
</div>
<p>(this assumes you have your project requirements in a <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code>
file - if not, you can just list the dependencies manually on the pip command
line).</p>
</li>
<li><p>Optionally, delete the <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code> directories created by pip in the
<code class="docutils literal notranslate"><span class="pre">myapp</span></code> directory. These hold metadata for pip to manage the packages, and
as you won't be making any further use of pip they aren't required -
although it won't do any harm if you leave them.</p></li>
<li><p>Package the application using:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python -m zipapp -p <span class="s2">&quot;interpreter&quot;</span> myapp
</pre></div>
</div>
</li>
</ol>
<p>This will produce a standalone executable, which can be run on any machine with
the appropriate interpreter available. See <a class="reference internal" href="#zipapp-specifying-the-interpreter"><span class="std std-ref">Specifying the Interpreter</span></a>
for details. It can be shipped to users as a single file.</p>
<p>On Unix, the <code class="docutils literal notranslate"><span class="pre">myapp.pyz</span></code> file is executable as it stands.  You can rename the
file to remove the <code class="docutils literal notranslate"><span class="pre">.pyz</span></code> extension if you prefer a &quot;plain&quot; command name.  On
Windows, the <code class="docutils literal notranslate"><span class="pre">myapp.pyz[w]</span></code> file is executable by virtue of the fact that
the Python interpreter registers the <code class="docutils literal notranslate"><span class="pre">.pyz</span></code> and <code class="docutils literal notranslate"><span class="pre">.pyzw</span></code> file extensions
when installed.</p>
<div class="section" id="making-a-windows-executable">
<h3>Making a Windows executable<a class="headerlink" href="#making-a-windows-executable" title="제목 주소">¶</a></h3>
<p>On Windows, registration of the <code class="docutils literal notranslate"><span class="pre">.pyz</span></code> extension is optional, and
furthermore, there are certain places that don't recognise registered
extensions &quot;transparently&quot; (the simplest example is that
<code class="docutils literal notranslate"><span class="pre">subprocess.run(['myapp'])</span></code> won't find your application - you need to
explicitly specify the extension).</p>
<p>On Windows, therefore, it is often preferable to create an executable from the
zipapp.  This is relatively easy, although it does require a C compiler.  The
basic approach relies on the fact that zipfiles can have arbitrary data
prepended, and Windows exe files can have arbitrary data appended.  So by
creating a suitable launcher and tacking the <code class="docutils literal notranslate"><span class="pre">.pyz</span></code> file onto the end of it,
you end up with a single-file executable that runs your application.</p>
<p>A suitable launcher can be as simple as the following:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#define Py_LIMITED_API 1</span>
<span class="c1">#include &quot;Python.h&quot;</span>

<span class="c1">#define WIN32_LEAN_AND_MEAN</span>
<span class="c1">#include &lt;windows.h&gt;</span>

<span class="c1">#ifdef WINDOWS</span>
<span class="nb">int</span> <span class="n">WINAPI</span> <span class="n">wWinMain</span><span class="p">(</span>
    <span class="n">HINSTANCE</span> <span class="n">hInstance</span><span class="p">,</span>      <span class="o">/*</span> <span class="n">handle</span> <span class="n">to</span> <span class="n">current</span> <span class="n">instance</span> <span class="o">*/</span>
    <span class="n">HINSTANCE</span> <span class="n">hPrevInstance</span><span class="p">,</span>  <span class="o">/*</span> <span class="n">handle</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">instance</span> <span class="o">*/</span>
    <span class="n">LPWSTR</span> <span class="n">lpCmdLine</span><span class="p">,</span>         <span class="o">/*</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">command</span> <span class="n">line</span> <span class="o">*/</span>
    <span class="nb">int</span> <span class="n">nCmdShow</span>              <span class="o">/*</span> <span class="n">show</span> <span class="n">state</span> <span class="n">of</span> <span class="n">window</span> <span class="o">*/</span>
<span class="p">)</span>
<span class="c1">#else</span>
<span class="nb">int</span> <span class="n">wmain</span><span class="p">()</span>
<span class="c1">#endif</span>
<span class="p">{</span>
    <span class="n">wchar_t</span> <span class="o">**</span><span class="n">myargv</span> <span class="o">=</span> <span class="n">_alloca</span><span class="p">((</span><span class="n">__argc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">wchar_t</span><span class="o">*</span><span class="p">));</span>
    <span class="n">myargv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__wargv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">myargv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">__wargv</span><span class="p">,</span> <span class="n">__argc</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">wchar_t</span> <span class="o">*</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">Py_Main</span><span class="p">(</span><span class="n">__argc</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">myargv</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you define the <code class="docutils literal notranslate"><span class="pre">WINDOWS</span></code> preprocessor symbol, this will generate a
GUI executable, and without it, a console executable.</p>
<p>To compile the executable, you can either just use the standard MSVC
command line tools, or you can take advantage of the fact that distutils
knows how to compile Python source:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">distutils.ccompiler</span> <span class="k">import</span> <span class="n">new_compiler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">distutils.sysconfig</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="k">import</span> <span class="n">Path</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">src</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">cc</span> <span class="o">=</span> <span class="n">new_compiler</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">exe</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">stem</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">cc</span><span class="o">.</span><span class="n">add_include_dir</span><span class="p">(</span><span class="n">distutils</span><span class="o">.</span><span class="n">sysconfig</span><span class="o">.</span><span class="n">get_python_inc</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">cc</span><span class="o">.</span><span class="n">add_library_dir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">base_exec_prefix</span><span class="p">,</span> <span class="s1">&#39;libs&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c1"># First the CLI executable</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">objs</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">compile</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">src</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">cc</span><span class="o">.</span><span class="n">link_executable</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="n">exe</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="c1"># Now the GUI executable</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">cc</span><span class="o">.</span><span class="n">define_macro</span><span class="p">(</span><span class="s1">&#39;WINDOWS&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">objs</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">compile</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">src</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">cc</span><span class="o">.</span><span class="n">link_executable</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="n">exe</span> <span class="o">+</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">compile</span><span class="p">(</span><span class="s2">&quot;zastub.c&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting launcher uses the &quot;Limited ABI&quot;, so it will run unchanged with
any version of Python 3.x.  All it needs is for Python (<code class="docutils literal notranslate"><span class="pre">python3.dll</span></code>) to be
on the user's <code class="docutils literal notranslate"><span class="pre">PATH</span></code>.</p>
<p>For a fully standalone distribution, you can distribute the launcher with your
application appended, bundled with the Python &quot;embedded&quot; distribution.  This
will run on any PC with the appropriate architecture (32 bit or 64 bit).</p>
</div>
<div class="section" id="caveats">
<h3>Caveats<a class="headerlink" href="#caveats" title="제목 주소">¶</a></h3>
<p>There are some limitations to the process of bundling your application into
a single file.  In most, if not all, cases they can be addressed without
needing major changes to your application.</p>
<ol class="arabic simple">
<li><p>If your application depends on a package that includes a C extension, that
package cannot be run from a zip file (this is an OS limitation, as executable
code must be present in the filesystem for the OS loader to load it). In this
case, you can exclude that dependency from the zipfile, and either require
your users to have it installed, or ship it alongside your zipfile and add code
to your <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> to include the directory containing the unzipped
module in <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>. In this case, you will need to make sure to ship
appropriate binaries for your target architecture(s) (and potentially pick the
correct version to add to <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> at runtime, based on the user's machine).</p></li>
<li><p>If you are shipping a Windows executable as described above, you either need to
ensure that your users have <code class="docutils literal notranslate"><span class="pre">python3.dll</span></code> on their PATH (which is not the
default behaviour of the installer) or you should bundle your application with
the embedded distribution.</p></li>
<li><p>The suggested launcher above uses the Python embedding API.  This means that in
your application, <code class="docutils literal notranslate"><span class="pre">sys.executable</span></code> will be your application, and <em>not</em> a
conventional Python interpreter.  Your code and its dependencies need to be
prepared for this possibility.  For example, if your application uses the
<a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> module, it will need to call
<a class="reference internal" href="multiprocessing.html#multiprocessing.set_executable" title="multiprocessing.set_executable"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiprocessing.set_executable()</span></code></a> to let the module know where to find the
standard Python interpreter.</p></li>
</ol>
</div>
</div>
<div class="section" id="the-python-zip-application-archive-format">
<h2>The Python Zip Application Archive Format<a class="headerlink" href="#the-python-zip-application-archive-format" title="제목 주소">¶</a></h2>
<p>Python has been able to execute zip files which contain a <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> file
since version 2.6.  In order to be executed by Python, an application archive
simply has to be a standard zip file containing a <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> file which
will be run as the entry point for the application.  As usual for any Python
script, the parent of the script (in this case the zip file) will be placed on
<a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> and thus further modules can be imported from the zip file.</p>
<p>The zip file format allows arbitrary data to be prepended to a zip file.  The
zip application format uses this ability to prepend a standard POSIX &quot;shebang&quot;
line to the file (<code class="docutils literal notranslate"><span class="pre">#!/path/to/interpreter</span></code>).</p>
<p>Formally, the Python zip application format is therefore:</p>
<ol class="arabic simple">
<li><p>An optional shebang line, containing the characters <code class="docutils literal notranslate"><span class="pre">b'#!'</span></code> followed by an
interpreter name, and then a newline (<code class="docutils literal notranslate"><span class="pre">b'\n'</span></code>) character.  The interpreter
name can be anything acceptable to the OS &quot;shebang&quot; processing, or the Python
launcher on Windows.  The interpreter should be encoded in UTF-8 on Windows,
and in <a class="reference internal" href="sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code></a> on POSIX.</p></li>
<li><p>Standard zipfile data, as generated by the <a class="reference internal" href="zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> module.  The
zipfile content <em>must</em> include a file called <code class="docutils literal notranslate"><span class="pre">__main__.py</span></code> (which must be
in the &quot;root&quot; of the zipfile - i.e., it cannot be in a subdirectory).  The
zipfile data can be compressed or uncompressed.</p></li>
</ol>
<p>If an application archive has a shebang line, it may have the executable bit set
on POSIX systems, to allow it to be executed directly.</p>
<p>There is no requirement that the tools in this module are used to create
application archives - the module is a convenience, but archives in the above
format created by any means are acceptable to Python.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipapp</span></code> --- 실행 가능한 파이썬 zip 아카이브 관리</a><ul>
<li><a class="reference internal" href="#basic-example">기본 예</a></li>
<li><a class="reference internal" href="#command-line-interface">명령 줄 인터페이스</a></li>
<li><a class="reference internal" href="#python-api">파이썬 API</a></li>
<li><a class="reference internal" href="#examples">예</a></li>
<li><a class="reference internal" href="#specifying-the-interpreter">Specifying the Interpreter</a></li>
<li><a class="reference internal" href="#creating-standalone-applications-with-zipapp">Creating Standalone Applications with zipapp</a><ul>
<li><a class="reference internal" href="#making-a-windows-executable">Making a Windows executable</a></li>
<li><a class="reference internal" href="#caveats">Caveats</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-python-zip-application-archive-format">The Python Zip Application Archive Format</a></li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="venv.html"
                        title="이전 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code> --- 가상 환경 생성</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="python.html"
                        title="다음 장">파이썬 실행시간 서비스</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="python.html" title="파이썬 실행시간 서비스"
             >다음</a> |</li>
        <li class="right" >
          <a href="venv.html" title="venv --- 가상 환경 생성"
             >이전</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">설명서 </a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="distribution.html" >소프트웨어 패키징 및 배포</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2020, Python Software Foundation.
    <br />
    한국어 번역 저작권 &copy; 2017-2020, Flowdas &amp; 역자. All rights reserved.
    </div>

  </body>
</html>